{"componentChunkName":"component---src-templates-post-page-template-index-tsx","path":"/2026/01/30/developer-intuition-readable-code-and-neuroscience/en/","result":{"data":{"markdownRemark":{"id":"73164d21-6db6-5d5a-b728-925b83a48c87","tableOfContents":"<ul>\n<li>\n<p><a href=\"#what-happens-in-the-brain-when-we-read-code\">What Happens in the Brain When We Read Code</a></p>\n</li>\n<li>\n<p><a href=\"#working-memory-4-slots\">Working Memory: 4 Slots</a></p>\n</li>\n<li>\n<p><a href=\"#chunking-the-brains-data-compression-algorithm\">Chunking: The Brain’s Data Compression Algorithm</a></p>\n</li>\n<li>\n<p><a href=\"#system-1-and-system-2-intuition-and-analysis\">System 1 and System 2: Intuition and Analysis</a></p>\n</li>\n<li>\n<p><a href=\"#gestalt-principles-how-visual-structure-affects-code-comprehension\">Gestalt Principles: How Visual Structure Affects Code Comprehension</a></p>\n<ul>\n<li><a href=\"#law-of-proximity\">Law of Proximity</a></li>\n<li><a href=\"#law-of-similarity\">Law of Similarity</a></li>\n<li><a href=\"#law-of-continuity\">Law of Continuity</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#cognitive-load-theory-three-types-of-load\">Cognitive Load Theory: Three Types of Load</a></p>\n</li>\n<li>\n<p><a href=\"#experience-physically-changes-the-brain\">Experience Physically Changes the Brain</a></p>\n</li>\n<li>\n<p><a href=\"#predictive-coding-the-brain-doesnt-read-code--it-predicts\">Predictive Coding: The Brain Doesn’t Read Code — It Predicts</a></p>\n</li>\n<li>\n<p><a href=\"#so-what-is-good-code-really\">So What Is “Good Code,” Really?</a></p>\n</li>\n<li>\n<p><a href=\"#wrapping-up\">Wrapping Up</a></p>\n</li>\n</ul>","excerpt":"I previously wrote a post called “What Is Good Code? On the Illusion of Readability” where I discussed how subjective and context-dependent the formula “good code = readable code” really is. The conclusion that people judge readability differently is fair enough. But if you trace the mechanics behind it — where that sense of “this is easy to read” actually comes from — you start to find some hints.","html":"<p>I previously wrote a post called <a href=\"/2024/12/23/the-illusion-of-a-right-answer/\">“What Is Good Code? On the Illusion of Readability”</a> where I discussed how subjective and context-dependent the formula “good code = readable code” really is.</p>\n<p>The conclusion that people judge readability differently is fair enough. But if you trace the mechanics behind it — where that sense of “this is easy to read” actually comes from — you start to find some hints.</p>\n<!-- more -->\n<p>So that’s what this post is about. How humans understand code, and what makes certain forms of information feel easier to process.</p>\n<h2 id=\"what-happens-in-the-brain-when-we-read-code\" style=\"position:relative;\">What Happens in the Brain When We Read Code<a href=\"#what-happens-in-the-brain-when-we-read-code\" aria-label=\"what happens in the brain when we read code permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>In a <a href=\"https://doi.org/10.7554/eLife.58906\" target=\"_blank\" rel=\"nofollow\">2020 fMRI study conducted at MIT</a>, researchers observed which brain regions activate when programmers read code. The results were interesting.</p>\n<p>According to the study, reading code primarily activated the Multiple Demand Network — the region responsible for logical reasoning and complex cognitive tasks — rather than the language network. The language regions weren’t completely uninvolved, but the Multiple Demand Network response was dominant.</p>\n<p>Put simply, when our brains read code, they rely more on logical reasoning than language processing.</p>\n<p>The study confirmed that five brain regions related to working memory, attention, and language processing showed pronounced activation during code comprehension. Meanwhile, Default Mode Network activity (the regions active when the brain is resting) decreased. In other words, reading code is a fairly expensive operation for the brain.</p>\n<p>So far, this might seem unsurprising. But the more interesting findings come from the differences between experts and novices. Skilled developers showed lower overall brain activation levels when reading code. Not because they were trying less, but because they were processing more efficiently. Novice developers, on the other hand, showed widespread brain activation — meaning they were consciously processing nearly everything one piece at a time.</p>\n<p>Novices tended to read code like natural language text, top to bottom. Experts followed the program’s execution flow. Same code, fundamentally different processing.</p>\n<h2 id=\"working-memory-4-slots\" style=\"position:relative;\">Working Memory: 4 Slots<a href=\"#working-memory-4-slots\" aria-label=\"working memory 4 slots permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>To understand why some code reads easily while other code refuses to organize itself in your head, you need to know about working memory.</p>\n<p>In 1956, cognitive psychologist George A. Miller published the famous paper <a href=\"https://doi.org/10.1037/h0043158\" target=\"_blank\" rel=\"nofollow\">“The Magical Number Seven, Plus or Minus Two”</a>, revealing that human short-term memory capacity is roughly 7±2 items. Subsequent research has revised this downward — according to <a href=\"https://doi.org/10.1017/s0140525x01003922\" target=\"_blank\" rel=\"nofollow\">Cowan (2001)</a> and others, the number of chunks that can be simultaneously held in working memory converges around 3–4. Though this figure can vary depending on the type of task, level of expertise, and modality of information.</p>\n<p>Think about what we load into our heads when reading code. The current value of a variable, the direction of control flow, the order of function calls, the state of the current scope — all of these occupy working memory slots. When those slots fill up, the brain struggles to take in new information. That’s the moment when you get that “this code feels complicated” sensation.</p>\n<p>To put it in programming terms, working memory is like a fixed-size stack.</p>\n<p>Real working memory is a far more complex system than a stack, but the analogy works well enough for intuiting the key property: “there’s a capacity limit, and exceeding it causes things to break down.” The stack size is roughly 4, and exceeding it causes a stack overflow. In practice, the items occupying each slot aren’t uniform in size, and interference between items also occurs, so the exact number matters less than the fact that capacity is limited. And the moment that capacity hits its limit is exactly when you feel “this code is hard to read.”</p>\n<p>Let’s compare code that rapidly exhausts working memory with code that doesn’t.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Code that rapidly exhausts all 4 working memory slots</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">processOrder</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token string\">'pending'</span> <span class=\"token operator\">&amp;&amp;</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> discount <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>customer<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span>\n      <span class=\"token operator\">?</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> sum <span class=\"token operator\">+</span> item<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span>\n      <span class=\"token operator\">:</span> order<span class=\"token punctuation\">.</span>coupon<span class=\"token operator\">?.</span>discount <span class=\"token operator\">??</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> tax <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>domestic <span class=\"token operator\">?</span> <span class=\"token number\">0.1</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> finalPrice <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount <span class=\"token operator\">+</span> tax <span class=\"token operator\">+</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>cost<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>order<span class=\"token punctuation\">,</span> finalPrice<span class=\"token punctuation\">,</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'processed'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This function isn’t wrong, but it demands too many things be held in the reader’s working memory simultaneously.</p>\n<p>The condition on <code class=\"language-text\">order.status</code>, the check on <code class=\"language-text\">order.items</code>, the discount branching by <code class=\"language-text\">customer.tier</code>, the null check on the coupon, the domestic/international tax branching, the final price calculation — trying to fit all of this context into 3–4 slots is what makes the brain scream.</p>\n<p>If we can break this context into appropriately sized units, we can save working memory slots needed to understand each operation.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Version that reduces working memory load</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateDiscount</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>customer<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> subtotal <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> sum <span class=\"token operator\">+</span> item<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> subtotal <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">.</span>coupon<span class=\"token operator\">?.</span>discount <span class=\"token operator\">??</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateTax</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> shipping<span class=\"token operator\">:</span> ShippingInfo<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> shipping<span class=\"token punctuation\">.</span>domestic <span class=\"token operator\">?</span> amount <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">processOrder</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>status <span class=\"token operator\">!==</span> <span class=\"token string\">'pending'</span> <span class=\"token operator\">||</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> discount <span class=\"token operator\">=</span> <span class=\"token function\">calculateDiscount</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> tax <span class=\"token operator\">=</span> <span class=\"token function\">calculateTax</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount<span class=\"token punctuation\">,</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> finalPrice <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount <span class=\"token operator\">+</span> tax <span class=\"token operator\">+</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>cost<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>order<span class=\"token punctuation\">,</span> finalPrice<span class=\"token punctuation\">,</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'processed'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In this version, the amount you need to hold in your head at each step is noticeably reduced. The behavior is identical, but by packaging information into consistent units, we control how much context occupies each working memory slot.</p>\n<p>When reading <code class=\"language-text\">calculateDiscount</code>, you only need to focus on discount logic. When reading <code class=\"language-text\">processOrder</code>, you can understand the overall flow without knowing each calculation’s implementation details. Each function is digestible within working memory’s capacity, which is why it feels easier to understand. This is also why proper abstraction at appropriate granularity matters in design. Of course, the reverse is also true — splitting things too finely means you spend working memory on jumping between functions and tracking context. The goal isn’t splitting for its own sake, but reducing how much you need to hold in your head at once.</p>\n<h2 id=\"chunking-the-brains-data-compression-algorithm\" style=\"position:relative;\">Chunking: The Brain’s Data Compression Algorithm<a href=\"#chunking-the-brains-data-compression-algorithm\" aria-label=\"chunking the brains data compression algorithm permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Here’s a natural question: if working memory only has about 4 slots, how on earth do we comprehend hundreds of lines of code?</p>\n<p>The answer lies in a cognitive mechanism called chunking. Chunking means grouping multiple small units of information into a single meaningful cluster. According to <a href=\"https://doi.org/10.5334/joc.451\" target=\"_blank\" rel=\"nofollow\">research from the University of Zurich</a>, chunking reduces working memory load by retrieving compressed chunk representations from long-term memory to replace individual element representations. The freed-up capacity is then used to process new incoming information.</p>\n<p>Think about phone numbers. Trying to remember <code class=\"language-text\">01012345678</code> as eleven individual digits would far exceed working memory capacity. But split it as <code class=\"language-text\">010-1234-5678</code>, and you only need to remember three chunks. Better yet, if <code class=\"language-text\">010</code> is already familiar as “Korean mobile prefix,” it’s automatically processed as a single chunk, meaning you really only need to memorize two new chunks.</p>\n<p>The same thing happens with code. Look at what happens when a skilled developer reads this:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> activeUsers <span class=\"token operator\">=</span> users<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">=></span> u<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">=></span> u<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>A novice developer has to load each individual element into working memory: the <code class=\"language-text\">users</code> variable, how <code class=\"language-text\">.filter</code> works, arrow function syntax, the <code class=\"language-text\">u.isActive</code> property access, how <code class=\"language-text\">.map</code> works, another arrow function…</p>\n<p>For a skilled developer, <code class=\"language-text\">users.filter(...).map(...)</code> is recognized as a single chunk: “filter array then transform.” Having seen this pattern hundreds or thousands of times, they pull a stored chunk from long-term memory and use just one working memory slot. The remaining slots can be allocated to higher-level thinking like “why is this being filtered?” or “where does the result get used?”</p>\n<p>This is the same principle that allows chess masters to glance at a board and grasp the entire situation. Chess masters don’t memorize individual piece positions one by one — they recognize familiar formation patterns as single chunks. That’s why they can quickly recall meaningfully arranged boards but perform no better than novices with randomly placed pieces.</p>\n<p>Code works the same way. Idiomatic code is easy to read not because it’s “correct,” but because it matches chunks already stored in the developer’s long-term memory.</p>\n<p>And what makes a pattern idiomatic is shaped by external factors: the language’s design intent, standard library conventions, and the community’s repeated choices. It’s not simply “familiar because it’s used a lot” — it’s that convergence driven by multiple forces created that familiarity. This is also why project-specific unique patterns or overly creative code are hard to read. When existing chunks don’t match, the brain has to decompose everything into individual elements for processing, and working memory saturates almost instantly.</p>\n<h2 id=\"system-1-and-system-2-intuition-and-analysis\" style=\"position:relative;\">System 1 and System 2: Intuition and Analysis<a href=\"#system-1-and-system-2-intuition-and-analysis\" aria-label=\"system 1 and system 2 intuition and analysis permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>This is where Daniel Kahneman’s dual process theory becomes relevant. Kahneman divided human thinking into two systems:</p>\n<hr>\n<ul>\n<li><strong>System 1</strong>: Fast, automatic, intuitive thinking. Based on pattern recognition.</li>\n<li><strong>System 2</strong>: Slow, conscious, analytical thinking. Based on logical reasoning.</li>\n</ul>\n<hr>\n<p>Most of our everyday judgments are handled by System 1. Driving a car, or sensing your partner’s mood from a single word over the phone — that’s all System 1. When encountering new information, System 1 doesn’t create entirely new patterns; it matches against patterns already stored.</p>\n<p>When System 1 gets stuck, that’s when System 2 gets called in. The moment you consciously think “what is this?” and begin analyzing — that’s System 2 engaging. And when you apply this framework to code reading, it explains a remarkable amount.</p>\n<p>Readable code is code that’s mostly processed by System 1’s pattern recognition, with minimal System 2 involvement.</p>\n<p>When skilled developers read code, familiar patterns are handled automatically by System 1. <code class=\"language-text\">for</code> loops, <code class=\"language-text\">if-else</code> branches, <code class=\"language-text\">map</code>/<code class=\"language-text\">filter</code>/<code class=\"language-text\">reduce</code> chaining, <code class=\"language-text\">try-catch</code> blocks — these have been seen thousands of times, so they’re processed without conscious effort. System 2 stays in a comfortable low-power mode, simply approving the information that System 1 surfaces.</p>\n<p>But when an unexpected pattern appears, things change.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Code that System 1 can handle</span>\n<span class=\"token keyword\">const</span> canPurchase <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">>=</span> <span class=\"token number\">18</span> <span class=\"token operator\">&amp;&amp;</span> user<span class=\"token punctuation\">.</span>isVerified<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Code that invokes System 2</span>\n<span class=\"token keyword\">const</span> canPurchase <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&lt;</span> <span class=\"token number\">18</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>user<span class=\"token punctuation\">.</span>isVerified<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Both express the same intent. But the moment you see the second version, System 1 sends an “I don’t know” signal, and System 2 begins its expensive analysis. You have to unwind the double negation, run De Morgan’s law in your head, and figure out why that final <code class=\"language-text\">undefined</code> check is necessary. This transition itself is a cognitive cost.</p>\n<p>Kahneman called this phenomenon cognitive strain. The more System 2 intervenes, the more energy the brain consumes and the more fatigue it experiences. The subjective feeling of “hard-to-read code” is really the cognitive cost arising from pattern matching failure triggering a system switch.</p>\n<p>From this perspective, feedback like “this is hard to understand” in code reviews isn’t just a matter of taste — it’s closer to a signal that system-switching costs are actually occurring. The magnitude of that cost varies by individual experience and chunk composition, but the fact that the cost occurs is real.</p>\n<h2 id=\"gestalt-principles-how-visual-structure-affects-code-comprehension\" style=\"position:relative;\">Gestalt Principles: How Visual Structure Affects Code Comprehension<a href=\"#gestalt-principles-how-visual-structure-affects-code-comprehension\" aria-label=\"gestalt principles how visual structure affects code comprehension permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Readable code depends not only on logical structure but on visual structure as well. This is where the perceptual principles of Gestalt psychology come in.</p>\n<p>Gestalt psychology studies how the human brain prioritizes perceiving overall patterns and structures over individual elements. Several of its core principles connect directly to code readability.</p>\n<h3 id=\"law-of-proximity\" style=\"position:relative;\">Law of Proximity<a href=\"#law-of-proximity\" aria-label=\"law of proximity permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Elements that are close together are perceived as a group. Let’s look at two versions of the same code to see why this grouping matters.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Code without proximity principle applied</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> user<span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> email <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> isValid <span class=\"token operator\">=</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'@'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> role <span class=\"token operator\">=</span> <span class=\"token function\">determineRole</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>permissions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dashboard <span class=\"token operator\">=</span> <span class=\"token function\">getDashboard</span><span class=\"token punctuation\">(</span>role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> notifications <span class=\"token operator\">=</span> <span class=\"token function\">getNotifications</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Code with proximity principle applied</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> user<span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> email <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> isValid <span class=\"token operator\">=</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'@'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> role <span class=\"token operator\">=</span> <span class=\"token function\">determineRole</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>permissions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dashboard <span class=\"token operator\">=</span> <span class=\"token function\">getDashboard</span><span class=\"token punctuation\">(</span>role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> notifications <span class=\"token operator\">=</span> <span class=\"token function\">getNotifications</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The second version just adds a single blank line, yet the brain automatically recognizes two groups: “user info processing” and “permission-based data retrieval.”</p>\n<p>According to Gestalt research, proximity is an even stronger grouping cue than similarity of color or shape. This principle is used directly in UI design — related information is placed close together and unrelated information is spaced apart, precisely for this reason.</p>\n<p>Similarly, the reason blank lines and indentation matter in code isn’t just aesthetics — it’s because the brain’s perceptual system uses them to parse structure.</p>\n<h3 id=\"law-of-similarity\" style=\"position:relative;\">Law of Similarity<a href=\"#law-of-similarity\" aria-label=\"law of similarity permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Like proximity, elements that look alike are also perceived as belonging to the same group. This explains why consistent naming matters in code.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Naming that violates similarity</span>\n<span class=\"token keyword\">const</span> userData <span class=\"token operator\">=</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> get_orders <span class=\"token operator\">=</span> <span class=\"token function\">retrieveOrderList</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> pmtHistory <span class=\"token operator\">=</span> <span class=\"token function\">loadPayments</span><span class=\"token punctuation\">(</span>uid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Naming that follows similarity</span>\n<span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> orders <span class=\"token operator\">=</span> <span class=\"token function\">fetchOrders</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> payments <span class=\"token operator\">=</span> <span class=\"token function\">fetchPayments</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In the first version, despite all three being the same kind of operation — data fetching — the naming conventions are inconsistent. <code class=\"language-text\">userData</code>, <code class=\"language-text\">get_orders</code>, <code class=\"language-text\">pmtHistory</code> each have different forms, and <code class=\"language-text\">fetchUser</code>, <code class=\"language-text\">retrieveOrderList</code>, <code class=\"language-text\">loadPayments</code> lack any consistency. The brain can’t recognize these as the same group and processes each line as a separate item, consuming working memory.</p>\n<p>In the second version, the pattern is clear. The consistent <code class=\"language-text\">fetch + resourceName</code> structure causes all three lines to be recognized as a single chunk: “data fetching in the same pattern.”</p>\n<h3 id=\"law-of-continuity\" style=\"position:relative;\">Law of Continuity<a href=\"#law-of-continuity\" aria-label=\"law of continuity permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>The law of continuity states that we perceive elements as a single continuous entity when they follow a natural flow of direction. In code, this relates to the linearity of execution flow.</p>\n<p>Our brains find top-to-bottom, left-to-right flow natural. Deep nesting, complex callbacks, and scattered <code class=\"language-text\">goto</code> statements are hard to read because they violate the law of continuity.</p>\n<p>This is also why early return patterns feel easier to read than nested <code class=\"language-text\">if</code> statements. Once edge cases are filtered out, the remaining code flows in a single direction from top to bottom.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Code that breaks continuity</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">,</span> product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>inStock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>onSale<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>salePrice<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Out of stock'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Inactive user'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Code that maintains continuity</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">,</span> product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>user<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Inactive user'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>product<span class=\"token punctuation\">.</span>inStock<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Out of stock'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>onSale<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>salePrice<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The first version forces your eyes to zigzag right and left as indentation deepens. The brain has to maintain “which condition am I currently inside” in working memory at each nesting level.</p>\n<p>The second version filters out exceptions first, then flows naturally from top to bottom. Because it aligns with the law of continuity, the cost for the brain to parse the structure drops significantly.</p>\n<h2 id=\"cognitive-load-theory-three-types-of-load\" style=\"position:relative;\">Cognitive Load Theory: Three Types of Load<a href=\"#cognitive-load-theory-three-types-of-load\" aria-label=\"cognitive load theory three types of load permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>There’s a framework that systematically organizes everything discussed so far: John Sweller’s <a href=\"https://en.wikipedia.org/wiki/Cognitive_load\" target=\"_blank\" rel=\"nofollow\">Cognitive Load Theory</a>.</p>\n<p>According to this theory, cognitive load during learning or problem-solving breaks down into three types:</p>\n<hr>\n<ol>\n<li><strong>Intrinsic load</strong>: The inherent complexity of the task itself. Algorithm difficulty, domain complexity, and so on.</li>\n<li><strong>Extraneous load</strong>: Unnecessary complexity from presentation that’s irrelevant to the task. Inconsistent naming, unnecessary indirection, confusing code structure.</li>\n<li><strong>Germane load</strong>: The beneficial load spent forming and learning new schemas.</li>\n</ol>\n<hr>\n<p>According to this theory, what we should pursue when writing readable code is minimizing extraneous load.</p>\n<p>Intrinsic load can’t be reduced — it’s inherent to the problem. Code implementing a distributed consensus algorithm will be complex no matter how well it’s written. The problem to avoid is when extraneous load from “how it’s expressed” piles unnecessarily on top of intrinsic load.</p>\n<p>From this perspective, patterns that improve readability — consistent naming, appropriate function decomposition, clear type declarations, meaningful blank lines — are all acts of reducing extraneous cognitive load. They let the brain’s limited resources avoid being wasted on extraneous load and focus on processing intrinsic load (the actual problem).</p>\n<p>A <a href=\"https://doi.org/10.1016/j.jss.2023.111619\" target=\"_blank\" rel=\"nofollow\">2023 systematic literature review</a> found something interesting as well. Among studies investigating the relationship between source code metrics and actually measured cognitive load, few traditional code metrics showed consistently high correlation with actual cognitive load, and even when correlation was found, results tended to vary depending on task conditions and measurement methods. In other words, what we “measure” as complexity and what a developer’s brain actually “feels” as complex can be different things.</p>\n<p>This is a significant finding. Mechanically measurable metrics capture a code’s surface-level complexity, but the cognitive load a developer’s brain actually experiences is influenced by subjective perception — pattern familiarity, chunking efficiency, and visual structural clarity.</p>\n<h2 id=\"experience-physically-changes-the-brain\" style=\"position:relative;\">Experience Physically Changes the Brain<a href=\"#experience-physically-changes-the-brain\" aria-label=\"experience physically changes the brain permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>I mentioned earlier that expert and novice brain activation patterns differ. This isn’t just “more experience means you get better.” A <a href=\"https://www.nature.com/articles/s41598-024-56090-6\" target=\"_blank\" rel=\"nofollow\">2024 study published in Scientific Reports</a> measured brainwaves from 62 Python programmers while observing their neural responses to intentionally inserted syntax errors and semantic errors in code.</p>\n<p>The results were striking. Skilled programmers showed distinct brainwave patterns for syntactic violations versus semantic violations. This parallels how the brain produces different brainwave responses to grammatical errors versus semantic errors when reading natural language. It means that programming experience forms neural circuits in the brain specialized for processing specific languages and patterns.</p>\n<p>In other words, coding experience physically changes the brain’s structure. Through neuroplasticity, code patterns encountered repeatedly are stored as schemas in long-term memory, and these schemas become the foundation for chunking. System 1’s ability to automatically process code is the result of accumulated schemas.</p>\n<p>Furthermore, because schemas form based on the patterns an individual has been exposed to, people who repeatedly encounter the same patterns in the same codebase end up sharing similar schemas. Flip this around, and maintaining a consistent code style within a team isn’t a matter of taste — it’s the process of forming shared chunks in team members’ brains. The reason coding conventions matter isn’t just uniformity; it’s collective cognitive efficiency.</p>\n<h2 id=\"predictive-coding-the-brain-doesnt-read-code--it-predicts\" style=\"position:relative;\">Predictive Coding: The Brain Doesn’t Read Code — It Predicts<a href=\"#predictive-coding-the-brain-doesnt-read-code--it-predicts\" aria-label=\"predictive coding the brain doesnt read code  it predicts permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>One of the theories gaining attention in recent cognitive science is predictive coding. According to this theory, the brain doesn’t passively receive information — it constantly predicts what information will come next and only performs additional processing when the actual input differs from its prediction.</p>\n<p>The same applies when reading code. Our brains constantly predict what the next line will be.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUserProfile</span><span class=\"token punctuation\">(</span>userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>userId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Your brain is already predicting what comes next</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>A skilled developer’s brain reading this code is already predicting “it’ll probably parse the response data and return it.” And when <code class=\"language-text\">return response.data;</code> actually appears, the prediction was correct, so virtually no additional cognitive cost is incurred.</p>\n<p>But what if something completely unexpected shows up?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUserProfile</span><span class=\"token punctuation\">(</span>userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>userId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    globalEventBus<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'user-fetched'</span><span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Wait, what?</span>\n    localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">setItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lastUser'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Huh?</span>\n    analytics<span class=\"token punctuation\">.</span><span class=\"token function\">track</span><span class=\"token punctuation\">(</span><span class=\"token string\">'profile_view'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> userId <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Why is logging here?</span>\n    <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>What the brain predicted from the name <code class=\"language-text\">fetchUserProfile</code> was “a function that fetches a user profile and returns it.” But then event bus emission, localStorage writes, and analytics tracking appear — actions outside the prediction. Each time, the brain generates a prediction error signal and invokes System 2 to analyze why this code is here.</p>\n<p>The reason the second version feels hard to read is that the function is named <code class=\"language-text\">fetchUserProfile</code>, but internally it does things that have nothing to do with that name. The more closely a name’s set expectation matches the actual behavior, the fewer prediction errors occur and the less cognitive cost is incurred.</p>\n<p>This applies not just within functions but to interface design as well. Let me use component interfaces familiar to frontend developers like myself as an example.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// Predictable interface</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">TextInput</span></span>\n  <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>setName<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">placeholder</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Enter your name<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// Hard-to-predict interface</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserNameInput</span></span>\n  <span class=\"token attr-name\">user</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">setUser</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>setUser<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">blank</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Enter your name<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The first component follows <code class=\"language-text\">value</code>, <code class=\"language-text\">onChange</code>, <code class=\"language-text\">placeholder</code> — an interface shared by virtually every input component in the React ecosystem. A developer’s System 1, having encountered this pattern countless times, processes it as “it’s an input component” and moves on.</p>\n<p>The second uses <code class=\"language-text\">user</code>, <code class=\"language-text\">setUser</code>, <code class=\"language-text\">blank</code> — an interface either tightly coupled to business logic or with unclear meaning. Until you figure out which fields of the <code class=\"language-text\">user</code> object it touches internally and when <code class=\"language-text\">blank</code> is actually used, you can’t use it with confidence. You have to look at the internal implementation every time, and each time, prediction errors occur.</p>\n<p>In other words, to write readable code, we need to maximize predictability at every level of the codebase — not just function names, but variable names, file structure, directory organization, and API design.</p>\n<h2 id=\"so-what-is-good-code-really\" style=\"position:relative;\">So What Is “Good Code,” Really?<a href=\"#so-what-is-good-code-really\" aria-label=\"so what is good code really permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Summarizing everything so far, the substance behind the subjective feeling of “readable code” is this:</p>\n<hr>\n<ol>\n<li><strong>Code that doesn’t exceed working memory</strong>: Context that needs to be held simultaneously stays within 3–4 items</li>\n<li><strong>Code that matches existing chunks</strong>: Uses familiar patterns so long-term memory schemas can be leveraged</li>\n<li><strong>Code processable by System 1</strong>: Understandable through pattern recognition alone, without unnecessarily invoking System 2</li>\n<li><strong>Code whose visual structure matches its logical structure</strong>: Aligns with Gestalt principles so the brain’s perceptual system automatically parses the structure</li>\n<li><strong>Predictable code</strong>: Doesn’t violate expectations set by names and structure</li>\n<li><strong>Code with low extraneous cognitive load</strong>: Removes unnecessary complexity from presentation, leaving only the problem’s inherent complexity</li>\n</ol>\n<hr>\n<p>Looking at this list, you’ll notice something interesting. None of these mean “correct code.”</p>\n<p>Readability and correctness are separate axes. Code can be perfectly correct but impossible to read, and code can be easy to read but wrong. That said, readable code also makes bugs easier to find — with lower extraneous load, the brain can focus its resources on finding logical errors.</p>\n<p>There’s one caveat, though. Kahneman also warned about System 1’s biases. System 1 is fast, but that speed comes at the cost of bias. A classic example is familiarity bias. It’s true that you feel patterns familiar to you as “readable code,” but whether that’s objectively optimal is a separate question. A developer fluent in functional programming might find <code class=\"language-text\">for</code> loops “hard to read,” and vice versa. In those cases, the feeling of “hard to read” may not reflect the code’s objective quality but the bias of chunks stored in your own System 1.</p>\n<p>When giving “this is hard to understand” feedback in code reviews, it’s worth asking yourself once: is this genuinely high-cognitive-load code, or is it simply a pattern not registered in my System 1? If the former, refactoring is needed. If the latter, it might actually be an opportunity to expand your chunk library.</p>\n<h2 id=\"wrapping-up\" style=\"position:relative;\">Wrapping Up<a href=\"#wrapping-up\" aria-label=\"wrapping up permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>“Readable code” isn’t just a matter of feeling or taste. It’s a natural outcome produced by human cognitive architecture — working memory capacity limits, chunking mechanisms, dual process systems, Gestalt perceptual principles, and predictive coding.</p>\n<p>The reason I said “readability is subjective” in my previous post comes down to exactly this. Chunking depends on individual experience, and the patterns registered in System 1 differ from person to person.</p>\n<p>When two people look at the same code and one finds it easy while the other finds it hard, it’s not just a difference in taste — it’s because the schemas accumulated in their brains are different. The very reason readability is inevitably subjective is embedded in our cognitive structure.</p>\n<p>Many developers stop their thinking at “good code is readable code.” But if readable code is the answer, then what exactly is readable code? That’s a question worth asking yourself, and exploring in depth. Stopping your thinking in a vague domain is the most dangerous thing of all.</p>","fields":{"slug":"20260130-developer-intuition-readable-code-and-neuroscience-en","path":"/2026/01/30/developer-intuition-readable-code-and-neuroscience/en/","lang":"en"},"frontmatter":{"title":"Why Do We Feel Some Code Is Easier to Read?","subTitle":"Developer Intuition, Code Readability, and Neuroscience","date":"Jan 30, 2026","categories":["Programming"],"tags":["Neuroscience","Readability","Cognitive Psychology","DX"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/018bf68e64ee3bfca73cdc09a1144553/d803c/thumbnail.png","srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/d803c/thumbnail.png 320w,\n/static/018bf68e64ee3bfca73cdc09a1144553/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/fc5c5/thumbnail.webp 320w,\n/static/018bf68e64ee3bfca73cdc09a1144553/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/018bf68e64ee3bfca73cdc09a1144553/01fb2/thumbnail.png","srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}},"allMarkdownRemark":{"edges":[{"node":{"id":"cca520f5-4ad7-5867-8d7e-204a8480f038","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EC%9D%84-%EB%95%8C-%EB%87%8C%EC%97%90%EC%84%9C%EB%8A%94-%EB%AC%B4%EC%8A%A8-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C\">코드를 읽을 때 뇌에서는 무슨 일이 일어날까</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%91%EC%97%85-%EA%B8%B0%EC%96%B5-4%EA%B0%9C%EC%9D%98-%EC%8A%AC%EB%A1%AF\">작업 기억: 4개의 슬롯</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B2%AD%ED%82%B9-%EB%87%8C%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%95%95%EC%B6%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">청킹: 뇌의 데이터 압축 알고리즘</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-1%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-2-%EC%A7%81%EA%B4%80%EA%B3%BC-%EB%B6%84%EC%84%9D\">시스템 1과 시스템 2: 직관과 분석</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%8C%EC%8A%88%ED%83%88%ED%8A%B8-%EC%9B%90%EB%A6%AC-%EC%BD%94%EB%93%9C%EC%9D%98-%EC%8B%9C%EA%B0%81%EC%A0%81-%EA%B5%AC%EC%A1%B0%EA%B0%80-%EC%9D%B4%ED%95%B4%EC%97%90-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5\">게슈탈트 원리: 코드의 시각적 구조가 이해에 미치는 영향</a></p>\n<ul>\n<li><a href=\"#%EA%B7%BC%EC%A0%91%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\">근접성의 원리</a></li>\n<li><a href=\"#%EC%9C%A0%EC%82%AC%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\">유사성의 원리</a></li>\n<li><a href=\"#%EC%97%B0%EC%86%8D%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\">연속성의 원리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B8%EC%A7%80-%EB%B6%80%ED%95%98-%EC%9D%B4%EB%A1%A0-%EC%84%B8-%EA%B0%80%EC%A7%80-%EB%B6%80%ED%95%98%EC%9D%98-%EC%A2%85%EB%A5%98\">인지 부하 이론: 세 가지 부하의 종류</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%BD%ED%97%98%EC%9D%B4-%EB%87%8C%EB%A5%BC-%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B0%94%EA%BE%BC%EB%8B%A4\">경험이 뇌를 물리적으로 바꾼다</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%98%88%EC%B8%A1-%EB%B6%80%ED%98%B8%ED%99%94-%EB%87%8C%EB%8A%94-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EB%8A%94-%EA%B2%8C-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%98%88%EC%B8%A1%ED%95%9C%EB%8B%A4\">예측 부호화: 뇌는 코드를 읽는 게 아니라 예측한다</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EA%B2%B0%EA%B5%AD\">그래서 “좋은 코드”란 결국</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n</li>\n</ul>","excerpt":"이전에 좋은 코드란 무엇일까? - 가독성이란 허상에 대하여라는 글에서, “좋은 코드 = 가독성이 좋은 코드”라는 공식이 얼마나 주관적이고 맥락 의존적인지에 대해 이야기한 적이 있다. 물론 사람마다 가독성이 좋다고 판단하는 결과는 주관적이라고 볼 수 있다. 하지만 가독성이 좋은 코드라는 것이 어떤 원리로 동작하는지, 그 감각은 대체 어디서 오는 것인지를 추적해보다보면 약간은 힌트를 얻을 수 있다.","html":"<p>이전에 <a href=\"/2024/12/23/the-illusion-of-a-right-answer/\">좋은 코드란 무엇일까? - 가독성이란 허상에 대하여</a>라는 글에서, “좋은 코드 = 가독성이 좋은 코드”라는 공식이 얼마나 주관적이고 맥락 의존적인지에 대해 이야기한 적이 있다.</p>\n<p>물론 사람마다 가독성이 좋다고 판단하는 결과는 주관적이라고 볼 수 있다. 하지만 가독성이 좋은 코드라는 것이 어떤 원리로 동작하는지, 그 감각은 대체 어디서 오는 것인지를 추적해보다보면 약간은 힌트를 얻을 수 있다.</p>\n<!-- more -->\n<p>그래서 이번 포스팅에서는 바로 그 이야기를 해보려 한다. 인간이 코드를 이해하는 방식, 그리고 어떤 형태의 정보가 이해하기 쉽다고 느끼는지에 대한 이야기이다.</p>\n<h2 id=\"코드를-읽을-때-뇌에서는-무슨-일이-일어날까\" style=\"position:relative;\">코드를 읽을 때 뇌에서는 무슨 일이 일어날까<a href=\"#%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EC%9D%84-%EB%95%8C-%EB%87%8C%EC%97%90%EC%84%9C%EB%8A%94-%EB%AC%B4%EC%8A%A8-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C\" aria-label=\"코드를 읽을 때 뇌에서는 무슨 일이 일어날까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://doi.org/10.7554/eLife.58906\" target=\"_blank\" rel=\"nofollow\">MIT에서 2020년에 진행한 기능적 MRI 연구</a>에서 프로그래머들이 코드를 읽을 때 뇌의 어떤 영역이 활성화되는지를 관찰했는데, 재밌는 결과가 나왔다.</p>\n<p>연구에 따르면 코드를 읽을 때는 언어 네트워크가 아니라 논리 추론과 복잡한 인지 작업을 담당하는 다중 수요 네트워크가 주로 활성화되었다고 한다. 언어 영역의 관여가 완전히 없었던 것은 아니지만, 다중 수요 네트워크의 반응이 지배적이었다.</p>\n<p>쉽게 말해서, 우리 뇌는 코드를 읽을 때 언어 처리보다는 논리적 추론 쪽에 더 크게 의존한다는 뜻이다.</p>\n<p>이 연구에서 확인된 것은 코드 이해 시 작업 기억, 주의 집중, 언어 처리와 관련된 다섯 개의 뇌 영역이 뚜렷하게 활성화된다는 점이다. 동시에 디폴트 모드 네트워크(뇌가 쉬고 있을 때 활성화되는 영역)의 활동은 감소했다. 즉, 코드를 읽는 건 뇌 입장에서 꽤 비싼 작업인 셈이다.</p>\n<p>여기까지는 그러려니 할 수 있겠지만, 더 흥미로운 사실은 바로 전문가와 초보자의 차이에서 나온다. 숙련된 개발자는 코드를 읽을 때 뇌의 전반적인 활성화 수준이 낮았다. 덜 열심히 한 게 아니라, 더 효율적으로 처리한 것이다. 반면 초보 개발자는 뇌의 넓은 영역이 활성화됐는데, 이는 거의 모든 것을 의식적으로 하나씩 처리하고 있다는 뜻이다.</p>\n<p>초보자는 코드를 자연어 텍스트처럼 위에서 아래로 읽는 경향이 있었고, 전문가는 프로그램의 실행 흐름을 따라 읽었다. 같은 코드를 보고 있지만, 뇌가 처리하는 방식 자체가 다른 것이다.</p>\n<h2 id=\"작업-기억-4개의-슬롯\" style=\"position:relative;\">작업 기억: 4개의 슬롯<a href=\"#%EC%9E%91%EC%97%85-%EA%B8%B0%EC%96%B5-4%EA%B0%9C%EC%9D%98-%EC%8A%AC%EB%A1%AF\" aria-label=\"작업 기억 4개의 슬롯 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>왜 어떤 코드는 쉽게 읽히는데 어떤 코드는 머릿속에서 정리가 안 되는지를 이해하려면, 작업 기억이라는 개념을 알아야 한다.</p>\n<p>1956년 인지심리학자 조지 밀러(George A. Miller)가 발표한 유명한 논문 <a href=\"https://doi.org/10.1037/h0043158\" target=\"_blank\" rel=\"nofollow\">“The Magical Number Seven, Plus or Minus Two”</a>에서, 인간의 단기 기억 용량이 약 7±2개의 항목이라는 사실이 밝혀졌다. 이후 연구에서는 이 숫자가 더 줄어들어, <a href=\"https://doi.org/10.1017/s0140525x01003922\" target=\"_blank\" rel=\"nofollow\">Cowan(2001)</a> 등의 견해에 따르면 작업 기억에 동시에 유지할 수 있는 청크는 약 3~4개 수준으로 수렴한다는 주장이 유력하다. 다만 이 수치는 과제의 종류, 숙련도, 정보의 양식에 따라 달라질 수 있다.</p>\n<p>코드를 읽을 때 우리가 머릿속에 올려놓는 것들을 떠올려보자. 변수의 현재 값, 제어 흐름의 방향, 함수 호출 순서, 현재 스코프의 상태 등 다양한 것들이 작업 기억의 슬롯을 차지한다. 그리고 이 슬롯이 꽉 차면, 뇌는 새로운 정보를 받아들이기 어려워는데, 바로 이때 “이 코드 뭔가 복잡한데”라는 느낌이 찾아오는 것이다.</p>\n<p>이걸 개발랭이들이 이해하기 쉬운 프로그래밍적인 비유로 바꿔보면, 작업 기억은 일종의 고정 크기 스택이라고 볼 수 있다.</p>\n<p>실제 작업 기억은 스택보다 훨씬 복잡한 시스템이지만, “용량에 한계가 있고 초과하면 처리가 무너진다”는 특성을 직관적으로 이해하기에는 나쁘지 않은 비유다. 스택 사이즈가 약 4인데 이걸 초과하면 스택 오버플로우가 나는 것이다. 다만 실제로는 슬롯에 담기는 항목의 크기가 균일하지 않고, 항목 간 간섭도 발생하기 때문에, 숫자 자체보다는 “용량에 한계가 있다”는 사실이 핵심이다. 그리고 이 용량이 한계에 부딪히는 순간이 바로 “이 코드 읽기 어렵다”는 감각이 발생하는 순간이다.</p>\n<p>한번 작업 기억을 빠르게 소진하는 코드와 그렇지 않은 코드를 비교해보며 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 작업 기억 슬롯 4개를 빠르게 소진하는 코드</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">processOrder</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token string\">'pending'</span> <span class=\"token operator\">&amp;&amp;</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> discount <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>customer<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span>\n      <span class=\"token operator\">?</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> sum <span class=\"token operator\">+</span> item<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span>\n      <span class=\"token operator\">:</span> order<span class=\"token punctuation\">.</span>coupon<span class=\"token operator\">?.</span>discount <span class=\"token operator\">??</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> tax <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>domestic <span class=\"token operator\">?</span> <span class=\"token number\">0.1</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> finalPrice <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount <span class=\"token operator\">+</span> tax <span class=\"token operator\">+</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>cost<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>order<span class=\"token punctuation\">,</span> finalPrice<span class=\"token punctuation\">,</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'processed'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 틀린 코드는 아니지만, 읽는 사람의 작업 기억에 동시에 올려야 할 것이 너무 많다.</p>\n<p><code class=\"language-text\">order.status</code>의 조건, <code class=\"language-text\">order.items</code>의 존재 여부, <code class=\"language-text\">customer.tier</code>에 따른 할인 분기, 쿠폰의 널 체크, 세금 계산의 국내/해외 분기, 최종 가격 산출 등 이 모든 맥락을 3~4개의 슬롯에 동시에 담으려 하니 뇌가 비명을 지르는 것이다.</p>\n<p>만약 이 맥락을 적절한 단위와 크기로 나눠줄 수 있다면, 어떤 동작을 이해하기 위해 필요한 작업 슬롯을 아낄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 작업 기억 부담을 줄인 버전</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateDiscount</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>customer<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> subtotal <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> sum <span class=\"token operator\">+</span> item<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> subtotal <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">.</span>coupon<span class=\"token operator\">?.</span>discount <span class=\"token operator\">??</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateTax</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> shipping<span class=\"token operator\">:</span> ShippingInfo<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> shipping<span class=\"token punctuation\">.</span>domestic <span class=\"token operator\">?</span> amount <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">processOrder</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>status <span class=\"token operator\">!==</span> <span class=\"token string\">'pending'</span> <span class=\"token operator\">||</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> discount <span class=\"token operator\">=</span> <span class=\"token function\">calculateDiscount</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> tax <span class=\"token operator\">=</span> <span class=\"token function\">calculateTax</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount<span class=\"token punctuation\">,</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> finalPrice <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount <span class=\"token operator\">+</span> tax <span class=\"token operator\">+</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>cost<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>order<span class=\"token punctuation\">,</span> finalPrice<span class=\"token punctuation\">,</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'processed'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 버전에서는 각 단계에서 머릿속에 올려야 할 것이 확연하게 줄어든다. 동작 자체는 동일하지만, 정보를 일정한 단위로 패키징함으로서 작업 슬롯에 들어가는 맥락을 제어해주는 것이다.</p>\n<p><code class=\"language-text\">calculateDiscount</code>를 읽을 때는 할인 로직에만 집중하면 되며, <code class=\"language-text\">processOrder</code>를 읽을 때는 각 계산의 세부 구현을 몰라도 전체 흐름을 이해할 수 있다. 각 함수가 작업 기억의 용량 안에서 소화 가능한 크기이기 때문에 이해가 쉽다고 느껴진다. 그리고 이것이 우리가 설계를 할 때 적절한 단위로 추상화를 해야하는 이유라고도 할 수 있다. 물론 반대로, 지나치게 잘게 쪼개면 함수 간 점프와 맥락 추적에 작업 기억을 소모하게 된다. 분리 자체가 목적이 아니라, 한 번에 머릿속에 올려야 할 양을 줄이는 것이 목적이다.</p>\n<h2 id=\"청킹-뇌의-데이터-압축-알고리즘\" style=\"position:relative;\">청킹: 뇌의 데이터 압축 알고리즘<a href=\"#%EC%B2%AD%ED%82%B9-%EB%87%8C%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%95%95%EC%B6%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"청킹 뇌의 데이터 압축 알고리즘 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그런데 여기서 한 가지 의문이 생긴다. 작업 기억의 슬롯이 겨우 4개라면, 우리는 대체 어떻게 수백 줄의 코드를 이해할 수 있는 걸까?</p>\n<p>답은 청킹이라는 인지 메커니즘에 있다. 청킹이란 여러 개의 작은 정보 단위를 하나의 의미 있는 덩어리로 묶어서 처리하는 것을 말한다. <a href=\"https://doi.org/10.5334/joc.451\" target=\"_blank\" rel=\"nofollow\">취리히 대학교의 연구</a>에 따르면, 청킹은 장기 기억에서 압축된 청크 표상을 불러와 개별 요소의 표상을 대체함으로써 작업 기억의 부하를 줄인다. 이로 인해 확보된 용량은 이후에 입력되는 새로운 정보를 처리하는 데 사용된다.</p>\n<p>전화번호를 생각해보자. <code class=\"language-text\">01012345678</code>이라는 11자리 숫자를 한 자리씩 기억하려면 작업 기억의 용량을 한참 초과한다. 그런데 <code class=\"language-text\">010-1234-5678</code>로 나누면 세 덩어리만 기억하면 된다. 더 나아가, 이미 익숙한 <code class=\"language-text\">010</code>은 “한국 휴대폰 번호 앞자리”라는 하나의 청크로 자동 처리되니, 실질적으로 두 덩어리만 새로 기억하면 되는 것이다.</p>\n<p>코드에서도 같은 일이 일어난다. 숙련된 개발자가 아래 코드를 볼 때 일어나는 일을 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> activeUsers <span class=\"token operator\">=</span> users<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">=></span> u<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">=></span> u<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>초보 개발자는 이걸 읽을 때 <code class=\"language-text\">users</code>라는 변수, <code class=\"language-text\">.filter</code> 메서드의 동작, 화살표 함수의 문법, <code class=\"language-text\">u.isActive</code>라는 속성 접근, <code class=\"language-text\">.map</code> 메서드의 동작, 또 다른 화살표 함수… 이런 개별 요소들을 하나씩 작업 기억에 올려야 한다.</p>\n<p>반면 숙련된 개발자에게 <code class=\"language-text\">users.filter(...).map(...)</code>은 “배열 필터링 후 변환”이라는 하나의 청크로 인식된다. 이 패턴을 수백, 수천 번 봤기 때문에, 장기 기억에 저장된 청크를 꺼내와서 작업 기억의 슬롯을 하나만 쓰는 것이다. 나머지 슬롯은 “왜 필터링하는가”, “결과가 어디에 쓰이는가” 같은 더 상위 수준의 사고에 할당할 수 있다.</p>\n<p>이것이 바로 체스 마스터가 체스판을 한 번 보고 전체 상황을 파악할 수 있는 원리와 같다. 체스 마스터는 개별 말의 위치를 하나씩 기억하는 게 아니라, 익숙한 포진 패턴을 하나의 청크로 인식한다. 그래서 의미 있는 배치의 체스판은 빠르게 기억하지만, 말을 무작위로 배치하면 초보자와 별 차이가 없다.</p>\n<p>코드도 마찬가지다. 관용적인 코드가 읽기 쉬운 이유는 그게 “올바른” 코드여서가 아니라, 개발자의 장기 기억에 이미 저장된 청크와 일치하기 때문이다.</p>\n<p>그리고 특정 패턴이 관용적이 되는 데는 언어의 설계 의도, 표준 라이브러리의 관례, 커뮤니티의 반복적 선택 같은 외부 요인이 작용한다. 단순히 “많이 써서 익숙한 것”이 아니라, 여러 이유로 수렴한 결과가 익숙함을 만든 것이다. 프로젝트만의 독특한 패턴이나 지나치게 창의적인 코드가 읽기 어려운 이유도 여기에 있다. 기존 청크와 매칭되지 않으면, 뇌는 모든 것을 개별 요소로 분해해서 처리해야 하고, 작업 기억은 순식간에 포화된다.</p>\n<h2 id=\"시스템-1과-시스템-2-직관과-분석\" style=\"position:relative;\">시스템 1과 시스템 2: 직관과 분석<a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-1%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-2-%EC%A7%81%EA%B4%80%EA%B3%BC-%EB%B6%84%EC%84%9D\" aria-label=\"시스템 1과 시스템 2 직관과 분석 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여기서 다니엘 카너먼(Daniel Kahneman)의 이중 처리 이론을 꺼내야 한다. 카너먼은 인간의 사고를 두 가지 시스템으로 나눴다.</p>\n<hr>\n<ul>\n<li><strong>시스템 1</strong>: 빠르고, 자동적이고, 직관적인 사고. 패턴 인식에 기반한다.</li>\n<li><strong>시스템 2</strong>: 느리고, 의식적이고, 분석적인 사고. 논리적 추론에 기반한다.</li>\n</ul>\n<hr>\n<p>우리가 일상적으로 하는 판단 대부분은 시스템 1이 담당한다. 운전을 하거나, 전화기 너머 여친의 기분을 한마디에 알아채는 것도 시스템 1의 영역이다. 시스템 1은 새로운 정보를 접했을 때, 완전히 새로운 패턴을 만들어내는 게 아니라 기존에 저장된 패턴과 대조하는 방식으로 작동한다.</p>\n<p>시스템 1이 막히면 그때서야 시스템 2가 호출된다. “이게 뭐지?” 하고 의식적으로 분석을 시작하는 순간이 바로 시스템 2가 개입하는 시점이다. 그리고 이 프레임워크를 코드 읽기에 적용하면 정말 많은 것이 설명된다.</p>\n<p>읽기 쉬운 코드란, 대부분 시스템 1의 패턴 인식으로 처리되고 시스템 2의 개입이 최소화되는 코드다.</p>\n<p>숙련된 개발자가 코드를 읽을 때, 익숙한 패턴은 시스템 1이 자동으로 처리한다. <code class=\"language-text\">for</code> 루프, <code class=\"language-text\">if-else</code> 분기, <code class=\"language-text\">map</code>/<code class=\"language-text\">filter</code>/<code class=\"language-text\">reduce</code> 체이닝, <code class=\"language-text\">try-catch</code> 블록 등 이런 것들은 수천 번 봐온 패턴이기 때문에 의식적 노력 없이 처리된다. 시스템 2는 편안한 저전력 모드에 머물면서, 시스템 1이 올려주는 정보를 승인하기만 하면 된다.</p>\n<p>그런데 갑자기 예상치 못한 패턴이 나타나면 상황이 달라진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 시스템 1이 처리 가능한 코드</span>\n<span class=\"token keyword\">const</span> canPurchase <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">>=</span> <span class=\"token number\">18</span> <span class=\"token operator\">&amp;&amp;</span> user<span class=\"token punctuation\">.</span>isVerified<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 시스템 2를 호출하는 코드</span>\n<span class=\"token keyword\">const</span> canPurchase <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&lt;</span> <span class=\"token number\">18</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>user<span class=\"token punctuation\">.</span>isVerified<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 코드는 같은 의도를 표현한다. 하지만 두 번째 코드를 보는 순간 뇌에서는 시스템 1이 “모르겠다”는 신호를 보내고, 시스템 2가 비싼 비용을 들여 분석을 시작한다. 이중 부정을 풀고, 드모르간 법칙을 머릿속에서 돌리고, 마지막 <code class=\"language-text\">undefined</code> 체크가 왜 필요한지를 따져봐야 한다. 이러한 전환 자체가 인지적 비용이다.</p>\n<p>카너먼은 이런 현상을 인지적 긴장이라 불렀다. 시스템 2가 개입할수록 뇌는 더 많은 에너지를 소비하고 피로감을 느끼게 된다. “읽기 어려운 코드”라는 주관적 느낌의 실체는 바로 패턴 매칭 실패로 인한 시스템 전환, 그리고 그에 따르는 인지적 비용이 발생하는 것이다.</p>\n<p>이 관점에서 보면, 코드 리뷰에서 “이해하기 어렵다”는 피드백은 단순한 취향 불만이 아니라, 인지 시스템의 전환 비용이 실제로 발생하고 있다는 신호에 가깝다. 그 비용의 크기는 개인의 경험과 청크 구성에 따라 다르겠지만, 비용이 발생한다는 사실 자체는 실재한다.</p>\n<h2 id=\"게슈탈트-원리-코드의-시각적-구조가-이해에-미치는-영향\" style=\"position:relative;\">게슈탈트 원리: 코드의 시각적 구조가 이해에 미치는 영향<a href=\"#%EA%B2%8C%EC%8A%88%ED%83%88%ED%8A%B8-%EC%9B%90%EB%A6%AC-%EC%BD%94%EB%93%9C%EC%9D%98-%EC%8B%9C%EA%B0%81%EC%A0%81-%EA%B5%AC%EC%A1%B0%EA%B0%80-%EC%9D%B4%ED%95%B4%EC%97%90-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5\" aria-label=\"게슈탈트 원리 코드의 시각적 구조가 이해에 미치는 영향 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>읽기 쉬운 코드에는 논리적 구조뿐만 아니라 시각적 구조도 중요하다. 여기서 게슈탈트 심리학의 지각 원리가 등장한다.</p>\n<p>게슈탈트 심리학은 인간의 뇌가 개별 요소가 아닌 전체 패턴과 구조를 우선적으로 인식한다는 점을 연구하는 분야다. 그 핵심 원리 몇 가지는 코드 가독성에 직접적으로 연결된다.</p>\n<h3 id=\"근접성의-원리\" style=\"position:relative;\">근접성의 원리<a href=\"#%EA%B7%BC%EC%A0%91%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"근접성의 원리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>가까이 있는 요소들은 하나의 그룹으로 인식된다. 한번 두 가지 버전의 코드를 살펴보며 이 그룹이 왜 중요한지를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 근접성 원리가 적용되지 않은 코드</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> user<span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> email <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> isValid <span class=\"token operator\">=</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'@'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> role <span class=\"token operator\">=</span> <span class=\"token function\">determineRole</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>permissions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dashboard <span class=\"token operator\">=</span> <span class=\"token function\">getDashboard</span><span class=\"token punctuation\">(</span>role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> notifications <span class=\"token operator\">=</span> <span class=\"token function\">getNotifications</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 근접성 원리가 적용된 코드</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> user<span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> email <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> isValid <span class=\"token operator\">=</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'@'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> role <span class=\"token operator\">=</span> <span class=\"token function\">determineRole</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>permissions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dashboard <span class=\"token operator\">=</span> <span class=\"token function\">getDashboard</span><span class=\"token punctuation\">(</span>role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> notifications <span class=\"token operator\">=</span> <span class=\"token function\">getNotifications</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 번째 버전에서 빈 줄 하나가 추가됐을 뿐인데 뇌는 자동으로 “사용자 정보 처리”와 “권한 기반 데이터 조회”라는 두 그룹을 인식한다.</p>\n<p>게슈탈트 연구에 따르면 근접성은 색상이나 형태의 유사성보다도 더 강력한 그룹핑 단서다. 이 원리는 UI 디자인에서도 그대로 사용되는데, 서로 연관이 있는 정보는 가까이 붙이고 연관이 없는 정보는 간격을 늘려 멀리 떨어트려놓는 것이 이 때문이다.</p>\n<p>마찬가지로 코드에서 빈 줄과 들여쓰기가 중요한 이유는 단순히 미관 때문이 아니라, 뇌의 지각 시스템이 그걸 기반으로 구조를 파악하기 때문이다.</p>\n<h3 id=\"유사성의-원리\" style=\"position:relative;\">유사성의 원리<a href=\"#%EC%9C%A0%EC%82%AC%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"유사성의 원리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>근접성과 마찬가지로 비슷하게 생긴 요소들도 같은 그룹으로 인식된다. 이것을 유사성의 원리라고 하는데, 이 원리는 코드에서 일관된 네이밍이 왜 중요한지를 설명한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 유사성 원리가 깨진 네이밍</span>\n<span class=\"token keyword\">const</span> userData <span class=\"token operator\">=</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> get_orders <span class=\"token operator\">=</span> <span class=\"token function\">retrieveOrderList</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> pmtHistory <span class=\"token operator\">=</span> <span class=\"token function\">loadPayments</span><span class=\"token punctuation\">(</span>uid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 유사성 원리가 적용된 네이밍</span>\n<span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> orders <span class=\"token operator\">=</span> <span class=\"token function\">fetchOrders</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> payments <span class=\"token operator\">=</span> <span class=\"token function\">fetchPayments</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 버전에서는 데이터 페칭이라는 같은 종류의 작업임에도 네이밍 규칙이 제각각이다. <code class=\"language-text\">userData</code>, <code class=\"language-text\">get_orders</code>, <code class=\"language-text\">pmtHistory</code>라는 변수명은 각각 다른 형태를 가지고, <code class=\"language-text\">fetchUser</code>, <code class=\"language-text\">retrieveOrderList</code>, <code class=\"language-text\">loadPayments</code>라는 함수명도 일관성이 없다. 뇌는 이런 코드를 보면 이들을 같은 그룹으로 인식하지 못하고 각 라인을 개별 항목으로 처리하면서 작업 기억을 소진한다.</p>\n<p>두 번째 버전에서는 패턴이 명확하다. <code class=\"language-text\">fetch + 리소스명</code>이라는 일관된 구조 덕분에, 세 줄이 “동일한 패턴의 데이터 패칭”이라는 하나의 청크로 인식된다.</p>\n<h3 id=\"연속성의-원리\" style=\"position:relative;\">연속성의 원리<a href=\"#%EC%97%B0%EC%86%8D%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"연속성의 원리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>연속성의 원리는 시선이 자연스럽게 흐르는 방향을 따라 요소들을 하나의 연속된 것으로 인식하는 원리다. 코드에서 이건 실행 흐름의 선형성과 관련된다.</p>\n<p>우리 뇌는 위에서 아래로, 왼쪽에서 오른쪽으로 흐르는 것을 자연스럽게 느낀다. 깊은 중첩, 복잡한 콜백, 여기저기 점프하는 <code class=\"language-text\">goto</code>문 등이 읽기 어려운 이유는 연속성의 원리를 위반하기 때문이다.</p>\n<p>우리가 얼리 리턴 패턴을 사용했을 때, 중첩된 <code class=\"language-text\">if</code>문보다 읽기 쉬운 이유도 마찬가지다. 예외 케이스를 먼저 걸러내고 나면 남은 코드는 위에서 아래로 한 방향으로 흐른다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 연속성이 깨지는 코드</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">,</span> product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>inStock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>onSale<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>salePrice<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Out of stock'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Inactive user'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 연속성이 유지되는 코드</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">,</span> product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>user<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Inactive user'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>product<span class=\"token punctuation\">.</span>inStock<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Out of stock'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>onSale<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>salePrice<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 버전은 들여쓰기가 깊어지면서 시선이 오른쪽으로, 다시 왼쪽으로 지그재그를 그린다. 뇌는 각 중첩 수준에서 “지금 어느 조건 안에 있는가”를 작업 기억에 유지해야 한다.</p>\n<p>반면 두 번째 버전은 예외를 먼저 걸러낸 뒤 위에서 아래로 자연스럽게 흘러내린다. 연속성의 원리에 부합하기 때문에 뇌가 구조를 파악하는 데 드는 비용이 크게 줄어든다.</p>\n<h2 id=\"인지-부하-이론-세-가지-부하의-종류\" style=\"position:relative;\">인지 부하 이론: 세 가지 부하의 종류<a href=\"#%EC%9D%B8%EC%A7%80-%EB%B6%80%ED%95%98-%EC%9D%B4%EB%A1%A0-%EC%84%B8-%EA%B0%80%EC%A7%80-%EB%B6%80%ED%95%98%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"인지 부하 이론 세 가지 부하의 종류 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여기까지의 이야기를 좀 더 체계적으로 정리해주는 프레임워크가 있다. 존 스웰러(John Sweller)의 <a href=\"https://ko.wikipedia.org/wiki/%EC%9D%B8%EC%A7%80_%EB%B6%80%ED%95%98\" target=\"_blank\" rel=\"nofollow\">인지 부하 이론</a>이다.</p>\n<p>이 이론에 따르면 학습이나 문제 해결 시 발생하는 인지 부하는 세 가지로 나뉜다.</p>\n<hr>\n<ol>\n<li><strong>내재적 부하</strong>: 과제 자체의 본질적 복잡성. 알고리즘의 난이도, 도메인의 복잡성 같은 것.</li>\n<li><strong>외재적 부하</strong>: 과제와 무관한, 표현 방식에서 오는 불필요한 복잡성. 일관되지 않은 네이밍, 불필요한 간접 참조, 혼란스러운 코드 구조 같은 것.</li>\n<li><strong>본유적 부하</strong>: 새로운 스키마를 형성하고 학습하는 데 드는 유익한 부하.</li>\n</ol>\n<hr>\n<p>이 이론에 따르면 우리가 읽기 쉬운 코드를 작성하기 위해 추구해야하는 것은 외재적 부하를 최소화하는 것이다.</p>\n<p>어차피 내재적 부하는 문제 자체에 내재된 것이니 줄일 수 없다. 예를 들어 분산 시스템의 합의 알고리즘을 구현하는 코드는 아무리 잘 써도 복잡할 수밖에 없는 것이다. 우리가 피해야할 문제는 “표현 방식”에서 오는 외재적 부하가 내재적 부하 위에 불필요하게 쌓일 때다.</p>\n<p>이 관점으로 보면 코드 가독성을 높이는 일관된 네이밍, 적절한 함수 분리, 명확한 타입 선언, 의미 있는 빈 줄과 같은 패턴은 결국 외재적 인지 부하를 줄이는 행위다. 뇌의 제한된 자원을 외재적 부하에 낭비하지 않고, 내재적 부하(실제 문제)를 처리하는 데 집중할 수 있게 해주는 것이다.</p>\n<p><a href=\"https://doi.org/10.1016/j.jss.2023.111619\" target=\"_blank\" rel=\"nofollow\">2023년에 발표된 체계적 문헌 리뷰</a>에서도 흥미로운 사실이 확인됐다. 소스 코드 메트릭과 실제 측정된 인지 부하 사이의 관계를 조사한 연구들에서 전통적 코드 메트릭 중 실제 인지 부하와 일관되게 높은 상관을 보인 것은 드물었고, 상관이 확인된 경우에도 과제 조건이나 측정 방식에 따라 결과가 달라지는 경향이 있었다. 즉, 우리가 “복잡도”라고 측정하는 것과 개발자의 뇌가 실제로 “복잡하다”고 느끼는 것은 다를 수 있다는 뜻이다.</p>\n<p>이건 의미심장한 결과다. 기계적으로 측정 가능한 메트릭은 코드의 외형적 복잡도를 포착하지만, 개발자의 뇌가 실제로 겪는 인지 부하는 패턴의 익숙함, 청킹의 효율성, 시각적 구조의 명확성과 같이 주관적 인식에 영향을 받는다는 것이다.</p>\n<h2 id=\"경험이-뇌를-물리적으로-바꾼다\" style=\"position:relative;\">경험이 뇌를 물리적으로 바꾼다<a href=\"#%EA%B2%BD%ED%97%98%EC%9D%B4-%EB%87%8C%EB%A5%BC-%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B0%94%EA%BE%BC%EB%8B%A4\" aria-label=\"경험이 뇌를 물리적으로 바꾼다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 전문가와 초보자의 뇌 활성화 패턴이 다르다고 했다. 이건 단순히 개발 짬바가 쌓이면 더 잘한다는 이야기가 아니다. <a href=\"https://www.nature.com/articles/s41598-024-56090-6\" target=\"_blank\" rel=\"nofollow\">2024년 Scientific Reports에 발표된 연구</a>에서는 62명의 파이썬 프로그래머를 대상으로 뇌파를 측정하며, 코드에 의도적으로 삽입한 문법 오류와 의미 오류에 대한 뇌의 반응을 관찰했다.</p>\n<p>결과는 놀라웠다. 숙련된 프로그래머는 코드의 문법적 위반과 의미적 위반에 대해 서로 다른 뇌파 패턴을 보였다. 이는 자연어를 읽을 때 문법 오류와 의미 오류에 대해 다른 뇌파가 나타나는 것과 유사한 패턴이다. 프로그래밍 경험이 뇌에 특정 언어와 패턴을 처리하기 위한 신경 회로를 형성한다는 뜻이다.</p>\n<p>다시 말해, 코딩 경험은 뇌의 물리적 구조를 변화시킨다. 신경가소성에 의해, 반복적으로 노출된 코드 패턴은 장기 기억에 스키마로 저장되고, 이 스키마가 청킹의 기반이 된다. 시스템 1이 코드를 자동으로 처리할 수 있는 것은 이런 스키마가 축적된 결과다.</p>\n<p>또한 스키마는 개인이 노출된 패턴에 따라 형성되기 때문에 같은 코드베이스에서 같은 패턴을 반복적으로 접한 사람들은 비슷한 스키마를 공유하게 된다. 이걸 뒤집어 생각하면 팀에서 일관된 코드 스타일을 유지하는 것은 취향의 문제가 아니라 팀원들의 뇌에 공유된 청크를 형성하는 과정인 셈이다. 코딩 컨벤션이 중요한 이유가 단순히 통일성이 아니라, 집단적 인지 효율성 때문인 것이다.</p>\n<h2 id=\"예측-부호화-뇌는-코드를-읽는-게-아니라-예측한다\" style=\"position:relative;\">예측 부호화: 뇌는 코드를 읽는 게 아니라 예측한다<a href=\"#%EC%98%88%EC%B8%A1-%EB%B6%80%ED%98%B8%ED%99%94-%EB%87%8C%EB%8A%94-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EB%8A%94-%EA%B2%8C-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%98%88%EC%B8%A1%ED%95%9C%EB%8B%A4\" aria-label=\"예측 부호화 뇌는 코드를 읽는 게 아니라 예측한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>최근 인지과학에서 주목받는 이론 중 하나는 예측 부호화다. 이 이론에 따르면, 뇌는 수동적으로 정보를 수신하는 게 아니라, 끊임없이 다음에 올 정보를 예측하고, 실제 입력이 그 예측과 다를 때만 추가적인 처리를 한다.</p>\n<p>코드를 읽을 때도 마찬가지다. 우리 뇌는 다음 줄에 뭐가 올지 끊임없이 예측한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUserProfile</span><span class=\"token punctuation\">(</span>userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>userId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 여기에 뭐가 올지, 이미 예측하고 있다</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 코드를 읽는 숙련된 개발자의 뇌는 이미 “뭐 이제 응답 데이터를 파싱해서 리턴하겠지”라고 예측하고 있다. 그리고 실제로 <code class=\"language-text\">return response.data;</code> 같은 코드가 나오면 그 예측이 맞았으므로 추가적인 인지 비용이 거의 발생하지 않는다.</p>\n<p>하지만 만약 예측과 전혀 다른 쌩뚱맞은 코드가 나오면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUserProfile</span><span class=\"token punctuation\">(</span>userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>userId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    globalEventBus<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'user-fetched'</span><span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 엥 이거 뭐임?</span>\n    localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">setItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lastUser'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 어라?</span>\n    analytics<span class=\"token punctuation\">.</span><span class=\"token function\">track</span><span class=\"token punctuation\">(</span><span class=\"token string\">'profile_view'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> userId <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 아 로깅을 왜 여기서 해</span>\n    <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">fetchUserProfile</code>이라는 이름에서 뇌가 예측한 것은 “사용자 프로필을 가져와서 돌려주는 함수”다. 그런데 이벤트 버스 발행, 로컬 스토리지 저장, 애널리틱스 추적이라는 예측 밖의 동작이 나타난다. 이때마다 뇌는 예측 오류 신호를 발생시키고, 시스템 2를 호출해서 이 코드가 왜 여기에 있는지를 분석하기 시작한다.</p>\n<p>즉, 우리가 두 번째 버전의 코드를 읽기 어렵다고 느끼는 이유는 함수의 이름은 <code class=\"language-text\">fetchUserProfile</code>이지만, 내부에서는 그와 전혀 상관없는 동작들이 발생하고 있기 대문이다. 이름이 설정한 예측과 실제 동작이 일치할수록 예측 오류가 줄어들고 인지 비용이 절감된다.</p>\n<p>이건 함수 내부뿐 아니라 인터페이스 설계에서도 마찬가지다. 필자와 같은 프론트엔드 개발자에게 익숙한 컴포넌트 인터페이스를 예시로 들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 예측 가능한 인터페이스</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">TextInput</span></span>\n  <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>setName<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">placeholder</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>이름을 입력하세요<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 예측이 어려운 인터페이스</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserNameInput</span></span>\n  <span class=\"token attr-name\">user</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">setUser</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>setUser<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">blank</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>이름을 입력하세요<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 컴포넌트는 <code class=\"language-text\">value</code>, <code class=\"language-text\">onChange</code>, <code class=\"language-text\">defaultValue</code>라는 React 생태계에서 거의 모든 입력 컴포넌트가 공유하는 인터페이스를 따른다. 이 패턴을 수없이 접해온 개발자의 시스템 1은 “입력 컴포넌트구나”로 처리하고 넘어간다.</p>\n<p>반면 두 번째는 <code class=\"language-text\">user</code>, <code class=\"language-text\">setUser</code>, <code class=\"language-text\">blank</code>라는 비즈니스 로직에 강하게 결합되었거나 의미를 알기 어려운 인터페이스를 가지고 있다. 이 컴포넌트가 내부에서 <code class=\"language-text\">user</code> 객체의 어떤 필드를 건드리는지, <code class=\"language-text\">blank</code>는 도대체 언제 사용되는 것인지 파악하기 전까지는 안심하고 사용할 수가 없다. 매번 내부 구현을 들여다봐야 하고, 그때마다 예측 오류가 발생한다.</p>\n<p>즉 읽기 쉬운 코드를 작성하기 위해서 우리는 함수의 이름 뿐 아니라 변수명, 파일 구조, 디렉토리 구성, API 설계 등 코드베이스의 모든 수준에서 예측 가능성을 높여야한다.</p>\n<h2 id=\"그래서-좋은-코드란-결국\" style=\"position:relative;\">그래서 “좋은 코드”란 결국<a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EA%B2%B0%EA%B5%AD\" aria-label=\"그래서 좋은 코드란 결국 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지의 내용을 정리해보면, “읽기 쉬운 코드”라는 주관적 느낌의 실체는 다음과 같다.</p>\n<hr>\n<ol>\n<li><strong>작업 기억을 초과하지 않는 코드</strong>: 동시에 머릿속에 담아야 할 맥락이 3~4개 이내인 코드</li>\n<li><strong>기존 청크와 매칭되는 코드</strong>: 익숙한 패턴을 사용해서 장기 기억의 스키마를 활용할 수 있는 코드</li>\n<li><strong>시스템 1에서 처리 가능한 코드</strong>: 시스템 2를 불필요하게 호출하지 않는, 패턴 인식만으로 이해 가능한 코드</li>\n<li><strong>시각적 구조가 논리적 구조와 일치하는 코드</strong>: 게슈탈트 원리에 부합하여 뇌의 지각 시스템이 구조를 자동으로 파악하는 코드</li>\n<li><strong>예측 가능한 코드</strong>: 이름과 구조에서 설정한 기대를 위반하지 않는 코드</li>\n<li><strong>외재적 인지 부하가 낮은 코드</strong>: 문제 자체의 복잡성만 남기고, 표현에서 오는 불필요한 복잡성을 제거한 코드</li>\n</ol>\n<hr>\n<p>이 목록을 보면 재밌는 사실을 하나 발견할 수 있다. 이 중 어느 것도 “정확한 코드”를 의미하지 않는다는 점이다.</p>\n<p>가독성과 정확성은 별개의 축이다. 완벽하게 정확하지만 읽기 불가능한 코드도 있고, 읽기는 쉽지만 틀린 코드도 있다. 다만 읽기 쉬운 코드는 버그를 발견하기도 쉽다. 외재적 부하가 낮으니, 뇌의 자원을 논리적 오류를 찾는 데 집중할 수 있기 때문이다.</p>\n<p>다만 한 가지 주의할 점이 있다. 카너먼은 시스템 1의 편향에 대해서도 경고했다. 시스템 1은 빠르지만, 그 속도의 대가로 편향이 존재한다. 대표적인 것이 익숙함 편향이다. 자신에게 익숙한 패턴을 “읽기 쉬운 코드”로 느끼는 것은 사실이지만, 그것이 객관적으로 최선인지는 별개의 문제다. 함수형 프로그래밍에 익숙한 개발자는 <code class=\"language-text\">for</code> 루프를 “읽기 어렵다”고 느낄 수 있고, 반대의 경우도 마찬가지다. 이때 “읽기 어렵다”는 느낌은 코드의 객관적 품질이 아니라, 자신의 시스템 1에 저장된 청크의 편향을 반영하는 것일 수 있다.</p>\n<p>코드 리뷰에서 “이해하기 어렵다”는 피드백을 줄 때, 한 번쯤 자문해볼 가치가 있다. 이게 정말로 인지 부하가 높은 코드인가, 아니면 단순히 내 시스템 1에 등록되지 않은 패턴인가? 전자라면 리팩토링이 필요하고, 후자라면 오히려 내 청크 라이브러리를 확장할 기회다.</p>\n<h2 id=\"마무리\" style=\"position:relative;\">마무리<a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>“읽기 쉬운 코드”는 그냥 느낌이나 취향의 문제가 아니다. 작업 기억의 용량 제한, 청킹 메커니즘, 이중 처리 시스템, 게슈탈트 지각 원리, 예측 부호화와 같은 인간의 인지 구조가 만들어내는 자연스러운 결과다.</p>\n<p>필자가 이전 글에서 “가독성은 주관적이다”라고 했던 이야기의 이유도 바로 여기에 있다. 청킹은 개인의 경험에 의존하고 시스템 1에 등록된 패턴은 사람마다 다르기 때문이다.</p>\n<p>같은 코드를 보고 누군가는 쉽다고 느끼고 누군가는 어렵다고 느끼는 건 그저 취향이 달라서가 아니라 뇌에 축적된 스키마가 다르기 때문이다. 가독성이 주관적일 수밖에 없는 이유 자체가 인지 구조에 내재되어 있는 셈이다.</p>\n<p>이상으로 우리는 왜 어떤 코드를 읽기 쉽다고 느낄까 포스팅을 마친다.</p>","fields":{"slug":"20260130-developer-intuition-readable-code-and-neuroscience","path":"/2026/01/30/developer-intuition-readable-code-and-neuroscience/","lang":"ko"},"frontmatter":{"title":"우리는 왜 어떤 코드를 읽기 쉽다고 느낄까","subTitle":"개발자의 직관과 코드 가독성, 그리고 뇌과학","date":"Jan 30, 2026","categories":["프로그래밍"],"tags":["뇌과학","가독성","인지심리학","DX"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/018bf68e64ee3bfca73cdc09a1144553/d803c/thumbnail.png","srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/d803c/thumbnail.png 320w,\n/static/018bf68e64ee3bfca73cdc09a1144553/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/fc5c5/thumbnail.webp 320w,\n/static/018bf68e64ee3bfca73cdc09a1144553/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/018bf68e64ee3bfca73cdc09a1144553/01fb2/thumbnail.png","srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"slug":"20260130-developer-intuition-readable-code-and-neuroscience-en","previous":{"fields":{"slug":"20260125-types-as-proofs-typescript-hidden-math-en","path":"/2026/01/25/types-as-proofs-typescript-hidden-math/en/","lang":"en","postGroup":"20260125-types-as-proofs-typescript-hidden-math"},"frontmatter":{"title":"Why Do Type Systems Behave Like Proofs?"}},"next":null,"lang":"en","postGroup":"20260130-developer-intuition-readable-code-and-neuroscience"}},"staticQueryHashes":["3129619726","3523904809","376081736","650499039"],"slicesMap":{}}