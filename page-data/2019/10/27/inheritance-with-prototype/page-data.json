{"componentChunkName":"component---src-templates-post-tsx","path":"/2019/10/27/inheritance-with-prototype/","result":{"data":{"markdownRemark":{"id":"4415efaf-d77a-55de-9651-977abc6dcb11","excerpt":"이번 포스팅에서는 이전 포스팅에 이어, 프로토타입을 사용한 다양한 상속 패턴에 대한 이야기를 해볼까 한다. 사실 자바스크립트에는 상속이나 캡슐화와 같은 개념이 명시적으로 존재하지는 않기 때문에 자바나 C++ 같은 클래스 기반 언어를 사용하던 개발자들은 자바스크립트에 클래스가 없다는 사실에 혼란스러워한다.","html":"<p>이번 포스팅에서는 <a href=\"/2019/10/23/js-prototype/\">이전 포스팅</a>에 이어, 프로토타입을 사용한 다양한 상속 패턴에 대한 이야기를 해볼까 한다.</p>\n<p>사실 자바스크립트에는 상속이나 캡슐화와 같은 개념이 명시적으로 존재하지는 않기 때문에 자바나 C++ 같은 클래스 기반 언어를 사용하던 개발자들은 자바스크립트에 클래스가 없다는 사실에 혼란스러워한다.</p>\n<!-- more -->\n<p>즉, 자바스크립트에서의 상속이나 캡슐화 등은 <code class=\"language-text\">OOP(객체지향프로그래밍)</code>에 익숙한 개발자들이 자바스크립트에서도 이런 개념들을 가져다 사용하기 위해 프토토타입을 사용하여 이를 유사하게 구현한 일종의 디자인 패턴이라고 할 수 있다.</p>\n<p>자바스크립트에서의 상속은 프로토타입 체인을 사용하여 구현하고, 캡슐화는 클로저를 사용해서 구현하게 되는데, 이번 포스팅에서는 이 중 프로토타입을 사용한 상속 패턴에 집중해서 설명해볼까 한다.</p>\n<h2 id=\"프로퍼티와-메소드는-원본-객체를-통해-공유될-수-있다\" style=\"position:relative;\">프로퍼티와 메소드는 원본 객체를 통해 공유될 수 있다<a href=\"#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C%EB%8A%94-%EC%9B%90%EB%B3%B8-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%ED%86%B5%ED%95%B4-%EA%B3%B5%EC%9C%A0%EB%90%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\" aria-label=\"프로퍼티와 메소드는 원본 객체를 통해 공유될 수 있다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>객체의 상속을 알아보기 전에 객체를 생성할 때 프로퍼티와 메소드를 부여하는 방법에 대해서 알아보도록 하자. <a href=\"/2019/10/23/js-prototype/\">이전 포스팅</a>에서 필자는 자바스크립트는 클래스가 아닌 <code class=\"language-text\">함수</code>를 사용하여 객체를 생성한다고 이야기 했었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">User</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 <code class=\"language-text\">User</code> 함수를 생성자로 호출하면서 생성된 <code class=\"language-text\">evan</code> 객체는 <code class=\"language-text\">User.prototype</code> 객체를 원본 객체로 하여 복제된 객체이다.</p>\n<p>이때 두 가지 방법을 사용하여 새롭게 생성되는 객체들에게 프로퍼티나 메소드를 부여할 수 있는데, 첫 번째는 생성자 함수 내에서 <code class=\"language-text\">this</code>를 사용하여 선언하는 방법, 두 번째는 새롭게 생성되는 객체들이 복사할 원본 객체인 <code class=\"language-text\">프로토타입 객체</code>에 선언하는 방법이다.</p>\n<p>먼저, <code class=\"language-text\">this</code>를 사용하여 프로퍼티나 메소드를 정의하는 방법에 대해서 살펴보자.</p>\n<h3 id=\"생성자-함수-내에서-this를-사용하는-방법\" style=\"position:relative;\">생성자 함수 내에서 this를 사용하는 방법<a href=\"#%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98-%EB%82%B4%EC%97%90%EC%84%9C-this%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"생성자 함수 내에서 this를 사용하는 방법 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>자바스크립트도 생성자 역할을 하는 함수 내에서 <code class=\"language-text\">this</code>를 사용하여 다른 언어와 비슷한 느낌으로 객체들에게 프로퍼티나 메소드를 부여할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">User</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">say</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello, World!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span><span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Hello, World!</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>참고로 생성자 함수 내에서 <code class=\"language-text\">strict</code> 모드를 사용한 이유는, 해당 생성자 함수가 실수로 <code class=\"language-text\">new</code> 예약어 없이 호출되어 <code class=\"language-text\">this</code>가 전역 객체로 평가되는 불상사를 방어하기 위해서이다.<small>(이 내용은 프로토타입과는 관련이 없기 때문에 자세히 다루지는 않겠다)</small></p>\n<p>이 방법은 일반적인 생성자의 사용 방법과 비슷해서 직관적으로 이해가 되는 편이다. 이때 생성자 함수 안의 <code class=\"language-text\">this</code>는 새롭게 생성된 객체를 의미하기 때문에, 함수 내에서 <code class=\"language-text\">this</code>를 통해 정의한 프로퍼티나 메소드는 이 생성자 함수를 사용하여 객체가 생성될 때마다 새롭게 정의된다.</p>\n<p>무슨 말인지 조금 더 쉽게 알아보기 위해 생성자 함수를 통해 두 개의 새로운 객체를 생성하고, 이 객체들의 메소드를 비교해도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> john <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>say <span class=\"token operator\">===</span> john<span class=\"token punctuation\">.</span>say<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>생성자 함수가 호출될 때 <code class=\"language-text\">this</code>는 각각 <code class=\"language-text\">evan</code> 객체와 <code class=\"language-text\">john</code> 객체를 의미했을 것이고, <code class=\"language-text\">say</code> 메소드 또한 이 객체들에게 직접 할당되었을 것이다. 자바스크립트의 <code class=\"language-text\">완전할당연산자(===)</code>는 다른 메모리에 적재된 객체는 다르다고 평가하므로 이 두 객체의 메소드들은 각자 다른 메모리에 담긴, 전혀 다른 함수라고 할 수 있다.</p>\n<p>이때 <code class=\"language-text\">evan</code> 객체나 <code class=\"language-text\">john</code> 객체를 출력해보면, 객체 내부에 <code class=\"language-text\">say</code> 메소드가 정의되어 있는 모습 또한 확인해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">User <span class=\"token punctuation\">{</span><span class=\"token function-variable function\">say</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 당연한 이야기를 하는 이유는 바로 밑에서 후술할 <code class=\"language-text\">프로토타입 객체에 정의하는 방법</code>과 차이점을 분명히 하기 위해서이다. 프로토타입 객체를 사용해서 프로퍼티나 메소드를 정의하게되면 지금과는 전혀 다른 결과가 나온다.</p>\n<h3 id=\"프로토타입-객체에-정의하는-방법\" style=\"position:relative;\">프로토타입 객체에 정의하는 방법<a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4%EC%97%90-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"프로토타입 객체에 정의하는 방법 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이번에는 <code class=\"language-text\">User</code> 생성자 함수의 프로토타입 객체인 <code class=\"language-text\">User.prototype</code>을 사용하여 메소드를 한번 정의해보도록 하자. <code class=\"language-text\">this</code>를 통해서 정의하는 방법과 어떤 차이가 있을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">User</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">say</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello, World!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span><span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Hello, World!</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>일단 <code class=\"language-text\">this</code>를 사용하여 정의했던 메소드와 동일한 느낌으로 작동하고 있다. 그래서 동일한 동작이라고 생각할 수도 있지만, 사실 두 방법들 사이에는 중요한 차이가 존재한다.</p>\n<p>바로 생성자 함수를 통해 생성된 모든 객체들이 해당 메소드를 <code class=\"language-text\">공유하고 있냐, 없냐</code>의 차이이다. 이전과 마찬가지로 두 개의 객체를 생성하고, 두 객체의 메소드를 비교해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> john <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>say <span class=\"token operator\">===</span> john<span class=\"token punctuation\">.</span>say<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>음? 이번에는 아까와는 다르게 두 객체의 메소드가 같다고 한다. 방금 전과는 다르게 이번에는 <code class=\"language-text\">evan.say</code>와 <code class=\"language-text\">john.say</code>가 객체에 따로따로 정의된 메소드가 아닌, 원본 객체의 메소드를 공유하고 있는 상황이기 때문이다.</p>\n<p>생성된 <code class=\"language-text\">evan</code> 객체를 한번 콘솔에 출력해보면, 원본 객체의 프로퍼티나 메소드를 공유하고 있다는 말이 무엇인지 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">User <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">evan</code> 객체를 출력해보니, 이 객체는 아무 메소드나 프로퍼티도 가지고 있지 않고 텅 비어있는 친구다.</p>\n<p>즉, 생성자 함수 내에서 <code class=\"language-text\">this</code>를 사용하지 않고, 원본 객체에 메소드나 프로퍼티를 정의하게 되면 객체들에게는 해당 프로퍼티가 없고, 원본 객체의 프로퍼티나 메소드를 참조한다는 것이다.</p>\n<p>이 특징을 제대로 인지하지 못하면 이런 상황도 발생할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>john<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Evan\nEvan</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그렇기 때문에 각 객체마다 고유한 프로퍼티를 부여하고 싶다면 원본 객체에 정의하는 것이 아니라, 생성자 함수 내에서 <code class=\"language-text\">this</code>를 사용하여 정의해야한다. 다시 말하지만 원본 객체에 정의한 프로퍼티나 메소드는 생성된 객체들 끼리 <code class=\"language-text\">공유</code>된다.</p>\n<p>한 가지 이상한 점은, 분명히 <code class=\"language-text\">evan</code> 객체에는 아무런 프로퍼티나 메소드도 없었는데, 필자는 분명히 <code class=\"language-text\">evan.say</code>를 통해 해당 메소드에 접근할 수 있었다는 것이다. 어떻게 이런 일이 가능한 것일까?</p>\n<h2 id=\"프로토타입-룩업\" style=\"position:relative;\">프로토타입 룩업<a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A3%A9%EC%97%85\" aria-label=\"프로토타입 룩업 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그 질문에 대한 해답은 바로 자바스크립트가 객체 내에서 프로퍼티를 찾는 방법 중 하나인 <code class=\"language-text\">프로토타입 룩업(Prototype Lookup)</code>에서 알아볼 수 있다. 방금 전 자바스크립트가 <code class=\"language-text\">evan</code> 객체에서 <code class=\"language-text\">say</code> 메소드를 찾아냈던 과정은 다음과 같다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/3caa593b82cbd86bf7af67e4dff11475/a2498/prototype_lookup.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 48.75000000000001%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAD2EAAA9hAHVrK90AAAByElEQVQoz41Ru0uCURS/5ictbkHQ4iYRLgUtTf0R7YKTNtZYNjQELuHiZDYkzY6hBL4R8QGKD3zi+4EPUJEvvZ9+t3M+NIoSO8vv3HvO+Z3Hj5BvptFoCGNMjn69Xn+klLJgMEg9Ho+YzWbZcDjkbTabCuNOp1NGtpler0dCDv3RaGQCAhaPxz9isZgQiUSQcBKNRg8w7na7txMqlUoklBJDodAr+8O0Wu0pxv1+/2bC+XxO0um05EPNDoA8EAhcF4vFsM/nc7VarXeY2A0Tvul0uqNVnpQPZ/lJ1u12uVQqxeXzeQ4IFOSfhpu0221FIpHgSqUS1+/3JfyVOJvNDmFdAySf4dtgMHydAXAvHA5rofnFxk7NZtOYyWSMuVzuttfr3ZfL5QeXy3UJeI5xUFhWqVRkq2b7Xq9XB6RXg8HAVK1Wb6D2rlAoGGFTIyJ2ZclkkgGBdHRIfP6rsdVq/RLBYrGo1iKh+jCI5C8WC0bG4zHtdDpUEAQeP+EWTyiKw+HYxWK1Wo1bkG9CKOx2+zHP81MQaQGTzUVRpMvlksIwlDQaDREKxMlkIiAhHPZlrbbZbP4lBCL8nyBRrVZjMIw4nU6xXkSuT+OMcziyb0qfAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prototype lookup\" title=\"prototype lookup\" src=\"/static/3caa593b82cbd86bf7af67e4dff11475/6af66/prototype_lookup.png\" srcset=\"/static/3caa593b82cbd86bf7af67e4dff11475/69538/prototype_lookup.png 160w,\n/static/3caa593b82cbd86bf7af67e4dff11475/72799/prototype_lookup.png 320w,\n/static/3caa593b82cbd86bf7af67e4dff11475/6af66/prototype_lookup.png 640w,\n/static/3caa593b82cbd86bf7af67e4dff11475/d9199/prototype_lookup.png 960w,\n/static/3caa593b82cbd86bf7af67e4dff11475/21b4d/prototype_lookup.png 1280w,\n/static/3caa593b82cbd86bf7af67e4dff11475/a2498/prototype_lookup.png 1764w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n</center>\n<blockquote>\n<ol>\n<li><code class=\"language-text\">evan.say</code>로 접근 시도</li>\n<li>어, <code class=\"language-text\">say</code> 프로퍼티가 없네? <code class=\"language-text\">__proto__</code>를 통해 원본 객체로 올라가보자!</li>\n<li><code class=\"language-text\">User.prototype</code>객체야, 너는 <code class=\"language-text\">say</code> 프로퍼티 가지고 있니?</li>\n<li>있네? Profit!</li>\n</ol>\n</blockquote>\n<p>이런 식으로 우리가 어떤 객체의 프로퍼티에 접근을 시도했을 때, 자바스크립트는 먼저 그 객체가 해당 프로퍼티를 가지고 있는지를 확인하고, 해당 프로퍼티가 없다면 그 객체의 원본 객체로 거슬러 올라가서 다시 확인하게 된다.</p>\n<p>이 집요한 확인 과정은 모든 객체의 조상인 <code class=\"language-text\">Object.prototype</code>에 다다를 때까지 계속되고, 만약 여기에도 존재하지 않는 프로퍼티라면 그때서야 <code class=\"language-text\">undefined</code>를 반환하게 된다.</p>\n<p>이 말인 즉슨, 모든 객체는 자신의 프로토타입 체인 내에 있는 모든 원본 객체들의 프로퍼티나 메소드에 접근할 수 있다는 뜻이다.</p>\n<p>쉽게 말해, 방금 생성한 <code class=\"language-text\">evan</code> 객체는 아무 프로퍼티나 메소드도 가지고 있지 않지만, 자신의 원본 객체인 <code class=\"language-text\">User.prorotype</code>에 정의된 <code class=\"language-text\">say</code> 메소드도 사용할 수 있고, <code class=\"language-text\">Object.prototype</code>에 있는 <code class=\"language-text\">toString</code>이나 <code class=\"language-text\">hasOwnProperty</code>와 같은 메소드도 사용할 수 있다는 것이다.</p>\n<center>\n  <div style=\"width: 200px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7b54dda3a84203718b2412b4631d61b5/31493/prototype_lookup2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 220.00000000000003%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,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&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prototype lookup2\" title=\"prototype lookup2\" src=\"/static/7b54dda3a84203718b2412b4631d61b5/6af66/prototype_lookup2.png\" srcset=\"/static/7b54dda3a84203718b2412b4631d61b5/69538/prototype_lookup2.png 160w,\n/static/7b54dda3a84203718b2412b4631d61b5/72799/prototype_lookup2.png 320w,\n/static/7b54dda3a84203718b2412b4631d61b5/6af66/prototype_lookup2.png 640w,\n/static/7b54dda3a84203718b2412b4631d61b5/31493/prototype_lookup2.png 664w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  </div>\n  <small>evan &#xAC1D;&#xCCB4;&#xB294; &#xD504;&#xD1A0;&#xD1A0;&#xD0C0;&#xC785; &#xCCB4;&#xC778; &#xB0B4;&#xC5D0; &#xC788;&#xB294; &#xBAA8;&#xB4E0; &#xC6D0;&#xBCF8; &#xAC1D;&#xCCB4;&#xC758; &#xD504;&#xB85C;&#xD37C;&#xD2F0;&#xB97C; &#xACF5;&#xC720;&#xBC1B;&#xB294;&#xB2E4;</small>\n  <br>\n  <br>\n</center>\n<p>이 프로토타입 룩업 과정은 객체의 프로퍼티나 메소드에 접근하는 그 순간마다 수행되기 때문에, 클래스가 정의될 때 모든 상속관계가 함께 평가되는 클래스 기반 언어의 상속과는 조금 다른 느낌이다.</p>\n<p>그러나 추상적으로 생각해보면 원본 객체(부모)의 속성을 물려받고 있다는 점에서 착안하여, 프로토타입 룩업을 토대로 상속을 구현할 수 있다.</p>\n<h2 id=\"프로토타입을-사용한-상속\" style=\"position:relative;\">프로토타입을 사용한 상속<a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%83%81%EC%86%8D\" aria-label=\"프로토타입을 사용한 상속 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자바스크립트에서 프로토타입을 사용하여 상속을 구현하는 방법은 크게 <code class=\"language-text\">Object.create</code> 메소드를 사용하는 방법과 이 메소드를 사용하지않는 <small>(더러운)</small> 방법, 두 가지로 나누어질 수 있다.</p>\n<p>사실 <code class=\"language-text\">Object.create</code>만 사용해도 프로토타입을 사용한 상속은 충분히 구현이 가능하다. 하지만 굳이 두 가지를 나눠서 이야기한 이유는, <code class=\"language-text\">Object.create</code> 메소드가 <code class=\"language-text\">Internet Explorer 9</code>부터 지원이 되기 때문이다.</p>\n<p>하지만 필자는 필자의 행복을 위해 쓰는 포스팅에서 <code class=\"language-text\">IE 8</code> 이하 환경에 대한 자세한 이야기는 별로 하고 싶지 않으므로 <code class=\"language-text\">Object.create</code>를 사용하지 않는 방법에 대한 코드를 간단하게 <a href=\"https://gist.github.com/evan-moon/a7e5a51e20d22016ea443a03480765b7\" target=\"_blank\" rel=\"nofollow\">필자의 Github Gist 링크</a>로 첨부하겠다.</p>\n<h3 id=\"objectcreate를-사용하자\" style=\"position:relative;\">Object.create를 사용하자<a href=\"#objectcreate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90\" aria-label=\"objectcreate를 사용하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Object.create</code> 메소드는 첫 번째 인자로 생성할 객체의 원본 객체가 될 객체, 두 번째 인자로 새로 생성할 객체에 추가할 프로퍼티를 객체 타입으로 받는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>proto<span class=\"token operator\">:</span> Object<span class=\"token punctuation\">,</span> properties<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 두 번째 인자는 선택사항이며, 단순하게 <code class=\"language-text\">{ test: 1 }</code>처럼 넘기는 것이 아니라, <code class=\"language-text\">Object.defineProperties</code> 메소드를 사용할 때 처럼 데이터 서술자와 접근 서술자를 지정해줘야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  foo<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    configurable<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    enumerable<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    value<span class=\"token operator\">:</span> <span class=\"token string\">'I am Foo!'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>자세한 프로퍼티들의 의미는 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\" target=\"_blank\" rel=\"nofollow\">MDN Web Docs: Object.defineProperties</a>에서 확인해보도록 하자.</p>\n<p>이 메소드에서 중요한 포인트는 <code class=\"language-text\">객체의 프로토타입 객체</code>를 지정할 수 있다는 것이며, 이 말인 즉슨 객체의 프로토타입 체인을 내 맘대로 만져줄 수 있다는 것이다. 심지어 동적으로 변경도 가능하다.<small>(사실 이게 JS의 변태적인 면…)</small></p>\n<p>그럼 이제 <code class=\"language-text\">Object.create</code> 메소드와 프로토타입을 사용하여 상속을 한번 구현해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">SuperClass</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">SuperClass</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">say</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">I am </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>우선 부모 클래스 역할을 할 <code class=\"language-text\">SuperClass</code> 생성자 함수를 생성하고, 이 함수의 프로토타입 객체에 <code class=\"language-text\">say</code> 메소드를 정의했다. 그럼 이제 자식 클래스 역할을 할 생성자 함수를 구현하고, 이 두 개의 함수의 상속 관계도 함께 정의해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">SubClass</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">SuperClass</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">SubClass</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SuperClass</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">SubClass</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">=</span> SubClass<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">SubClass</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">run</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> is running</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>뭘 이것저것 많이 만진 것 같지만, 막상 하나하나 뜯어보면 별 거 없다.</p>\n<p><strong>SuperClass.call(this)</strong>\n<code class=\"language-text\">Function.prototype.call</code> 메소드는 호출된 함수의 실행 컨텍스트를 첫 번째 인자로 받은 녀석으로 변경한다. 즉, <code class=\"language-text\">this</code>의 타겟을 변경하는 것이다.</p>\n<p>즉, <code class=\"language-text\">SuperClass.call(this, name)</code>의 의미는 부모 생성자 함수의 생성자를 호출하되, 실행 컨텍스트를 자식 생성자 함수로 변경하라는 의미이다. 자바로 치면 <code class=\"language-text\">super</code> 메소드를 호출하는 것과 비슷한 느낌이랄까.</p>\n<p>필자는 이때 <code class=\"language-text\">call</code> 메소드를 사용했지만, 뭐가 됐든 부모 생성자 함수의 실행 컨텍스트만 변경해주면 장땡이기 때문에 <code class=\"language-text\">apply</code>나 <code class=\"language-text\">bind</code> 메소드를 사용해도 상관없다.</p>\n<p><strong>SubClass.prototype 변경</strong>\n그 후 <code class=\"language-text\">Object.create</code> 메소드를 사용하여 <code class=\"language-text\">SuperClass.prototype</code> 객체를 원본 객체로 하는 새로운 객체를 생성하고, 이 객체를 <code class=\"language-text\">SubClass</code>의 프로토타입 객체로 할당해준다. 자식 생성자 함수의 프로토타입 객체와 부모 생성자 함수의 프로토타입 객체 간의 프로토타입 체인, 쉽게 말해 부모 자식 관계를 만들어 주는 것이다.</p>\n<p><strong>SubClass.prorotype.constructor 변경</strong>\n우리는 부모 생성자 함수의 프로토타입 객체를 토씨 하나 안바꾸고 그대로 복제했기 때문에, 새롭게 생성한 자식 생성자 함수의 프로토타입 객체의  <code class=\"language-text\">constructor</code> 프로퍼티는 여전히 부모 생성자 함수인 <code class=\"language-text\">SuperClass</code>를 참조하고 있다.</p>\n<p>하지만 자식 생성자 함수인 <code class=\"language-text\">SubClass</code>를 통해 생성된 객체가 <code class=\"language-text\">SuperClass</code>를 사용하여 생성된 것처럼 처리되면 안되므로, 다시 <code class=\"language-text\">constructor</code> 프로퍼티를 <code class=\"language-text\">SubClass</code>로 변경해줘야한다.</p>\n<p>이런 과정들을 거치면 다음과 같은 관계가 성립된다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8ad5010e348e3ea93ea8ee00b6a3a94b/a3c4c/extends.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 46.25%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAD2EAAA9hAHVrK90AAACAUlEQVQoz5WSy6tSURTGbRJE2KCobtGwoDtp4onbTAobiYOyCw0d3GkFTboH76CG/gcOnIlCCgcdKOIDlMQXiuIbfJHvt/jW49Xdtzc1KQpasFnnnP3b31rnW1syGo3Idrsl6XSaeDwemvcIMhwOOxqN5pHT6XztcrnO5HL57X6/L4iiSLLZ7M7n85FwOHwol8uXCIL8XEKj1+uJdLVaLbHT6YiTyWRDEOv1+rtWqz1KJBJcMpl8IZVKr0Lw62KxIOBWlKXnkBnvcDheMUHyl0DXG6VSecdms72x2+3vgV7P5XLfUIgsl8s/eL/ff8oEUYEHwOPXeVTkB4PBOZ4vut3uO7VafU2v1980GAz3KAvB01Qq9QX5HJbw6Jjy/Hg8vjCbzfcl/xNo4sq/9tHhh1gs9lkSj8c5DILzer0cBsC53W4ZOngK45/8figSiTzM5/MnhUJBBis4iHD1el1WqVSeGY3GxyaT6Ujyy49qtcqmjE32PpvNepjysSAIZ/Dwk0qleoBvAt3LZDL7YDBIotEoqdVqjA+FQi9Z1Xa7TRqNBplOp2Sz2ZDdbrf/OZSWTqe7NZ/PjzH5E8o2m00BvpFSqbSjV221WhFM/ZLygUBAxQQBHHDggE4PuGMHiDJBCLUUCsVdi8Xy1mq1fgR6A9Y4isUigSVUkPFYTBAWKajeD6kt1qLqkFwBAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"extends\" title=\"extends\" src=\"/static/8ad5010e348e3ea93ea8ee00b6a3a94b/6af66/extends.png\" srcset=\"/static/8ad5010e348e3ea93ea8ee00b6a3a94b/69538/extends.png 160w,\n/static/8ad5010e348e3ea93ea8ee00b6a3a94b/72799/extends.png 320w,\n/static/8ad5010e348e3ea93ea8ee00b6a3a94b/6af66/extends.png 640w,\n/static/8ad5010e348e3ea93ea8ee00b6a3a94b/d9199/extends.png 960w,\n/static/8ad5010e348e3ea93ea8ee00b6a3a94b/21b4d/extends.png 1280w,\n/static/8ad5010e348e3ea93ea8ee00b6a3a94b/a3c4c/extends.png 2196w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n</center>\n<p>이제 한번 <code class=\"language-text\">SubClass</code> 생성자 함수를 사용하여 객체를 생성해보고, 제대로 부모 생성자 함수의 속성들을 물려받았는지 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SubClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Evan'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">SubClass <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 에반 객체</span>\nSubClass <span class=\"token punctuation\">{</span> constructor<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>Function<span class=\"token operator\">:</span> SubClass<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> run<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>Function<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 에반 객체의 원본 객체</span>\nSuperClass <span class=\"token punctuation\">{</span> say<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>Function<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 에반 객체의 원본 객체의 원본 객체</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">evan</code> 객체는 <code class=\"language-text\">SubClass</code>의 프로토타입 객체를 복제해서 정상적으로 생성되었고, <code class=\"language-text\">evan</code> 객체의 원본 객체와 원본 객체의 원본 객체도 잘 체이닝되어있다.</p>\n<p>즉, <code class=\"language-text\">evan -&gt; SubClass.prototype -&gt; SuperClass.prototype</code>으로 이어지는 프로토타입 체인이 완성된 것이다. 이때 <code class=\"language-text\">evan</code> 객체의 <code class=\"language-text\">run</code>이나 <code class=\"language-text\">say</code> 메소드를 호출하면, 위에서 언급한 프로토타입 룩업을 통해 원본 객체의 메소드를 호출할 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"/2019/10/23/js-prototype/\">이전 포스팅</a>에 이어 이번에는 자바스크립트에서 프로토타입을 활용한 상속 패턴에 대한 내용을 한번 다뤄보았다.</p>\n<p>솔직히 말해서, 필자가 실무에서 이러한 패턴을 사용해서 상속을 구현해본 경험은 거의 없다. 필자가 개발자로 일을 시작하고 얼마 되지 않아 ES6가 나오기도 했었고, 필자는 당시 자바가 더 익숙했기 때문에 새로 추가된 <code class=\"language-text\">class</code> 키워드에 흠뻑 빠져있었다.</p>\n<p>하지만 일을 시작하고 몇 년이 지나면서 레거시 코드에서 이 상속 패턴을 꽤 마주치기도 했고, 면접에서 이런 패턴에 대해서 물어보는 경우도 있었기 때문에 확실히 공부할 필요는 있는 것 같다.</p>\n<p>아무리 요즘 ES5를 거의 사용하지 않는다고 하지만, 사실 이런 상속 패턴이 자바스크립트를 사용한 프로그램 아키텍처의 근간이기도 하니 말이다.</p>\n<p>이상으로 프로토타입을 사용하여 상속하기 포스팅을 마친다.</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C%EB%8A%94-%EC%9B%90%EB%B3%B8-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%ED%86%B5%ED%95%B4-%EA%B3%B5%EC%9C%A0%EB%90%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\">프로퍼티와 메소드는 원본 객체를 통해 공유될 수 있다</a></p>\n<ul>\n<li><a href=\"#%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98-%EB%82%B4%EC%97%90%EC%84%9C-this%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\">생성자 함수 내에서 this를 사용하는 방법</a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4%EC%97%90-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\">프로토타입 객체에 정의하는 방법</a></li>\n</ul>\n</li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A3%A9%EC%97%85\">프로토타입 룩업</a></li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%83%81%EC%86%8D\">프로토타입을 사용한 상속</a></p>\n<ul>\n<li><a href=\"#objectcreate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90\">Object.create를 사용하자</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","fields":{"lang":"ko"},"frontmatter":{"title":"[JS 프로토타입] 프로토타입을 사용하여 상속하기","date":"2019-10-27","categories":["Programming","JavaScript"],"tags":["프로토타입","자바스크립트","JavaScript","Prototype"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABgklEQVQoz31Q20vCUBzeH91T9RI99FJBRfgWGb1IZkEpEbW8jrxsY55t7p6iNuc2sUwiyejbZncSPsZ3+X3n/HaozeXCf1hbyAJzBqiNpcJ/yCTUdEKdM0Btr5R+YWeVWV/MpxPK6/Rl+jbJJBRImH8nqXqlG0EoBwh4tcsx7W5rOB6PHkcPneaQYzowf8yEoHSxH8IxZNeQPY04kGbDMxuuaz959hgEEiYiU/YwpolO1KLUugNoxOVLLbZ4p8s+YgSK0IsiEEiYaNaKTbbU0kU3ilBG5vJFyxEOfHGP3Kq66KlCD/fgGxH0DdGrMPpJ+ei0lKriDtFVgjIOlvxaVno2difWFpetaeJAJw7LtONnVvzcAgkWlnz6mj/m91PcYYFumJKHE6lwZ0fm+0K+QvKMxAbbWrJ7eWHGcnYsdw8CCVNi7Su6St9wDd5RyWzt6J+hfYUMNNIPZR/Pm0xbyYxFqt1P0yA+9tfC5lc5RC/ETOKRVN7WeDsgH6ZS7ynfZt4BsOgFP6DxsWsAAAAASUVORK5CYII=","aspectRatio":1.7699115044247788,"src":"/static/ffc88c93a54f1c5d1783f61478e57588/ee604/thumbnail.png","srcSet":"/static/ffc88c93a54f1c5d1783f61478e57588/69585/thumbnail.png 200w,\n/static/ffc88c93a54f1c5d1783f61478e57588/497c6/thumbnail.png 400w,\n/static/ffc88c93a54f1c5d1783f61478e57588/ee604/thumbnail.png 800w,\n/static/ffc88c93a54f1c5d1783f61478e57588/f3583/thumbnail.png 1200w,\n/static/ffc88c93a54f1c5d1783f61478e57588/5707d/thumbnail.png 1600w,\n/static/ffc88c93a54f1c5d1783f61478e57588/eeb1b/thumbnail.png 1920w","sizes":"(max-width: 800px) 100vw, 800px"}}}}},"allMarkdownRemark":{"edges":[]}},"pageContext":{"slug":"/20191027-inheritance-with-prototype/","previous":{"fields":{"slug":"/20191023-js-prototype/","path":"/2019/10/23/js-prototype/","lang":"ko","postGroup":"20191023-js-prototype"},"frontmatter":{"title":"[JS 프로토타입] 자바스크립트의 프로토타입 훑어보기"}},"next":{"fields":{"slug":"/20191030-make-simple-with-math/","path":"/2019/10/30/make-simple-with-math/","lang":"ko","postGroup":"20191030-make-simple-with-math"},"frontmatter":{"title":"수학과 함께 복잡한 문제를 단순하게 만들자!"}},"lang":"ko","postGroup":"20191027-inheritance-with-prototype"}}}