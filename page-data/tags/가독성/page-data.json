{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/가독성/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"cca520f5-4ad7-5867-8d7e-204a8480f038","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EC%9D%84-%EB%95%8C-%EB%87%8C%EC%97%90%EC%84%9C%EB%8A%94-%EB%AC%B4%EC%8A%A8-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C\">코드를 읽을 때 뇌에서는 무슨 일이 일어날까</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%91%EC%97%85-%EA%B8%B0%EC%96%B5-4%EA%B0%9C%EC%9D%98-%EC%8A%AC%EB%A1%AF\">작업 기억: 4개의 슬롯</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B2%AD%ED%82%B9-%EB%87%8C%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%95%95%EC%B6%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">청킹: 뇌의 데이터 압축 알고리즘</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-1%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-2-%EC%A7%81%EA%B4%80%EA%B3%BC-%EB%B6%84%EC%84%9D\">시스템 1과 시스템 2: 직관과 분석</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%8C%EC%8A%88%ED%83%88%ED%8A%B8-%EC%9B%90%EB%A6%AC-%EC%BD%94%EB%93%9C%EC%9D%98-%EC%8B%9C%EA%B0%81%EC%A0%81-%EA%B5%AC%EC%A1%B0%EA%B0%80-%EC%9D%B4%ED%95%B4%EC%97%90-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5\">게슈탈트 원리: 코드의 시각적 구조가 이해에 미치는 영향</a></p>\n<ul>\n<li><a href=\"#%EA%B7%BC%EC%A0%91%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\">근접성의 원리</a></li>\n<li><a href=\"#%EC%9C%A0%EC%82%AC%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\">유사성의 원리</a></li>\n<li><a href=\"#%EC%97%B0%EC%86%8D%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\">연속성의 원리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B8%EC%A7%80-%EB%B6%80%ED%95%98-%EC%9D%B4%EB%A1%A0-%EC%84%B8-%EA%B0%80%EC%A7%80-%EB%B6%80%ED%95%98%EC%9D%98-%EC%A2%85%EB%A5%98\">인지 부하 이론: 세 가지 부하의 종류</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%BD%ED%97%98%EC%9D%B4-%EB%87%8C%EB%A5%BC-%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B0%94%EA%BE%BC%EB%8B%A4\">경험이 뇌를 물리적으로 바꾼다</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%98%88%EC%B8%A1-%EB%B6%80%ED%98%B8%ED%99%94-%EB%87%8C%EB%8A%94-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EB%8A%94-%EA%B2%8C-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%98%88%EC%B8%A1%ED%95%9C%EB%8B%A4\">예측 부호화: 뇌는 코드를 읽는 게 아니라 예측한다</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EA%B2%B0%EA%B5%AD\">그래서 “좋은 코드”란 결국</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n</li>\n</ul>","excerpt":"이전에 좋은 코드란 무엇일까? - 가독성이란 허상에 대하여라는 글에서, “좋은 코드 = 가독성이 좋은 코드”라는 공식이 얼마나 주관적이고 맥락 의존적인지에 대해 이야기한 적이 있다. 물론 사람마다 가독성이 좋다고 판단하는 결과는 주관적이라고 볼 수 있다. 하지만 가독성이 좋은 코드라는 것이 어떤 원리로 동작하는지, 그 감각은 대체 어디서 오는 것인지를 추적해보다보면 약간은 힌트를 얻을 수 있다.","html":"<p>이전에 <a href=\"/2024/12/23/the-illusion-of-a-right-answer/\">좋은 코드란 무엇일까? - 가독성이란 허상에 대하여</a>라는 글에서, “좋은 코드 = 가독성이 좋은 코드”라는 공식이 얼마나 주관적이고 맥락 의존적인지에 대해 이야기한 적이 있다.</p>\n<p>물론 사람마다 가독성이 좋다고 판단하는 결과는 주관적이라고 볼 수 있다. 하지만 가독성이 좋은 코드라는 것이 어떤 원리로 동작하는지, 그 감각은 대체 어디서 오는 것인지를 추적해보다보면 약간은 힌트를 얻을 수 있다.</p>\n<!-- more -->\n<p>그래서 이번 포스팅에서는 바로 그 이야기를 해보려 한다. 인간이 코드를 이해하는 방식, 그리고 어떤 형태의 정보가 이해하기 쉽다고 느끼는지에 대한 이야기이다.</p>\n<h2 id=\"코드를-읽을-때-뇌에서는-무슨-일이-일어날까\" style=\"position:relative;\">코드를 읽을 때 뇌에서는 무슨 일이 일어날까<a href=\"#%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EC%9D%84-%EB%95%8C-%EB%87%8C%EC%97%90%EC%84%9C%EB%8A%94-%EB%AC%B4%EC%8A%A8-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C\" aria-label=\"코드를 읽을 때 뇌에서는 무슨 일이 일어날까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://doi.org/10.7554/eLife.58906\" target=\"_blank\" rel=\"nofollow\">MIT에서 2020년에 진행한 기능적 MRI 연구</a>에서 프로그래머들이 코드를 읽을 때 뇌의 어떤 영역이 활성화되는지를 관찰했는데, 재밌는 결과가 나왔다.</p>\n<p>연구에 따르면 코드를 읽을 때는 언어 네트워크가 아니라 논리 추론과 복잡한 인지 작업을 담당하는 다중 수요 네트워크가 주로 활성화되었다고 한다. 언어 영역의 관여가 완전히 없었던 것은 아니지만, 다중 수요 네트워크의 반응이 지배적이었다.</p>\n<p>쉽게 말해서, 우리 뇌는 코드를 읽을 때 언어 처리보다는 논리적 추론 쪽에 더 크게 의존한다는 뜻이다.</p>\n<p>이 연구에서 확인된 것은 코드 이해 시 작업 기억, 주의 집중, 언어 처리와 관련된 다섯 개의 뇌 영역이 뚜렷하게 활성화된다는 점이다. 동시에 디폴트 모드 네트워크(뇌가 쉬고 있을 때 활성화되는 영역)의 활동은 감소했다. 즉, 코드를 읽는 건 뇌 입장에서 꽤 비싼 작업인 셈이다.</p>\n<p>여기까지는 그러려니 할 수 있겠지만, 더 흥미로운 사실은 바로 전문가와 초보자의 차이에서 나온다. 숙련된 개발자는 코드를 읽을 때 뇌의 전반적인 활성화 수준이 낮았다. 덜 열심히 한 게 아니라, 더 효율적으로 처리한 것이다. 반면 초보 개발자는 뇌의 넓은 영역이 활성화됐는데, 이는 거의 모든 것을 의식적으로 하나씩 처리하고 있다는 뜻이다.</p>\n<p>초보자는 코드를 자연어 텍스트처럼 위에서 아래로 읽는 경향이 있었고, 전문가는 프로그램의 실행 흐름을 따라 읽었다. 같은 코드를 보고 있지만, 뇌가 처리하는 방식 자체가 다른 것이다.</p>\n<h2 id=\"작업-기억-4개의-슬롯\" style=\"position:relative;\">작업 기억: 4개의 슬롯<a href=\"#%EC%9E%91%EC%97%85-%EA%B8%B0%EC%96%B5-4%EA%B0%9C%EC%9D%98-%EC%8A%AC%EB%A1%AF\" aria-label=\"작업 기억 4개의 슬롯 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>왜 어떤 코드는 쉽게 읽히는데 어떤 코드는 머릿속에서 정리가 안 되는지를 이해하려면, 작업 기억이라는 개념을 알아야 한다.</p>\n<p>1956년 인지심리학자 조지 밀러(George A. Miller)가 발표한 유명한 논문 <a href=\"https://doi.org/10.1037/h0043158\" target=\"_blank\" rel=\"nofollow\">“The Magical Number Seven, Plus or Minus Two”</a>에서, 인간의 단기 기억 용량이 약 7±2개의 항목이라는 사실이 밝혀졌다. 이후 연구에서는 이 숫자가 더 줄어들어, <a href=\"https://doi.org/10.1017/s0140525x01003922\" target=\"_blank\" rel=\"nofollow\">Cowan(2001)</a> 등의 견해에 따르면 작업 기억에 동시에 유지할 수 있는 청크는 약 3~4개 수준으로 수렴한다는 주장이 유력하다. 다만 이 수치는 과제의 종류, 숙련도, 정보의 양식에 따라 달라질 수 있다.</p>\n<p>코드를 읽을 때 우리가 머릿속에 올려놓는 것들을 떠올려보자. 변수의 현재 값, 제어 흐름의 방향, 함수 호출 순서, 현재 스코프의 상태 등 다양한 것들이 작업 기억의 슬롯을 차지한다. 그리고 이 슬롯이 꽉 차면, 뇌는 새로운 정보를 받아들이기 어려워는데, 바로 이때 “이 코드 뭔가 복잡한데”라는 느낌이 찾아오는 것이다.</p>\n<p>이걸 개발랭이들이 이해하기 쉬운 프로그래밍적인 비유로 바꿔보면, 작업 기억은 일종의 고정 크기 스택이라고 볼 수 있다.</p>\n<p>실제 작업 기억은 스택보다 훨씬 복잡한 시스템이지만, “용량에 한계가 있고 초과하면 처리가 무너진다”는 특성을 직관적으로 이해하기에는 나쁘지 않은 비유다. 스택 사이즈가 약 4인데 이걸 초과하면 스택 오버플로우가 나는 것이다. 다만 실제로는 슬롯에 담기는 항목의 크기가 균일하지 않고, 항목 간 간섭도 발생하기 때문에, 숫자 자체보다는 “용량에 한계가 있다”는 사실이 핵심이다. 그리고 이 용량이 한계에 부딪히는 순간이 바로 “이 코드 읽기 어렵다”는 감각이 발생하는 순간이다.</p>\n<p>한번 작업 기억을 빠르게 소진하는 코드와 그렇지 않은 코드를 비교해보며 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 작업 기억 슬롯 4개를 빠르게 소진하는 코드</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">processOrder</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token string\">'pending'</span> <span class=\"token operator\">&amp;&amp;</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> discount <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>customer<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span>\n      <span class=\"token operator\">?</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> sum <span class=\"token operator\">+</span> item<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span>\n      <span class=\"token operator\">:</span> order<span class=\"token punctuation\">.</span>coupon<span class=\"token operator\">?.</span>discount <span class=\"token operator\">??</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> tax <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>domestic <span class=\"token operator\">?</span> <span class=\"token number\">0.1</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> finalPrice <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount <span class=\"token operator\">+</span> tax <span class=\"token operator\">+</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>cost<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>order<span class=\"token punctuation\">,</span> finalPrice<span class=\"token punctuation\">,</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'processed'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 틀린 코드는 아니지만, 읽는 사람의 작업 기억에 동시에 올려야 할 것이 너무 많다.</p>\n<p><code class=\"language-text\">order.status</code>의 조건, <code class=\"language-text\">order.items</code>의 존재 여부, <code class=\"language-text\">customer.tier</code>에 따른 할인 분기, 쿠폰의 널 체크, 세금 계산의 국내/해외 분기, 최종 가격 산출 등 이 모든 맥락을 3~4개의 슬롯에 동시에 담으려 하니 뇌가 비명을 지르는 것이다.</p>\n<p>만약 이 맥락을 적절한 단위와 크기로 나눠줄 수 있다면, 어떤 동작을 이해하기 위해 필요한 작업 슬롯을 아낄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 작업 기억 부담을 줄인 버전</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateDiscount</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>customer<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> subtotal <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> sum <span class=\"token operator\">+</span> item<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> subtotal <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">.</span>coupon<span class=\"token operator\">?.</span>discount <span class=\"token operator\">??</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateTax</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> shipping<span class=\"token operator\">:</span> ShippingInfo<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> shipping<span class=\"token punctuation\">.</span>domestic <span class=\"token operator\">?</span> amount <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">processOrder</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>status <span class=\"token operator\">!==</span> <span class=\"token string\">'pending'</span> <span class=\"token operator\">||</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> discount <span class=\"token operator\">=</span> <span class=\"token function\">calculateDiscount</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> tax <span class=\"token operator\">=</span> <span class=\"token function\">calculateTax</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount<span class=\"token punctuation\">,</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> finalPrice <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount <span class=\"token operator\">+</span> tax <span class=\"token operator\">+</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>cost<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>order<span class=\"token punctuation\">,</span> finalPrice<span class=\"token punctuation\">,</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'processed'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 버전에서는 각 단계에서 머릿속에 올려야 할 것이 확연하게 줄어든다. 동작 자체는 동일하지만, 정보를 일정한 단위로 패키징함으로서 작업 슬롯에 들어가는 맥락을 제어해주는 것이다.</p>\n<p><code class=\"language-text\">calculateDiscount</code>를 읽을 때는 할인 로직에만 집중하면 되며, <code class=\"language-text\">processOrder</code>를 읽을 때는 각 계산의 세부 구현을 몰라도 전체 흐름을 이해할 수 있다. 각 함수가 작업 기억의 용량 안에서 소화 가능한 크기이기 때문에 이해가 쉽다고 느껴진다. 그리고 이것이 우리가 설계를 할 때 적절한 단위로 추상화를 해야하는 이유라고도 할 수 있다. 물론 반대로, 지나치게 잘게 쪼개면 함수 간 점프와 맥락 추적에 작업 기억을 소모하게 된다. 분리 자체가 목적이 아니라, 한 번에 머릿속에 올려야 할 양을 줄이는 것이 목적이다.</p>\n<h2 id=\"청킹-뇌의-데이터-압축-알고리즘\" style=\"position:relative;\">청킹: 뇌의 데이터 압축 알고리즘<a href=\"#%EC%B2%AD%ED%82%B9-%EB%87%8C%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%95%95%EC%B6%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"청킹 뇌의 데이터 압축 알고리즘 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그런데 여기서 한 가지 의문이 생긴다. 작업 기억의 슬롯이 겨우 4개라면, 우리는 대체 어떻게 수백 줄의 코드를 이해할 수 있는 걸까?</p>\n<p>답은 청킹이라는 인지 메커니즘에 있다. 청킹이란 여러 개의 작은 정보 단위를 하나의 의미 있는 덩어리로 묶어서 처리하는 것을 말한다. <a href=\"https://doi.org/10.5334/joc.451\" target=\"_blank\" rel=\"nofollow\">취리히 대학교의 연구</a>에 따르면, 청킹은 장기 기억에서 압축된 청크 표상을 불러와 개별 요소의 표상을 대체함으로써 작업 기억의 부하를 줄인다. 이로 인해 확보된 용량은 이후에 입력되는 새로운 정보를 처리하는 데 사용된다.</p>\n<p>전화번호를 생각해보자. <code class=\"language-text\">01012345678</code>이라는 11자리 숫자를 한 자리씩 기억하려면 작업 기억의 용량을 한참 초과한다. 그런데 <code class=\"language-text\">010-1234-5678</code>로 나누면 세 덩어리만 기억하면 된다. 더 나아가, 이미 익숙한 <code class=\"language-text\">010</code>은 “한국 휴대폰 번호 앞자리”라는 하나의 청크로 자동 처리되니, 실질적으로 두 덩어리만 새로 기억하면 되는 것이다.</p>\n<p>코드에서도 같은 일이 일어난다. 숙련된 개발자가 아래 코드를 볼 때 일어나는 일을 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> activeUsers <span class=\"token operator\">=</span> users<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">=></span> u<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">=></span> u<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>초보 개발자는 이걸 읽을 때 <code class=\"language-text\">users</code>라는 변수, <code class=\"language-text\">.filter</code> 메서드의 동작, 화살표 함수의 문법, <code class=\"language-text\">u.isActive</code>라는 속성 접근, <code class=\"language-text\">.map</code> 메서드의 동작, 또 다른 화살표 함수… 이런 개별 요소들을 하나씩 작업 기억에 올려야 한다.</p>\n<p>반면 숙련된 개발자에게 <code class=\"language-text\">users.filter(...).map(...)</code>은 “배열 필터링 후 변환”이라는 하나의 청크로 인식된다. 이 패턴을 수백, 수천 번 봤기 때문에, 장기 기억에 저장된 청크를 꺼내와서 작업 기억의 슬롯을 하나만 쓰는 것이다. 나머지 슬롯은 “왜 필터링하는가”, “결과가 어디에 쓰이는가” 같은 더 상위 수준의 사고에 할당할 수 있다.</p>\n<p>이것이 바로 체스 마스터가 체스판을 한 번 보고 전체 상황을 파악할 수 있는 원리와 같다. 체스 마스터는 개별 말의 위치를 하나씩 기억하는 게 아니라, 익숙한 포진 패턴을 하나의 청크로 인식한다. 그래서 의미 있는 배치의 체스판은 빠르게 기억하지만, 말을 무작위로 배치하면 초보자와 별 차이가 없다.</p>\n<p>코드도 마찬가지다. 관용적인 코드가 읽기 쉬운 이유는 그게 “올바른” 코드여서가 아니라, 개발자의 장기 기억에 이미 저장된 청크와 일치하기 때문이다.</p>\n<p>그리고 특정 패턴이 관용적이 되는 데는 언어의 설계 의도, 표준 라이브러리의 관례, 커뮤니티의 반복적 선택 같은 외부 요인이 작용한다. 단순히 “많이 써서 익숙한 것”이 아니라, 여러 이유로 수렴한 결과가 익숙함을 만든 것이다. 프로젝트만의 독특한 패턴이나 지나치게 창의적인 코드가 읽기 어려운 이유도 여기에 있다. 기존 청크와 매칭되지 않으면, 뇌는 모든 것을 개별 요소로 분해해서 처리해야 하고, 작업 기억은 순식간에 포화된다.</p>\n<h2 id=\"시스템-1과-시스템-2-직관과-분석\" style=\"position:relative;\">시스템 1과 시스템 2: 직관과 분석<a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-1%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-2-%EC%A7%81%EA%B4%80%EA%B3%BC-%EB%B6%84%EC%84%9D\" aria-label=\"시스템 1과 시스템 2 직관과 분석 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여기서 다니엘 카너먼(Daniel Kahneman)의 이중 처리 이론을 꺼내야 한다. 카너먼은 인간의 사고를 두 가지 시스템으로 나눴다.</p>\n<hr>\n<ul>\n<li><strong>시스템 1</strong>: 빠르고, 자동적이고, 직관적인 사고. 패턴 인식에 기반한다.</li>\n<li><strong>시스템 2</strong>: 느리고, 의식적이고, 분석적인 사고. 논리적 추론에 기반한다.</li>\n</ul>\n<hr>\n<p>우리가 일상적으로 하는 판단 대부분은 시스템 1이 담당한다. 운전을 하거나, 전화기 너머 여친의 기분을 한마디에 알아채는 것도 시스템 1의 영역이다. 시스템 1은 새로운 정보를 접했을 때, 완전히 새로운 패턴을 만들어내는 게 아니라 기존에 저장된 패턴과 대조하는 방식으로 작동한다.</p>\n<p>시스템 1이 막히면 그때서야 시스템 2가 호출된다. “이게 뭐지?” 하고 의식적으로 분석을 시작하는 순간이 바로 시스템 2가 개입하는 시점이다. 그리고 이 프레임워크를 코드 읽기에 적용하면 정말 많은 것이 설명된다.</p>\n<p>읽기 쉬운 코드란, 대부분 시스템 1의 패턴 인식으로 처리되고 시스템 2의 개입이 최소화되는 코드다.</p>\n<p>숙련된 개발자가 코드를 읽을 때, 익숙한 패턴은 시스템 1이 자동으로 처리한다. <code class=\"language-text\">for</code> 루프, <code class=\"language-text\">if-else</code> 분기, <code class=\"language-text\">map</code>/<code class=\"language-text\">filter</code>/<code class=\"language-text\">reduce</code> 체이닝, <code class=\"language-text\">try-catch</code> 블록 등 이런 것들은 수천 번 봐온 패턴이기 때문에 의식적 노력 없이 처리된다. 시스템 2는 편안한 저전력 모드에 머물면서, 시스템 1이 올려주는 정보를 승인하기만 하면 된다.</p>\n<p>그런데 갑자기 예상치 못한 패턴이 나타나면 상황이 달라진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 시스템 1이 처리 가능한 코드</span>\n<span class=\"token keyword\">const</span> canPurchase <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">>=</span> <span class=\"token number\">18</span> <span class=\"token operator\">&amp;&amp;</span> user<span class=\"token punctuation\">.</span>isVerified<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 시스템 2를 호출하는 코드</span>\n<span class=\"token keyword\">const</span> canPurchase <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&lt;</span> <span class=\"token number\">18</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>user<span class=\"token punctuation\">.</span>isVerified<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 코드는 같은 의도를 표현한다. 하지만 두 번째 코드를 보는 순간 뇌에서는 시스템 1이 “모르겠다”는 신호를 보내고, 시스템 2가 비싼 비용을 들여 분석을 시작한다. 이중 부정을 풀고, 드모르간 법칙을 머릿속에서 돌리고, 마지막 <code class=\"language-text\">undefined</code> 체크가 왜 필요한지를 따져봐야 한다. 이러한 전환 자체가 인지적 비용이다.</p>\n<p>카너먼은 이런 현상을 인지적 긴장이라 불렀다. 시스템 2가 개입할수록 뇌는 더 많은 에너지를 소비하고 피로감을 느끼게 된다. “읽기 어려운 코드”라는 주관적 느낌의 실체는 바로 패턴 매칭 실패로 인한 시스템 전환, 그리고 그에 따르는 인지적 비용이 발생하는 것이다.</p>\n<p>이 관점에서 보면, 코드 리뷰에서 “이해하기 어렵다”는 피드백은 단순한 취향 불만이 아니라, 인지 시스템의 전환 비용이 실제로 발생하고 있다는 신호에 가깝다. 그 비용의 크기는 개인의 경험과 청크 구성에 따라 다르겠지만, 비용이 발생한다는 사실 자체는 실재한다.</p>\n<h2 id=\"게슈탈트-원리-코드의-시각적-구조가-이해에-미치는-영향\" style=\"position:relative;\">게슈탈트 원리: 코드의 시각적 구조가 이해에 미치는 영향<a href=\"#%EA%B2%8C%EC%8A%88%ED%83%88%ED%8A%B8-%EC%9B%90%EB%A6%AC-%EC%BD%94%EB%93%9C%EC%9D%98-%EC%8B%9C%EA%B0%81%EC%A0%81-%EA%B5%AC%EC%A1%B0%EA%B0%80-%EC%9D%B4%ED%95%B4%EC%97%90-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5\" aria-label=\"게슈탈트 원리 코드의 시각적 구조가 이해에 미치는 영향 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>읽기 쉬운 코드에는 논리적 구조뿐만 아니라 시각적 구조도 중요하다. 여기서 게슈탈트 심리학의 지각 원리가 등장한다.</p>\n<p>게슈탈트 심리학은 인간의 뇌가 개별 요소가 아닌 전체 패턴과 구조를 우선적으로 인식한다는 점을 연구하는 분야다. 그 핵심 원리 몇 가지는 코드 가독성에 직접적으로 연결된다.</p>\n<h3 id=\"근접성의-원리\" style=\"position:relative;\">근접성의 원리<a href=\"#%EA%B7%BC%EC%A0%91%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"근접성의 원리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>가까이 있는 요소들은 하나의 그룹으로 인식된다. 한번 두 가지 버전의 코드를 살펴보며 이 그룹이 왜 중요한지를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 근접성 원리가 적용되지 않은 코드</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> user<span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> email <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> isValid <span class=\"token operator\">=</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'@'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> role <span class=\"token operator\">=</span> <span class=\"token function\">determineRole</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>permissions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dashboard <span class=\"token operator\">=</span> <span class=\"token function\">getDashboard</span><span class=\"token punctuation\">(</span>role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> notifications <span class=\"token operator\">=</span> <span class=\"token function\">getNotifications</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 근접성 원리가 적용된 코드</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> user<span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> email <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> isValid <span class=\"token operator\">=</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'@'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> role <span class=\"token operator\">=</span> <span class=\"token function\">determineRole</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>permissions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dashboard <span class=\"token operator\">=</span> <span class=\"token function\">getDashboard</span><span class=\"token punctuation\">(</span>role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> notifications <span class=\"token operator\">=</span> <span class=\"token function\">getNotifications</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 번째 버전에서 빈 줄 하나가 추가됐을 뿐인데 뇌는 자동으로 “사용자 정보 처리”와 “권한 기반 데이터 조회”라는 두 그룹을 인식한다.</p>\n<p>게슈탈트 연구에 따르면 근접성은 색상이나 형태의 유사성보다도 더 강력한 그룹핑 단서다. 이 원리는 UI 디자인에서도 그대로 사용되는데, 서로 연관이 있는 정보는 가까이 붙이고 연관이 없는 정보는 간격을 늘려 멀리 떨어트려놓는 것이 이 때문이다.</p>\n<p>마찬가지로 코드에서 빈 줄과 들여쓰기가 중요한 이유는 단순히 미관 때문이 아니라, 뇌의 지각 시스템이 그걸 기반으로 구조를 파악하기 때문이다.</p>\n<h3 id=\"유사성의-원리\" style=\"position:relative;\">유사성의 원리<a href=\"#%EC%9C%A0%EC%82%AC%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"유사성의 원리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>근접성과 마찬가지로 비슷하게 생긴 요소들도 같은 그룹으로 인식된다. 이것을 유사성의 원리라고 하는데, 이 원리는 코드에서 일관된 네이밍이 왜 중요한지를 설명한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 유사성 원리가 깨진 네이밍</span>\n<span class=\"token keyword\">const</span> userData <span class=\"token operator\">=</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> get_orders <span class=\"token operator\">=</span> <span class=\"token function\">retrieveOrderList</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> pmtHistory <span class=\"token operator\">=</span> <span class=\"token function\">loadPayments</span><span class=\"token punctuation\">(</span>uid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 유사성 원리가 적용된 네이밍</span>\n<span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> orders <span class=\"token operator\">=</span> <span class=\"token function\">fetchOrders</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> payments <span class=\"token operator\">=</span> <span class=\"token function\">fetchPayments</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 버전에서는 데이터 페칭이라는 같은 종류의 작업임에도 네이밍 규칙이 제각각이다. <code class=\"language-text\">userData</code>, <code class=\"language-text\">get_orders</code>, <code class=\"language-text\">pmtHistory</code>라는 변수명은 각각 다른 형태를 가지고, <code class=\"language-text\">fetchUser</code>, <code class=\"language-text\">retrieveOrderList</code>, <code class=\"language-text\">loadPayments</code>라는 함수명도 일관성이 없다. 뇌는 이런 코드를 보면 이들을 같은 그룹으로 인식하지 못하고 각 라인을 개별 항목으로 처리하면서 작업 기억을 소진한다.</p>\n<p>두 번째 버전에서는 패턴이 명확하다. <code class=\"language-text\">fetch + 리소스명</code>이라는 일관된 구조 덕분에, 세 줄이 “동일한 패턴의 데이터 패칭”이라는 하나의 청크로 인식된다.</p>\n<h3 id=\"연속성의-원리\" style=\"position:relative;\">연속성의 원리<a href=\"#%EC%97%B0%EC%86%8D%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"연속성의 원리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>연속성의 원리는 시선이 자연스럽게 흐르는 방향을 따라 요소들을 하나의 연속된 것으로 인식하는 원리다. 코드에서 이건 실행 흐름의 선형성과 관련된다.</p>\n<p>우리 뇌는 위에서 아래로, 왼쪽에서 오른쪽으로 흐르는 것을 자연스럽게 느낀다. 깊은 중첩, 복잡한 콜백, 여기저기 점프하는 <code class=\"language-text\">goto</code>문 등이 읽기 어려운 이유는 연속성의 원리를 위반하기 때문이다.</p>\n<p>우리가 얼리 리턴 패턴을 사용했을 때, 중첩된 <code class=\"language-text\">if</code>문보다 읽기 쉬운 이유도 마찬가지다. 예외 케이스를 먼저 걸러내고 나면 남은 코드는 위에서 아래로 한 방향으로 흐른다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 연속성이 깨지는 코드</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">,</span> product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>inStock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>onSale<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>salePrice<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Out of stock'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Inactive user'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 연속성이 유지되는 코드</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">,</span> product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>user<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Inactive user'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>product<span class=\"token punctuation\">.</span>inStock<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Out of stock'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>onSale<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>salePrice<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 버전은 들여쓰기가 깊어지면서 시선이 오른쪽으로, 다시 왼쪽으로 지그재그를 그린다. 뇌는 각 중첩 수준에서 “지금 어느 조건 안에 있는가”를 작업 기억에 유지해야 한다.</p>\n<p>반면 두 번째 버전은 예외를 먼저 걸러낸 뒤 위에서 아래로 자연스럽게 흘러내린다. 연속성의 원리에 부합하기 때문에 뇌가 구조를 파악하는 데 드는 비용이 크게 줄어든다.</p>\n<h2 id=\"인지-부하-이론-세-가지-부하의-종류\" style=\"position:relative;\">인지 부하 이론: 세 가지 부하의 종류<a href=\"#%EC%9D%B8%EC%A7%80-%EB%B6%80%ED%95%98-%EC%9D%B4%EB%A1%A0-%EC%84%B8-%EA%B0%80%EC%A7%80-%EB%B6%80%ED%95%98%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"인지 부하 이론 세 가지 부하의 종류 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여기까지의 이야기를 좀 더 체계적으로 정리해주는 프레임워크가 있다. 존 스웰러(John Sweller)의 <a href=\"https://ko.wikipedia.org/wiki/%EC%9D%B8%EC%A7%80_%EB%B6%80%ED%95%98\" target=\"_blank\" rel=\"nofollow\">인지 부하 이론</a>이다.</p>\n<p>이 이론에 따르면 학습이나 문제 해결 시 발생하는 인지 부하는 세 가지로 나뉜다.</p>\n<hr>\n<ol>\n<li><strong>내재적 부하</strong>: 과제 자체의 본질적 복잡성. 알고리즘의 난이도, 도메인의 복잡성 같은 것.</li>\n<li><strong>외재적 부하</strong>: 과제와 무관한, 표현 방식에서 오는 불필요한 복잡성. 일관되지 않은 네이밍, 불필요한 간접 참조, 혼란스러운 코드 구조 같은 것.</li>\n<li><strong>본유적 부하</strong>: 새로운 스키마를 형성하고 학습하는 데 드는 유익한 부하.</li>\n</ol>\n<hr>\n<p>이 이론에 따르면 우리가 읽기 쉬운 코드를 작성하기 위해 추구해야하는 것은 외재적 부하를 최소화하는 것이다.</p>\n<p>어차피 내재적 부하는 문제 자체에 내재된 것이니 줄일 수 없다. 예를 들어 분산 시스템의 합의 알고리즘을 구현하는 코드는 아무리 잘 써도 복잡할 수밖에 없는 것이다. 우리가 피해야할 문제는 “표현 방식”에서 오는 외재적 부하가 내재적 부하 위에 불필요하게 쌓일 때다.</p>\n<p>이 관점으로 보면 코드 가독성을 높이는 일관된 네이밍, 적절한 함수 분리, 명확한 타입 선언, 의미 있는 빈 줄과 같은 패턴은 결국 외재적 인지 부하를 줄이는 행위다. 뇌의 제한된 자원을 외재적 부하에 낭비하지 않고, 내재적 부하(실제 문제)를 처리하는 데 집중할 수 있게 해주는 것이다.</p>\n<p><a href=\"https://doi.org/10.1016/j.jss.2023.111619\" target=\"_blank\" rel=\"nofollow\">2023년에 발표된 체계적 문헌 리뷰</a>에서도 흥미로운 사실이 확인됐다. 소스 코드 메트릭과 실제 측정된 인지 부하 사이의 관계를 조사한 연구들에서 전통적 코드 메트릭 중 실제 인지 부하와 일관되게 높은 상관을 보인 것은 드물었고, 상관이 확인된 경우에도 과제 조건이나 측정 방식에 따라 결과가 달라지는 경향이 있었다. 즉, 우리가 “복잡도”라고 측정하는 것과 개발자의 뇌가 실제로 “복잡하다”고 느끼는 것은 다를 수 있다는 뜻이다.</p>\n<p>이건 의미심장한 결과다. 기계적으로 측정 가능한 메트릭은 코드의 외형적 복잡도를 포착하지만, 개발자의 뇌가 실제로 겪는 인지 부하는 패턴의 익숙함, 청킹의 효율성, 시각적 구조의 명확성과 같이 주관적 인식에 영향을 받는다는 것이다.</p>\n<h2 id=\"경험이-뇌를-물리적으로-바꾼다\" style=\"position:relative;\">경험이 뇌를 물리적으로 바꾼다<a href=\"#%EA%B2%BD%ED%97%98%EC%9D%B4-%EB%87%8C%EB%A5%BC-%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B0%94%EA%BE%BC%EB%8B%A4\" aria-label=\"경험이 뇌를 물리적으로 바꾼다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 전문가와 초보자의 뇌 활성화 패턴이 다르다고 했다. 이건 단순히 개발 짬바가 쌓이면 더 잘한다는 이야기가 아니다. <a href=\"https://www.nature.com/articles/s41598-024-56090-6\" target=\"_blank\" rel=\"nofollow\">2024년 Scientific Reports에 발표된 연구</a>에서는 62명의 파이썬 프로그래머를 대상으로 뇌파를 측정하며, 코드에 의도적으로 삽입한 문법 오류와 의미 오류에 대한 뇌의 반응을 관찰했다.</p>\n<p>결과는 놀라웠다. 숙련된 프로그래머는 코드의 문법적 위반과 의미적 위반에 대해 서로 다른 뇌파 패턴을 보였다. 이는 자연어를 읽을 때 문법 오류와 의미 오류에 대해 다른 뇌파가 나타나는 것과 유사한 패턴이다. 프로그래밍 경험이 뇌에 특정 언어와 패턴을 처리하기 위한 신경 회로를 형성한다는 뜻이다.</p>\n<p>다시 말해, 코딩 경험은 뇌의 물리적 구조를 변화시킨다. 신경가소성에 의해, 반복적으로 노출된 코드 패턴은 장기 기억에 스키마로 저장되고, 이 스키마가 청킹의 기반이 된다. 시스템 1이 코드를 자동으로 처리할 수 있는 것은 이런 스키마가 축적된 결과다.</p>\n<p>또한 스키마는 개인이 노출된 패턴에 따라 형성되기 때문에 같은 코드베이스에서 같은 패턴을 반복적으로 접한 사람들은 비슷한 스키마를 공유하게 된다. 이걸 뒤집어 생각하면 팀에서 일관된 코드 스타일을 유지하는 것은 취향의 문제가 아니라 팀원들의 뇌에 공유된 청크를 형성하는 과정인 셈이다. 코딩 컨벤션이 중요한 이유가 단순히 통일성이 아니라, 집단적 인지 효율성 때문인 것이다.</p>\n<h2 id=\"예측-부호화-뇌는-코드를-읽는-게-아니라-예측한다\" style=\"position:relative;\">예측 부호화: 뇌는 코드를 읽는 게 아니라 예측한다<a href=\"#%EC%98%88%EC%B8%A1-%EB%B6%80%ED%98%B8%ED%99%94-%EB%87%8C%EB%8A%94-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EB%8A%94-%EA%B2%8C-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%98%88%EC%B8%A1%ED%95%9C%EB%8B%A4\" aria-label=\"예측 부호화 뇌는 코드를 읽는 게 아니라 예측한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>최근 인지과학에서 주목받는 이론 중 하나는 예측 부호화다. 이 이론에 따르면, 뇌는 수동적으로 정보를 수신하는 게 아니라, 끊임없이 다음에 올 정보를 예측하고, 실제 입력이 그 예측과 다를 때만 추가적인 처리를 한다.</p>\n<p>코드를 읽을 때도 마찬가지다. 우리 뇌는 다음 줄에 뭐가 올지 끊임없이 예측한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUserProfile</span><span class=\"token punctuation\">(</span>userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>userId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 여기에 뭐가 올지, 이미 예측하고 있다</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 코드를 읽는 숙련된 개발자의 뇌는 이미 “뭐 이제 응답 데이터를 파싱해서 리턴하겠지”라고 예측하고 있다. 그리고 실제로 <code class=\"language-text\">return response.data;</code> 같은 코드가 나오면 그 예측이 맞았으므로 추가적인 인지 비용이 거의 발생하지 않는다.</p>\n<p>하지만 만약 예측과 전혀 다른 쌩뚱맞은 코드가 나오면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUserProfile</span><span class=\"token punctuation\">(</span>userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>userId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    globalEventBus<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'user-fetched'</span><span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 엥 이거 뭐임?</span>\n    localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">setItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lastUser'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 어라?</span>\n    analytics<span class=\"token punctuation\">.</span><span class=\"token function\">track</span><span class=\"token punctuation\">(</span><span class=\"token string\">'profile_view'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> userId <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 아 로깅을 왜 여기서 해</span>\n    <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">fetchUserProfile</code>이라는 이름에서 뇌가 예측한 것은 “사용자 프로필을 가져와서 돌려주는 함수”다. 그런데 이벤트 버스 발행, 로컬 스토리지 저장, 애널리틱스 추적이라는 예측 밖의 동작이 나타난다. 이때마다 뇌는 예측 오류 신호를 발생시키고, 시스템 2를 호출해서 이 코드가 왜 여기에 있는지를 분석하기 시작한다.</p>\n<p>즉, 우리가 두 번째 버전의 코드를 읽기 어렵다고 느끼는 이유는 함수의 이름은 <code class=\"language-text\">fetchUserProfile</code>이지만, 내부에서는 그와 전혀 상관없는 동작들이 발생하고 있기 대문이다. 이름이 설정한 예측과 실제 동작이 일치할수록 예측 오류가 줄어들고 인지 비용이 절감된다.</p>\n<p>이건 함수 내부뿐 아니라 인터페이스 설계에서도 마찬가지다. 필자와 같은 프론트엔드 개발자에게 익숙한 컴포넌트 인터페이스를 예시로 들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 예측 가능한 인터페이스</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">TextInput</span></span>\n  <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>setName<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">placeholder</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>이름을 입력하세요<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 예측이 어려운 인터페이스</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserNameInput</span></span>\n  <span class=\"token attr-name\">user</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">setUser</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>setUser<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">blank</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>이름을 입력하세요<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 컴포넌트는 <code class=\"language-text\">value</code>, <code class=\"language-text\">onChange</code>, <code class=\"language-text\">defaultValue</code>라는 React 생태계에서 거의 모든 입력 컴포넌트가 공유하는 인터페이스를 따른다. 이 패턴을 수없이 접해온 개발자의 시스템 1은 “입력 컴포넌트구나”로 처리하고 넘어간다.</p>\n<p>반면 두 번째는 <code class=\"language-text\">user</code>, <code class=\"language-text\">setUser</code>, <code class=\"language-text\">blank</code>라는 비즈니스 로직에 강하게 결합되었거나 의미를 알기 어려운 인터페이스를 가지고 있다. 이 컴포넌트가 내부에서 <code class=\"language-text\">user</code> 객체의 어떤 필드를 건드리는지, <code class=\"language-text\">blank</code>는 도대체 언제 사용되는 것인지 파악하기 전까지는 안심하고 사용할 수가 없다. 매번 내부 구현을 들여다봐야 하고, 그때마다 예측 오류가 발생한다.</p>\n<p>즉 읽기 쉬운 코드를 작성하기 위해서 우리는 함수의 이름 뿐 아니라 변수명, 파일 구조, 디렉토리 구성, API 설계 등 코드베이스의 모든 수준에서 예측 가능성을 높여야한다.</p>\n<h2 id=\"그래서-좋은-코드란-결국\" style=\"position:relative;\">그래서 “좋은 코드”란 결국<a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EA%B2%B0%EA%B5%AD\" aria-label=\"그래서 좋은 코드란 결국 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지의 내용을 정리해보면, “읽기 쉬운 코드”라는 주관적 느낌의 실체는 다음과 같다.</p>\n<hr>\n<ol>\n<li><strong>작업 기억을 초과하지 않는 코드</strong>: 동시에 머릿속에 담아야 할 맥락이 3~4개 이내인 코드</li>\n<li><strong>기존 청크와 매칭되는 코드</strong>: 익숙한 패턴을 사용해서 장기 기억의 스키마를 활용할 수 있는 코드</li>\n<li><strong>시스템 1에서 처리 가능한 코드</strong>: 시스템 2를 불필요하게 호출하지 않는, 패턴 인식만으로 이해 가능한 코드</li>\n<li><strong>시각적 구조가 논리적 구조와 일치하는 코드</strong>: 게슈탈트 원리에 부합하여 뇌의 지각 시스템이 구조를 자동으로 파악하는 코드</li>\n<li><strong>예측 가능한 코드</strong>: 이름과 구조에서 설정한 기대를 위반하지 않는 코드</li>\n<li><strong>외재적 인지 부하가 낮은 코드</strong>: 문제 자체의 복잡성만 남기고, 표현에서 오는 불필요한 복잡성을 제거한 코드</li>\n</ol>\n<hr>\n<p>이 목록을 보면 재밌는 사실을 하나 발견할 수 있다. 이 중 어느 것도 “정확한 코드”를 의미하지 않는다는 점이다.</p>\n<p>가독성과 정확성은 별개의 축이다. 완벽하게 정확하지만 읽기 불가능한 코드도 있고, 읽기는 쉽지만 틀린 코드도 있다. 다만 읽기 쉬운 코드는 버그를 발견하기도 쉽다. 외재적 부하가 낮으니, 뇌의 자원을 논리적 오류를 찾는 데 집중할 수 있기 때문이다.</p>\n<p>다만 한 가지 주의할 점이 있다. 카너먼은 시스템 1의 편향에 대해서도 경고했다. 시스템 1은 빠르지만, 그 속도의 대가로 편향이 존재한다. 대표적인 것이 익숙함 편향이다. 자신에게 익숙한 패턴을 “읽기 쉬운 코드”로 느끼는 것은 사실이지만, 그것이 객관적으로 최선인지는 별개의 문제다. 함수형 프로그래밍에 익숙한 개발자는 <code class=\"language-text\">for</code> 루프를 “읽기 어렵다”고 느낄 수 있고, 반대의 경우도 마찬가지다. 이때 “읽기 어렵다”는 느낌은 코드의 객관적 품질이 아니라, 자신의 시스템 1에 저장된 청크의 편향을 반영하는 것일 수 있다.</p>\n<p>코드 리뷰에서 “이해하기 어렵다”는 피드백을 줄 때, 한 번쯤 자문해볼 가치가 있다. 이게 정말로 인지 부하가 높은 코드인가, 아니면 단순히 내 시스템 1에 등록되지 않은 패턴인가? 전자라면 리팩토링이 필요하고, 후자라면 오히려 내 청크 라이브러리를 확장할 기회다.</p>\n<h2 id=\"마무리\" style=\"position:relative;\">마무리<a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>“읽기 쉬운 코드”는 그냥 느낌이나 취향의 문제가 아니다. 작업 기억의 용량 제한, 청킹 메커니즘, 이중 처리 시스템, 게슈탈트 지각 원리, 예측 부호화와 같은 인간의 인지 구조가 만들어내는 자연스러운 결과다.</p>\n<p>필자가 이전 글에서 “가독성은 주관적이다”라고 했던 이야기의 이유도 바로 여기에 있다. 청킹은 개인의 경험에 의존하고 시스템 1에 등록된 패턴은 사람마다 다르기 때문이다.</p>\n<p>같은 코드를 보고 누군가는 쉽다고 느끼고 누군가는 어렵다고 느끼는 건 그저 취향이 달라서가 아니라 뇌에 축적된 스키마가 다르기 때문이다. 가독성이 주관적일 수밖에 없는 이유 자체가 인지 구조에 내재되어 있는 셈이다.</p>\n<p>이상으로 우리는 왜 어떤 코드를 읽기 쉽다고 느낄까 포스팅을 마친다.</p>","fields":{"slug":"20260130-developer-intuition-readable-code-and-neuroscience","path":"/2026/01/30/developer-intuition-readable-code-and-neuroscience/","lang":"ko"},"frontmatter":{"title":"우리는 왜 어떤 코드를 읽기 쉽다고 느낄까","subTitle":"개발자의 직관과 코드 가독성, 그리고 뇌과학","date":"Jan 30, 2026","categories":["프로그래밍"],"tags":["뇌과학","가독성","인지심리학","DX"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/018bf68e64ee3bfca73cdc09a1144553/d803c/thumbnail.png","srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/d803c/thumbnail.png 320w,\n/static/018bf68e64ee3bfca73cdc09a1144553/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/fc5c5/thumbnail.webp 320w,\n/static/018bf68e64ee3bfca73cdc09a1144553/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/018bf68e64ee3bfca73cdc09a1144553/01fb2/thumbnail.png","srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"9bdc4240-2cf3-5832-b560-82aaa4d6ca20","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%A0%95%EB%8B%B5%EC%9D%84-%EC%B0%BE%EC%9C%BC%EB%A0%A4%EB%8A%94-%EB%85%B8%EB%A0%A5\">정답을 찾으려는 노력</a></p>\n<ul>\n<li><a href=\"#%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%B4-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EC%9A%94\">좋은 코드란 무엇일까요? 가독성이 좋은 코드요.</a></li>\n<li><a href=\"#%EC%84%B1%EC%9E%A5%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C%EC%9A%94\">성장하려면 어떻게 해야할까요?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B3%A0%EC%A0%95%EB%90%9C-%EC%A7%84%EB%A6%AC%EA%B0%80-%EC%95%84%EB%8B%8C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A7%A5%EB%9D%BD-%EC%86%8D%EC%97%90%EC%84%9C-%EB%B3%80%ED%99%94%ED%95%98%EB%8A%94-%EC%A7%84%EB%A6%AC\">고정된 진리가 아닌 다양한 맥락 속에서 변화하는 진리</a></p>\n<ul>\n<li><a href=\"#%EB%82%98%EC%9D%98-%EC%84%A0%ED%83%9D%EC%9D%B8%EA%B0%80-%ED%83%80%EC%9D%B8%EC%9D%98-%EA%B8%B0%EB%8C%80%EC%9D%B8%EA%B0%80\">나의 선택인가, 타인의 기대인가?</a></li>\n<li><a href=\"#%EB%82%98%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%B2%AB%EA%B1%B8%EC%9D%8C%EC%9D%B4%EB%8B%A4\">나를 이해하는 것이 첫걸음이다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"우리는 인생을 살아가며 수없이 많은 문제들과 마주친다. 당장 현실적인 부분들만 보아도 입시, 취업, 이직, 재테크, 커리어, 성장 등 다양한 미션을 만나게 되는데, 종종 사람들과 이에 대해 이야기를 나누다보면 마치 정답이 정해져있다는 것과 같은 이야기 혹은 정답이 있기를 바라는 것과 같은 이야기를 듣고는 한다.","html":"<p>우리는 인생을 살아가며 수없이 많은 문제들과 마주친다. 당장 현실적인 부분들만 보아도 입시, 취업, 이직, 재테크, 커리어, 성장 등 다양한 미션을 만나게 되는데, 종종 사람들과 이에 대해 이야기를 나누다보면 마치 정답이 정해져있다는 것과 같은 이야기 혹은 정답이 있기를 바라는 것과 같은 이야기를 듣고는 한다.</p>\n<!-- more -->\n<p>때로는 사회가 정답을 강요한다는 생각이 들기도 한다. “좋은 대학에 입학하면 인생이 필거야”, “행복하게 살려면 서울에 집 한 채는 있어야지”, “월 수입이 얼마는 되어야 중산층이지”와 같은 여러가지 조건과 기준들을 듣고 있자면, 내가 결정하는 것들이 정말 내가 결정하는 것이 맞는지 아니면 단순히 사회가 정해놓은 기준에 따라가고 있는 것인지 의문이 들 때가 있다.</p>\n<p>학생들은 지식을 얻고 탐구하고자 학습하는 것이 아닌, 다수가 외치는 정답을 맞추기 위해 학습한다. 그리고 이런 폐단은 학교 뿐 아니라 사교육에서도 동일하게 나타나며, 개발자들을 가르치는 여러 조직들 또한 크게 다르지 않다. 결국 고객들이 정답을 원하고 있으니 정답을 가르치는 것이 비즈니스 임팩트이기 때문이다.</p>\n<p>이렇게 사회가 제공하는 성공의 공식은 우리를 길들여왔다. 그래서 우리가 접하는 대부분의 문제들은 비정형적이고 정답이 없는 것들인 경우가 대부분이지만, 종종 우리는 문제를 만났을 때 마치 정답이 있을 것이라고 착각하고는 한다.</p>\n<p>이런 사회적 강요는 우리의 사고방식에도 깊은 영향을 미치며, 필자와 같은 개발자들 역시 예외는 아니다. 그래서 이번 포스팅에서는 이에 대해 필자가 평소 느꼈던 문제 의식에 대해 한번 풀어보고자 한다.</p>\n<h2 id=\"정답을-찾으려는-노력\" style=\"position:relative;\">정답을 찾으려는 노력<a href=\"#%EC%A0%95%EB%8B%B5%EC%9D%84-%EC%B0%BE%EC%9C%BC%EB%A0%A4%EB%8A%94-%EB%85%B8%EB%A0%A5\" aria-label=\"정답을 찾으려는 노력 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 필자와 같은 개발자들은 정답을 찾기 위해 노력하는 것이 익숙한 부류이다. 아무래도 논리를 다루는 직업의 특성 상, 명확한 근거를 기반으로 논리적으로 오류가 없는 의사 결정을 내리는 것에 익숙하기 때문이다.</p>\n<p>보통 개발자들이 외치는 정답은 대부분 코드의 형상과 관계에 초점이 맞춰져 있는데, 간혹 명확한 이유 없이 모노레포를 도입한다거나 전역 상태 관리 라이브러리 또는 메모이제이션과 같은 특정 메소드를 맥락 없이 도입하는 경우도 흔하다.</p>\n<p>하지만 앞서 이야기 했듯 현실은 그렇게 단순하지 않으며 많은 경우 “최선”이라는 것은 맥락과 상황에 따라, 혹은 해석하는 사람에 따라 다르게 정의된다.</p>\n<h3 id=\"좋은-코드란-무엇일까요-가독성이-좋은-코드요\" style=\"position:relative;\">좋은 코드란 무엇일까요? 가독성이 좋은 코드요.<a href=\"#%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%B4-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EC%9A%94\" aria-label=\"좋은 코드란 무엇일까요 가독성이 좋은 코드요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자는 어쩌다 보니 경력 초반인 지난 2016년부터 현재까지 꾸준히 인터뷰어로서의 경험을 쌓고 있는데, 아무래도 오랫동안 이 일을 하다보니 개인적으로 사용하는 질문 템플릿이 몇 가지 있다.</p>\n<p>그 중 하나는 “좋은 코드란 무엇일까요?”라는 질문이다. 이는 개인적으로도 오랫동안 고민해온 주제라 인터뷰를 통해 다양한 개발자들의 의견을 듣고 싶은 마음도 있다. 하지만 이런 질문을 던지면 신기하게도 굉장히 많은 분들이 “가독성이 좋은 코드”라는 답변을 해주시는데, 과장을 조금 보태자면 100명 중 99명은 이 답변을 주시는 것 같다.</p>\n<p>필자는 이 답변을 들을 때마다 묘한 어색함을 느끼는데, 가독성은 본질적으로 주관적이고 추상적인 개념이기 때문이다. 같은 코드를 보아도 누군가는 가독성이 좋다고 말할 수 있고, 누군가는 나쁘다고 말할 수 있는 것이니 말이다.</p>\n<p>물론 코드를 이집트 상형 문자로 표현하는 것보다 나에게 익숙한 언어로 표현하는 것이 이해하기 쉬운 것처럼 많은 사람들이 가독성이 높다고 공감할 수 있는 요소들은 존재할 수 있겠지만, 사실 우리가 이야기하는 가독성이라는 것이 이런 수준의 이야기를 하는 것이 아니라는 건 다들 알고 있을 것이다.</p>\n<p>애초에 전 세계에 존재하는 약 2,600만 명의 소프트웨어 개발자들이 모두 공감할 수 있는 기술적 요소라는 것이 존재할 수나 있는 것일까? 모두가 공감할 수 없는 가치라면 애초에 가독성이 좋은 코드라는 것이 세상에 존재하기는 하는 것인지에 대한 의심을 해봐야 하지 않을까?</p>\n<p>이런 마음을 담아 지원자에게 “가독성이 좋은 코드는 무엇인가요?”라는 질문을 던지면 이제부터 답변이 다양해진다. 누군가는 응집이나 결합을 강조하고, 누군가는 명확하고 직관적인 네이밍, 누군가는 관심사에 대한 이야기를 한다. 즉, 가독성이라는 것의 본질 전체를 꿰뚫는 정의가 아닌, 현실의 특정 사례를 예시로 들며 “이렇게 했을 때 가독성이 좋아집니다”와 같은 답변을 하는 경우가 많았다.</p>\n<p>결국 개발자마다 좋은 가독성을 달성하기 위해 가장 필요하다고 생각하는 부분이 모두 다르다는 것이며, 이 답변들이 오히려 가독성이라는 것이 얼마나 주관적이고 추상적이며 맥락 의존적인 것인지 드러내는 사례이다. 마치 같은 그림을 보면서도 누군가는 아름답다고 여기고 누군가는 도대체 뭘 표현하려는 것인지 모르겠다고 하는 것처럼 말이다.</p>\n<p>하지만 분명 많은 사람들은 “좋은 코드가 무엇인가?”에 대한 질문에 “가독성이 좋은 코드”라는 답변을 하고 있다. 마치 정답이 정해져 있기라도 한 것처럼 말이다.</p>\n<h3 id=\"성장하려면-어떻게-해야할까요\" style=\"position:relative;\">성장하려면 어떻게 해야할까요?<a href=\"#%EC%84%B1%EC%9E%A5%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C%EC%9A%94\" aria-label=\"성장하려면 어떻게 해야할까요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 본능은 비단 개발자 뿐 아니라, 우리가 일상에서 내리는 크고 작은 결정에서도 자주 드러난다. 필자는 종종 1-on-1, 멘토링과 같이 다른 개발자들의 고민을 듣고 도움을 드릴 수 있는 자리를 가지고는 하는데, 사실 이런 자리에서도 정답을 찾으려는 노력을 많이 보아왔다.</p>\n<p>이런 자리에서 주로 듣는 질문과 고민은 대략 이런 느낌이다.</p>\n<hr>\n<ul>\n<li>좋은 개발자가 되려면 어떻게 해야 하나요?</li>\n<li>ㅇㅇ 회사에 들어가려면 어떤 점을 채워야 할까요?</li>\n<li>나중에 이런 경험을 하고 싶은데, 그러면 어떻게 해야 하나요?</li>\n</ul>\n<hr>\n<p>물론 이런 질문을 하는 마음은 충분히 공감이 간다. 무언가를 달성하고 싶은 마음은 크지만 무엇을 해야 하는지는 모르겠을 때, 그 답답한 마음은 누구나 한번 쯤은 느껴보았을 것이다.</p>\n<p>사실 이런 질문을 던지는 분들은 분명 성장을 갈망하며 진심으로 더 나아지고 싶어한다. 하지만 문제는 성공이나 성장이라는 목표를 지나치게 정형화된 방법으로 접근한다는 점이다.</p>\n<p>그 결과 자신의 환경, 목표, 역량과 맞지 않는 보편적인 정답을 따라가다가 오히려 잘못된 방향으로 노력을 쏟는 경우를 자주 목격했다. 마치 내 몸에 맞지 않는 옷을 억지로 입으려고 하는 것처럼 말이다.</p>\n<p>행간에는 1만 시간의 법칙과 같이 무조건 노력하면 언젠가 원하는 바를 달성할 수 있다는 이야기도 있지만, 필자는 절대 여기에 동의하지 않는다. 노력과 시간이라는 것은 매우 한정된 자원이기 때문에 어디에 투자할 것인지가 매우 중요하기 때문이다. <small>(기껏 1만 시간을 투자했더니 알고보니 내 성장에 전혀 도움이 되지 않았던 곳이었다고 해도 날려버린 1만 시간은 두번 다시 돌아오지 않는다.)</small></p>\n<p>결국 중요한 것은 시간과 에너지를 어디에 투자할 것인가에 대한 방향성인데, 문제는 우리는  이 방향성을 스스로 결정했다고 믿지만, 사실 그 선택은 타인이나 사회가 제시한 기준에 의존한 결과일 때가 많다는 것이다.</p>\n<h2 id=\"고정된-진리가-아닌-다양한-맥락-속에서-변화하는-진리\" style=\"position:relative;\">고정된 진리가 아닌 다양한 맥락 속에서 변화하는 진리<a href=\"#%EA%B3%A0%EC%A0%95%EB%90%9C-%EC%A7%84%EB%A6%AC%EA%B0%80-%EC%95%84%EB%8B%8C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A7%A5%EB%9D%BD-%EC%86%8D%EC%97%90%EC%84%9C-%EB%B3%80%ED%99%94%ED%95%98%EB%8A%94-%EC%A7%84%EB%A6%AC\" aria-label=\"고정된 진리가 아닌 다양한 맥락 속에서 변화하는 진리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 사람은 누구나 안정성과 확실성을 추구하고 불확실한 상황을 불편해하는 심리적 기제를 지니고 있기 때문에 이러한 사고가 부자연스러운 것은 아니다. 오히려 정답이 없다고 믿는 것이 인간의 본능을 거스르는 행위일 수도 있다.</p>\n<p>그래서 앞서 언급한 가독성과 성장의 사례 또한 훌륭한 개발자가 되기 위해 갈망하고 공부하던 많은 사람들이 어떤 블로그, 책, 혹은 주변에 있는 개발자 등을 통해 퍼진 정보들을 비판 없이 흡수했을 가능성이 높다. 하지만 가독성이나 성장과 같은 문제는 정해진 정답이라는 것이 없다는 점을 간과해서는 안된다.</p>\n<p>철학에서는 이러한 문제를 탐구하기 위해 상대주의(Relativism)와 맥락주의(Contextualism) 같은 개념을 사용한다.</p>\n<p>상대주의는 진리나 가치는 보편적이지 않고, 특정 문화, 관점, 상황에 따라 달라진다는 것이며, 이는 가독성의 기준도 개인의 기준 혹은 개인이 처한 상황에 따라 달라질 수 있다는 것을 의미한다.</p>\n<p>맥락주의는 어떤 명제가 참인지 여부는 그것이 사용되는 맥락에 달려 있다는 것을 의미한다.</p>\n<p>예를 들어 동일한 코드라 하더라도, 팀의 문화나 프로젝트의 성격, 그리고 비즈니스 상황에 따라 그에 대한 평가가 달라질 수 있는 것처럼 말이다.</p>\n<p>많은 이들이 좋은 코드란 무엇인가에 대해 가독성 좋은 코드라는 답을 정답처럼 외치고 있지만, 이것은 고정된 진리가 아니라 다양한 맥락 속에서 변화하는 상대적인 개념인 것이다.</p>\n<p>물론 인터뷰라는 자리를 마치 인터뷰어가 생각하는 정답을 맞춰야하는 게임이라고 착각하시는 경우가 많기 때문에 다소 편향이 발생했을 수도 있지만, 비단 인터뷰 뿐만 아니라 멘토링이나 1-on-1과 같은 자리에서도 많은 분들이 비슷한 반응을 보였기 때문에 편향이 크지는 않다고 생각한다. <small>(독자 여러분도 당장 주변에 있는 개발자 아무나 10명만 붙잡고 “좋은 코드란 뭐라고 생각하심?”이라는 질문을 한번 던져보면 아마 높은 확률로 가독성 이야기가 나올 것이다)</small></p>\n<p>물론 우리가 굳이 기계어가 아니라 인간에게 익숙한 기호들로 추상화된 프로그래밍 언어를 사용하는 것은 결국 인간이 컴퓨터의 동작을 쉽게 이해하기 위함이니, 가독성이 좋은 코드라는 가치를 달성할 수만 있다면 더할 나위 없이 좋은 코드라고 부를 수 있음에는 이견이 없다.</p>\n<p>하지만 상황이나 맥락에 따라 다르게 판단될 수 밖에 없는 이 가독성이 좋다는 것이 도대체 무엇인지, 근본적인 진리에 대한 의문과 고찰없이 이런 답을 섣불리 내는 것은 프로그래밍 전문가로써 해서는 안될 행동이다.</p>\n<p>그렇다면 우리는 과연 무엇을 기준으로 본질적인 가치를 찾아야 하는 것일까?</p>\n<h3 id=\"나의-선택인가-타인의-기대인가\" style=\"position:relative;\">나의 선택인가, 타인의 기대인가?<a href=\"#%EB%82%98%EC%9D%98-%EC%84%A0%ED%83%9D%EC%9D%B8%EA%B0%80-%ED%83%80%EC%9D%B8%EC%9D%98-%EA%B8%B0%EB%8C%80%EC%9D%B8%EA%B0%80\" aria-label=\"나의 선택인가 타인의 기대인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>가장 먼저 나의 의사결정 또는 내가 옳다고 생각하는 무언가가 정말 내가 결정한 것이 맞는지에 대해 성찰하는 과정이 필요하다.</p>\n<p>앞서 여러 번 언급했듯이 우리는 집단주의 성향이 강한 문화권에서 살아가고 있기 때문에, 내가 스스로 결정했다고 믿는 것이 사실은 타인이나 사회의 기준에 의해 결정된 경우가 많다.</p>\n<hr>\n<ul>\n<li>다들 개발자 초봉은 n천만원이라고 하니, 나도 그 정도는 받아야지.</li>\n<li>요즘 AI가 대세라고 하니까 나도 AI를 공부해야겠다.</li>\n<li>대기업은 알고리즘을 본다고 하네. 그럼 오늘부터 성실하게 1일 1알고리즘 풀이를 해야겠다.</li>\n<li>집은 무조건 서울에 사야지.</li>\n<li>기술의 선두 주자가 되려면 미국으로 건너가야겠다.</li>\n</ul>\n<hr>\n<p>물론 필자도 알게 모르게 이런 생각을 많이 한다. 가장 최근에 했던 생각은 “비싼 수입차를 타면 내 인생에 대한 만족도가 조금은 올라가지 않을까”였는데, 처음에는 좋았지만 결국 3개월 정도 지나니까 익숙해져서 돈은 돈대로 쓰고 원했던 만족도는 얻지 못 했다.</p>\n<p>결국 이것 또한 사회에서 일반적으로 통용되는 성공의 상징을 취득하면 삶의 질이 올라갈 것이라 판단한 것이니, 필자 스스로의 의사결정이라기보다는 사회나 타인의 시선에 영향을 받은 상황이라고 볼 수 있다.</p>\n<p>그래서 이렇게 “A를 하려면 B를 해야한다”와 같은 논리가 머릿속에 떠올랐다면 대부분 정답이 아닌 경우가 많다. 더 정확히 말하자면 누군가에게는 정답일 수 있어도 나에게는 아닐 수 있기 때문에 한번 멈추고 성찰하는 과정이 필요한 것이다.</p>\n<h3 id=\"나를-이해하는-것이-첫걸음이다\" style=\"position:relative;\">나를 이해하는 것이 첫걸음이다<a href=\"#%EB%82%98%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%B2%AB%EA%B1%B8%EC%9D%8C%EC%9D%B4%EB%8B%A4\" aria-label=\"나를 이해하는 것이 첫걸음이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>정답은 사실 멀리 있는 것이 아니다. 정답을 찾기 위해서는 일단 나 스스로에 대한 깊은 이해가 필요하다.</p>\n<p>내가 무엇을 좋아하고, 어떨 때 기쁨을 느끼며, 어떤 순간에 슬픔을 느끼는 지 알아야 한다. 무엇을 할 때 가슴이 뛰는지, 어떤 일을 할 때 가장 몰입하는지를 돌아보아야 한다. 이런 자기 성찰이 뒷받침되지 않는다면, 우리는 쉽게 타인이나 사회가 정해준 기준에 휘둘릴 수밖에 없다.</p>\n<p>필자는 이것이 굉장히 중요한 요소라고 생각하는데, 안타깝게도 바쁘게 현생을 살다보면 외부의 문제에는 있는 힘껏 머리를 쓰면서도 정작 나에 대해서 돌아보고 생각해볼 기회는 많이 없는 것 같다.</p>\n<p>성찰이라고 하면 고루하고 어려운 이야기처럼 느껴질 수는 있지만, 사실 스스로에게 던지는 작은 질문부터 시작해보면 그리 어려운 것은 아니다.</p>\n<hr>\n<ul>\n<li>나는 어떤 상황에서 행복함을 느꼈을까?</li>\n<li>나는 회사를 왜 다니고 있지?</li>\n<li>나는 왜 개발자로 일하고 있지?</li>\n</ul>\n<hr>\n<p>결국 중요한 것은 내가 내리는 모든 결정이 진정 나의 의지에서 비롯된 것인지 점검하고, 내가 생각하고 결정한 것이 정말 내 몸에 맞는 옷이 맞는지를 확인하는 것이다.</p>\n<p>필자는 비싼 값을 치루고 수입차를 샀지만 결국 3개월 만에 익숙해져버려 원했던 만족감을 얻지 못 했다. 하지만 누군가는 동일한 행위를 해도 충분히 만족하면서 살아갈 수도 있다. 애초에 이 행위는 필자에 맞는 옷이 아니었던 것이다. <small>(하지만 또 팔기는 아까워서 아직 잘 타고 있다)</small></p>\n<p>정답은 멀리 있는 것이 아니라, 내 안에 있다. 비록 우리는 집단주의적 성향이 강한 사회 속에서 살아가지만, 오히려 이런 곳에서 나만의 기준을 세워가는 것이야말로 진정한 만족과 성취를 얻는 길이라고 할 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>실존주의 철학자 장폴 사르트르는 “우리는 스스로를 정의하며, 우리 존재의 의미는 우리가 만드는 것”이라고 말하며 인간이 자유롭게 선택할 수 있는 존재임과 동시에, 그 선택에 대한 책임을 져야 한다는 점을 강조했다.</p>\n<p>이는 우리의 선택이 타인의 기대가 아니라 스스로의 가치와 기준에서 나올 때, 진정으로 만족스러운 삶을 살 수 있음을 시사한다.</p>\n<p>물론 현생을 살기 위해서는 사회나 타인이 요구하는 여러 조건들을 맞춰야 하는 경우도 있다. 하지만 중요한 것은 스스로가 그 조건을 왜 맞춰야 하는지 인지하고 결정한 것이 맞냐는 것이다.</p>\n<p>좋은 코드는 가독성이 높은 코드라는 말, 좋은 개발자가 되기 위해서는 이런 저런 일을 해야한다는 타인의 말은 그저 수많은 데이터 중 하나일 뿐이다. 우리의 역할은 저 데이터를 그대로 받아들이는 것이 아니라 내 기준에 맞춰 정제하여 취할 것은 취하고 버릴 것은 버리는 것이다.</p>\n<p>그러니 데이터 자체가 정답이라고 믿는 것이 아닌 데이터를 재료로 하여 나만의 가치관과 철학을 만드는 과정에 대해 더 깊은 고민을 해보는 것을 추천한다.</p>\n<p>이상으로 정답이 존재한다는 착각 포스팅을 마친다.</p>","fields":{"slug":"20241223-the-illusion-of-a-right-answer","path":"/2024/12/23/the-illusion-of-a-right-answer/","lang":"ko"},"frontmatter":{"title":"좋은 코드란 무엇일까? - 가독성이란 허상에 대하여","subTitle":"개발자의 판단력을 흐리는 정답 강박에서 벗어나기","date":"Dec 23, 2024","categories":["에세이"],"tags":["실존주의","가독성"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/d8ae58549615ef582a117e086c2797bb/fc5c5/thumbnail.webp","srcSet":"/static/d8ae58549615ef582a117e086c2797bb/fc5c5/thumbnail.webp 320w,\n/static/d8ae58549615ef582a117e086c2797bb/e9225/thumbnail.webp 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/d8ae58549615ef582a117e086c2797bb/b384d/thumbnail.webp","srcSet":"/static/d8ae58549615ef582a117e086c2797bb/b384d/thumbnail.webp 750w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"가독성","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}