{"componentChunkName":"component---src-templates-posts-page-template-tsx","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"f58c9bb7-8172-534f-ac13-0b3c07a7a3cf","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%A1%B0%EC%A7%81%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%80-%EA%B0%9C%EC%9D%B8%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%B4-%EB%AA%A8%EC%97%AC-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A7%84%EB%8B%A4\">조직의 탁월함은 개인의 탁월함이 모여 만들어진다</a></p>\n<ul>\n<li><a href=\"#%ED%83%81%EC%9B%94%ED%95%9C-%EC%A1%B0%EC%A7%81%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">탁월한 조직이란 무엇인가</a></li>\n<li><a href=\"#10%EB%AA%85%EC%97%90%EC%84%9C-140%EB%AA%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\">10명에서 140명, 시스템의 필요성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A1%B0%EC%A7%81%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%ED%94%8C%EB%9D%BC%EC%9D%B4%ED%9C%A0%EC%9D%84-%EA%B5%B4%EB%A0%A4%EB%9D%BC\">조직의 탁월함을 만드는 플라이휠을 굴려라</a></p>\n<ul>\n<li><a href=\"#1%EB%8B%A8%EA%B3%84-%EC%9C%A0%EC%9E%85---%EC%84%B1%EC%9E%A5%EC%97%90-%EB%AF%B8%EC%B3%90%EC%9E%88%EB%8A%94-%ED%83%81%EC%9B%94%ED%95%9C-%EC%9D%B8%EC%9E%AC%EB%A5%BC-%EB%AA%A8%EC%9D%80%EB%8B%A4\">1단계: 유입 - 성장에 미쳐있는 탁월한 인재를 모은다</a></li>\n<li><a href=\"#2%EB%8B%A8%EA%B3%84-%EB%A9%94%ED%83%80%EC%9D%B8%EC%A7%80---%EC%A1%B0%EC%A7%81%EC%9D%98-%EA%B8%B0%EB%8C%80%EC%B9%98%EC%99%80-%EB%82%98%EC%9D%98-%EA%B0%95%EC%A0%90%EC%9D%84-%EA%B0%99%EC%9D%80-%EC%96%B8%EC%96%B4%EB%A1%9C-%EB%B0%94%EB%9D%BC%EB%B3%B8%EB%8B%A4\">2단계: 메타인지 - 조직의 기대치와 나의 강점을 같은 언어로 바라본다</a></li>\n<li><a href=\"#3%EB%8B%A8%EA%B3%84-%EA%B8%B0%ED%9A%8C%EC%A0%9C%EA%B3%B5---%EC%9E%91%EC%9D%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EC%84%B1%EC%9E%A5%EC%9D%84-%EA%B2%BD%ED%97%98%ED%95%98%EA%B2%8C-%ED%95%9C%EB%8B%A4\">3단계: 기회제공 - 작은 단위로 성장을 경험하게 한다</a></li>\n<li><a href=\"#4%EB%8B%A8%EA%B3%84-%EC%9D%B8%EC%A0%95---%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%8B%AC%EB%A6%AC%EC%A0%81-%EB%B3%B4%EC%83%81%EC%9C%BC%EB%A1%9C-%EC%84%B1%EC%B7%A8%EB%A5%BC-%EA%B2%BD%ED%97%98%ED%95%98%EA%B2%8C-%ED%95%98%EB%8B%A4\">4단계: 인정 - 물리적/심리적 보상으로 성취를 경험하게 하다</a></li>\n<li><a href=\"#5%EB%8B%A8%EA%B3%84-%EA%B8%B0%EC%97%AC---%EC%A2%8B%EC%9D%80-%EA%B2%BD%ED%97%98%EC%9D%B4-%EC%A1%B0%EC%A7%81%EC%9D%84-%ED%83%81%EC%9B%94%ED%95%98%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4\">5단계: 기여 - 좋은 경험이 조직을 탁월하게 만든다</a></li>\n<li><a href=\"#6%EB%8B%A8%EA%B3%84-%EB%B8%8C%EB%9E%9C%EB%94%A9---%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%84-%EC%99%B8%EB%B6%80%EB%A1%9C-%EC%95%8C%EB%A6%B0%EB%8B%A4\">6단계: 브랜딩 - 탁월함을 외부로 알린다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 필자가 지금까지 약 2년 반 정도 토스에서 프론트엔드 챕터 리드로 일하면서 고민해왔던 내용에 대해 이야기하려고 한다. 필자가 토스팀에서 챕터 리드로서 해야하는 일, 그리고 목표는 명확하다. 토스 프론트엔드 챕터를 세상에서 가장 탁월한 조직으로 만들어내는 것이다.","html":"<p>이번 포스팅에서는 필자가 지금까지 약 2년 반 정도 토스에서 프론트엔드 챕터 리드로 일하면서 고민해왔던 내용에 대해 이야기하려고 한다.</p>\n<p>필자가 토스팀에서 챕터 리드로서 해야하는 일, 그리고 목표는 명확하다. 토스 프론트엔드 챕터를 세상에서 가장 탁월한 조직으로 만들어내는 것이다.</p>\n<!-- more -->\n<p>이 탁월함에 대해서는 여러가지 정의를 할 수 있지만, 사실 중요한 것은 현재 상태에서 탁월함을 만들어내는 것보다 필자가 없어도 스스로 탁월함을 향해 나아갈 수 있는 조직이 되는 것이 핵심이라고 생각한다.</p>\n<h2 id=\"조직의-탁월함은-개인의-탁월함이-모여-만들어진다\" style=\"position:relative;\">조직의 탁월함은 개인의 탁월함이 모여 만들어진다<a href=\"#%EC%A1%B0%EC%A7%81%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%80-%EA%B0%9C%EC%9D%B8%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%B4-%EB%AA%A8%EC%97%AC-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A7%84%EB%8B%A4\" aria-label=\"조직의 탁월함은 개인의 탁월함이 모여 만들어진다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"탁월한-조직이란-무엇인가\" style=\"position:relative;\">탁월한 조직이란 무엇인가<a href=\"#%ED%83%81%EC%9B%94%ED%95%9C-%EC%A1%B0%EC%A7%81%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"탁월한 조직이란 무엇인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>탁월한 조직은 기본적으로 탁월한 개인들의 집합이라고 생각한다. 탁월한 개인이 모여 서로에게 자극을 주고 받으며 등을 맞대고 함께 일할 수 있는 조직이 되면 자연스레 조직의 탁월함도 만들어지기 때문이다. 실제로 토스 프론트엔드 챕터에는 복잡한 문제를 빠르게 이해하고, 우아한 해결책을 만들어내고, 서로를 성장시키는 탁월한 개발자들이 많이 있다.</p>\n<p>규모가 작은 조직을 리딩할 때는 명확한 기술 / 문화적 채용 기준을 수립하고 탁월한 인재들을 수집하는 것에 집중함으로서 조직의 탁월함을 만들어볼 수 있다. 그래서 필자가 전직장에 있을 때는 채용에 가장 공을 들였던 기억이 난다.</p>\n<p>그러나 토스 프론트엔드 챕터는 커뮤니티 기준으로 250명, 필자가 몸담고 있는 토스 코어 프론트엔드 챕터만 140명에 가까운 대조직이다. 이렇게 큰 조직을 리딩할 때는 작은 조직과는 조금 다른 접근 방법이 필요하다.</p>\n<p>이 정도로 조직이 크다면 탁월한 개인들을 모으는 것만으로는 충분하지 않다. 더 다양하고 많은 사람들이 모이게 되면서 조직이 이 사람들의 강점과 역량을 파악하고 탁월한 의사결정을 하는데 더 많은 에너지가 필요하기 때문이다.</p>\n<h3 id=\"10명에서-140명-시스템의-필요성\" style=\"position:relative;\">10명에서 140명, 시스템의 필요성<a href=\"#10%EB%AA%85%EC%97%90%EC%84%9C-140%EB%AA%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"10명에서 140명 시스템의 필요성 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>예전 프론트엔드 챕터가 10명 남짓이었을 시절에는 챕터원들이 서로에 대해 상세하게 파악하는 것이 가능했다. 인원이 적으니 얼굴도 이름도 성격도 알 수 있는 것이다.</p>\n<p>하지만 필자가 다시 토스로 돌아왔을 때, 프론트엔드 챕터는 이미 예전에 비해 엄청난 대조직이 되어있었다.</p>\n<p>같은 챕터라고 해도 어떤 사람이 있는지 모르는 경우도 있으며 심지어 특별히 관심을 쓰지 않으면 어떤 신규입사자가 들어왔는지도 모른다. 애초에 10명일 때와 140명일 때는 게임의 룰 자체가 다른 것이다.</p>\n<p>심지어 챕터 리드조차 특별하게 신경을 쓰지 않는다면 이 많은 인원의 강점, 성장 곡선, 동기를 파악하는 것이 굉장히 어렵다. 지금은 그래도 리드 개인의 노력으로 어느 정도 커버가 되는 수준이지만 만약 여기서 인원이 더 늘어난다면 이마저도 불가능한 순간이 분명히 올 것이다.</p>\n<p>개인에 대한 정보는 여러 명의 리드들의 머릿속에 파편화될 것이며, 리드와의 상호작용 여부에 따라 누군가는 더 잘 보이고 누군가는 덜 보이는 상황이 발생하게 될 것이 뻔하다.</p>\n<p>그래서 필자는 이 게임에서 리드의 역할이 “사람을 직접 케어하는 것”에서 “조직을 저절로 탁월하게 만드는 시스템을 구축하는 것”으로 변화해야한다고 생각했다.</p>\n<h2 id=\"조직의-탁월함을-만드는-플라이휠을-굴려라\" style=\"position:relative;\">조직의 탁월함을 만드는 플라이휠을 굴려라<a href=\"#%EC%A1%B0%EC%A7%81%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%ED%94%8C%EB%9D%BC%EC%9D%B4%ED%9C%A0%EC%9D%84-%EA%B5%B4%EB%A0%A4%EB%9D%BC\" aria-label=\"조직의 탁월함을 만드는 플라이휠을 굴려라 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 언급했듯이 탁월한 조직을 만드는 것의 핵심은 탁월함을 향해 저절로 굴러가는 조직을 설계하는 것이다. 이는 마치 제품 개발 개념에서 차용하는 <a href=\"https://brunch.co.kr/@b-rian/4\" target=\"_blank\" rel=\"nofollow\">플라이휠 효과</a>와도 유사하다.</p>\n<p>플라이휠 효과란 하나의 작은 임팩트들이 반복적으로 누적되며 점점 더 큰 성과를 만들어내는 구조를 말한다. 초기에는 많은 에너지가 필요하지만, 한 번 돌아가기 시작하면 관성에 의해 점점 적은 힘으로도 더 큰 성과를 만들어낸다.</p>\n<p>이와 마찬가지로 조직 운영에서도 개별 활동이 선순환 구조로 연결될 때, 탁월함은 자연스럽게 가속된다.</p>\n<p>필자가 설계한 탁월한 조직의 플라이휠은 크게 6단계로 구성된다.</p>\n<hr>\n<ol>\n<li><strong>유입</strong>: 성장에 미쳐있는 탁월한 인재를 모은다.</li>\n<li><strong>메타인지</strong>: 조직이 원하는 기대치, 현재 나의 상태를 파악한다.</li>\n<li><strong>기회제공</strong>: 준비가 되어있는 인재가 다음 성장을 작은 단위로 경험할 수 있는 기회를 제공한다.</li>\n<li><strong>인정</strong>: 성장을 만들어낸 인재들에게 물리/심리적 보상을 전달하여 인정과 성취의 경험을 제공한다.</li>\n<li><strong>기여</strong>: 좋은 경험을 한 인재들이 프론트엔드 챕터의 여러 활동에 참여하여 조직이 탁월해진다.</li>\n<li><strong>브랜딩</strong>: 이렇게 탁월해진 챕터의 활동을 정리하여 외부로 알린다.</li>\n</ol>\n<hr>\n<h3 id=\"1단계-유입---성장에-미쳐있는-탁월한-인재를-모은다\" style=\"position:relative;\">1단계: 유입 - 성장에 미쳐있는 탁월한 인재를 모은다<a href=\"#1%EB%8B%A8%EA%B3%84-%EC%9C%A0%EC%9E%85---%EC%84%B1%EC%9E%A5%EC%97%90-%EB%AF%B8%EC%B3%90%EC%9E%88%EB%8A%94-%ED%83%81%EC%9B%94%ED%95%9C-%EC%9D%B8%EC%9E%AC%EB%A5%BC-%EB%AA%A8%EC%9D%80%EB%8B%A4\" aria-label=\"1단계 유입   성장에 미쳐있는 탁월한 인재를 모은다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>탁월한 조직을 만들려면 탁월한 인재가 계속 들어와야 한다. 그런데 여기서 중요한 건 단순히 실력 있는 인재가 아니라 성장에 미쳐있고 성장 가능성이 높은 인재를 모으는 것이다.</p>\n<p>이를 위해 채용 단계에서 이런 분들을 찾아낼 수 있는 것도 중요하지만, 더 중요한 것은 브랜딩을 통해 외부에 있는 사람들이 “아, 저기에 가면 내가 더 성장할 수 있겠구나”라는 생각을 할 수 있도록 만들어 자연스레 토스팀에 더 많은 지원을 하는 그림을 만드는 것이다.</p>\n<p>토스 프론트엔드 챕터가 어떤 기술력을 가지고 있는지, 어떤 문화를 가진 조직인지를 구체적으로 보여줘야 한다. 이것이 바로 6단계 브랜딩이 다시 1단계 유입으로 연결되는 지점이다.</p>\n<h3 id=\"2단계-메타인지---조직의-기대치와-나의-강점을-같은-언어로-바라본다\" style=\"position:relative;\">2단계: 메타인지 - 조직의 기대치와 나의 강점을 같은 언어로 바라본다<a href=\"#2%EB%8B%A8%EA%B3%84-%EB%A9%94%ED%83%80%EC%9D%B8%EC%A7%80---%EC%A1%B0%EC%A7%81%EC%9D%98-%EA%B8%B0%EB%8C%80%EC%B9%98%EC%99%80-%EB%82%98%EC%9D%98-%EA%B0%95%EC%A0%90%EC%9D%84-%EA%B0%99%EC%9D%80-%EC%96%B8%EC%96%B4%EB%A1%9C-%EB%B0%94%EB%9D%BC%EB%B3%B8%EB%8B%A4\" aria-label=\"2단계 메타인지   조직의 기대치와 나의 강점을 같은 언어로 바라본다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자가 믿는 성장은 언제나 메타인지에서 출발한다. 그래서 탁월한 조직이 만들어내는 구성원들의 성장 또한 결국 구성원 각자가 자신의 역량과 강점을 얼마나 정확하게 인식하고 있는지에서 시작된다고 믿는다.</p>\n<p>이건 마치 삼국지 게임과도 비슷하다. 예를 들어 여포와 제갈량을 한번 생각해보자. 두 사람 모두 뛰어난 인재이지만 맞지 않는 역할이 주어지는 순간 그 탁월함은 사라진다. 여포에게 내정을 맡기거나, 제갈량에게 일기토를 시키면 좋지 않은 결과가 나올 것이 뻔하기 때문이다.</p>\n<p>문제는 현실에서는 자신이 여포인지 제갈량인지조차 모르는 경우가 많고, 혹은 여포임에도 내정을 하고 싶다고 말하는 경우도 있다. 이는 의지의 문제가 아니라 메타인지의 부족에 가깝다고 생각한다.</p>\n<p>그래서 필자는 탁월한 조직에서 만들어내는 성장의 첫걸음은 구성원들이 스스로의 역량과 강점을 제대로 인식하고, 그에 맞는 올바른 성장 기회를 얻는 것에서부터 출발한다고 생각한다.</p>\n<p>이런 생각에 연장선에서, 토스 프론트엔드 챕터에서는 스킬트리라는 도구를 활용하고 있다. 이 스킬트리는 탁월함을 규정하기 위한 장치라기보다는 구성원들이 자신의 현재 역량 상태와 강점을 더 선명하게 인식하고 다음 성장 방향을 스스로 언어화할 수 있도록 돕기 위한 참고선에 가깝다.</p>\n<p>그리고 자신의 성장 방향과 강점을 언어화할 수 있다면 이제 리드들은 이 정보를 바탕으로 각자의 강점이 실제 성과와 성장으로 이어질 수 있도록 코칭한다.</p>\n<h3 id=\"3단계-기회제공---작은-단위로-성장을-경험하게-한다\" style=\"position:relative;\">3단계: 기회제공 - 작은 단위로 성장을 경험하게 한다<a href=\"#3%EB%8B%A8%EA%B3%84-%EA%B8%B0%ED%9A%8C%EC%A0%9C%EA%B3%B5---%EC%9E%91%EC%9D%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EC%84%B1%EC%9E%A5%EC%9D%84-%EA%B2%BD%ED%97%98%ED%95%98%EA%B2%8C-%ED%95%9C%EB%8B%A4\" aria-label=\"3단계 기회제공   작은 단위로 성장을 경험하게 한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>메타인지가 이루어졌다면, 그 다음으로 조직이 해야 할 일은 명확하다. 구성원들이 부담 없이 도전하고, 작은 단위의 성공을 경험할 수 있는 기회를 제공하는 것이다. 아무리 자신의 강점과 현재 상태를 잘 인식하고 있어도, 실제로 시도해볼 수 있는 장이 없다면 성장은 관념에 머물 수밖에 없다.</p>\n<p>이 생각은 최근 진행한 리더십 설문조사를 통해 더 선명해졌다. 설문 결과를 보면 리더십 역할에 대한 관심은 생각보다 훨씬 많았다. 다만 많은 구성원들이 공통적으로 “관심은 있지만 아직 준비가 안 된 것 같다.”라고 답했다는 점이 특징이었다.</p>\n<p>처음에는 구성원들이 스스로의 역량이 부족하다고 느낀다고 생각했지만, 개별 응답을 더 분석해보니 오히려 “내가 무엇을 준비해야 하는지, 어떤 역량을 쌓아야 하는지 잘 모르겠다”에 더 가까웠다. 즉, 챕터가 성장의 방향성과 기준, 그리고 그 방법에 대한 힌트를 충분히 제공하지 못하고 있었던 것이다.</p>\n<p>그래서 필자는 이런 기회를 더 많이 만들고, 더 자주 노출해야 한다고 생각했다. 성장은 한 번의 큰 도약이 아니라, 여러 번의 작은 성공 경험 위에서 만들어지는 것이기 때문에 챕터원들이 부담없이 도전할 수 있는 환경을 만들어줘야한다.</p>\n<p>이런 문제의식에서 시작된 것이 Next F-Lead 프로그램이다. 이 프로그램은 전략적 사고, 인터뷰 스킬, 1 on 1 코칭이라는 세 가지 핵심 역량에 집중한다. 목표는 누군가를 갑자기 리드로 만드는 게 아니라, F-Lead의 역할을 작은 단위로 미리 경험해볼 수 있도록 돕는 데 있다. 이를 통해 구성원들은 “리더십이 나와는 먼 이야기”가 아니라 “조금씩 준비해볼 수 있는 다음 단계”라는 감각을 얻게 된다.</p>\n<p>Next F-Lead뿐만 아니라, 다양한 교육과 체험 프로그램을 통해 구성원들이 자신의 Next Step을 더 선명하게 그릴 수 있도록 노력하고 있다. 중요한 건 누군가를 특정 방향으로 밀어붙이는 게 아니라, 각자가 스스로 도전해보고 선택할 수 있는 환경을 만들어주는 것이라고 생각한다.</p>\n<p>작은 성공을 경험한 사람은 더 큰 도전을 상상할 수 있고, 그 상상은 다시 다음 성장을 향한 실제 행동으로 이어진다. 이것이 기회제공 단계가 플라이휠에서 중요한 이유다.</p>\n<h3 id=\"4단계-인정---물리적심리적-보상으로-성취를-경험하게-하다\" style=\"position:relative;\">4단계: 인정 - 물리적/심리적 보상으로 성취를 경험하게 하다<a href=\"#4%EB%8B%A8%EA%B3%84-%EC%9D%B8%EC%A0%95---%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%8B%AC%EB%A6%AC%EC%A0%81-%EB%B3%B4%EC%83%81%EC%9C%BC%EB%A1%9C-%EC%84%B1%EC%B7%A8%EB%A5%BC-%EA%B2%BD%ED%97%98%ED%95%98%EA%B2%8C-%ED%95%98%EB%8B%A4\" aria-label=\"4단계 인정   물리적심리적 보상으로 성취를 경험하게 하다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>성장은 경험만으로 완성되지 않는다. 성장을 만들어낸 사람에게는 반드시 인정이 따라와야 한다. 특히 긍정적인 피드백을 통한 보상은 조직 운영에서 과소평가되기 쉽지만, 실제로는 플라이휠을 다시 가속시키는 데 가장 중요한 요소 중 하나다.</p>\n<p>토스 프론트엔드 챕터 안에는 이미 자신의 강점을 드러내며 조직에 기여하고 있는 사람들이 많이 있다. 예를 들면 기술 공유를 꾸준히 하는 사람, 오픈소스 위원회나 코드 퀄리티 위원회 같은 활동에 참여하는 사람, 동료들이 더 잘 일할 수 있도록 도구를 만들어 공유하는 사람들이다.</p>\n<p>이런 기여들은 조직을 한 단계 끌어올리지만, 그 가치가 충분히 드러나지 않으면 당사자조차 자신의 성취를 체감하기 어렵다. 그래서 필자는 이들이 지금보다 더 자주, 더 분명하게 인정받아야 한다고 생각한다.</p>\n<p>리드 역할을 맡고 있는 사람들 역시 마찬가지다. 이들은 자신의 성과뿐 아니라 동료들의 성장을 바로 옆에서 돕는 역할을 수행한다. 조직 관점에서는 매우 중요한 역할이고, 개인 관점에서는 결코 가볍지 않은 책임이다. 실제로 해야 할 일도 많고, 고민해야 할 것도 많다. 필자에게 이들과 함께하는 매일은 감사의 연속이며, 이런 헌신은 반드시 보상받아야 한다.</p>\n<p>그래서 토스 프론트엔드 챕터에서는 이들을 위한 전용 리더십 교육 프로그램을 준비하고 있다. 단순한 교육을 넘어, 챕터의 의사결정에 더 깊이 참여할 수 있는 기회, 명시적인 권한과 역할의 확장도 함께 기획하고 있다. 이건 단순한 보상이 아니라 “당신의 성장은 조직이 진지하게 대하고 있다”는 명확한 메시지다.</p>\n<p>인정은 성과의 끝이 아니라 다음 성장을 시작하게 만드는 신호다. 성취를 경험한 사람은 다시 기여하고 싶어지고, 그 기여는 다시 조직을 탁월하게 만든다. 이것이 인정 단계가 플라이휠에서 빠질 수 없는 이유다.</p>\n<h3 id=\"5단계-기여---좋은-경험이-조직을-탁월하게-만든다\" style=\"position:relative;\">5단계: 기여 - 좋은 경험이 조직을 탁월하게 만든다<a href=\"#5%EB%8B%A8%EA%B3%84-%EA%B8%B0%EC%97%AC---%EC%A2%8B%EC%9D%80-%EA%B2%BD%ED%97%98%EC%9D%B4-%EC%A1%B0%EC%A7%81%EC%9D%84-%ED%83%81%EC%9B%94%ED%95%98%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4\" aria-label=\"5단계 기여   좋은 경험이 조직을 탁월하게 만든다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>인정을 받고 성취를 경험한 인재들은 자연스럽게 조직에 기여하게 된다. 그리고 이런 기여를 했을 때 앞서 4단계에서 언급한 샤라웃, 권한 확장, 의사결정 참여 같은 인정을 다시 받게 되면, 이런 행동은 자연스럽게 강화된다. 이것이 플라이휠의 핵심이다.</p>\n<p>필자는 지식의 공유, 새로운 아이디어와 피드백, 격렬한 토론 등이 자주 등장해야 탁월한 조직이 될 것이라 믿는다. 이런 것들이 바로 기여에 해당하고, 이런 기여들이 모여 결국 탁월한 조직이 된다.</p>\n<p>사실 토스 프론트엔드 챕터는 이런 기여들을 경험해본 적이 많은 조직이다.</p>\n<p>사람이 별로 없던 초반에는 사내 라이브러리 구축, TDS(Toss Design System) 개발, 어드민 개발 등이 이런 기여를 통해 진행됐다. 지금은 기술 관련 도구나 정보 공유, 오픈소스 위원회, 코드 퀄리티 위원회, Frontend Accelerator 멘토링 지원, 유저 접근성 개선 등으로 나타나고 있다.</p>\n<p>Next F-Lead를 수료한 리드들이 프로그램을 개선하고, 오픈소스 위원회에서 활동한 개발자들이 새로운 라이브러리를 제안하고, 스킬트리를 사용한 챕터원들이 피드백을 준다. 이 모든 것이 기여다.</p>\n<p>시스템은 개인에 의해 개선되고, 개선된 시스템은 다시 더 많은 개인을 탁월하게 만든다. 작은 플라이휠은 이미 돌아가고 있는 것이다.</p>\n<h3 id=\"6단계-브랜딩---탁월함을-외부로-알린다\" style=\"position:relative;\">6단계: 브랜딩 - 탁월함을 외부로 알린다<a href=\"#6%EB%8B%A8%EA%B3%84-%EB%B8%8C%EB%9E%9C%EB%94%A9---%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%84-%EC%99%B8%EB%B6%80%EB%A1%9C-%EC%95%8C%EB%A6%B0%EB%8B%A4\" aria-label=\"6단계 브랜딩   탁월함을 외부로 알린다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>마지막 단계는 브랜딩이다. 이렇게 탁월해진 챕터의 활동을 정리해서 외부로 알리는 것이다.</p>\n<p>현재 토스 프론트엔드 챕터는 오픈소스 위원회, Frontend Accelerator 멘토링, Frontend Fundamentals 문서 제작, 모닥불 유튜브 콘텐츠 등 다양한 활동을 통해 탁월함에 대한 브랜드를 구축해나가고 있다.</p>\n<p>예를 들어 오픈소스 위원회는 es-toolkit, es-hangul, overlay-kit 등 여러 라이브러리를 배출해냈는데, 특히 <a href=\"https://es-toolkit.dev/\" target=\"_blank\" rel=\"nofollow\">es-toolkit</a>의 경우 마이크로소프트와 같은 빅테크에서 사용하기도 했고, Storybook이나 yarn 같은 유명한 도구에서 채택되기도 했다. 현재는 주간 다운로드 수가 900만 건에 달한다.</p>\n<p>또한 <a href=\"https://frontend-fundamentals.com/code-quality/\" target=\"_blank\" rel=\"nofollow\">Frontend Fundamentals</a>와 Frontend Accelerator 멘토링은 프론트엔드 생태계를 더욱 성장시키는 것을 목표로 하는데, 이를 통해 더 탁월한 개발자들이 생태계 내에서 배출되고 이로 인해 토스팀에도 자연스럽게 탁월한 인재들이 유입되는 선순환을 기대하고 있다.</p>\n<p><a href=\"https://toss.tech/article/firesidechat_frontend_10\" target=\"_blank\" rel=\"nofollow\">모닥불 유튜브</a>와 같은 콘텐츠는 상대적으로 적은 비용으로 많은 개발자들에게 좋은 영향력을 만들어낼 수 있는 훌륭한 수단이다. 토스 프론트엔드 챕터가 어떤 기준으로 코드를 작성하는지, 챕터 내에 어떤 개발자들이 있는지 자연스럽게 보여주어 브랜딩 효과를 만들어낸다.</p>\n<p>이 모든 활동들은 “토스 프론트엔드 챕터는 탁월한 조직이다”라는 메시지를 외부에 전달하며, 이 메시지를 보고 성장에 미쳐있는 탁월한 인재들이 다시 토스팀으로 유입된다. 브랜딩이 잘 된다면 다시 1단계인 유입으로 이어지며 플라이휠이 완성된다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>리더로서 필자가 가장 중요하게 생각하는 것은 “내가 없어도 돌아가는 조직”을 만드는 것이다. 역설적으로 들릴 수 있지만, 이것이 진짜 지속 가능성이다.</p>\n<p>개인 의존성을 줄이고, 명확한 기준과 작동하는 시스템을 남기는 것. 필자가 휴가를 가거나, 다른 일에 집중하거나, 심지어 이 역할을 떠나더라도 플라이휠이 계속 돌아가도록 만드는 것. 그래서 필자는 지난 2년 반 동안 사람을 직접 케어하는 것이 아니라 조직을 저절로 탁월하게 만드는 시스템을 구축하는 데 집중해왔다.</p>\n<p>진짜 탁월한 조직은 탁월한 개인을 계속 만들어낼 수 있는 조직이다. 그리고 그 개인들이 다시 조직을 더 탁월하게 만드는 조직이다.</p>\n<p>사실 각 시스템은 아직 개선할 부분이 많다. 스킬트리는 더 정교해져야 하고, Next F-Lead는 더 많은 리드를 배출해야 하고, 인정 시스템은 아직 구축 중이다. 무엇보다 이 모든 것이 정말로 “조직을 더 탁월하게 만들고 있는가”에 대한 명확한 답은 여전히 찾아가는 중이다.</p>\n<p>하지만 방향은 맞다고 확신한다. 작은 성과들이 쌓이고 있고, 챕터원들의 피드백이 계속 들어오고 있으며, 무엇보다 작은 플라이휠은 실제로 돌아가고 있기 때문이다.</p>\n<p>조직 운영은 단기간에 답이 나오는 문제가 아니다. 하지만 명확한 방향성과 작동하는 시스템이 있다면, 시간이 지날수록 플라이휠은 더 빠르게 돌고 토스 프론트엔드 챕터는 지금보다 더 탁월한 조직이 될 것이라 믿는다.</p>","fields":{"slug":"20260124-leading-frontend-organization","path":"/2026/01/24/leading-frontend-organization/","lang":"ko"},"frontmatter":{"title":"조직의 탁월함은 사람으로 만들지만 지속성은 시스템이 만든다","subTitle":"개인 의존성을 줄이고 시스템을 남기는 플라이휠 설계","date":"Jan 24, 2026","categories":["에세이"],"tags":["리더십","조직문화","프론트엔드","챕터리드","토스프론트엔드"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/ad36c013dbd2031d00e50cb2530b0f09/d803c/thumbnail.png","srcSet":"/static/ad36c013dbd2031d00e50cb2530b0f09/d803c/thumbnail.png 320w,\n/static/ad36c013dbd2031d00e50cb2530b0f09/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/ad36c013dbd2031d00e50cb2530b0f09/fc5c5/thumbnail.webp 320w,\n/static/ad36c013dbd2031d00e50cb2530b0f09/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/ad36c013dbd2031d00e50cb2530b0f09/01fb2/thumbnail.png","srcSet":"/static/ad36c013dbd2031d00e50cb2530b0f09/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/ad36c013dbd2031d00e50cb2530b0f09/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"8944cbf8-b382-5ecf-85c2-2d8329cc62c5","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%98%84%EC%9E%AC-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%AA%A8%EB%A5%B4%EB%A9%B4-%EC%96%B4%EB%96%A4-%ED%8C%90%EB%8B%A8%EB%8F%84-%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\">현재 상태를 모르면, 어떤 판단도 할 수 없다</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%95%ED%99%95%ED%95%9C-%EC%88%AB%EC%9E%90%EB%B3%B4%EB%8B%A4-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%B6%94%EC%83%81%ED%99%94%EA%B0%80-%EB%A8%BC%EC%A0%80%EB%8B%A4\">정확한 숫자보다, 올바른 추상화가 먼저다</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%90%EC%82%B0%EC%9D%80-%ED%9D%90%EB%A6%84%EA%B3%BC-%EC%83%81%ED%83%9C%EB%A1%9C-%EC%9A%94%EC%95%BD%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\">자산은 흐름과 상태로 요약할 수 있다</a></p>\n<ul>\n<li><a href=\"#%ED%98%84%EA%B8%88-%ED%9D%90%EB%A6%84-%EC%A0%95%EB%B0%80%ED%95%9C-%EB%A1%9C%EA%B7%B8%EA%B0%80-%EC%95%84%EB%8B%8C-%EB%B9%84%EC%9C%A8%EC%9D%84-%EB%B3%B8%EB%8B%A4\">현금 흐름: 정밀한 로그가 아닌 비율을 본다</a></li>\n<li><a href=\"#%EC%9E%90%EC%82%B0-%EC%83%81%ED%83%9C-%EA%B7%9C%EB%AA%A8%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EB%B3%B8%EB%8B%A4\">자산 상태: 규모가 아니라 구조를 본다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%88%AC%EC%9E%90%EB%8A%94-%EC%88%98%EC%9D%B5%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%B0%94%EA%BE%B8%EB%8A%94-%EC%84%A0%ED%83%9D%EC%9D%B4%EB%8B%A4\">투자는 수익이 아니라 상태를 바꾸는 선택이다</a></p>\n<ul>\n<li><a href=\"#%EB%A6%AC%EC%8A%A4%ED%81%AC-%EA%B4%80%EB%A6%AC%EB%8A%94-%ED%8C%90%EB%8B%A8%EC%9D%84-%EB%B3%B4%ED%98%B8%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EC%84%A4%EA%B3%84%EB%8B%A4\">리스크 관리는 판단을 보호하기 위한 설계다</a></li>\n<li><a href=\"#%EA%B7%BC%EB%A1%9C%EC%86%8C%EB%93%9D%EC%9D%80-%EA%B0%80%EC%9E%A5-%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%ED%97%B7%EC%A7%95-%EB%A0%88%EC%9D%B4%EC%96%B4%EB%8B%A4\">근로소득은 가장 안정적인 헷징 레이어다</a></li>\n<li><a href=\"#%EC%95%88%EC%A0%84%EC%9E%90%EC%82%B0%EC%9D%80-%EC%A0%84%EB%9E%B5%EC%9D%84-%EA%B0%80%EB%8A%A5%ED%95%98%EA%B2%8C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B2%84%ED%8D%BC%EB%8B%A4\">안전자산은 전략을 가능하게 만드는 버퍼다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 기술적인 내용보다는 일상에 가까운 내용에 대해서 한번 이야기해보려고 한다. 바로 자산 관리에 대한 이야기이다. 일단 필자는 부자가 아니며, 일확천금을 만들어 낼 수 있는 투자 비법 같은 것이 있는 것도 아니다. 그렇기에 일반적인 직장인으로서 꾸준히 자산을 늘려갈 수 있는 방법에 대해서 오랫동안 고민해왔다는 점을 이야기하고 싶다.","html":"<p>이번 포스팅에서는 기술적인 내용보다는 일상에 가까운 내용에 대해서 한번 이야기해보려고 한다. 바로 자산 관리에 대한 이야기이다.</p>\n<p>일단 필자는 부자가 아니며, 일확천금을 만들어 낼 수 있는 투자 비법 같은 것이 있는 것도 아니다. 그렇기에 일반적인 직장인으로서 꾸준히 자산을 늘려갈 수 있는 방법에 대해서 오랫동안 고민해왔다는 점을 이야기하고 싶다.</p>\n<!-- more -->\n<p>물론 이미 사업이나 투자를 통해 큰 돈을 버신 분들이 보시기에는 다소 뻔한 이야기들일 수 있지만, 필자처럼 평범한 조건에서 자산을 관리해나가야 하는 사람에게는 충분히 공감할 수 있는 이야기라고 생각해, 필자 나름의 기준을 한번 정리해보려고 한다.</p>\n<h2 id=\"현재-상태를-모르면-어떤-판단도-할-수-없다\" style=\"position:relative;\">현재 상태를 모르면, 어떤 판단도 할 수 없다<a href=\"#%ED%98%84%EC%9E%AC-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%AA%A8%EB%A5%B4%EB%A9%B4-%EC%96%B4%EB%96%A4-%ED%8C%90%EB%8B%A8%EB%8F%84-%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\" aria-label=\"현재 상태를 모르면 어떤 판단도 할 수 없다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자산 관리를 하면서 필자가 가장 중요하게 생각하는 것 중 하나는, 현재 내가 어디에 서 있는지를 아는 것이다. 이를 위해 필자는 자산 데이터를 꾸준히 기록해왔다.</p>\n<p>처음부터 자산 관리를 잘할 수는 없다. 대부분은 시행착오를 겪고, 그 과정에서 조금씩 기준을 만들어간다. 그런데 지금 내 상태가 어떤지조차 알 수 없다면, 잘하고 있는지 아닌지를 판단하는 것 자체가 불가능하다.</p>\n<p>필자는 개발자로 일을 시작했던 2018년부터 매월 말 자산 스냅샷을 기록해오고 있다. 이렇게 쌓인 데이터는 지금에 와서는 자산의 변화 과정을 한눈에 보여주지만, 당시에는 오히려 혼란스러울 때도 많았다. 자산이 늘어난 달도 있었고, 예상보다 크게 줄어든 달도 있었다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ee3caeb1f1b5b18d2656441300609777/d698c/chart.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 43.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAq0lEQVR42q2QgQrDMAhE8/+/2zZGE3WnjlI6BoM1cFStvlxs/ugxb8+x1I3pOaAKudL2P9B0uU321beEtl9381myBOnYS3wgl29Aq4E13WSguSMWuJkJMTixqIXmqFp81x0Yi8Ut1QRQNnHtJ3KpoRMeWhfh+a0SwQDXTfkDYHu7TGnGV0XtrjDUjh3LBECEnYjSKDM7j5HxGOQzXAPSe89ehZOIgy0i51ycF6fjyeS7d8mWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"chart\" title=\"\" src=\"/static/ee3caeb1f1b5b18d2656441300609777/6af66/chart.png\" srcset=\"/static/ee3caeb1f1b5b18d2656441300609777/69538/chart.png 160w,\n/static/ee3caeb1f1b5b18d2656441300609777/72799/chart.png 320w,\n/static/ee3caeb1f1b5b18d2656441300609777/6af66/chart.png 640w,\n/static/ee3caeb1f1b5b18d2656441300609777/d9199/chart.png 960w,\n/static/ee3caeb1f1b5b18d2656441300609777/21b4d/chart.png 1280w,\n/static/ee3caeb1f1b5b18d2656441300609777/d698c/chart.png 1846w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>이렇게 데이터를 쌓아두면 시장에 어떤 이슈가 있을 때 내 자산이 어떻게 변동되는지, 월 자산 성장률은 어떻게 되는지, 5년 전에 비해 내 자산이 얼마나 늘어났는지 등을 한번에 볼 수 있다.</p>\n<p>기록을 남기면서 가장 자주 들었던 생각은 “이 방향이 맞는 걸까?”였다. 중요한 것은 자산이 오르거나 내린 사실 자체가 아니라, 그때마다 감정에 휘둘리지 않고 이전에 세워둔 판단 기준을 유지할 수 있었는지였다.</p>\n<p>지금의 수치는 결과적으로 보이는 숫자일 뿐이다. 필자에게 이 데이터의 진짜 가치는, 불확실한 상황 속에서도 현재의 선택이 과거의 판단과 얼마나 일관되어 있는지를 확인할 수 있었다는 점에 있다. 만약 이런 기록이 없었다면, 필자는 중간 어딘가에서 방향을 잃었을 가능성이 크다.</p>\n<p>그래서 필자는 자산 관리에서 데이터를 미래를 예측하기 위한 도구로 사용하지 않는다. 다만 지금 내가 어디에 서 있는지를 확인하고, 판단의 기준이 흐트러지지 않았는지를 점검하기 위한 용도로 활용할 뿐이다.</p>\n<h2 id=\"정확한-숫자보다-올바른-추상화가-먼저다\" style=\"position:relative;\">정확한 숫자보다, 올바른 추상화가 먼저다<a href=\"#%EC%A0%95%ED%99%95%ED%95%9C-%EC%88%AB%EC%9E%90%EB%B3%B4%EB%8B%A4-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%B6%94%EC%83%81%ED%99%94%EA%B0%80-%EB%A8%BC%EC%A0%80%EB%8B%A4\" aria-label=\"정확한 숫자보다 올바른 추상화가 먼저다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 금융이나 자산 관리에서 데이터가 중요하다는 점은 이미 많은 사람들이 알고 있다. 그 출발점으로 가장 많이 선택되는 것이 바로 가계부다. 수입과 지출을 기록하면서 내 현금 흐름이 어떻게 움직이는지를 확인하는 것은 분명 의미 있는 일이다.</p>\n<p>문제는 이 가계부라는 도구가 생각보다 오래 가지 않는다는 데 있다. 매달 수십, 수백 건에 달하는 소비 내역을 하나하나 분류하고, 어디에 얼마를 썼는지 정확히 맞추려다 보면 어느 순간부터 부담이 된다. 계산이 조금이라도 어긋나면 괜히 신경이 쓰이고, 기록이 밀리기 시작하면 아예 손을 놓게 된다. 필자 역시 이런 과정을 몇 번 반복하다가 가계부를 꾸준히 쓰는 것은 포기했다.</p>\n<p>근데 잘 생각해보면 문제를 약간 다르게 볼 수 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 270px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f12412c188bfb126bc3bedd4b1a1c470/01bf6/um.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsTAAALEwEAmpwYAAADWElEQVR42hXLWVMaBwAA4H3v9MFkak0y1IRqwn3usrALy6IcAgsGXEFEQY5ExAtBIHIsyABOgYDGEEysIZomBklaNaRmTNpp69jmpTN5aP9P7ff+AT+/PtiurtaygUrKV0p4SwlPLEBiEi4svAmBHBHIk8AiFJUocQRXoTAsYjL7uHwWYVBnYneBD53jRpmqZf7P8emRtbh7bsosETFgMYMvZEESoUIhRVCpHEOlKCyCBHwBm8NjgiKOSYsCnYPWk1r2ftpfSfqWvOZibCIwqZdCLDbzulLMuDeOF31DWY8u6tQ6jXJMJr7F6L/F7KN/SwN5N4HW7k6jnFrPTidmR60aJOw3Z0K2xYDNYVUGTeBdg3jBwM7ZwXmCHxmRUDaYxJjd3V1Xr3zV090FHL7ab5Soh/nZCYsKEvRRIVtueTyX8KUj43nP4LQepMYVNS8+S0BBAq55scIEyqJdIoW9LNplYG/nUaNCbWRnXKTKPizPhMcucibmSSw5N0Pmx8GBd1nHYcaxtUB8vzTcDJsiVghh9ES1rDG1EPj4/mS7mi2n/YWYi1CDi3dMhfjkRc7Ep0rzxotc9alLblUzPNwIanM2cMYgmFIyEiMyJyEF3r45qJcTD/LBdcrvtWuoiGM1PEZF3dl7nvtRO+WQkSjDpxN858HLbjQ5Kg6axAu3kSkT7CBkwIunW/VKOjLndLtHjtqPzz/sHe9X27vlp/VUmZrRgTSXnO1CWHasP+uAly0i75BwzKIhjYjrtgIorCaHSSumNwiVgyvp0N9nrV+On2wU53/cKyaX7yjZX09iDLukL24VmCW9OKfHYwBDc/6A1xZ0GoABwiRVqZX6IcJuUenwo9b62UmzXlrqvCq3dysQl87q7eLQL+uhG8yrX2Lcazu1HJWK59JznR+qgACRgxiOaNTGUVKC4/l86NPp83opfPrmwec/9u02E/2bK7z+a7RLXyh414vp5aPWHukgGxup8/dNAFYNQkoVPDCIE3pEqwvOu387eba5FvrpeemfP9ubtUw/j6vDYbsRX8tET9++Tq2k1YShs7/5e6cJ3GCwGXwBqtFoLRY6i2226j+fH27XVtrNwr+fDv/6+JJ0OmRKxdyMb+vhenwlLh3QJpOLZ++e/Xq88x9ZGD9eANmthgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"um\" title=\"\" src=\"/static/f12412c188bfb126bc3bedd4b1a1c470/01bf6/um.png\" srcset=\"/static/f12412c188bfb126bc3bedd4b1a1c470/69538/um.png 160w,\n/static/f12412c188bfb126bc3bedd4b1a1c470/01bf6/um.png 270w\" sizes=\"(max-width: 270px) 100vw, 270px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>꼭 정확해야할 필요가 있나...?</small>\n</center>\n<p>문제의 핵심은 기록을 안 한 데 있는 것이 아니라, 정확해야 한다는 전제를 너무 당연하게 받아들였다는 점에 있었던 것 같다. 우리가 개인 자산을 관리하면서 회계 결산이나 세무 신고를 하는 것도 아닌데, 원 단위까지 맞아떨어지는 데이터가 과연 필수적일까 하는 의문이 들었다.</p>\n<p>필자가 생각하기에 개인 자산 관리에서 더 중요한 것은 정밀한 숫자가 아니라, 금융이라는 복잡한 현실을 판단 가능한 수준으로 단순화해서 바라볼 수 있는가에 가깝다. 이 점에서 자산 관리는 개발자가 복잡한 시스템을 다루는 방식과 꽤 닮아 있다.</p>\n<p>우리는 프로그램을 작성할 때 메모리 주소를 직접 다루지 않는다. 비트 단위의 연산으로 모든 것을 해결하려고도 하지 않는다. 대신 변수와 타입, 인터페이스 같은 추상화된 개념을 사용한다. 세밀한 제어를 일부 포기하는 대신, 전체 구조를 이해하고 더 나은 판단을 내릴 수 있는 여지를 확보하기 위해서다.</p>\n<p>자산 관리에서도 비슷한 일이 벌어진다고 생각한다. 모든 소비를 정확히 분해하고 분류하다 보면 오히려 판단은 느려지고, 감정이 개입될 여지는 커진다. 반대로 몇 개의 핵심 지표로 구조를 요약해두면, 지금 상태가 위험한지, 유지 가능한지, 혹은 공격적인 선택을 해도 되는지에 대한 판단을 훨씬 빠르게 내릴 수 있다.</p>\n<p>결국 자산 관리에서 추상화가 중요한 이유는 귀찮음을 피하기 위해서가 아니라, 판단의 기준을 단순하게 만들기 위해서다. 어디에 1,000원을 더 썼는지보다 중요한 것은 지금 내가 재정적으로 안전한 상태인지, 현재의 현금 흐름이 지속 가능한 구조인지, 그리고 원하는 목표에 도달하기 위해 어떤 선택지를 가지고 있는지다.</p>\n<p>필자는 자산 관리가 숫자를 얼마나 정확하게 맞추느냐의 문제가 아니라, 불확실한 상황에서도 흔들리지 않을 기준을 세우는 과정이라고 생각한다. 그리고 그 기준은 언제나 정밀한 데이터가 아니라, 잘 설계된 추상화 위에서 만들어진다.</p>\n<h2 id=\"자산은-흐름과-상태로-요약할-수-있다\" style=\"position:relative;\">자산은 흐름과 상태로 요약할 수 있다<a href=\"#%EC%9E%90%EC%82%B0%EC%9D%80-%ED%9D%90%EB%A6%84%EA%B3%BC-%EC%83%81%ED%83%9C%EB%A1%9C-%EC%9A%94%EC%95%BD%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\" aria-label=\"자산은 흐름과 상태로 요약할 수 있다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 자산 관리는 정밀도의 문제가 아니라 추상화의 문제라고 이야기했다. 그렇다면 개인 자산을 판단 가능한 수준으로 추상화하기 위해서는 어떤 정보들이 필요할까?</p>\n<p>이러한 거시적인 판단들을 내리기 위해 필요한 정보는 생각보다 많지 않은데, 크게는 자산의 흐름과 현재 상태 데이터, 이 두 가지만으로 충분하다.</p>\n<p>이는 마치 기업의 재무제표에 포함되는 현금 흐름표와 재무 상태표와도 유사하다. 기본적으로는 이 두 가지 표만 봐도 해당 기업이 돈을 어떻게 썼고 어떻게 벌었는지, 현재 재무 상태는 어떠한지와 같은 주요 정보들을 빠르게 이해할 수 있다.</p>\n<p>개인의 자산 관리도 크게 다르지 않다고 생각한다. 개인이 기업처럼 복잡한 회계를 할 필요는 없지만, 최소한 지금 돈이 어떤 경로로 들어오고 나가는지, 그리고 현재 자산이 어떤 형태로 구성되어 있는지는 알고 있어야 한다.</p>\n<p>자산의 흐름은 현금 흐름 데이터를 통해 확인할 수 있다. 이번 달에 얼마를 벌었고, 얼마를 썼는지, 그 결과 얼마가 남았는지를 보는 것이다. 이 데이터는 자산 관리의 속도와 방향성을 결정한다. 흐름이 건강하지 않다면 자산은 언젠가 정체되거나 줄어들 수밖에 없다.</p>\n<p>반면 자산의 상태는 스냅샷 데이터로 확인한다. 지금 당장 가용 가능한 현금은 얼마인지, 자산이 어떤 형태로 어디에 묶여 있는지, 부채는 어느 정도인지와 같은 정보들이다. 이 데이터는 현재 내가 감당할 수 있는 리스크의 범위를 보여준다.</p>\n<p>중요한 점은 이 두 데이터 모두 아주 정확할 필요는 없다는 것이다. 개인 자산 관리에서 필요한 것은 숫자의 정밀함이 아니라 구조에 대한 감각이다. 이번 달 지출이 정확히 얼마였는지보다, 대략적인 수입 대비 지출 비율이 어떤지 아는 것이 더 중요하다. 마찬가지로 자산의 현재 가치가 몇 만원 단위까지 맞아떨어지는지보다, 유동성이 높은 자산과 낮은 자산이 어떤 비율로 구성되어 있는지를 아는 것이 더 의미 있다.</p>\n<p>이렇게 흐름과 상태를 분리해서 바라보면, 자산 관리가 훨씬 단순해진다. 흐름이 안정적인지, 상태가 과도한 리스크를 내포하고 있지는 않은지. 이 두 가지 질문에만 답할 수 있어도 대부분의 중요한 의사결정은 가능하다.</p>\n<p>필자는 자산 관리를 하면서 더 많은 데이터를 보려고 애쓰기보다는, 이 두 가지 정보를 꾸준히 확인하는 데 집중해왔다. 그 결과 시장 상황이 바뀌어도, 자산의 규모가 커져도, 판단의 기준 자체는 크게 흔들리지 않았다.</p>\n<p>이제부터는 이 두 가지 정보를 각각 어떻게 바라보고 관리하고 있는지에 대해 조금 더 구체적으로 이야기해보려고 한다. 먼저 현금 흐름부터 살펴보자.</p>\n<h3 id=\"현금-흐름-정밀한-로그가-아닌-비율을-본다\" style=\"position:relative;\">현금 흐름: 정밀한 로그가 아닌 비율을 본다<a href=\"#%ED%98%84%EA%B8%88-%ED%9D%90%EB%A6%84-%EC%A0%95%EB%B0%80%ED%95%9C-%EB%A1%9C%EA%B7%B8%EA%B0%80-%EC%95%84%EB%8B%8C-%EB%B9%84%EC%9C%A8%EC%9D%84-%EB%B3%B8%EB%8B%A4\" aria-label=\"현금 흐름 정밀한 로그가 아닌 비율을 본다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>자산의 흐름을 파악한다는 것은, 결국 내가 한 달 동안 얼마를 벌었고 그중 얼마를 남겼는지를 확인하는 일에 가깝다. 흔히 현금 흐름을 관리한다고 하면 가계부를 떠올리지만, 필자는 가계부를 쓰는 방식이 반드시 정답이라고 생각하지는 않는다.</p>\n<p>가계부의 목적은 어디에 얼마를 썼는지를 정확히 기록하는 데 있다기보다는, 내 수입과 지출의 구조를 이해하는 데 있다. 그런데 많은 경우 이 목적과 수단이 뒤바뀐다. 기록 자체가 부담이 되기 시작하면, 흐름을 이해하기는커녕 기록을 유지하는 것조차 어려워진다.</p>\n<p>그래서 필자는 현금 흐름을 관리할 때 세부 지출 항목보다는 훨씬 단순한 기준을 사용한다.</p>\n<table>\n<thead>\n<tr>\n<th>대카테고리</th>\n<th>중카테고리</th>\n<th>카테고리</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>수입</td>\n<td>근로</td>\n<td>급여</td>\n</tr>\n<tr>\n<td></td>\n<td>근로</td>\n<td>사업</td>\n</tr>\n<tr>\n<td></td>\n<td>부채</td>\n<td>대출</td>\n</tr>\n<tr>\n<td></td>\n<td>투자</td>\n<td>배당금</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>매도금</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>이자</td>\n</tr>\n<tr>\n<td>지출</td>\n<td>소비</td>\n<td>개인소비</td>\n</tr>\n<tr>\n<td></td>\n<td>고정비</td>\n<td>보험</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>통신비</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>공과금</td>\n</tr>\n<tr>\n<td></td>\n<td>주거</td>\n<td>집세</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>관리비</td>\n</tr>\n</tbody>\n</table>\n<p>이때 이 카테고리에는 어떤 정답도 없다. 중요한 것은 남들도 이렇게 하니까 따라 하는 것이 아니라, 내가 어떤 데이터를 보고 싶어서 이렇게 나눴는지다.</p>\n<p>예를 들어 필자의 경우 수입에서는 근로와 투자를 구분해두었고, 지출에서는 고정비와 주거를 따로 떼어두었다. 불로소득의 비중이 어느 정도인지, 소득 대비 주거 비용이 얼마나 되는지를 알고 싶었기 때문이다. 만약 이런 정보가 필요 없다면, 소비를 하나의 카테고리로 묶어도 전혀 문제 없다.</p>\n<p>이렇게 대략적인 흐름만 정리해두어도, 한 달 동안 내가 얼마나 벌었고 그중 얼마를 남겼는지는 충분히 파악할 수 있다.</p>\n<p>이렇게 캐시 플로우를 정리하는 것만으로도 많은 정보들을 알 수 있지만 필자가 생각했을 때 가장 중요한 데이터는 바로 이익률, 즉 한 달 수입 중 대략 몇 퍼센트를 남기고 있는지다.</p>\n<p>이 하나의 숫자는 생각보다 많은 정보를 담고 있다. 수입이 늘고 있는지, 지출이 과도한지, 혹은 현재의 생활 수준이 자산 증가 속도에 비해 과한지를 직관적으로 보여준다. 어디에 5만 원을 더 썼는지는 몰라도, 이번 달에 수입의 30%를 남겼는지 50%를 남겼는지는 분명히 알 수 있다.</p>\n<p>참고로 2025년 기준 대한민국 가계의 평균 소득 대비 소비 비율은 약 67% 수준이다. 즉, 평균적으로는 소득의 약 3분의 1 정도를 남기고 있다는 의미다. 대출 원금과 이자까지 포함하면 실제로 체감되는 지출 비율은 이보다 더 높다. 이 수치는 절대적인 기준이라기보다는, 내 현금 흐름이 사회 평균 대비 어느 지점에 있는지를 가늠하기 위한 참고선 정도로 보면 된다.</p>\n<p>이 수치는 절대적인 기준이라기보다는, 내 현금 흐름이 사회 평균 대비 어느 지점에 있는지를 가늠하기 위한 참고선에 가깝다.</p>\n<p>만약 평균을 기준으로 삼는다면, 소득의 30% 이상을 남기고 있다면 최소한 구조적으로 크게 무리한 상태는 아닐 가능성이 높다. 물론 개인의 상황에 따라 이 수치는 얼마든지 달라질 수 있다. 중요한 것은 정확한 퍼센트가 아니라, 내 현금 흐름이 어떤 방향으로 움직이고 있는지를 지속적으로 확인하는 것이다.</p>\n<p>물론 가계부처럼 지출 내역을 세세하게 분석하는 접근이 의미 없다고 생각하지는 않는다. 지출을 줄이기 위해서는 어디에 돈이 새고 있는지를 아는 것이 필요할 수도 있다. 다만 필자는 지출을 줄이는 것보다, 수입 구조를 개선하는 데 먼저 집중하는 편이 낫다고 생각한다.</p>\n<p>어차피 지출을 줄이는 데에는 명확한 한계가 있기 때문이다. 월세를 안 낼 수는 없고, 생활비를 완전히 없앨 수도 없다. 아무리 절약해도 도달할 수 있는 최소치는 정해져 있다.</p>\n<p>반면 수입은 구조에 따라 얼마든지 확장될 수 있다. 연봉 인상이나 이직, 투자 수익, 배당 소득, 부업처럼 수입의 경로를 하나씩 늘려가는 것은 시간이 걸리더라도 상방이 열려 있다. 이 차이는 단순히 금액의 문제가 아니라, 장기적으로 유지 가능한 전략인지의 문제라고 생각한다.</p>\n<p>그래서 필자가 현금 흐름에서 가장 중요하게 보는 것은 “얼마를 썼는가”가 아니라 “얼마를 남겼는가”다. 이익률이 안정적으로 유지된다면, 자산을 늘릴 수 있는 여지는 자연스럽게 따라온다. 그리고 이 여지가 바로 다음 단계의 선택, 즉 자산을 어떻게 배분하고 어떤 리스크를 감당할 수 있을지를 결정하는 기반이 된다.</p>\n<p>이제 현금 흐름이라는 “속도”에 대한 이야기를 했으니, 다음으로는 자산의 “상태”, 즉 현재 자산이 어떤 형태로 구성되어 있는지를 살펴볼 차례다.</p>\n<h3 id=\"자산-상태-규모가-아니라-구조를-본다\" style=\"position:relative;\">자산 상태: 규모가 아니라 구조를 본다<a href=\"#%EC%9E%90%EC%82%B0-%EC%83%81%ED%83%9C-%EA%B7%9C%EB%AA%A8%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EB%B3%B8%EB%8B%A4\" aria-label=\"자산 상태 규모가 아니라 구조를 본다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>현금 흐름 데이터가 돈의 수입과 지출이라는 ‘흐름’을 보여준다면, 자산 스냅샷은 말 그대로 현재 상태를 보여주는 데이터다. 필자는 정기적으로 지금 당장 가용 가능한 현금이 얼마인지, 자산이 어떤 형태로 어디에 묶여 있는지를 확인한다. 이때 각 자산의 금액이 정확히 맞아떨어질 필요는 없다고 생각한다. 필자의 경우에는 대략 100만 원 정도의 오차는 충분히 허용 가능한 범위로 보고 있다.</p>\n<p>자산 스냅샷을 구성할 때도 현금 흐름과 마찬가지로 중요한 것은 정밀함이 아니라 구조다. 필자가 사용하는 자산 카테고리는 대략 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th>대카테고리</th>\n<th>중카테고리</th>\n<th>카테고리</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>자산</td>\n<td>현금</td>\n<td>KRW</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>USD</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>예금</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>주택청약</td>\n</tr>\n<tr>\n<td></td>\n<td>투자</td>\n<td>국내주식</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>해외주식</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>부동산</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>연금</td>\n</tr>\n<tr>\n<td></td>\n<td>기타</td>\n<td>자동차</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>주택 보증금</td>\n</tr>\n<tr>\n<td>부채</td>\n<td>단기부채</td>\n<td>신용카드</td>\n</tr>\n<tr>\n<td></td>\n<td>장기부채</td>\n<td>대출</td>\n</tr>\n</tbody>\n</table>\n<p>이 카테고리 역시 정답이 있는 것은 아니다. 중요한 것은 이 구분을 통해 어떤 질문에 답하고 싶은지다. 필자의 경우에는 자산의 총액보다도, 즉시 유동화가 가능한 자산과 그렇지 않은 자산이 어떤 비율로 구성되어 있는지를 가장 중요하게 본다.</p>\n<p>같은 금액의 자산을 가지고 있더라도, 그 자산이 어떤 형태로 묶여 있는지에 따라 상황은 전혀 다르게 전개된다. 현금이나 주식처럼 비교적 빠르게 현금화할 수 있는 자산의 비중이 충분하다면, 시장이 흔들릴 때도 선택지가 남아 있다. 반대로 대부분의 자산이 보증금이나 부동산처럼 쉽게 움직일 수 없는 형태로 묶여 있다면, 작은 변동성도 곧바로 압박으로 다가온다. 이 차이가 바로 유동성이 가져다주는 혜택이다.</p>\n<p>유동성은 단순히 “얼마나 빨리 팔 수 있는가”의 문제가 아니다. 필자가 느끼기에 유동성은 선택권에 가깝다. 유동성이 충분한 상태에서는 기다릴 수 있고, 상황이 바뀌면 기회를 선택할 수도 있다. 반면 유동성이 부족한 상태에서는 아무것도 하지 않는 선택조차 쉽지 않다. 시장의 변동성이 그대로 개인의 심리적 부담으로 전이되기 때문이다.</p>\n<p>이런 관점에서 보면 자산 스냅샷은 단순히 자산 규모를 확인하기 위한 수단이 아니라, 현재 내가 감당할 수 있는 리스크의 범위를 가늠하기 위한 도구에 가깝다. 그래서 필자는 자산 스냅샷을 볼 때 특정 자산의 가격 자체보다는, 전체 구조가 지금의 나에게 과도한 부담을 주고 있지는 않은지를 먼저 확인한다.</p>\n<p>그렇다면 자산 상태를 점검할 때 참고할 만한 지표는 무엇일까. 필자가 하나의 참고 지표로 사용하는 것은 월 자산 성장률이다. 여기서 중요한 점은 이 수치를 목표로 삼지 않는다는 것이다. 매달 자산을 몇 퍼센트씩 늘려야 한다는 식의 기준을 세우기보다는, 지금의 방향성이 유지되고 있는지를 확인하기 위한 보조 지표로 활용한다.</p>\n<p>작년에 발표된 <a href=\"https://www.korea.kr/news/policyNewsView.do?newsId=148955870\" target=\"_blank\" rel=\"nofollow\">기획 재정부 뉴스</a>에 따르면, 2025년 한 해 동안 가구당 평균 자산 증가율은 약 4.9% 수준이었다고 한다. 이를 단순히 월 단위로 환산하면 대략 0.4% 정도다. 물론 자산은 소득보다 변수의 폭이 훨씬 넓고, 개인 간 편차도 크기 때문에 이 평균값 자체에 큰 의미를 두기는 어렵다. 다만 이런 수치를 알고 있으면, 내 자산이 사회 전체의 흐름과 비교했을 때 크게 벗어나고 있는지 정도는 가늠해볼 수 있다.</p>\n<p>여기서 중요한 것은 이 숫자가 정답이 아니라는 점이다. 월 성장률이 높다고 해서 반드시 좋은 상태라고 볼 수도 없고, 낮다고 해서 잘못된 선택을 하고 있다고 단정할 수도 없다. 중요한 것은 자산이 장기적으로 같은 방향을 유지하고 있는지, 그리고 그 과정에서 내가 감당하기 어려운 리스크를 쌓아가고 있지는 않은지다.</p>\n<p>필자는 자산 성장에서 속도보다 방향성이 훨씬 중요하다고 생각한다. 단기간에 큰 수익을 내는 것보다, 매달 크지 않은 변화라도 일관된 방향을 유지하는 것이 결국 더 오래 갈 수 있는 방식이기 때문이다. 그래서 매월 말 현금 흐름과 자산 스냅샷을 함께 정리하면서, 지난달과 비교해 어떤 변화가 있었는지, 어떤 자산이 구조적으로 부담이 되고 있는지를 점검한다.</p>\n<p>그리고 이 과정에서 자연스럽게 다음 질문으로 이어진다. 지금의 자산 구조는 어느 정도의 변동성을 견딜 수 있는 상태인가. 이 질문에 답하기 위해서 필자는 안전자산의 비중과 투자 전략을 함께 고민하게 된다.</p>\n<h2 id=\"투자는-수익이-아니라-상태를-바꾸는-선택이다\" style=\"position:relative;\">투자는 수익이 아니라 상태를 바꾸는 선택이다<a href=\"#%ED%88%AC%EC%9E%90%EB%8A%94-%EC%88%98%EC%9D%B5%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%B0%94%EA%BE%B8%EB%8A%94-%EC%84%A0%ED%83%9D%EC%9D%B4%EB%8B%A4\" aria-label=\"투자는 수익이 아니라 상태를 바꾸는 선택이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자산 관리를 어느 정도 해오다 보면, 결국 투자를 어떻게 바라볼 것인가라는 질문에 도달하게 된다. 더 많은 수익을 얻기 위해서라기보다는, 지금의 자산 구조가 시간이 지나도 같은 방향을 유지할 수 있을지에 대한 고민에 가깝다.</p>\n<p>많은 경우 투자는 수익률의 문제로 이야기된다. 어떤 종목이 더 오를지, 언제 사고 언제 팔아야 할지, 혹은 어떤 전략이 더 높은 수익을 낼 수 있는지에 대한 이야기들이다. 물론 이런 논의들이 전혀 중요하지 않다고 말할 수는 없다. 다만 필자가 경험해온 바로는, 이런 이야기들은 모두 하나의 전제가 깔려 있을 때에만 의미를 갖는다.</p>\n<p>바로, 그 변동성을 감당할 수 있는 상태인가라는 전제다.</p>\n<p>투자는 본질적으로 변동성을 동반한다. 가격은 오를 수도 있고, 예상과 다르게 움직일 수도 있다. 문제는 이 변동성이 누구에게나 같은 의미로 다가오지 않는다는 점이다. 같은 10%의 하락이라도 어떤 사람에게는 단순한 숫자의 변화일 수 있지만, 어떤 사람에게는 판단을 뒤흔드는 압박으로 작용한다.</p>\n<p>이 차이를 만드는 것은 투자 지식이나 종목 선택 능력보다는, 자산 구조와 상태에 가깝다고 생각한다. 특히 정기적이고 예측 가능한 현금 흐름이 있는지, 자산이 한쪽으로 과도하게 쏠려 있지는 않은지, 그리고 지금의 생활과 심리 상태가 이 변동성을 견딜 수 있는지와 같은 요소들이 훨씬 더 큰 영향을 미친다.</p>\n<p>그래서 필자는 투자를 이야기할 때, 먼저 “얼마를 벌 수 있는가”보다 “어떤 상태에서 이 선택을 하고 있는가”를 먼저 점검해야 한다고 생각한다. 리스크를 얼마나 감수할 수 있는지, 그리고 그 리스크가 현실적인 생활 압박이나 감정적인 판단으로 이어지지는 않는지 말이다.</p>\n<p>이 관점에서 보면, 투자와 리스크 관리는 서로 분리된 주제가 아니다. 오히려 리스크를 어떻게 다루느냐에 따라, 투자라는 행위의 성격 자체가 달라진다. 같은 전략이라도 어떤 구조 위에서 실행하느냐에 따라 전혀 다른 결과로 이어질 수 있기 때문이다.</p>\n<p>이제부터는 이 관점에서, 리스크 관리를 어떻게 이해해야 하는지, 그리고 그 리스크를 흡수하는 데 있어 근로소득과 안전자산이 어떤 역할을 하는지에 대해 차례대로 이야기해보려고 한다.</p>\n<h3 id=\"리스크-관리는-판단을-보호하기-위한-설계다\" style=\"position:relative;\">리스크 관리는 판단을 보호하기 위한 설계다<a href=\"#%EB%A6%AC%EC%8A%A4%ED%81%AC-%EA%B4%80%EB%A6%AC%EB%8A%94-%ED%8C%90%EB%8B%A8%EC%9D%84-%EB%B3%B4%ED%98%B8%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EC%84%A4%EA%B3%84%EB%8B%A4\" aria-label=\"리스크 관리는 판단을 보호하기 위한 설계다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자가 생각하는 투자의 기본기는 사실 굉장히 단순하다. 싸게 사서 비싸게 파는 것이다. 이 문장을 부정할 수 있는 사람은 거의 없을 것이다. 문제는 이 단순한 원칙을 실제로 지키는 것이 생각보다 매우 어렵다는 데 있다.</p>\n<p>이게 어려운 이유는 계산이 복잡해서도, 정보가 부족해서도 아니다. 대부분의 경우 실패의 원인은 감정이다. 가격이 오를 때는 더 오를 것 같고, 가격이 떨어질 때는 더 떨어질 것 같다는 생각이 자연스럽게 든다. 머리로는 지금이 싸다고 판단하면서도, 손은 매수 버튼 위에서 쉽게 움직이지 않는다.</p>\n<p>특히 하락 구간에서는 이 감정이 더 강하게 작용한다. 가격이 내려간다는 사실보다도, “혹시 내가 틀린 선택을 한 건 아닐까”라는 불안이 먼저 올라온다. 그리고 이 불안은 판단의 기준을 조금씩 흐리게 만든다. 원래 세워두었던 가설이나 조건은 점점 뒷전으로 밀리고, 당장의 가격 움직임이 모든 의사결정을 지배하게 된다.</p>\n<p>이 지점에서 많은 사람들이 투자가 어렵다고 느낀다. 하지만 필자는 이 문제를 투자 기법의 문제라기보다는, 상태의 문제라고 생각한다. 지금의 내가 이 변동성을 감정적으로 견딜 수 있는 상태인가에 대한 문제다.</p>\n<p>리스크 관리는 바로 이 상태를 다루는 일에 가깝다. 필자가 생각하는 리스크 관리는 손실을 피하는 기술이 아니라, 감정이 판단을 덮어버리지 않도록 환경을 설계하는 과정이다. 가격이 흔들려도 당장 결정을 내려야 할 이유가 없는 여유, 판단이 틀렸을 가능성을 인정하더라도 다음 선택을 할 수 있는 시간, 그리고 처음 세워둔 기준을 끝까지 검증해볼 수 있는 심리적 거리감을 확보하는 일이다.</p>\n<p>이런 환경이 갖춰져 있을 때에야 비로소 투자의 기본기가 작동하기 시작한다. 가격이 떨어졌을 때 공포가 아니라 근거를 다시 점검할 수 있고, 가격이 올랐을 때도 흥분이 아니라 원래의 가설을 되짚어볼 수 있다. 싸게 사서 비싸게 판다는 단순한 원칙은, 감정을 통제할 수 있는 구조 위에서만 의미를 갖는다.</p>\n<p>그래서 필자는 투자를 이야기할 때 “얼마를 벌 수 있는가”보다 “이 선택을 감당할 수 있는 상태인가”를 먼저 묻는 편이다. 같은 전략이라도 어떤 자산 구조, 어떤 현금 흐름, 어떤 심리적 여유 위에서 실행되느냐에 따라 결과는 전혀 달라질 수 있기 때문이다.</p>\n<p>이렇게 보면 투자의 본질은 결국 가격을 맞히는 능력이 아니라, 감정이 개입되지 않도록 환경을 설계하는 일에 가깝다. 그리고 이 환경을 실제로 떠받치고 있는 요소들은 생각보다 훨씬 현실적인 것들이다.</p>\n<p>이제부터는 이 관점에서, 이러한 리스크 관리 환경을 구성하는 핵심 요소 중 하나인 근로소득이 투자에서 어떤 역할을 하는지, 그리고 왜 이 요소가 자주 과소평가되는지에 대해 이야기해보려고 한다.</p>\n<h3 id=\"근로소득은-가장-안정적인-헷징-레이어다\" style=\"position:relative;\">근로소득은 가장 안정적인 헷징 레이어다<a href=\"#%EA%B7%BC%EB%A1%9C%EC%86%8C%EB%93%9D%EC%9D%80-%EA%B0%80%EC%9E%A5-%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%ED%97%B7%EC%A7%95-%EB%A0%88%EC%9D%B4%EC%96%B4%EB%8B%A4\" aria-label=\"근로소득은 가장 안정적인 헷징 레이어다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>“월급은 의미 없다”, “근로소득으로는 부자가 될 수 없다”는 말은 투자 이야기를 할 때 거의 상식처럼 소비된다.</p>\n<p>특히 시장이 좋았던 시기에는 이런 말이 더 쉽게 퍼졌다. 자산 가격이 빠르게 오르는 구간에서, 매달 고정적으로 들어오는 월급은 느리고 답답해 보인다. 투자 수익과 나란히 놓고 보면 상대적으로 초라해 보이는 것도 사실이다. 하지만 이 문장은 수익의 관점에서만 부분적으로 맞을 뿐, 리스크의 관점에서는 결정적으로 틀린 말이다.</p>\n<p>하지만 앞서 언급했듯이 투자는 수익을 만드는 행위이기 이전에 변동성을 감당하는 행위다. 가격이 오를 수 있다는 말은, 같은 크기로 내려갈 수도 있다는 뜻이다. 이 단순한 사실은 시장이 좋을 때는 쉽게 잊힌다. 숫자가 늘어나는 구간에서는 누구나 리스크를 과소평가한다. 문제는 하락이 시작됐을 때다.</p>\n<p>이때 사람을 압박하는 것은 손실 그 자체가 아니라, 손실이 생활로 번질 수 있다는 가능성이다. 다음 달 생활비, 고정비, 예정된 지출이 머릿속에 떠오르는 순간부터 투자는 확률과 가설의 문제가 아니라 생존의 문제로 바뀐다.</p>\n<p>여기서 근로소득의 역할이 드러난다. 매달 예측 가능한 현금 흐름이 있다는 사실은 단순한 수입 이상의 의미를 가진다. 이는 “지금 당장 틀려도 괜찮다”는 시간을 벌어준다. 가격이 더 내려가도, 판단이 조금 늦어져도, 당장 결정을 내려야 할 이유가 사라진다. 이 여유가 없는 상태에서는 싸게 사는 것도, 비싸게 파는 것도 모두 불가능해진다. 근로소득은 자산을 폭발적으로 키워주지는 않지만, 자산이 감정 때문에 무너지는 것을 막아주는 구조를 만든다.</p>\n<p>투자 수익만으로 생활을 감당해야 하는 상태에서는 작은 변동성조차 과도한 압박으로 작용한다. 같은 10% 하락이라도, 누군가에게는 “기다릴 수 있는 구간”이고 누군가에게는 “지금 팔아야 하는 위기”가 된다. 이 차이는 종목 선택이나 분석 능력에서 나오지 않는다. 현금 흐름의 안정성에서 나온다. 그래서 근로소득을 “언젠가는 벗어나야 할 것”으로만 바라보는 관점은 위험하다. 그것은 투자를 가능하게 만드는 바닥을 스스로 걷어차는 일에 가깝다.</p>\n<p>근로소득은 투자와 경쟁하는 대상이 아니다. 근로소득은 투자가 정상적으로 작동하도록 버텨주는 마지막 안전망이다. 시장이 좋을 때는 누구나 공격적인 포지션을 취할 수 있다. 진짜 차이는 시장이 흔들릴 때 드러난다. 그리고 그 순간 끝까지 판단을 유지할 수 있는 사람은, 대부분 안정적인 현금 흐름을 가진 사람이다. 월급이 의미 없어 보일 때야말로, 월급의 진짜 가치는 가장 깊이 가려져 있는 시기다.</p>\n<h3 id=\"안전자산은-전략을-가능하게-만드는-버퍼다\" style=\"position:relative;\">안전자산은 전략을 가능하게 만드는 버퍼다<a href=\"#%EC%95%88%EC%A0%84%EC%9E%90%EC%82%B0%EC%9D%80-%EC%A0%84%EB%9E%B5%EC%9D%84-%EA%B0%80%EB%8A%A5%ED%95%98%EA%B2%8C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B2%84%ED%8D%BC%EB%8B%A4\" aria-label=\"안전자산은 전략을 가능하게 만드는 버퍼다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>사실 이 지점에서 한 가지는 솔직하게 밝혀두는 편이 좋을 것 같다.</p>\n<p>필자의 포트폴리오는 결코 보수적이지 않다. 자산의 상당 부분이 TSLA를 중심으로 구성되어 있고, 레버리지 상품인 TSLL이나 NVDA 같은 변동성이 큰 자산도 함께 들고 있다. 변동성만 놓고 보면 누구에게나 추천할 만한 구조는 아니다.</p>\n<p>그럼에도 불구하고 이런 선택을 유지하고 있는 이유는, 필자가 리스크를 가볍게 보고 있어서가 아니다. 오히려 그 반대다. 이 정도의 변동성을 감당할 수 있는 구조가 만들어져 있다고 판단했기 때문에 가능한 선택이다.</p>\n<p>많은 사람들이 공격적인 투자를 “확신”이나 “배짱”의 문제로 이야기한다. 하지만 필자가 경험한 바로는, 감정적으로 흔들리지 않는 투자자일수록 준비가 훨씬 보수적이다. 현금 흐름이 안정적이고, 안전자산이 충분히 확보되어 있으며, 최악의 경우에도 생활이 흔들리지 않는 상태일 때에야 비로소 변동성을 전략의 일부로 받아들일 수 있다.</p>\n<p>필자에게 안전자산은 수익을 내기 위한 자산이 아니다. 가격이 오르지 않아도 상관없고, 몇 년간 그대로 있어도 괜찮다. 중요한 것은 이 자산이 존재함으로써 선택지가 생긴다는 점이다. 가격이 내려갔을 때 추가로 매수할 수 있고, 아무것도 하지 않고 기다릴 수도 있으며, 판단이 틀렸다고 느껴지면 일부를 정리할 여유도 생긴다.</p>\n<p>이 여유가 없는 상태에서의 공격적인 투자는 투자라기보다는 도박에 가깝다. 변동성을 견딜 수 없는 구조에서는, 어떤 종목을 사든 결국 감정이 먼저 무너진다. 반대로 안전자산과 안정적인 현금 흐름이 받쳐주는 구조에서는, 변동성은 위기가 아니라 선택의 조건으로 바뀐다.</p>\n<p>그래서 필자는 자산 증가 속도를 높이고 싶을수록, 오히려 안전자산의 비중을 더 신경 쓴다. 역설적으로 들릴 수 있지만, 가장 공격적인 선택은 항상 가장 보수적인 준비 위에서만 가능하다고 생각한다. 이 구조가 유지되는 한, 가격의 등락은 감정을 자극하는 소음이 아니라 판단을 실행할 수 있는 신호에 가깝다.</p>\n<p>결국 안전자산의 비중을 관리한다는 것은 위험을 피하겠다는 선언이 아니다. 위험을 감당할 수 있는 상태를 유지하겠다는 선택이다. 그리고 이 상태가 유지될 때, 자산 증가는 속도의 문제가 아니라 전략의 문제로 바뀐다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자산 관리를 하면서 필자가 점점 확신하게 된 것은, 자산 증식이 어떤 종목을 고르는 능력이나 시장을 예측하는 감각의 문제가 아니라는 점이다. 오히려 불확실한 상황 속에서도 스스로의 판단을 유지할 수 있는 구조를 만들 수 있는지가 훨씬 중요하다고 느꼈다.</p>\n<p>시장은 언제든 흔들릴 수 있고, 가격은 내가 원하지 않는 방향으로 움직일 수 있다. 환율도, 금리도, 정치적 이슈도 개인이 통제할 수 있는 영역은 아니다. 이런 환경에서 자산 관리를 “잘한다”는 것은, 외부 변수를 제거하는 일이 아니라 그 영향을 감당할 수 있는 상태를 만들어두는 일에 가깝다.</p>\n<p>그래서 필자는 자산을 볼 때 항상 구조부터 확인한다. 현금 흐름이 안정적인지, 자산이 한쪽으로 과도하게 쏠려 있지는 않은지, 그리고 지금의 내가 이 변동성을 감정적으로 견딜 수 있는 상태인지 말이다. 이 기준이 유지되는 한, 가격의 등락은 불안을 자극하는 요소가 아니라 판단을 점검하는 신호로 바뀐다.</p>\n<p>이 글에서 이야기한 현금 흐름, 자산 스냅샷, 리스크 관리, 근로소득, 안전자산 비중은 모두 같은 질문으로 수렴한다.</p>\n<blockquote>\n<p>“지금의 나는 어떤 선택을 할 수 있는 상태인가?”</p>\n</blockquote>\n<p>자산 관리는 단기간에 답이 나오는 문제가 아니다. 오히려 시간이 지날수록 아주 작은 차이가 누적되어 큰 차이를 만들어내는 영역에 가깝다. 그래서 더더욱 속도보다 방향성이 중요하고, 방향성을 유지하기 위해서는 감정이 아니라 구조에 의존해야 한다고 생각한다.</p>\n<p>이 글이 어떤 투자 전략이나 수익 아이디어를 제공하지는 못했을지도 모른다. 다만 자신의 자산을 바라보는 기준을 한 번쯤 점검해보는 계기가 된다면, 필자에게는 그걸로 충분하다. 적어도 필자는 이런 방식으로, 지금까지의 선택을 이어올 수 있었다.</p>","fields":{"slug":"20260117-assets-management","path":"/2026/01/17/assets-management/","lang":"ko"},"frontmatter":{"title":"자산 관리는 상태 관리의 문제다","subTitle":"왜 나는 공격적인 투자에도 흔들리지 않는가","date":"Jan 17, 2026","categories":["에세이"],"tags":["자산관리","투자","주식","리스크 관리"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/81668c6675719d7dd589cfc13a3a4ed7/3a812/thumbnail.jpg","srcSet":"/static/81668c6675719d7dd589cfc13a3a4ed7/3a812/thumbnail.jpg 320w,\n/static/81668c6675719d7dd589cfc13a3a4ed7/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/81668c6675719d7dd589cfc13a3a4ed7/fc5c5/thumbnail.webp 320w,\n/static/81668c6675719d7dd589cfc13a3a4ed7/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/81668c6675719d7dd589cfc13a3a4ed7/2d839/thumbnail.jpg","srcSet":"/static/81668c6675719d7dd589cfc13a3a4ed7/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/81668c6675719d7dd589cfc13a3a4ed7/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"1280d487-b169-5155-86a0-f8f947ff8029","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EB%B3%B8%EC%A7%88\">선언적 프로그래밍의 본질</a></p>\n<ul>\n<li><a href=\"#%EC%83%81%ED%83%9C-%EA%B3%B5%EA%B0%84%EA%B3%BC-%EC%9D%B8%EC%A7%80%EC%A0%81-%EB%B6%80%ED%95%98\">상태 공간과 인지적 부하</a></li>\n<li><a href=\"#%EC%9E%85%EB%A0%A5%EA%B3%BC-%EC%B6%9C%EB%A0%A5%EC%9D%98-%EA%B4%80%EA%B3%84\">입력과 출력의 관계</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81-%EC%98%A4%EB%B2%84%EB%A0%88%EC%9D%B4-%ED%8C%A8%ED%84%B4declarative-overlay-pattern\">선언적 오버레이 패턴(Declarative Overlay Pattern)</a></p>\n<ul>\n<li><a href=\"#%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C-%EA%B4%80%EA%B3%84%EB%A1%9C\">상태에서 관계로</a></li>\n<li><a href=\"#%EC%9D%B8%EC%A7%80%EC%A0%81-%EB%B6%80%ED%95%98%EC%9D%98-%EC%9E%AC%EB%B6%84%EB%B0%B0\">인지적 부하의 재분배</a></li>\n<li><a href=\"#%EC%A1%B0%ED%95%A9%EA%B3%BC-%EC%A0%9C%EC%96%B4-%ED%9D%90%EB%A6%84\">조합과 제어 흐름</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81-%EC%82%AC%EA%B3%A0%EC%9D%98-%ED%99%95%EC%9E%A5\">선언적 사고의 확장</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 지난 포스팅에 이어 선언적 프로그래밍이 현실에 어떤 형태로 구현되는지에 대해서 조금 더 자세한 이야기를 해보려고 한다. 그냥 이론적인 설명만 하면 너무 재미가 없으니 리액트에서 오버레이 요소들을 쉽게 다룰 수 있도록 도와주는 overlay-kit이라는 라이브러리를 통해 선언적 프로그래밍에 대해 조금 더 자세히 알아보겠다. 선언적 프로그래밍의 본질 필자는 이전에 선언적 프로그래밍의 본질에 대해 이야기한 바 있다. 이나  같은 배열 메소드를 쓴다고 해서 무조건 선언적인 것이 아니며, 진정한 선언적 사고는 “어떻게(H…","html":"<p>이번 포스팅에서는 지난 포스팅에 이어 선언적 프로그래밍이 현실에 어떤 형태로 구현되는지에 대해서 조금 더 자세한 이야기를 해보려고 한다.</p>\n<p>그냥 이론적인 설명만 하면 너무 재미가 없으니 리액트에서 오버레이 요소들을 쉽게 다룰 수 있도록 도와주는 <a href=\"https://overlay-kit.slash.page/ko\" target=\"_blank\" rel=\"nofollow\">overlay-kit</a>이라는 라이브러리를 통해 선언적 프로그래밍에 대해 조금 더 자세히 알아보겠다.</p>\n<!--more -->\n<h2 id=\"선언적-프로그래밍의-본질\" style=\"position:relative;\">선언적 프로그래밍의 본질<a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EB%B3%B8%EC%A7%88\" aria-label=\"선언적 프로그래밍의 본질 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 이전에 <a href=\"/2025/09/07/declarative-programming-misconceptions-and-essence/\">선언적 프로그래밍의 본질</a>에 대해 이야기한 바 있다. <code class=\"language-text\">map</code>이나 <code class=\"language-text\">filter</code> 같은 배열 메소드를 쓴다고 해서 무조건 선언적인 것이 아니며, 진정한 선언적 사고는 “어떻게(How)“가 아닌 “무엇을(What)”, 절차가 아닌 관계에 집중하는 것이라고 말했다.</p>\n<p>하지만 React를 사용하는 대부분의 개발자들은 여전히 모달이나 토스트와 같은 요소를 다룰 때 만큼은 10년 전의 절차적 사고에서 벗어나지 못하고 있다.</p>\n<p>우리는 여전히 <code class=\"language-text\">useState</code>를 사용해 상태를 만들고, 이벤트 핸들러를 연결하고, 상태 변화의 순서를 관리한다. 이것은 “먼저 다이얼로그를 열고, 그 다음 확인을 기다리고, 마지막에 API를 호출한다”는 시간적 순서에 집중하는 절차적 사고라고 볼 수 있다.</p>\n<p>마치 <code class=\"language-text\">map</code>을 사용하면서도 절차적으로 사고할 수 있는 것처럼, <code class=\"language-text\">useState</code>를 사용한다고 해서 선언적인 코드가 되는 것은 아니다.</p>\n<h3 id=\"상태-공간과-인지적-부하\" style=\"position:relative;\">상태 공간과 인지적 부하<a href=\"#%EC%83%81%ED%83%9C-%EA%B3%B5%EA%B0%84%EA%B3%BC-%EC%9D%B8%EC%A7%80%EC%A0%81-%EB%B6%80%ED%95%98\" aria-label=\"상태 공간과 인지적 부하 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이전 글에서 다뤘던 비동기 데이터 상태를 기억하는가? <code class=\"language-text\">loading</code>, <code class=\"language-text\">data</code>, <code class=\"language-text\">error</code>를 독립적인 boolean 상태로 관리하면 논리적으로 불가능한 상태 조합이 발생한다는 이야기였다. 오버레이 관리에서도 똑같은 문제가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isOpen<span class=\"token punctuation\">,</span> setIsOpen<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isLoading<span class=\"token punctuation\">,</span> setIsLoading<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>result<span class=\"token punctuation\">,</span> setResult<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useState</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token string\">'confirmed'</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 논리적으로 불가능한 상태 조합들</span>\n<span class=\"token comment\">// { isOpen: false, isLoading: true, result: null }</span>\n<span class=\"token comment\">// → 닫혀있는데 로딩 중</span>\n\n<span class=\"token comment\">// { isOpen: false, isLoading: false, result: 'confirmed' }</span>\n<span class=\"token comment\">// → 닫혀있는데 결과가 있음</span>\n\n<span class=\"token comment\">// { isOpen: true, isLoading: true, result: 'confirmed' }</span>\n<span class=\"token comment\">// → 로딩 중인데 이미 결과가 있음</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>세 개의 독립적인 상태 변수는 이론적으로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">2³ = 8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">8</span></span></span></span></span>가지 조합을 만들지만, 실제로 논리적으로 유효한 조합은 그보다 훨씬 적다. 개발자는 코드를 작성할 때마다 “이 조합이 가능한가?”를 머릿속으로 검증해야 한다.</p>\n<p>이러한 상황이 문제가 되는 근본적인 이유는 바로 인지적 부하의 증가다. 심리학자 존 스웰러(John Sweller)의 <a href=\"https://ko.wikipedia.org/wiki/%EC%9D%B8%EC%A7%80_%EB%B6%80%ED%95%98\" target=\"_blank\" rel=\"nofollow\">인지 부하 이론</a>에 따르면, 인간의 작업 기억은 제한적이며, 동시에 처리할 수 있는 정보의 양에는 한계가 있다고 한다. 조지 밀러(George Miller)가 제시한 “매직 넘버 7±2”도 이와 동일한 맥락에서 나온 이야기이다.</p>\n<p>그래서 위 예시의 오버레이 관리 패턴을 보면 <code class=\"language-text\">isOpen</code>, <code class=\"language-text\">isLoading</code>, <code class=\"language-text\">result</code>, 그리고 이들 사이의 유효한 조합까지 추적해야만 오버레이의 동작을 유추할 수 있다는 점이 문제인 것이다. 그나마 지금은 8가지 경우의 수 밖에 되지 않지만, 필요한 상태가 늘어날 수록 개발자가 기억해야할 정보의 양도 기하급수적으로 늘어날 것이다.</p>\n<p>하지만 이 상황은 문제 자체의 복잡도가 아니라, 표현 방식이 만들어낸 외재적 인지 부하이기 때문에 충분히 해결해볼 수 있는 문제이다. 수학에서 복잡한 식을 적절한 표기법으로 바꾸면 이해가 쉬워지는 것처럼, 약간의 접근 방법만 바꾸면 오버레이도 더 간단한 방식으로 표현할 수 있다.</p>\n<h3 id=\"입력과-출력의-관계\" style=\"position:relative;\">입력과 출력의 관계<a href=\"#%EC%9E%85%EB%A0%A5%EA%B3%BC-%EC%B6%9C%EB%A0%A5%EC%9D%98-%EA%B4%80%EA%B3%84\" aria-label=\"입력과 출력의 관계 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자가 이전 글에서 강조했던 핵심은 선언적 코드는 시간의 흐름이 아닌 관계를 표현한다는 것이었다.</p>\n<p>한번 일차 함수를 나타내는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>=</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">y = 2x + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>을 떠올려보자. 이것은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>에 2를 곱하고 1을 더하라는 계산 절차를 의미하는 것이 아니라 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span> 사이의 관계를 선언하는 것이다. 이 관계는 시간과 무관한 영원한 진리다. 언제 어디서나 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>가 3이라면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span>는 7이기 때문이다.</p>\n<p>오버레이의 본질도 마찬가지다. 브라우저 네이티브 API인 <code class=\"language-text\">window.confirm</code>을 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">confirm</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"정말 삭제하시겠습니까?\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>물론 <code class=\"language-text\">window.confirm</code>은 UI를 띄우는 부수 효과를 가지므로 순수 함수는 아니다. 하지만 중요한 것은 이 함수가 상태 관리를 호출자에게 노출하지 않는다는 점이다. <code class=\"language-text\">isOpen</code> 같은 상태도, <code class=\"language-text\">handleConfirm</code> 같은 핸들러도 필요하지 않다. 내부적으로 어떻게 구현했는지, 어떤 순서로 렌더링하는지는 추상화 뒤로 숨겨져 있다. 개발자는 오직 “무엇을 넣으면 무엇이 나오는가”라는 관계에만 집중할 수 있다.</p>\n<p>수학에서 함수는 집합 간의 대응 관계를 나타낸다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f:A→B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>라고 쓸 때, 우리는 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>의 각 원소가 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>의 원소와 어떻게 대응되는지를 선언한다. 이것은 계산 과정이 아니라 구조 간의 관계다.</p>\n<p><code class=\"language-text\">window.confirm</code>도 마찬가지다. 메시지 문자열이라는 집합에서 <code class=\"language-text\">boolean</code> 값이라는 집합으로의 대응 관계를 나타낸다.</p>\n<h2 id=\"선언적-오버레이-패턴declarative-overlay-pattern\" style=\"position:relative;\">선언적 오버레이 패턴(Declarative Overlay Pattern)<a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81-%EC%98%A4%EB%B2%84%EB%A0%88%EC%9D%B4-%ED%8C%A8%ED%84%B4declarative-overlay-pattern\" aria-label=\"선언적 오버레이 패턴declarative overlay pattern permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그렇다면 어떻게 해야 할까? 답은 의외로 간단하다. 오버레이를 상태로 다루지 말고 함수로 다루면 된다.</p>\n<p>선언적 오버레이 패턴은 <code class=\"language-text\">window.confirm</code>이 보여준 함수적 본질을 React 생태계로 가져온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> overlay<span class=\"token punctuation\">.</span><span class=\"token function\">openAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> isOpen<span class=\"token punctuation\">,</span> close <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ConfirmDialog</span></span>\n    <span class=\"token attr-name\">isOpen</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>isOpen<span class=\"token punctuation\">}</span></span>\n    <span class=\"token attr-name\">onConfirm</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span>\n    <span class=\"token attr-name\">onCancel</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span>\n  <span class=\"token punctuation\">/></span></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">openAsync</code>는 <code class=\"language-text\">Promise&lt;T></code>를 반환하는 함수다.</p>\n<p>Promise를 써본 개발자라면 이미 이 패턴을 알고 있다. API를 호출하면 Promise가 반환되고, await로 결과를 기다린다. <code class=\"language-text\">openAsync</code>도 동일하다. 오버레이를 열면 Promise가 반환되고, 사용자가 응답할 때까지 기다린다. 다만 API 서버 대신 사용자에게서 응답을 받을 뿐이다.</p>\n<p>즉, “오버레이를 보여주고 사용자 응답을 받는다”는 관계를 선언하는 것이다.</p>\n<p>이번 섹션에서는 선언적 오버레이 패턴이 왜 전통적인 상태 관리보다 나은지 세 가지 측면에서 살펴보려고 한다.</p>\n<h3 id=\"상태에서-관계로\" style=\"position:relative;\">상태에서 관계로<a href=\"#%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C-%EA%B4%80%EA%B3%84%EB%A1%9C\" aria-label=\"상태에서 관계로 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이전 글에서 불가능한 상태 조합을 막는 방법을 다뤘다. 가능한 상태들을 명시적으로 열거하고, 타입 시스템이 불가능한 조합을 차단하도록 하는 것이다.</p>\n<p>하지만 선언적 오버레이 패턴은 다른 접근을 취한다. 상태 조합을 제한하는 대신, 상태 자체를 추상화한다.</p>\n<p>전통적인 상태 관리는 스냅샷을 다룬다. “지금 다이얼로그가 열려있는가?”, “지금 로딩 중인가?”, “지금 결과가 있는가?” 같은 현재 시점의 상태를 추적한다. 그리고 이 상태들을 하나씩 바꿔나가며 원하는 동작을 만든다. 이는 마치 사진 여러 장을 이어붙여 애니메이션을 만드는 것과 비슷하다.</p>\n<p>하지만 잘 생각해보면 우리는 사용자가 다이얼로그에서 확인을 눌렀는지 아닌지를 알고 싶은 것이지 다이얼로그가 현재 열려있는지 닫혀있는지를 알고 싶은게 아니다.</p>\n<p>즉, 중간 과정의 상태들은 사실 그 결과를 얻기 위한 수단일 뿐, 현재 상태가 아니라 최종 결과를 알고 싶은 것이다.</p>\n<p>선언적 오버레이 패턴은 이 중간 과정을 제거한다. 기존에는 복잡하게 다루었던 여러 상태들을 오버레이를 연다는 하나의 동작으로 표현하고, 그 결과를 받는 것에만 집중한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// 다이얼로그를 열고</span>\n<span class=\"token function\">setIsOpen</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 나중에 어딘가에서 다이얼로그를 닫으며 결과를 입력한다.</span>\n<span class=\"token function\">setIsOpen</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setResult</span><span class=\"token punctuation\">(</span><span class=\"token string\">'confirmed'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// 동작과 결과와의 관계만 표현해서 깔끔해졌다</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> overlay<span class=\"token punctuation\">.</span><span class=\"token function\">openAsync</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>왜 이것이 더 나을까?</p>\n<p>첫째, 코드가 의도를 직접 표현한다. “사용자 확인을 받고 싶다”는 의도가 코드에 그대로 드러난다. 개발자가 머릿속으로 상태 변수 세 개를 조합해서 “아, 이게 확인을 받으려는 동작이구만”이라고 유추할 필요가 없다.</p>\n<p>둘째, 에러를 만들 여지가 줄어든다. 첫 번째 방법은 isOpen을 true로 바꿨는데 나중에 false로 바꾸는 걸 깜빡한다거나, <code class=\"language-text\">result</code>를 설정했는데 다이얼로그를 닫지 않는다거나 하는 휴먼 에러의 구멍이 많다. 이러한 동작들을 추상화해서 함수로 표현하면 이런 실수들이 구조적으로 불가능해진다.</p>\n<p>셋째, 변화의 과정이 아니라 변화의 결과에 집중할 수 있다. 상태가 어떻게 바뀌는지가 아니라 무엇이 일어나는지를 표현한다. 즉, 선언적이다.</p>\n<p>다시 말해, 선언적 오버레이 패턴은 개별 상태 변수들이 어떤 값을 가지고 있는지(상태의 스냅샷)를 다루는 대신, 어떤 동작을 하면 어떤 결과가 나오는지(입출력의 관계)를 다루는 것이다.</p>\n<h3 id=\"인지적-부하의-재분배\" style=\"position:relative;\">인지적 부하의 재분배<a href=\"#%EC%9D%B8%EC%A7%80%EC%A0%81-%EB%B6%80%ED%95%98%EC%9D%98-%EC%9E%AC%EB%B6%84%EB%B0%B0\" aria-label=\"인지적 부하의 재분배 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>코드의 가독성은 종종 주관적인 취향의 문제로 여겨진다. 하지만 심리학자 존 스웰러(John Sweller)의 인지 부하 이론은 이것이 단순한 취향이 아니라 인지 과학의 문제임을 보여준다.</p>\n<p>전통적인 상태 관리 방식을 다시 보자. 개발자는 <code class=\"language-text\">isOpen</code>, <code class=\"language-text\">isLoading</code>, <code class=\"language-text\">result</code> 같은 여러 상태 변수를 동시에 추적해야 한다. 개발자가 모듈의 동작을 이해하기 위해 이 변수들이 어떤 순서로 바뀌는지, 어떤 조합이 유효한지를 머릿속으로 시뮬레이션해야 한다는 의미이다.</p>\n<p>이것을 인지 부하 이론에서는 외재적 부하(Extraneous Load)라고 부른다. 코드에서 발생하는 외재적 부하는 문제 자체의 복잡도가 아니라 표현 방식이 만들어낸 불필요한 복잡도라고 볼 수 있다. 오버레이를 띄워 사용자 확인을 받는다는 본질적인 문제는 단순하지만, 이 행위를 여러 개의 상태 변수로 표현하면서 복잡도가 인위적으로 증가한 것이다.</p>\n<p>조지 밀러(George Miller)가 제시한 “매직 넘버 7±2”를 떠올려보자. 인간은 동시에 약 7개 정도의 정보만 작업 기억에 유지할 수 있다. 하지만 상태 변수가 세 개만 되어도 가능한 조합은 8가지가 되고, 이 중 유효한 조합이 무엇인지까지 추적하면 이미 인지적 한계에 다다른다.</p>\n<p>선언적 오버레이 패턴은 이 외재적 부하를 제거한다. 개발자는 더 이상 여러 개의 상태 변수 간의 조합을 기억할 필요가 없고, 하나의 함수 호출, 즉 오직 입력과 출력의 관계만 기억하면 되기 때문에 부하가 줄어든다.</p>\n<p>필자는 이렇게 같은 문제를 더 적은 인지 부하로 표현하는 것, 개발자가 본질적인 문제에 집중할 수 있도록 불필요한 복잡도를 제거하는 것이 가독성 높은 코드를 만드는 본질이라고 생각한다.</p>\n<p>하지만 오해하지 말아야 할 점이 있다. 복잡도가 사라진 것이 아니라 그저 재분배되었을 뿐이다.</p>\n<p>overlay-kit 라이브러리 구현자는 여전히 Promise 관리, 상태 동기화와 같은 복잡한 로직을 다뤄야 하지만, 이런 짜치는 구현은 한 번만 하면 된다.</p>\n<p>소수의 기여를 통해 수많은 개발자들이 낮은 인지 부하로 오버레이라는 동작을 다룰 수 있는 것, 이것이 추상화가 우리에게 선물해주는 가치이다.</p>\n<h3 id=\"조합과-제어-흐름\" style=\"position:relative;\">조합과 제어 흐름<a href=\"#%EC%A1%B0%ED%95%A9%EA%B3%BC-%EC%A0%9C%EC%96%B4-%ED%9D%90%EB%A6%84\" aria-label=\"조합과 제어 흐름 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>여러 오버레이를 통해 사용자 입력을 받아야 하는 상황을 생각해보자. 전통적인 방법에서는 아래와 같은 코드로 해당 로직을 구현하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">CreateUserFlow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>step<span class=\"token punctuation\">,</span> setStep<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>info<span class=\"token punctuation\">,</span> setInfo<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>preference<span class=\"token punctuation\">,</span> setPreference<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleInfoSubmit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setInfo</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setStep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handlePreferenceSubmit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setPreference</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setStep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleConfirm</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">createUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>info<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>preference <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setStep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setInfo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setPreference</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>step <span class=\"token operator\">===</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserInfoForm</span></span> <span class=\"token attr-name\">onSubmit</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>handleInfoSubmit<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>step <span class=\"token operator\">===</span> <span class=\"token number\">2</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PreferenceForm</span></span> <span class=\"token attr-name\">onSubmit</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>handlePreferenceSubmit<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>step <span class=\"token operator\">===</span> <span class=\"token number\">3</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ConfirmDialog</span></span> <span class=\"token attr-name\">onConfirm</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>handleConfirm<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 코드는 사용자 정보, 선호도, 최종 확인을 받은 후 API를 호출하는 간단한 플로우다. 하지만 정보의 흐름이 코드 곳곳에 흩어져 있기 때문에 개발자는 <code class=\"language-text\">step</code> 상태가 어떻게 바뀌는지, 각 핸들러가 무엇을 하는지, JSX에서 어떤 조건으로 렌더링되는지를 모두 따라가야 전체 흐름을 이해할 수 있다.</p>\n<p>이제 같은 로직을 overlay-kit의 <code class=\"language-text\">openAsync</code>로 구현한 모습을 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">createUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> info <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> overlay<span class=\"token punctuation\">.</span><span class=\"token function\">openAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> isOpen<span class=\"token punctuation\">,</span> close <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserInfoForm</span></span> <span class=\"token attr-name\">isOpen</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>isOpen<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">onSubmit</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>close<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> preference <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> overlay<span class=\"token punctuation\">.</span><span class=\"token function\">openAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> isOpen<span class=\"token punctuation\">,</span> close <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PreferenceForm</span></span> <span class=\"token attr-name\">isOpen</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>isOpen<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">onSubmit</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>close<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> <span class=\"token function\">confirmCreation</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">,</span> preference<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">createUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>info<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>preference <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>가장 큰 차이점은 정보의 흐름이 선형적이라는 점이다. 첫 번째 줄에서 사용자 정보를 입력받고, 두 번째 줄에서 선호도를 입력받고, 세 번째 줄에서 확인을 거쳐 API를 호출한다. 코드를 위에서 아래로 읽는 순서가 곧 실행 순서다.</p>\n<p><code class=\"language-text\">openAsync</code>가 Promise를 반환하기 때문에 이것이 가능하다. Promise는 비동기 작업의 완료를 기다릴 수 있게 해준다. 첫 번째 오버레이가 닫힐 때까지 기다렸다가 두 번째 오버레이를 연다. 두 번째가 닫히면 세 번째로 넘어간다. 각 단계가 순차적으로 실행되면서 정보가 위에서 아래로 흐른다.</p>\n<p>또한 각 단계는 독립적이기 때문에 각 관심사의 결합도가 낮고 응집도가 높다. 사용자 정보를 받는 폼은 사용자 정보만 받고 선호도를 받는 폼은 선호도만 받으며, 최종적으로 이들을 어떻게 이어붙일지는 <code class=\"language-text\">createUser</code> 함수가 결정한다. 각 컴포넌트는 그저 <code class=\"language-text\">close</code> 함수를 호출할 뿐이고, 이 결과가 어디로 가는지는 알 필요가 없다.</p>\n<p>게다가 <code class=\"language-text\">openAsync</code>는 그저 값을 반환하는 함수이기에 일반적인 제어 흐름에 자연스럽게 통합된다. 조건부 로직이 필요하면 <code class=\"language-text\">if</code> 문을 쓰면 되고, 에러 처리가 필요하면 <code class=\"language-text\">try/catch</code>를 쓰면 되며, 반복이 필요하면 <code class=\"language-text\">for</code> 문을 쓰면 된다. 프로그래밍 101에서 배우는 제어 흐름이 그대로 작동하며, 오버레이를 위한 특별한 패턴을 배울 필요가 없다.</p>\n<p>이러한 함수의 특성 덕에 특정 UX 흐름에 대한 재사용도 간단한 편이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">confirmAction</span><span class=\"token punctuation\">(</span>message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> overlay<span class=\"token punctuation\">.</span><span class=\"token function\">openAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> isOpen<span class=\"token punctuation\">,</span> close <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ConfirmDialog</span></span> \n      <span class=\"token attr-name\">message</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span></span>\n      <span class=\"token attr-name\">isOpen</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>isOpen<span class=\"token punctuation\">}</span></span> \n      <span class=\"token attr-name\">onConfirm</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span>\n      <span class=\"token attr-name\">onCancel</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span>\n    <span class=\"token punctuation\">/></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> <span class=\"token function\">confirmAction</span><span class=\"token punctuation\">(</span><span class=\"token string\">'정말 삭제하시겠습니까?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">deleteUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> <span class=\"token function\">confirmAction</span><span class=\"token punctuation\">(</span><span class=\"token string\">'설정을 초기화하시겠습니까?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">resetSettings</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이것이 오버레이를 함수로 다루는 힘이다. 정보의 흐름을 선형적으로 표현할 수 있고, <code class=\"language-text\">if</code>와 <code class=\"language-text\">try/catch</code>와 <code class=\"language-text\">for</code> 같은 일반적인 제어 흐름에 자연스럽게 통합되며, 재사용은 별도 함수로 빼는 것만으로 충분하다.</p>\n<h2 id=\"선언적-사고의-확장\" style=\"position:relative;\">선언적 사고의 확장<a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81-%EC%82%AC%EA%B3%A0%EC%9D%98-%ED%99%95%EC%9E%A5\" aria-label=\"선언적 사고의 확장 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>2013년, 우리는 React를 통해 직접적인 DOM 조작에서 벗어나 JSX로 데이터와 UI의 구조적 관계를 표현하며 선언적으로 UI를 다루는 세상을 접하게 되었다.</p>\n<p>하지만 슬프게도 우리는 같은 React 코드베이스에서 컴포넌트는 선언적으로 작성하면서 오버레이만큼은 절차적으로 다루고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 컴포넌트는 선언적으로</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserProfile</span></span> <span class=\"token attr-name\">user</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n\n<span class=\"token comment\">// 오버레이는 절차적으로</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isOpen<span class=\"token punctuation\">,</span> setIsOpen<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleOpen</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setIsOpen</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleClose</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setIsOpen</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>왜 이런 분열이 생긴 걸까? 그 이유는 오버레이가 마치 시간에 종속된 것처럼 보이기 때문이다. 사용자가 버튼을 누르면 다이얼로그가 열리고, 그 이후 확인 버튼을 누르면 API를 호출하고, 응답이 오면 다시 다이얼로그를 닫는 것처럼 말이다. 그래서 우리는 상태로 이 순서를 관리해야 한다고 생각했다.</p>\n<p>하지만 <code class=\"language-text\">window.confirm</code>을 다시 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span><span class=\"token function\">confirm</span><span class=\"token punctuation\">(</span><span class=\"token string\">'정말 삭제하시겠습니까?'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">deleteItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>물론 이 코드가 발생시키는 이펙트에도 사용자가 다이얼로그 내에서 확인을 누르기 까지 기다려야한다는 시간적 순서는 존재한다. 하지만 우리는 이것을 코드 상에서 시간의 흐름으로 표현하지 않으며, 문자열을 인자로 받아 boolean 값을 반환하는 함수, 즉 문자열과 boolean의 관계로만 표현한다.</p>\n<p>선언적 오버레이 패턴이 하는 일이 바로 이것이다. 시간적 순서를 조건과 결과의 관계로 바꾼다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 절차적: \"먼저 열고, 기다리고, 닫고, 그 다음...\"</span>\n<span class=\"token function\">setIsOpen</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ... 어딘가에서</span>\n<span class=\"token function\">setIsOpen</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ... 그 다음에</span>\n<span class=\"token function\">deleteItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 선언적: \"확인받으면 삭제한다\"</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> overlay<span class=\"token punctuation\">.</span><span class=\"token function\">openAsync</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">deleteItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 우리는 React의 선언적 철학을 오버레이에도 적용할 수 있다. 컴포넌트가 데이터와 UI의 관계를 선언하듯, 오버레이도 사용자 응답과 다음 동작의 관계를 선언한다.</p>\n<p>그리고 이 통일성이 중요하다. 컴포넌트를 읽을 때는 선언적으로 사고하다가, 오버레이를 읽을 때는 절차적으로 사고해야 한다면 인지적 분열이 발생한다. 하지만 선언적 오버레이 패턴을 사용하면 전체 코드베이스가 하나의 사고방식으로 통일된다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://overlay-kit.slash.page/ko\" target=\"_blank\" rel=\"nofollow\">overlay-kit</a>은 이 패턴을 구현한 라이브러리다.</p>\n<p>이 라이브러리의 가치는 코드 줄 수를 줄이는 것이 아니라, <code class=\"language-text\">window.confirm</code>이 보여준 단순함을 React 생태계로 가져오는 것이다. 10년 전에는 간단했지만 복잡해진 무언가를 다시 간단하게 만드는 것 뿐이다.</p>\n<p>필자는 이전 글에서 선언적 프로그래밍이 도구가 아니라 사고방식이라고 말했다. <code class=\"language-text\">map</code>이나 <code class=\"language-text\">filter</code>를 쓴다고 선언적인 것이 아니듯, <code class=\"language-text\">useState</code>를 쓴다고 절차적인 것도 아니다. 중요한 것은 무엇을 표현하는가였다.</p>\n<p>이 글에서 다룬 선언적 오버레이 패턴도 마찬가지다. 중요한 것은 <code class=\"language-text\">openAsync</code>라는 API가 아니라 “오버레이를 상태로 볼 것인가, 관계로 볼 것인가”이다.</p>\n<p>상태로 보면 <code class=\"language-text\">isOpen</code>, <code class=\"language-text\">isLoading</code>, <code class=\"language-text\">result</code> 같은 변수들을 추적해야 한다. 관계로 보면 입력과 출력만 생각하면 된다. 같은 문제를 다르게 표현하는 것만으로 인지 부하가 달라진다.</p>\n<p>그리고 필자는 이렇게 개발자가 본질적인 문제에 집중할 수 있도록 불필요한 복잡도를 제거하는 것이 좋은 추상화의 본질이라고 생각한다.</p>","fields":{"slug":"20251007-declarative-overlay-pattern-with-overlay-kit","path":"/2025/10/07/declarative-overlay-pattern-with-overlay-kit/","lang":"ko"},"frontmatter":{"title":"상태에서 관계로: 선언적 오버레이 패턴(Declarative Overlay Pattern)","subTitle":"overlay-kit으로 배우는 선형적 정보 흐름과 인지 부하 재분배","date":"Oct 07, 2025","categories":["프로그래밍"],"tags":["함수형 프로그래밍","선언적 프로그래밍"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/2266686ccc6c841e53970844943c01ec/d803c/thumbnail.png","srcSet":"/static/2266686ccc6c841e53970844943c01ec/d803c/thumbnail.png 320w,\n/static/2266686ccc6c841e53970844943c01ec/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/2266686ccc6c841e53970844943c01ec/fc5c5/thumbnail.webp 320w,\n/static/2266686ccc6c841e53970844943c01ec/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/2266686ccc6c841e53970844943c01ec/01fb2/thumbnail.png","srcSet":"/static/2266686ccc6c841e53970844943c01ec/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/2266686ccc6c841e53970844943c01ec/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"d0800a4e-a13e-553b-8a36-b010129d7acd","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%80%EC%9E%A5-%ED%9D%94%ED%95%9C-%EC%B0%A9%EA%B0%81\">선언적 프로그래밍에 대한 가장 흔한 착각</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%88%98%ED%95%99%EC%A0%81-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-%EC%84%A0%EC%96%B8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\">수학적 관점에서 본 선언적 프로그래밍</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%88%EC%B0%A8%EC%A0%81-vs-%EC%84%A0%EC%96%B8%EC%A0%81-%EC%82%AC%EA%B3%A0%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%B0%A8%EC%9D%B4\">절차적 vs 선언적: 사고방식의 차이</a></p>\n</li>\n<li>\n<p><a href=\"#jsx%EB%8A%94-%EC%99%9C-%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%BC%EA%B9%8C\">JSX는 왜 선언적일까?</a></p>\n<ul>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%99%80-ui%EC%9D%98-%EB%8C%80%EC%9D%91-%EA%B4%80%EA%B3%84\">데이터와 UI의 대응 관계</a></li>\n<li><a href=\"#%EA%B5%AC%EC%A1%B0%EC%A0%81-%EA%B4%80%EA%B3%84%EC%9D%98-%ED%91%9C%ED%98%84\">구조적 관계의 표현</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81%EA%B3%BC-%EC%A0%88%EC%B0%A8%EC%A0%81%EC%9D%80-%EC%83%81%EB%8C%80%EC%A0%81%EC%9D%B4%EB%8B%A4\">선언적과 절차적은 상대적이다</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%B8-%EC%BD%94%EB%93%9C%EB%9D%BC%EA%B3%A0-%EC%B0%A9%EA%B0%81%ED%95%98%EB%8A%94-%EC%BD%94%EB%93%9C-vs-%EC%A7%84%EC%A7%9C-%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%B8-%EC%BD%94%EB%93%9C\">선언적인 코드라고 착각하는 코드 vs 진짜 선언적인 코드</a></p>\n<ul>\n<li><a href=\"#%EC%B0%A9%EA%B0%81%ED%95%98%EB%8A%94-%EC%BD%94%EB%93%9C---%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94-%EA%B3%BC%EC%A0%95%EC%97%90-%EC%A7%91%EC%A4%91\">착각하는 코드 - 상태 변화 과정에 집중</a></li>\n<li><a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%B8-%EC%BD%94%EB%93%9C---%EC%83%81%ED%83%9C-%EA%B4%80%EA%B3%84%EC%97%90-%EC%A7%91%EC%A4%91\">선언적인 코드 - 상태 관계에 집중</a></li>\n<li><a href=\"#%EC%99%9C-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%EC%BD%94%EB%93%9C%EA%B0%80-%EC%A0%88%EC%B0%A8%EC%A0%81%EC%9D%B8%EA%B0%80\">왜 첫 번째 코드가 절차적인가?</a></li>\n<li><a href=\"#%EB%91%90-%EB%B2%88%EC%A7%B8-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%B8%EA%B0%80\">두 번째 코드는 왜 선언적인가?</a></li>\n<li><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C%EC%9D%98-%EC%B0%A8%EC%9D%B4\">컴포넌트에서 사용할 때의 차이</a></li>\n<li><a href=\"#%ED%99%95%EC%9E%A5%EC%84%B1-%EC%B8%A1%EB%A9%B4%EC%97%90%EC%84%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4\">확장성 측면에서의 차이</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%8B%A4%EB%AC%B4-%EC%A0%81%EC%9A%A9-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8\">실무 적용 가이드라인</a></p>\n<ul>\n<li><a href=\"#%EC%96%B8%EC%A0%9C-%EC%84%A0%EC%96%B8%EC%A0%81-%EC%A0%91%EA%B7%BC%EC%9D%84-%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80\">언제 선언적 접근을 해야 하는가?</a></li>\n<li><a href=\"#%EC%96%B8%EC%A0%9C-%EC%A0%88%EC%B0%A8%EC%A0%81-%EC%A0%91%EA%B7%BC%EC%9D%84-%ED%95%B4%EB%8F%84-%EB%90%98%EB%8A%94%EA%B0%80\">언제 절차적 접근을 해도 되는가?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"필자는 평소 기술 인터뷰를 진행하며 지원자 분들이 과제를 작성하면서 내렸던 의사결정에 대한 근거를 물어보는 경우가 잦다. 이때 이에 대한 근거로 “이런 방식이 보다 선언적이기 때문이다”라는 답변을 많이 해주시는데, 정작 그 방식이 왜 선언적인 것인지, 선언적인 코드란 무엇인지 여쭤보면 시원한 답변을 해주시는 경우는 많지 않았던 것 같다. 그래서 이번 포스팅에서는 필자가 생각하는 선언적이라는 것이 무엇인지, 그리고 선언적인 코드란 무엇인지에 대해서 한번 간략하게 이야기해보려고 한다.","html":"<p>필자는 평소 기술 인터뷰를 진행하며 지원자 분들이 과제를 작성하면서 내렸던 의사결정에 대한 근거를 물어보는 경우가 잦다.</p>\n<p>이때 이에 대한 근거로 “이런 방식이 보다 선언적이기 때문이다”라는 답변을 많이 해주시는데, 정작 그 방식이 왜 선언적인 것인지, 선언적인 코드란 무엇인지 여쭤보면 시원한 답변을 해주시는 경우는 많지 않았던 것 같다.</p>\n<p>그래서 이번 포스팅에서는 필자가 생각하는 선언적이라는 것이 무엇인지, 그리고 선언적인 코드란 무엇인지에 대해서 한번 간략하게 이야기해보려고 한다.</p>\n<!-- more -->\n<p>많은 개발자들이 스스로 선언적인 코드를 작성한다고 생각하지만 실제로는 본질을 놓치고 있는 경우가 종종 있으며, 단지 특정한 도구를 사용하거나 문법을 사용하는 것이 선언적인 것이라고 착각하고는 한다.</p>\n<p>하지만 필자가 생각하는 선언적 프로그래밍은 도구의 문제가 아니라 사고방식의 근본적 전환이다.</p>\n<h2 id=\"선언적-프로그래밍에-대한-가장-흔한-착각\" style=\"position:relative;\">선언적 프로그래밍에 대한 가장 흔한 착각<a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%80%EC%9E%A5-%ED%9D%94%ED%95%9C-%EC%B0%A9%EA%B0%81\" aria-label=\"선언적 프로그래밍에 대한 가장 흔한 착각 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>많은 개발자들이 빠지는 첫 번째 함정은 “절차적인 동작을 함수로 추상화하면 선언적”이라는 착각이다. 하지만 함수를 사용한다고 해서 무조건 선언적인 프로그래밍을 구사하는 것은 아니다.</p>\n<p>가장 간단한 예부터 살펴보자. 사용자 정보를 가져오는 함수를 절차적으로 작성하면 이렇게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getUserInfo</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> connection <span class=\"token operator\">=</span> <span class=\"token function\">connectDB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> userRow <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">'SELECT * FROM users WHERE id = ?'</span><span class=\"token punctuation\">,</span> userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> permissionRows <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">'SELECT * FROM permissions WHERE user_id = ?'</span><span class=\"token punctuation\">,</span> userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    id<span class=\"token operator\">:</span> userRow<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n    name<span class=\"token operator\">:</span> userRow<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>\n    email<span class=\"token operator\">:</span> userRow<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">,</span>\n    permissions<span class=\"token operator\">:</span> permissionRows<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>row <span class=\"token operator\">=></span> row<span class=\"token punctuation\">.</span>permission_name<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    user<span class=\"token punctuation\">.</span>displayName <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 코드는 함수를 사용하고는 있지만 “먼저 DB에서 사용자를 가져오고, 그 다음 권한을 추가하고, 마지막에 포맷팅한다”는 시간적 순서에 집중하고 있다. 즉, 함수를 사용했다고 해서 절차적 사고에서 벗어난 것이 아니다.</p>\n<p>선언적인 코드는 동작의 시간적 순서에서 벗어나 동작 간의 관계를 기술하는 것에 집중해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 선언적 접근 - 데이터 변환 관계에 집중</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getUserInfo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> \n  <span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span>\n    fetchUserFromDB<span class=\"token punctuation\">,</span>\n    addUserPermissions<span class=\"token punctuation\">,</span>\n    formatUserData\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 또는 더 명확하게</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getUserInfo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> \n  <span class=\"token function\">formatUserData</span><span class=\"token punctuation\">(</span>\n    <span class=\"token function\">addUserPermissions</span><span class=\"token punctuation\">(</span>\n      <span class=\"token function\">fetchUserFromDB</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 코드는 “사용자 ID → 포맷된 사용자 정보”라는 관계를 선언한다. 실행 순서가 아니라 데이터 변환의 관계에 집중하고 있다.</p>\n<p>여기서 핵심 구분 기준은 명확하다. 절차적 코드는 “어떻게(How) 단계별로 실행할 것인가”에 집중하고, 선언적 코드는 “무엇을(What) 원하는 관계인가”에 집중한다.</p>\n<p>이런 착각은 특히 배열 메소드를 사용할 때 자주 발생한다. <code class=\"language-text\">map</code>, <code class=\"language-text\">filter</code>, <code class=\"language-text\">reduce</code> 같은 메소드를 쓰면 자동으로 선언적 코드가 된다고 생각하는 경우가 많다.</p>\n<p>하지만 마찬가지로 배열 메소드를 사용하더라도 얼마든지 절차적인 사고가 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 배열 메소드를 사용했지만 절차적 사고</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">processItems</span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> items\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> price <span class=\"token operator\">=</span> item<span class=\"token punctuation\">.</span>basePrice<span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span>discount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        price <span class=\"token operator\">=</span> price <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> item<span class=\"token punctuation\">.</span>discount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      price <span class=\"token operator\">=</span> price <span class=\"token operator\">*</span> <span class=\"token number\">1.1</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>item<span class=\"token punctuation\">,</span> finalPrice<span class=\"token operator\">:</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>price <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>finalPrice <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>반면 선언적인 접근은 각각의 변환이 나타내는 비즈니스 관계에만 집중하여 기술한다는 차이점이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// 진정한 선언적 접근</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">processItems</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">items</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  items\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>applyDiscount<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>addTax<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>formatPrice<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>hasValidPrice<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">applyDiscount</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>item<span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">price</span><span class=\"token operator\">:</span> item<span class=\"token punctuation\">.</span>basePrice <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span>discount <span class=\"token operator\">||</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">addTax</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>item<span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">price</span><span class=\"token operator\">:</span> item<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token number\">1.1</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">formatPrice</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>item<span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">finalPrice</span><span class=\"token operator\">:</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">100</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">hasValidPrice</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>finalPrice <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 코드는 배열 메소드를 사용했지만 여전히 단계별 처리 과정에 집중하고 있지만, 두 번째 코드는 각각의 변환이 나타내는 비즈니스 관계를 명확히 선언하고 있다.</p>\n<p>중요한 것은 그 함수가 무엇을 하는지를 명확하게 표현하는 올바른 추상화까지 곁들여야 한다는 것이다.</p>\n<p>결국 함수 자체는 중립적인 도구다. 절차적 사고를 함수로 포장할 수도 있고, 관계적 사고를 함수로 표현할 수도 있다. 선언적 프로그래밍의 핵심은 함수 사용 여부가 아니라, 그 함수가 어떤 추상화를 제공하느냐에 따라 달라진다.</p>\n<p>대략적인 예시만으로는 이해가 쉽지 않을 수 있으니 이제 본질적인 부분을 살펴보도록 하자.</p>\n<h2 id=\"수학적-관점에서-본-선언적-프로그래밍\" style=\"position:relative;\">수학적 관점에서 본 선언적 프로그래밍<a href=\"#%EC%88%98%ED%95%99%EC%A0%81-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-%EC%84%A0%EC%96%B8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"수학적 관점에서 본 선언적 프로그래밍 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>선언적 프로그래밍을 제대로 이해하려면 먼저 “선언”이라는 개념 자체를 이해해야 한다. 이를 가장 쉽게 이해할 수 있는 방법은 일상의 예시부터 시작하는 것이다.</p>\n<p>우리가 요리 레시피를 생각해보자. 절차적 접근은 레시피와 같다. “물 2컵을 끓인다, 면을 넣고 3분간 끓인다, 스프를 넣고 1분간 더 끓인다, 그릇에 담는다”라는 시간의 흐름에 따른 행동 지침이다.</p>\n<p>반면 선언적 접근은 관계를 표현한다. “라면 = 삶은 면 + 스프 + 뜨거운 물의 조합”이라는 재료들 사이의 본질적 관계를 나타낸다.</p>\n<p>레시피는 시간의 흐름에 따른 행동 지침이고, 관계적 선언은 재료들 사이의 본질적 관계를 나타낸다. 이 차이가 바로 절차적 사고와 선언적 사고의 본질적 차이다.</p>\n<p>수학에서 더 명확한 예를 살펴보자. 우리가 중학교 때 배운 일차함수 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">f(x) = 2x + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>을 생각해보자. 이 수식은 컴퓨터에게 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>에 2를 곱하고 1을 더하라”는 명령이 아니다. 이는 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span></span> 사이에는 이런 관계가 있다”는 사실을 선언한 것이다.</p>\n<p>이 선언은 관계에 대한 기술이기 때문에 시간과 무관한 영원한 진리다. 언제 어디서나 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>가 3이라면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span></span>는 7이라는 것이다. 여기서 계산 과정이나 실행 순서는 중요하지 않다. 중요한 것은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>의 관계 그 자체다.</p>\n<p>수학자들이 함수를 정의할 때 주목하는 것은 바로 이런 불변적 관계다. 함수는 계산 알고리즘이 아니라 구조 간의 대응 관계를 나타내는 것이다. 우리가 삼각함수 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\sin(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">sin</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span></span>를 정의할 때, 우리는 단위원에서 각도와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span>좌표 사이의 관계를 선언하는 것이지, 어떻게 계산할지를 지시하는 것이 아닌 것과 마찬가지이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ce883bea384b4c39d034555b129d50a2/151cf/image1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxYEj//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAYEAADAQEAAAAAAAAAAAAAAAAAEBEBQf/aAAgBAQABPyHqwhF//9oADAMBAAIAAwAAABCzz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAAIDAQEBAAAAAAAAAAAAAAERACExQVGR/9oACAEBAAE/EGSd4Zo0ivZnuxW2fsVdgFT/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image1\" title=\"\" src=\"/static/ce883bea384b4c39d034555b129d50a2/c08c5/image1.jpg\" srcset=\"/static/ce883bea384b4c39d034555b129d50a2/0913d/image1.jpg 160w,\n/static/ce883bea384b4c39d034555b129d50a2/cb69c/image1.jpg 320w,\n/static/ce883bea384b4c39d034555b129d50a2/c08c5/image1.jpg 640w,\n/static/ce883bea384b4c39d034555b129d50a2/6a068/image1.jpg 960w,\n/static/ce883bea384b4c39d034555b129d50a2/151cf/image1.jpg 1181w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>우리가 삼각비 표를 외우는 것은 sin, cos, tan 함수가 나타내는 관계를 외우는 것이다</small>\n</center>\n<p>프로그래밍에서도 마찬가지다. 선언적 코드는 컴퓨터에게 어떤 일을 할지 주문하는 것이 아니라 “이 문제의 본질은 이런 관계에 있다”는 것을 표현한다. 이런 관점에서 보면, 프로그래밍은 계산 과정을 지시하는 것이 아니라 문제 도메인의 수학적 구조를 발견하고 표현하는 행위가 된다.</p>\n<h2 id=\"절차적-vs-선언적-사고방식의-차이\" style=\"position:relative;\">절차적 vs 선언적: 사고방식의 차이<a href=\"#%EC%A0%88%EC%B0%A8%EC%A0%81-vs-%EC%84%A0%EC%96%B8%EC%A0%81-%EC%82%AC%EA%B3%A0%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"절차적 vs 선언적 사고방식의 차이 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이제 같은 기능을 두 가지 사고방식으로 접근한 구체적 예시를 통해 차이점을 명확히 해보자. 절차적 사고는 시간의 흐름 속에서 일어나는 변화에 집중한다. “먼저 이것을 하고, 그 다음에 저것을 하고…”라는 순차적 실행 모델이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// 절차적 프로그래밍 - 어떻게(How) 할 것인가에 집중</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateTotalPrice</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">items</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> total <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token comment\">// 단계 1: 각 아이템을 순회</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> items<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> item <span class=\"token operator\">=</span> items<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 단계 2: 유효성 검사</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span>quantity <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 단계 3: 기본 가격 계산</span>\n      <span class=\"token keyword\">let</span> itemPrice <span class=\"token operator\">=</span> item<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> item<span class=\"token punctuation\">.</span>quantity<span class=\"token punctuation\">;</span>\n      \n      <span class=\"token comment\">// 단계 4: 할인 적용</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span>discount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        itemPrice <span class=\"token operator\">=</span> itemPrice <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>itemPrice <span class=\"token operator\">*</span> item<span class=\"token punctuation\">.</span>discount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      \n      <span class=\"token comment\">// 단계 5: 총합에 누적</span>\n      total <span class=\"token operator\">=</span> total <span class=\"token operator\">+</span> itemPrice<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">return</span> total<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 코드는 시간적 순서와 상태 변화에 집중한다. 각 단계에서 무엇이 일어나는지, 변수가 어떻게 변하는지를 추적해야 한다.</p>\n<p>반면 선언적 사고는 시간을 초월한 논리적 관계에 집중한다. “총 가격 = 유효한 아이템들의 할인된 가격들의 합”이라는 관계를 선언한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// 선언적 프로그래밍 - 무엇을(What) 원하는가에 집중</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">calculateTotalPrice</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">items</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  items\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>hasValidQuantity<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>calculateItemPrice<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">hasValidQuantity</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>quantity <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">calculateItemPrice</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> \n  item<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> item<span class=\"token punctuation\">.</span>quantity <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span>discount <span class=\"token operator\">||</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sum</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 코드는 데이터 변환의 관계를 선언한다. 각 함수는 특정한 변환 관계를 나타내고, 이들의 합성으로 전체 문제를 해결한다.</p>\n<p>프로그래밍에서 이 차이는 코드가 표현하는 추상화의 종류로 드러난다. 절차적 코드는 컴퓨터의 실행 과정을 추상화한다. 메모리 할당, 루프 실행, 조건 분기 같은 기계적 연산을 변수와 제어 구조로 포장한다. 선언적 코드는 문제 도메인의 논리적 구조를 추상화한다. 비즈니스 규칙, 데이터 관계, 상태 변환 같은 개념적 관계를 함수와 타입으로 표현한다.</p>\n<p>그렇다면 왜 이런 관계적 사고가 중요할까? 근본적인 이유는 인간의 인지적 한계 때문이다. 심리학자 조지 밀러(George Miller)의 연구에 따르면, 인간의 단기 기억은 동시에 7±2개의 정보 단위만 처리할 수 있다고 한다.</p>\n<p>그러나 절차적 사고에서는 시간의 흐름에 따른 상태 변화를 모두 추적해야 하며 프로그램이 복잡해질수록 이런 상태들의 조합이 기하급수적으로 증가한다. 10개의 변수가 있다면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup><mo>=</mo><mn>1024</mn></mrow><annotation encoding=\"application/x-tex\">2^{10} = 1024</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">10</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1024</span></span></span></span></span>가지의 가능한 상태가 있고, 각 단계에서 이 모든 경우의 수를 고려해야 한다는 의미이다. 인간의 기억력으로 이 모든 변화를 추적하는 것은 불가능에 가깝다.</p>\n<p>반면 관계적 사고에서는 불변적 관계의 합성으로 복잡성을 관리한다. 수학에서 복잡한 함수를 간단한 함수들의 합성으로 표현하는 것과 같은 원리다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">h(x) = f(g(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span></span>를 이해하기 위해 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>의 내부 구현을 모두 알 필요가 없고 각각의 입출력 관계만 이해하면 되는 것처럼 말이다.</p>\n<p>이러한 관계적 사고로 인해 복잡한 상태들을 몇 개의 청크로 나누어 기억할 수 있게 되고, 이는 우리가 복잡한 코드를 이해하는 데 큰 도움을 준다.</p>\n<h2 id=\"jsx는-왜-선언적일까\" style=\"position:relative;\">JSX는 왜 선언적일까?<a href=\"#jsx%EB%8A%94-%EC%99%9C-%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%BC%EA%B9%8C\" aria-label=\"jsx는 왜 선언적일까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이제 평소에 우리가 자주 접하는 대표적인 선언적 도구인 JSX를 예시로 한번 살펴보자. 앞서 제기한 “왜 특정 코드가 선언적인가?”라는 질문에 대해 JSX를 통해 한번 알아보려고 한다.</p>\n<p>필자가 인터뷰에서 자주 보는 광경 중 하나는 바로 “선언적인 코드란 무엇인가?”라는 질문에 “JSX나 React 같은 도구를 사용하는 것”이라고 답하는 것이다. 이때 “그럼 JSX는 왜 선언적인가요?”라고 물어보면 “JSX를 사용하면 선언적인 코드를 작성할 수 있어서요”라고 답변하는, 전형적인 순환논법에 빠지는 경우가 많았다.</p>\n<p>JSX가 선언적인 진짜 이유는 구조적 관계를 표현하는 방식에 있다. 두 가지 접근법을 비교해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">createUserProfile</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> container <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  container<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> <span class=\"token string\">'user-profile'</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">const</span> nameElement <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'h2'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  nameElement<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n  container<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>nameElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">const</span> emailElement <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  emailElement<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">;</span>\n  container<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>emailElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>avatar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> avatarElement <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'img'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    avatarElement<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>avatar<span class=\"token punctuation\">;</span>\n    avatarElement<span class=\"token punctuation\">.</span>alt <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>user<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">의 아바타</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n    container<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>avatarElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">return</span> container<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">UserProfile</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> user <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>user-profile<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>avatar <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>avatar<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">alt</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>user<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">의 아바타</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 코드는 DOM 요소를 생성하고 조작하는 순서에 집중한다. “먼저 컨테이너를 만들고, 그 다음 이름 요소를 만들어서 추가하고, 이메일 요소를 만들어서 추가하고…” 라는 시간적 순서가 중요하다. 심지어 각 <code class=\"language-text\">appendChild</code> 호출의 순서를 바꾸면 결과도 달라진다.</p>\n<p>반면 JSX로 작성된 두 번째 코드는 “UserProfile은 이름, 이메일, 그리고 선택적으로 아바타로 구성된 구조다”라는 관계를 선언하는 것에만 집중한다. 여기서는 요소들 사이의 포함 관계와 계층 구조가 중요하며 시간적 순서는 전혀 중요하지 않다.</p>\n<h3 id=\"데이터와-ui의-대응-관계\" style=\"position:relative;\">데이터와 UI의 대응 관계<a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%99%80-ui%EC%9D%98-%EB%8C%80%EC%9D%91-%EA%B4%80%EA%B3%84\" aria-label=\"데이터와 ui의 대응 관계 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>JSX의 진짜 힘은 데이터 구조와 UI 구조 사이의 대응 관계를 직관적으로 표현할 수 있다는 점에 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">TodoList</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> todos <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token punctuation\">{</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">todo</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">TodoItem</span></span> \n        <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>todo<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span> \n        <span class=\"token attr-name\">text</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>todo<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">}</span></span> \n        <span class=\"token attr-name\">completed</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>todo<span class=\"token punctuation\">.</span>completed<span class=\"token punctuation\">}</span></span> \n      <span class=\"token punctuation\">/></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 코드를 보면 <code class=\"language-text\">todos</code> 배열의 각 항목이 <code class=\"language-text\">TodoItem</code> 컴포넌트와 대응된다는 관계가 즉시 읽힌다. 데이터의 구조가 곧 UI의 구조가 되는 것이다.</p>\n<p>같은 동작을 명령형으로 작성하면 이렇게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">createTodoList</span><span class=\"token punctuation\">(</span>todos<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> ul <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ul'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> todos<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> li <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'li'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    li<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> todos<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>todos<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>completed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      li<span class=\"token punctuation\">.</span>classList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'completed'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    ul<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>li<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">return</span> ul<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>명령형 코드에서는 데이터 순회, 요소 생성, 속성 설정, DOM 추가 등의 절차적 단계들이 섞여 있다. 데이터의 구조와 최종 UI의 구조 사이의 관계를 파악하려면 전체 코드를 읽고 머릿속으로 실행해봐야 한다.</p>\n<h3 id=\"구조적-관계의-표현\" style=\"position:relative;\">구조적 관계의 표현<a href=\"#%EA%B5%AC%EC%A1%B0%EC%A0%81-%EA%B4%80%EA%B3%84%EC%9D%98-%ED%91%9C%ED%98%84\" aria-label=\"구조적 관계의 표현 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>JSX는 수학에서 집합의 관계를 표현하는 것과 비슷하다. 수학에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">A = \\{a, b, c\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">}</span></span></span></span></span>라고 쓸 때, 우리는 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>가 원소 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">a, b, c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></span>로 구성된다는 관계를 선언한다. 이 관계는 원소들을 어떤 순서로 집합에 넣었는지와는 무관하다.</p>\n<p>JSX도 마찬가지다. 아래와 같은 코드를 쓸 때, 우리는 ”<code class=\"language-text\">UserCard</code>는 <code class=\"language-text\">Avatar</code>와 <code class=\"language-text\">UserInfo</code>로 구성된다”는 구조적 관계를 선언한다. 이 관계는 컴포넌트들이 어떤 순서로 렌더링되는지와는 개념적으로 분리되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 구조적 관계의 선언</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">UserCard</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> user <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>user-card<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Avatar</span></span> <span class=\"token attr-name\">src</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>avatar<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserInfo</span></span> <span class=\"token attr-name\">name</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">email</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>즉, “사용자 카드는 아바타, 사용자 정보의 조합이다”라는 관계를 선언하는 것에만 집중하고 각 컴포넌트가 어떻게 구현되는지, 어떤 순서로 DOM에 추가되는지는 이 관계 선언과는 별개의 관심사다.</p>\n<p>이런 관점에서 보면, JSX가 선언적인 이유는 복잡한 과정을 숨겨주는 것 뿐 아니라, 데이터와 UI 사이의 본질적 관계를 직접적으로 표현할 수 있게 해주기 때문이다.</p>\n<p>JSX가 선언적인 이유를 이해했다면, 이제 한 가지 의문이 들 수 있다.</p>\n<blockquote>\n<p>“그런데 JSX도 결국 <code class=\"language-text\">createElement</code>로 변환되고, React의 reconciliation도 절차적 코드 아닌가? 그럼 이게 정말 선언적인 건가?”</p>\n</blockquote>\n<h2 id=\"선언적과-절차적은-상대적이다\" style=\"position:relative;\">선언적과 절차적은 상대적이다<a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81%EA%B3%BC-%EC%A0%88%EC%B0%A8%EC%A0%81%EC%9D%80-%EC%83%81%EB%8C%80%EC%A0%81%EC%9D%B4%EB%8B%A4\" aria-label=\"선언적과 절차적은 상대적이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이는 추상화나 선언적인 프로그래밍을 이해할 때 매우 핵심적인 부분인데, 이 개념들을 절대적인 무언가로 이해하면 치명적인 오개념이 생길 수 있다.</p>\n<p>실제로는 같은 코드라도 관찰하는 관점과 추상화 레벨에 따라 선언적일 수도, 절차적일 수도 있다. “선언적”과 “절차적”은 절대적인 구분이 아니라 상대적인 개념이다.</p>\n<p>React Query를 사용한 예시로 이런 상대성을 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 애플리케이션 레벨 - 선언적</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">useUserData</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'user'</span><span class=\"token punctuation\">,</span> userId<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">UserProfile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> userId <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token operator\">:</span> user<span class=\"token punctuation\">,</span> isLoading<span class=\"token punctuation\">,</span> error <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useUserData</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isLoading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">로딩 중...</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">에러가 발생했습니다</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>애플리케이션 개발자의 관점에서 보면 이 코드는 완전히 선언적이다. ”<code class=\"language-text\">userId</code>에 해당하는 사용자 데이터를 가져오는 쿼리”라는 관계를 선언하고 있다. 캐싱, 재시도, 에러 처리 같은 복잡한 로직은 모두 추상화되어 있다.</p>\n<p>하지만 <code class=\"language-text\">useQuery</code>의 핵심 로직인 <a href=\"https://github.com/TanStack/query/blob/main/packages/query-core/src/queryClient.ts\" target=\"_blank\" rel=\"nofollow\">QueryClient를 구현하는 코드</a>는 절차적이다. 캐시 확인, 네트워크 요청, 상태 업데이트, 재시도 로직 등 복잡한 절차적 과정들이 모두 드러나 있다.</p>\n<p>이런 상대성은 도메인 경계에서 특히 명확하게 드러난다. 비즈니스 로직 레벨에서 주문을 처리하는 함수를 보면 이렇다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 비즈니스 로직 레벨 - 선언적</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">processOrder</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> validatedOrder <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">validateOrder</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> payment <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">processPayment</span><span class=\"token punctuation\">(</span>validatedOrder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> shipment <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">scheduleShipment</span><span class=\"token punctuation\">(</span>validatedOrder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">return</span> <span class=\"token function\">createOrderConfirmation</span><span class=\"token punctuation\">(</span>validatedOrder<span class=\"token punctuation\">,</span> payment<span class=\"token punctuation\">,</span> shipment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 비즈니스 로직 관점에서는 선언적이다. “주문을 검증하고, 결제를 처리하고, 배송을 스케줄링한다”는 관계를 명확히 표현한다. 하지만 그 아래 결제 처리 같은 인프라 레벨 함수들은 절차적이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 인프라 레벨 - 절차적</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">processPayment</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> paymentGateway <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PaymentGateway</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">PAYMENT_API_KEY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> paymentRequest <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      amount<span class=\"token operator\">:</span> order<span class=\"token punctuation\">.</span>total<span class=\"token punctuation\">,</span>\n      currency<span class=\"token operator\">:</span> order<span class=\"token punctuation\">.</span>currency<span class=\"token punctuation\">,</span>\n      source<span class=\"token operator\">:</span> order<span class=\"token punctuation\">.</span>paymentMethod\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> paymentGateway<span class=\"token punctuation\">.</span><span class=\"token function\">charge</span><span class=\"token punctuation\">(</span>paymentRequest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token string\">'succeeded'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">await</span> database<span class=\"token punctuation\">.</span>payments<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        orderId<span class=\"token operator\">:</span> order<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n        paymentId<span class=\"token operator\">:</span> response<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n        amount<span class=\"token operator\">:</span> response<span class=\"token punctuation\">.</span>amount<span class=\"token punctuation\">,</span>\n        status<span class=\"token operator\">:</span> <span class=\"token string\">'completed'</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      \n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> success<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> paymentId<span class=\"token operator\">:</span> response<span class=\"token punctuation\">.</span>id <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PaymentError</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Payment processing failed'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> orderId<span class=\"token operator\">:</span> order<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> error <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">throw</span> error<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이처럼 선언적이라는 개념은 어떤 계층에서 바라보냐에 따라 상대적일 수 밖에 없다. 결국 선언적인 코드의 포인트는 절차적으로 작성된 부분을 얼마나 덜 확인할 수 있도록 추상화된 부분을 잘 표현해주는 것이냐에 따라 달려있다.</p>\n<p>또한 “절차적 코드는 나쁘고 무조건 피해야 할 것”이라는 편견도 흔히 볼 수 있는데, 이 역시 잘못된 생각이다. 가장 우아한 함수형 코드도 결국 CPU의 절차적 명령어로 실행되기 때문이다.</p>\n<p>중요한 것은 적절한 레벨에서 적절한 추상화를 제공하는 것이다.</p>\n<p>이런 상대성을 이해하면 각 레벨에서 적절한 추상화를 찾는 것이 중요하다는 것을 알 수 있다. 모든 것을 선언적으로 만들려고 할 필요는 없다. 비즈니스 로직 레벨에서는 선언적으로 접근하는 것이 좋다. 도메인의 본질적 관계를 표현하는 데 집중해야 하기 때문이다. 반면 인프라 레벨에서는 절차적이어도 괜찮다. 효율적이고 안전한 구현이 더 중요하기 때문이다.</p>\n<p>핵심은 경계를 명확히 하고 추상화의 레벨을 맞춰주는 것이다. 어느 레벨에서 어떤 관심사를 다루는지 분명히 구분해야 한다. 좋은 예를 보면, 비즈니스 레벨에서는 선언적으로 쇼핑카트의 구조를 표현하고, 인프라 레벨에서는 절차적인 계산 로직을 사용해도 문제없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 좋은 예: 명확한 레벨 분리</span>\n\n<span class=\"token comment\">// 비즈니스 레벨 - 선언적</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ShoppingCart</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> items<span class=\"token punctuation\">,</span> onCheckout <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>shopping-cart<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ItemList</span></span> <span class=\"token attr-name\">items</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>items<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">TotalPrice</span></span> <span class=\"token attr-name\">items</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>items<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CheckoutButton</span></span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">onCheckout</span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 프레젠테이션 레벨 - 선언적</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ItemList</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> items <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>item-list<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token punctuation\">{</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ItemCard</span></span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">item</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 인프라 레벨 - 절차적이어도 OK</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateTotalWithTax</span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> taxRate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> subtotal <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> item <span class=\"token keyword\">of</span> items<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    subtotal <span class=\"token operator\">+=</span> item<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> item<span class=\"token punctuation\">.</span>quantity<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">const</span> tax <span class=\"token operator\">=</span> subtotal <span class=\"token operator\">*</span> taxRate<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> subtotal <span class=\"token operator\">+</span> tax<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이런 관점에서 보면, 선언적 프로그래밍은 “모든 코드를 선언적으로 만드는 것”이 아니라 “적절한 추상화 레벨에서 적절한 표현력을 갖는 것”이라고 할 수 있다.</p>\n<h2 id=\"선언적인-코드라고-착각하는-코드-vs-진짜-선언적인-코드\" style=\"position:relative;\">선언적인 코드라고 착각하는 코드 vs 진짜 선언적인 코드<a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%B8-%EC%BD%94%EB%93%9C%EB%9D%BC%EA%B3%A0-%EC%B0%A9%EA%B0%81%ED%95%98%EB%8A%94-%EC%BD%94%EB%93%9C-vs-%EC%A7%84%EC%A7%9C-%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%B8-%EC%BD%94%EB%93%9C\" aria-label=\"선언적인 코드라고 착각하는 코드 vs 진짜 선언적인 코드 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이제 앞서 제기한 핵심 질문인 “왜 특정 코드가 선언적인가?”에 구체적으로 답해보자. 선언적 코드의 핵심은 “가능한 상태들 간의 관계”를 명확히 정의하는 것이다.</p>\n<p>수학에서 함수의 정의역을 명확히 하는 것처럼, 프로그램에서도 “어떤 상태 조합이 논리적으로 가능한가”를 먼저 선언해야 한다.</p>\n<p>비동기 데이터 요청을 생각해보면, 실제로는 아직 시작하지 않음(idle), 요청 중(loading), 성공(데이터 있음), 실패(에러 있음) 같은 상태들만 논리적으로 가능하다. “로딩 중이면서 동시에 데이터도 있고 에러도 있는” 상태는 현실에서는 일어날 수 없는 모순된 조합이다.</p>\n<p>React + TypeScript 환경에서 비동기 데이터를 다루는 상황을 통해 이런 선언적 사고의 본질을 구체적으로 살펴보자.</p>\n<h3 id=\"착각하는-코드---상태-변화-과정에-집중\" style=\"position:relative;\">착각하는 코드 - 상태 변화 과정에 집중<a href=\"#%EC%B0%A9%EA%B0%81%ED%95%98%EB%8A%94-%EC%BD%94%EB%93%9C---%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94-%EA%B3%BC%EC%A0%95%EC%97%90-%EC%A7%91%EC%A4%91\" aria-label=\"착각하는 코드   상태 변화 과정에 집중 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>절차적 접근으로 작성된 비동기 데이터 훅을 보면 상태가 어떻게 변하는지에 집중하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 절차적 접근 - 상태가 어떻게 변하는지에 집중</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">useAsyncData</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">fetcher</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>data<span class=\"token punctuation\">,</span> setData<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useState</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>loading<span class=\"token punctuation\">,</span> setLoading<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>error<span class=\"token punctuation\">,</span> setError<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useState</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 1단계: 로딩 상태로 전환</span>\n    <span class=\"token function\">setLoading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setError</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setData</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">fetcher</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 2단계: 성공 상태로 전환</span>\n        <span class=\"token function\">setData</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setLoading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span>err <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 3단계: 에러 상태로 전환</span>\n        <span class=\"token function\">setError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setLoading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setData</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>fetcher<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> loading<span class=\"token punctuation\">,</span> error <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"선언적인-코드---상태-관계에-집중\" style=\"position:relative;\">선언적인 코드 - 상태 관계에 집중<a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%B8-%EC%BD%94%EB%93%9C---%EC%83%81%ED%83%9C-%EA%B4%80%EA%B3%84%EC%97%90-%EC%A7%91%EC%A4%91\" aria-label=\"선언적인 코드   상태 관계에 집중 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>선언적 접근으로 작성하면 가능한 상태가 무엇인지에 집중한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 선언적 접근 - 가능한 상태가 무엇인지에 집중</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">AsyncDataState<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> \n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'idle'</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'loading'</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'success'</span><span class=\"token punctuation\">;</span> data<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'error'</span><span class=\"token punctuation\">;</span> error<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">useAsyncData</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">fetcher</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> AsyncDataState<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useState</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>AsyncDataState<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">>></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'idle'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'loading'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token function\">fetcher</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">=></span> <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'success'</span><span class=\"token punctuation\">,</span> data <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span>error <span class=\"token operator\">=></span> <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'error'</span><span class=\"token punctuation\">,</span> error<span class=\"token operator\">:</span> error<span class=\"token punctuation\">.</span>message <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>fetcher<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"왜-첫-번째-코드가-절차적인가\" style=\"position:relative;\">왜 첫 번째 코드가 절차적인가?<a href=\"#%EC%99%9C-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%EC%BD%94%EB%93%9C%EA%B0%80-%EC%A0%88%EC%B0%A8%EC%A0%81%EC%9D%B8%EA%B0%80\" aria-label=\"왜 첫 번째 코드가 절차적인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>첫 번째 코드는 상태 변화의 순서와 과정에 집중한다. “먼저 로딩을 <code class=\"language-text\">true</code>로 설정하고, 에러를 <code class=\"language-text\">null</code>로 초기화하고, 데이터를 <code class=\"language-text\">null</code>로 리셋하고…” 같은 절차적 명령의 나열이다.</p>\n<p>더 중요한 문제는 불가능한 상태 조합이 타입 수준에서 허용된다는 점이다. TypeScript가 <code class=\"language-text\">{ data: someUserData, loading: true, error: \"Network Error\" }</code>라는 말이 안 되는 상태를 막아주지 못한다. 데이터가 있으면서 동시에 로딩 중이고 에러도 있다는 것은 논리적으로 모순이다. 하지만 첫 번째 방식에서는 개발자가 모든 상태 조합의 유효성을 수동으로 보장해야 한다.</p>\n<p>각 <code class=\"language-text\">setState</code> 호출마다 다른 상태들을 올바르게 초기화했는지 일일이 확인해야 하고, 이는 휴먼 에러로 이어지기 쉽다. 예를 들어 성공 시에 <code class=\"language-text\">setLoading(false)</code>를 깜빡하거나, 에러 시에 <code class=\"language-text\">setData(null)</code>을 빼먹을 수 있다.</p>\n<h3 id=\"두-번째-코드는-왜-선언적인가\" style=\"position:relative;\">두 번째 코드는 왜 선언적인가?<a href=\"#%EB%91%90-%EB%B2%88%EC%A7%B8-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%84%A0%EC%96%B8%EC%A0%81%EC%9D%B8%EA%B0%80\" aria-label=\"두 번째 코드는 왜 선언적인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>두 번째 코드는 “비동기 데이터 요청”이라는 도메인의 본질적 상태 관계를 선언한다. Union Type을 통해 “이 네 가지 상태 중 정확히 하나만 존재할 수 있다”는 불변적 관계를 타입 수준에서 표현한다.</p>\n<p>여기서 핵심은 불가능한 상태를 원천적으로 차단한다는 점이다. TypeScript 컴파일러가 로딩 중이면서 동시에 성공 상태 같은 모순된 조합을 컴파일 타임에 방지해준다. 이는 수학에서 집합의 정의역을 명확히 하는 것과 같은 원리다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f: A \\rightarrow B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>는 함수 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>의 정의역이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>에 속하지 않는 값에 대해서는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>가 정의되지 않는다.</p>\n<p>Union Type이 제공하는 안전장치를 더 구체적으로 살펴보면, TypeScript가 컴파일 타임에 강제하는 안전성을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// TypeScript가 컴파일 타임에 강제하는 안전성</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">handleAsyncState</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>state<span class=\"token operator\">:</span> AsyncDataState<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'idle'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">\"아직 시작하지 않음\"</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">case</span> <span class=\"token string\">'loading'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token string\">\"로딩 중...\"</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 여기서 state.data나 state.error 접근 시 컴파일 에러</span>\n    \n    <span class=\"token keyword\">case</span> <span class=\"token string\">'success'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">데이터: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>state<span class=\"token punctuation\">.</span>data<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 여기서는 state.data가 확실히 존재</span>\n      <span class=\"token comment\">// state.error 접근 시 컴파일 에러</span>\n    \n    <span class=\"token keyword\">case</span> <span class=\"token string\">'error'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">에러: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>state<span class=\"token punctuation\">.</span>error<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 여기서는 state.error가 확실히 존재</span>\n      <span class=\"token comment\">// state.data 접근 시 컴파일 에러</span>\n    \n    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n      <span class=\"token comment\">// TypeScript가 모든 case를 다뤘는지 검증</span>\n      <span class=\"token keyword\">const</span> exhaustiveCheck<span class=\"token operator\">:</span> <span class=\"token builtin\">never</span> <span class=\"token operator\">=</span> state<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> exhaustiveCheck<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>각 case에서는 해당 상태에서만 유효한 속성에만 접근할 수 있고, 다른 속성에 접근하려고 하면 컴파일 에러가 발생한다. 또한 <code class=\"language-text\">default</code> 케이스의 <code class=\"language-text\">never</code> 타입을 통해 모든 경우를 다뤘는지 컴파일러가 검증해준다.</p>\n<h3 id=\"컴포넌트에서-사용할-때의-차이\" style=\"position:relative;\">컴포넌트에서 사용할 때의 차이<a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"컴포넌트에서 사용할 때의 차이 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>첫 번째 방식을 사용하면 개발자가 모든 조합을 수동으로 처리해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 첫 번째 방식 - 모든 조합을 수동으로 처리</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">DataDisplay</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> fetcher<span class=\"token punctuation\">,</span> render <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token function-variable function\">fetcher</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> \n  <span class=\"token function-variable function\">render</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>data<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> React<span class=\"token punctuation\">.</span>ReactNode<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> loading<span class=\"token punctuation\">,</span> error <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useAsyncData</span><span class=\"token punctuation\">(</span>fetcher<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 개발자가 모든 경우의 수를 수동으로 고려해야 함</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>error <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>data<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">LoadingSpinner</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>loading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ErrorMessage</span></span> <span class=\"token attr-name\">error</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>error<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>loading <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>error<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">render</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token comment\">// 예상치 못한 상태 조합들은 어떻게 처리할까?</span>\n  <span class=\"token comment\">// { loading: true, data: someData, error: null } 같은 경우는?</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">알 수 없는 상태</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>반면 두 번째 방식을 사용하면 타입이 모든 경우를 보장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 두 번째 방식 - 타입이 모든 경우를 보장</span>\n<span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">DataDisplay</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> fetcher<span class=\"token punctuation\">,</span> render <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> \n  <span class=\"token function-variable function\">fetcher</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> \n  <span class=\"token function-variable function\">render</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>data<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> React<span class=\"token punctuation\">.</span>ReactNode<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> state <span class=\"token operator\">=</span> <span class=\"token function\">useAsyncData</span><span class=\"token punctuation\">(</span>fetcher<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// TypeScript가 모든 case를 처리했는지 검증</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'idle'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">준비 중...</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n      \n    <span class=\"token keyword\">case</span> <span class=\"token string\">'loading'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">LoadingSpinner</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n      \n    <span class=\"token keyword\">case</span> <span class=\"token string\">'success'</span><span class=\"token operator\">:</span>\n      <span class=\"token comment\">// state.data가 확실히 T 타입으로 존재</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">render</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      \n    <span class=\"token keyword\">case</span> <span class=\"token string\">'error'</span><span class=\"token operator\">:</span>\n      <span class=\"token comment\">// state.error가 확실히 존재</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ErrorMessage</span></span> <span class=\"token attr-name\">error</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>state<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n      \n    <span class=\"token comment\">// TypeScript가 모든 case를 다뤘는지 컴파일 타임에 검증</span>\n    <span class=\"token comment\">// 새로운 상태가 추가되면 컴파일 에러로 알려줌</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>TypeScript가 모든 case를 처리했는지 검증하고, 각 case에서 해당 속성이 확실히 존재함을 보장한다. 새로운 상태가 추가되면 컴파일 에러를 통해 놓친 부분을 알려준다.</p>\n<h3 id=\"확장성-측면에서의-차이\" style=\"position:relative;\">확장성 측면에서의 차이<a href=\"#%ED%99%95%EC%9E%A5%EC%84%B1-%EC%B8%A1%EB%A9%B4%EC%97%90%EC%84%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"확장성 측면에서의 차이 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>새로운 상태를 추가해야 하는 상황을 생각해보자. 첫 번째 방식에서는 여러 변수를 모두 수정해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 첫 번째 방식 - 여러 변수를 모두 수정해야 함</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>retrying<span class=\"token punctuation\">,</span> setRetrying<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>stale<span class=\"token punctuation\">,</span> setStale<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 각 상태 변화마다 다른 모든 상태들과의 조합을 고려해야 함</span>\n<span class=\"token comment\">// 16가지 boolean 조합 중 논리적으로 말이 되는 것은 몇 개일까?</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>반면 두 번째 방식에서는 타입 정의만 확장하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 두 번째 방식 - 타입 정의만 확장</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">AsyncDataState<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> \n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'idle'</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'loading'</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'retrying'</span><span class=\"token punctuation\">;</span> previousError<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> attempt<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'success'</span><span class=\"token punctuation\">;</span> data<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span> stale<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'error'</span><span class=\"token punctuation\">;</span> error<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// TypeScript가 모든 사용처에서 새로운 case 처리를 강제</span>\n<span class=\"token comment\">// 컴파일 에러를 통해 놓친 부분을 알려줌</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>새로운 상태를 추가하면 TypeScript가 모든 사용처에서 새로운 case를 처리하도록 강제한다. 컴파일 에러를 통해 놓친 부분을 확실히 알려주기 때문에 안전하게 확장할 수 있다.</p>\n<p>이 예시에서 보는 선언적 사고의 핵심은 “무엇이 가능한가”를 먼저 정의하는 것이다. 수학에서 함수의 정의역과 치역을 명확히 하는 것처럼, 비동기 요청의 가능한 상태들을 명시적으로 선언한다.</p>\n<p>절차적 접근은 “어떻게 상태를 변경할 것인가”에 집중하지만, 선언적 접근은 “이 문제 도메인에서 어떤 상태들이 논리적으로 가능한가”를 먼저 선언한다. 이런 관점 전환이 바로 선언적 프로그래밍의 본질이다.</p>\n<h2 id=\"실무-적용-가이드라인\" style=\"position:relative;\">실무 적용 가이드라인<a href=\"#%EC%8B%A4%EB%AC%B4-%EC%A0%81%EC%9A%A9-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8\" aria-label=\"실무 적용 가이드라인 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이제 앞서 살펴본 이론을 실무에 적용할 수 있는 구체적인 기준을 정리해보자. 언제 절차적 접근을 택하고 언제 선언적 접근을 택할 것인가에 대한 실용적 가이드라인이다.</p>\n<h3 id=\"언제-선언적-접근을-해야-하는가\" style=\"position:relative;\">언제 선언적 접근을 해야 하는가?<a href=\"#%EC%96%B8%EC%A0%9C-%EC%84%A0%EC%96%B8%EC%A0%81-%EC%A0%91%EA%B7%BC%EC%9D%84-%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"언제 선언적 접근을 해야 하는가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><strong>비즈니스 로직과 상태 관리</strong>에서는 선언적 접근이 유리하다.</p>\n<p>앞서 다룬 비동기 데이터 상태 예시처럼, 복잡한 상태 조합이 가능한 경우에는 타입 수준에서 불가능한 상태를 차단하는 것이 중요하다:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 앞서 다룬 AsyncDataState 예시 재활용</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">AsyncDataState<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> \n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'idle'</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'loading'</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'success'</span><span class=\"token punctuation\">;</span> data<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'error'</span><span class=\"token punctuation\">;</span> error<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>UI 구조 표현</strong>에서도 선언적 접근이 자연스럽다. JSX 예시에서 봤듯이 데이터와 UI 사이의 구조적 관계를 직접 표현할 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token comment\">// JSX 예시 재활용 - 구조적 관계를 명확히 선언</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">UserProfile</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> user <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>user-profile<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>avatar <span class=\"token operator\">&amp;&amp;</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>avatar<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">alt</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>user<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">의 아바타</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>데이터 변환 파이프라인</strong>에서도 각 단계가 독립적으로 정의되고 테스트 가능할 때 선언적 접근이 효과적이다:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 변환 관계를 명확히 선언</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">processUserData</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>rawUsers<span class=\"token operator\">:</span> RawUser<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  rawUsers\n    <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>isActiveUser<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>normalizeUserData<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>addComputedFields<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>byLastLoginDate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"언제-절차적-접근을-해도-되는가\" style=\"position:relative;\">언제 절차적 접근을 해도 되는가?<a href=\"#%EC%96%B8%EC%A0%9C-%EC%A0%88%EC%B0%A8%EC%A0%81-%EC%A0%91%EA%B7%BC%EC%9D%84-%ED%95%B4%EB%8F%84-%EB%90%98%EB%8A%94%EA%B0%80\" aria-label=\"언제 절차적 접근을 해도 되는가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><strong>인프라 레벨과 성능 최적화</strong>에서는 절차적 접근이 적절하다.</p>\n<p>앞서 상대성 섹션에서 다룬 계산 로직처럼, 효율성과 성능이 중요한 경우에는 절차적 구현이 자연스럽다:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 앞서 다룬 계산 로직 예시 재활용</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateTotalWithTax</span><span class=\"token punctuation\">(</span>items<span class=\"token punctuation\">,</span> taxRate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> subtotal <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> item <span class=\"token keyword\">of</span> items<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    subtotal <span class=\"token operator\">+=</span> item<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> item<span class=\"token punctuation\">.</span>quantity<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">const</span> tax <span class=\"token operator\">=</span> subtotal <span class=\"token operator\">*</span> taxRate<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> subtotal <span class=\"token operator\">+</span> tax<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>React Query 내부 구현처럼 <strong>복잡한 상태 관리와 최적화</strong>가 필요한 라이브러리 코드에서도 절차적 접근이 필요하다. 캐시 확인, 네트워크 요청, 상태 업데이트, 재시도 로직 등은 절차적으로 구현하는 것이 효율적이다.</p>\n<p><strong>에러 처리가 복잡한 시스템 레벨 코드</strong>에서도 절차적 접근이 적합하다:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 복잡한 에러 처리와 재시도 로직</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">retryWithBackoff</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">operation</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  maxAttempts<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> lastError<span class=\"token operator\">:</span> Error<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> attempt <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> attempt <span class=\"token operator\">&lt;=</span> maxAttempts<span class=\"token punctuation\">;</span> attempt<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">await</span> <span class=\"token function\">operation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      lastError <span class=\"token operator\">=</span> error <span class=\"token keyword\">as</span> Error<span class=\"token punctuation\">;</span>\n      \n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>attempt <span class=\"token operator\">===</span> maxAttempts<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> lastError<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      \n      <span class=\"token keyword\">const</span> delay <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> attempt <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">await</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token builtin\">Promise</span></span><span class=\"token punctuation\">(</span>resolve <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> delay<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">throw</span> lastError<span class=\"token operator\">!</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>선언적 프로그래밍은 단순히 특정 문법이나 도구를 사용하는 것이 아니다. 그것은 “어떻게”에서 “무엇”으로, 절차에서 관계로 사고하는 방식의 전환이다.</p>\n<p>이번 포스팅에서 다룬 핵심 내용을 정리해보면, 선언적 프로그래밍의 본질은 관계적 사고에 있다. 시간적 순서가 아닌 논리적 관계에 집중하는 것이다. 또한 상태 모델링을 통해 가능한 상태를 먼저 선언하고 불가능한 상태를 원천 차단하는 것이 중요하다. 적절한 추상화를 통해 각 레벨에서 적합한 표현력을 제공해야 하며, 이는 절대적 구분이 아닌 관점과 레벨에 따른 상대적 개념이라는 점을 이해해야 한다.</p>\n<p>진정한 선언적 코드의 특징을 보면, 비즈니스 의도가 코드 구조에서 직접 읽힌다. 기술적 복잡성은 적절한 추상화 뒤로 숨겨지고, 각 부분이 독립적으로 이해 가능하면서도 안전하게 합성된다. 그리고 불가능한 상태가 타입 수준에서 방지된다.</p>\n<p>선언적 프로그래밍은 하루아침에 습득할 수 있는 기술이 아니다. 하지만 꾸준히 연습하고 적절한 추상화 레벨을 찾아가는 과정에서, 더 읽기 쉽고 유지보수하기 쉬운 코드를 작성할 수 있게 될 것이다.</p>\n<p>코드는 컴퓨터를 위한 것이 아니라 사람을 위한 것이다. 선언적 프로그래밍은 바로 그 사람들이 복잡한 문제를 더 쉽게 이해하고 다룰 수 있게 도와주는 강력한 도구다.</p>\n<p>선언적 프로그래밍은 도구가 아니라 사고방식이며, 문법이 아니라 철학이다. 이 철학을 이해하고 실무에 적용할 때, 우리는 더 나은 코드를 작성할 수 있게 된다.</p>","fields":{"slug":"20250907-declarative-programming-misconceptions-and-essence","path":"/2025/09/07/declarative-programming-misconceptions-and-essence/","lang":"ko"},"frontmatter":{"title":"선언적 프로그래밍에 대한 착각과 오해","subTitle":"문법이 아닌 사고방식의 전환이 만드는 진정한 선언적 코드","date":"Sep 07, 2025","categories":["프로그래밍"],"tags":["함수형 프로그래밍","선언적 프로그래밍"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/6a5f574ff07ce78b377e52b976f14a84/d803c/thumbnail.png","srcSet":"/static/6a5f574ff07ce78b377e52b976f14a84/d803c/thumbnail.png 320w,\n/static/6a5f574ff07ce78b377e52b976f14a84/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/6a5f574ff07ce78b377e52b976f14a84/fc5c5/thumbnail.webp 320w,\n/static/6a5f574ff07ce78b377e52b976f14a84/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/6a5f574ff07ce78b377e52b976f14a84/01fb2/thumbnail.png","srcSet":"/static/6a5f574ff07ce78b377e52b976f14a84/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/6a5f574ff07ce78b377e52b976f14a84/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"7a982b73-ead4-5ca1-8bd2-1dee5253ea16","tableOfContents":"<ul>\n<li><a href=\"#%EB%94%9C%EB%A0%88%EB%A7%88%EC%9D%98-%EC%8B%9C%EC%9E%91\">딜레마의 시작</a></li>\n<li><a href=\"#%EB%8B%A4%EC%96%91%EC%84%B1-%EC%A1%B4%EC%A4%91%EC%9D%98-%ED%95%A8%EC%A0%95\">다양성 존중의 함정</a></li>\n<li><a href=\"#%EB%8B%A4%EC%96%91%EC%84%B1%EC%9D%98-%EB%B9%9B%EA%B3%BC-%EA%B7%B8%EB%A6%BC%EC%9E%90\">다양성의 빛과 그림자</a></li>\n<li><a href=\"#%EB%AC%B4%EC%95%84%E7%84%A1%E6%88%91%EC%99%80-%EC%84%B1%EC%9E%A5%EC%9D%98-%EB%B3%80%ED%99%94-%EA%B0%80%EB%8A%A5%EC%84%B1\">무아(無我)와 성장의 변화 가능성</a></li>\n<li><a href=\"#%ED%8C%94%EC%A0%95%EB%8F%84%E5%85%AB%E6%AD%A3%E9%81%93%EC%9D%98-%EC%A7%80%ED%98%9C-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%86%8C%ED%86%B5\">팔정도(八正道)의 지혜: 올바른 소통</a></li>\n<li><a href=\"#%EC%9E%90%EB%B9%84%E6%85%88%E6%82%B2%EC%99%80-%EB%B0%A9%ED%8E%B8%E6%96%B9%E4%BE%BF%EC%9D%98-%EB%A6%AC%EB%8D%94%EC%8B%AD\">자비(慈悲)와 방편(方便)의 리더십</a></li>\n<li><a href=\"#%EC%A4%91%EB%8F%84%E4%B8%AD%E9%81%93%EC%9D%98-%EA%B7%A0%ED%98%95\">중도(中道)의 균형</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","excerpt":"현대 조직에서 ‘다양성’은 거의 신성불가침의 가치로 여겨진다. 다양한 배경을 가진 사람들이 모여 시너지를 만들어내고, 서로 다른 관점이 혁신을 이끌어낸다는 믿음은 이제 상식이 되었다. 특히 IT 업계에서는 다양성과 포용성(Diversity & Inclusion)이 조직 문화의 핵심 키워드로 자리잡았다. 하지만 현실에서 리더로 일하다 보면, 이런 이상적인 원칙들이 생각보다 복잡한 딜레마를 만들어낸다는 것을 깨닫게 된다. 과연 모든 종류의 다양성을 무조건 존중해야 하는 것일까? 개인의 선택과 조직의 목표가 충돌할 때, 리더는 어떤 기…","html":"<p>현대 조직에서 ‘다양성’은 거의 신성불가침의 가치로 여겨진다. 다양한 배경을 가진 사람들이 모여 시너지를 만들어내고, 서로 다른 관점이 혁신을 이끌어낸다는 믿음은 이제 상식이 되었다. 특히 IT 업계에서는 다양성과 포용성(Diversity &#x26; Inclusion)이 조직 문화의 핵심 키워드로 자리잡았다.</p>\n<p>하지만 현실에서 리더로 일하다 보면, 이런 이상적인 원칙들이 생각보다 복잡한 딜레마를 만들어낸다는 것을 깨닫게 된다. 과연 모든 종류의 다양성을 무조건 존중해야 하는 것일까? 개인의 선택과 조직의 목표가 충돌할 때, 리더는 어떤 기준으로 판단해야 할까?</p>\n<p>이번 글에서는 필자가 100명 규모의 프론트엔드 조직에서 챕터 리드로 일을 하면서 마주한 구체적인 딜레마를 통해, 다양성 존중의 한계와 그 속에서 찾은 지혜에 대한 이야기를 해보려고 한다.</p>\n<p>그리고 이 과정에서 불교 철학, 특히 연기법과 중도 사상이 어떻게 현대 조직 운영에 실질적인 통찰을 제공할 수 있는지 살펴볼 것이다.</p>\n<h2 id=\"딜레마의-시작\" style=\"position:relative;\">딜레마의 시작<a href=\"#%EB%94%9C%EB%A0%88%EB%A7%88%EC%9D%98-%EC%8B%9C%EC%9E%91\" aria-label=\"딜레마의 시작 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>리더로서 탁월한 조직을 만들기 위해서는 구성원들의 성장을 지원하고 독려해야하지만 100명이나 되는 사람이 모여있다 보니 구성원들 중에서 생각이 다른 사람도 있을 수밖에 없다.</p>\n<p>최근 필자를 깊은 고민에 빠뜨린 팀원이 있었다. 그 분은 기술적으로 출중한 역량을 가지고 있었고, 현재 맡은 업무를 완벽하게 수행했으며, 동료들로부터도 신뢰를 받는 사람이었다. 그래서 필자가 볼 때는 리드를 하면 딱 좋을 것 같은데 이러한 추가적인 역할은 거부했다.</p>\n<p>필자가 성장을 위한 새로운 도전을 제안하면 그 분은 담담하게 이렇게 답했다.</p>\n<blockquote>\n<p>“지금은 딱히 생각이 없어요.”</p>\n<p>“다른 것에 집중하고 싶어서요.”</p>\n</blockquote>\n<p>만약 그 분이 역량이 부족하면서 성장도 하지 않는다면 명확히 문제가 되겠지만, 이미 잘하고 있는 사람이라서 더욱 애매했다.</p>\n<p>이 경험은 필자에게 근본적인 질문들을 던졌다.</p>\n<blockquote>\n<p>“충분히 잘 하고 있는 사람에게 더 높은 목표를 제시하는 것이 과연 옳은가?”</p>\n<p>그리고 “개인의 다양성과 선택을 존중해야 한다는 원칙은 어디까지 적용되어야 하는가?”</p>\n</blockquote>\n<p>독자 여러분도 비슷한 고민을 해본 적이 있을 것이다. 이런 딜레마 앞에서 우리는 흔히 두 가지 극단적인 선택지 사이에서 헤매게 된다. 하나는 “다양성을 무조건 존중해야 한다”는 입장이고, 다른 하나는 “조직의 목표를 위해서는 통일성이 필요하다”는 입장이다.</p>\n<p>이 경험을 통해 필자는 이런 극단적 선택지를 넘어서는 새로운 관점이 필요하다는 것을 깨달았다. 그 팀원의 상황을 더 깊이 들여다보면서, 다양성이라는 개념 자체를 보다 세밀하게 살펴볼 필요가 있다는 생각이 들었다. 과연 우리가 흔히 당연하게 여기는 다양성 존중이라는 개념에는 어떤 함정이 숨어있을까?</p>\n<h2 id=\"다양성-존중의-함정\" style=\"position:relative;\">다양성 존중의 함정<a href=\"#%EB%8B%A4%EC%96%91%EC%84%B1-%EC%A1%B4%EC%A4%91%EC%9D%98-%ED%95%A8%EC%A0%95\" aria-label=\"다양성 존중의 함정 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이 문제를 깊이 들여다보면서, 필자는 다양성이라는 개념이 흔히 이분법적으로 접근되는 경우가 많다는 것을 깨달았다. 즉, 다양성을 존중하는 것과 하지 않는 것으로 단순히 나누려는 시각이 존재한다는 것이다.</p>\n<p>하지만 현실은 그렇게 단순하지 않으며, 다양성을 존중해야 한다는 것은 절대적인 원칙이 아니라 조직이나 사회의 특성에 따라 어느 정도까지 포용할 수 있는가의 문제로 접근해야 한다.</p>\n<p>이는 불교의 연기법(緣起法)이 보여주는 진리와 맞닿아 있다. 모든 현상은 서로 의존하며 존재하기 때문에, 절대적인 자유나 절대적인 통제 모두 불가능하다는 것이다. <small>(뜬금없이 불교 얘기를 해서 당황스럽겠지만, 의외로 불교에서 말하는 에피소드들이 삶의 지혜를 많이 알려준다)</small></p>\n<p>대한민국의 헌법을 예로 들어보자. 대한민국은 국민의 자유를 보장하는 민주주의 국가이지만, 헌법 제8조에서는 특정 조건에 따라 위헌 정당을 해산할 수 있도록 하고 있다. 이는 민주적 기본 질서를 위협하는 요소가 있을 경우, 자유를 무제한으로 허용할 수 없다는 것을 의미한다. 즉, 국가조차도 모든 다양성을 무조건적으로 존중하지는 않는다는 것이다.</p>\n<p>이와 같은 원리는 조직에도 동일하게 적용된다. 예를 들어, 회사가 다양성을 존중해야 한다는 이유만으로 정해진 근무 시간을 지키지 않거나, 업무 태도가 성실하지 않음에도 불구하고 재택근무만을 주장하는 직원까지 포용해야 할까? 다양성은 존중받아야 하지만, 그것이 조직의 운영과 목표에 부합하지 않을 때는 결국 제한될 수밖에 없다.</p>\n<p>이러한 관찰을 통해 필자는 무조건적인 다양성 존중이라는 것은 존재할 수 없는 허상이라는 결론에 도달했다.</p>\n<p>그렇다면 다양성은 정말 무조건 나쁜 것일까? 물론 그런 것은 아니다. 다양성에는 분명히 빛과 그림자가 공존한다.</p>\n<h2 id=\"다양성의-빛과-그림자\" style=\"position:relative;\">다양성의 빛과 그림자<a href=\"#%EB%8B%A4%EC%96%91%EC%84%B1%EC%9D%98-%EB%B9%9B%EA%B3%BC-%EA%B7%B8%EB%A6%BC%EC%9E%90\" aria-label=\"다양성의 빛과 그림자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>물론 다양성이 우리에게 선물해주는 긍정적인 효과는 분명하다. 다양한 배경과 사고 방식을 가진 팀원들이 모였을 때, 새로운 아이디어가 탄생하고, 문제를 해결하는 데 있어 더 많은 접근법을 시도할 수 있다는 것이다. 필자가 100명 규모의 프론트엔드 조직에서 일하면서 평소 굉장히 다양한 개발자들을 만나고, 개발자가 아닌 동료들과도 밀접한 협업을 수행하는 과정에서 탁월한 역량을 가진 다양한 사람들이 모여 만들어내는 시너지를 느낄 수 있었다.</p>\n<p>하지만 이러한 다양성이 항상 긍정적인 결과만을 가져오는 것은 아니다. 의견 차이가 커질수록 조율에 드는 시간과 에너지가 기하급수적으로 증가하며, 이 과정에서 팀의 결속력이 약해지기도 한다. 이는 불교의 연기법이 보여주는 바와 같이, 모든 현상이 상호의존적이기 때문에 한 요소의 변화가 전체 시스템에 예상치 못한 영향을 미칠 수 있음을 의미한다.</p>\n<p>다양성의 이런 양면성을 이해하고 나니, 앞서 언급한 팀원에 대한 고민도 새로운 시각에서 바라볼 수 있게 되었다.</p>\n<h2 id=\"무아無我와-성장의-변화-가능성\" style=\"position:relative;\">무아(無我)와 성장의 변화 가능성<a href=\"#%EB%AC%B4%EC%95%84%E7%84%A1%E6%88%91%EC%99%80-%EC%84%B1%EC%9E%A5%EC%9D%98-%EB%B3%80%ED%99%94-%EA%B0%80%EB%8A%A5%EC%84%B1\" aria-label=\"무아無我와 성장의 변화 가능성 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 언급한 팀원에 대한 고민을 더 깊이 생각해보면서, 필자는 불교의 무아(無我) 사상을 떠올리게 되었다. 개인의 다양성이라는 것도 고정불변한 속성이 아니라 끊임없이 변화하는 것이다. 그 팀원이 현재 성장을 원하지 않는다고 해서 미래에도 그럴 것이라고 단정할 수는 없다.</p>\n<p>필자는 리더로서 항상 팀원들에게 더 높은 수준의 목표를 제시하려고 노력해왔다. 이는 단순히 성과를 내기 위한 것이 아니라, 각자가 가진 잠재력을 최대한 끌어내어 프로페셔널로서 더 성장하길 바라는 마음에서였다. 그러나 이 과정에서 “성장은 강요될 수 없는 것”이라는 결론에 도달했다. 성장을 제안할 수는 있지만, 그 선택의 최종 결정과 책임은 개인의 몫이라는 점을 깨달았다.</p>\n<p>결국 필자는 이 순간의 선택을 존중하면서도, 변화의 가능성을 열어두고 인내심을 갖고 기다리는 지혜가 필요하다는 것을 깨달았다.</p>\n<p>하지만 단순히 기다리기만 하는 것이 능사는 아니다. 리더로서 어떻게 소통하고 행동해야 하는지에 대한 구체적인 원칙도 필요했다.</p>\n<h2 id=\"팔정도八正道의-지혜-올바른-소통\" style=\"position:relative;\">팔정도(八正道)의 지혜: 올바른 소통<a href=\"#%ED%8C%94%EC%A0%95%EB%8F%84%E5%85%AB%E6%AD%A3%E9%81%93%EC%9D%98-%EC%A7%80%ED%98%9C-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%86%8C%ED%86%B5\" aria-label=\"팔정도八正道의 지혜 올바른 소통 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이때 필자에게 도움이 된 것은 불교의 팔정도(八正道) 사상이었다. 팔정도는 부처가 제시한 여덟 가지 올바른 수행 방법으로, 깨달음에 이르는 길을 구체적으로 제시한 것이다.</p>\n<p>이 중에서도 정어(正語)와 정업(正業)은 리더가 팀원과 소통할 때 지켜야 할 원칙을 명확하게 보여준다.</p>\n<p>정어(正語)는 “올바른 말”을 의미한다. 거짓말, 이간질, 욕설, 쓸데없는 말을 하지 않고, 진실하고 도움이 되는 말을 해야 한다는 것이다. 정업(正業)은 “올바른 행동”으로, 자신과 타인에게 해가 되지 않는 행동을 하라는 가르침이다.</p>\n<p>성장을 제안할 때는 비난이나 강요가 아닌 진실하고 건설적인 언어를 사용해야 하며, 개인과 조직 모두에게 도움이 되는 방향으로 행동해야 한다는 점이 중요하다. 단순히 더 나아져야 한다는 추상적인 목표가 아니라, 그 성장이 어떤 의미를 가지며 어떤 긍정적 영향을 줄 수 있는지 구체적으로 보여주는 것이 핵심이다.</p>\n<p>그런데 이런 원칙들을 실천하려고 하다 보면, 또 다른 복잡한 문제에 직면하게 된다. 바로 리더 자신의 가치관과 팀원들의 다양한 생각 사이에서 어떤 균형을 잡아야 하는가의 문제다.</p>\n<h2 id=\"자비慈悲와-방편方便의-리더십\" style=\"position:relative;\">자비(慈悲)와 방편(方便)의 리더십<a href=\"#%EC%9E%90%EB%B9%84%E6%85%88%E6%82%B2%EC%99%80-%EB%B0%A9%ED%8E%B8%E6%96%B9%E4%BE%BF%EC%9D%98-%EB%A6%AC%EB%8D%94%EC%8B%AD\" aria-label=\"자비慈悲와 방편方便의 리더십 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이러한 고민은 정치적 이데올로기의 충돌과도 비슷하다. 진보와 보수, 각각의 이념적 차이는 고유한 강점과 약점을 가지고 있으며, 옳고 그름의 문제라기보다는 어떤 방향성을 추구하느냐의 차이일 뿐이다. 조직 문화도 마찬가지다. 리더로서 필자가 가진 신념과 가치가 있다고 해도 그것을 구성원들에게 강요하는 것이 과연 정당한가? 하지만 모든 것에 대한 자유를 허용하면 조직은 혼란스러워질 수 있다.</p>\n<p>불교에서 말하는 자비(慈悲)는 단순한 동정이 아니라 상대방이 진정으로 행복해지도록 돕는 것이다. 필자가 팀원들의 성장을 바라는 마음도 이와 같은 자비심의 발현이라고 생각한다. 그리고 방편(方便)의 지혜를 통해, 각 개인의 상황과 성향에 맞는 다른 접근법을 사용하는 것이 필요하다.</p>\n<p>모든 사람에게 동일한 잣대를 적용하는 것이 아니라, 개별적인 맥락을 이해하고 그에 맞는 방법을 찾아가는 것이다.</p>\n<p>이렇게 여러 불교적 원칙들을 살펴보면서, 필자는 결국 이 모든 것이 하나의 핵심으로 수렴된다는 것을 깨달았다. 바로 “균형”이다.</p>\n<h2 id=\"중도中道의-균형\" style=\"position:relative;\">중도(中道)의 균형<a href=\"#%EC%A4%91%EB%8F%84%E4%B8%AD%E9%81%93%EC%9D%98-%EA%B7%A0%ED%98%95\" aria-label=\"중도中道의 균형 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>결국 다양성을 존중하는 것이 중요한 만큼, 조직의 목표와 성과를 달성하기 위해 일정 수준의 기준과 질서도 필요하다.</p>\n<p>그렇다면 이 균형은 어떻게 잡아야 할까? 필자가 팀을 운영하며 내린 한 가지 결론은 “모든 다양성이 무조건 존중받아야 하는 것은 아니다”라는 것이다. 이 말은 다양성을 제한해야 한다는 뜻이 아니라, 조직의 본질적인 목적과 일치하는 방향에서 다양성이 활용되어야 한다는 의미다.</p>\n<p>리더로서, 필자는 팀원들에게 다양성을 존중받을 수 있는 안전한 환경을 제공하는 동시에, 협업의 효율성을 위해 명확한 기준과 가이드를 제시하려고 노력한다. 불교의 관점에서 보면, 리더는 팀원들이 각자의 속도와 방식대로 성장하도록 지원하는 존재이기도 하며, 방향성을 제시하고 그것을 따라가도록 이끄는 존재이기도 하다.</p>\n<p>이 두 가지 역할 간의 균형을 맞추는 것은 쉽지 않지만, 조직과 개인 모두에게 최선의 결과를 낼 수 있는 중도의 길이라고 생각한다. 마치 부처가 극단적 쾌락주의와 극단적 고행주의 사이에서 중도를 찾았듯이, 리더는 무조건적 다양성 존중과 일방적 통제 사이에서 균형점을 찾아야 한다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>다양성은 조직의 성장과 혁신을 위한 필수 요소다. 그러나 그것이 갈등과 비효율을 초래하지 않도록 균형을 잡는 것은 리더의 몫이다. 필자는 앞으로도 팀의 다양성을 존중하면서, 조직의 목표를 달성하기 위해 어떤 기준을 세워야 할지에 대해 꾸준히 고민할 것이다. 그리고 이 여정에서 얻은 통찰을 계속 나누고자 한다.</p>\n<p>마치 부처가 가르친 것처럼, “마음을 따르지 말고 마음을 가르치라”는 지혜를 기억하며, 개인의 다양성과 조직의 목표 사이에서 지혜로운 선택을 계속해 나가고 싶다. 이것이 바로 현대 조직에서 필요한 불교적 리더십의 핵심이 아닐까 생각한다.</p>\n<p>이상으로 연기법으로 본 조직 운영의 지혜 포스팅을 마친다.</p>","fields":{"slug":"20250706-diversity-illusion-leadership","path":"/2025/07/06/diversity-illusion-leadership/","lang":"ko"},"frontmatter":{"title":"무조건적 다양성 존중은 허상이다: 연기법(緣起法)으로 본 조직 운영의 지혜","subTitle":"성장을 거부하는 우수한 팀원, 리더는 어떻게 해야 할까","date":"Jul 06, 2025","categories":["에세이"],"tags":["불교","다양성","리더십","연기법"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/8b30ac0e40bcf4132d8f6cdec41223e5/d803c/thumbnail.png","srcSet":"/static/8b30ac0e40bcf4132d8f6cdec41223e5/d803c/thumbnail.png 320w,\n/static/8b30ac0e40bcf4132d8f6cdec41223e5/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/8b30ac0e40bcf4132d8f6cdec41223e5/fc5c5/thumbnail.webp 320w,\n/static/8b30ac0e40bcf4132d8f6cdec41223e5/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/8b30ac0e40bcf4132d8f6cdec41223e5/01fb2/thumbnail.png","srcSet":"/static/8b30ac0e40bcf4132d8f6cdec41223e5/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/8b30ac0e40bcf4132d8f6cdec41223e5/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"6fc49a6a-7d29-518a-a332-e007a6c917c2","tableOfContents":"<ul>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"필자는 이 책의 첫 번째 파트에서 카테고리 이론과 프로그래밍이 모두 합성 가능성(Composability)에 대한 것이라는 주장을 하였다. 프로그래밍에서는 문제를 조금씩 세분화해나가며 다룰 수 있는 세부 수준으로 분해한 다음, 각 하위 문제를 해결하고, 하위 문제의 해결책들을 다시 합성하여 전체 문제를 해결하는 방식을 사용한다.","html":"<p>필자는 이 책의 첫 번째 파트에서 카테고리 이론과 프로그래밍이 모두 합성 가능성(Composability)에 대한 것이라는 주장을 하였다.</p>\n<p>프로그래밍에서는 문제를 조금씩 세분화해나가며 다룰 수 있는 세부 수준으로 분해한 다음, 각 하위 문제를 해결하고, 하위 문제의 해결책들을 다시 합성하여 전체 문제를 해결하는 방식을 사용한다.</p>\n<!-- more -->\n<p>이를 수행하는 방법에는 크게두 가지 정도가 있다. 하나는 컴퓨터에게 무엇을 해야 하는지 알려주는 방법, 그리고 다른 하나는 어떻게 해야 하는 지를 알려주는 방법이다. 이때 전자는 선언형(Declarative), 후자는 명령형(Imperative)이라고 한다.</p>\n<p>이 두 가지 방법의 차이는 가장 기본적인 수준에서도 확인이 가능하다. 먼저 선언적으로 <code class=\"language-text\">h</code>를 함수 <code class=\"language-text\">f</code>가 실행된 이후 <code class=\"language-text\">g</code>를 적용한 합성이라고 정의해보면 이렇게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">h</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>혹은 명령적으로 정의해볼 수도 있다. 즉, 먼저 <code class=\"language-text\">f</code>를 호출하고 그 호출의 결과를 기억한 뒤, 그 결과를 사용해서 다시 <code class=\"language-text\">g</code>를 호출하는 것이다.</p>\n<p>명령형 방식의 프로그램은 일반적으로 시간 순서대로 정렬된 일련의 작업들로 표현된다. 특히 이 방식에서는 명시적으로 <code class=\"language-text\">g</code>의 호출이 <code class=\"language-text\">f</code>의 실행이 완료되기 전에는 절대 발생할 수 없음이 표현된다. 그러나 지연 평가(lazy evaluation)와 call-by-need 방식의 인수 전달을 사용하는 언어에서는 실제 실행 순서가 다를 수 있다.</p>\n<p>사실, 컴파일러의 최적화 수준에 따라 선언적 코드와 명령적 코드의 실행 방식에는 거의 차이가 없을 수도 있다. 하지만 이 두 가지 방법론은 때로 문제 해결 접근 방식과 결과 코드의 유지보수성 및 테스트 가능성에서 극명하게 다르다.</p>\n<p>여기서 중요한 질문은 “우리가 문제를 풀 때 항상 선언적인 접근 방식과 명령적인 접근 방식 중 하나를 선택할 수 있는가? 그리고 만약 선언적인 해결책이 있다면 항상 컴퓨터 코드로 변환할 수 있는 것인가?”이다. 사실 이 질문에 대한 답은 아직 명확하게 나오지 않았으며, 만약 그 답을 찾을 수 있다면 아마 우리 우주에 대한 이해를 혁신적으로 바꿀 수 있을 것이다.</p>\n<p>설명을 덧붙이자면, 물리학에서도 이와 유사한 이중성이 존재한다. 이는 심오한 근본 원칙을 가리키거나, 우리의 사고방식에 대해 무언가를 말해주는 것일 수 있다. 리처드 파인만은 자신의 양자 전기역학 연구에서 이 이중성이 영감의 원천이 되었다고 언급한 바 있다.</p>\n<p>물리 법칙을 표현하는 데에는 두 가지 방식이 있다. 하나는 국소적(local) 또는 미소적(infinitesimal) 접근 방식을 사용하는 것이다. 이 접근 방식은 먼저 시스템의 작은 근방에서의 상태를 관찰하고, 다음 순간에 그것이 어떻게 변화할 지를 예측한다. 이러한 변화는 보통 미분 방정식을 사용하여 표현되며, 이를 일정 시간 동안 적분하거나 합산하여 최종 결과를 표현한다.</p>\n<p>이는 이전 단계의 결과에 의존하는 각각의 작은 단계들을 거쳐 최종 해결책에 도달하는 명령형 사고방식과 유사하다.</p>\n<p>실제로 물리적 시스템의 컴퓨터 시뮬레이션은 미분 방정식을 차분 방정식으로 변환하고 이를 반복 실행하는 방식으로 구현하는 경우가 많다. <a href=\"https://ko.wikipedia.org/wiki/%EC%95%84%EC%8A%A4%ED%85%8C%EB%A1%9C%EC%9D%B4%EC%A6%88_(%EB%B9%84%EB%94%94%EC%98%A4_%EA%B2%8C%EC%9E%84)\" target=\"_blank\" rel=\"nofollow\">Asteroids 게임</a>에서 우주선이 애니메이션화 되는 방식도 이와 동일하다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 320px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/07e05bace0a500d1b2cd29c78efa839e/72799/1.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVR42oVTXQuDMAxMFT8q0spQdCD4KgiOuUf////abcEauzrzIKm95JJLSstr6e4dESml+MsGv6qqKIqMMUmS0GZ8NQzDuq40TVOe5wAVRYG/WZbBYQQca21d13Ec09HGcZwfMyEMB4C67sNvrHkuzzRNGQRO50tmRLFDfODa4OhCg3+/OzEf4Lo9JBaG+pumkRL4wRzpgqWvtW7b9lcCCvKgYVkCC/S3+s0g4e1rILwE+3eQDeQYmNekbCScMsighF3ggqVx25eDJKiFbiUOu4jF9NZmZ3N6wsfalWWJ3Xbx6L/ve6Q4nbMrDw8DaATLjIFpnc2Z38yZ1G+umgueGdC4iAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/07e05bace0a500d1b2cd29c78efa839e/72799/1.png\" srcset=\"/static/07e05bace0a500d1b2cd29c78efa839e/69538/1.png 160w,\n/static/07e05bace0a500d1b2cd29c78efa839e/72799/1.png 320w\" sizes=\"(max-width: 320px) 100vw, 320px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>각 시간 단계마다 우주선의 위치는 속도와 시간 델타를 곱하여 계산된 작은 증분을 더해가면서 변경된다. 속도는 다시 가속도에 비례하는 작은 증분을 더해 변경되며, 가속도는 힘을 질량으로 나눈 값이다.</p>\n<p>이것은 사실 뉴턴의 운동 법칙에 해당하는 미분 방정식을 직접적으로 구현한 것이다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo>=</mo><mi>m</mi><mfrac><mrow><mi>d</mi><mi>v</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mspace linebreak=\"newline\"></mspace><mi>v</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">F=m\\frac{dv}{dt}\\\\\nv=\\frac{dx}{dt}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0574em;vertical-align:-0.686em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">t</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0574em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">t</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></div>\n<p>이외에도 맥스웰 방정식을 사용하여 전자기장의 전파를 분석하거나, 격자 양자색역학(lattice QCD)을 사용하여 양성자 내부에서 쿼크와 글루온의 행동을 설명하는 등 더 복잡한 문제에도 국소적 사고방식이 적용될 수 있다.</p>\n<p>이러한 국소적 사고방식은 디지털 컴퓨터를 사용하여 공간과 시간을 이산화(discretization)하는 시도와 결합되어, 우주의 모든 복잡성을 간단한 셀룰러 오토마타 시스템으로 축소하려는 스티븐 울프람(Stephen Wolfram)과 같은 영웅이 등장하기도 했다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>셀룰러 오토마타는 격자 내부에 위치한 여러 개의 셀들이 간단한 규칙에 따라 유한 개의 상태로 변화할 수 있는 시스템이다. 대표적인 셀룰러 오토마타 중 하나로는 <a href=\"https://namu.wiki/w/%EC%BD%98%EC%9B%A8%EC%9D%B4%EC%9D%98%20%EC%83%9D%EB%AA%85%20%EA%B2%8C%EC%9E%84\" target=\"_blank\" rel=\"nofollow\">콘웨이의 생명 게임</a>이 있으며, 이러한 시스템은 간단한 규칙이 생명과 같은 복잡한 패턴을 표현할 수 있음을 보여준다.</p>\n</blockquote>\n<p>다른 접근법은 전역적(global) 접근 방법이다. 시스템의 초기 상태와 최종 상태를 확인한 뒤, 에너지, 시간, 거리와 같은 물리량을 최소한으로 사용하여 이 상태들을 연결할 수 있는 최적의 경로를 계산한다. 가장 간단한 예는 <strong>페르마의 최소 시간 원리</strong>이다.</p>\n<p>이 원리는 빛이 비행 시간을 최소화하는 경로를 따라 전파된다는 것을 나타낸다. 그래서 반사나 굴절이 없는 경우, A 지점에서 B 지점으로 가는 빛은 가장 짧은 경로인 A와 B 사이의 직선 경로를 선택한다.</p>\n<p>그러나 빛은 물이나 유리와 같은 밀도가 높은 투명 물질에서는 속도가 느려진다. 따라서 빛의 시작 지점이 공기 중에 있고 도착 지점이 물속에 있을 경우, 빛이 공기 중에서 이동하는 거리보다 물 속에서 이동하는 거리가 더 짧아져야 한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 477px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6eea0ab0c036ddfe049479e302fa185d/b18ba/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 134.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAIBAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAe1DUprFFnNqWEHK/8QAGxABAAIDAQEAAAAAAAAAAAAAAQIRABAhAzH/2gAIAQEAAQUCZVkVk5PpGxvUuehbpBw+f//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABoQAAICAwAAAAAAAAAAAAAAABEgACEQMVH/2gAIAQEABj8C1aCsmcT/xAAdEAEAAgICAwAAAAAAAAAAAAABABEhcRBRMUFh/9oACAEBAAE/IXsaI5XB6ODhKvceG0OpTslS+RgJWtX448gXBQCf/9oADAMBAAIAAwAAABCcwIz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAWEQEBAQAAAAAAAAAAAAAAAAAQASH/2gAIAQIBAT8QLp//xAAgEAEBAAEEAQUAAAAAAAAAAAABEQAhMUFREHGRscHx/9oACAEBAAE/EB7UajhO8sUJu/Pv4B7ONid4ZQXdIHY74z9bEWwvpiFr7BHTv6w39VgDQ8KUkCFwCEAgZ//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/6eea0ab0c036ddfe049479e302fa185d/b18ba/2.jpg\" srcset=\"/static/6eea0ab0c036ddfe049479e302fa185d/0913d/2.jpg 160w,\n/static/6eea0ab0c036ddfe049479e302fa185d/cb69c/2.jpg 320w,\n/static/6eea0ab0c036ddfe049479e302fa185d/b18ba/2.jpg 477w\" sizes=\"(max-width: 477px) 100vw, 477px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>최소 시간을 따르는 경로는 빛이 공기와 물의 경계에서 굴절되도록 하며, 이는 스넬의 굴절 법칙(Snell’s Law of Refraction)으로 이어진다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><msub><mi>θ</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mfrac><mo>=</mo><mfrac><msub><mi>v</mi><mn>1</mn></msub><msub><mi>v</mi><mn>2</mn></msub></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{\\sin(\\theta_1)}{\\sin(\\theta_2)} = \\frac{v_1}{v_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.363em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mop\">sin</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mop\">sin</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.9436em;vertical-align:-0.836em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1076em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.836em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></div>\n<p>여기서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>은 공기 중에서의 빛의 속도이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>는 물속에서의 빛의 속도이다.</p>\n<p>고전 역학의 모든 법칙은 최소 작용 원리로부터 도출될 수 있다. 작용은 라그랑지안(Lagrangian)을 경로에 따라 적분하여 계산할 수 있으며, 라그랑지안은 운동 에너지와 위치 에너지의 차이를 나타낸다 (참고로 합(sum)이 아니라 차이(difference)다. 합은 총 에너지를 나타낸다).</p>\n<p>우리가 특정 목표를 맞추기 위해 박격포를 발사하면, 포탄은 먼저 중력으로 인해 위치 에너지가 더 높은 곳으로 올라가고, 그 과정 속에서 점점 작용에 음의 기여를 축적한다. 그 후 포탄은 포물선의 꼭대기에서 속도를 줄여 운동 에너지를 최소화하고, 최종적으로는 위치 에너지가 낮은 구간을 빠르게 통과하기 위해 속도를 높인다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/3bcd91aec0bd17805bb6b69ae376b97c/c08c5/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe7OkFA//8QAGRABAAMBAQAAAAAAAAAAAAAAAQACERIx/9oACAEBAAEFAvZZ4B0lqloGT//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAIDAQAAAAAAAAAAAAAAAAABEBEhYf/aAAgBAQAGPwLhZajUYf/EABkQAQEBAAMAAAAAAAAAAAAAAAERABAxQf/aAAgBAQABPyE93BoqYC6Hg8LTAYIb/9oADAMBAAIAAwAAABBgz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEBAAMBAAAAAAAAAAAAAAERABAxUWH/2gAIAQEAAT8QcwvEZfuumkJ21z0UKPAQiqDp2eBv/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/3bcd91aec0bd17805bb6b69ae376b97c/c08c5/3.jpg\" srcset=\"/static/3bcd91aec0bd17805bb6b69ae376b97c/0913d/3.jpg 160w,\n/static/3bcd91aec0bd17805bb6b69ae376b97c/cb69c/3.jpg 320w,\n/static/3bcd91aec0bd17805bb6b69ae376b97c/c08c5/3.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>리처드 파인만의 주요 기여 중 한 가지는 최소 작용 원리가 양자역학으로 일반화될 수 있음을 보여준 것이다. 이 경우에도 문제는 초기 상태와 최종 상태로 구성되며, 두 상태 사이의 전이 확률을 계산하기 위해 파인만 경로 적분(Feynman path integral)이 사용된다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/58afbf9a618154e80664783c0512faf6/c08c5/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3JoWD//EABoQAAICAwAAAAAAAAAAAAAAAAABAhEQEiH/2gAIAQEAAQUCk6Nnhorh/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAQUAAAAAAAAAAAAAAAAAEAABIUGh/9oACAEBAAY/AlTmcH//xAAcEAEAAgIDAQAAAAAAAAAAAAABACERYTFBUXH/2gAIAQEAAT8hT4e3qbNRCi3MRc5NEvwHkHFz/9oADAMBAAIAAwAAABCwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB4QAQACAgIDAQAAAAAAAAAAAAEAESFBMWFRcdHw/9oACAEBAAE/EExE4NC8vUqeQtC5f32FEsbZX1ByGPb3BsBtsElqWF3U/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/58afbf9a618154e80664783c0512faf6/c08c5/4.jpg\" srcset=\"/static/58afbf9a618154e80664783c0512faf6/0913d/4.jpg 160w,\n/static/58afbf9a618154e80664783c0512faf6/cb69c/4.jpg 320w,\n/static/58afbf9a618154e80664783c0512faf6/c08c5/4.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>중요한 점은 물리 법칙을 설명하는 방식에 우열을 가리기 어려운 이중성이 존재한다는 것이다. 우리는 하나의 물리적 결과를 설명할 때 작은 일들이 순차적인 여러 단계로 나누어져 발생하는 국소적인 관점을 사용할 수도 있고, 초기 조건과 최종 조건을 선언한 뒤 그 사이에 무슨 일이 있었는지를 설명하는 전역적인 관점을 사용할 수도 있다.</p>\n<p>전역적 접근법은 프로그래밍에서도 사용될 수 있다. 예를 들어 레이 트레이싱(ray tracing)을 구현할 때, 우리는 눈의 위치와 광원의 위치를 선언하고, 이들을 연결하는 광선의 경로를 계산한다. 이때 우리가 각 광선의 비행 시간을 명시적으로 최소화하지 않더라도, 스넬의 법칙(Snell’s law)과 반사의 기하학을 이용하여 동일한 효과를 얻을 수 있다.</p>\n<p>국소적 접근법과 전역적 접근법의 가장 큰 차이점은 공간, 그리고 더 중요한 시간에 대한 처리 방식이다. 국소적 접근법은 “지금 이 순간”의 즉각적인 결과를 중시하지만, 전역적 접근법은 마치 미래가 이미 정해져 있는 것처럼 장기적이고 정적인 관점을 취하며, 우리가 영원한 우주의 속성을 분석하는 것과 같다.</p>\n<p>이 점이 가장 잘 드러나는 곳은 사용자 상호작용에 대한 함수형 반응형 프로그래밍(Functional Reactive Programming, FRP) 접근법이다. FRP는 모든 이벤트에 대해 개별 핸들러를 작성하고 이들이 공유되는 가변 상태에 접근하도록 만드는 대신, 이벤트를 무한 리스트로 간주하고 이 이벤트에 대해 반응하는 특정한 변환을 적용한다.</p>\n<p>이론적으로 미래에 발생할 모든 동작을 담은 무한 리스트는 프로그램의 입력 데이터로 사용할 수 있다. 사실 프로그램 관점에서는 𝜋의 숫자 리스트, 의사 난수(pseudo-random number) 리스트, 또는 컴퓨터 하드웨어를 통해 전달되는 마우스 위치 리스트나 큰 차이가 없다. 데이터의 출처가 뭐든 간에 결국 리스트의 n번째 항목을 가져오려면 먼저 𝑛 − 1개의 항목을 통과해야 한다는 사실은 동일하기 때문이다. 이러한 속성이 시간적 이벤트에 적용될 때 이를 인과성(causality)이라고 부른다.</p>\n<p>그렇다면 이것이 카테고리 이론과 어떤 관련이 있다는 것일까? 필자는 카테고리 이론이 전역적 접근법을 장려하고, 따라서 선언적 프로그래밍을 지원한다는 이야기를 하려고 한다.</p>\n<p>첫 번째로, 미적분학과 달리 카테고리 이론에는 거리(distance), 이웃(neighborhood), 시간(time)과 같은 개념이 없다. 우리가 다루는 것은 그저 추상적인 대상과 대상들 간의 추상적인 연결뿐이다. 만약 A에서 B로 여러 단계를 통해 이동할 수 있다면, 한 번에 도달할 수도 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 541px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7bf87462d30c7320a6e32b55dd90f97e/8af7b/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 81.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAIBAwQF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB71LIaCA//8QAGhABAAIDAQAAAAAAAAAAAAAAAQASAhEiMf/aAAgBAQABBQJdQy6jZaIHn//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAMAAwAAAAAAAAAAAAAAAAABEBJRof/aAAgBAQAGPwI5NIeM/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARIVExEP/aAAgBAQABPyEPU1WPtD4c9B3bY3Tru9iWyU8n/9oADAMBAAIAAwAAABBTz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQACAgMBAAAAAAAAAAAAAAERIQBBMVGBEP/aAAgBAQABPxA0ZWxRitcQLkYlk138hN1Rs0V175kT2jaRHE8UYSTuWs//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/7bf87462d30c7320a6e32b55dd90f97e/8af7b/5.jpg\" srcset=\"/static/7bf87462d30c7320a6e32b55dd90f97e/0913d/5.jpg 160w,\n/static/7bf87462d30c7320a6e32b55dd90f97e/cb69c/5.jpg 320w,\n/static/7bf87462d30c7320a6e32b55dd90f97e/8af7b/5.jpg 541w\" sizes=\"(max-width: 541px) 100vw, 541px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>게다가 카테고리 이론의 주요 도구인 보편적 구성(universal construction)은 전역적 접근법의 정수이다. 우리는 이를 카테고리적 곱(categorical product)의 정의에서 확인했다. 이는 그저 해당 대상의 속성을 명시함하는 것만으로도 충분히 정의할 수 있었으며, 이는 매우 선언적인 접근이다. 곱은 두 투영(projection)을 갖춘 대상이며, 다른 대상들의 투영을 인수분해하는 특성을 최적화하는 가장 적합한 대상이다.</p>\n<p>이런 특성을 페르마의 최소 시간 원리 또는 최소 작용 원리와 비교해보면 꽤 유사하다는 것을 알 수 있다.</p>\n<p>반대로 카테고리적 곱을 전통적인 데카르트 곱의 정의와 비교해보자. 데카르트 곱은 훨씬 더 명령적인 접근을 보여주고 있다. 이 방법은 하나의 집합에서 원소를 선태갛고 다른 집합에서 또 다른 원소를 선택하여 최종적으로 곱의 원소를 생성하는 방법을 보여주고 있다.</p>\n<p>Haskell과 같은 프로그래밍 언어에서 곱 타입, 합 타입, 그리고 함수 타입은 보편적 구성을 통해 정의되는 것이 아니라 이미 내장되어있는 경우가 대부분이다. (물론 카테고리적 프로그래밍 언어를 만드려는 시도는 있었으며, <a href=\"http://web.sfc.keio.ac.jp/~hagino/thesis.pdf\" target=\"_blank\" rel=\"nofollow\">타츠야 하기노의 논문</a>에 그 내용이 잘 나와있다.)</p>\n<p>하지만 프로그래밍 언어에 카테고리적인 정의가 직접적으로 사용되던 아니던, 결국 카테고리적 정의는 기존의 프로그래밍 구조를 정당화하고 새로운 구조를 만들어낼 수 있는 토대가 된다. 가장 중요한 점은 카테고리 이론이 컴퓨터 프로그램을 선언적인 수준에서 추론하기 위한 메타 언어를 제공한다는 것이다. 또한 문제를 코드로 구현하기 전에 명세에 대해 논리적으로 사고하는 것에도 많은 도움을 준다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20241225-category-theory-for-programmers-11-declarative-programming","path":"/2024/12/25/category-theory-for-programmers-11-declarative-programming/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 11. 선언적 프로그래밍","subTitle":null,"date":"Dec 25, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"9bdc4240-2cf3-5832-b560-82aaa4d6ca20","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%A0%95%EB%8B%B5%EC%9D%84-%EC%B0%BE%EC%9C%BC%EB%A0%A4%EB%8A%94-%EB%85%B8%EB%A0%A5\">정답을 찾으려는 노력</a></p>\n<ul>\n<li><a href=\"#%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%B4-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EC%9A%94\">좋은 코드란 무엇일까요? 가독성이 좋은 코드요.</a></li>\n<li><a href=\"#%EC%84%B1%EC%9E%A5%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C%EC%9A%94\">성장하려면 어떻게 해야할까요?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B3%A0%EC%A0%95%EB%90%9C-%EC%A7%84%EB%A6%AC%EA%B0%80-%EC%95%84%EB%8B%8C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A7%A5%EB%9D%BD-%EC%86%8D%EC%97%90%EC%84%9C-%EB%B3%80%ED%99%94%ED%95%98%EB%8A%94-%EC%A7%84%EB%A6%AC\">고정된 진리가 아닌 다양한 맥락 속에서 변화하는 진리</a></p>\n<ul>\n<li><a href=\"#%EB%82%98%EC%9D%98-%EC%84%A0%ED%83%9D%EC%9D%B8%EA%B0%80-%ED%83%80%EC%9D%B8%EC%9D%98-%EA%B8%B0%EB%8C%80%EC%9D%B8%EA%B0%80\">나의 선택인가, 타인의 기대인가?</a></li>\n<li><a href=\"#%EB%82%98%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%B2%AB%EA%B1%B8%EC%9D%8C%EC%9D%B4%EB%8B%A4\">나를 이해하는 것이 첫걸음이다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"우리는 인생을 살아가며 수없이 많은 문제들과 마주친다. 당장 현실적인 부분들만 보아도 입시, 취업, 이직, 재테크, 커리어, 성장 등 다양한 미션을 만나게 되는데, 종종 사람들과 이에 대해 이야기를 나누다보면 마치 정답이 정해져있다는 것과 같은 이야기 혹은 정답이 있기를 바라는 것과 같은 이야기를 듣고는 한다.","html":"<p>우리는 인생을 살아가며 수없이 많은 문제들과 마주친다. 당장 현실적인 부분들만 보아도 입시, 취업, 이직, 재테크, 커리어, 성장 등 다양한 미션을 만나게 되는데, 종종 사람들과 이에 대해 이야기를 나누다보면 마치 정답이 정해져있다는 것과 같은 이야기 혹은 정답이 있기를 바라는 것과 같은 이야기를 듣고는 한다.</p>\n<!-- more -->\n<p>때로는 사회가 정답을 강요한다는 생각이 들기도 한다. “좋은 대학에 입학하면 인생이 필거야”, “행복하게 살려면 서울에 집 한 채는 있어야지”, “월 수입이 얼마는 되어야 중산층이지”와 같은 여러가지 조건과 기준들을 듣고 있자면, 내가 결정하는 것들이 정말 내가 결정하는 것이 맞는지 아니면 단순히 사회가 정해놓은 기준에 따라가고 있는 것인지 의문이 들 때가 있다.</p>\n<p>학생들은 지식을 얻고 탐구하고자 학습하는 것이 아닌, 다수가 외치는 정답을 맞추기 위해 학습한다. 그리고 이런 폐단은 학교 뿐 아니라 사교육에서도 동일하게 나타나며, 개발자들을 가르치는 여러 조직들 또한 크게 다르지 않다. 결국 고객들이 정답을 원하고 있으니 정답을 가르치는 것이 비즈니스 임팩트이기 때문이다.</p>\n<p>이렇게 사회가 제공하는 성공의 공식은 우리를 길들여왔다. 그래서 우리가 접하는 대부분의 문제들은 비정형적이고 정답이 없는 것들인 경우가 대부분이지만, 종종 우리는 문제를 만났을 때 마치 정답이 있을 것이라고 착각하고는 한다.</p>\n<p>이런 사회적 강요는 우리의 사고방식에도 깊은 영향을 미치며, 필자와 같은 개발자들 역시 예외는 아니다. 그래서 이번 포스팅에서는 이에 대해 필자가 평소 느꼈던 문제 의식에 대해 한번 풀어보고자 한다.</p>\n<h2 id=\"정답을-찾으려는-노력\" style=\"position:relative;\">정답을 찾으려는 노력<a href=\"#%EC%A0%95%EB%8B%B5%EC%9D%84-%EC%B0%BE%EC%9C%BC%EB%A0%A4%EB%8A%94-%EB%85%B8%EB%A0%A5\" aria-label=\"정답을 찾으려는 노력 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 필자와 같은 개발자들은 정답을 찾기 위해 노력하는 것이 익숙한 부류이다. 아무래도 논리를 다루는 직업의 특성 상, 명확한 근거를 기반으로 논리적으로 오류가 없는 의사 결정을 내리는 것에 익숙하기 때문이다.</p>\n<p>보통 개발자들이 외치는 정답은 대부분 코드의 형상과 관계에 초점이 맞춰져 있는데, 간혹 명확한 이유 없이 모노레포를 도입한다거나 전역 상태 관리 라이브러리 또는 메모이제이션과 같은 특정 메소드를 맥락 없이 도입하는 경우도 흔하다.</p>\n<p>하지만 앞서 이야기 했듯 현실은 그렇게 단순하지 않으며 많은 경우 “최선”이라는 것은 맥락과 상황에 따라, 혹은 해석하는 사람에 따라 다르게 정의된다.</p>\n<h3 id=\"좋은-코드란-무엇일까요-가독성이-좋은-코드요\" style=\"position:relative;\">좋은 코드란 무엇일까요? 가독성이 좋은 코드요.<a href=\"#%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%B4-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EC%9A%94\" aria-label=\"좋은 코드란 무엇일까요 가독성이 좋은 코드요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자는 어쩌다 보니 경력 초반인 지난 2016년부터 현재까지 꾸준히 인터뷰어로서의 경험을 쌓고 있는데, 아무래도 오랫동안 이 일을 하다보니 개인적으로 사용하는 질문 템플릿이 몇 가지 있다.</p>\n<p>그 중 하나는 “좋은 코드란 무엇일까요?”라는 질문이다. 이는 개인적으로도 오랫동안 고민해온 주제라 인터뷰를 통해 다양한 개발자들의 의견을 듣고 싶은 마음도 있다. 하지만 이런 질문을 던지면 신기하게도 굉장히 많은 분들이 “가독성이 좋은 코드”라는 답변을 해주시는데, 과장을 조금 보태자면 100명 중 99명은 이 답변을 주시는 것 같다.</p>\n<p>필자는 이 답변을 들을 때마다 묘한 어색함을 느끼는데, 가독성은 본질적으로 주관적이고 추상적인 개념이기 때문이다. 같은 코드를 보아도 누군가는 가독성이 좋다고 말할 수 있고, 누군가는 나쁘다고 말할 수 있는 것이니 말이다.</p>\n<p>물론 코드를 이집트 상형 문자로 표현하는 것보다 나에게 익숙한 언어로 표현하는 것이 이해하기 쉬운 것처럼 많은 사람들이 가독성이 높다고 공감할 수 있는 요소들은 존재할 수 있겠지만, 사실 우리가 이야기하는 가독성이라는 것이 이런 수준의 이야기를 하는 것이 아니라는 건 다들 알고 있을 것이다.</p>\n<p>애초에 전 세계에 존재하는 약 2,600만 명의 소프트웨어 개발자들이 모두 공감할 수 있는 기술적 요소라는 것이 존재할 수나 있는 것일까? 모두가 공감할 수 없는 가치라면 애초에 가독성이 좋은 코드라는 것이 세상에 존재하기는 하는 것인지에 대한 의심을 해봐야 하지 않을까?</p>\n<p>이런 마음을 담아 지원자에게 “가독성이 좋은 코드는 무엇인가요?”라는 질문을 던지면 이제부터 답변이 다양해진다. 누군가는 응집이나 결합을 강조하고, 누군가는 명확하고 직관적인 네이밍, 누군가는 관심사에 대한 이야기를 한다. 즉, 가독성이라는 것의 본질 전체를 꿰뚫는 정의가 아닌, 현실의 특정 사례를 예시로 들며 “이렇게 했을 때 가독성이 좋아집니다”와 같은 답변을 하는 경우가 많았다.</p>\n<p>결국 개발자마다 좋은 가독성을 달성하기 위해 가장 필요하다고 생각하는 부분이 모두 다르다는 것이며, 이 답변들이 오히려 가독성이라는 것이 얼마나 주관적이고 추상적이며 맥락 의존적인 것인지 드러내는 사례이다. 마치 같은 그림을 보면서도 누군가는 아름답다고 여기고 누군가는 도대체 뭘 표현하려는 것인지 모르겠다고 하는 것처럼 말이다.</p>\n<p>하지만 분명 많은 사람들은 “좋은 코드가 무엇인가?”에 대한 질문에 “가독성이 좋은 코드”라는 답변을 하고 있다. 마치 정답이 정해져 있기라도 한 것처럼 말이다.</p>\n<h3 id=\"성장하려면-어떻게-해야할까요\" style=\"position:relative;\">성장하려면 어떻게 해야할까요?<a href=\"#%EC%84%B1%EC%9E%A5%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C%EC%9A%94\" aria-label=\"성장하려면 어떻게 해야할까요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 본능은 비단 개발자 뿐 아니라, 우리가 일상에서 내리는 크고 작은 결정에서도 자주 드러난다. 필자는 종종 1-on-1, 멘토링과 같이 다른 개발자들의 고민을 듣고 도움을 드릴 수 있는 자리를 가지고는 하는데, 사실 이런 자리에서도 정답을 찾으려는 노력을 많이 보아왔다.</p>\n<p>이런 자리에서 주로 듣는 질문과 고민은 대략 이런 느낌이다.</p>\n<hr>\n<ul>\n<li>좋은 개발자가 되려면 어떻게 해야 하나요?</li>\n<li>ㅇㅇ 회사에 들어가려면 어떤 점을 채워야 할까요?</li>\n<li>나중에 이런 경험을 하고 싶은데, 그러면 어떻게 해야 하나요?</li>\n</ul>\n<hr>\n<p>물론 이런 질문을 하는 마음은 충분히 공감이 간다. 무언가를 달성하고 싶은 마음은 크지만 무엇을 해야 하는지는 모르겠을 때, 그 답답한 마음은 누구나 한번 쯤은 느껴보았을 것이다.</p>\n<p>사실 이런 질문을 던지는 분들은 분명 성장을 갈망하며 진심으로 더 나아지고 싶어한다. 하지만 문제는 성공이나 성장이라는 목표를 지나치게 정형화된 방법으로 접근한다는 점이다.</p>\n<p>그 결과 자신의 환경, 목표, 역량과 맞지 않는 보편적인 정답을 따라가다가 오히려 잘못된 방향으로 노력을 쏟는 경우를 자주 목격했다. 마치 내 몸에 맞지 않는 옷을 억지로 입으려고 하는 것처럼 말이다.</p>\n<p>행간에는 1만 시간의 법칙과 같이 무조건 노력하면 언젠가 원하는 바를 달성할 수 있다는 이야기도 있지만, 필자는 절대 여기에 동의하지 않는다. 노력과 시간이라는 것은 매우 한정된 자원이기 때문에 어디에 투자할 것인지가 매우 중요하기 때문이다. <small>(기껏 1만 시간을 투자했더니 알고보니 내 성장에 전혀 도움이 되지 않았던 곳이었다고 해도 날려버린 1만 시간은 두번 다시 돌아오지 않는다.)</small></p>\n<p>결국 중요한 것은 시간과 에너지를 어디에 투자할 것인가에 대한 방향성인데, 문제는 우리는  이 방향성을 스스로 결정했다고 믿지만, 사실 그 선택은 타인이나 사회가 제시한 기준에 의존한 결과일 때가 많다는 것이다.</p>\n<h2 id=\"고정된-진리가-아닌-다양한-맥락-속에서-변화하는-진리\" style=\"position:relative;\">고정된 진리가 아닌 다양한 맥락 속에서 변화하는 진리<a href=\"#%EA%B3%A0%EC%A0%95%EB%90%9C-%EC%A7%84%EB%A6%AC%EA%B0%80-%EC%95%84%EB%8B%8C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A7%A5%EB%9D%BD-%EC%86%8D%EC%97%90%EC%84%9C-%EB%B3%80%ED%99%94%ED%95%98%EB%8A%94-%EC%A7%84%EB%A6%AC\" aria-label=\"고정된 진리가 아닌 다양한 맥락 속에서 변화하는 진리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 사람은 누구나 안정성과 확실성을 추구하고 불확실한 상황을 불편해하는 심리적 기제를 지니고 있기 때문에 이러한 사고가 부자연스러운 것은 아니다. 오히려 정답이 없다고 믿는 것이 인간의 본능을 거스르는 행위일 수도 있다.</p>\n<p>그래서 앞서 언급한 가독성과 성장의 사례 또한 훌륭한 개발자가 되기 위해 갈망하고 공부하던 많은 사람들이 어떤 블로그, 책, 혹은 주변에 있는 개발자 등을 통해 퍼진 정보들을 비판 없이 흡수했을 가능성이 높다. 하지만 가독성이나 성장과 같은 문제는 정해진 정답이라는 것이 없다는 점을 간과해서는 안된다.</p>\n<p>철학에서는 이러한 문제를 탐구하기 위해 상대주의(Relativism)와 맥락주의(Contextualism) 같은 개념을 사용한다.</p>\n<p>상대주의는 진리나 가치는 보편적이지 않고, 특정 문화, 관점, 상황에 따라 달라진다는 것이며, 이는 가독성의 기준도 개인의 기준 혹은 개인이 처한 상황에 따라 달라질 수 있다는 것을 의미한다.</p>\n<p>맥락주의는 어떤 명제가 참인지 여부는 그것이 사용되는 맥락에 달려 있다는 것을 의미한다.</p>\n<p>예를 들어 동일한 코드라 하더라도, 팀의 문화나 프로젝트의 성격, 그리고 비즈니스 상황에 따라 그에 대한 평가가 달라질 수 있는 것처럼 말이다.</p>\n<p>많은 이들이 좋은 코드란 무엇인가에 대해 가독성 좋은 코드라는 답을 정답처럼 외치고 있지만, 이것은 고정된 진리가 아니라 다양한 맥락 속에서 변화하는 상대적인 개념인 것이다.</p>\n<p>물론 인터뷰라는 자리를 마치 인터뷰어가 생각하는 정답을 맞춰야하는 게임이라고 착각하시는 경우가 많기 때문에 다소 편향이 발생했을 수도 있지만, 비단 인터뷰 뿐만 아니라 멘토링이나 1-on-1과 같은 자리에서도 많은 분들이 비슷한 반응을 보였기 때문에 편향이 크지는 않다고 생각한다. <small>(독자 여러분도 당장 주변에 있는 개발자 아무나 10명만 붙잡고 “좋은 코드란 뭐라고 생각하심?”이라는 질문을 한번 던져보면 아마 높은 확률로 가독성 이야기가 나올 것이다)</small></p>\n<p>물론 우리가 굳이 기계어가 아니라 인간에게 익숙한 기호들로 추상화된 프로그래밍 언어를 사용하는 것은 결국 인간이 컴퓨터의 동작을 쉽게 이해하기 위함이니, 가독성이 좋은 코드라는 가치를 달성할 수만 있다면 더할 나위 없이 좋은 코드라고 부를 수 있음에는 이견이 없다.</p>\n<p>하지만 상황이나 맥락에 따라 다르게 판단될 수 밖에 없는 이 가독성이 좋다는 것이 도대체 무엇인지, 근본적인 진리에 대한 의문과 고찰없이 이런 답을 섣불리 내는 것은 프로그래밍 전문가로써 해서는 안될 행동이다.</p>\n<p>그렇다면 우리는 과연 무엇을 기준으로 본질적인 가치를 찾아야 하는 것일까?</p>\n<h3 id=\"나의-선택인가-타인의-기대인가\" style=\"position:relative;\">나의 선택인가, 타인의 기대인가?<a href=\"#%EB%82%98%EC%9D%98-%EC%84%A0%ED%83%9D%EC%9D%B8%EA%B0%80-%ED%83%80%EC%9D%B8%EC%9D%98-%EA%B8%B0%EB%8C%80%EC%9D%B8%EA%B0%80\" aria-label=\"나의 선택인가 타인의 기대인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>가장 먼저 나의 의사결정 또는 내가 옳다고 생각하는 무언가가 정말 내가 결정한 것이 맞는지에 대해 성찰하는 과정이 필요하다.</p>\n<p>앞서 여러 번 언급했듯이 우리는 집단주의 성향이 강한 문화권에서 살아가고 있기 때문에, 내가 스스로 결정했다고 믿는 것이 사실은 타인이나 사회의 기준에 의해 결정된 경우가 많다.</p>\n<hr>\n<ul>\n<li>다들 개발자 초봉은 n천만원이라고 하니, 나도 그 정도는 받아야지.</li>\n<li>요즘 AI가 대세라고 하니까 나도 AI를 공부해야겠다.</li>\n<li>대기업은 알고리즘을 본다고 하네. 그럼 오늘부터 성실하게 1일 1알고리즘 풀이를 해야겠다.</li>\n<li>집은 무조건 서울에 사야지.</li>\n<li>기술의 선두 주자가 되려면 미국으로 건너가야겠다.</li>\n</ul>\n<hr>\n<p>물론 필자도 알게 모르게 이런 생각을 많이 한다. 가장 최근에 했던 생각은 “비싼 수입차를 타면 내 인생에 대한 만족도가 조금은 올라가지 않을까”였는데, 처음에는 좋았지만 결국 3개월 정도 지나니까 익숙해져서 돈은 돈대로 쓰고 원했던 만족도는 얻지 못 했다.</p>\n<p>결국 이것 또한 사회에서 일반적으로 통용되는 성공의 상징을 취득하면 삶의 질이 올라갈 것이라 판단한 것이니, 필자 스스로의 의사결정이라기보다는 사회나 타인의 시선에 영향을 받은 상황이라고 볼 수 있다.</p>\n<p>그래서 이렇게 “A를 하려면 B를 해야한다”와 같은 논리가 머릿속에 떠올랐다면 대부분 정답이 아닌 경우가 많다. 더 정확히 말하자면 누군가에게는 정답일 수 있어도 나에게는 아닐 수 있기 때문에 한번 멈추고 성찰하는 과정이 필요한 것이다.</p>\n<h3 id=\"나를-이해하는-것이-첫걸음이다\" style=\"position:relative;\">나를 이해하는 것이 첫걸음이다<a href=\"#%EB%82%98%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%B2%AB%EA%B1%B8%EC%9D%8C%EC%9D%B4%EB%8B%A4\" aria-label=\"나를 이해하는 것이 첫걸음이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>정답은 사실 멀리 있는 것이 아니다. 정답을 찾기 위해서는 일단 나 스스로에 대한 깊은 이해가 필요하다.</p>\n<p>내가 무엇을 좋아하고, 어떨 때 기쁨을 느끼며, 어떤 순간에 슬픔을 느끼는 지 알아야 한다. 무엇을 할 때 가슴이 뛰는지, 어떤 일을 할 때 가장 몰입하는지를 돌아보아야 한다. 이런 자기 성찰이 뒷받침되지 않는다면, 우리는 쉽게 타인이나 사회가 정해준 기준에 휘둘릴 수밖에 없다.</p>\n<p>필자는 이것이 굉장히 중요한 요소라고 생각하는데, 안타깝게도 바쁘게 현생을 살다보면 외부의 문제에는 있는 힘껏 머리를 쓰면서도 정작 나에 대해서 돌아보고 생각해볼 기회는 많이 없는 것 같다.</p>\n<p>성찰이라고 하면 고루하고 어려운 이야기처럼 느껴질 수는 있지만, 사실 스스로에게 던지는 작은 질문부터 시작해보면 그리 어려운 것은 아니다.</p>\n<hr>\n<ul>\n<li>나는 어떤 상황에서 행복함을 느꼈을까?</li>\n<li>나는 회사를 왜 다니고 있지?</li>\n<li>나는 왜 개발자로 일하고 있지?</li>\n</ul>\n<hr>\n<p>결국 중요한 것은 내가 내리는 모든 결정이 진정 나의 의지에서 비롯된 것인지 점검하고, 내가 생각하고 결정한 것이 정말 내 몸에 맞는 옷이 맞는지를 확인하는 것이다.</p>\n<p>필자는 비싼 값을 치루고 수입차를 샀지만 결국 3개월 만에 익숙해져버려 원했던 만족감을 얻지 못 했다. 하지만 누군가는 동일한 행위를 해도 충분히 만족하면서 살아갈 수도 있다. 애초에 이 행위는 필자에 맞는 옷이 아니었던 것이다. <small>(하지만 또 팔기는 아까워서 아직 잘 타고 있다)</small></p>\n<p>정답은 멀리 있는 것이 아니라, 내 안에 있다. 비록 우리는 집단주의적 성향이 강한 사회 속에서 살아가지만, 오히려 이런 곳에서 나만의 기준을 세워가는 것이야말로 진정한 만족과 성취를 얻는 길이라고 할 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>실존주의 철학자 장폴 사르트르는 “우리는 스스로를 정의하며, 우리 존재의 의미는 우리가 만드는 것”이라고 말하며 인간이 자유롭게 선택할 수 있는 존재임과 동시에, 그 선택에 대한 책임을 져야 한다는 점을 강조했다.</p>\n<p>이는 우리의 선택이 타인의 기대가 아니라 스스로의 가치와 기준에서 나올 때, 진정으로 만족스러운 삶을 살 수 있음을 시사한다.</p>\n<p>물론 현생을 살기 위해서는 사회나 타인이 요구하는 여러 조건들을 맞춰야 하는 경우도 있다. 하지만 중요한 것은 스스로가 그 조건을 왜 맞춰야 하는지 인지하고 결정한 것이 맞냐는 것이다.</p>\n<p>좋은 코드는 가독성이 높은 코드라는 말, 좋은 개발자가 되기 위해서는 이런 저런 일을 해야한다는 타인의 말은 그저 수많은 데이터 중 하나일 뿐이다. 우리의 역할은 저 데이터를 그대로 받아들이는 것이 아니라 내 기준에 맞춰 정제하여 취할 것은 취하고 버릴 것은 버리는 것이다.</p>\n<p>그러니 데이터 자체가 정답이라고 믿는 것이 아닌 데이터를 재료로 하여 나만의 가치관과 철학을 만드는 과정에 대해 더 깊은 고민을 해보는 것을 추천한다.</p>\n<p>이상으로 정답이 존재한다는 착각 포스팅을 마친다.</p>","fields":{"slug":"20241223-the-illusion-of-a-right-answer","path":"/2024/12/23/the-illusion-of-a-right-answer/","lang":"ko"},"frontmatter":{"title":"좋은 코드란 무엇일까? - 가독성이란 허상에 대하여","subTitle":"개발자의 판단력을 흐리는 정답 강박에서 벗어나기","date":"Dec 23, 2024","categories":["에세이"],"tags":["실존주의","가독성"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/d8ae58549615ef582a117e086c2797bb/fc5c5/thumbnail.webp","srcSet":"/static/d8ae58549615ef582a117e086c2797bb/fc5c5/thumbnail.webp 320w,\n/static/d8ae58549615ef582a117e086c2797bb/e9225/thumbnail.webp 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/d8ae58549615ef582a117e086c2797bb/b384d/thumbnail.webp","srcSet":"/static/d8ae58549615ef582a117e086c2797bb/b384d/thumbnail.webp 750w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5}}}}}},{"node":{"id":"f94c8754-7a93-51b8-a6d0-28e2b12cb24d","tableOfContents":"<ul>\n<li><a href=\"#chatgpt%EB%A5%BC-%EC%8D%BC%EB%8B%A4%EB%A9%B4-%EB%8D%94-%EC%9E%98%ED%95%A0-%EC%88%98-%EC%9E%88%EC%97%88%EC%9D%84-%EA%B2%83-%EA%B0%99%EC%95%84%EC%9A%94\">ChatGPT를 썼다면 더 잘할 수 있었을 것 같아요</a></li>\n<li><a href=\"#%EC%9D%B8%EA%B0%84-%EC%A1%B4%EC%9E%AC%EC%9D%98-%EB%B3%B8%EC%A7%88%EC%A0%81-%EC%9D%98%EC%9D%98%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">인간 존재의 본질적 의의는 무엇인가</a></li>\n<li><a href=\"#ai%EB%8A%94-%EC%9D%B8%EA%B0%84-%EC%A1%B4%EC%9E%AC%EC%9D%98-%EB%B3%B8%EC%A7%88%EC%9D%84-%EC%9C%84%ED%98%91%ED%95%98%EB%8A%94%EA%B0%80\">AI는 인간 존재의 본질을 위협하는가</a></li>\n<li><a href=\"#%EC%A7%80%EA%B8%88-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8B%B9%EC%8B%A0%EC%9D%80-%EB%88%84%EA%B5%AC%EC%9D%B8%EA%B0%80\">지금 프로그래밍을 하고 있는 당신은 누구인가</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","excerpt":"AI는 우리의 생활을 크게 변화시키고 있다. ChatGPT 모바일 앱을 사용하면서 음성으로 대화를 주고 받다보면 이제는 영화 아이언맨에 나오는 인공지능 비서 자비스가 현실화된 것이 아닌가 하는 착각마저도 일으킬 정도이다. ChatGPT와 같은 생성형 AI는 일상적인 대화부터 복잡한 문제 해결까지 다양한 용도로 사용되며, 우리의 삶을 더욱 윤택하게 만들고 있다. 그러나 필자는 이러한 기술의 발전이 선물해준 편리함 속에서 우리가 중요한 질문을 잊고 있는 것은 아닌지 돌아볼 필요가 있다고 생각한다. 바로 인간 존재의 본질적 의의에 대한…","html":"<p>AI는 우리의 생활을 크게 변화시키고 있다. ChatGPT 모바일 앱을 사용하면서 음성으로 대화를 주고 받다보면 이제는 영화 아이언맨에 나오는 인공지능 비서 자비스가 현실화된 것이 아닌가 하는 착각마저도 일으킬 정도이다.</p>\n<p>ChatGPT와 같은 생성형 AI는 일상적인 대화부터 복잡한 문제 해결까지 다양한 용도로 사용되며, 우리의 삶을 더욱 윤택하게 만들고 있다.</p>\n<p>그러나 필자는 이러한 기술의 발전이 선물해준 편리함 속에서 우리가 중요한 질문을 잊고 있는 것은 아닌지 돌아볼 필요가 있다고 생각한다. 바로 <strong>인간 존재의 본질적 의의</strong>에 대한 질문이다.</p>\n<p>지난 수천 년 동안 많은 철학자들은 인간이 자기 성찰, 비판적/이성적 사고, 자아 인식과 자기 성찰, 도덕적 판단과 같은 것들을 가지고 있기 때문에 인간일 수 있다고 이야기해왔다.</p>\n<p>하지만 최근 주변을 둘러보면 지금껏 우리가 인간으로 존재하기 위해 지녀야 한다고 이야기해왔던 많은 가치들을 ChatGPT와 같은 도구에게 위임하는 모습을 볼 수 있다.</p>\n<p>물론 지금의 생성형 AI는 아직 정확도가 높지 않기 때문에 많은 부분을 위임하지는 않겠지만, 그 위임이 이미 시작되고 있다는 것이 중요한 부분이며, AI의 발전속도를 생각해보면 앞으로 점점 더 빠른 속도로 위임이 이루어질 미래를 그리 어렵지 않게 그려볼 수 있다.</p>\n<p>하지만 AI가 발전하는 속도에 비해 이러한 윤리적/철학적 담론은 거의 배제되고 있다. 필자는 추후 AI가 더욱 발전했을 때 이러한 담론의 부재가 큰 사이드 이펙트로 돌아올 것이라고 생각하며, 특히 이 기술을 개발하고 있는 분들은 더더욱 이 아젠다에 관심을 가져야 한다고 생각한다.</p>\n<h2 id=\"chatgpt를-썼다면-더-잘할-수-있었을-것-같아요\" style=\"position:relative;\">ChatGPT를 썼다면 더 잘할 수 있었을 것 같아요<a href=\"#chatgpt%EB%A5%BC-%EC%8D%BC%EB%8B%A4%EB%A9%B4-%EB%8D%94-%EC%9E%98%ED%95%A0-%EC%88%98-%EC%9E%88%EC%97%88%EC%9D%84-%EA%B2%83-%EA%B0%99%EC%95%84%EC%9A%94\" aria-label=\"chatgpt를 썼다면 더 잘할 수 있었을 것 같아요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 지난 2016년부터 지금까지 수많은 개발자들의 인터뷰를 진행했었다. 만약 한 달에 4-6명씩 인터뷰를 진행했었다고 하면 대략 400-600명 정도 되는 인원을 만나본 셈이다.</p>\n<p>이러한 인터뷰를 통해 다양한 답변과 견해를 들을 수 있었지만, 최근에 들은 답변은 그동안의 경험에서 한 번도 듣지 못했던 것이었다.</p>\n<blockquote>\n<p>“ChatGPT를 썼다면 과제를 더 잘할 수 있었을 것 같아요”</p>\n</blockquote>\n<p>이는 필자에게 꽤나 독특하고 낯선 답변으로 다가왔다. 이것은 도구를 사용할 수 없었기 때문에 자신에게 주어진 문제를 온전히 풀어낼 수 없었다고 시인한 것이나 마찬가지이기 때문이다. 이 도구가 ChatGPT든, 구글링이든 상관없이 말이다.</p>\n<p>보통 인터뷰를 진행할 때 지원자들은 자신의 능력을 과소평가하는 말을 피하고, 오히려 도구가 없이도 펼칠 수 있는 자신 본연의 역량을 최대한 강조하려고 노력하기 마련이다. 이는 인터뷰라는 것이 도구가 없다면 문제를 해결할 수 없는 사람보다는 도구가 없어도 문제를 해결할 수 있되, 도구를 통해 자신의 역량을 부스팅할 수 있는 사람을 찾고자 하는 과정이라는 사실을 모두가 알고 있기 때문이기도 하다.</p>\n<p>혹시 이 글을 읽고 있는 누군가는 어차피 입사하면 ChatGPT를 사용할 것인데 역량 검증 과정에서 도구를 사용하는 것이 뭐가 문제냐고 할 수도 있다. 이 도구를 활용하는 역량을 검증하면 되는 것 아니냐고 말이다.</p>\n<p>물론 필자도 실무에서 ChatGPT를 사용한다. 그리고 필자는 ChatGPT를 업무에 잘 활용하면 생산성이 압도적으로 높아질 수 있다는 것을 부정하지도 않는다. 하지만 필자가 이 포스팅에서 이야기하고 싶은 주제는 “인터뷰에서 ChatGPT 활용 역량을 검증해야하냐”와 같은 지엽적인 주제는 아니다.</p>\n<p>한번 생각해보자. 지금이야 생성형 AI가 등장한지 2년 밖에 되지 않았으니 인간이 프롬프트를 잘 작성하기 위해 고민하는 과정이 필요하겠지만, 앞으로는 개떡같이 질문해도 찰떡같은 대답을 해주는 수준까지 금방 발전할 것이다.</p>\n<p>만약 이런 수준의 AI가 등장한다면 이 도구를 활용하는 역량을 검증한다는 것이 무슨 의미가 있을까? 아무런 지식이 없는 사람이 AI에게 대충 질문해도 찰떡같은 대답을 해주는 수준이 된다면 도구의 숙련도라는 개념도 어차피 무의미해진다.</p>\n<p>중요한 것은 생성형 AI인 ChatGPT가 세상에 소개된지 이제 겨우 2년 밖에 지나지 않았음에도 불구하고 AI라는 도구에 자신의 사고를 의존하는 사람들이 빠르게 늘어나고 있지만, 정작 “우리가 AI를 어떤 식으로 다뤄야 하는지”, “AI에게 사고를 의존한다는 것이 무슨 의미인지”와 같은 윤리적 담론에는 별로 주목하고 있지 않다는 것이다.</p>\n<p>서론에서 언급했듯이 물론 지금은 생성형 AI가 완전하지 않다는 사실에 대해 인간들도 알고 있으니 자신의 사고를 AI에게 온전히 위임하는 상황은 발생하지 않는다. 그러나 만약 인간이 보기에 AI가 자신보다 더 나은 답변을 내놓는다고 판단하기 시작한다면 그 위임의 정도는 빠르게 높아질 것이다.</p>\n<p>이는 단순히 도구를 활용하여 생산성을 증가시키는 것과는 완전히 다른 개념이다. 지금까지의 도구는 인간의 능력을 보조하는 역할을 하거나, 혹은 인간 스스로의 힘으로는 불가능한 일을 할 수 있도록 도와주는 역할이었다.</p>\n<p>하지만 AI는 인간과 거의 동등한 레벨의 사고와 의사결정을 할 수도 있는 존재이며, 이미 특정 분야에 대해서는 인간의 능력을 넘어선 경우도 있다. 즉, 지금까지의 도구와는 다르게 인간의 능력을 보조하는 정도를 넘어서서 인간의 사고 자체를 AI에게 위임하는 것도 가능하다는 것이다. 그리고 인간들이 이러한 가능성에 대해서 경계하는 움직임은 거의 보이지 않는다.</p>\n<p>생성형 AI가 세상에 본격적으로 등장한지 꼴랑 2년 밖에 되지 않은 지금도 사고의 일부를 AI에게 위임하는 상황들이 발생하고 있으니, 앞으로는 이런 상황들이 더더욱 많아질 것이라고 생각한다.</p>\n<h2 id=\"인간-존재의-본질적-의의는-무엇인가\" style=\"position:relative;\">인간 존재의 본질적 의의는 무엇인가<a href=\"#%EC%9D%B8%EA%B0%84-%EC%A1%B4%EC%9E%AC%EC%9D%98-%EB%B3%B8%EC%A7%88%EC%A0%81-%EC%9D%98%EC%9D%98%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"인간 존재의 본질적 의의는 무엇인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자가 가졌던 문제의식에 대해서 이야기하려면, 지금껏 우리가 무엇 때문에 인간으로 존재할 수 있다고 정의해왔는지부터 살펴봐야한다. “인간이란 무엇인가?”라는 질문은 지난 수천 년 동안 수 많은 철학자들이 탐구해온 주제이다.</p>\n<p>우리는 분명 다른 동물과 구분된 무언가를 가지고 있다는 사실을 알고 있지만, 그게 무엇인지에 대해서는 명확히 알려주는 이가 없었기에 수천 년 동안 스스로 탐구해온 것이다.</p>\n<p>플라톤은 이데아론을 통해 인간은 진리와 이상을 추구하는 존재라고 하였으며, 아리스토텔레스는 인간을 이성적 동물로 정의했다. 데카르트는 “나는 생각한다, 고로 존재한다”라는 명제를 통해 인간의 존재를 사유, 그리고 자아인식과 연결지었다. 칸트는 인간을 자율적이고 도덕적인 판단을 내리는 주체로 정의했으며, 사르트르는 인간이 스스로 자신의 본질을 창조하는 존재라 했다.</p>\n<p>이처럼 수많은 철학자들이 인간의 본질과 존재의 의의에 대해 다양한 정의를 내렸지만, 잘 살펴보면 공통적인 요소들이 몇 가지 있다.</p>\n<p>그 중에서도 가장 두드러지는 공통점은 바로 <strong>자기 성찰과 자아 인식</strong>이다. 이는 인간이 스스로를 이해하고, 자신의 생각과 행동을 분석하며, 자신의 존재에 대한 깊은 이해를 추구할 수 있는 능력을 뜻한다. 플라톤과 아리스토텔레스의 이성적 사고, 데카르트의 사유와 자아인식, 칸트의 도덕적 자율성, 사르트르의 본질 창조 모두 이러한 자기 성찰과 자아 인식을 중심으로 전개된다.</p>\n<p>즉 인간은 단순히 경험하고 반응하는 존재가 아니라, 자신의 경험을 분석하고 평가하며, 그로부터 새로운 의미와 방향을 찾아내는 존재라고 할 수 있는 것이다.</p>\n<p>지금까지의 철학자들이 강조한 인간의 본질적 특징, 자기 성찰과 자아 인식은 인간이 단순한 생물학적 존재를 넘어선 독특한 존재로서의 가치를 지니게 하는 핵심 요소이기 때문에 우리가 이 부분을 AI에게 위임할 가능성이 존재하는 한, 우리는 이 문제에 대해 깊은 고민과 성찰을 통해 들여다봐야 할 필요가 있다.</p>\n<h2 id=\"ai는-인간-존재의-본질을-위협하는가\" style=\"position:relative;\">AI는 인간 존재의 본질을 위협하는가<a href=\"#ai%EB%8A%94-%EC%9D%B8%EA%B0%84-%EC%A1%B4%EC%9E%AC%EC%9D%98-%EB%B3%B8%EC%A7%88%EC%9D%84-%EC%9C%84%ED%98%91%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"ai는 인간 존재의 본질을 위협하는가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>“ChatGPT를 썼다면 더 잘할 수 있었을 것 같아요”라는 지원자의 답변에서, 필자는 인간이 AI에게 사고를 점점 더 위임하게 됨으로써 발생할 수 있는 위험에 대해 이야기했다. 말 그대로 이 답변은 AI의 도움을 받지 못했기 때문에 과제를 제대로 수행할 수 없었다는 의미로, 인간의 사고 능력이 AI에 의존하게 되는 현상을 보여준다고 할 수 있다.</p>\n<p>인간이 스스로를 이해하고 자신의 생각과 행동을 분석하며, 자신의 존재에 대한 깊은 이해를 추구할 수 있는 능력, 즉 사고와 자기 성찰, 자아 인식이라는 것은 인간의 본질을 규정하는 중요한 요소이다. 이러한 능력들은 인간이 단순한 생물학적 존재를 넘어선 독특한 존재로서의 가치를 지니게 하는 핵심 요소라고 할 수 있다.</p>\n<p>이러한 근거를 토대로 필자는 AI가 인간 존재의 본질을 위협할 가능성에 대해 경계할 필요가 있다고 이야기하고 싶다.</p>\n<p>AI가 발전함에 따라 우리는 점점 더 많은 사고 과정을 AI에게 위임하고 있다. 우리가 어떠한 문제를 해결할 때 AI의 도움을 받는 것이 점점 일반화된다면, 스스로 깊이 생각하고 고민하는 과정을 생략하게 될 가능성이 높으며 이는 결국 자기 성찰의 기회를 잃게 만들고 우리의 사고 능력을 제한할 수 있다.</p>\n<p>더 나아가 AI가 인간의 의사결정까지도 점점 대신하게 된다면 인간은 자아 인식의 중요한 요소인 책임감과 자율성을 상실할 위험이 있다. 또한 AI가 내린 의사결정에 의존하게 될수록 우리는 그 결과에 대한 책임을 덜 느끼게 되고, 이는 우리의 도덕적 판단 능력을 약화시킬 수도 있다.</p>\n<p>이렇게 책임감과 도덕적 판단 능력에 대한 이야기는 이미 “자율주행차가 사고를 내면 누구의 책임인가?”와 같은 생활 속의 아젠다로 떠오른지 오래지만, 필자는 아직도 이런 아젠다에 대한 명쾌한 결론은 아무 것도 나오지 않았다는 점을 강조하고 싶다.</p>\n<p>우리는 AI의 발전과 그에 따른 의존도가 높아질수록 우리가 인간으로 정의될 수 있는 본질적인 능력을 잃어버릴 위험에 처하게 될 수도 있다는 사실을 경계해야하는 것이다. 그리고 이러한 경계심에서 비롯된 윤리적 담론은 이 기술을 선도하고 있는 사람들일수록 더더욱 신경써야 한다.</p>\n<h2 id=\"지금-프로그래밍을-하고-있는-당신은-누구인가\" style=\"position:relative;\">지금 프로그래밍을 하고 있는 당신은 누구인가<a href=\"#%EC%A7%80%EA%B8%88-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8B%B9%EC%8B%A0%EC%9D%80-%EB%88%84%EA%B5%AC%EC%9D%B8%EA%B0%80\" aria-label=\"지금 프로그래밍을 하고 있는 당신은 누구인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>다들 예상했겠지만 이 기술을 선도하고 있는 사람들은 바로 개발자와 학자들이다. 특히 그 중에서도 AI라는 도메인에 직접적인 기여를 하고 있는 분들일것이다.</p>\n<p>그러나 최근 들어 개발자들 사이에서도 ChatGPT나 Copilot 같은 AI 도구를 사용하며 AI가 제안한 코드를 비판 없이 수용하는 사례가 종종 보인다.</p>\n<p>물론 ChatGPT나 Copilot의 발전은 매우 빠르며, 예전보다 높은 퀄리티의 코드를 출력해내고 있다는 것은 사실이지만, 하지만 현재 시점에서 보았을 때 그것이 완벽하다고 말할 수 있을까?</p>\n<p>아니, 그렇지 않다. AI가 생성한 코드는 때때로 오류를 포함하고 있으며, 특정 상황에서는 완벽한 해결책을 제시하지 못할 때도 있다. 특히 여러 모듈의 맥락을 연결해가며 이해하고 아키텍쳐를 설계해야하는 부분은 아직 AI가 정복하지 못한 문제이다.</p>\n<p>만약 AI가 제안한 코드가 이미 완벽하다면 개발자라는 직업은 이미 사라져야 마땅하다. 그러나 개발자라는 직업이 여전히 존재한다는 사실이 아직 AI의 코드가 완전하지 않다는 사실을 역설하고있다. 앞으로 AI가 발전하면 점점 이 직업에 종사하는 인구가 줄어들지언정 현재로써는 아직 그렇지 않다는 이야기이다.</p>\n<p>그렇다면 이러한 기술에 전문성을 가지고 있는 우리는 어떤 역할을 해야 하는 것일까?</p>\n<p>개발자는 단순히 AI의 출력을 수용하는 것에서 그치지 않고, AI가 생성한 코드를 비판적으로 검토하고 수정해야 한다. 우리는 AI를 도구로써 바라보고 활용해야 하며, 그 도구를 통해 우리의 사고력과 창의성을 극대화해야 한다. AI의 도움을 받더라도, 최종적인 결정과 책임은 우리 자신에게 있다는 것이다.</p>\n<p>할루시네이션이 존재한다는 사실을 뻔히 알면서도 그 코드를 비판적인 검토없이 복붙하거나, AI의 답변이 진실된 것인 것처럼 믿는 것은 아직 시기상조이며, 혹여 AI가 완벽한 답변을 내놓는 순간이 온다고 해도 어디까지나 AI는 도구로써 전문가에게 컨트롤되어야 한다는 사실을 잊어서는 안된다. <small>(AI는 라이브러리이지, 프레임워크가 아니다)</small></p>\n<p>만약 AI의 출력을 비판없이 수용하고 마치 그것이 내 능력인 것처럼 착각하고 있다면, 스스로에게 한번 반문해보자.</p>\n<blockquote>\n<p>나는 AI라는 도구를 활용하는 인간인가? 아니면 AI가 내놓은 출력물을 IDE에 옮겨담고 있는 존재일 뿐인가?</p>\n</blockquote>\n<p>AI는 “내”가 될 수 없다. 우리는 AI의 도움을 받을 수 있지만, 그 도움을 받는 과정에서 스스로 생각하고 판단하는 능력을 잃지 않도록 경계해야한다.</p>\n<p>이러한 질문은 단순히 프로그래밍이라는 문제를 넘어, 인간의 본질에 대한 깊은 성찰을 요구한다. 인간이 본질적으로 자기 성찰과 자아 인식을 통해 스스로를 이해하고 자신의 존재 이유와 삶의 의미를 탐구하는 존재라면, 인간이 아닌 도구의 지시대로 행동하는 것만으로는 인간으로 존재할 수 없기 때문이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>혹자는 필자의 이런 생각이 시기적으로 너무 이른 생각이라고, 혹은 너무 비약적이라고 이야기할 수도 있다. 하지만 독자 여러분도 아시다시피 AI의 발전 속도는 생각보다 어마무시하며, 특정 분야에서는 10년도 되지 않은 시간 안에 AI가 인간을 넘어선 경우도 존재한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7800e68ab22994055e740f794b98ab78/4b190/graph.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3pRQf//EABYQAAMAAAAAAAAAAAAAAAAAABAgIf/aAAgBAQABBQJKP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABsQAAICAwEAAAAAAAAAAAAAAAABITERQWGB/9oACAEBAAE/IXfCnCwKSdHgR//aAAwDAQACAAMAAAAQAA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAEAAwADAQAAAAAAAAAAAAABABExIUFhgf/aAAgBAQABPxBLlcJUvQHYBzFS6YhXhXsBbT5M6NPRP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"graph\" title=\"\" src=\"/static/7800e68ab22994055e740f794b98ab78/c08c5/graph.jpg\" srcset=\"/static/7800e68ab22994055e740f794b98ab78/0913d/graph.jpg 160w,\n/static/7800e68ab22994055e740f794b98ab78/cb69c/graph.jpg 320w,\n/static/7800e68ab22994055e740f794b98ab78/c08c5/graph.jpg 640w,\n/static/7800e68ab22994055e740f794b98ab78/4b190/graph.jpg 800w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>수학은 그렇다치고 언어 이해력 부문의 무시무시한 기울기를 보자.</small>\n</center>\n<p>깃허브에 올라와 있는 AI 관련 프로젝트의 수는 2011년 기준 약 800개에 불과했었으나, 2023년에는 약 180만개로 증가했으며, 같은 기간동안 논문의 수도 약 3배 정도 증가했다.</p>\n<p>필자는 이처럼 기술이 빠르게 발전하는 속도에 비해 우리가 이 기술을 바라보는 시각, 이 기술로 인해 발생할 여러가지 사이드 이펙트에 대한 논의는 아직까지 그 속도에 맞게 발전하지는 않았다고 생각한다.</p>\n<p>AI는 근본적으로 지금까지의 도구와는 궤를 달리한다. 지금까지의 도구는 무슨 짓을 해도 결코 인간을 넘어설 수 없었으며, 그러한 태생적 한계로 인해 아무리 좋은 도구라고 해도 그저 인간을 보조하는 정도에 그쳤다.</p>\n<p>하지만 이미 위 차트에서 볼 수 있듯이 이미 AI는 인간을 넘어서고 있다. 물론 AGI가 등장하려면 시간이 조금 더 걸리겠지만, 적어도 특정 분야에서만큼은 이미 그러하다. 우리는 이 점에 주목해야한다.</p>\n<p>결국 필자가 이야기하고 싶은 것은 우리가 AI라는 편리하고 폭발적인 생산성을 가져다주는 도구를 사용하면서, 나도 모르게 인간으로서의 본질적 가치를 이 도구에게 위임하고 있는 것은 아닌지 돌아보자는 것이다.</p>\n<p>도구는 인간이 주도권을 가지고 활용되기 때문에 도구라고 할 수 있다. 만약 우리가 AI를 사용함으로써 인간으로서의 주체성과 본질적 의의를 잃는다면, 그것을 더 이상 도구라고 할 수 있을까?</p>\n<p>결국 우리가 AI와 함께 더 나은 미래를 만들어 가기 위해서는 이러한 윤리적/철학적 담론이 반드시 동반되어야 하며, 특히 이 기술을 선도하고 있는 사람들이라면 단지 기술의 발전에만 몰두하는 것이 아니라 이러한 논의에도 활발하게 참여하여 우리가 인간으로써 AI라는 좋은 도구를 제대로 활용할 수 있는 세상을 만드는 것에 관심을 가져한다는 사실을 강조하고 싶다.</p>\n<p>이상으로 지금 프로그래밍을 하고 있는 당신은 누구인가 포스팅을 마친다.</p>","fields":{"slug":"20240623-perspective-on-ai","path":"/2024/06/23/perspective-on-ai/","lang":"ko"},"frontmatter":{"title":"지금 프로그래밍을 하고 있는 당신은 누구인가","subTitle":"AI가 사고를 대신하는 시대, 우리는 무엇을 잃어가고 있는가","date":"Jun 23, 2024","categories":["에세이"],"tags":["ChatGPT","생성형 AI","Generative AI","철학"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/f3e7e95695f94e8513c768994ddcd10a/fc5c5/thumbnail.webp","srcSet":"/static/f3e7e95695f94e8513c768994ddcd10a/fc5c5/thumbnail.webp 320w,\n/static/f3e7e95695f94e8513c768994ddcd10a/e9225/thumbnail.webp 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/f3e7e95695f94e8513c768994ddcd10a/b384d/thumbnail.webp","srcSet":"/static/f3e7e95695f94e8513c768994ddcd10a/b384d/thumbnail.webp 750w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5}}}}}},{"node":{"id":"f07d2419-e407-55f5-9ab2-a0ef3e27bcb3","tableOfContents":"<ul>\n<li><a href=\"#101-%EB%8B%A4%ED%98%95%EC%84%B1-%ED%95%A8%EC%88%98polymorphic-functions\">10.1 다형성 함수(Polymorphic Functions)</a></li>\n<li><a href=\"#102-%EC%9E%90%EC%97%B0%EC%84%B1%EC%9D%84-%EB%84%98%EC%96%B4beyond-naturality\">10.2 자연성을 넘어(Beyond Naturality)</a></li>\n<li><a href=\"#103-%ED%8E%91%ED%84%B0-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACfunctor-category\">10.3 펑터 카테고리(Functor Category)</a></li>\n<li><a href=\"#104-2-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\">10.4 2-카테고리</a></li>\n<li><a href=\"#105-%EA%B2%B0%EB%A1%A0\">10.5 결론</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"필자는 지금까지 카테고리 사이의 구조를 보존하는 사상으로써의 펑터에 대해 이야기하였다. 펑터는 한 카테고리를 다른 카테고리에 포함(Embeds)한다. 이는 결국 펑터가 여러 대상을 하나로 합칠 수는 있지만, 절대 구조를 변형하지는 않는다는 것을 의미한다. 펑터에 대해 이해하는 방법 중 하나는 함자를 사용하여 하나의 카테고리를 다른 카테고리 내부에서 모델링해보는 것이다. 소스가 되는 카테고리는 대상이 될 카테고리의 일부인 구조적인 모델 또는 청사진 역할을 한다. 어떤 하나의 카테고리를 다른 카테고리에 포함시키는 방법에는 여러가지가 …","html":"<p>필자는 지금까지 카테고리 사이의 구조를 보존하는 사상으로써의 펑터에 대해 이야기하였다. 펑터는 한 카테고리를 다른 카테고리에 <a href=\"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts/#57-%EB%B9%84%EB%8C%80%EC%B9%AD%EC%84%B1asymmetry\">포함(Embeds)</a>한다. 이는 결국 펑터가 여러 대상을 하나로 합칠 수는 있지만, 절대 구조를 변형하지는 않는다는 것을 의미한다. 펑터에 대해 이해하는 방법 중 하나는 함자를 사용하여 하나의 카테고리를 다른 카테고리 내부에서 모델링해보는 것이다.</p>\n<p>소스가 되는 카테고리는 대상이 될 카테고리의 일부인 구조적인 모델 또는 청사진 역할을 한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c4214ca2fdd7dfbd1bc9f19c3c05ac86/c08c5/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 98.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvZ1EbCkBYP//EABkQAAMAAwAAAAAAAAAAAAAAAAABEQIQIP/aAAgBAQABBQKmTcJw1r//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAgEBPwFj/8QAFhAAAwAAAAAAAAAAAAAAAAAAACEw/9oACAEBAAY/AhQ//8QAGhABAQEAAwEAAAAAAAAAAAAAAQAREDFBUf/aAAgBAQABPyHEJJ2JfmT3719jgV2L/9oADAMBAAIAAwAAABAEDwD/xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPxAj/8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQIBAT8QRH//xAAeEAACAQQDAQAAAAAAAAAAAAABEQAhMUFxEFFhof/aAAgBAQABPxAjbNiBAgFWfZZECzajikA2IHxKnvghJ0x3AQn/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/c4214ca2fdd7dfbd1bc9f19c3c05ac86/c08c5/1.jpg\" srcset=\"/static/c4214ca2fdd7dfbd1bc9f19c3c05ac86/0913d/1.jpg 160w,\n/static/c4214ca2fdd7dfbd1bc9f19c3c05ac86/cb69c/1.jpg 320w,\n/static/c4214ca2fdd7dfbd1bc9f19c3c05ac86/c08c5/1.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>어떤 하나의 카테고리를 다른 카테고리에 포함시키는 방법에는 여러가지가 있을 수 있다. 대표적인 두 방법 중 하나의 방법은 소스 카테고리를 대상 카테고리가 가진 하나의 대상으로 축소시키는 방법, 그리고 다른 방법은 소스 카테고리의 각 대상을 대상 카테고리의 각 대상으로, 소스 카테고리의 각 사상을 대상 카테고리의 각 사상으로 매핑하는 방법이다. 즉, 같은 청사진이라고 해도 여러가지 방법으로 표현될 수 있다는 의미이다. 자연 변환은 이런 방법들을 비교하는 데 큰 도움이 된다. 자연 변환은 펑터들의 펑터적 성질을 보존해주는 특별한 사상이기 때문이다.</p>\n<p>카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 를 매핑하는 두 개의 펑터 <code class=\"language-text\">F</code>와 <code class=\"language-text\">G</code>를 한번 상상해보자. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>가 가진 하나의 대상인 <code class=\"language-text\">a</code>에 대해서 한번 생각해보자면, 이 펑터들은 두 개의 대상인 <code class=\"language-text\">F a</code>와 <code class=\"language-text\">G a</code>로 매핑될 것이다. 여기서 펑터들의 매핑이라는 말의 의미는 <code class=\"language-text\">F a</code>를 <code class=\"language-text\">G a</code>로 매핑하는 행위를 의미하는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f698739fc8d3c8896112a676ed3e29b5/c08c5/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 85%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGQABAQEAAwAAAAAAAAAAAAAAAAIDAQQF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB93OsjsuBUBYP/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAECEBFC/9oACAEBAAEFAtFLWOOiQq6P/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFxABAAMAAAAAAAAAAAAAAAAAIQAQIP/aAAgBAQAGPwKDbn//xAAbEAACAgMBAAAAAAAAAAAAAAABEQAxECFBwf/aAAgBAQABPyEiCXyNZAsObTozYjKFSuPGP//aAAwDAQACAAMAAAAQ8AcA/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAGhABAAMBAQEAAAAAAAAAAAAAAREhMQAQ4f/aAAgBAQABPxAQkELivnJjCqaInjIZxxKdCyuvIlZQh1sueCX1Vvxx4//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/f698739fc8d3c8896112a676ed3e29b5/c08c5/2.jpg\" srcset=\"/static/f698739fc8d3c8896112a676ed3e29b5/0913d/2.jpg 160w,\n/static/f698739fc8d3c8896112a676ed3e29b5/cb69c/2.jpg 320w,\n/static/f698739fc8d3c8896112a676ed3e29b5/c08c5/2.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>여기서 한 가지 유의해야할 점은 <code class=\"language-text\">F a</code>와 <code class=\"language-text\">G a</code> 모두 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상이라는 것이다. 동일한 카테고리 내의 대상들 사이의 매핑은 카테고리가 가진 특성을 위반해서는 안된다. 우리는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상들 사이에 인위적인 연결을 만들어내는 것이 아니라, 그저 사상이라는 개념을 <em>자연스럽게</em> 이용하면 되는 것이다.</p>\n<p>즉, 자연 변환은 <code class=\"language-text\">a</code>라는 대상으로 인해 발생할 수 있는 사상들 중 <code class=\"language-text\">F a → G a</code>와 같은 하나의 사상을 선택하는 것이라고 볼 수 있다. 이 자연 변환을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>(알파: a가 아니다.)라고 부른다면 이 사상은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>의 성분 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">α_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>(밑은 알파가 아닌 대상 a이다)라고 불린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 우리가 신경써야 하는 점은 대상 <code class=\"language-text\">a</code>는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 대상이고, 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">α_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 사상이라는 것이다.</p>\n<p>만약 어떠한 대상 <code class=\"language-text\">a</code>를 기반으로 한 매핑 결과 <code class=\"language-text\">F a</code>와 <code class=\"language-text\">G a</code> 사이에 사상이 존재하지 않는다면, 펑터 <code class=\"language-text\">F</code>와 펑터 <code class=\"language-text\">G</code> 간의 자연 변환 또한 존재할 수 없다는 의미이다.</p>\n<p>물론 이 이야기는 대상에 대한 이야기이므로 펑터가 만들어낼 수 있는 모든 케이스를 커버할 수 있는 것은 아니다. 왜냐하면 펑터들은 대상 뿐 아니라 사상 또한 매핑하기 때문이다. 그렇다면 사상들에 대해서는 자연 변환이 어떻게 작용하는 것일까?</p>\n<p>한번 임의의 사상을 <code class=\"language-text\">f</code>라고 해보자. 사상들이 표현하는 매핑 행위는 고정되어있으니, <code class=\"language-text\">F</code>와 <code class=\"language-text\">G</code> 사이의 어떤 자연 변환에서도 <code class=\"language-text\">F f</code>는 반드시 <code class=\"language-text\">G f</code>로 변환되어야 한다.</p>\n<p>이에 더해 펑터는 이 사상들의 매핑이 가진 특성을 보존해야한다는 제약을 가지고 있기 때문에 자연 변환의 정의 또한 이 제약에 얽매일 수 밖에 없다. 한번 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>가 가진 두 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 사이에 적용되는 사상 <code class=\"language-text\">f</code>를 생각해보자. 이 사상은 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>가 가진 두 개의 사상인 <code class=\"language-text\">F f</code>와 <code class=\"language-text\">G f</code>로 매핑될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">b</span>\n<span class=\"token constant\">G</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 내의 다이어그램을 완성할 수 있는 두 개의 사상을 추가적으로 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span>\nα<span class=\"token hvariable\">_b</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/baadfd22e8685308e55e728d5cb9234b/c08c5/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 82.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAIBBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7cJTYC1gJB//xAAZEAADAQEBAAAAAAAAAAAAAAAAAQIRMRD/2gAIAQEAAQUCdCoT0dG4lzyef//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABwQAAEDBQAAAAAAAAAAAAAAAAABESESIDFRkf/aAAgBAQAGPwKBNEDTwpMvZ//EABsQAQACAwEBAAAAAAAAAAAAAAEAERAhMXHR/9oACAEBAAE/IR4xZXsjxAFqyJsBXd21PIeNVPsYeYf/2gAMAwEAAgADAAAAEI8AAP/EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/EGP/xAAWEQEBAQAAAAAAAAAAAAAAAAABIDH/2gAIAQIBAT8QTI//xAAdEAEAAgEFAQAAAAAAAAAAAAABABFhECExQXGR/9oACAEBAAE/EEFgHK7HyJValJajmBwJ2SimNLALwYirjs0DV9rcdhpg05PJxez/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/baadfd22e8685308e55e728d5cb9234b/c08c5/3.jpg\" srcset=\"/static/baadfd22e8685308e55e728d5cb9234b/0913d/3.jpg 160w,\n/static/baadfd22e8685308e55e728d5cb9234b/cb69c/3.jpg 320w,\n/static/baadfd22e8685308e55e728d5cb9234b/c08c5/3.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>위 다이어그램을 보면 <code class=\"language-text\">F a</code>에서 <code class=\"language-text\">G b</code>로 가는 방법은 총 두 가지이다. 이 두 가지 방법이 동일한지 확인하려면 모든 f에 대해서 성립할 수 있는 <em>자연성</em> 조건을 부여해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G</span> <span class=\"token hvariable\">f</span> ◦ α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">=</span> α<span class=\"token hvariable\">_b</span> ◦ <span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이러한 자연성 조건은 매우 엄격한 제약이라고 볼 수 있다. 예를 들어 사상 <code class=\"language-text\">F f</code>가 가역적이라면 자연성 조건을 통해 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">α_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>만 사용해서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>b</mi></msub></mrow><annotation encoding=\"application/x-tex\">α_b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>를 결정해버릴 수 있다. 아래와 같이 말이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α<span class=\"token hvariable\">_b</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">G</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> ◦ α<span class=\"token hvariable\">_a</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span><span class=\"token operator\">^-</span><span class=\"token number\">1</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5c990e34263308dff03e8d7e9a68fc21/c08c5/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHaVqLAr//EABoQAAICAwAAAAAAAAAAAAAAAAERABIhIjH/2gAIAQEAAQUCeS6ji2RMDn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAaEAACAgMAAAAAAAAAAAAAAAAAERAhMWGh/9oACAEBAAY/AtDfJyWf/8QAGxABAAIDAQEAAAAAAAAAAAAAAQARIUFhcTH/2gAIAQEAAT8ha4N7LqIMXjsvsU2upRRp5MHxfJ//2gAMAwEAAgADAAAAEEjP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFREBAQAAAAAAAAAAAAAAAAAAEEH/2gAIAQIBAT8Qp//EAB8QAQACAQMFAAAAAAAAAAAAAAEAEUEhUWFxkaHB0f/aAAgBAQABPxBWTt7h8lONZq4cRiUBuKYMqAdb29xZdCYU+JUbrOmk/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/5c990e34263308dff03e8d7e9a68fc21/c08c5/4.jpg\" srcset=\"/static/5c990e34263308dff03e8d7e9a68fc21/0913d/4.jpg 160w,\n/static/5c990e34263308dff03e8d7e9a68fc21/cb69c/4.jpg 320w,\n/static/5c990e34263308dff03e8d7e9a68fc21/c08c5/4.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>만약 두 대상 사이에 여러 개의 가역적인 사상들이 존재한다면, 이 변환들은 모두 이 조건을 만족시켜야한다. 즉, 자연성 조건이 보장되는 상황이라면 어떤 경로를 따라가더라도 결국 동일한 결과에 다다라야 한다는 것이다. 그러나 일반적으로 사상들이 가역적인 경우는 별로 없기 때문에, 두 펑터 간의 자연 변환이 존재한다는 것이 항상 보장되는 것은 아니라고 이야기한 것이다.</p>\n<p>결과적으로는 이런 자연 변환을 통해 여러 펑터들이 작용하는 카테고리의 구조에 대한 많은 정보들을 표현해낼 수 있다. 추후 리미트와 요네다 보조정리에 대해 이야기할 때 이에 대한 몇 가지 예시를 다시 살펴볼 것이다.</p>\n<p>자연 변환을 각 요소 별로 뜯어서 살펴보면 결국 대상을 사상으로 매핑하는 것이라고 말할 수 있다. 자연성 조건으로 인해 사상을 교차하는 사각형 다이어그램으로 매핑한다고 볼 수도 있다는 것이다. 즉, 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>가 가진 각각의 사상에 대해서 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>는 이 사상들을 교차하는 자연성 사각형 다이어그램을 가지고 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7d47f98e7bebb1e14efececc63d81552/c08c5/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7mUnDDFf/8QAGBABAQADAAAAAAAAAAAAAAAAADEBAhH/2gAIAQEAAQUC6rEbI//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAAMAAAAAAAAAAAAAAAAAAAAgQf/aAAgBAQAGPwIq/wD/xAAaEAEBAQEAAwAAAAAAAAAAAAABEQAhMUFh/9oACAEBAAE/ITuRezdN4noc7gTHw/cAIE3/2gAMAwEAAgADAAAAEEsP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8QZ//EABwQAQEAAwADAQAAAAAAAAAAAAERACExUWFxkf/aAAgBAQABPxBq62oa+/ubDUeiDzmMNVRRrvuFUOtfbgkqKbFLkwh4M//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/7d47f98e7bebb1e14efececc63d81552/c08c5/5.jpg\" srcset=\"/static/7d47f98e7bebb1e14efececc63d81552/0913d/5.jpg 160w,\n/static/7d47f98e7bebb1e14efececc63d81552/cb69c/5.jpg 320w,\n/static/7d47f98e7bebb1e14efececc63d81552/c08c5/5.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>자연 변환이 가진 이러한 성질은 카테고리적인 구성을 할 때 매우 유용하다. 카테고리적인 구성을 할 때 종종 교차 다이어그램이 포함되는 경우가 많은데, 이때 적절한 펑터를 선택함으로써 이러한 교차성 조건을 자연성 조건으로 변환할 수 있다. 이는 추후 극한(limits), 쌍대극한(colimits), 수반(Adjunctions)에 대한 예시를 다룰 때 더 자세히 살펴보도록 하겠다.</p>\n<p>마지막으로 자연 변환은 펑터들의 동형사상을 정의하는 데에도 사용될 수 있다. 두 펑터가 자연적으로 동형이라고 말하는 것은 두 펑터가 거의 같다고 말하는 것과 동일한 말이다. <em>자연 동형성</em>은 모든 요소가 동형사상인 자연 변환으로 정의된다.</p>\n<h2 id=\"101-다형성-함수polymorphic-functions\" style=\"position:relative;\">10.1 다형성 함수(Polymorphic Functions)<a href=\"#101-%EB%8B%A4%ED%98%95%EC%84%B1-%ED%95%A8%EC%88%98polymorphic-functions\" aria-label=\"101 다형성 함수polymorphic functions permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 필자는 프로그래밍에서의 펑터(특히 엔도펑터)에 대해서 이야기해왔었다. 이 펑터는 타입을 다른 타입으로 매핑하는 타입 생성자에 해당한다. 또한 함수를 함수로 매핑하기도 하며, 이 매핑은 고계 함수 <code class=\"language-text\">fmap</code>에 의해 구현된다.</p>\n<p>자연 변환을 구성하기 위해서는 대상, 여기서는 타입 <code class=\"language-text\">a</code>부터 시작한다. 펑터 <code class=\"language-text\">F</code>는 이 타입을 타입 <code class=\"language-text\">F a</code>로 매핑할 것이다. 그리고 또 다른 펑터 <code class=\"language-text\">G</code>는 이 타입을 <code class=\"language-text\">G a</code>로 매핑한다. 이때 <code class=\"language-text\">alpha</code>라는 자연 변환의 성분은 타입 <code class=\"language-text\">a</code>이며, 이것은 결국 <code class=\"language-text\">F a</code>에서 <code class=\"language-text\">G a</code>로 매핑되는 함수를 의미한다. 이것을 Haskell 의사코드로 표현해보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>자연 변환은 모든 타입 <code class=\"language-text\">a</code>에 대해 정의되는 다형성 함수라고 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">forall</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">.</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서 <code class=\"language-text\">forall</code> 키워드는 선택적으로 사용할 수 있으며, 이 키워드를 사용하기 위해서는 <code class=\"language-text\">ExplicitForAll</code> 언어 확장을 활성화해야한다. 일반적으로는 아래와 같이 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 표현은 <code class=\"language-text\">a</code>에 의해 매개변수화된 함수라는 점에 주의하자. 이는 Haskell 구문의 간결함에 대한 또 다른 예시이기도 하다. 만약 C++에서 이와 유사한 구조를 표현하려면 약간 더 복잡해질 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span> G<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token function\">alpha</span><span class=\"token punctuation\">(</span>F<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서의 다형성 함수와 C++의 일반적인 함수 사이에는 더 깊은 차이가 있으며, 이 차이는 이러한 함수들이 구현되고 타입 검사되는 방식에도 그대로 적용된다. Haskell의 다형성 함수는 모든 타입에 적용될 수 있도록 일관되게 정의되어야한다. 즉, 하나의 공식이 모든 타입에 대해 작동해야한다는 것이다. 이를 *매개변수 다형성(Parametric polymorphism)*이라고 한다.</p>\n<p>C++은 기본적으로 특수 다형성(Ad hoc polymorphism)을 지원한다. 이는 어떤 하나의 템플릿이 반드시 모든 타입에 대해 적용될 수 있도록 정의될 필요는 없다는 것을 의미한다. 주어진 타입에 대해 템플릿이 적용될 수 있는지에 대한 여부는 인스턴스화 타임에 결정며, 이때 타입 매개변수가 구체적인 타입으로 대체된다. 이러한 과정 때문에 타입 검사가 느려지기도 하며, 가끔은 이해하기 어려운 에러 메시지를 만나기도 한다.</p>\n<p>C++에는 함수 오버로딩이나 템플릿 특수화 같은 매커니즘도 존재한다. 이를 통해 하나의 함수가 각기 다른 타입에 맞춰 다른 정의를 제공할 수도 있다. Haskell에서는 이런 기능이 타입 클래스와 타입 패밀리를 통해 제공된다.</p>\n<p>Haskell의 매개변수 다형성은 종종 예상치 못한 결과를 가져오기도 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">F</code>와 <code class=\"language-text\">G</code>는 펑터이며 자연성 조건을 자동으로 만족한다. 이를 카테고리적 표기법으로 나타내면 다음과 같다. (<code class=\"language-text\">f</code>는 함수 <code class=\"language-text\">f :: a -> b</code>이다)</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G</span> <span class=\"token hvariable\">f</span> ◦ α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">=</span> α<span class=\"token hvariable\">_b</span> ◦ <span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서 펑터 <code class=\"language-text\">G</code>의 사상 <code class=\"language-text\">f</code>에 대한 작용은 <code class=\"language-text\">fmap</code>을 사용하여 구현된다. 먼저 명시적인 타입 주석을 사용하여 Haskell 의사 코드로 작성해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">fmap_G</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">alpha_a</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">alpha_b</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">fmap_F</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사실 타입 추론 덕분에 이러한 주석들은 필요하지 않으며, 다음의 등식이 성립할 수 있게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">alpha</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">alpha</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이건 진짜 Haskell 문법이 아니라 의사 코드이다. 함수의 동등성은 코드로 표현할 수 없기 때문이다. 하지만 이런 항등식은 방정식 추론에 이용할 수 있으며, 컴파일러가 최적화를 구현하는 데에도 사용될 수 있다.</p>\n<p>Haskell에서 자연성 조건이 자동으로 성립하는 이유는 “공짜 정리(Theorems for free)와 관련이 있다. Haskell에서 자연 변환을 정의하는데 사용되는 매개변수 다형성은 모든 타입에 대해 작동할 수 있는 하나의 공식을 구현해야한다는 강력한 제한을 부과한다. 이러한 제한은 함수에 대해 방정식 정리를 사용할 수 있도록 만든다. 펑터를 변환하는 함수의 경우 공짜 정리는 자연성 조건을 의미한다.</p>\n<p>Haskell에서 펑터를 다루는 아이디어 중 하나는 바로 펑터를 일반화된 컨테이너로 간주하는 것이다. 비유를 해보자면 펑터는 자연 변환한 컨테이너의 내용을 다른 컨테이너로 다시 포장하는 일종의 레시피라고 볼 수 있다. 우리는 컨테이너 내부 요소 자체를 수정하거나 새로운 요소를 만드는 것과 같은 변화를 가하지 않는다. 단지 그 요소들을 복사하여 새로운 컨테이너에 담을 뿐이다.</p>\n<p>자연성 조건은 내부 요소를 <code class=\"language-text\">fmap</code>을 통해 먼저 수정하고 나중에 재포장하든, 재포장을 먼저 하고 새로운 컨테이너에서 내부 요소를 수정하든 상관없다는 것을 명시적으로 표현한다. 재포장과 <code class=\"language-text\">fmap</code>이라는 두 개의 동작은 마치 “계란을 옮긴다”, “계란을 끓인다”와 같이 직교적(서로 독립적)이라고 할 수 있다.</p>\n<p>한번 Haskell에서의 자연 변환을 보여주는 몇 가지 예시를 살펴보도록 하자. 첫 번째 예시는 <code class=\"language-text\">List</code> 펑터와 <code class=\"language-text\">Maybe</code> 펑터와의 자연 변환이다. 이 함수는 리스트의 첫 번째 요소를 반환하지만, 만약 리스트가 비어있다면 <code class=\"language-text\">Nothing</code>을 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">safeHead</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 <code class=\"language-text\">a</code>에 대해 다형적이다. <code class=\"language-text\">a</code>가 어떤 타입이든 함수는 제한없이 작동하기 때문에 매개변수 다형성을 갖추고 있다고 하는 것이다. 따라서 이 함수는 두 개의 펑터 사이의 자연 변환의 예시가 될 수 있다. 하지만 확실히 짚고 넘어가기 위해 자연성 조건을 한번 검증해보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">safeHead</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">safeHead</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 두 개의 경우를 고려해야한다. 먼저 빈 리스트에 대한 경우를 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n\n<span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그리고 비어있지 않은 리스트에 대해서도 대응해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">:</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fx</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>List 펑터와 Maybe 펑터의 <code class=\"language-text\">fmap</code> 구현에 대해서도 한번 되짚어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token comment\">-- List</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">:</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">xs</span>\n\n<span class=\"token comment\">-- Maybe</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>더 흥미로운 예시는 펑터 중 하나가 단순한 <code class=\"language-text\">Const</code> 펑터인 경우이다. <code class=\"language-text\">Const</code> 펑터로부터 출발하거나 <code class=\"language-text\">Const</code> 펑터로 향하는 자연 변환은 반환 타입이나 인수 타입 중 하나에 다형성을 가진 함수와 동일하다.</p>\n<p>예를 들어 길이(length)는 <code class=\"language-text\">List</code> 펑터에서 <code class=\"language-text\">Const Int</code> 펑터로의 자연 변환으로 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">length</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Const</span> <span class=\"token constant\">Int</span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">length</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Const</span> <span class=\"token number\">0</span>\n<span class=\"token builtin\">length</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">unConst</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">length</span> <span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">unConst</code>는 <code class=\"language-text\">Const</code> 생성자를 제거하는데 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">unConst</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span>\n<span class=\"token hvariable\">unConst</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>물론 실제 <code class=\"language-text\">length</code>는 아래와 같이 단순하게 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">length</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 타입 시그니처는 <code class=\"language-text\">length</code>가 <code class=\"language-text\">List</code> 펑터에서 <code class=\"language-text\">Const</code> 펑터로의 자연 변환이라는 사실을 숨기고 있다.</p>\n<p>반면 <code class=\"language-text\">Const</code> 펑터에서 출발하는 매개변수 다형성 함수를 찾는 것은 조금 더 어려운 일이다. 왜냐하면 아무것도 없는 상태에서 값을 생성하기를 요구하기 때문이다. 따라서 우리가 할 수 있는 최선은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">scam</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Const</span> <span class=\"token constant\">Int</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">scam</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또 다른 펑터는 예전에 보았던 <code class=\"language-text\">Reader</code> 펑터이며, 이 펑터는 요네다 보조정리에서도 중요한 역할을 한다. <code class=\"language-text\">newtype</code> 키워드를 사용하여 <code class=\"language-text\">Reader</code> 펑터의 정의를 다시 작성해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">Reader</span> <span class=\"token hvariable\">e</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Reader</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">e</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것은 두 가지 타입으로 매개변수화되지만, 두 번째 유형에 대해서만 공변적으로 펑터적이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Reader</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>모든 타입 <code class=\"language-text\">e</code>에 대해서, <code class=\"language-text\">Reader e</code>에서 다른 펑터 <code class=\"language-text\">f</code>로의 자연 변환들을 정의할 수도 있다. 나중에 요네다 보조정리에 대한 이야기를 할 때 이 변환들의 구성원들이 항상 <code class=\"language-text\">f e</code>의 요소와 일대일 대응되는 것을 보게될 것이다.</p>\n<p>예를 들어 유닛 타입 <code class=\"language-text\">()</code>를 생각해보자. 이 타입은 단 하나의 원소인 <code class=\"language-text\">()</code>를 가진다. <code class=\"language-text\">Reader</code> 펑터는 임의의 타입 <code class=\"language-text\">a</code>를 가져와서 함수 타입 <code class=\"language-text\">() -> a</code>로 매핑한다. 그리고 이 함수는 집합 <code class=\"language-text\">a</code>에서 하나의 원소를 선택하는 모든 함수들을 의미한다. 즉, 이 함수들은 집합 <code class=\"language-text\">a</code>에 있는 원소들의 수만큼 존재하는 것이다.</p>\n<p>그럼 이제 이 펑터에서 <code class=\"language-text\">Maybe</code> 펑터로의 자연 변환을 생각해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Reader</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 자연 변환은 <code class=\"language-text\">dumb</code>와 <code class=\"language-text\">obvious</code> 두 가지 함수로 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">dumb</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n\n<span class=\"token hvariable\">obvious</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>(어차피 함수 <code class=\"language-text\">g</code>가 할 수 있는 유일한 행위는 값 <code class=\"language-text\">()</code>에 적용되는 것 뿐이다.)</p>\n<p>실제로 요네다 보조정리에서 예측된대로 이 두 함수들은 <code class=\"language-text\">Maybe ()</code> 타입의 두 요소들인 <code class=\"language-text\">Nothing</code>과 <code class=\"language-text\">Just ()</code>에 대응한다. 이에 대해서는 추후 요네다 보조정리를 이야기하며 더 자세히 살펴보도록 하겠다.</p>\n<h2 id=\"102-자연성을-넘어beyond-naturality\" style=\"position:relative;\">10.2 자연성을 넘어(Beyond Naturality)<a href=\"#102-%EC%9E%90%EC%97%B0%EC%84%B1%EC%9D%84-%EB%84%98%EC%96%B4beyond-naturality\" aria-label=\"102 자연성을 넘어beyond naturality permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>두 펑터 사이의 매개변수 다형성 함수는 항상 자연 변환이다. 즉, 모든 표준 대수적 데이터 타입은 펑터이니 이러한 타입들 사이의 모든 다형성 함수는 자연 변환이다.</p>\n<p>또한 우리는 함수 타입을 사용할 수 있으며, 함수 타입은 반환 타입에 대해 펑터적이다. 이를 사용하여 <code class=\"language-text\">Reader</code> 펑터와 같은 펑터를 만들고, 고차 함수인 자연 변환을 정의할 수도 있다.</p>\n<p>그러나 함수 타입은 인자 타입에 대해 공변적이지 않으며 반공변적으로 작동한다. 물론 반공변 펑터는 반대 카테고리에서의 공변 펑터와 동등하다. 두 반공변 펑터 사이의 다형성 함수를 카테고리적 의미에서 보았을때는 여전히 자연 변환이다. 단, 이것들은 반대 카테고리에서 Haskell 타입으로 가는 펑터에서 작동한다.</p>\n<p>이전에 보았던 반공변 펑터의 예시를 다시 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">Op</span> <span class=\"token hvariable\">r</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Op</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 펑터는 <code class=\"language-text\">a</code>에 대해 반공변적이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Contravariant</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">contramap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Op</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>우리는 이 펑터를 가지고 <code class=\"language-text\">Op Bool</code>에서 <code class=\"language-text\">Op String</code>으로 향하는 다형성 함수를 작성해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">predToStr</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Op</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token keyword\">then</span> <span class=\"token string\">\"T\"</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"F\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그러나 두 펑터가 모두 공변적이지 않기 때문에, 이것은 <strong>Hask</strong>에서의 자연 변환이 아니다. 그러나 두 펑터가 모두 반공변적이니, “반대” 자연성 조건을 만족할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">contramap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">predToStr</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">predToStr</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">contramap</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">contramap</code>의 시그니처 때문에 함수 <code class=\"language-text\">f</code>는 <code class=\"language-text\">fmap</code>을 사용할 때와는 반대 방향으로 가야한다는 점을 주목하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">contramap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token constant\">Bool</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Op</span> <span class=\"token constant\">Bool</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그렇다면 공변적이든 반공변적이든 펑터가 아닌 타입 생성자도 있을까? 여기 한 가지 예시가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것은 동일한 타입 <code class=\"language-text\">a</code>가 반공변 위치, 공변 위치 모두에서 사용되기 때문에 펑터가 아니며, 이 타입에 대한 <code class=\"language-text\">fmap</code>이나 <code class=\"language-text\">contramap</code>을 구현할 수도 없다. 따라서 아래와 같은 시그니처를 가진 함수는 자연 변환이 될 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>흥미롭게도 이러한 경우를 다루는 자연 변환의 일반화된 형태가 있으며, 이를 이자연 변환(Dinatural transformations)이라고 한다. 이에 대해서는 추후 끝(ends)에 대해 이야기할 때 다시 살펴볼 것이다.</p>\n<h2 id=\"103-펑터-카테고리functor-category\" style=\"position:relative;\">10.3 펑터 카테고리(Functor Category)<a href=\"#103-%ED%8E%91%ED%84%B0-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACfunctor-category\" aria-label=\"103 펑터 카테고리functor category permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이제 우리는 펑터 간의 사상인 자연 변환에 대해 알게 되었으므로, 펑터만으로 이루어진 카테고리도 존재하는지 대해서 이야기해볼 수 있게 되었다. 그리고 실제로 펑터로만 이루어진 카테고리는 존재한다. 각 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 향하는 펑터로만 이루어진 카테고리를 생각해보자. 이 카테고리의 대상은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 향하는 펑터이며, 사상은 이 펑터들 사이의 자연 변환일 것이다.</p>\n<p>또한 이미 우리는 사상을 어떻게 합성하는지 알고 있으니, 두 자연 변환의 합성의 정의 또한 쉽게 할 수 있다.</p>\n<p>한번 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>로 향하는 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>를 생각해보자. 이때 대상 <code class=\"language-text\">a</code>의 성분은 다음과 같은 사상이 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 이 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>를 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span></span>로 향하는 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>와 합성하려고 한다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 대상 <code class=\"language-text\">a</code>의 성분은 다음과 같은 사상이 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">β<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">H</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>당연히 이 사상들은 합성이 가능하며, 그 합성 결과는 또 다른 사상이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">β<span class=\"token hvariable\">_a</span> ◦ α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">H</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 두 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 합성인 이 사상을 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mo>⋅</mo><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">β ⋅ α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>의 성분으로 사용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span>β ⋅ α<span class=\"token punctuation\">)</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> β<span class=\"token hvariable\">_a</span> ◦ α<span class=\"token hvariable\">_a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/77760305bd4e45023763ece302c8b710/c08c5/6.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 67.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHbVqKGV//EABgQAQEBAQEAAAAAAAAAAAAAAAEAAhAR/9oACAEBAAEFAnUah9tQc//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAABAR/9oACAEBAAY/Amv/xAAaEAEAAwEBAQAAAAAAAAAAAAABACExERBB/9oACAEBAAE/ISwd+wgtyoAplDjSMa98/9oADAMBAAIAAwAAABAbz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EGf/xAAcEAEBAQACAwEAAAAAAAAAAAABEQAhQVFxgbH/2gAIAQEAAT8QUhII8mXOAUXas6fuTJIMfeH6Rw4yvyoaHjf/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"\" src=\"/static/77760305bd4e45023763ece302c8b710/c08c5/6.jpg\" srcset=\"/static/77760305bd4e45023763ece302c8b710/0913d/6.jpg 160w,\n/static/77760305bd4e45023763ece302c8b710/cb69c/6.jpg 320w,\n/static/77760305bd4e45023763ece302c8b710/c08c5/6.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>아래 다이어그램을 보면, 이 합성의 결과가 실제로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span></span>로 향하는 자연 변환임을 확인해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">H</span> <span class=\"token hvariable\">f</span> ◦ <span class=\"token punctuation\">(</span>β ⋅ α<span class=\"token punctuation\">)</span><span class=\"token hvariable\">_a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>β ⋅ α<span class=\"token punctuation\">)</span><span class=\"token hvariable\">_b</span> ◦ <span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/3ab8658c2500dadea960bfb7de8ab5c3/c08c5/7.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 96.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7lWcbpVALg//xAAbEAACAwADAAAAAAAAAAAAAAAAAQIRMRIyQf/aAAgBAQABBQLkWyOeJCVEuscP/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGRAAAgMBAAAAAAAAAAAAAAAAARAAESEx/9oACAEBAAY/AuMzKRf/xAAfEAABAwMFAAAAAAAAAAAAAAABABExIUFxEFFhscH/2gAIAQEAAT8hLCznRhE4W52jARzVEsdchMG9VeJQ40//2gAMAwEAAgADAAAAEDsHAP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABURAQEAAAAAAAAAAAAAAAAAAAEg/9oACAECAQE/EGP/xAAhEAEBAAIBAgcAAAAAAAAAAAABEQAhQRAxYXGBkbHB0f/aAAgBAQABPxC9VwDnyxRvT3YNeuVuEVu6ySKqivvGSM02QXn9wxFPCnABS7fGAFAFF9un/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"7\" title=\"\" src=\"/static/3ab8658c2500dadea960bfb7de8ab5c3/c08c5/7.jpg\" srcset=\"/static/3ab8658c2500dadea960bfb7de8ab5c3/0913d/7.jpg 160w,\n/static/3ab8658c2500dadea960bfb7de8ab5c3/cb69c/7.jpg 320w,\n/static/3ab8658c2500dadea960bfb7de8ab5c3/c08c5/7.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>자연 변환의 합성은 일반적인 사상과 동일하기 때문에 합성에 대한 결합법칙 또한 만족한다.</p>\n<p>마지막으로 각 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에 대해서는 성분이 항등 사상인 항등 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mn>1</mn><mi>F</mi></msub></mrow><annotation encoding=\"application/x-tex\">1_F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7944em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>도 존재할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">id_Fa</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>따라서 펑터로만 이루어진 카테고리도 존재한다고 말할 수 있는 것이다.</p>\n<p>참고로 이 책에서는 카테고리 이론의 공동 창시자인 사운더스 맥레인(Saunders Mac Lane)의 방식을 따라, 자연 변환의 합성을 점으로 표기하고 있다.</p>\n<p>문제는 자연 변환을 합성하는 방법이 하나가 아니라는 것이다. 이 방법들은 크게 수직 합성과 수평 합성으로 나누어진다. 그 중에서도 수직 합성은 일반적인 다이어그램에서 펑터와 자연 변환이 모두 수직으로 표기되기 때문에 불리는 명칭이며, 이는 펑터 카테고리를 이해할 때 중요한 개념이기도 하다. 또 다른 합성 방법인 수평 합성에 대해서는 다음 섹션에서 마저 설명하도록 하겠다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 623px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ea88c3814b829b2a248e93f9300f8566/50112/8.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdlaoUGD/8QAGxAAAgEFAAAAAAAAAAAAAAAAAAIBEBESEyH/2gAIAQEAAQUCdubDKCVuQlP/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAACAwEAAAAAAAAAAAAAAAAAEAERITH/2gAIAQEABj8CNXaNlf/EAB0QAQACAgIDAAAAAAAAAAAAAAEAMREhEGFBUXH/2gAIAQEAAT8h1MPmyCFsZx2/JZ1NTCR6lmwb4//aAAwDAQACAAMAAAAQo8//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxCn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAQADAQADAAAAAAAAAAAAAREAITFhQVHx/9oACAEBAAE/EAAYIrcjz39yzAkAh6C7+8EQLVHTm+ZKPD4nyYzLsYna2d5vJM//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"8\" title=\"\" src=\"/static/ea88c3814b829b2a248e93f9300f8566/50112/8.jpg\" srcset=\"/static/ea88c3814b829b2a248e93f9300f8566/0913d/8.jpg 160w,\n/static/ea88c3814b829b2a248e93f9300f8566/cb69c/8.jpg 320w,\n/static/ea88c3814b829b2a248e93f9300f8566/50112/8.jpg 623w\" sizes=\"(max-width: 623px) 100vw, 623px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 간의 펑터 카테고리는 <code class=\"language-text\">Fun(C, D)</code> 또는 <code class=\"language-text\">[C, D]</code>로 표기되며, 때로는 지수 형태인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>로 표기되기도 한다. 특히 마지막 표기법이 흥미로운데, 이는 펑터 카테고리 자체가 다른 카테고리에서 함수 대상(지수 대상)으로 간주될 수 있음을 암시하고 있기 때문이다. 이에 대해서 한번 알아보자.</p>\n<p>지금까지 우리가 구축해온 추상화 계층들을 한번 살펴보자. 우리는 대상과 사상의 집합인 카테고리에서부터 시작해왔다. 카테고리 자체, 특히 집합의 카테고리인 작은 카테고리는 상위 레벨 카테고리인 <strong>Cat</strong>(카테고리의 카테고리)에서의 대상이 된다. 그리고 <strong>Cat</strong>의 사상은 결국 펑터이기 때문에 <strong>Cat</strong>의 Hom 집합은 펑터들의 집합이 될 것이다. 예를 들어 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mi>a</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Cat(C, D)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">)</span></span></span></span></span>는 두 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 간의 펑터들의 집합이다.</p>\n<p>펑터 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[C, D]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span></span></span></span></span> 역시 사상으로 자연 변환을 가지고 있다는 점만 제외하면 두 카테고리 간의 펑터들의 집합이라고 볼 수 있다. 이 카테고리의 대상은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mi>a</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Cat(C, D)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">)</span></span></span></span></span>의 원소와 동일하기 때문이다. 게다가 펑터 카테고리 또한 카테고리이기 때문에 <strong>Cat</strong>의 대상이 되어야 한다. 즉, 우리는 이 관계를 하나의 카테고리 내의 Hom 집합과 대상 간의 관계로 표현할 수 있다는 것이며, 이건 이전 섹션에서 보았던 지수 대상과 정확하게 같은 개념이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/4259939dc4841e14f984da03becbf3f3/c08c5/9.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 98.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAIBAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7aEb0qYIsV//xAAbEAACAgMBAAAAAAAAAAAAAAABAhARABIxIf/aAAgBAQABBQI9DRZoN6vCoOax/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFxAAAwEAAAAAAAAAAAAAAAAAASAxIf/aAAgBAQAGPwKxMK//xAAaEAADAQADAAAAAAAAAAAAAAAAATEREFFh/9oACAEBAAE/IXcNlGvpTClmkCGiJQQk7fH/2gAMAwEAAgADAAAAECsPvP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABURAQEAAAAAAAAAAAAAAAAAABEQ/9oACAECAQE/EFhP/8QAHhABAAICAgMBAAAAAAAAAAAAAREhADFBsRBRccH/2gAIAQEAAT8QRMlh4q4cOcaAsCIfuCARkck5EQbstxmZhMMutxzrDFCDYO4y5s7++8HUhqKOvH//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"9\" title=\"\" src=\"/static/4259939dc4841e14f984da03becbf3f3/c08c5/9.jpg\" srcset=\"/static/4259939dc4841e14f984da03becbf3f3/0913d/9.jpg 160w,\n/static/4259939dc4841e14f984da03becbf3f3/cb69c/9.jpg 320w,\n/static/4259939dc4841e14f984da03becbf3f3/c08c5/9.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>한번 <strong>Cat</strong>에서 이 개념을 어떻게 구성할 수 있는지 살펴보자.</p>\n<p>지수를 구성하기 위해서는 먼저 곱의 개념을 정의해야 한다는 것을 기억할 것이다. 다행히도 <strong>Cat</strong>에서는 곱을 정의하기가 비교적 쉽다. 각각의 작은 카테고리들은 대상들의 집합이므로, 곱이라는 개념을 집합의 곱으로 생각해도 무방할 것이다. 따라서 곱 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C × D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상은 그냥 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상들 중 하나씩 뽑아내어 구성된 대상들의 쌍 <code class=\"language-text\">(c, d)</code>이다.</p>\n<p>마찬가지로 두 개의 쌍 <code class=\"language-text\">(c, d)</code>와 <code class=\"language-text\">(c', d')</code> 간의 사상은 사상의 쌍 <code class=\"language-text\">(f, g)</code>으로, 이때 각 사상들은 <code class=\"language-text\">f :: c -> c'</code>와 <code class=\"language-text\">g :: d -> d'</code>가 될 것이다. 이러한 사상의 쌍은 성분 별로 합성되고, 항상 항등 사상의 쌍인 항등 쌍 또한 존재할 수 있다. 간단하게 말하자면 <strong>Cat</strong>은 완전한 데카르트 폐쇄 카테고리이기 때문에 모든 카테고리 쌍에 대한 지수 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>를 가진다는 의미이다. 이때 <strong>Cat</strong>의 대상이라는 것은 결국 카테고리를 의미하므로, 결론적으로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 간의 펑터 카테고리라고 말할 수 있다.</p>\n<h2 id=\"104-2-카테고리\" style=\"position:relative;\">10.4 2-카테고리<a href=\"#104-2-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\" aria-label=\"104 2 카테고리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><strong>Cat</strong>을 조금 더 자세히 들여다보자. 앞서 언급한 정의에 따라 <strong>Cat</strong>의 Hom 집합은 펑터들의 집합이다. 하지만 방금 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[C, D]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span></span></span></span></span>의 사례에서 보았듯이 두 대상 사이의 펑터는 단순한 집합 이상으로 더 풍부한 구조를 지니고 있다. 자연 변환을 사상으로 적용하여 카테고리를 형성할 수도 있기 때문이다. 펑터는 <strong>Cat</strong>에서 사상으로 간주되므로, 자연 변환은 사상 간의 사상이라고 할 수 있다.</p>\n<p>이처럼 더 풍부한 구조가 바로 2-카테고리의 예로, 2-카테고리에는 대상과 사상(또는 1-사상) 외에도 사상과 사상 간의 사상인 2-사상 또한 존재할 수 있다.</p>\n<p>즉, <strong>Cat</strong>를 2-카테고리라고 본다면</p>\n<hr>\n<ul>\n<li><strong>대상</strong>: 작은 카테고리들</li>\n<li><strong>1-사상</strong>: 카테고리 간의 펑터</li>\n<li><strong>2-사상</strong>: 펑터 간의 자연 변환</li>\n</ul>\n<hr>\n<p>으로 정의할 수 있다는 것이다.</p>\n<p>그렇다면 이제 우리는 두 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 간의 Hom 집합 대신에, Hom 카테고리인 펑터 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>를 가질 수 있게 된다. 그리고 이 펑터들은 합성될 수도 있다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>의 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mi>D</mi></msup></mrow><annotation encoding=\"application/x-tex\">E^D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span></span></span></span></span></span></span></span>의 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>가 합성되어 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">E^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>의 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>◦</mtext><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">G ◦ F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>를 얻을 수 있는 것처럼 말이다. 또한 각 Hom 카테고리 내에서 자연 변환 또는 2-사상이라고 부르는 수직 합성 또한 가질 수 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c46acab2023857c85a7f9ce461dc859f/c08c5/10.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAGQAAAQUAAAAAAAAAAAAAAAAAAAECAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdsSKLIwP//EABkQAAMAAwAAAAAAAAAAAAAAAAABAhESMf/aAAgBAQABBQJ92MlIUilH/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxAAAwEAAAAAAAAAAAAAAAAAACAx0f/aAAgBAQAGPwKphD//xAAaEAEAAwEBAQAAAAAAAAAAAAABABEhMXFh/9oACAEBAAE/IU6wHYaxH0qBTs9PiQbL2m+pS2P/2gAMAwEAAgADAAAAEJjv/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFhEBAQEAAAAAAAAAAAAAAAAAABEh/9oACAECAQE/EK1//8QAHRABAAEEAwEAAAAAAAAAAAAAAREAIUFRMWFxsf/aAAgBAQABPxAiPAhbfO6lBOMAkt33U0QOlo7qSWQKmYgoiMmkF04uxn2uBujRgr//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"10\" title=\"\" src=\"/static/c46acab2023857c85a7f9ce461dc859f/c08c5/10.jpg\" srcset=\"/static/c46acab2023857c85a7f9ce461dc859f/0913d/10.jpg 160w,\n/static/c46acab2023857c85a7f9ce461dc859f/cb69c/10.jpg 320w,\n/static/c46acab2023857c85a7f9ce461dc859f/c08c5/10.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>이제 이렇게 두 종류의 합성이 있는 2-카테고리에서 이 합성 체계들이 어떻게 상호작용하는지를 알아보도록 하자.</p>\n<p>우선 <strong>Cat</strong>에서 임의로 두 개의 펑터(1-사상)을 선택해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> <span class=\"token operator\">::</span> <span class=\"token constant\">C</span> <span class=\"token operator\">-></span> <span class=\"token constant\">D</span>\n<span class=\"token constant\">G</span> <span class=\"token operator\">::</span> <span class=\"token constant\">D</span> <span class=\"token operator\">-></span> <span class=\"token constant\">E</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그리고 이들의 합성은 아래와 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G</span> ◦ <span class=\"token constant\">F</span> <span class=\"token operator\">::</span> <span class=\"token constant\">C</span> <span class=\"token operator\">-></span> <span class=\"token constant\">E</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>에 작용하는 두 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>도 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token operator\">-></span> <span class=\"token constant\">F'</span>\nβ <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/26542db3b831313d7518b50db28363fd/c08c5/11.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 55.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHbS2AHD//EABoQAQACAwEAAAAAAAAAAAAAAAEAEQIQEiH/2gAIAQEAAQUCWdXBsfZlr//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAAMAAAAAAAAAAAAAAAAAAAEQIP/aAAgBAQAGPwKAv//EABsQAQADAQADAAAAAAAAAAAAAAEAEVEhEEGB/9oACAEBAAE/IWx+RWuPqdyoSl7ALffH/9oADAMBAAIAAwAAABBjz//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/EKf/xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8QTSf/xAAcEAEAAgMAAwAAAAAAAAAAAAABABEhMUEQYeH/2gAIAQEAAT8QxChEaFr8lRZYqO955iOfTpp9kpJsAwwA4+P/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"11\" title=\"\" src=\"/static/26542db3b831313d7518b50db28363fd/c08c5/11.jpg\" srcset=\"/static/26542db3b831313d7518b50db28363fd/0913d/11.jpg 160w,\n/static/26542db3b831313d7518b50db28363fd/cb69c/11.jpg 320w,\n/static/26542db3b831313d7518b50db28363fd/c08c5/11.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>이 쌍에는 수직 합성을 적용할 수가 없다. 왜냐하면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>를 통해 도달한 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 소스가 아니기 때문이다. 사실 이들은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mi>D</mi></msup></mrow><annotation encoding=\"application/x-tex\">E^D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span></span></span></span></span></span></span></span>라는 서로 다른 펑터 카테고리의 멤버이다. 하지만 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>를 통해 도달한 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">G’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">’</span></span></span></span></span>의 소스이기 때문에 이 두 펑터는 합성할 수 있다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>◦</mtext><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">G ◦ F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>’◦</mtext><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">G’◦ F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">’◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>는 무슨 관계일까? <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>를 가지고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>◦</mtext><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">G ◦ F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>’◦</mtext><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">G’◦ F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">’◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>로 향하는 자연 변환을 정의할 수는 있는 것일까? 다이어그램을 통해 전체적인 구조를 한번 살펴보자.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/dc97ff15d263e478db5b98e4123b69ec/c08c5/12.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 72.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMCBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHs4vKLCv/EABkQAQEBAAMAAAAAAAAAAAAAAAEAEQIhMf/aAAgBAQABBQJ9iTY494X/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAADAQAAAAAAAAAAAAAAAAAQICFh/9oACAEBAAY/AtSj/8QAGxABAAICAwAAAAAAAAAAAAAAAQARIWEQMcH/2gAIAQEAAT8hu6uqhbQ0+wAYKhyjk3XF/9oADAMBAAIAAwAAABAbD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAQADAQACAwAAAAAAAAAAAAEAESExQVGBkbH/2gAIAQEAAT8QWxoMKsTvusjDodBS1+bzYBBPaJSLiVT83GS6N6c/IFwftn//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"12\" title=\"\" src=\"/static/dc97ff15d263e478db5b98e4123b69ec/c08c5/12.jpg\" srcset=\"/static/dc97ff15d263e478db5b98e4123b69ec/0913d/12.jpg 160w,\n/static/dc97ff15d263e478db5b98e4123b69ec/cb69c/12.jpg 320w,\n/static/dc97ff15d263e478db5b98e4123b69ec/c08c5/12.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>가장 먼저 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 대상인 <code class=\"language-text\">a</code>에서 부터 출발해보자. 이 대상의 이미지는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 <code class=\"language-text\">F a</code>와 <code class=\"language-text\">F'a</code>라는 두 대상으로 나누어진다. 그리고 이때 이 두 대상을 연결하는 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>의 성분인 사상도 함께 생긴다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">F'</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로 갈 때, 이 두 개의 대상은 네 개의 대상으로 나누어진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 이 네 개의 대상을 서로 연결하는 정사각형, 즉 네 개의 사상 또한 생긴다. 그리고 이 사상들 중 두 개는 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 성분이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">β<span class=\"token hvariable\">_Fa</span>  <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\nβ<span class=\"token hvariable\">_F</span>’<span class=\"token hvariable\">a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그리고 다른 두 개의 사상은 두 펑터에 의한 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">α_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>의 이미지이다. (펑터는 사상 또한 매핑한다는 사실을 기억하자)</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G</span> α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">G'</span>α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>갑자기 사상이 너무 많아져서 조금 복잡해지긴 했지만, 결국 우리의 목표는 이 중 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>◦</mtext><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">G ◦ F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>’◦</mtext><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">G’◦ F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">’◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>를 연결하는 자연 변환의 성분이 될 수 있는 <code class=\"language-text\">G (F a)</code>에서 <code class=\"language-text\">G'(F'a)</code>로 향하는 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>β</mi><mtext>◦</mtext><mi>α</mi><msub><mo stretchy=\"false\">)</mo><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">(β◦α)_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>를 찾는 것이다.</p>\n<p>사실 위 다이어그램을 보면 <code class=\"language-text\">G (F a)</code>에서 <code class=\"language-text\">G'(F'a)</code>로 가는 경로는 총 두 가지이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G'</span>α<span class=\"token hvariable\">_a</span> ◦ β<span class=\"token hvariable\">_Fa</span>\nβ<span class=\"token hvariable\">_F</span>’<span class=\"token hvariable\">a</span> ◦ <span class=\"token constant\">G</span> α<span class=\"token hvariable\">_a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>다행히도 이 두 경로는 같기 때문에 위 다이어그램의 정사각형은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 자연성 정사각형이된다.(다이어그램이 가환한다는 의미이다)</p>\n<p>이렇게 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>◦</mtext><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">G ◦ F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>’◦</mtext><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">G’◦ F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">’◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>로 향하는 자연 변환의 성분을 정의해보았다. 그리고 이 변환의 자연성을 증명하는 것은 귀찮은 과정이기는 하지만 꽤나 간단하게 해결이 가능한 부분이다.</p>\n<p>그리고 이 자연 변환을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 수평 합성이라고 부르는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">β ◦ α <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> ◦ <span class=\"token constant\">F</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G'</span> ◦ <span class=\"token constant\">F'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>앞서 이야기했듯 이 책은 맥레인의 표기법을 따르고 있기 때문에, 수평 합성에는 작은 원(<code class=\"language-text\">◦</code>)을 사용한다. 참고로 다른 곳에서는 경우에 따라 별표(<code class=\"language-text\">*</code>)를 사용하는 경우도 있다.</p>\n<p>카테고리 이론을 공부할 때의 원칙 중 하나는 어떠한 합성이 있을 때마다 이 합성이 속한 카테고리도 찾아내야 한다는 것이다. 앞서 언급했던 자연 변환의 수직 합성은 펑터 카테고리의 일부였다. 그렇다면 수평 합성은 어떤 카테고리에 속하는 것일까?</p>\n<p>이것을 알아내는 방법은 <strong>Cat</strong>을 옆으로 보는 것이다. 자연 변환을 펑터 사이의 화살표가 아닌 카테고리 사이의 화살표로 본다. 그럼 이제 자연 변환은 자신이 변환하는 펑터가 연결하는 두 개의 카테고리 사이에 위치한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d1a5bd4e72d167a0a3646612dd7daa24/c08c5/13.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 28.750000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdu4SD//xAAWEAADAAAAAAAAAAAAAAAAAAAQEiH/2gAIAQEAAQUCrD//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAEDH/2gAIAQEABj8CKv/EABkQAQACAwAAAAAAAAAAAAAAAAEAQRExcf/aAAgBAQABPyHGhqIpSHZ//9oADAMBAAIAAwAAABAAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EEn/xAAbEAEAAgIDAAAAAAAAAAAAAAABABEhUWFxkf/aAAgBAQABPxBVUjRvi9eyuCWwIEMp7n//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"13\" title=\"\" src=\"/static/d1a5bd4e72d167a0a3646612dd7daa24/c08c5/13.jpg\" srcset=\"/static/d1a5bd4e72d167a0a3646612dd7daa24/0913d/13.jpg 160w,\n/static/d1a5bd4e72d167a0a3646612dd7daa24/cb69c/13.jpg 320w,\n/static/d1a5bd4e72d167a0a3646612dd7daa24/c08c5/13.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>이제 <strong>Cat</strong>의 두 대상인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 사이의 사상은 자신들을 연결해주던 펑터들을 연결하는 자연 변환이 되었다. 마찬가지로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로 향하는 펑터들을 연결하는 자연 변환도 있을테니, 이를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로 향하는 새로운 사상으로 간주할 수 있다. 결국 수평 합성은 이러한 관점에서 바라볼 때 사상들의 합성인 것이다.</p>\n<p>또한 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>로 향하는 항등 사상도 있을 것이다. 이때의 항등 사상은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 항등 펑터를 자기 자신으로 매핑하는 항등 자연 변환이다. 수직 합성에서의 항등 자연 변환은 모든 자연 변환의 수직 합성에 대해서 항등 역할을 할 수 있지만, 수평 합성에서는 항상 그렇지만은 않다는 것을 기억해두자.</p>\n<p>마지막으로 두 합성은 교환 법칙을 만족한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span>β' ⋅ α'<span class=\"token punctuation\">)</span> ◦ <span class=\"token punctuation\">(</span>β ⋅ α<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>β' ◦ β<span class=\"token punctuation\">)</span> ⋅ <span class=\"token punctuation\">(</span>α' ◦ α<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사운더스 맥레인(Saunders Mac Lane)의 말을 인용하자면 독자들은 이 사실을 증명하기 위해 명확한 다이어그램을 작성하는 것을 즐기게 될지도 모른다고 한다.</p>\n<p>나중에 유용하게 사용할 수 있는 표기법이 하나 더 있다. <strong>Cat</strong>을 옆에서 바라보겠다는 이 해석에서 어떤 대상에서 다른 대상으로 향하는 방법에는 펑터를 사용하는 방법과 자연 변환을 사용하는 두 가지 방법이 있었다. 이때 이 펑터 화살표를 펑터에 작용하는 특수한 종류의 자연 변환인 항등 자연 변환으로 재해석해볼 수도 있다. 그래서 종종 아래와 같은 표기법을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> ◦ α</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로 향하는 펑터이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 향하는 두 펑터 사이의 자연 변환이다. 펑터는 자연 변환과 합성할 수 없기 때문에, 이것은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>가 작용한 이후 항등 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mn>1</mn><mi>F</mi></msub></mrow><annotation encoding=\"application/x-tex\">1_F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7944em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>가 작용하는 수평 합성으로 해석하게된다.</p>\n<p>이와 마찬가지로 아래 표기는 항등 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mn>1</mn><mi>F</mi></msub></mrow><annotation encoding=\"application/x-tex\">1_F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7944em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>의 작용 이후 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>가 작용하는 것으로 해석하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α ◦ <span class=\"token constant\">F</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2 id=\"105-결론\" style=\"position:relative;\">10.5 결론<a href=\"#105-%EA%B2%B0%EB%A1%A0\" aria-label=\"105 결론 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇게 이 책의 첫 번째 파트를 마쳤다. 이제 우리는 카테고리 이론의 기본적인 용어들을 배웠으며, 대상과 카테고리를 명사로 생각하고 사상, 펑터 그리고 자연 변환을 동사로 생각할 수 있는 역량을 얻었다.</p>\n<p>사상은 대상을 연결하고 펑터는 카테고리를 연결하며 자연 변환은 펑터를 연결하는 것처럼 말이다.</p>\n<p>하지만 앞서 살펴보았듯이 한 수준의 추상화 단계에서는 동사로 보이는 것이 다음 수준에서는 대상이 되기도 한다. 마치 사상의 집합이 함수 대상이 되었던 것처럼 말이다. 그러면 이제 이 대상은 다시 다른 사상의 출발점이나 목표지점이 될 수 있게 된다. 이것이 우리가 알고있는 고차 함수(Higher Order Function)의 아이디어였다.</p>\n<p>펑터는 대상을 대상으로 매핑하기 때문에 이를 타입 생성자 또는 매개변수적 타입으로 사용할 수 있다. 또한 펑터는 사상도 매핑하는데, 이것이 바로 고차 함수인 <code class=\"language-text\">fmap</code>이다. <code class=\"language-text\">Const</code>, 곱, 쌍대곱과 같은 간단한 펑터들은 다양한 대수적 데이터 타입을 생성하는데 사용할 수도 있다. 함수 타입 또한 공변 펑터적인 성질과 반공변 펑터적인 성질을 모두 가지고 있으므로 대수적 데이터 타입을 확장하는데 사용할 수 있다.</p>\n<p>펑터는 펑터 카테고리에서 대상으로 간주될 수도 있다. 따라서 펑터는 자연 변환의 출발점과 목표가 되며, 자연 변환은 다형성 함수의 특별한 타입이라고 볼 수 있다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240601-category-theory-for-programmers-10-natural-transformations","path":"/2024/06/01/category-theory-for-programmers-10-natural-transformations/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 10. 자연 변환","subTitle":null,"date":"Jun 01, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"8c27f197-f80b-5745-8160-8b77ad6878d2","tableOfContents":"<ul>\n<li>\n<p><a href=\"#91-%EB%B3%B4%ED%8E%B8%EC%A0%81-%EA%B5%AC%EC%84%B1universal-construction\">9.1 보편적 구성(Universal Construction)</a></p>\n</li>\n<li>\n<p><a href=\"#92-%EC%BB%A4%EB%A7%81currying\">9.2 커링(Currying)</a></p>\n</li>\n<li>\n<p><a href=\"#93-%EC%A7%80%EC%88%98exponentials\">9.3 지수(Exponentials)</a></p>\n</li>\n<li>\n<p><a href=\"#94-%EB%8D%B0%EC%B9%B4%EB%A5%B4%ED%8A%B8-%EB%8B%AB%ED%9E%8C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACcartesian-closed-categories\">9.4 데카르트 닫힌 카테고리(Cartesian Closed Categories)</a></p>\n</li>\n<li>\n<p><a href=\"#95-%EC%A7%80%EC%88%98%EC%99%80-%EB%8C%80%EC%88%98%EC%A0%81-%EC%9E%90%EB%A3%8C%ED%98%95exponentials-and-algebraic-data-types\">9.5 지수와 대수적 자료형(Exponentials and Algebraic Data Types)</a></p>\n<ul>\n<li><a href=\"#951-0%EC%8A%B9\">9.5.1 0승</a></li>\n<li><a href=\"#952-1%EC%9D%98-%EC%A7%80%EC%88%98\">9.5.2 1의 지수</a></li>\n<li><a href=\"#953-1%EC%8A%B9\">9.5.3 1승</a></li>\n<li><a href=\"#954-%EC%A7%80%EC%88%98%EC%9D%98-%ED%95%A9\">9.5.4 지수의 합</a></li>\n<li><a href=\"#955-%EC%A7%80%EC%88%98%EC%9D%98-%EC%A7%80%EC%88%98\">9.5.5 지수의 지수</a></li>\n<li><a href=\"#956-%EA%B3%B1%EC%9D%98-%EC%A7%80%EC%88%98\">9.5.6 곱의 지수</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#96-%EC%BB%A4%EB%A6%AC-%ED%95%98%EC%9B%8C%EB%93%9C-%EB%8F%99%ED%98%95%EC%82%AC%EC%83%81curry-howard-isomorphism\">9.6 커리-하워드 동형사상(Curry-Howard Isomorphism)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></p>\n</li>\n</ul>","excerpt":"지금까지는 함수 타입의 의미를 간단하게만 설명해왔다. 하지만 조금 더 자세히 들여다보면 함수 타입은 다른 타입과는 약간 다른 특성을 가지고 있다. 예를 들어  타입은 그냥 정수들의 집합, 그리고  타입은 두 개의 원소로 이루어진 집합일 뿐이다. 그러나 함수 타입 은 대상 와  사이에 존재하는 모든 사상들의 집합이다. 어떤 카테고리에서 두 객체 사이의 존재하는 모든 사상들의 집합은 Hom 집합이라고 한다. 그리고 Hom 집합 또한 결국 집합이기 때문에 카테고리 Set(모든 집합의 카테고리)에서는 Hom 집합 또한 Set에 포함된 대…","html":"<p>지금까지는 함수 타입의 의미를 간단하게만 설명해왔다. 하지만 조금 더 자세히 들여다보면 함수 타입은 다른 타입과는 약간 다른 특성을 가지고 있다.</p>\n<p>예를 들어 <code class=\"language-text\">Integer</code> 타입은 그냥 정수들의 집합, 그리고 <code class=\"language-text\">Bool</code> 타입은 두 개의 원소로 이루어진 집합일 뿐이다. 그러나 함수 타입 <code class=\"language-text\">a -> b</code>은 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 사이에 존재하는 모든 사상들의 집합이다. 어떤 카테고리에서 두 객체 사이의 존재하는 모든 사상들의 집합은 Hom 집합이라고 한다. 그리고 Hom 집합 또한 결국 집합이기 때문에 카테고리 <strong>Set</strong>(모든 집합의 카테고리)에서는 Hom 집합 또한 <strong>Set</strong>에 포함된 대상이다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cb189cb187003cfbbbefe5161aefba06/bba1f/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 111.87500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAWABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAIDAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9rlzGiVVBGgr/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAERAhAS/9oACAEBAAEFAta8t6gmSijENCzOf//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CH//EABgQAQEBAQEAAAAAAAAAAAAAAAERAEEx/9oACAEBAAE/ISCujuBLoqg51nMLqeM3Bgm//9oADAMBAAIAAwAAABBkx7z/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAVEQEBAAAAAAAAAAAAAAAAAAAgIf/aAAgBAgEBPxCj/8QAHBABAAMBAAMBAAAAAAAAAAAAAQARITFBUWGB/9oACAEBAAE/EHBacrKPs2iv7AQSOpgvSC1FKvd/YJXxcQOh7DtgvtEAAcJ//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/cb189cb187003cfbbbefe5161aefba06/c08c5/1.jpg\" srcset=\"/static/cb189cb187003cfbbbefe5161aefba06/0913d/1.jpg 160w,\n/static/cb189cb187003cfbbbefe5161aefba06/cb69c/1.jpg 320w,\n/static/cb189cb187003cfbbbefe5161aefba06/c08c5/1.jpg 640w,\n/static/cb189cb187003cfbbbefe5161aefba06/bba1f/1.jpg 840w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>Hom 집합도 결국 집합이기 때문에 Set에 포함된 대상이다.</small>\n  <br>\n  <br>\n</center>\n<p><strong>Set</strong>이 아닌 다른 카테고리에서는 Hom 집합이 카테고리 외부에 있는 경우도 있다. 이런 경우 외부(External) Hom 집합이라고 한다.</p>\n<p>이것이 바로 함수 타입을 다른 타입보다 특별하게 만드는 카테고리 <strong>Set</strong>의 자기 참조적인 성격이다. 이런 카테고리에서는 Hom 집합을 나타내는 대상을 구성할 수 있는 방법이 존재하며, 이러한 대상을 내부(Internal) Hom 집합이라고 한다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/42654a7df0869c5e40df37dc0c04c694/232db/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 117.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAYABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHstILUJzI2Ff/EABoQAQACAwEAAAAAAAAAAAAAAAEAAhARIRL/2gAIAQEAAQUCtfyttQecgjhlaax//8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQAGPwIf/8QAHRAAAgIBBQAAAAAAAAAAAAAAAAERITEQQVFhof/aAAgBAQABPyGIVueBez0cw7dmJMCyibp//9oADAMBAAIAAwAAABCUyPz/xAAWEQEBAQAAAAAAAAAAAAAAAAAQEUH/2gAIAQMBAT8Qwp//xAAWEQEBAQAAAAAAAAAAAAAAAAAREAH/2gAIAQIBAT8Qhiz/xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhMRBRcYH/2gAIAQEAAT8QBQJ/EEbTi8QTUbht34I0jSmnBuACjUWo6SXKG6zx/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/42654a7df0869c5e40df37dc0c04c694/c08c5/2.jpg\" srcset=\"/static/42654a7df0869c5e40df37dc0c04c694/0913d/2.jpg 160w,\n/static/42654a7df0869c5e40df37dc0c04c694/cb69c/2.jpg 320w,\n/static/42654a7df0869c5e40df37dc0c04c694/c08c5/2.jpg 640w,\n/static/42654a7df0869c5e40df37dc0c04c694/232db/2.jpg 819w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>카테고리 C의 Hom 집합은 외부 Hom 집합이다.</small>\n  <br>\n  <br>\n</center>\n<h2 id=\"91-보편적-구성universal-construction\" style=\"position:relative;\">9.1 보편적 구성(Universal Construction)<a href=\"#91-%EB%B3%B4%ED%8E%B8%EC%A0%81-%EA%B5%AC%EC%84%B1universal-construction\" aria-label=\"91 보편적 구성universal construction permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 이제 함수 타입이 집합이라는 사실은 잠시 잊고, 함수 타입을 일반화하여 내부 Hom 집합이라고 생각해서 처음부터 구성해보도록 하자. 일반적으로는 <code class=\"language-text\">Set</code> 카테고리가 이 구성에 대한 단서를 주겠지만, 여기서는 집합의 특성에 의존하지 않고 생각해볼 것이다. 이런 과정을 통해 하나의 구성이 다른 카테고리에 자동으로 적용될 수 있도록 일반화해볼 수 있다.</p>\n<p>함수 타입은 인수 타입과 결과 타입과의 관계로 인해 복합적인 타입으로 간주된다. 이미 우리는 <a href=\"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts/\">곱 타입과 합 타입</a>이라는 대상 간의 관계를 포함하는 복합적인 타입들을 정의하기 위한 보편적 구성(Universal Construction)에 대해서 배웠던 적이 있다. 함수 타입을 정의하는 데도 동일한 방법을 사용해볼 수 있다.</p>\n<p>함수 타입을 정의하기 위해서는 구성하려는 함수 타입, 인수 타입, 결과 타입을 모두 포함하는 패턴이 필요하다.</p>\n<p>이 세 가지 타입을 연결하는 명확한 패턴은 함수 적용(Function application) 또는 평가(Evaluation)이라고 불린다. 만약 함수 타입의 후보인 대상을 <code class=\"language-text\">z</code>라고 하고 인수 타입인 대상을 <code class=\"language-text\">a</code>라고 할 때, 적용(Application)은 이 쌍을 결과 타입인 대상 <code class=\"language-text\">b</code>로 매핑하는 행위이다. 즉, 우리에게는 총 세 가지 대상이 있으며, 이 중 인수 타입과 결과 타입 두 가지는 고정되어있는 것이다.</p>\n<p>우리는 매핑인 적용도 가지고 있다. 어떻게 하면 이 매핑을 이 패턴에 통합할 수 있을까? 만약 우리가 대상 내부를 들여다볼 수 있다면, 집합 <code class=\"language-text\">z</code>의 원소인 함수 <code class=\"language-text\">f</code>와 집합 <code class=\"language-text\">a</code>의 원소인 인수 <code class=\"language-text\">x</code>를 짝지어 집합 <code class=\"language-text\">b</code>의 원소인 <code class=\"language-text\">f x</code>로 매핑할 수 있게 된다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8d0e9053a062a17fd43fa807d4d4d315/a847c/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAMBAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7NJoswoDYH//xAAYEAEAAwEAAAAAAAAAAAAAAAABAAIQIv/aAAgBAQABBQJt1lll1hHf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGBAAAgMAAAAAAAAAAAAAAAAAABAgISL/2gAIAQEABj8CdGY//8QAGRABAQEBAQEAAAAAAAAAAAAAAREAECEx/9oACAEBAAE/IWATzSYbgwGhI93xwHP/2gAMAwEAAgADAAAAEHQPAP/EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/ECP/xAAVEQEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAgEBPxBGP//EABwQAQACAgMBAAAAAAAAAAAAAAEAESExEEFhUf/aAAgBAQABPxC2pRkPdMtosqe9xVJ+p50wLo7JYQuaUuagEyECtHH/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/8d0e9053a062a17fd43fa807d4d4d315/c08c5/3.jpg\" srcset=\"/static/8d0e9053a062a17fd43fa807d4d4d315/0913d/3.jpg 160w,\n/static/8d0e9053a062a17fd43fa807d4d4d315/cb69c/3.jpg 320w,\n/static/8d0e9053a062a17fd43fa807d4d4d315/c08c5/3.jpg 640w,\n/static/8d0e9053a062a17fd43fa807d4d4d315/a847c/3.jpg 846w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>함수 집합 z에서 함수 f를 선택하고, 인수 타입 a의 집합에서 하나의 인수 x를 선택한다.<br>그러면 이제 집합 b에서 원소 f x를 얻을 수 있게된다.</small>\n  <br>\n  <br>\n</center>\n<p>그러나 이렇게 하나의 쌍인 <code class=\"language-text\">(f, x)</code>를 다루는 것보다는 함수 타입 <code class=\"language-text\">z</code>와 인수 타입 <code class=\"language-text\">a</code>의 전체적인 곱에 대해서 이야기하는 것이 더 일반화된 개념일 것이다. 곱 <code class=\"language-text\">z×a</code> 또한 하나의 대상이며, 이 대상에서 <code class=\"language-text\">b</code>로의 화살표인 우리의 적용 변형으로 <code class=\"language-text\">g</code>를 선택할 수 있다. <strong>Set</strong>에서는 <code class=\"language-text\">g</code>가 모든 쌍 <code class=\"language-text\">(f, x)</code>를 <code class=\"language-text\">f x</code>로 매핑하는 함수가 될 것이다.</p>\n<p>두 대상 <code class=\"language-text\">z</code>와 <code class=\"language-text\">a</code>의 곱이 사상 <code class=\"language-text\">g</code>에 의해 다른 대상 <code class=\"language-text\">b</code>로 연결되는, 이것이 바로 패턴이다.</p>\n<p>정말 이 패턴이 보편적 구성을 통해 함수 타입을 명확하게 정의할 수 있는 것일까? 사실 모든 카테고리에 대해서 생각해본다면 그렇지 않을 수도 있다. 하지만 우리가 지금 다루고자 하는 카테고리에 대해서는 충분하다.</p>\n<p>그렇다면 또 다른 질문을 해보자. 과연 우리는 곱을 먼저 정의하지 않고도 함수 대상을 정의할 수 있을까? 모든 쌍의 대상에 대해 곱이 없는 카테고리나 모든 쌍의 곱이 존재하지 않는 카테고리도 있지 않은가? 정답은 “아니다”이다. 곱 타입이 없다면 함수 타입도 존재할 수 없다. 이에 대한 내용은 추후 지수(Exponentials)에 대해 설명하며 다시 다루도록 하겠다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/4848023ae6caa38a3db6fb74b2138af9/c222a/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 57.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAexqolQ//8QAGhAAAgIDAAAAAAAAAAAAAAAAAAECERASIf/aAAgBAQABBQLZnSLtON5//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAHRAAAgIBBQAAAAAAAAAAAAAAAAERITEQQVFhkf/aAAgBAQABPyFsnpwco2wMsTQjOfRUtP/aAAwDAQACAAMAAAAQ08//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEBAAICAwAAAAAAAAAAAAABEQAhEDFRgbH/2gAIAQEAAT8QChg6Q7mWCE9lyiUGbJca3nwR8wAB0a4//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/4848023ae6caa38a3db6fb74b2138af9/c08c5/4.jpg\" srcset=\"/static/4848023ae6caa38a3db6fb74b2138af9/0913d/4.jpg 160w,\n/static/4848023ae6caa38a3db6fb74b2138af9/cb69c/4.jpg 320w,\n/static/4848023ae6caa38a3db6fb74b2138af9/c08c5/4.jpg 640w,\n/static/4848023ae6caa38a3db6fb74b2138af9/c222a/4.jpg 794w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이 그림이 바로 보편적 구성의 시작점인 대상과 사상의 패턴이다.</small>\n</center>\n<p>한번 보편적 구성에 대해 검토해보자. 우선 대상과 사상의 패턴에서부터 시작할 것이다. 물론 그저 대상과 사상의 패턴이라고만 하면 굉장히 많은 결과가 매칭될 것이기 때문에 이대로는 상당히 부정확한 쿼리라고 할 수 있다.</p>\n<p><strong>Set</strong>에서는 거의 모든 것이 서로 연결되어있다. 어떤 대상 <code class=\"language-text\">z</code>와 대상 <code class=\"language-text\">a</code>의 곱을 형성할 수도 있으며, 이 곱에서 <code class=\"language-text\">b</code>로의 함수도 존재할 수 있다. (단, <code class=\"language-text\">b</code>가 빈 집합일 경우는 제외한다.)</p>\n<p>이제 이 패턴의 결과들에 대한 순위를 매긴다는 비밀무기를 꺼내볼 차례이다. 일반적으로 후보 대상들 사이에는 이 구성을 어떤 방식이로든 분해할 수 있는 고유한 매핑이 있어야 한다.</p>\n<p>필자는 <code class=\"language-text\">z</code>와 <code class=\"language-text\">z×a</code>에서 <code class=\"language-text\">b</code>로 향하는 사상 <code class=\"language-text\">g</code>가 <code class=\"language-text\">z'</code>와 이에 적용되는 사상 <code class=\"language-text\">g’</code>보다 우수하다고 결정할 것이다. 그리고 만약 이 결정이 참이라면 <code class=\"language-text\">z'</code>에서 <code class=\"language-text\">z</code>로 향하는 유일한 사상 <code class=\"language-text\">h</code>이 존재해야 할 것이다. 그리고 이 사상은 <code class=\"language-text\">g'</code>를 적용한 결과와 <code class=\"language-text\">g</code>를 적용한 결과가 동일하다는 것 또한 보장해야한다. (잘 이해되지 않는다면 아래 그림을 보면서 이 문장을 읽어보자.)</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d7e642209529d3ac993be63af211510a/d4b53/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdqkqDCh/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAERAhD/2gAIAQEAAQUCd7oQlD//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAIDH/2gAIAQEABj8CWn//xAAcEAEAAgEFAAAAAAAAAAAAAAABABFBECFRYYH/2gAIAQEAAT8hVniDsaF78gaLcRBlP//aAAwDAQACAAMAAAAQs8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAWEQADAAAAAAAAAAAAAAAAAAABEDH/2gAIAQIBAT8QEX//xAAaEAEBAAMBAQAAAAAAAAAAAAABEQAhMRCh/9oACAEBAAE/EGiUKRHuLsOnb45ey0LvzFWONTdxwK2prmf/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/d7e642209529d3ac993be63af211510a/c08c5/5.jpg\" srcset=\"/static/d7e642209529d3ac993be63af211510a/0913d/5.jpg 160w,\n/static/d7e642209529d3ac993be63af211510a/cb69c/5.jpg 320w,\n/static/d7e642209529d3ac993be63af211510a/c08c5/5.jpg 640w,\n/static/d7e642209529d3ac993be63af211510a/d4b53/5.jpg 853w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>함수 대상에 대한 후보들 간의 순위를 결정한다.</small>\n</center>\n<p>여기가 조금 어려운 부분인데, 이게 바로 필자가 이 보편적 구성에 대한 정의를 계속 질질 끌고 있던 이유이다. 사상 <code class=\"language-text\">h :: z'-> z</code>가 주어졌을 때 우리는 <code class=\"language-text\">z’</code>와 <code class=\"language-text\">z</code>가 모두 <code class=\"language-text\">a</code>와 연결되어있는 다이어그램을 닫기를 원한다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>다이어그램을 닫는다는 이야기가 이해하기 어렵다면, 자료구조 그래프를 떠올려보면 된다. 여기서 <code class=\"language-text\">z’</code>와 <code class=\"language-text\">z</code>가 모두 연결되어있는 다이어그램을 닫고 싶다는 의미는, <code class=\"language-text\">z→a</code>, <code class=\"language-text\">z’→a</code>, <code class=\"language-text\">z’→z</code>처럼 연결되어있고 다른 대상들과는 이어지지 않은 그래프를 만들고 싶다는 의미이다.</p>\n</blockquote>\n<p>이를 위해 필요한 것은 <code class=\"language-text\">z’</code>에서 <code class=\"language-text\">z</code>로 향하는 매핑 <code class=\"language-text\">h</code>가 주어졌을 때, 이를 이용해서 <code class=\"language-text\">z'×a</code>에서 <code class=\"language-text\">z×a</code>로의 매핑을 얻어내는 것이다. 앞서 <a href=\"/2024/04/02/category-theory-for-programmers-8-functoriality/\">곱의 함수적인 특징</a>에 대해 논의했었으니, 이제 이 과정에 대해 이해할 수 있을 것이다.</p>\n<p>곱 자체는 펑터, 정확하게는 엔도 이항 펑터이기 때문에 쌍에 대한 사상을 리프팅할 수 있다. 다른 말로 하면 우리는 대상의 곱 뿐만 아니라 사상의 곱도 정의할 수 있다는 것이다.</p>\n<p>이를 리프팅하기 위해 곱 <code class=\"language-text\">z'×a</code>의 두 번째 구성 요소인 <code class=\"language-text\">a</code>에는 아무런 영향을 끼치지 않아야 하므로, <code class=\"language-text\">a</code>에 대한 항등사상인 <code class=\"language-text\">id</code>를 사용하여 사상의 쌍 <code class=\"language-text\">(h, id)</code>를 리프팅할 것이다.</p>\n<p><code class=\"language-text\">g’</code>를 <code class=\"language-text\">g</code>가 포함된 식으로 인수 분해하는 방법은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">h</span> × <span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서의 핵심은 곱이 사상에 대해서 어떻게 작용하고 있는지를 보는 것이다.</p>\n<p>보편적 구성의 세 번째 파트는 보편적으로 가장 좋은 대상을 선택하는 것이었다. 필자는 이 대상을 <code class=\"language-text\">a ⇒ b</code>라고 부를 것이다. (참고로 이건 어떤 대상에 대한 상징적인 이름이며, Haskell 타입 클래스 제약과는 관련없는 네이밍이다. 추후에 조금 더 다양한 방법으로 이름을 지을 수 있는 방법에 대해 논의해보겠다.)</p>\n<p><code class=\"language-text\">a ⇒ b</code>라는 대상은 <code class=\"language-text\">(a ⇒ b) × a</code> 에서 <code class=\"language-text\">b</code>로 향하는 사상인 <code class=\"language-text\">eval</code>이라는 적용을 가지고 있다. 만약 다른 함수 대상 후보로부터 출발하는 사상 <code class=\"language-text\">g</code>가 <code class=\"language-text\">eval</code>을 포함한 식으로 분해되어 이 대상에 유일하게 매핑될 수 있다면, 대상 <code class=\"language-text\">a ⇒ b</code>가 가장 적합한 후보라고 할 수 있을 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/36c0f5325a8dadf4bf7dcae580413720/edf8d/6.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 76.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHt1CNUq//EABkQAAIDAQAAAAAAAAAAAAAAAAABAhExIf/aAAgBAQABBQJ6sJIUeUf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAQICH/2gAIAQEABj8CSj//xAAcEAACAgIDAAAAAAAAAAAAAAABEQAhUZEQMUH/2gAIAQEAAT8hZrqMOBSznE6j7gEenc//2gAMAwEAAgADAAAAEBsP/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQMBAT8Qh//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ECf/xAAcEAEBAAMAAwEAAAAAAAAAAAABEQAhMUFRscH/2gAIAQEAAT8QDr4QDtxEsS++GDeZuhNAI/cdQVdcfMuza3H/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"\" src=\"/static/36c0f5325a8dadf4bf7dcae580413720/c08c5/6.jpg\" srcset=\"/static/36c0f5325a8dadf4bf7dcae580413720/0913d/6.jpg 160w,\n/static/36c0f5325a8dadf4bf7dcae580413720/cb69c/6.jpg 320w,\n/static/36c0f5325a8dadf4bf7dcae580413720/c08c5/6.jpg 640w,\n/static/36c0f5325a8dadf4bf7dcae580413720/edf8d/6.jpg 929w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이것이 보편적 구성을 통한 함수 대상의 정의이다. 위 그림과 동일한 다이어그램이지만 이제 대상 a ⇒ b가 가장 보편적이게 되었다.</small>\n</center>\n<p>한번 정리해보자.</p>\n<p><code class=\"language-text\">a</code>에서 <code class=\"language-text\">b</code>로 향하는 <strong>함수 대상</strong>은 대상 <code class=\"language-text\">a ⇒ b</code>와 사상 <code class=\"language-text\">eval :: ((a ⇒ b) × a) -> b</code> 으로 정의된다. 만약 임의의 다른 대상 <code class=\"language-text\">z × a</code>에서 <code class=\"language-text\">b</code>로 향하는 사상 <code class=\"language-text\">g :: z × a -> b</code>가 주어진다면, <code class=\"language-text\">z</code>에서 <code class=\"language-text\">a ⇒ b</code>로 향하는 유일한 사상 <code class=\"language-text\">h :: z -> (a ⇒ b)</code>이 존재해야하고, 최종적으로 <code class=\"language-text\">g</code>는 <code class=\"language-text\">eval</code>을 포함한 식으로 분해될 수 있어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">eval</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">h</span> × <span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>물론 모든 카테고리에서 반드시 임의의 대상의 쌍 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>에 대해 대상 <code class=\"language-text\">a ⇒ b</code>가 반드시 존재할 것이라는 보장은 없다. 하지만 최소한 <strong>Set</strong>에서만큼은 항상 존재한다. 게다가 이 대상은 Set의 Hom 집합인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Set(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>와도 동형이다.</p>\n<h2 id=\"92-커링currying\" style=\"position:relative;\">9.2 커링(Currying)<a href=\"#92-%EC%BB%A4%EB%A7%81currying\" aria-label=\"92 커링currying permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수 대상에 대한 후보를 다시 한번 살펴보자. 그러나 이번에는 사상 <code class=\"language-text\">g</code>를 두 변수 <code class=\"language-text\">z</code>와 <code class=\"language-text\">a</code>에 대한 함수로 생각해볼 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">z</span> × <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>대상의 곱으로부터 출발한 사상은 두 개의 변수를 가진 함수와 유사한 형태를 가지고 있다. <strong>Set</strong>에서 <code class=\"language-text\">g</code>는 집합 <code class=\"language-text\">z</code>과 집합 <code class=\"language-text\">a</code>에서 값을 하나씩 가져와 구성한 쌍에서 출발하게 될 것이다.</p>\n<p>그리고 함수 <code class=\"language-text\">g</code>가 가진 보편적인 속성에 따라 각각의 <code class=\"language-text\">g</code>에 대해 <code class=\"language-text\">z</code>를 함수 대상 <code class=\"language-text\">a ⇒ b</code>로 매핑하는 유일한 사상 <code class=\"language-text\">h</code> 또한 존재한다는 것을 떠올려볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">h</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">z</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><strong>Set</strong>에서는 단순히 <code class=\"language-text\">h</code>가 타입이 <code class=\"language-text\">z</code>인 변수를 하나 받아 <code class=\"language-text\">a</code>에서 <code class=\"language-text\">b</code>로 향하는 함수를 반환하는 함수임을 의미한다. 이러한 정의는 <code class=\"language-text\">h</code>를 고차함수(Higher ordered function)로 만든다.</p>\n<p>따라서 보편적 구성은 이변수 함수와 함수를 반환하는 일변수 함수 간의 일대일 대응을 설정한다. 이 대응은 커링(Currying)이라고 불리며, <code class=\"language-text\">h</code>는 <code class=\"language-text\">g</code>의 커링된(Curried) 버전이라고 한다.</p>\n<p>이처럼 어떤 <code class=\"language-text\">g</code>가 주어졌을때 유일한 <code class=\"language-text\">h</code>가 존재하고, 어떤 <code class=\"language-text\">h</code>가 주어질 때도 아래의 공식을 이용하여 이변수 함수인 <code class=\"language-text\">g</code>를 다시 생성할 수 있기 때문에 일대일 대응이라고 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">eval</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">h</span> × <span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 함수 <code class=\"language-text\">g</code>는 <code class=\"language-text\">h</code>의 커링되지 않은(Uncurried) 버전이라고 할 수 있다. 사실 커링은 함수가 함수를 반환하는 Haskell의 구문만으로도 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이런 문법은 보통 아래와 같이 괄호가 제거된 시그너치를 통해 이변수 함수로 해석된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이러한 해석은 다인수 함수를 정의할 때 명확하게 확인해볼 수 있다. 예를 들어 아래와 같은 함수처럼 말이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">catstr</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">catstr</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">s'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 함수는 하나의 인수를 받아 다시 함수를 반환하는 형태로도 작성할 수 있다. 만약 람다로 표현하면 다음과 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">catstr'</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">s'</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 두 정의는 동등하며, 두 정의 중 어떤 것을 사용하든 하나의 인수에 대해 부분 적용되어 아래와 같이 하나의 인수를 받은 함수를 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">greet</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">greet</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">catstr</span> <span class=\"token string\">\"Hello \"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>엄밀히 말하자면 이변수 함수는 곱 타입인 쌍을 받는 함수이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 두 개의 표현 간의 변환은 간단하다. 이미 예상했겠지만 이러한 변환을 수행하는 두 개의 고차함수는 <code class=\"language-text\">curry</code>와 <code class=\"language-text\">uncurry</code>로 불린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">curry</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">curry</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">uncurry</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">uncurry</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">curry</code>가 함수 대상의 보편적 구성을 위한 인수분해(factorization)라는 점에 주목하자. 이 점은 아래와 같은 형태로 다시 작성해보면 더 명확하게 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorizer</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">factorizer</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>다시 한번 짚고 넘어가자면 <code class=\"language-text\">factorizer</code>라는 인수분해 행위는 후보로부터 분해 함수를 생성한다.</p>\n<p>C++과 같이 함수형 언어가 아닌 언어에서도 커링이 가능하기는 하지만 일이 조금 복잡해진다. C++에서의 다인수 함수는 Haskell에서 튜플을 받는 함수에 해당한다고 볼 수 있다. (여기서 더 혼란스러운 점은 C++에서 명시적으로 <code class=\"language-text\">std::tuple</code>을 받는 함수, 가변 인수 함수, 초기화 리스트를 받는 함수를 정의할 수 있다는 점이다.)</p>\n<p>C++ 함수를 부분 적용하려면 템플릿 <code class=\"language-text\">std::bind</code>를 사용하면 된다. 예를 들어 아래와 같이 두 개의 문자열을 받는 함수가 있다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>string <span class=\"token function\">catstr</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>string s1<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>string s2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> s1 <span class=\"token operator\">+</span> s2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그럼 이 함수와 <code class=\"language-text\">std::bind</code>를 사용하여 하나의 문자열을 받는 함수를 정의해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token double-colon punctuation\">::</span>placeholders<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">auto</span> greet <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>catstr<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Hello \"</span><span class=\"token punctuation\">,</span> _1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Haskell Curry\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Scala는 C++이나 Java에 비하면 함수형 프로그래밍에 더 가깝긴 하지만, 사실은 애매한 어딘가에 위치하고 있다. 만약 함수가 부분 적용되도록 작성하려면 아래처럼 여러 인수의 목록으로 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> catstr<span class=\"token punctuation\">(</span>s1<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>s2<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> s2</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>물론 이 코드는 이 함수가 확실히 부분 적용될 것이라는 것을 가정하기 때문에 프로그래머의 예지력에 의존하고 있지만 말이다.</p>\n<h2 id=\"93-지수exponentials\" style=\"position:relative;\">9.3 지수(Exponentials)<a href=\"#93-%EC%A7%80%EC%88%98exponentials\" aria-label=\"93 지수exponentials permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>수학 논문에서 함수 대상 또는 두 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 사이의 내부 Hom 대상은 종종 지수(Exponential)로 불리며 <code class=\"language-text\">ba</code>라고 표기된다. 처음에는 이 표기법이 조금 어색해보일 수 있지만, 함수와 곱의 관계를 생각해보면 그렇게 이상한 것도 아니다. 이미 내부 Hom 대상의 보편적 구성에서 곱이 필요하다는 것을 한 차례 확인했지만, 사실 이 둘 간의 연결은 더 심오하다.</p>\n<p>이 연결은 <code class=\"language-text\">Bool</code>, <code class=\"language-text\">Char</code>, <code class=\"language-text\">Int</code>, <code class=\"language-text\">Double</code>과 같이 유한한 값을 가지는 집합 간의 함수를 고려해볼 때 제대로 확인해볼 수 있다. 이러한 함수들은 원론적으로 완전히 메모아이징(Memoizing)될 수 있거나 데이터 구조로 변환되어 조회될 수도 있다. 이것이 바로 사상으로써의 함수와 대상으로써의 함수 타입 간 동등성의 본질이다.</p>\n<p>예를 들어 <code class=\"language-text\">Bool</code>에서의 순수 함수는 <code class=\"language-text\">False</code>에 해당하는 값과 <code class=\"language-text\">True</code>에 해당하는 값의 쌍에 의해 완전히 특정화된다. <code class=\"language-text\">Bool</code>에서 <code class=\"language-text\">Int</code>로 향하는 모든 함수의 집합은 모든 <code class=\"language-text\">Int</code> 쌍들의 집합이다. 이것은 곱 <code class=\"language-text\">Int × Int</code>, 조금 더 창의적으로 표기해보자면 <code class=\"language-text\">Int2</code>와 동일하다.</p>\n<p>다른 예시로 C++의 타입인 <code class=\"language-text\">char</code>를 한번 살펴보자. 이 타입은 총 256개의 값을 포함하고 있다.</p>\n<p>C++ 표준 라이브러리의 <code class=\"language-text\">isupper</code>, <code class=\"language-text\">isspace</code>와 같은 일부 함수들은 테이블 조회를 사용하여 구현되며, 이 테이블은 256개의 부울 값들의 튜플과 동등하다. 튜플은 곱 타입이므로 우리는 <code class=\"language-text\">bool × bool × bool × ... × bool</code>과 같은 256개의 부울의 곱을 떠올려볼 수 있다.</p>\n<p>그리고 우리는 이렇게 반복적인 곱이 곧 지수(Exponential)을 정의한다는 사실을 알고 있다. 만약 <code class=\"language-text\">bool</code>을 <code class=\"language-text\">char</code> 타입이 가진 값의 개수인 256번만큼 곱한다면, <code class=\"language-text\">bool</code>을 <code class=\"language-text\">char</code>만큼 거듭제곱한 것, 즉, <code class=\"language-text\">boolchar</code>를 얻을 수 있다.</p>\n<p>그렇다면 <code class=\"language-text\">bool</code>의 256 튜플로 정의된 타입에는 얼마나 많은 값이 존재하는 것일까? 정확하게 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>256</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{256}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">256</span></span></span></span></span></span></span></span></span></span></span></span></span>개이다. 이는 <code class=\"language-text\">char</code>에서 <code class=\"language-text\">bool</code>로 향하는 서로 다른 함수들의 개수와도 동일하며, 각 함수는 고유한 256 튜플에 해당된다.</p>\n<p>비슷한 방식으로 <code class=\"language-text\">bool</code>에서 <code class=\"language-text\">char</code>로 향하는 함수의 개수도 계산해보면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>256</mn><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">256^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">25</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>개라는 사실을 알 수 있다. 함수 타입에 대한 지수 표기법은 이런 의미를 가지고 있는 것이다.</p>\n<p>아마 우리는 <code class=\"language-text\">int</code>나 <code class=\"language-text\">double</code>에서 출발하는 함수를 모두 메모아이즈하고 싶어하지는 않을 것이다. 하지만 비록 실용적이지 않더라도 함수와 데이터 타입 사이의 동등성은 명확히 존재한다.</p>\n<p>그리고 리스트, 트리, 문자열과 같은 무한한 타입도 있다. 이러한 타입에서 출발하는 함수를 메모아이즈하기 위해서는 무한한 저장 공간을 필요로 한다.</p>\n<p>그러나 Haskell은 게으른 언어이므로, 게으르게 평가되는 무한한 데이터 구조와 함수 사이의 경계는 모호하게 다가온다. 이러한 함수와 데이터 간의 쌍대성은 함수 타입을 카테고리론적 지수 대상과 동일시 할 수 있다는 것을 설명한다. 이러한 특성은 우리가 가진 데이터에 대한 개념과도 일치하기 때문에 Haskell에서는 함수를 데이터처럼 취급할 수 있다.</p>\n<h2 id=\"94-데카르트-닫힌-카테고리cartesian-closed-categories\" style=\"position:relative;\">9.4 데카르트 닫힌 카테고리(Cartesian Closed Categories)<a href=\"#94-%EB%8D%B0%EC%B9%B4%EB%A5%B4%ED%8A%B8-%EB%8B%AB%ED%9E%8C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACcartesian-closed-categories\" aria-label=\"94 데카르트 닫힌 카테고리cartesian closed categories permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>물론 필자는 계속 집합의 카테고리를 타입과 함수의 모델로 사용할 것이지만, 이런 목적으로 사용할 수 있는 더 큰 카테고리 패밀리가 있다는 것을 언급하는 것은 충분히 가치가 있을 것 같다. 이런 카테고리는 데카르트 닫힌 카테고리(Cartesian closed categories)라고 하며, <strong>Set</strong>은 그저 이 카테고리 중 하나의 예일 뿐이다.</p>\n<p>데카르트 닫힌 카테고리는 아래 세 가지를 반드시 포함하고 있어야 한다.</p>\n<ol>\n<li>종결 대상</li>\n<li>어떤 두 대상의 곱</li>\n<li>어떤 두 대상의 지수</li>\n</ol>\n<p>지수를 무한히 많은 횟수로 반복되는 곱이라고 간주한다면, 데카르트 닫힌 카테고리는 임의의 항수를 지원하는 것이라고 생각할 수 있다. 특히 종결 대상은 곱의 항등원(0)인 대상의 곱 또는 대상의 항등원(0) 승이라고 볼 수 있다.</p>\n<p>컴퓨터 과학의 관점에서 데카르트 닫힌 카테고리들이 흥미로운 이유는 이 카테고리들이 간단하게 타이핑된 람다 미적분법의 모델을 제공하고 있기 때문이다. 이 모델은 타입을 사용하는 모든 프로그래밍 언어의 기초를 형성한다.</p>\n<p>종결 대상과 곱 연산에는 각각 초기 대상과 합 연산이라는 쌍대(Dual)가 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">a × (b + c) = a × b + a × c\n(b + c) × a = b × a + c × a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 두 요소를 지원하고 곱이 합을 통해 분배될 수 있는 데카르트 닫힌 카테고리를 이중 데카르트 닫힌 카테고리(Bicartesian closed category)라고 한다. 다음 섹션에서 보겠지만 우리가 계속 다뤄온 <strong>Set</strong>이 대표적인 이중 데카르트 닫힌 카테고리이며, 이 카테고리는 몇 가지 흥미로운 특성을 가지고 있다.</p>\n<h2 id=\"95-지수와-대수적-자료형exponentials-and-algebraic-data-types\" style=\"position:relative;\">9.5 지수와 대수적 자료형(Exponentials and Algebraic Data Types)<a href=\"#95-%EC%A7%80%EC%88%98%EC%99%80-%EB%8C%80%EC%88%98%EC%A0%81-%EC%9E%90%EB%A3%8C%ED%98%95exponentials-and-algebraic-data-types\" aria-label=\"95 지수와 대수적 자료형exponentials and algebraic data types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수 타입을 지수로 해석하는 것은 대수적 자료형의 체계에 아주 잘 들어맞는다. 실제로 고등학교에서 배우는 대수학에서 나오는 숫자 0과 1, 합, 곱, 그리고 지수와 관련된 기본적인 항등식은 각각 초기 대상, 종결 대상, 합집합, 곱집합 그리고 지수에 대해 거의 그대로 적용된다는 것을 볼 수 있다.</p>\n<p>우리는 아직 이 성질을 제대로 증명할만한 수반(Adjunction)이나 요네다 보조정리같은 도구를 가지고 있지는 않지만, 그럼에도 불구하고 독자 여러분께 직관을 제공하기 위해 일단 쭉 설명해보겠다.</p>\n<h3 id=\"951-0승\" style=\"position:relative;\">9.5.1 0승<a href=\"#951-0%EC%8A%B9\" aria-label=\"951 0승 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>a</mi><mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">a^0 = 1 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8641em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></div>\n<p>카테고리적 해석에서 우리는 0을 초기 대상으로, 1을 종결 대상으로, 그리고 등식을 동형사상으로 대체한다. 여기서 지수는 내부 Hom 대상을 의미하기 때문에 결국 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">a^0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>이라는 식은 초기 대상에서 임의의 대상 <code class=\"language-text\">a</code>로 향하는 사상의 집합을 나타낸다. 초기 대상의 정의에 따라 이런 사상은 정확히 하나만 존재할 수 있으므로 Hom 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C(0,a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span></span>는 단일 원소 집합이다.</p>\n<p>단일 원소 집합은 <strong>Set</strong>에서의 종결 대상이므로, 이 항등식은 <strong>Set</strong>에서 쉽게 성립할 수 있다. 여기서 중요한 것은 이 항등식이 이중 데카르트 닫힌 카테고리의 모든 경우에 대해서 성립한다는 것이다.</p>\n<p>Haskell에서는 0을 <code class=\"language-text\">Void</code>로, 1을 유닛 타입인 <code class=\"language-text\">()</code>으로 대체한다. 결국 필자가 앞에서 했던 주장은 <code class=\"language-text\">Void</code>에서 임의의 타입 <code class=\"language-text\">a</code>로 향하는 함수의 집합이 유닛 타입과 동등하다는 것이다. 다시 말하자면 <code class=\"language-text\">Void -> a</code> 함수는 하나뿐이라는 것이다. 그리고 우리는 이미 이 함수를 예전에 본 적이 있다. 바로 <code class=\"language-text\">absurd</code> 함수이다.</p>\n<p>그러나 이것을 현실에 구현하기는 약간 까다롭다. 이유는 크게 두 가지인데, 첫째로 Haskell에서는 실제로 어떤 값도 속하지 않는 타입이라는게 존재하지 않는다. 모든 타입은 “끝나지 않는 계산의 결과” 또는 Bottom(<code class=\"language-text\">_|_</code>)을 포함하기 때문이다.</p>\n<p>두번째 이유는 <code class=\"language-text\">absurd</code>에는 어떤 값도 전달할 수 없기 때문에 누가 무슨 짓을 하던 결국 아무도 실행시킬 수 없다는 점이다. 결국 이 함수의 구현은 근본적으로 모두 동등하다는 것이다. 그렇다고 해서 만약 영원히 끝나지 않는 계산을 전달한다면 이 함수는 결코 반환이라는 행위까지 도달하지 못할 것이다.</p>\n<h3 id=\"952-1의-지수\" style=\"position:relative;\">9.5.2 1의 지수<a href=\"#952-1%EC%9D%98-%EC%A7%80%EC%88%98\" aria-label=\"952 1의 지수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mn>1</mn><mi>a</mi></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1^a = 1\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></div>\n<p>위 식은 <strong>Set</strong>에서 해석될 때 모든 대상에서 종결 대상으로 향하는 고유한 사상이 존재한다는 종결 대상에 대한 정의를 다시 한번 표현하고 있다. 일반적으로 <code class=\"language-text\">a</code>에서 종결 대상으로 향하는 내부 Hom 대상은 종결 대상과 동형이다.</p>\n<p>Haskell에서 임의의 타입 <code class=\"language-text\">a</code>에서 유닛으로 향하는 함수는 <code class=\"language-text\">a -> ()</code> 단 하나 뿐이다. 우리는 이 함수를 <code class=\"language-text\">unit</code>이라고 부른다는 것을 이미 알고 있다. 이 함수는 <code class=\"language-text\">()</code>에 부분 적용된 <code class=\"language-text\">const</code> 함수로 생각할 수도 있다.</p>\n<h3 id=\"953-1승\" style=\"position:relative;\">9.5.3 1승<a href=\"#953-1%EC%8A%B9\" aria-label=\"953 1승 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>a</mi><mn>1</mn></msup><mo>=</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a^1 = a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8641em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span></div>\n<p>위 식은 종결 대상으로부터 출발하는 사상은 대상 <code class=\"language-text\">a</code>의 원소를 선택하는데 사용될 수 있다는 것을 다시 표현한 것이다. 이러한 사상들의 집합은 대상 자체와 동형이다. <strong>Set</strong>, 그리고 Haskell에서는 집합 <code class=\"language-text\">a</code>의 원소들과 해당 원소들을 선택하는 함수들인 <code class=\"language-text\">() -> a</code>가 동형이라는 것이다.</p>\n<h3 id=\"954-지수의-합\" style=\"position:relative;\">9.5.4 지수의 합<a href=\"#954-%EC%A7%80%EC%88%98%EC%9D%98-%ED%95%A9\" aria-label=\"954 지수의 합 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>a</mi><mrow><mi>b</mi><mo>+</mo><mi>c</mi></mrow></msup><mo>=</mo><msup><mi>a</mi><mi>b</mi></msup><mo>×</mo><msup><mi>a</mi><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">a^{b+c} = a^b ×a^c\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8991em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9824em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>카테고리론적으로 위 식은 대상의 두 지수의 합이 각 지수를 가진 대상들의 곱과 동형이라는 것을 의미한다.</p>\n<p>이 대수적 동형성을 Haskell에서 다루게 되면 매우 실용적인 해석을 가져다준다. 이는 두 타입의 합으로부터 출발하는 함수가 각각의 타입으로부터 출발하는 함수의 쌍과 동등하다는 것을 의미하기 때문이다.</p>\n<p>이 개념이 바로 우리가 합에 대한 함수를 정의할 때 사용하는 문법의 근원이다. 우리는 합을 의미하는 <code class=\"language-text\">Either</code>를 정의할 때 <code class=\"language-text\">case</code> 문을 사용하여 함수를 정의하지 않고, 각각의 타입 생성자를 따로 처리하는 두 개, 혹은 그 이상의 함수로 나눈다.</p>\n<p>예를 들어 합 타입(<code class=\"language-text\">Either Int Double</code>)를 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Either</span> <span class=\"token constant\">Int</span> <span class=\"token constant\">Double</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 경우 <code class=\"language-text\">Either</code>는 각각 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Double</code>에 대한 함수의 쌍으로 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Left</span> <span class=\"token hvariable\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token keyword\">then</span> <span class=\"token string\">\"Negative int\"</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"Positive int\"</span>\n<span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Right</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.0</span> <span class=\"token keyword\">then</span> <span class=\"token string\">\"Negative double\"</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"Positive double\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"955-지수의-지수\" style=\"position:relative;\">9.5.5 지수의 지수<a href=\"#955-%EC%A7%80%EC%88%98%EC%9D%98-%EC%A7%80%EC%88%98\" aria-label=\"955 지수의 지수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>a</mi><mi>b</mi></msup><msup><mo stretchy=\"false\">)</mo><mi>c</mi></msup><mo>=</mo><msup><mi>a</mi><mrow><mi>b</mi><mo>×</mo><mi>c</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">(a^b)^c = a^{b×c}\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1491em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8991em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>위 식은 지수 대상들에 대한 커링(Currying)을 표현하고 있다. 함수가 함수를 반환하는 것은 곱에서 출발하는 함수, 즉 이변수 함수와 동등하다.</p>\n<h3 id=\"956-곱의-지수\" style=\"position:relative;\">9.5.6 곱의 지수<a href=\"#956-%EA%B3%B1%EC%9D%98-%EC%A7%80%EC%88%98\" aria-label=\"956 곱의 지수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><msup><mo stretchy=\"false\">)</mo><mi>c</mi></msup><mo>=</mo><msup><mi>a</mi><mi>c</mi></msup><mo>×</mo><msup><mi>b</mi><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">(a×b)^c =a^c × b^c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7977em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>Haskell에서 쌍을 반환하는 함수는 각 쌍의 요소 하나를 생성하는 두 함수의 쌍과 동등하다.</p>\n<p>이처럼 고등학교에서 배우는 대수학의 간단한 항등식들이 카테고리 이론으로 확장되어 함수형 프로그래밍에서 실용적으로 적용될 수 있다는 것은 굉장히 놀라운 일이다.</p>\n<h2 id=\"96-커리-하워드-동형사상curry-howard-isomorphism\" style=\"position:relative;\">9.6 커리-하워드 동형사상(Curry-Howard Isomorphism)<a href=\"#96-%EC%BB%A4%EB%A6%AC-%ED%95%98%EC%9B%8C%EB%93%9C-%EB%8F%99%ED%98%95%EC%82%AC%EC%83%81curry-howard-isomorphism\" aria-label=\"96 커리 하워드 동형사상curry howard isomorphism permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 이미 논리와 대수적 자료형 간의 대응 관계에 대해 언급한 적이 있다. <code class=\"language-text\">Void</code> 타입과 유닛 타입(<code class=\"language-text\">()</code>)은 각각 거짓과 참에 해당하며, 곱 타입과 합 타입은 논리곱(AND)과 논리합(OR)에 해당한다. 이 체계에서 함수 타입은 논리적 함의(<code class=\"language-text\">⇒</code>)에 해당한다. 다시 말해 타입 <code class=\"language-text\">a -> b</code>는 “만약 <code class=\"language-text\">a</code>라면 <code class=\"language-text\">b</code>이다”라고 읽을 수 있다.</p>\n<p>커리-하워드 동형사상에 따르면 모든 타입은 참 또는 거짓일 수 있는 명제, 즉 진술이나 판단으로 해석될 수 있다. 해당 타입이 존재하면 그 명제는 참으로 간주되고, 존재하지 않으면 거짓으로 간주된다. 특히 논리적 함의가 참이라는 것은 그에 해당하는 함수 타입이 존재한다는 것을 의미하며, 그 타입의 함수가 실제로 존재한다는 것을 의미한다.</p>\n<p>따라서 함수의 구현 자체가 정리의 증명이 되는 것이며, 우리가 프로그램을 작성하는 것은 정리를 증명하는 것과 동등하다. 한번 몇 가지 예시를 살펴보자.</p>\n<p>함수 대상의 정의에서 소개했던 <code class=\"language-text\">eval</code> 함수를 살펴보도록 하겠다. <code class=\"language-text\">eval</code>의 시그니처는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">eval</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 함수는 함수와 그 인자로 구성된 쌍을 받아 적절한 타입의 결과를 반환한다. 즉 위 코드는 사상에 대한 Haskell에서의 구현이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">eval</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> ⇒ <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> × <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 표현은 함수 타입 <code class=\"language-text\">a ⇒ b</code> (또는 지수 대상 <code class=\"language-text\">ba</code>)를 정의한다. 이 서명을 커리-하워드 동형사상을 사용하여 논리적 술어로 번역해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">((a ⇒ b) ∧ a) ⇒ b</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 명제는 만약 <code class=\"language-text\">b</code>가 <code class=\"language-text\">a</code>로부터 도출되는 것이 참이고, <code class=\"language-text\">a</code> 또한 참이라면, <code class=\"language-text\">b</code> 또한 반드시 참이어야 한다고 읽을 수 있다. 이는 직관적으로 완벽한 의미를 가지고 있으며 고대부터 전건 긍정(*modus ponens)*라고 불려왔다. 이제 다음 함수를 구현함으로써 이 정리를 증명할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">eval</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n<span class=\"token hvariable\">eval</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">a</code>를 받아서 <code class=\"language-text\">b</code>를 반환하는 함수 <code class=\"language-text\">f</code>와 타입 <code class=\"language-text\">a</code>의 구체적인 값 <code class=\"language-text\">x</code>로 구성된 쌍을 제공한다면, 함수 <code class=\"language-text\">f</code>를 <code class=\"language-text\">x</code>에 적용함으로써 타입 b의 구체적인 값을 생성할 수 있다.</p>\n<p>즉, 필자는 이 함수를 구현함으로써 타입 <code class=\"language-text\">((a -> b), a) -> b</code>가 실제로 존재한다는 것을 보였다. 따라서 우리의 논리에서 전건 긍정(modus ponens)는 참이다.</p>\n<p>그렇다면 명백하게 거짓인 술어는 어떨까? 예를 들어 “만약 <code class=\"language-text\">a</code> 또는 <code class=\"language-text\">b</code>가 참이면, <code class=\"language-text\">a</code>는 반드시 참이어야 한다”와 같은 명제가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">a ∨ b ⇒ a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이는 명백하게 잘못된 명제이다. 왜냐하면 이 명제대로라면 <code class=\"language-text\">a</code>가 거짓이고  <code class=\"language-text\">b</code>가 참인 상황도 존재할 수 있기 때문이다. 이 술어를 커리-하워드 동형사상을 사용하여 함수 시그니처로 매핑하면 다음과 같은 결과를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사실 아무리 시도를 하더라도 이 함수는 절대 구현할 수 없다. <code class=\"language-text\">Right</code> 값으로 호출되었을 때는 <code class=\"language-text\">a</code> 타입의 값을 생성할 수 없기 때문이다. (우리가 순수 함수에 대해서만 이야기하고 있다는 점을 기억하자)</p>\n<p>이제 드디어 <code class=\"language-text\">absurd</code> 함수의 진짜 의미에 대해 이야기할 때가 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">absurd</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Void</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>만약 <code class=\"language-text\">Void</code>가 “거짓”이라고 번역된다고 생각해보면 우리는 아래와 같은 술어를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">false ⇒ a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>거짓에서는 어떤 것이든 따라올 수 있다(<em>ex falso quodlibet</em>). 여기 Haskell에서 이 명제(함수)를 증명(구현)할 수 있는 한 가지 예시가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">absurd</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Void</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">absurd</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서 <code class=\"language-text\">Void</code>는 다음과 같이 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">Void</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Void</span> <span class=\"token constant\">Void</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Void</code> 타입은 까다로운 녀석이다. 이 정의는 <code class=\"language-text\">Void</code> 타입의 값을 생성하기 위해서는 <code class=\"language-text\">Void</code> 타입의 값이 필요하다는 의미를 가지고 있기 때문에 절대 값을 구성할 수 없게 만든다. 결국 <code class=\"language-text\">Void</code> 타입의 값이라는 것은 존재할 수가 없으므로 <code class=\"language-text\">absurd</code> 함수는 절대 호출될 수가 없는 것이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>“거짓에서는 어떤 것이든 따라올 수 있다”라는 뜻의 <em>ex falso quodlibet</em>는 거짓 명제로부터는 어떤 명제라도 유도될 수 있다는 것을 의미하며, 이는 논리학에서 매우 중요한 원칙 중 하나이다.</p>\n<p>쉽게 말하자면 거짓인 전제가 주어진다면, 그 전제로부터 나오는 어떠한 결론도 모두 정당화될 수 있다는 것이다.이와 마찬가지로 <code class=\"language-text\">absurd</code> 함수는 절대 생성될 수 없는 값의 타입인 <code class=\"language-text\">Void</code>를 인자로 받아 임의의 타입 <code class=\"language-text\">a</code>를 반환할 수 있다고 선언된다.</p>\n<p>즉, 거짓으로부터 출발했으니 어떤 타입을 반환하더라도 논리가 깨지지는 않는 것이다.참고로 <code class=\"language-text\">absurd</code> 함수는 절대 호출될 수가 없기 때문에 실제로 사용될 수는 없고, 순수하게 프로그래밍 언어의 타입 시스템의 원리를 설명하기 위한 이론적인 목적으로만 사용된다.</p>\n</blockquote>\n<p>물론 이 예시들이 모두 흥미롭기는 하지만, 도대체 커리-하워드 동형사상이 우리에게 어떤 실용적인 혜택을 가져다준다는 것일까? 아마도 일상적인 프로그래밍에서는 아니겠지만, Agda나 Coq와 같은 프로그래밍 언어들은 정리를 증명하기 위해 커리-하워드 동형사상을 활용한다.</p>\n<p>컴퓨터는 수학자들이 그들의 일을 하는데 도움을 주는 것뿐만 아니라, 수학의 근본을 혁신하고 있다. 이러한 분야에서 가장 최근에 뜨거운 감자로 떠오르는 연구는 호모토피 타입 이론이라고 하며, 타입 이론의 발전에 큰 기여를 하고있다. 이 이론은 Boolean, Integer, 곱과 쌍대곱, 함수 타입 등으로 가득 차 있다. 그리고 이러한 이론은 Coq와 Agda에서 공식적으로 도입되고 있다.</p>\n<p>이처럼 컴퓨터는 여러 방면에서 세상을 혁신하고 있다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240418-category-theory-for-programmers-9-function-types","path":"/2024/04/18/category-theory-for-programmers-9-function-types/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 9. 함수 타입","subTitle":null,"date":"Apr 18, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"ee3fcb22-5cce-5033-9187-c2ea953b6f10","tableOfContents":"<ul>\n<li><a href=\"#81-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0bifunctors\">8.1 이항 펑터(Bifunctors)</a></li>\n<li><a href=\"#82-%EA%B3%B1%EA%B3%BC-%ED%95%A9-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0product-and-coproduct-bifunctors\">8.2 곱과 합 이항 펑터(Product and Coproduct Bifunctors)</a></li>\n<li><a href=\"#83-%ED%8E%91%ED%84%B0%EC%A0%81%EC%9D%B8-%EB%8C%80%EC%88%98%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%90%EB%A3%8C%ED%98%95functorial-algebraic-data-types\">8.3 펑터적인 대수적 데이터 자료형(Functorial Algebraic Data Types)</a></li>\n<li><a href=\"#84-c%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0functors-in-c\">8.4 C++에서의 펑터(Functors in C++)</a></li>\n<li><a href=\"#85-writer-%ED%8E%91%ED%84%B0\">8.5 Writer 펑터</a></li>\n<li><a href=\"#86-%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0%EC%99%80-%EB%B0%98%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0covariant-and-contravariant-functors\">8.6 공변적 펑터와 반공변적 펑터(Covariant and Contravariant Functors)</a></li>\n<li><a href=\"#87-%ED%94%84%EB%A1%9C%ED%8E%91%ED%84%B0profunctors\">8.7 프로펑터(Profunctors)</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"이제 펑터가 무엇인지 알았으니, 작은 펑터로부터 큰 펑터를 구축해나가는 방법에 대해서 살펴보도록 하겠다. 여기서 특히 흥미로운 부분은 카테고리 내 대상 간의 매핑에 대당하는 타입의 생성자가 확장되어 사상 간의 매핑을 포함하는 펑터가 되는 과정을 볼 수 있다는 것이다. 8.1 이항 펑터(Bifunctors) 펑터는 카테고리들의 카테고리인 Cat에서의 사상이기 때문에 사상에 대한 많은 직관들 특히 함수에 대한 직관들은 펑터에도 그대로 작용한다고 할 수 있다. 예를 들어 두 개의 인수를 가지는 함수가 있듯이, 두 개의 인수를 가지는 펑…","html":"<p>이제 펑터가 무엇인지 알았으니, 작은 펑터로부터 큰 펑터를 구축해나가는 방법에 대해서 살펴보도록 하겠다.</p>\n<p>여기서 특히 흥미로운 부분은 카테고리 내 대상 간의 매핑에 대당하는 타입의 생성자가 확장되어 사상 간의 매핑을 포함하는 펑터가 되는 과정을 볼 수 있다는 것이다.</p>\n<h2 id=\"81-이항-펑터bifunctors\" style=\"position:relative;\">8.1 이항 펑터(Bifunctors)<a href=\"#81-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0bifunctors\" aria-label=\"81 이항 펑터bifunctors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>펑터는 카테고리들의 카테고리인 <em>Cat</em>에서의 사상이기 때문에 사상에 대한 많은 직관들 특히 함수에 대한 직관들은 펑터에도 그대로 작용한다고 할 수 있다.</p>\n<p>예를 들어 두 개의 인수를 가지는 함수가 있듯이, 두 개의 인수를 가지는 펑터인 이항 펑터(Bifunctors)도 존재할 수 있다. 먼저 대상에 대해서만 생각해보자면 이항 펑터는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>, 그리고 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 각각의 대상으로 이루어진 모든 쌍을 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>의 대상으로 매핑하는 펑터이다. 즉, 이항 헝터는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C×D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 표현되는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 데카르트 곱에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로의 매핑이라고 볼 수 있는 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 313px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 95%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQCAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9qSmO25pJriHcH//xAAbEAACAgMBAAAAAAAAAAAAAAABAhESAAMiIf/aAAgBAQABBQK/R2myGwK+8h1EKROBFnP/xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPwEj/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgIDAAAAAAAAAAAAAAAAARARMQAgIf/aAAgBAQAGPwKMtSa0PF//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhMWFBEP/aAAgBAQABPyGm2apHKjWu5l0eoCAxftQgBvsDByTij8//2gAMAwEAAgADAAAAEMPAfP/EABcRAQEBAQAAAAAAAAAAAAAAAAEQMUH/2gAIAQMBAT8QK8gpk//EABYRAQEBAAAAAAAAAAAAAAAAAAEgMf/aAAgBAgEBPxAQ2P/EABwQAQEAAwEAAwAAAAAAAAAAAAERACExQWFxgf/aAAgBAQABPxArQUr9GVYl0LA8Odyl0qJ5+YboVU+zFxsGnZXcHJOkvyu8CjSiONoXhtw0Z//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" srcset=\"/static/6f3400dcb00c047b27d284f6c7f27034/0913d/1.jpg 160w,\n/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg 313w\" sizes=\"(max-width: 313px) 100vw, 313px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>사실 여기까지는 매우 간단하게 이해할 수 있다. 그러나 펑터의 특성상 이항 펑터는 대상 뿐만 아니라 사상 또한 매핑할 수 있어야 한다. 즉, 하나는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 다른 하나는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 가져온 사상의 쌍을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>의 사상으로 매핑해야 한다는 것이다.</p>\n<p>한번 더 이야기하자면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>가 가진 사상의 쌍은 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C×D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 단일한 사상이다. 우리는 데카르트 곱 카테고리에서의 사상을 어떤 대상의 쌍에서 다른 대상의 쌍으로 이동하는 사상의 쌍으로 정의할 수 있다. 이러한 사상의 쌍들은 아래와 같은 방식으로 합성도 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">)</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f'</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> ◦ <span class=\"token hvariable\">f'</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span> ◦ <span class=\"token hvariable\">g'</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>합성은 결합법칙을 만족하며, <code class=\"language-text\">(id, id)</code>와 같은 항등원 또한 존재한다. 이처럼 데카르트 곱 카테고리는 카테고리의 기본적인 법칙을 모두 만족하기 때문에 실제로 하나의 카테고리가 될 수 있는 것이다.</p>\n<p>이항 펑터에 대해서 더 쉽게 이해하려면 이 펑터가 두 인자 모두에 대한 펑터라는 점을 이해하는 것에서부터 출발해야한다. 즉, 펑터 법칙인 결합성과 항등 보존에 대한 개념을 곧바로 이항 펑터와 연결하고 확인해보려고 시도하는 것보다는, 이항 펑터가 가진 각 인자에 대해 하나씩 확인해보는 것이 더 이해하기 쉽다는 것이다.</p>\n<p>만약 한 쌍의 카테고리로부터 세 번째 카테고리로의 매핑이 있고, 그 매핑이 각 인자에 대해 펑터적(Functorial)이라는 사실을 만족한다는 사실을 증명한다면, 해당 매핑은 자동으로 이항 펑터가 된다. 여기서 펑터적이라는 의미는 이 펑터가 사상에 대해서 제대로 된 펑터처럼 작동한다는 것을 의미한다.</p>\n<p>Haskell에서 이항 펑터를 한번 정의해보자. 이 경우에는 세 개의 카테고리가 모두 Haskell 타입의 카테고리이기 때문에 사실상 같은 카테고리라고 볼 수 있다. 이항 펑터는 두 개의 타입 인자를 가지는 타입 생성자로 표현된다. 아래는 라이브러리 <code class=\"language-text\">Control.Bifunctor</code>에서 직접 가져온 <code class=\"language-text\">Bifunctor</code> 타입 클래스의 정의이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token hvariable\">f</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">d</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">g</span> <span class=\"token hvariable\">h</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">first</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">second</span> <span class=\"token hvariable\">h</span>\n  \t<span class=\"token hvariable\">first</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">b</span>\n  \t<span class=\"token hvariable\">first</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">g</span> <span class=\"token builtin\">id</span>\n  \t<span class=\"token hvariable\">second</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">d</span>\n  \t<span class=\"token hvariable\">second</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">bimap</span> <span class=\"token builtin\">id</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>타입 변수 <code class=\"language-text\">f</code>는 이항 펑터를 나타내며, 아래 정의된 모든 타입 시그니처에서 이 타입 변수가 항상 두 개의 타입 인자에 적용되는 것을 볼 수 있다.</p>\n<p>첫 번째 타입 시그니처는 <code class=\"language-text\">bimap</code>을 정의하는데, 이것은 두 함수의 매핑을 한 번에 나타낸다. 결과는 이항 펑터의 타입 생성자에 의해 생성된 타입들에서 동작하는 함수 <code class=\"language-text\">(f a b -> f c d)</code>이다. <code class=\"language-text\">bimap</code>은 <code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>를 사용하여 구현되어 있는데, 이는 이항 펑터가 각각의 인자에 대해 펑터적으로 작동한다는 사실을 정의하는 것만으로도 이항 펑터를 정의할 수 있다는 사실을 보여준다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 313px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 95%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQCAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9qSmO25pJriHcH//xAAbEAACAgMBAAAAAAAAAAAAAAABAhESAAMiIf/aAAgBAQABBQK/R2myGwK+8h1EKROBFnP/xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPwEj/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgIDAAAAAAAAAAAAAAAAARARMQAgIf/aAAgBAQAGPwKMtSa0PF//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhMWFBEP/aAAgBAQABPyGm2apHKjWu5l0eoCAxftQgBvsDByTij8//2gAMAwEAAgADAAAAEMPAfP/EABcRAQEBAQAAAAAAAAAAAAAAAAEQMUH/2gAIAQMBAT8QK8gpk//EABYRAQEBAAAAAAAAAAAAAAAAAAEgMf/aAAgBAgEBPxAQ2P/EABwQAQEAAwEAAwAAAAAAAAAAAAERACExQWFxgf/aAAgBAQABPxArQUr9GVYl0LA8Odyl0qJ5+YboVU+zFxsGnZXcHJOkvyu8CjSiONoXhtw0Z//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" srcset=\"/static/6f3400dcb00c047b27d284f6c7f27034/0913d/1.jpg 160w,\n/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg 313w\" sizes=\"(max-width: 313px) 100vw, 313px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>bimap</small>\n</center>\n<p><code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>는 각각 첫 번째와 두 번째 인자에 대한 <code class=\"language-text\">f</code>의 펑터적인 성질을 증명하는 두 개의 <code class=\"language-text\">fmap</code>이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 388px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/351da696e6a37d5df6740dce2c23f8d6/c3c84/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 82.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAEEBQL/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB1613PXQdkkEg/8QAHRAAAgEEAwAAAAAAAAAAAAAAAQIAAxAREhMhMf/aAAgBAQABBQJqms5ThO1YYg2g8v8A/8QAFREBAQAAAAAAAAAAAAAAAAAAASD/2gAIAQMBAT8BCP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABoQAQEAAgMAAAAAAAAAAAAAAAEAESEgIkH/2gAIAQEABj8Cb3LblDcdeP8A/8QAHBAAAgEFAQAAAAAAAAAAAAAAAAERICExQVFh/9oACAEBAAE/IfY4JqX0B3JkISQbQzOEr8MFoo//2gAMAwEAAgADAAAAEB/PAP/EABURAQEAAAAAAAAAAAAAAAAAAAEg/9oACAEDAQE/EGY//8QAFhEBAQEAAAAAAAAAAAAAAAAAAREg/9oACAECAQE/EKGP/8QAHRABAAICAgMAAAAAAAAAAAAAAQARITFBgRBRkf/aAAgBAQABPxBUQwHAVPUdSwoLj7UGbi3mzqERNwu+oYWLGXTviBAQqyGiPENeP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/351da696e6a37d5df6740dce2c23f8d6/c3c84/3.jpg\" srcset=\"/static/351da696e6a37d5df6740dce2c23f8d6/0913d/3.jpg 160w,\n/static/351da696e6a37d5df6740dce2c23f8d6/cb69c/3.jpg 320w,\n/static/351da696e6a37d5df6740dce2c23f8d6/c3c84/3.jpg 388w\" sizes=\"(max-width: 388px) 100vw, 388px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>first</small>\n</center>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 423px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f7734853d3675663d3f814199fd26135/b7bea/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 92.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGQABAQADAQAAAAAAAAAAAAAAAAQBAgMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAfXlqkq9sjPMOoP/xAAbEAACAgMBAAAAAAAAAAAAAAABAhEhAAMSE//aAAgBAQABBQL0g9uShlTrsKJWgbzhZz//xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPwEj/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgMBAQAAAAAAAAAAAAAAEBEAASExMv/aAAgBAQAGPwJKYLt5PR4P/8QAGhABAQEBAQEBAAAAAAAAAAAAAREAITEQcf/aAAgBAQABPyFt6Qz2DzNZ9wUTlHpn7gCDcARKYPx+f//aAAwDAQACAAMAAAAQ9898/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EBs1J//EABURAQEAAAAAAAAAAAAAAAAAAAEg/9oACAECAQE/EBCP/8QAHRABAQACAwADAAAAAAAAAAAAAREAMSFBUWGx0f/aAAgBAQABPxCxKhH2X8xw1bCgF89wyOyOAVINjq2/eJoBUQ8dmRNJv35yISbHvHCUJvnDg4z/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/f7734853d3675663d3f814199fd26135/b7bea/4.jpg\" srcset=\"/static/f7734853d3675663d3f814199fd26135/0913d/4.jpg 160w,\n/static/f7734853d3675663d3f814199fd26135/cb69c/4.jpg 320w,\n/static/f7734853d3675663d3f814199fd26135/b7bea/4.jpg 423w\" sizes=\"(max-width: 423px) 100vw, 423px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>second</small>\n</center>\n<p>타입 클래스 정의는 <code class=\"language-text\">bimap</code>을 기반으로 두 개의 함수에 대한 기본 구현을 제공한다.</p>\n<p><code class=\"language-text\">Bifunctor</code>의 인스턴스를 선언할 때는 <code class=\"language-text\">bimap</code>을 구현하고, <code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>의 기본 값을 사용하거나, 반대로 <code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>를 모두 구현하고 <code class=\"language-text\">bimap</code>의 기본 값을 사용하는 선택권을 가질 수 있다. (물론 세 가지 모두를 구현할 수는 있겠지만, 그러면 이들이 위와 같은 성질을 가질 수 있도록 보장해줘야 한다.)</p>\n<h2 id=\"82-곱과-합-이항-펑터product-and-coproduct-bifunctors\" style=\"position:relative;\">8.2 곱과 합 이항 펑터(Product and Coproduct Bifunctors)<a href=\"#82-%EA%B3%B1%EA%B3%BC-%ED%95%A9-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0product-and-coproduct-bifunctors\" aria-label=\"82 곱과 합 이항 펑터product and coproduct bifunctors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이항 펑터의 예시 중 특히 중요한 것은 카테고리적 곱(Categorical Product)이다. 이는 두 대상의 곱으로, <a href=\"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts\">보편적 구성(Universial Construction)</a>에 의해 정의된다. 만약 어떤 두 대상에 대한 곱이 존재한다면, 해당 대상들에서 곱으로의 매핑은 이항 펑터적(Bifunctorial)이다. 이것은 일반적으로 참이며, 특히 Haskell에서도 마찬가지이다.</p>\n<p>아래는 가장 간단한 곱 타입인 쌍 생성자에 대한 <code class=\"language-text\">Bifunctor</code> 인스턴스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">bimap</code>은 단순히 쌍의 첫 번째 구성 요소에 첫 번째 함수를 적용하고, 두 번째 구성 요소에는 두 번째 함수를 적용하고 있기 때문에, 딱히 고민할만한 부분이 없다. 이렇게 명확하고 간단한 동작이 요구사항으로 주어진다면 코드 작성 자체는 간단하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">bimap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 이항 펑터의 작용은 타입들의 쌍을 만드는 것이다. 예를 들면 이런 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>쌍대성에 의해 이 정의가 카테고리 내의 모든 대상 쌍에 대해서 정의된다면, 합(Coproduct) 또한 이항 펑터라고 할 수 있다. Haskell에서는 <code class=\"language-text\">Either</code> 타입 생성자를 <code class=\"language-text\">Bifunctor</code>의 인스턴스인 것으로 나타낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token constant\">Either</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">_</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Left</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Right</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>워낙 동작이 간단하고 요구사항이 명확하니 코드 작성은 어렵지 않다.</p>\n<p>혹시 모노이드 카테고리(Monoidal Category)에 대해 이야기했던 것을 기억하는가? 모노이드 카테고리는 단위 대상과 함께 대상에 작용하는 이항 연산자인 모노이드 곱(Monoidal Product)을 정의한다.</p>\n<p>예전에 이야기했듯이 <em>Set</em>(집합의 카테고리)은 데카르트 곱 연산을 이항 연산으로 사용하여 대상 간의 결합을 정의하는 모노이드 카테고리이며, 이때 단위 대상은 단일 원소 집합이다. 또한 서로소 합집합 연산에 대해서도 모노이드 카테고리라고 볼 수 있으며, 이때의 단위 대상은 공집합이 된다.</p>\n<p>당시 필자가 언급하지 않은 것이 하나가 있다. 바로 모노이드 카테고리의 요구 사항 중 하나는 이항 연산자가 이항 펑터여야 한다는 것이다.</p>\n<p>우리는 모노이드 곱의 연산 구조가 사상에 의해 정의된 카테고리의 구조와 호환되도록 만들어야 하며, 이것은 매우 중요한 요구 사항이다. 물론 완전한 이해를 하기에는 아직 자연성(Naturality)이라는 큰 산이 하나 남아 있기는 하지만, 그래도 모노이드 카테고리의 전체 정의에 한 발짝 더 가까워졌다.</p>\n<h2 id=\"83-펑터적인-대수적-데이터-자료형functorial-algebraic-data-types\" style=\"position:relative;\">8.3 펑터적인 대수적 데이터 자료형(Functorial Algebraic Data Types)<a href=\"#83-%ED%8E%91%ED%84%B0%EC%A0%81%EC%9D%B8-%EB%8C%80%EC%88%98%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%90%EB%A3%8C%ED%98%95functorial-algebraic-data-types\" aria-label=\"83 펑터적인 대수적 데이터 자료형functorial algebraic data types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 펑터가 될 수 있는 몇 가지 파라미터화된 데이터 타입을 살펴봤다. 우리는 이러한 타입들에 대한 <code class=\"language-text\">fmap</code>을 정의할 수 있었다. 복잡한 데이터 타입은 더 간단한 데이터 타입을 기반으로 하여 구성되는데, 합과 곱의 개념을 사용하여 대수적 데이터 타입(ADT)을 생성하는 것이 바로 그 예이다.</p>\n<p>앞선 섹션에서 우리는 이미 합과 곱이 펑터적이라는 사실을 확인했고, 펑터가 합성 가능하다는 사실도 알게 되었다. 결국 우리가 대수적 데이터 타입의 기본 구성 요소가 펑터라는 사실을 보일 수만 있다면, 파라미터화된 대수적 데이터 타입도 결국 펑터라는 사실로 이어질 수 있다는 것이다.</p>\n<p>파라미터화된 대수적 데이터 타입이라는 것이 무엇을 의미하는걸까? 먼저 <code class=\"language-text\">Maybe</code>의 <code class=\"language-text\">Nothing</code>이나 <code class=\"language-text\">List</code>의 <code class=\"language-text\">Nil</code>처럼 펑터의 타입 파라미터에 의존하지 않는 녀석들이 있으며, 이들은 <code class=\"language-text\">Const</code> 펑터와 동등하다. <code class=\"language-text\">Const</code> 펑터는 자신이 받는 타입 파라미터를 무시한다는 사실을 기억해보자. (정확히 말하면 첫 번째 타입 파라미터는 고정이며, 두 번째 파라미터를 무시하는 것이다.)</p>\n<p>또한 <code class=\"language-text\">Maybe</code>의 <code class=\"language-text\">Just</code>처럼 단순히 타입 파라미터 자체를 캡슐화하는 녀석들도 있다. 이들은 항등 펑터와 동등하다. 이전에 <em>Cat</em>에서의 항등 사상에 대한 이야기를 하면서 항등 펑터를 언급한 적이 있었지만, Haskell에서의 정의는 보여주지 않았었다. 이것이 바로 항등 펑터의 정의다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span>\n\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Identity</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Identity</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">Identity</code>는 항상 타입이 <code class=\"language-text\">a</code>인 하나의 불변 값만을 가지는 간단한 컨테이너라고 생각해볼 수 있다. 대수적 데이터 구조에서 이 개념을 제외한 나머지 것들은 모두 두 가지 원시적 요소를 합하거나 곱하여 생성된다.</p>\n<p>이 새로운 지식을 토대로 <code class=\"language-text\">Maybe</code> 타입 생성자를 다시 한번 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이건 결국 <code class=\"language-text\">Nothing</code>과 <code class=\"language-text\">Just</code> 두 타입의 합이며, 합은 펑터적이다. 첫 번째 부분인 <code class=\"language-text\">Nothing</code>은 <code class=\"language-text\">Const ()</code>가 <code class=\"language-text\">a</code>에 작용하는 것이라고 볼 수 있다. (여기서 <code class=\"language-text\">Const</code>의 첫 번째 타입 파라미터는 유닛으로 설정한다.) 그리고 두 번째 부분인 <code class=\"language-text\">Just</code>는 그저 항등 펑터의 다른 이름일 뿐이다. 그럼 이제 우리는 <code class=\"language-text\">Maybe</code>를 동형적으로 아래와 같이 다시 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>결국 <code class=\"language-text\">Maybe</code>는 이항 펑터 <code class=\"language-text\">Either</code>를 사용하여 <code class=\"language-text\">Const ()</code>, <code class=\"language-text\">Identify</code>라는 두 개의 펑터를 조합한 것이다. (실제로는 <code class=\"language-text\">Const</code> 또한 이항 펑터이지만, 여기서는 항상 부분적용된 상태로만 사용한다.)</p>\n<p>우리는 이미 펑터의 합성 또한 펑터라는 것을 알고 있으며, 이항 펑터 또한 이와 마찬가지로 동일한 원칙이 적용될 것이라는 점을 쉽게 예상해볼 수 있다. 한번 이항 펑터와 두 펑터의 합성이 사상에 어떤 식으로 작용하는지 알아보도록 하자. 먼저 두 개의 사상 중 하나를 한 펑터로 리프팅한 후, 다른 하나를 또 하나의 다른 펑터로 리프팅할 것이다. 그 다음 여기서 얻어진 두 사상의 쌍을 이항 펑터로 리프팅하는 순서로 진행하면 된다.</p>\n<p>이 과정을 Haskell로 한번 표현해보자. 이 데이터 타입의 매개변수는 다음과 같다. 두 개의 타입을 인자로 받는 타입 생성자를 의미하는 이항 펑터 <code class=\"language-text\">bf</code>, 각각 하나의 타입 변수를 받는 타입 생성자인 두 개의 펑터 <code class=\"language-text\">fu</code>와 <code class=\"language-text\">gu</code>와 두 개의 일반적인 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>이다. 이제 펑터 <code class=\"language-text\">fu</code>를 <code class=\"language-text\">a</code>에 적용하고, 펑터 <code class=\"language-text\">gu</code>는 <code class=\"language-text\">b</code>에 적용한 다음, 이 결과로 나온 타입 두 개에 이항 펑터 <code class=\"language-text\">bf</code>를 적용할 것이라는 것을 표현하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">bf</span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것은 객체 또는 타입에 대한 합성이다. Haskell에서는 타입 생성자를 타입에 적용하는 것이 마치 함수를 인수에 적용하는 것과 동일한 방식으로 이루어지며, 심지어 구문 또한 동일하다.</p>\n<p>조금 헷갈린다면, <code class=\"language-text\">BiComp</code>의 매개변수로 <code class=\"language-text\">Either</code>, <code class=\"language-text\">Const ()</code>, <code class=\"language-text\">Identity</code>, <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code>가 들어온다고 생각해보자. 결과적으로 <code class=\"language-text\">Maybe b</code>를 얻을 수 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>왜 <code class=\"language-text\">BiComp Either Const () Identity a b</code>가 <code class=\"language-text\">Maybe b</code>인지는 의사코드로 작성해보면 단번에 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">bf</span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token constant\">BiComp</span> <span class=\"token constant\">Either</span> <span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span>\n<span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span>\n</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</blockquote>\n<p>새로운 타입인 <code class=\"language-text\">Bicomp</code>는 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>에 대한 이항 펑터라고 할 수 있지만, 이 정의는 매개변수인 <code class=\"language-text\">bf</code>가 이항 펑터이고 <code class=\"language-text\">fu</code>와 <code class=\"language-text\">gu</code>가 펑터일 경우에만 성립할 수 있다. 즉, 컴파일러가 이 매개변수들을 추론했을때, <code class=\"language-text\">bf</code>에 대한 <code class=\"language-text\">bimap</code> 정의와 <code class=\"language-text\">fu</code> 및 <code class=\"language-text\">gu</code>에 대한 <code class=\"language-text\">fmap</code> 정의가 있다는 사실이 보장되어야 한다는 것이다.</p>\n<p>Haskell에서는 인스턴스 선언 시 클래스 제약 조건 집합 다음에 위치하는 이중 화살표(<code class=\"language-text\">=></code>)로 이러한 전제조건을 표현해줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Bifunctor</span> <span class=\"token hvariable\">bf</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Functor</span> <span class=\"token hvariable\">fu</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Functor</span> <span class=\"token hvariable\">gu</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token constant\">Bifunctor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">bf</span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">gu</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n        <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f1</span> <span class=\"token hvariable\">f2</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">bimap</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">BiComp</code>의 <code class=\"language-text\">bimap</code> 구현은 <code class=\"language-text\">bf</code>의 <code class=\"language-text\">bimap</code>과 <code class=\"language-text\">fu</code>, <code class=\"language-text\">gu</code>의 <code class=\"language-text\">fmap</code>을 사용하여 정의한다. 컴파일러는 <code class=\"language-text\">BiComp</code>가 사용될 때 이 타입들을 자동으로 추론하고 오버로드된 함수를 선택할 것이다.</p>\n<p>위의 <code class=\"language-text\">bimap</code> 정의에서 <code class=\"language-text\">x</code>의 타입은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것은 꽤나 복잡한 정의처럼 보인다. 외부 <code class=\"language-text\">bimap</code>은 외부 <code class=\"language-text\">bf</code> 레이어를 통과하며, 두 개의 <code class=\"language-text\">fmap</code>들은 각각 <code class=\"language-text\">fu</code>와 <code class=\"language-text\">gu</code> 아래로 파고들게 된다.</p>\n<p>만약 <code class=\"language-text\">f1</code>와 <code class=\"language-text\">f2</code>의 타입이 아래와 같은 상황이라고 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f1</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a'</span>\n<span class=\"token hvariable\">f2</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러면 최종 결과는 <code class=\"language-text\">bf (fu a') (gu b')</code> 타입이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">bimap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b'</span><span class=\"token punctuation\">)</span>\n  \t<span class=\"token operator\">-></span> <span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b'</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>만약 여러분이 직소 퍼즐을 좋아한다면, 이런 종류의 타입 조작에서 꽤나 큰 즐거움을 느낄 수 있을 것이다.</p>\n<p>결론적으로 <code class=\"language-text\">Maybe</code>는 두 펑터적인 요소의 합으로 구성되었기 때문에, 굳이 <code class=\"language-text\">Maybe</code>가 펑터라는 것을 증명하지 않아도 당연히 펑터라는 사실이 성립하는 것이다.</p>\n<p>만약 예리한 독자들은 대수적 데이터 타입에 대한 펑터 인스턴스의 유도가 이렇게 논리적으로 명확하게 정의될 수 있다면, 그냥 컴파일러에서 자동화해서 처리할 수는 없냐고 질문할 수도 있다.</p>\n<p>물론 가능하다. 이는 Haskell의 확장기능(Extensions)를 사용하면 되는데, 특정 확장기능을 사용하려면 소스 파일의 맨 위에 아래와 같은 라인을 추가하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token comment\">{-# LANGUAGE DeriveFunctor #-}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그 이후 데이터 구조에 <code class=\"language-text\">deriving Functor</code>를 추가하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span> <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Functor</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이처럼 <code class=\"language-text\">DeriveFunctor</code> 확장 기능을 사용하면 특정 데이터 구조에 대한 <code class=\"language-text\">fmap</code>이 자동으로 구현되도록 할 수 있다.</p>\n<p>이런 기능이 제공될 수 있는 이유는 대수적 데이터 구조의 규칙성으로 인해 <code class=\"language-text\">Functor</code>뿐 아니라 앞서 언급했던 <code class=\"language-text\">Eq</code>와 같은 여러 다른 타입 클래스 인스턴스를 논리적으로 유도하는 것이 가능하기 때문이다.</p>\n<p>이와 더불어 컴퍼일러에게 사용자 정의 타입 클래스의 인스턴스를 유도하는 것도 가능하지만 이것은 조금 더 고급 기능이다. 하지만 결국 사용자 정의 타입 클래스라고 해도 기본적인 구성 요소, 그리고 합과 곱의 동작을 제공하는 것 뿐이므로 근본적인 원리는 동일하다.</p>\n<h2 id=\"84-c에서의-펑터functors-in-c\" style=\"position:relative;\">8.4 C++에서의 펑터(Functors in C++)<a href=\"#84-c%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0functors-in-c\" aria-label=\"84 c에서의 펑터functors in c permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>만약 여러분이 C++ 프로그래머라면 펑터를 처음부터 끝까지 오롯이 혼자서 구현해야할 것이다. 그러나 이를 위해서는 C++이 가진 대수적 데이터 구조의 몇 가지 타입을 이해할 수 있어야하며, 이런 데이터 구조를 일반적인 템플릿으로 구현하고 이 구조에 대한 <code class=\"language-text\">fmap</code> 또한 직접 구현할 수 있어야한다.</p>\n<p>먼저 Haskell에서 재귀적인 합 타입으로 정의된 트리 데이터 구조를 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Tree</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Leaf</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Node</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Tree</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Tree</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Functor</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>앞서 언급한 대로, C++에서 합 타입을 구현하는 방법 중 하나는 바로 클래스 계층 구조를 이용하는 것이다. 객체지향 언어에서는 기본 클래스 <code class=\"language-text\">Functor</code>의 가상 함수(Virtual functions)로 <code class=\"language-text\">fmap</code>을 구현한 뒤 모든 하위 클래스에서 이를 재정의하는 방향이 자연스러울 것이다.</p>\n<p>하지만 아쉽게도 이런 방법을 사용하는 것은 불가능하다. 왜냐하면 결국 <code class=\"language-text\">fmap</code>은 템플릿이며, 이는 <code class=\"language-text\">this</code> 포인터로 전달되는 객체의 타입 뿐 아니라 적용된 함수의 반환 타입이 매개변수화되어야 한다는 것을 의미한다. 하지만 C++에서는 가상 함수를 템플릿화 할 수 없다. 대신 우리는 <code class=\"language-text\">dynamic_cast</code>를 사용하여 패턴 매칭을 대체하고 <code class=\"language-text\">fmap</code>을 일반적인 자유 함수로 구현할 것이다.</p>\n<p>기본 클래스는 동적 캐스팅을 지원하기 위해 최소 하나의 가상 함수를 정의해야하며, 이 경우 우리는 소멸자(Destructor)를 가상 함수로 정의할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Tree</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">virtual</span> <span class=\"token operator\">~</span><span class=\"token function\">Tree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>숨겨진 <code class=\"language-text\">Identity</code> 펑터인 <code class=\"language-text\">Leaf</code>를 정의하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Leaf</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Tree</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n    T _label<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Leaf</span><span class=\"token punctuation\">(</span>T l<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_label</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">Node</code>는 곱 타입으로 정의할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Tree</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n    Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> _left<span class=\"token punctuation\">;</span>\n    Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> _right<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> l<span class=\"token punctuation\">,</span> Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_left</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">_right</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">fmap</code>을 구현할 때는 <code class=\"language-text\">Tree</code>의 타입에 따른 동적 디스패치를 활용할 것이다. <code class=\"language-text\">Leaf</code>의 경우에는 <code class=\"language-text\">Identify</code> 버전의 <code class=\"language-text\">fmap</code>을 적용하고, <code class=\"language-text\">Node</code>의 경우에는 두 개의 <code class=\"language-text\">Tree</code> 펑터의 복사본과 결합된 이항 펑터처럼 처리할 것이다. 물론 C++ 프로그래머들은 이런 사고 방식과 용어로 코드를 분석하는 것에 익숙하지 않을 수 있지만, 이 모든 과정이 결국 카테고리론적 사고를 연습하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nTree<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token operator\">*</span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> Tree<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Leaf<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> pl <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">dynamic_cast</span> <span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Leaf<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token operator\">*</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pl<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token generic-function\"><span class=\"token function\">Leaf</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span> <span class=\"token punctuation\">(</span>pl<span class=\"token operator\">-></span>_label<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> pn <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">dynamic_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Node<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token operator\">*</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pn<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token generic-function\"><span class=\"token function\">Node</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> pn<span class=\"token operator\">-></span>_left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> pn<span class=\"token operator\">-></span>_right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서는 간결함을 위해 메모리나 리소스 관리 문제를 무시하고 있지만, 실제 코드에서는 정책에 따라 <code class=\"language-text\">unique</code>나 <code class=\"language-text\">shared</code> 같은 스마트 포인트를 사용할 것이다.</p>\n<p>이렇게 C++로 작성한 <code class=\"language-text\">Tree</code>의 <code class=\"language-text\">fmap</code>을 Haskell에서 작성한 버전으로 바꿔보자면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Tree</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Leaf</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Leaf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Node</span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">t'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Node</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t'</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그리고 이 역시 <code class=\"language-text\">DeriveFunctor</code> 확장 기능을 사용하면 컴파일러에 의해 자동으로 구현될 수 있다.</p>\n<h2 id=\"85-writer-펑터\" style=\"position:relative;\">8.5 Writer 펑터<a href=\"#85-writer-%ED%8E%91%ED%84%B0\" aria-label=\"85 writer 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이전에 설명했던 <a href=\"/2024/02/20/category-theory-for-programmers-4-kleisli-category\">크라이슬리 카테고리(Kleisli Category)</a> 섹션에서 <code class=\"language-text\">Writer</code> 펑터에 대해서 다시 설명하겠다고 했던 것을 기억하는가? 해당 카테고리에서의 사상들은 꾸며진(embellished) 함수로 표현되어 <code class=\"language-text\">Writer</code> 데이터 구조를 반환했었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>필자는 이렇게 꾸며진 기능이 어떤 방식으로든 엔도 펑터와 관련이 있다고 말했다. 그리고 실제로 <code class=\"language-text\">Writer</code> 타입 생성자는 <code class=\"language-text\">a</code>에 대해 펑터적이다. 심지어 이를 위해 <code class=\"language-text\">fmap</code>을 구현할 필요도 없다. 왜냐하면 반환된 타입은 단순한 곱 타입이기 떄문이다.</p>\n<p>일반적으로 크라이슬리 카테고리와 펑터 간의 관계는 다음과 같다. 크라이슬리 카테고리는 카테고리이기 때문에 합성과 항등성을 정의해야한다. 그리고 합성은 fish(<code class=\"language-text\">>=></code>) 연산자에 의해 제공된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">>=></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">m1</span> <span class=\"token operator\">>=></span> <span class=\"token hvariable\">m2</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m1</span> <span class=\"token hvariable\">x</span>\n        <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m2</span> <span class=\"token hvariable\">y</span>\n    <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 항등 사상은 <code class=\"language-text\">return</code>이라고 불리는 함수를 통해 제공했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">return</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span> <span class=\"token builtin\">return</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 이 두 함수들의 타입을 오랜 시간 들여다 보다보면, <code class=\"language-text\">fmap</code>으로 사용할 수 있는 올바른 타입의 함수를 생성하는 방법을 찾을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">id</span> <span class=\"token operator\">>=></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token builtin\">return</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 예시에서 fish 연산자는 우리에게 익숙한 <code class=\"language-text\">id</code>, 그리고 인수에 <code class=\"language-text\">f</code>를 적용한 결과에 다시 <code class=\"language-text\">return</code>을 적용한 람다, 두 함수를 합성한다.</p>\n<p>아마 여기서 가장 이해하기 어려운 부분은 <code class=\"language-text\">id</code>의 사용법일 것이다. fish 연산자의 인수는 <code class=\"language-text\">Int</code>, <code class=\"language-text\">Bool</code>과 같은 일반 타입을 가져와서 꾸며진(embellished) 타입을 반환하는 함수여야 한다고 생각할 수 있겠지만 사실은 아니다. 아무도 <code class=\"language-text\">a -> Writer b</code>에서의 <code class=\"language-text\">a</code>가 일반 타입이어야 한다고 한 적은 없다. 이것은 그저 타입 변수일뿐이므로 어떤 것이든 될 수 있으며, 심지어 <code class=\"language-text\">Writer b</code>와 같이 이미 꾸며진 타입이 될 수도 있다.</p>\n<p>그래서 <code class=\"language-text\">id</code>는 <code class=\"language-text\">Writer a</code>를 받아서 그대로 <code class=\"language-text\">Writer a</code>를 반환할 것이다. fish 연산자는 <code class=\"language-text\">a</code>의 값을 꺼내어 람다의 <code class=\"language-text\">x</code> 인자로 전달할 것이다. 이후 <code class=\"language-text\">f</code>는 그것을 <code class=\"language-text\">b</code>로 변환하고, <code class=\"language-text\">return</code>은 이 결과를 꾸며 최종적으로 <code class=\"language-text\">Writer b</code>로 만들 것이다. 이 모든 것을 조합한다면 우리는 <code class=\"language-text\">Writer a</code>를 가져와 <code class=\"language-text\">Writer b</code>를 반환하는 함수를 얻게된다. 즉, <code class=\"language-text\">Writer</code>의 <code class=\"language-text\">fmap</code>이 해야하는 것과 정확히 같은 일을 하는 것이다.</p>\n<p>이 정의에서 <code class=\"language-text\">Writer</code>는 다른 임의의 타입 생성자로 변경될 수 있기 때문에 이 인자는 매우 일반적이라고 할 수 있다. 뭐가 되었던 fish 연산자와 <code class=\"language-text\">return</code>을 지원한다면 이를 활용하여 <code class=\"language-text\">fmap</code>을 정의할 수 있다는 것이다. 따라서 크라이슬리 카테고리에서의 장식(embellishment)은 항상 펑터라고 할 수 있다.</p>\n<p>사실 우리가 방금 정의했던 <code class=\"language-text\">fmap</code>과 <strong><code class=\"language-text\">deriving Functor</code></strong> 확장 기능을 통해 컴파일러가 생성해주는 <code class=\"language-text\">fmap</code>은 동일하다. 이는 Haskell이 다형성 함수를 구현하는 방식 때문인데, 이를 매개변수 다형성(Parametric polymorphism)이라고 하며, 공짜 정리(Theorems for free)라고 불리는 정리의 원천이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>매개변수 다형성(Parametric polymorphism)은 함수나 데이터 유형이 여러 타입에 대해 동작할 수 있도록 하는 기능이며, 타입스크립트의 Generic Type도 매개변수 다형성의 구현 중 하나이다.</p>\n<p>공짜 정리(Theorems for free)는 어떤 하나의 정리를 통해 다른 정리가 추가적인 증명없이도 자동으로 성립하는 것을 의미하므로, 매개변수 다형성 또한 공짜 정리의 한 측면이라고 볼 수 있는 것이다. 타입스크립트로 예를 들자면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">nonEmptyArray</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>arr<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">nonEmptyArray</code> 함수는 인자가 <code class=\"language-text\">number[]</code> 타입이든 <code class=\"language-text\">string[]</code> 타입이든 상관없이 일관된 동작을 제공한다. 즉, 다형적인 동작이 제대로 정의되었다면, <code class=\"language-text\">number[]</code> 타입에 대해 제대로 작동한다는 사실이 증명됨과 함께 <code class=\"language-text\">string[]</code> 타입에 대한 동작이 제대로 작동한다는 보장도 함께 공짜로 성립되는 것이다.</p>\n</blockquote>\n<p>이러한 정리가 의미하는 것 중 하나는 특정 타입 생성자에 대한 <code class=\"language-text\">fmap</code>이 존재하고 이 함수가 항등성을 보존하고 있다면, 그 구현 방법은 유일해야 한다는 것이다.</p>\n<h2 id=\"86-공변적-펑터와-반공변적-펑터covariant-and-contravariant-functors\" style=\"position:relative;\">8.6 공변적 펑터와 반공변적 펑터(Covariant and Contravariant Functors)<a href=\"#86-%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0%EC%99%80-%EB%B0%98%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0covariant-and-contravariant-functors\" aria-label=\"86 공변적 펑터와 반공변적 펑터covariant and contravariant functors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">Writer</code> 펑터에 대해서 살펴보았으니, <code class=\"language-text\">Reader</code> 펑터도 다시 한번 살펴보자. 다시 한번 이야기하지만 <code class=\"language-text\">Reader</code> 펑터는 부분적용된 함수 화살표 타입 생성자를 기반으로 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">r</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 정의를 타입 동의어를 사용하여 다시 작성해보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Reader</span> <span class=\"token hvariable\">r</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">r</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 <code class=\"language-text\">Reader</code>의 <code class=\"language-text\">Functor</code> 인스턴스는 아래와 같이 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">g</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>쌍 타입 생성자나 <code class=\"language-text\">Either</code> 타입 생성자와 마찬가지로 함수 타입 생성자 또한 두 개의 타입 인자를 받는다. 기억을 되짚어보면 쌍과 <code class=\"language-text\">Either</code>는 자신들이 받는 각각의 인자에 대해 펑터적이었고, 이를 이항 펑터(bifunctor)라고 한다고 했다. 그렇다면 함수 생성자도 두 개의 타입 인자를 받고 있으니 이들과 동일하게 이항 펑터일까?</p>\n<p>백문이불여일견이니 직접 확인해보자. 우선 첫 번째 인자에 대해 펑터적인지 확인해보겠다. 우선 타입 동의어에서부터 시작해볼 것이다. 아래 정의는 <code class=\"language-text\">Reader</code>에서 단지 인수의 순서만 뒤바뀐 형태이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Op</span> <span class=\"token hvariable\">r</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 반환 타입인 <code class=\"language-text\">r</code>을 고정하고 인수 타입인 <code class=\"language-text\">a</code>에 변형을 가할 것이다. 그리고 <code class=\"language-text\">a</code>를 변형하는 <code class=\"language-text\">fmap</code>을 구현하기 위한 타입 시그니처는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>인수로 <code class=\"language-text\">a</code>를 받고 각각 <code class=\"language-text\">b</code>와 <code class=\"language-text\">r</code>을 반환하는 두 개의 함수만 있는 경우, 이들을 사용하여 <code class=\"language-text\">b</code>를 받아 <code class=\"language-text\">r</code>을 반환하는 함수를 만들 수 있는 방법은 존재하지 않는다.</p>\n<p>하지만 첫 번째 함수를 반대로 뒤집을 수 있다면 상황은 달라진다. 즉, 첫 번째 함수가 <code class=\"language-text\">b</code>를 받아 <code class=\"language-text\">a</code>를 반환하는 함수가 되도록 만들어주면 되는 것이다. 우리는 임의의 함수를 막 뒤집을 수는 없지만, 반대 카테고리로 이동해볼 수는 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>필자가 <code class=\"language-text\">Reader</code>에 대한 설명을 하다가 갑자기 반대 카테고리에 대한 이야기를 하고 있어서 설명의 흐름이 어색하다. 결과적으로 말하자면 <code class=\"language-text\">Reader r a</code>는 두 인자를 받아 <code class=\"language-text\">r</code>을 <code class=\"language-text\">a</code>로 변형하는 매핑을 의미하기 때문에 이항 펑터가 아니다.</p>\n<p>앞서 보았던 쌍이나 <code class=\"language-text\">Either</code>의 경우 자신들이 받는 인수의 순서를 변경하더라도 연산의 결과는 동일하게 보장된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 패턴 매칭을 통해 연산을 적용하기 때문에</span>\n<span class=\"token comment\">-- 인자의 순서가 g f (x, y)가 되어도 f는 x에, g는 y에 적용된다.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그러나 <code class=\"language-text\">Reader</code> 펑터의 <code class=\"language-text\">fmap</code>은 함수의 합성이기 때문에 첫 번째 인자의 결과가 두 번째 인자에 의존하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n\t  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">g</span>\n<span class=\"token comment\">-- 만약 합성의 순서가 g . f가 된다면 연산 결과가 달라지거나</span>\n<span class=\"token comment\">-- 혹은 합성 자체가 불가능한 상황이 발생할 수도 있다.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>필자는 이러한 <code class=\"language-text\">Reader</code> 펑터의 특성을 보이기 위해, 인수의 순서를 반대로 뒤집은 <code class=\"language-text\">Op</code>라는 타입을 예로 들어 설명하고 있는 것이다.</p>\n</blockquote>\n<p>반대 카테고리가 기억나지 않을 수 있으니 간단하게 복습해보자. 모든 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에 대한 반대 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 같은 대상들을 가지고 있지만 모든 화살표(사상)의 방향이 반대로 뒤집어진 카테고리이다.</p>\n<p>그럼 이제 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>와 다른 임의의 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 사이를 이동하는 펑터를 떠올려보자.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo>:</mo><mo>:</mo><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">F::C^{op} → D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span></div>\n<p>이런 펑터는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>의 어떤 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f^{op} :: a → b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">F f^{op} :: F a → F b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>로 매핑한다. 그러나 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">f^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>는 원래 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서의 어떤 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mo>:</mo><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">f :: b → a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>에 해당한다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>가 서로 반전되어있음에 주목하자.</p>\n<p>이렇게 반대 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>에서 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 나아가는 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>를 정의했다. 그렇다면 이제 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>를 사용하여 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 바로 나아가는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>라는 매핑도 생각해볼 수 있다. 즉, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로의 매핑이다. 하지만 사실 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>는 펑터가 아니다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 마찬가지로 대상들을 동일하게 매핑하지만, 사상을 매핑할 때는 반대로 뒤집어서 매핑하기 때문이다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mo>:</mo><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">f :: b → a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>를 반대 사상인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f^{op} :: a → b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>로 매핑한 다음, 이를 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에 적용하여 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">F f^{op} :: F a→F b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 얻어야 한다.</p>\n<p>주어진 조건에 따라 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">Fa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">Ga</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 동일하고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">Fb</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">Gb</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">b</span></span></span></span></span>와 동일하다고 가정할 때, 전체적인 흐름은 아래와 같이 나타내볼 수 있다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>G</mi><mi>f</mi><mo>:</mo><mo>:</mo><mo stretchy=\"false\">(</mo><mi>b</mi><mo>→</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><mi>G</mi><mi>a</mi><mo>→</mo><mi>G</mi><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G f :: (b → a) → (G a → G b) \t\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span></div>\n<p>이렇게 사상의 방향을 반전하는 카테고리 간의 매핑을 반공변적 펑터(Contravariant Functor)라고 한다. 반공변적 펑터는 반대 카테고리에서의 일반적인 펑터일 뿐이다. 그리고 우리가 지금까지 공부해왔던 일반적인 펑터는 공변적 펑터(Covariant Functor)라고 한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 530px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2675b6c5c6369f38ae301b55685cd3b0/d0861/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 98.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAQEAAwAAAAAAAAAAAAAAAAIBAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQD/2gAMAwEAAhADEAAAAfTrYbuIFOA8oT//xAAbEAACAwADAAAAAAAAAAAAAAABAgADEhEhMv/aAAgBAQABBQKx3BqZiY/OjrKeGUGFBkdD/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQESEx/9oACAEBAAY/AqQ75GMeiLn/xAAbEAACAgMBAAAAAAAAAAAAAAAAARFBITFREP/aAAgBAQABPyGplMqy742MHZDRa3g7JxslGmR9l0SBKj//2gAMAwEAAgADAAAAEMMIvP/EABYRAAMAAAAAAAAAAAAAAAAAABARQf/aAAgBAwEBPxBxCD//xAAWEQADAAAAAAAAAAAAAAAAAAARICH/2gAIAQIBAT8QgT//xAAcEAEBAQEAAgMAAAAAAAAAAAABESEAUWEQMZH/2gAIAQEAAT8QZnGXyeeLLQNEV9evjYwTJsXzxm5dOP3lb5xq3ldAT75DDobmcddABe//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/2675b6c5c6369f38ae301b55685cd3b0/d0861/5.jpg\" srcset=\"/static/2675b6c5c6369f38ae301b55685cd3b0/0913d/5.jpg 160w,\n/static/2675b6c5c6369f38ae301b55685cd3b0/cb69c/5.jpg 320w,\n/static/2675b6c5c6369f38ae301b55685cd3b0/d0861/5.jpg 530w\" sizes=\"(max-width: 530px) 100vw, 530px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>아래는 Haskell에서 반공변적인 (엔도)펑터를 정의하는 타입 클래스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Contravariant</span> <span class=\"token hvariable\">f</span> <span class=\"token keyword\">where</span>\n  \t<span class=\"token hvariable\">contramap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, 아까 정의했던 타입 생성자 <code class=\"language-text\">Op</code>의 인스턴스는 아래와 같이 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Contravariant</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n  \t<span class=\"token comment\">-- (b -> a) -> Op r a -> Op r b</span>\n  \t<span class=\"token hvariable\">contramap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>함수 <code class=\"language-text\">f</code>가 <code class=\"language-text\">Op</code>의 내용인 함수 <code class=\"language-text\">g</code>의 앞에 자신을 삽입한다는 것에 주목하자. (함수 합성의 연산 순서는 오른쪽에서 왼쪽이다.)</p>\n<p>여기서 <code class=\"language-text\">Op</code>의 <code class=\"language-text\">contramap</code>의 정의는 단지 인자를 뒤집은 함수 합성 연산자일 뿐이라는 것을 알 수 있으며, 이 사실을 알았다면 이제 더 간결하게 만들어 볼 수도 있다.</p>\n<p>여기 인자를 뒤집는데 사용되는 특수한 함수인 <code class=\"language-text\">flip</code>이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">flip</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">flip</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">y</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러면 이제 <code class=\"language-text\">contramap</code>의 정의를 이렇게 간단하게 바꿔볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">contramap</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">flip</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2 id=\"87-프로펑터profunctors\" style=\"position:relative;\">8.7 프로펑터(Profunctors)<a href=\"#87-%ED%94%84%EB%A1%9C%ED%8E%91%ED%84%B0profunctors\" aria-label=\"87 프로펑터profunctors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리는 함수 화살표 연산자가 첫 번째 인자에서 반공변 변형이 되고, 두 번째 인자에서 공변 변형이 되는 상황을 보았다. 이런 개념에 대한 명칭도 있을까?</p>\n<p>만약 대상 카테고리가 <em>Set</em>이라면 이 개념을 프로펑터(Profunctor)라고 부른다. 반공변적 펑터는 반대 카테고리에서의 공변적 펑터와 동일하기 때문에, 프로펑터는 아래와 같이 정의된다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>×</mo><mi>D</mi><mo>→</mo><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">C^{op} × D → Set \t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7977em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span></span></span></span></span></div>\n<p>일단 Haskell 타입을 집합이라고 가정해보면, 우리는 첫 번째 인자에 대해 반공변적 펑터적이고 두 번째 인자에 대해서는 펑터적인 두 개의 인자를 받는 타입 생성자 <code class=\"language-text\">p</code>에 <code class=\"language-text\">Profuctor</code>라는 이름을 부여할 수 있다. 아래는 <code class=\"language-text\">Data.Profuctor</code> 라이브러리에서 가져온 타입 클래스의 모습이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Profunctor</span> <span class=\"token hvariable\">p</span> <span class=\"token keyword\">where</span>\n  \t<span class=\"token hvariable\">dimap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">d</span>\n  \t<span class=\"token hvariable\">dimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">lmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">rmap</span> <span class=\"token hvariable\">g</span>\n  \t<span class=\"token hvariable\">lmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">c</span>\n  \t<span class=\"token hvariable\">lmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">dimap</span> <span class=\"token hvariable\">f</span> <span class=\"token builtin\">id</span>\n  \t<span class=\"token hvariable\">rmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">c</span>\n    <span class=\"token hvariable\">rmap</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">dimap</span> <span class=\"token builtin\">id</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>세 함수 모두 기본 구현이 제공된다. <code class=\"language-text\">Bifunctor</code>와 마찬가지로 <code class=\"language-text\">Profuctor</code>의 인스턴스를 선언할 때는 <code class=\"language-text\">dimap</code>을 구현하고 <code class=\"language-text\">lmap</code>과 <code class=\"language-text\">rmap</code>에 대한 기본값을 사용하거나, 혹은 <code class=\"language-text\">lmap</code>과 <code class=\"language-text\">rmap</code>을 모두 구현하고 <code class=\"language-text\">dimap</code>에 대한 기본값을 사용할 수 있는 선택권이 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 497px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8c3e7c302a315abaa1d56875acd0c0f8/fce5f/6.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 81.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHXTVAto0T/xAAaEAEAAgMBAAAAAAAAAAAAAAABAAIDERIx/9oACAEBAAEFAu0u5LTHvlqQGHn/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwEJ/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAwADAAAAAAAAAAAAAAAAABARITJB/9oACAEBAAY/ApxZLKaL/8QAGxABAAICAwAAAAAAAAAAAAAAAQARITFRgZH/2gAIAQEAAT8hdKZU4rp1PYl1dnEKtMzBQxU//9oADAMBAAIAAwAAABAbz//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/EGZ//8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/ENCf/8QAHBABAAMBAQADAAAAAAAAAAAAAQARITFRQWFx/9oACAEBAAE/EEiAW29I9Djvo5+zSoVenzHWlK+2QAU1W3V3WQhFAc8n/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"\" src=\"/static/8c3e7c302a315abaa1d56875acd0c0f8/fce5f/6.jpg\" srcset=\"/static/8c3e7c302a315abaa1d56875acd0c0f8/0913d/6.jpg 160w,\n/static/8c3e7c302a315abaa1d56875acd0c0f8/cb69c/6.jpg 320w,\n/static/8c3e7c302a315abaa1d56875acd0c0f8/fce5f/6.jpg 497w\" sizes=\"(max-width: 497px) 100vw, 497px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>여기까지 왔으면 이제 함수 화살표 연산자가 <code class=\"language-text\">Profuctor</code>의 인스턴스라는 것을 단언할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Profunctor</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">dimap</span> <span class=\"token hvariable\">ab</span> <span class=\"token hvariable\">cd</span> <span class=\"token hvariable\">bc</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">cd</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">bc</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">ab</span>\n    <span class=\"token hvariable\">lmap</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">flip</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n    <span class=\"token hvariable\">rmap</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>프로펑터는 Haskell 렌즈 라이브러리에서 응용되고 있으며, 추후 ends와 coends에 대해 이야기할 때 다시 한번 자세히 설명할 것이다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240402-category-theory-for-programmers-8-functoriality","path":"/2024/04/02/category-theory-for-programmers-8-functoriality/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 8. 펑터의 특성","subTitle":null,"date":"Apr 02, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"229edda2-bbc2-5edd-b61a-9b3cededad81","tableOfContents":"<ul>\n<li>\n<p><a href=\"#71-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0\">7.1 프로그래밍에서의 펑터</a></p>\n<ul>\n<li><a href=\"#711-maybe-%ED%8E%91%ED%84%B0\">7.1.1 Maybe 펑터</a></li>\n<li><a href=\"#712-%EB%B0%A9%EC%A0%95%EC%8B%9D-%EC%B6%94%EB%A1%A0equational-reasoning\">7.1.2 방정식 추론(Equational Reasoning)</a></li>\n<li><a href=\"#713-optional\">7.1.3 Optional</a></li>\n<li><a href=\"#714-%ED%83%80%EC%9E%85-%ED%81%B4%EB%9E%98%EC%8A%A4typeclasses\">7.1.4 타입 클래스(Typeclasses)</a></li>\n<li><a href=\"#715-c%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0functor-in-c\">7.1.5 C++에서의 펑터(Functor in C++)</a></li>\n<li><a href=\"#716-list-%ED%8E%91%ED%84%B0\">7.1.6 List 펑터</a></li>\n<li><a href=\"#717-reader-%ED%8E%91%ED%84%B0\">7.1.7 Reader 펑터</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#72-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%A1%9C%EC%8D%A8%EC%9D%98-%ED%8E%91%ED%84%B0\">7.2 컨테이너로써의 펑터</a></p>\n</li>\n<li>\n<p><a href=\"#73-%ED%8E%91%ED%84%B0-%ED%95%A9%EC%84%B1functor-composition\">7.3 펑터 합성(Functor Composition)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></p>\n</li>\n</ul>","excerpt":"이번 챕터에서는 펑터(Functor)에 대해서 이야기를 해보려고 한다. 펑터는 간단하지만 매우 강력한 개념이며 카테고리 이론은 이처럼 간단하지만 강력한 아이디어로 가득 차있다. 펑터는 카테고리 간의 매핑이다. 즉, 두 카테고리 와 가 주어졌을 때, 펑터 는 카테고리 의 대상을 카테고리 의 대상으로 매핑하는 것이며, 결국 대상들에 대한 함수라고 볼 수 있다. 만약 카테고리 의 대상을 라고 한다면, 우리는 매핑된 카테고리 의 대상을 라고 표현할 수 있다. 하지만 카테고리는 대상으로만 구성되어있지 않으며 대상과 그들을 연결하는 사상까지…","html":"<p>이번 챕터에서는 펑터(Functor)에 대해서 이야기를 해보려고 한다. 펑터는 간단하지만 매우 강력한 개념이며 카테고리 이론은 이처럼 간단하지만 강력한 아이디어로 가득 차있다.</p>\n<p>펑터는 카테고리 간의 매핑이다. 즉, 두 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>가 주어졌을 때, 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 대상을 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상으로 매핑하는 것이며, 결국 대상들에 대한 함수라고 볼 수 있다.</p>\n<p>만약 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 대상을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>라고 한다면, 우리는 매핑된 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">F a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span></span></span></span></span>라고 표현할 수 있다. 하지만 카테고리는 대상으로만 구성되어있지 않으며 대상과 그들을 연결하는 사상까지 모두 포함하는 개념이다. 즉, 펑터는 대상 뿐 아니라 사상 또한 매핑하며, 이런 경우에는 사상에 대한 함수라고 볼 수도 있다. 그렇다고 펑터가 마음대로 사상을 매핑하는 것은 아니고, 반드시 사상으로 연결된 대상들의 구조를 그대로 보존해야 한다.</p>\n<p>만약 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에 있는 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>가 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 연결하고 있다면,</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>펑터를 통해 매핑된 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에 있는 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">F f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> 또한 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 동일한 구조로 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">F a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">F b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 연결해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 548px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/53ed4e9ec17829d825f87748ed6a6e02/a8866/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAMCBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9adM10MorISoX//EABoQAQACAwEAAAAAAAAAAAAAAAECEgARIjH/2gAIAQEAAQUCktpOiG6zenyCpgFs/8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQMBAT8BY//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABoQAAICAwAAAAAAAAAAAAAAAAAQAREhUcH/2gAIAQEABj8CNmVfXK//xAAbEAACAwEBAQAAAAAAAAAAAAABEQAhMUFREP/aAAgBAQABPyEVHT9hC0CfJQ7hlByUwfFaYknwwh7MmPn/2gAMAwEAAgADAAAAEODAvP/EABgRAAMBAQAAAAAAAAAAAAAAAAABMRAR/9oACAEDAQE/EOUUdWf/xAAWEQEBAQAAAAAAAAAAAAAAAAABEDH/2gAIAQIBAT8QCGT/xAAfEAEAAgICAgMAAAAAAAAAAAABETEAIUFREIGRwdH/2gAIAQEAAT8Q3IVVhAlz6yHKYJk/cvqubuOMAcKrQd85WGzaKH3iBSTs5MAQBOkw0XxeP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/53ed4e9ec17829d825f87748ed6a6e02/a8866/1.jpg\" srcset=\"/static/53ed4e9ec17829d825f87748ed6a6e02/0913d/1.jpg 160w,\n/static/53ed4e9ec17829d825f87748ed6a6e02/cb69c/1.jpg 320w,\n/static/53ed4e9ec17829d825f87748ed6a6e02/a8866/1.jpg 548w\" sizes=\"(max-width: 548px) 100vw, 548px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>여기서 알 수 있듯이 펑터는 카테고리의 구조를 그대로 보존한다. 한 카테고리 내에서 연결되어있는 것들은 펑터를 통해 매핑된 카테고리에서도 그대로 연결되어 있는 것이다. 이에 더해 카테고리에는 단순히 대상을 사상으로 연결하는 것 뿐 아니라 사상 간의 합성이라는 개념 또한 존재한다.</p>\n<p>사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>의 합성사상인 상황을 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">h</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그렇다면 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>를 통해 만들어진 카테고리의 사상들의 합성 관계도 이와 동일하게 유지된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> <span class=\"token hvariable\">h</span> <span class=\"token operator\">=</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 384px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6c626a002083ba1ab990172bf55de07e/4ecad/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 108.74999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAWABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMCBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe3msioEwqD/xAAaEAACAwEBAAAAAAAAAAAAAAAAAQIRIRAS/9oACAEBAAEFAnI9ULVaFURaUhR5/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAwADAQAAAAAAAAAAAAAAAAEhEDFRQf/aAAgBAQAGPwKJnct+ENFvMf/EABwQAQADAAIDAAAAAAAAAAAAAAEAESEQUWFxgf/aAAgBAQABPyGnFPqWvrm4qHuJNLvUYUUtiBasmy03xN3IH4OP/9oADAMBAAIAAwAAABBTxzz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAcEAEBAAMBAAMAAAAAAAAAAAABEQAhMUGBkcH/2gAIAQEAAT8QZINb4MQEg2zXeW5NRIsfMJBvlbfjFom723m8HkXiNHFUK9MbyEyDc6TX3+YAGgPdZ//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/6c626a002083ba1ab990172bf55de07e/4ecad/2.jpg\" srcset=\"/static/6c626a002083ba1ab990172bf55de07e/0913d/2.jpg 160w,\n/static/6c626a002083ba1ab990172bf55de07e/cb69c/2.jpg 320w,\n/static/6c626a002083ba1ab990172bf55de07e/4ecad/2.jpg 384w\" sizes=\"(max-width: 384px) 100vw, 384px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>마지막으로 우리는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span> 안의 모든 항등사상들이 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 항등사상들로 매핑되는 상황 또한 생각해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> <span class=\"token hvariable\">id_a</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">id_Fa</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><msub><mi>d</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">id_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>는 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>의 항등사상이며, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><msub><mi>d</mi><mi>F</mi></msub><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">id_Fa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span></span></span></span></span>는 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">F a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span></span></span></span></span>의 항등사상이다. 이처럼 항상 카테고리의 구조를 보존해야한다는 조건들로 인해 펑터는 일반적인 함수보다 더 제한적인 개념이 된다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 302px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b3c6b68dbbf4939beb37c24ad5731725/7a297/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 133.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHuU0ErCuO4JH//xAAbEAACAgMBAAAAAAAAAAAAAAAAAQIRAyAiIf/aAAgBAQABBQKVnTFY1ZGKih+LH09P/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAQUBAAAAAAAAAAAAAAAAAQAQESAhMf/aAAgBAQAGPwLDC6taA5INf//EABwQAQACAgMBAAAAAAAAAAAAAAEAERAhMUFRYf/aAAgBAQABPyE1vSHq4fCnJU0cL+TX2leToZhWMQgJe/LwglJcAOMf/9oADAMBAAIAAwAAABBDCDD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAdEAEAAgIDAQEAAAAAAAAAAAABESEAQRAxUWGB/9oACAEBAAE/EHbOPb38vK5B42BPO+3NWPpWHfOzaJ+OEDYbWVfV28GghBti8E+IR7Qsvz5viBAeJOAUCWaOP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/b3c6b68dbbf4939beb37c24ad5731725/7a297/3.jpg\" srcset=\"/static/b3c6b68dbbf4939beb37c24ad5731725/0913d/3.jpg 160w,\n/static/b3c6b68dbbf4939beb37c24ad5731725/7a297/3.jpg 302w\" sizes=\"(max-width: 302px) 100vw, 302px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>만약 어떤 카테고리를 각 대상들이 사상으로 연결되어있는 일종의 네트워크라고 상상해보자. 펑터는 각 대상과 사상을 그저 매핑하는 개념일뿐이므로 네트워크의 요소들을 서로 분리해내는 것은 절대 불가능하다. 펑터로 대상들을 합칠 수도 있고 여러 사상들을 하나로 붙혀놓을 수도 있겠지만 분해하는 것은 불가능한 것이다.</p>\n<p>이와 같이 분해가 불가능하다는 제약은 미적분에서 볼 수 있는 연속성의 조건과 유사하다. 이런 의미에서 펑터는 “연속적”이라고 볼 수도 있다. 또한 마치 정의역과 공역의 관계를 축소나 포함이라는 시각으로 바라보는 것과 유사하게 펑터 또한 동일한 시각으로 바라볼 수 있다. 예를 들면 펑터의 소스가 되는 카테고리가 대상 카테고리보다 더 작을 때는 포함과 같은 개념으로 볼 수 있는 것이다.</p>\n<p>한번 극단적인 예시를 생각해보자. 펑터의 소스가 되는 카테고리는 단 하나의 대상과 하나의 항등사상만으로 이루어진 단일대상 카테고리가 될 수도 있다. 이처럼 단일대상 카테고리를 다른 카테고리로 매핑하는 펑터는 단순히 해당 카테고리에서 하나의 대상을 선택하는 것과 다를 게 없다. 이는 단일원소집합에서 하나의 원소를 선택하는 사상의 특성과 완전히 유사하다.</p>\n<p>소스 카테고리를 최대한 축소하는 펑터는 상수 펑터(Constant Functor), <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span><span class=\"mord mathnormal\">c</span></span></span></span></span>로 불린다. 이 펑터는 소스 카테고리의 모든 대상을 대상 카테고리에서 선택된 하나의 대상인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></span>로, 그리고 소스 카테고리의 모든 사상을 항등사상인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><msub><mi>d</mi><mi>c</mi></msub></mrow><annotation encoding=\"application/x-tex\">id_c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 매핑한다. 이 펑터는 마치 블랙홀처럼 작동하여 모든 것을 하나의 특이점으로 압축해버린다. 우리가 추후 한계(Limits)와 공한계(Colimits)에 대해 이야기할 때 이러한 펑터를 더 자세히 살펴볼 것이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>작가의 설명만 보면 마치 상수 펑터(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span><span class=\"mord mathnormal\">c</span></span></span></span></span>)가 어떤 카테고리를 다른 카테고리로 매핑하며 압축하는 녀석으로 보일 수 있지만, 사실 상수 펑터는 특정 카테고리를 자기 자신으로 매핑하는 엔도펑터(EndoFunctor)이다. (엔도펑터에 대한 설명은 바로 다음 섹션에 나온다.)</p>\n<p>즉, 상수 펑터는 어떤 카테고리의 모든 대상을 그 카테고리 내의 대상 하나로 매핑(압축)하는 개념이라고 보면 된다. 이 과정에서 카테고리의 대상들을 연결하던 임의의 사상들은 모두 선택된 대상의 항등 사상으로 매핑된다.</p>\n</blockquote>\n<h2 id=\"71-프로그래밍에서의-펑터\" style=\"position:relative;\">7.1 프로그래밍에서의 펑터<a href=\"#71-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0\" aria-label=\"71 프로그래밍에서의 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이제부터는 실질적인 프로그래밍에 대해서 이야기해보자. 이미 우리는 프로그래밍의 세계에서 타입과 함수로 이루어진 카테고리를 다루고 있다. 이번에는 이 카테고리를 자기 자신으로 매핑하는 펑터, 엔도펑터(EndoFunctor)에 대해서 생각해보려고 한다.</p>\n<p>자, 타입으로 이루어진 카테고리에서의 엔도펑터는 무엇일까? 이 펑터는 타입을 타입으로 매핑하는 펑터일 것이다. 사실 여러분은 이미 이러한 매핑의 예시를 숱하게 봐왔을테지만 단지 그것이 엔도펑터라는 것을 깨닿지 못 했을 뿐이다. 아래 몇 가지 예시를 한번 살펴보자.</p>\n<h3 id=\"711-maybe-펑터\" style=\"position:relative;\">7.1.1 Maybe 펑터<a href=\"#711-maybe-%ED%8E%91%ED%84%B0\" aria-label=\"711 maybe 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Maybe</code>의 정의는 어떠한 타입 <code class=\"language-text\">a</code>를 <code class=\"language-text\">Maybe a</code>라는 타입으로 매핑하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 중요한 포인트가 하나 있다. <code class=\"language-text\">Maybe</code> 자체는 타입이 아니라 타입 생성자(Type Constructor)라는 것이다. 타입 생성자를 타입으로 변환하기 위해서는 <code class=\"language-text\">Int</code>나 <code class=\"language-text\">Bool</code>과 같은 타입 인자를 생성자에게 제공해야 한다. 즉, 아무 인자로 받지 않는 <code class=\"language-text\">Maybe</code>는 타입에 대한 함수를 나타내는 것이다.</p>\n<p>그렇다면 <code class=\"language-text\">Maybe</code>를 펑터로 변환해볼 수 있을까? (프로그래밍 맥락에서 펑터에 대해 이야기할 때는 거의 항상 엔도펑터를 이야기한다는 사실을 유념하자.) 펑터는 대상(타입)의 매핑 뿐만 아니라 사상(함수)의 매핑도 모두 포함하는 개념이다. 한번 <code class=\"language-text\">a</code>에서 <code class=\"language-text\">b</code>로 나아가는 임의의 함수 <code class=\"language-text\">f</code>가 있다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 <code class=\"language-text\">Maybe a</code>에서 <code class=\"language-text\">Maybe b</code>로 나아가는 함수를 생성하고 싶다. 이러한 함수를 제대로 정의하기 위해서는 <code class=\"language-text\">Maybe</code>를 구성하는 두 생성자인 <code class=\"language-text\">Nothing</code>과 <code class=\"language-text\">Just</code>에 대해 고려해야한다.</p>\n<p><code class=\"language-text\">Nothing</code>의 경우에는 그저 <code class=\"language-text\">Nothing</code>을 반환해주기만 하면 되니 간단하다. 그리고 인자가 <code class=\"language-text\">Just</code>인 경우에는 함수 <code class=\"language-text\">f</code>를 <code class=\"language-text\">Just</code>가 가지고 있는 값에 적용해주면 될 것이다.</p>\n<p>즉, <code class=\"language-text\">Maybe</code>라는 펑터를 거친 <code class=\"language-text\">f</code>의 모습은 아래와 같은 함수가 된다. (Haskell에서는 변수명에 아포스트로피(<code class=\"language-text\">’</code>)를 사용할 수 있으며, 이 기능은 아래와 같은 경우에 매우 편리하다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f'</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">b</span>\n<span class=\"token hvariable\">f'</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token hvariable\">f'</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Haskell에서는 펑터가 사상을 매핑하는 행위를 <code class=\"language-text\">fmap</code>이라는 고차함수로 구현하며, <code class=\"language-text\">Maybe</code>의 경우에는 아래와 같은 정의가 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 469px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b4a1919d61c677ca0dd43a79a5bfd207/a76eb/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 73.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHbS2BwD//EABoQAQABBQAAAAAAAAAAAAAAAAESABARITH/2gAIAQEAAQUCllWLT3Zb/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAwADAAAAAAAAAAAAAAAAAAEQEUFR/9oACAEBAAY/AsI24js//8QAHhABAAICAQUAAAAAAAAAAAAAAQARMUEQIWFxgZH/2gAIAQEAAT8hr9DtELroxBsuk8xIAZ3KIp9+P//aAAwDAQACAAMAAAAQQM//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAEAAgIDAQEAAAAAAAAAAAABABEhQTFRYXGB/9oACAEBAAE/EHMd7InjUDW2mS38OcblXkNCmCU530ryaYHJgv7BUFKep//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/b4a1919d61c677ca0dd43a79a5bfd207/a76eb/4.jpg\" srcset=\"/static/b4a1919d61c677ca0dd43a79a5bfd207/0913d/4.jpg 160w,\n/static/b4a1919d61c677ca0dd43a79a5bfd207/cb69c/4.jpg 320w,\n/static/b4a1919d61c677ca0dd43a79a5bfd207/a76eb/4.jpg 469w\" sizes=\"(max-width: 469px) 100vw, 469px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>우리는 종종 <code class=\"language-text\">fmap</code>이 함수를 리프트(lift)한다고 말한다. 이렇게 리프팅된 함수는 이제 <code class=\"language-text\">Maybe</code> 타입의 값에 작용하는 함수가 되었다.</p>\n<p>또한 커링(Currting)으로 인해 위 정의는 하나의 함수 <code class=\"language-text\">a → b</code>를 받아서 다른 함수 <code class=\"language-text\">Maybe a → Maybe b</code>를 반환하는 함수, 그리고 <code class=\"language-text\">a → b</code>와 <code class=\"language-text\">Maybe a</code>라는 두 개의 인자를 받아 <code class=\"language-text\">Maybe b</code>를 반환하는 함수, 총 두 가지 방식으로 해석될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이러한 특성들을 기반으로 <code class=\"language-text\">Maybe</code>에 대한 <code class=\"language-text\">fmap</code>을 구현해보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">_</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 적용할 함수 f와 Just x를 인자로 받아,</span>\n<span class=\"token comment\">-- Just가 가진 값에 함수 f가 적용된 꼴인 Just (f x)를 반환한다.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>우리가 <code class=\"language-text\">Maybe</code> 타입 생성자와 <code class=\"language-text\">fmap</code> 함수가 펑터를 형성한다는 것을 보이기 위해서는 <code class=\"language-text\">fmap</code> 함수가 항등과 합성의 개념을 보존한다는 것을 증명해야한다. 이러한 것들을 “펑터 법칙(The Functor Laws)”이라는 거창한 이름으로 부르긴 하지만 사실은 그저 펑터가 카테고리의 구조를 보존한다는 것을 보장해야한다는 의미이다.</p>\n<h3 id=\"712-방정식-추론equational-reasoning\" style=\"position:relative;\">7.1.2 방정식 추론(Equational Reasoning)<a href=\"#712-%EB%B0%A9%EC%A0%95%EC%8B%9D-%EC%B6%94%EB%A1%A0equational-reasoning\" aria-label=\"712 방정식 추론equational reasoning permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>펑터 법칙을 증명하기 위해 방정식 추론(Equational Reasoning)을 사용해보려고 한다. 이는 Haskell에서 흔하게 사용되는 증명 기법인데, Haskell 함수가 좌변이 우변과 같다는 동등성(Equality)으로 정의된다는 사실을 이용하는 기법이다. 어떤 코드를 동작이 동일한 다른 코드로 대체할 수도 있고 변수명의 충돌을 피하기 위해 변수명을 변경할 수도 있는데, 이는 함수를 인라인화하는 행위나 반대로 표현식을 함수로 리팩토링하는 행위로 생각할 수도 있다. 한번 항등함수를 예시로 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">id</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이러한 함수가 존재한다면 이제 우리는 어떤 표현식에서 <code class=\"language-text\">id y</code>를 보았을 때, 이 코드를 <code class=\"language-text\">y</code>로 바꿔볼 수 있다(인라인화). 더 나아가서 <code class=\"language-text\">id (y + 2)</code>와 같이 <code class=\"language-text\">id</code>가 표현식에 적용되어있다면 이를 표현식 그 자체인 <code class=\"language-text\">(y + 2)</code>로 바꿀 수도 있다. 또한 이 치환은 양방향으로 적용되기 때문에 표현식 <code class=\"language-text\">e</code>를 <code class=\"language-text\">id e</code>로 치환할 수도 있다.(리팩토링)</p>\n<p>함수가 패턴 매칭에 의해 정의된 경우, 각각의 하위 정의를 독립적으로 사용할 수도 있다. 예를 들어 위의 <code class=\"language-text\">fmap</code> 정의에서 <code class=\"language-text\">fmap f Nothing</code>을 <code class=\"language-text\">Nothing</code>으로 바꿀 수 있으며, 반대로도 가능하다. 이제 이 개념이 실제로 어떻게 작동하는지를 살펴보자. 먼저 항등 보존을 살펴보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token builtin\">id</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">id</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 <code class=\"language-text\">Nothing</code>과 <code class=\"language-text\">Just</code>라는 두 가지 케이스를 고려해야한다. 먼저 첫 번째 경우를 살펴보겠다. 왼쪽의 항을 오른쪽 항으로 변환하기 위해 Haskell 문법의 Pseudo Code를 사용하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">  <span class=\"token builtin\">fmap</span> <span class=\"token builtin\">id</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Nothing</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">id</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n<span class=\"token builtin\">id</span> <span class=\"token constant\">Nothing</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>가장 마지막 단계에서는 <code class=\"language-text\">id</code>의 정의를 활용하여 표현식 <code class=\"language-text\">Nothing</code>을 <code class=\"language-text\">id Nothing</code>으로 대체했다. 실제로는 양 끝에서 촛불을 태우는 방식과 유사하게 이러한 증명을 수행해나가며, 중간에서 동일한 표현식을 만날 때까지 진행하게 된다. 위 케이스에서는 세 번째 라인의 <code class=\"language-text\">Nothing</code>이 이에 해당한다.</p>\n<p>두 번째 경우도 어렵지 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">  <span class=\"token builtin\">fmap</span> <span class=\"token builtin\">id</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">id</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">id</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">id</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">id</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 항등 보존에 대한 증명이 끝났으니, <code class=\"language-text\">fmap</code>이 합성을 보존한다는 것도 표현해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>첫 번째 <code class=\"language-text\">Nothing</code>의 케이스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">  <span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Nothing</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token constant\">Nothing</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 두 번째 케이스인 <code class=\"language-text\">Just</code>에 대해서는 이렇게 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">  <span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> 합성의 결합법칙에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> 합성의 결합법칙에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>이러한 추론 방식이 조금 어색하게 느껴지는 독자 분들도 계실텐데, 사실 위 예시에 작성된 모든 코드들은 모두 같은 동작을 하는 코드이다.</p>\n<p>방정식 추론이라는 말이 어려워보여서 그렇지 결국은 <code class=\"language-text\">x</code>, <code class=\"language-text\">x + 0</code>이 동형(Isomorphic)임을 밝혀나가는 노가다와 유사하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">addZero</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> identify <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> v<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">   <span class=\"token function\">identify</span><span class=\"token punctuation\">(</span><span class=\"token function\">addZero</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> identify의 정의에 의하면 <span class=\"token punctuation\">}</span>\n   <span class=\"token function\">addZero</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> addZero의 정의에 의하면 <span class=\"token punctuation\">}</span>\n   x\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> identify의 정의에 의하면 <span class=\"token punctuation\">}</span>\n   <span class=\"token function\">identify</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>함수가 참조 투명성을 보장하는 이상 함수를 함수의 본문으로 치환이 가능하기 때문에 이렇게 노가다로 정합성을 확인해나가는 행위가 가능한 것이다.</p>\n</blockquote>\n<p>이와 같은 방정식 추론을 사용할 때는 이 추론 방법이 사이드 이펙트를 가진 C++ 스타일의 함수에 대해서는 동작하지 않는다는 점을 잘 알아야 한다. 아래 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">square</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> x <span class=\"token operator\">*</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> c<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">double</span> y <span class=\"token operator\">=</span> <span class=\"token function\">square</span><span class=\"token punctuation\">(</span><span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>방정식 추론을 사용하면 <code class=\"language-text\">square</code>를 인라인화하여 아래와 같은 정의를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">double</span> y <span class=\"token operator\">=</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이는 확실히 유효한 변환이 아니며 매번 동일한 결과를 생성하지도 않을 것이다. 그럼에도 불구하고 매크로를 통해 <code class=\"language-text\">square</code>를 구현한 경우 C++ 컴파일러는 방정식 추론을 시도할 것이고, 그 결과는 참혹할 것이다.</p>\n<h3 id=\"713-optional\" style=\"position:relative;\">7.1.3 Optional<a href=\"#713-optional\" aria-label=\"713 optional permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>물론 Haskell을 사용하여 펑터를 쉽게 정의할 수 있기는 하지만, 사실 꼭 Haskell이 아니더라도 제네릭 프로그래밍과 고차함수를 지원하는 어떤 언어든 펑터를 정의할 수 있다. C++의 Maybe에 해당하는 템플릿 타입 <code class=\"language-text\">optional</code>을 생각해보자. 아래는 <code class=\"language-text\">optional</code> 구현에 대한 스케치이다. (실제 구현은 인수가 전달될 수 있는 여러가지 방법, Deep Copy/Shallow Copy와 같은 Copy Semantics, C++ 특유의 자원 관리 문제 등 을 고려해야하기 때문에 훨씬 더 복잡하다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">optional</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">bool</span> _isValid<span class=\"token punctuation\">;</span> <span class=\"token comment\">// the tag</span>\n\t\tT _v<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">optional</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">:</span> <span class=\"token function\">_isValid</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>        <span class=\"token comment\">// Nothing</span>\n    <span class=\"token function\">optional</span><span class=\"token punctuation\">(</span>T x<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_isValid</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">,</span> <span class=\"token function\">_v</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// Just</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> _isValid<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    T <span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> _v<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 템플릿은 타입 <code class=\"language-text\">T</code>를 새로운 타입 <code class=\"language-text\">optional&lt;T></code>로 매핑하여 펑터의 정의 중 하나인 타입에 대한 매핑을 제공한다. 이제 함수에 대한 동작을 정의해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nstd<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">optional</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>optional<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span>\n<span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>f<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>optional<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> opt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t\t\t\t\t<span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">else</span>\n\t\t\t\t\t\t<span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이것은 함수를 인자로 받고 다시 함수를 반환하는 고차함수이다. 커링되지 않는 버전은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\noptional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> optional<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> opt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이외에 <code class=\"language-text\">fmap</code>을 <code class=\"language-text\">optional</code>의 템플릿 메서드로 만드는 선택지도 있다. 이처럼 다양한 선택지들은 C++에서 펑터 패턴을 추상화하는 난이도를 더 높히는 주범이다. 펑터를 상속할 수 있는 인터페이스로 정의해야할까? 펑터는 커링된 함수인가 아니면 커링되지 않은 프리 템플릿 함수인가? C++ 컴퍼일러는 누락된 타입을 올바르게 추론할 수 있을까, 아니면 우리가 직접 명시적으로 지정해줘야 하는걸까?</p>\n<p>한번 입력 함수 <code class=\"language-text\">f</code>가 <code class=\"language-text\">int</code>를 받아 <code class=\"language-text\">bool</code>을 반환한다고 생각해보자. 이 경우에 컴파일러는 <code class=\"language-text\">g</code>의 타입을 어떻게 결정할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> g <span class=\"token operator\">=</span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>특히 <code class=\"language-text\">fmap</code>을 오버로딩하는 여러 가지 펑터가 있는 경우에는 어떻게 될까? (곧 우리는 더 많은 펑터들을 만나게 될 것이다)</p>\n<h3 id=\"714-타입-클래스typeclasses\" style=\"position:relative;\">7.1.4 타입 클래스(Typeclasses)<a href=\"#714-%ED%83%80%EC%9E%85-%ED%81%B4%EB%9E%98%EC%8A%A4typeclasses\" aria-label=\"714 타입 클래스typeclasses permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그렇다면 Haskell이 펑터를 추상화하는 방법은 무엇일까? 이를 위해서 Haskell은 타입 클래스 매커니즘을 사용한다. 타입 클래스는 공통 인터페이스를 지원하는 타입의 집합을 정의한다. 예를 들어, 동등성을 지원하는 객체들의 클래스는 아래와 같이 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Eq</span> <span class=\"token hvariable\">a</span> <span class=\"token keyword\">where</span>\n    <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 정의는 타입 <code class=\"language-text\">a</code>가 <code class=\"language-text\">Eq</code> 클래스의 멤버인 경우, 타입 <code class=\"language-text\">a</code>가 두 인자를 받아 <code class=\"language-text\">Bool</code>을 반환하는 <code class=\"language-text\">==</code> 연산자를 지원한다는 것을 나타낸다.</p>\n<p>만약 Haskell에게 특정 타입이 <code class=\"language-text\">Eq</code> 타입 클래스의 인스턴스라는 것을 알려주고 싶다면, 먼저 이 클래스의 인스턴스로 선언하고 <code class=\"language-text\">==</code>의 구현을 제공해줘야 한다. 예를 들어 두 개의 <code class=\"language-text\">Float</code>로 이루어진 곱 타입인 2D Point 타입의 정의가 주어졌다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Point</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Pt</span> <span class=\"token constant\">Float</span> <span class=\"token constant\">Float</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 각 점의 동등성을 이렇게 정의해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Eq</span> <span class=\"token constant\">Point</span> <span class=\"token keyword\">where</span>\n\t\t<span class=\"token punctuation\">(</span><span class=\"token constant\">Pt</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Pt</span> <span class=\"token hvariable\">x'</span> <span class=\"token hvariable\">y'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">x'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">y'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>여기서는 두 개의 패턴 <code class=\"language-text\">(Pt x y)</code>와 <code class=\"language-text\">(Pt x’ y’)</code>에게 중위 연산자 <code class=\"language-text\">==</code>를 사용해보았다. 함수의 본문은 단일 등호를 보면 이해가 쉽다. 이처럼 <code class=\"language-text\">Point</code>가 <code class=\"language-text\">Eq</code>의 인스턴스로 선언된다면 이제 직접적으로 연산자를 통해 각 점의 동등성을 비교할 수 있다.</p>\n<p>Haskell에서는 C++이나 Java와는 다르게 <code class=\"language-text\">Point</code>를 정의할 때, 이 타입이 직접 <code class=\"language-text\">Eq</code>클래스의 멤버라는 것을 명시할 필요는 없으며, 이는 추후 사용자가 직접 작성하는 클라이언트 코드에서 작성할 수 있다. 이러한 타입 클래스는 Haskell에서 함수나 연산자를 오버로딩할 수 있는 유일한 방법이다.</p>\n<p>다양한 펑터들에서 fmap의 동작을 오버로딩하여 활용하기 위해서는 이와 같은 타입 클래스 기법이 필요하다. 그러나 한 가지 복잡한 점이 있다. 펑터는 타입으로 정의되는 것이 아니라 타입들의 매핑인 타입 생성자로 정의된다. 즉, 펑터를 제대로 정의하기 위해서는 <code class=\"language-text\">Eq</code>의 경우처럼 타입들의 집합이 아닌 타입 생성자들의 집합으로 정의된 타입 클래스가 필요하다는 것이다. 다행히도 Haskell의 타입 클래스는 타입 뿐만 아니라 타입 생성자 또한 잘 지원해준다. 그럼 이제 <code class=\"language-text\">Functor</code> 클래스를 한번 정의해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Functor</span> <span class=\"token hvariable\">f</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 코드는 <code class=\"language-text\">f</code>가 <code class=\"language-text\">Functor</code>인 경우, 지정된 타입 시그니처를 가진 함수 <code class=\"language-text\">fmap</code>을 가지고 있다는 사실을 명시하고 있다. 여기서 소문자 <code class=\"language-text\">f</code>는 타입 변수이며, 타입 변수 <code class=\"language-text\">fmap</code>이 받고 있는 <code class=\"language-text\">a</code>나 <code class=\"language-text\">b</code>와 동일한 개념이다.</p>\n<p>컴파일러는 <code class=\"language-text\">f a</code>나 <code class=\"language-text\">f b</code>와 같이 이 타입 변수가 다른 타입을 처리하고 있다는 사실을 참고하여 <code class=\"language-text\">f</code>가 타입이 아닌 타입 생성자라는 사실을 추론할 수 있다. 따라서 <code class=\"language-text\">Functor</code>의 인스턴스를 선언할 때는 <code class=\"language-text\">Maybe</code>와 같은 타입 생성자를 지정해줘야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Maybe</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">_</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>사실 우리가 정의한 <code class=\"language-text\">Functor</code> 클래스, 그리고 <code class=\"language-text\">Maybe</code>와 같이 간단한 데이터 타입에 대한 인스턴스 정의들은 이미 표준 Prelude에 포함되어있다.</p>\n<h3 id=\"715-c에서의-펑터functor-in-c\" style=\"position:relative;\">7.1.5 C++에서의 펑터(Functor in C++)<a href=\"#715-c%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0functor-in-c\" aria-label=\"715 c에서의 펑터functor in c permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그렇다면 C++에서도 이와 동일한 접근 방식을 시도해볼 수 있을까? 타입 생성자는 <code class=\"language-text\">optional</code>과 같은 템플릿 클래스에 해당하므로, <code class=\"language-text\">fmap</code>을 템플릿 템플릿 매개변수 <code class=\"language-text\">F</code>로 매개화해볼 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span><span class=\"token operator\">></span> F<span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nF<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> F<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이제 이 템플릿을 다른 펑터들에 대해서 특수화(Specialize)하면 좋을 것 같다. 하지만 슬프게도 C++에서는 템플릿 함수의 부분 특수화를 금지하고 있기 때문에 아래처럼 작성할 수가 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\noptional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>optional<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> optional<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> opt<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>대신 우리는 함수 오버로딩을 사용할 것이다. 이렇게 되면 우리는 다시 커링되지 않은 펑터의 원래 정의로 돌아가게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\noptional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> optional<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> opt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 <code class=\"language-text\">fmap</code>의 두 번째 인자가 오버로드를 선택하기 때문에 이 정의 자체가 작동하기는 하지만, 이러한 방법은 <code class=\"language-text\">fmap</code>의 일반적인 정의에서는 많이 벗어나있다.</p>\n<h3 id=\"716-list-펑터\" style=\"position:relative;\">7.1.6 List 펑터<a href=\"#716-list-%ED%8E%91%ED%84%B0\" aria-label=\"716 list 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>프로그래밍에서 펑터가 어떤 역할을 하는지에 대해 감을 잡기 위해서는 조금 더 많은 예제를 살펴봐야할 것 같다. 다른 타입으로 매개화된 어떤 타입이든 모두 펑터의 후보라고 볼 수 있다. 제네릭 컨테니어는 저장된 요소의 타입에 의해 매개화되므로, 매우 간단한 컨테이너인 <code class=\"language-text\">List</code>를 한번 살펴보자.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>제네릭 컨테이너는 여러 타입의 데이터를 저장할 수 있는 데이터 컨테이너이다. 즉, 타입 파라미터를 받음으로써 동일한 구조를 유지하면서도 서로 다른 유형의 데이터를 저장할 수 있는 것이다. TypeScript에서는 <code class=\"language-text\">Array&lt;T></code>와 같은 타입이 일종의 제네릭 컨테이너라고 볼 수 있다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Cons</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기 <code class=\"language-text\">List</code>라는 타입 생성자가 있다. 이 타입 생성자는 임의의 타입 <code class=\"language-text\">a</code>를 타입 <code class=\"language-text\">List a</code>로 매핑한다. 이때 <code class=\"language-text\">List</code>가 펑터라는 것을 보이기 위해서는 함수 <code class=\"language-text\">a → b</code>가 주어졌을 때 함수 <code class=\"language-text\">List a → List b</code>로 나아가는 리프팅 함수를 정의해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">List</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">List a</code>에 작용하는 함수는 두 리스트 생성자인 <code class=\"language-text\">Nil</code>과 <code class=\"language-text\">Cons</code> 두 가지 경우를 고려해야한다. <code class=\"language-text\">Nil</code>의 경우에는 어차피 빈 리스트에 대해서 할 수 있는게 없으니, 그냥 <code class=\"language-text\">Nil</code>을 반환해주면 되므로 간단하게 처리가 가능하다.</p>\n<p>그러나 <code class=\"language-text\">Cons</code> 케이스의 경우에는 약간 까다롭다. 왜냐하면 재귀를 포함해야하기 때문이다. 일단 잠시 생각을 멈추고 우리가 정확히 어떤 것을 하려고 하는 것인지 다시 살펴보자. <code class=\"language-text\">fmap</code>의 인자로 <code class=\"language-text\">a</code>의 리스트, 그리고 <code class=\"language-text\">a</code>를 <code class=\"language-text\">b</code>로 변환하는 함수 <code class=\"language-text\">f</code>가 주어졌고, 이제 이것들을 가지고 <code class=\"language-text\">b</code>의 리스트를 생성해야한다.</p>\n<p>리스트의 각 요소를 <code class=\"language-text\">a</code>에서 <code class=\"language-text\">b</code>로 변환하는 것은 당연하게도 <code class=\"language-text\">f</code>를 사용하면 된다. 다만 비어있지 않은 리스트는 하나의 원소가 아닌 <code class=\"language-text\">Cons</code>로 표현되는 헤드(Head)와 나머지 꼬리(Tail)로 구성될텐데, 어떻게 모든 원소에 <code class=\"language-text\">f</code>를 적용해야 하는걸까?</p>\n<p>우리는 <code class=\"language-text\">f</code>를 헤드에 먼저 적용하고, 리프팅한(<code class=\"language-text\">fmap</code>한) <code class=\"language-text\">f</code>를 나머지 꼬리에 적용할 것이다. 이는 리프팅된 <code class=\"language-text\">f</code>를 또 다시 리프팅한 <code class=\"language-text\">f</code>로 정의하고 있기 때문에 재귀적인 정의가 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Cons</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Cons</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>Haksell에 익숙하지 않은 독자들을 위해 조금 더 읽기 쉬운 변수명으로 바꿔보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> 원소에적용할<span class=\"token hvariable\">fn</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Cons</span> 헤드원소 나머지테일<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Cons</span> <span class=\"token punctuation\">(</span>원소에적용할<span class=\"token hvariable\">fn</span> 헤드원소<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> 원소에적용할<span class=\"token hvariable\">fn</span> 나머지테일<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이를 TypeScript로 다시 작성해보자면 대략 이런 느낌이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// List 펑터 인터페이스</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">List<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">fn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Cons<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">List<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> head<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">public</span> tail<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">fn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 헤드에 fn를 적용해서 T를 U로 변경</span>\n    <span class=\"token comment\">// 이후 꼬리(List)가 가진 fmap을 호출하여 같은 행위를 재귀적으로 반복한다.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Cons<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span><span class=\"token punctuation\">(</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">.</span><span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Haksell은 <code class=\"language-text\">Cons (f x)</code>나 <code class=\"language-text\">(fmap f t)</code>와 같은 패턴매칭을 통해 헤드에 적용할 동작과 꼬리에 적용할 동작을 구분하지만, TypeScript는 그런 패러다임을 가진 언어가 아니기 때문에 직접 <code class=\"language-text\">this</code>를 통해 원하는 동작을 호출하고 있다.</p>\n</blockquote>\n<p>우항의 <code class=\"language-text\">fmap f</code> 구문은 정의하려는 리스트보다 더 짧은 리스트, 즉, 꼬리에 적용된다. 결국 점점 더 짧은 리스트로 재귀하다가 결국 최종적으로는 빈 리스트인 <code class=\"language-text\">Nil</code>에 도달하게 될 것이다.</p>\n<p>앞서 정의한대로 <code class=\"language-text\">fmap f</code>가 <code class=\"language-text\">Nil</code>에 적용되면 재귀가 종료된다. 최종 결과를 얻으려면 새로운 헤드 <code class=\"language-text\">(f x)</code>와 새로운 꼬리 <code class=\"language-text\">(fmap f t)</code>를 <code class=\"language-text\">Cons</code> 생성자를 통해 결합한다. 지금까지 이야기한 모든 내용을 하나로 합쳐보면 아래와 같이 List 펑터의 인스턴스 선언이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">List</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">_</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nil</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Cons</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Cons</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>만약 여러분이 C++에 익숙하다면, 일반적인 C++ 컨테이너인 <code class=\"language-text\">std::vector</code>를 한번 생각해보면 된다. <code class=\"language-text\">std::vector</code>에 대한 <code class=\"language-text\">fmap</code>의 구현은 단순히 <code class=\"language-text\">std::transform</code>의 얇은 캡슐화에 불과하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nstd<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> w<span class=\"token punctuation\">;</span>\n    std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">transform</span><span class=\"token punctuation\">(</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">back_inserter</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> w<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이를 사용하면 숫자 시퀀스인 원소를 제곱하는 등의 행위가 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> v<span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> w <span class=\"token operator\">=</span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> i<span class=\"token operator\">*</span>i<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">copy</span><span class=\"token punctuation\">(</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span>\n\t\t\t\t\t<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span>\n\t\t\t\t\t<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">ostream_iterator</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>cout<span class=\"token punctuation\">,</span> <span class=\"token string\">\", \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>대부분의 C++ 컨테이너는 <code class=\"language-text\">std::transform</code>에 전달할 수 있는 이터레이터를 구현함으로써 펑터가 되며, 이는 <code class=\"language-text\">fmap</code>의 원시적인 버전과도 같다. 그러나 안타깝게도 이터레이터와 임시 개체(Temporaries)의 혼란스러움으로 인해 펑터의 단순함이 상당 부분 사라져버린다(위의 <code class=\"language-text\">fmap</code> 구현을 참조해보자). 하지만 새롭게 제안된 <a href=\"https://learn.microsoft.com/ko-kr/cpp/standard-library/ranges?view=msvc-170\" target=\"_blank\" rel=\"nofollow\">range</a> 라이브러리는 특정한 범위 내에서 펑터적인 성질을 더 명확하게 표현해주고 있다.</p>\n<h3 id=\"717-reader-펑터\" style=\"position:relative;\">7.1.7 Reader 펑터<a href=\"#717-reader-%ED%8E%91%ED%84%B0\" aria-label=\"717 reader 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>여기까지 봤다면 이제 펑터가 어떤 컨테이너의 한 종류인 것 같다는 생각을 가지게 되었을 것이라 생각한다. 그렇다면 이제는 그 생각을 깨버리기 위해 지금까지와 매우 다른 것처럼 보이는 예제를 보여주려고 한다. 타입 <code class=\"language-text\">a</code>를 <code class=\"language-text\">a</code>를 반환하는 함수로 매핑하는 상황을 생각해보자.</p>\n<p>아직 함수 타입에 대한 깊이 있는 이야기를 나누지는 않았지만, 사실 프로그래머라면 함수에 대한 기본적인 이해 정도는 가지고 있다. Haskell에서 함수 타입은 두 개의 타입과 화살표 타입 생성자(<code class=\"language-text\">-></code>)를 사용하여 구성된다. 이 생성자는 인수 타입, 그리고 결과 타입이라는 두 가지 타입 사이의 중위 표현으로 등장한다. 기본적으로는 <code class=\"language-text\">a -> b</code>의 형태이지만 괄호를 사용하면 전위 표현으로도 사용이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>정규 함수와 마찬가지로 하나 이상의 인수를 가진 타입 함수는 부분적용이 가능하다. 따라서 아래 예시와 같이 화살표에 하나의 타입 인수만 제공한다면 결과 타입을 의미하는 다른 인수가 들어오는 것을 기다릴 수 있다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것이 바로 위 표현이 타입 생성자인 이유이다. <code class=\"language-text\">a -> b</code> 를 완전한 타입으로 만들기 위해서는 타입 <code class=\"language-text\">b</code>까지 제공되어야 하기 때문이다. 즉, 위 예시는 타입 <code class=\"language-text\">a</code>를 매개변수로 사용하는 타입 생성자 집합을 정의하고 있다고 볼 수 있다.</p>\n<p>그렇다면 이제 이 케이스가 펑터가 맞는지 살펴보도록 하자. 두 개의 타입 매개변수를 다루는 것은 어려울 수 있으니 이름을 조금 변경해보겠다. 이전에 정의했던 펑터의 정의와 일치하도록 인수의 타입을 <code class=\"language-text\">r</code>로, 결과 타입을 <code class=\"language-text\">a</code>로 지정해보겠다.</p>\n<p>즉, 이 타입 생성자는 임의의 타입 <code class=\"language-text\">a</code>를 <code class=\"language-text\">r -> a</code> 타입으로 매핑하는 녀석이다. 이것이 펑터가 되려면 함수 <code class=\"language-text\">a -> b</code>, 함수 <code class=\"language-text\">r -> a</code>를 인자로 받고 함수 <code class=\"language-text\">r -> b</code>를 반환하는 함수로 리프팅해야 한다. 이들은 각각 타입 생성자(<code class=\"language-text\">-></code>) <code class=\"language-text\">r</code>이 작용하는 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>를 사용하여 형성된 타입이다.</p>\n<p>이제 이 케이스를 표현할 수 있는 <code class=\"language-text\">fmap</code>의 정의를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">r</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">r</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 함수 <code class=\"language-text\">f::a -> b</code>와 함수 <code class=\"language-text\">g::r -> a</code>가 주어졌을 때 함수 <code class=\"language-text\">r -> b</code>를 생성해야하는 퍼즐을 풀어야 한다. 두 함수를 합성할 수 있는 방법은 오직 하나 뿐이며, 결과 또한 우리가 원하는 방향과 정확히 일치한다. 따라서 <code class=\"language-text\">fmap</code>의 구현은 아래와 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">g</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p><code class=\"language-text\">g::r → a</code>, <code class=\"language-text\">f::a → b</code>가 합성됨으로써 <code class=\"language-text\">r → a → b</code>, 즉 <code class=\"language-text\">r → b</code>가 성립된다.</p>\n</blockquote>\n<p>굉장히 간결하지만 우리가 원하는 동작은 정확히 구현되었다. 만약 더 간결한 표기를 선호한다면, 함수 합성에 대한 표현을 전위 표기법으로 바꿔볼 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 인수를 생략해서 <code class=\"language-text\">fmap</code>과 함수 합성을 의미하는 <code class=\"language-text\">.</code> 연산자, 두 함수의 직접적인 동등성을 표현할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이처럼 <code class=\"language-text\">(->) r</code> 타입 생성자와 <code class=\"language-text\">fmap</code> 구현의 결합을 Reader 펑터라고 한다.</p>\n<h2 id=\"72-컨테이너로써의-펑터\" style=\"position:relative;\">7.2 컨테이너로써의 펑터<a href=\"#72-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%A1%9C%EC%8D%A8%EC%9D%98-%ED%8E%91%ED%84%B0\" aria-label=\"72 컨테이너로써의 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 프로그래밍 언어에서 일반적인 용도의 컨테이너를 정의하는 펑터의 몇 가지 예시를 살펴보았다.</p>\n<p>우리는 보통 함수를 일종의 데이터라고 생각하지않기 때문에 Reader 펑터같은 녀석들이 조금 어색해보이기도 한다. 그러나 순수함수는 메모이제이션될 수 있으며 함수의 실행은 일종의 테이블 조회 행위로 변환될 수도 있다. 그리고 테이블은 데이터이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>함수의 실행을 일종의 테이블 조회 행위로 변환할 수 있다는 말은 어떤 함수가 순수하고 불변적이며 입력에 따라 항상 같은 출력을 반환한다는 가정을 전제로 하는 설명이다.</p>\n<p>위와 같은 전제가 지켜진다면 함수의 실행 결과를 테이블에 저장하고 함수의 입력 값을 키로 사용하여 함수의 실행 결과를 “검색”할 수 있다.</p>\n<p>이러한 메모이제이션에 사용되는 자료구조가 꼭 테이블이어야만 하는 것은 아니지만, 작가는 순수한 함수의 이러한 특성으로 인해 순수함수의 실행이 일종의 데이터 조회 행위가 될 수 있다는 사실을 강조하고 있는 것이다.</p>\n</blockquote>\n<p>반대로 Haskell의 게으른 평가(지연평가) 때문에 전통적인 컨테이너인 리스트는 함수로 구현될 수도 있다. 예를 들어 자연수의 무한한 리스트는 아래와 같이 간결하게 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">nats</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Integer</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">nats</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>첫 번째 라인의 대괄호 쌍은 Haskell의 리스트에 대한 내장 타입 생성자이다. 두 번째 라인의 대괄호는 리스트 리터럴을 만드는 데 사용된다.</p>\n<p>당연하겠지만 이런 방식의 무한 리스트는 메모리에 저장할 수 없다. 그래서 필요할 때마다 <code class=\"language-text\">Integer</code>를 생성하는 함수로 이러한 동작을 구현하는 것이다. Haskell은 사실상 데이터와 코드 사이의 구분을 명확하게 하지 않는다. 리스트는 함수로 간주될 수도 있고, 함수는 인수를 결과에 매핑하는 테이블로 간주될 수도 있다. 특히 후자는 함수의 정의역이 유한하고 크기가 크지 않은 경우에는 꽤나 실용적인 개념이다.</p>\n<p>그러나 <code class=\"language-text\">strlen</code>을 테이블 조회로 구현하는 것은 현실적이지 않다. 왜냐하면 무한히 많은 서로 다른 문자열들이 존재하기 때문이다. 프로그래머로써 우리는 무한을 좋아하지 않겠지만, 카테고리 이론에서는 무한을 아침식사처럼 즐기는 방법을 배워볼 수 있다. 모든 문자열의 집합이나 우주의 과거, 현재, 미래의 상태 같이 무한한 것들도 다뤄볼 수 있다는 말이다.</p>\n<p>그래서 필자는 펑터 객체(엔도펑터에 의해 생성된 타입의 객체)를 어떤 타입을 가진 값 또는 값들을 추상적으로 가지고 있는 무언가로 생각하는 것을 추천한다. 물리적으로 그 값을 가지고 있지는 않지만 말이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>여기서 작가가 펑터가 특정 타입의 값을 직접 가지고 있는 것이 아니라 추상적으로 가지고 있다고 표현하는 의미는 다음과 같다. TypeScript의 Array를 예로 들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> numbers<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 숫자 타입의 배열</span>\n<span class=\"token keyword\">const</span> doubledNumbers <span class=\"token operator\">=</span> numbers<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [2, 4, 6]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">number[]</code> 타입의 배열은 사실 “모든 숫자를 가진 배열”으로 정의되었다고 봐야 한다. 하지만 현재 이 배열이 실제로 모든 숫자를 가지고 있는 것은 아니며, 단지 <code class=\"language-text\">map</code>과 같은 메소드를 사용하여 배열 내부의 값들을 간접적으로 다룰 수 있는 방법만을 제공하고 있다.</p>\n<p>이러한 방법들을 통해 이 배열은 이론상 모든 숫자를 가질 수 있겠지만, 실제로 이 배열이 모든 숫자를 가지고 있는 것은 아니기에 “추상적으로 가지고 있다”라는 표현을 사용한 것이다.</p>\n</blockquote>\n<p>C++에서의 예시를 보자면 <code class=\"language-text\">std::future</code>가 있다. 언젠가는 값을 가지게 될테지만 반드시 그렇다는 보장은 없으며, Future 내부의 값에 접근하려면 다른 스레드의 실행이 완료될 때까지 기다려야할 수도 있다.</p>\n<p>또 다른 예시로는 Haskell의 <code class=\"language-text\">IO</code> 객체가 있다. 이 객체는 사용자의 입력을 받거나 “Hello World!”가 모니터에 표시된 우주의 상태를 포함할 수도 있다.</p>\n<p>이러한 해석들에 따르면 펑터 객체는 매개변수화된 타입의 값을 포함하거나 그런 값을 생성하는 방법을 포함하고 있는 무언가로 바라볼 수 있다. 펑터 내부의 값에 접근하는 동작은 완전히 선택사항이며 펑터의 범위에 꼭 포함되어야 하는 동작도 아니다. 우리가 관심을 가져야하는 부분은 함수를 사용해서 그 값을 조작할 수 있다는 것 뿐이다.</p>\n<p>만약 그 값에 접근할 수 있다면 그 조작에 대한 결과를 볼 수 있어야 한다. 그러나 접근할 수 없다면 우리가 오직 신경써야하는 것은 그 조작들이 올바르게 합성되었는지, 그리고 항등 함수를 통한 조작은 아무것도 바꾸지 않는다는 사실 뿐이다. 펑터 객체 내부의 값에 접근하는 것이 그렇게 중요한 일이 아니라는 것을 보여주기 위해 한 가지 예시를 보여주겠다. 여기 인자 <code class=\"language-text\">a</code>를 완전히 무시하는 타입 생성자가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Const</code> 타입 생성자는 <code class=\"language-text\">c</code>와 <code class=\"language-text\">a</code> 두 개의 타입을 받는다. 화살표 생성자 때와 마찬가지로 이를 부분적으로 적용해서 펑터를 만들어볼 것이다. <code class=\"language-text\">Const</code>라고 하는 데이터 생성자는 <code class=\"language-text\">c</code> 타입의 값 하나만을 취하며, 이는 <code class=\"language-text\">a</code>에 대한 의존성이 없다는 것을 의미한다. 이 타입 생성자에 대한 <code class=\"language-text\">fmap</code>의 타입 정의는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>펑터가 타입 인수를 무시하고 있기 때문에, <code class=\"language-text\">fmap</code>의 구현에서도 함수 인수를 무시할 수 있다. 함수에 적용할 대상 자체가 없기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">_</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token hvariable\">v</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">v</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>오히려 이런 부분은 컴파일 시간에 발생하는 타입 인자와 런타임에 발생하는 값 사이의 더 강한 구분이 있는 C++에서 더 명확하게 나타날 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Const</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">Const</span><span class=\"token punctuation\">(</span>C v<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_v</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\t\tC _v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>C++으로 구현된 <code class=\"language-text\">fmap</code> 또한 함수의 인자를 무시하고 <code class=\"language-text\">Const</code> 인자를 본래 값과 함께 다시 캐스팅하는 역할을 수행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nConst<span class=\"token operator\">&lt;</span>C<span class=\"token punctuation\">,</span> B<span class=\"token operator\">></span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> Const<span class=\"token operator\">&lt;</span>C<span class=\"token punctuation\">,</span> A<span class=\"token operator\">></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Const<span class=\"token operator\">&lt;</span>C<span class=\"token punctuation\">,</span> B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>c<span class=\"token punctuation\">.</span>_v<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>당장 이해하기는 어려울 수 있지만 사실 <code class=\"language-text\">Const</code> 펑터는 많은 구조들에서 굉장히 중요한 역할을 담당한다. 카테고리 이론에서 <code class=\"language-text\">Const</code> 펑터는 앞서 언급했던 블랙홀의 엔도펑터, 즉, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span><span class=\"mord mathnormal\">c</span></span></span></span></span> 펑터의 특수한 경우이다. 추후 이러한 개념에 대해서도 더 자세히 다뤄보도록 하겠다.</p>\n<h2 id=\"73-펑터-합성functor-composition\" style=\"position:relative;\">7.3 펑터 합성(Functor Composition)<a href=\"#73-%ED%8E%91%ED%84%B0-%ED%95%A9%EC%84%B1functor-composition\" aria-label=\"73 펑터 합성functor composition permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>펑터가 마치 함수와 같이 합성될 수 있다라는 것은 꽤 직관적인 이해가 가능한 사실이다. 결국 두 펑터의 합성이라는 것은 펑터가 특정 카테고리 내의 객체나 사상에 매핑되는 행위들의 합성이라고 볼 수 있다.</p>\n<p>합성된 두 개의 펑터를 거치더라도 항등 사상은 그대로 항등 사상으로 남게 되며, 사상들의 합성 규칙은 여전히 동일한 규칙을 가지게 된다. 이는 굉장히 단순하고 간단한 규칙이며, 특히 엔도펑터를 합성하는 것은 더더욱 쉽다. 혹시 <code class=\"language-text\">maybeTail</code> 함수를 기억하는가?</p>\n<p>이 함수를 Haskell의 내장 리스트 구현을 사용해서 다시 작성해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">maybeTail</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">maybeTail</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token hvariable\">maybeTail</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">xs</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>지금까지 <code class=\"language-text\">Nil</code>로 호출하던 빈 리스트 생성자는 빈 대괄호 쌍인 <code class=\"language-text\">[]</code>으로 대체되었고, <code class=\"language-text\">Cons</code> 생성자는 중위 연산자 <code class=\"language-text\">:</code>으로 대체되었다.</p>\n<p><code class=\"language-text\">maybeTail</code>의 결과는 두 펑터 <code class=\"language-text\">Maybe</code>, <code class=\"language-text\">[]</code>가 <code class=\"language-text\">a</code>에 작용하는 형태를 지니고 있다. 만약 여기서 합성된 <code class=\"language-text\">Maybe</code> 리스트의 원소에 어떤 함수 <code class=\"language-text\">f</code>를 적용하려고 한다면 어떻게 접근해야할까?</p>\n<p>함수가 <code class=\"language-text\">Maybe</code> 리스트의 원소에 도달하기 위해서는 <code class=\"language-text\">Maybe</code>와 <code class=\"language-text\">[]</code>라는 두 겹의 펑터를 뚫어야 한다. 가장 먼저 외부의 <code class=\"language-text\">Maybe</code>를 뚫기 위해 <code class=\"language-text\">fmap</code>을 사용할 수 있다. 그러나 함수 <code class=\"language-text\">f</code>는 리스트에 대해서는 작동하지 않기 때문에 이대로 이 함수를 <code class=\"language-text\">Maybe</code>의 안쪽으로 보낼 수는 없다. 우리는 내부 리스트에서 작동할 <code class=\"language-text\">(fmap f)</code>를 보내야 한다. 한번 <code class=\"language-text\">Maybe</code> 리스트의 정수 원소들을 제곱하는 예시를 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">square</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token hvariable\">mis</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">mis</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token hvariable\">mis2</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">square</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">mis</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>먼저 컴파일러는 타입을 분석한 후, 외부의 <code class=\"language-text\">fmap</code>에 대해서는 <code class=\"language-text\">Maybe</code> 인스턴스의 구현을 사용하고, 내부의 <code class=\"language-text\">fmap</code>에 대해서는 리스트 펑터의 구현을 사용해야한다는 것을 추론해낼 것이다. 물론 지금 시점에서 위 코드가 아래와 같은 코드로 다시 작성될 수 있다는 사실이 바로 이해가 되지는 않을 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">mis2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">fmap</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">square</span> <span class=\"token hvariable\">mis</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그러나 <code class=\"language-text\">fmap</code>은 하나의 인수에 대한 함수로 간주될 수 있다는 것을 기억해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 경우 <code class=\"language-text\">(fmap . fmap)</code>안의 두 번째 <code class=\"language-text\">fmap</code>은 다음과 같은 타입의 인수를 취한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">square</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 다음과 같은 타입의 함수를 반환할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이후 첫 번째 <code class=\"language-text\">fmap</code>은 이 함수를 취하고 다음과 같은 타입의 함수를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 비로소 이 함수가 <code class=\"language-text\">mis</code>에 적용된다. 따라서 두 펑터의 합성은 해당 <code class=\"language-text\">fmap</code>들의 합성인 펑터라고 볼 수 있다.</p>\n<p>다시 카테고리 이론으로 돌아가보자. 대상들의 매핑이 결합법칙을 만족하며, 사상들의 매핑도 결합법칙을 만족하니 펑터의 합성 또한 결합법칙을 만족한다는 사실은 명확하다. 그리고 모든 카테고리에는 당연히 항등 펑터 또한 존재한다. 항등 펑터는 모든 대상과 사상이 자기자신에게 매핑되는 펑터이다.</p>\n<p>즉, 펑터는 마치 어떠한 카테고리의 사상들과 동일한 특성을 가지게 된다. 그렇다면 그 카테고리란 무엇일까?</p>\n<p>바로 대상이 카테고리이고, 사상이 펑터인 카테고리이다. 즉, 카테고리들의 카테고리라고 할 수 있다. 그러나 모든 카테고리들의 카테고리 또한 카테고리이니, 자기 자신을 자기 자신 안에 포함해야하는 모순에 빠지게 된다.</p>\n<p>모든 “작은” 카테고리의 카테고리인 <strong>Cat</strong>이라는 개념이 있다. 작은 카테고리는 대상들이 집합을 형성하는 카테고리를 가리키며, 심지어 무한하여 셀 수 없는 집합도 “작은” 카테고리로 간주된다. 필자는 이런 개념들이 다양한 추상화 수준에서 동일한 구조가 반복되는 것을 표현할 수 있다는 것에 매우 놀라웠다. 심지어 나중에는 펑터들이 카테고리를 형성하는 케이스도 보게 될 것이다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240315-category-theory-for-programmers-7-functors","path":"/2024/03/15/category-theory-for-programmers-7-functors/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 7. 펑터","subTitle":null,"date":"Mar 19, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"47605aa1-3714-56bb-adc5-4cb4803954da","tableOfContents":"<ul>\n<li><a href=\"#61-%EA%B3%B1-%ED%83%80%EC%9E%85product-types\">6.1 곱 타입(Product Types)</a></li>\n<li><a href=\"#62-%EB%A0%88%EC%BD%94%EB%93%9Crecords\">6.2 레코드(Records)</a></li>\n<li><a href=\"#63-%ED%95%A9-%ED%83%80%EC%9E%85sum-types\">6.3 합 타입(Sum Types)</a></li>\n<li><a href=\"#64-%ED%83%80%EC%9E%85%EC%9D%98-%EB%8C%80%EC%88%98%ED%95%99\">6.4 타입의 대수학</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"앞서 우리는 곱과 합이라는 두 가지 기본적인 방법을 통해 타입을 결합하는 것을 보았다. 사실 우리가 일상적인 프로그래밍에서 자주 접하는 데이터 구조는 이 두 가지 메커니즘만으로도 충분히 표현할 수 있다. 이처럼 데이터 구조의 많은 속성들을 합성할 수 있다는 사실은 굉장히 중요한 포인트이다. 예를 들어 동등성을 사용하여 기본적인 타입의 값들을 비교하는 방법과 이러한 비교 행위를 곱과 합 타입으로 일반화하는 방법을 알고 있다면, 우리는 자연스럽게 합성 타입에 대한 동등 연산자라는 개념을 유도할 수 있다. Haskell에서는 이렇게 합…","html":"<p>앞서 우리는 곱과 합이라는 두 가지 기본적인 방법을 통해 타입을 결합하는 것을 보았다. 사실 우리가 일상적인 프로그래밍에서 자주 접하는 데이터 구조는 이 두 가지 메커니즘만으로도 충분히 표현할 수 있다.</p>\n<p>이처럼 데이터 구조의 많은 속성들을 합성할 수 있다는 사실은 굉장히 중요한 포인트이다. 예를 들어 동등성을 사용하여 기본적인 타입의 값들을 비교하는 방법과 이러한 비교 행위를 곱과 합 타입으로 일반화하는 방법을 알고 있다면, 우리는 자연스럽게 합성 타입에 대한 동등 연산자라는 개념을 유도할 수 있다. Haskell에서는 이렇게 합성된 타입의 하위 집합에 대해 동등성, 비교, 문자열로의 변환과 같은 연산들을 유도할 수 있다.</p>\n<p>그럼 프로그래밍에서 곱 및 합 타입이 나타나는 방식에 대해서 자세히 살펴보도록 하자.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 409px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/fcf5139ae1c84cc62f66e0f43c59f1ba/e9a96/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.12499999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB0lsLLOMUf//EABoQAAMBAAMAAAAAAAAAAAAAAAECAwAREjH/2gAIAQEAAQUCejKwsRlPKvLuXiG3m//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABoQAAICAwAAAAAAAAAAAAAAAAABEBEhMVH/2gAIAQEABj8C3ZmmJss5H//EABoQAQEBAAMBAAAAAAAAAAAAAAERACExUaH/2gAIAQEAAT8hgQCyB8wZdekzQFfMVTOMmJ1OJ7gBAgb/2gAMAwEAAgADAAAAENgP/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EKF//8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EIV//8QAHhABAQACAQUBAAAAAAAAAAAAAREAITFBUWGBkfD/2gAIAQEAAT8QcsEhUefb9rIZxuzvshgYALvT7myGQQ63nGIptMi1fOqYZMCAEDP/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/fcf5139ae1c84cc62f66e0f43c59f1ba/e9a96/1.jpg\" srcset=\"/static/fcf5139ae1c84cc62f66e0f43c59f1ba/0913d/1.jpg 160w,\n/static/fcf5139ae1c84cc62f66e0f43c59f1ba/cb69c/1.jpg 320w,\n/static/fcf5139ae1c84cc62f66e0f43c59f1ba/e9a96/1.jpg 409w\" sizes=\"(max-width: 409px) 100vw, 409px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"61-곱-타입product-types\" style=\"position:relative;\">6.1 곱 타입(Product Types)<a href=\"#61-%EA%B3%B1-%ED%83%80%EC%9E%85product-types\" aria-label=\"61 곱 타입product types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>프로그래밍 언어에서 두 타입의 곱의 대표적인 구현은 바로 쌍(Pair)이다. Haskell에서는 쌍이 원시 타입 생성자이며, C++에서는 표준 라이브러리에서 정의된 템플릿이다.</p>\n<p>엄밀히 말해 쌍은 교환 법칙을 따르지 않는다. 어떠한 쌍 <code class=\"language-text\">(Int, Bool)</code>은 <code class=\"language-text\">(Bool, Int)</code>으로 대체될 수 없다는 것이다. 하지만 이 두 타입은 동형성(Isomorphism)을 지니고 있다. 이 동형성은 Swap 함수에 의해 제공되며, Swap 함수는 아래와 같이 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">swap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">swap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 두 쌍은 동일한 데이터를 저장하지만 단순히 다른 형식을 사용하고 있는 것이라고 생각할 수 있다. 이는 마치 빅 엔디안(Big Endian) vs 리틀 엔디안(Little Endian)의 관계와도 비슷하다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>엔디안(Endian)은 컴퓨터 메모리에 데이터를 저장하는 방식을 의미한다. 빅 엔디안(Big Endian)은 가장 상위 바이트(Most Significant Byte, MSB)를 가장 낮은 주소에 저장하고, 반대로 리틀 엔디안은 MSB를 가장 높은 주소에 저장한다. 즉, 같은 데이터를 다루더라도 저장하는 방식만 다르다는 것이다.</p>\n<p>이는 <code class=\"language-text\">(Int, Bool)</code>과 <code class=\"language-text\">(Bool, Int)</code> 쌍처럼 같은 타입들의 곱이지만 각 구성 요소의 위치만 다른 상황과도 유사하기에 작가는 이러한 예시를 든 것이다.</p>\n</blockquote>\n<p>만약 임의의 개수인 타입들을 곱으로 결합하려면 그저 쌍을 중첩시키는 것만으로도 표현할 수 있지만 더 쉬운 방법도 있다. 이렇게 중첩된 쌍은 튜플과 동일한데, 이는 쌍을 중첩하는 다양한 방법들이 동형(Isomorphic)이기 때문이다. 세가지 타입 <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code>, <code class=\"language-text\">c</code>를 순서대로 곱으로 결합하려면 아래와 같은 두 가지 방법을 사용해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 또는</span>\n<span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 타입들은 분명히 다른 타입이다. <code class=\"language-text\">((a, b), c)</code> 타입을 받을 수 있는 함수에 <code class=\"language-text\">(a, (b, c))</code> 타입을 전달할 수 없다는 것을 생각해보면 된다. 하지만 이 타입들이 가진 각각의 요소들은 분명 일대일 대응 관계에 놓여있다.</p>\n<p>여기 이 두 타입을 서로 매핑해주는 함수가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">alpha</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그리고 이 함수에는 역함수 또한 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha_inv</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">alpha_inv</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, 이 매핑 함수는 동형사상(Isomorphism)이며, 이 과정에서 이 타입들이 결국 동일한 데이터를 여러 방법으로 패키징하고 있을 뿐이라는 사실을 알 수 있다.</p>\n<p>이렇게 생성된 곱 타입을 타입에 대한 이항 연산이라고 생각해볼 수도 있다. 이 관점에서 바라보면 위에서 알아본 동형사상은 모노이드(Monoid)에서 본 결합 법칙과 매우 유사한 형태를 띄고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그러나 모노이드의 경우 이 두 가지 방법이 완전히 동일하다고 말할 수 있겠지만, 곱 타입의 경우 완전히 동일하다는 의미가 아닌 동형사상에 따라 동일하다고 말할 수 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>만약 <code class=\"language-text\">(a * b) * c</code>와 <code class=\"language-text\">a * (b * c)</code>를 모노이드인 곱 연산의 관점에서 바라본다면, 이 연산은 교환법칙을 만족하기 때문에 완벽히 동일(Equal)하다고 이야기할 수 있다.</p>\n<p>하지만 곱 타입의 경우 각 튜플 안에 있는 요소들이 서로 정보의 손실 없이 매핑될 수 있는 일대일 대응함수가 존재하는 동형(Isomorphic)일 뿐이다.</p>\n<p>즉, 두 곱 타입이 동형사상을 통해 서로 매핑이 가능하므로 “동형성에 의해 같다”고 말할 수는 있겠지만 엄밀한 의미에서 동일하지는 않다는 것이다.</p>\n</blockquote>\n<p>만약 우리가 동형사상을 수용할 수 있고 엄격한 동일성을 요구하지 않는다면, 유닛 타입인 <code class=\"language-text\">()</code>이 곱셈의 항등원인 1과 같이  작동한다는 것을 보일 수도 있다. 실제로 임의의 타입 <code class=\"language-text\">a</code>인 값과 Unit을 쌍으로 묶는 것은 어떠한 정보도 추가하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>결국 이 타입은 <code class=\"language-text\">a</code>와 동형(Isomorphic)이다. 아래와 같이 동형사상을 정의할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">rho</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">rho</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token hvariable\">rho_inv</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">rho_inv</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이러한 분석을 통해 집합의 카테고리가 모노이드 카테고리(Monoidal Category)라는 것을 형식적으로 설명할 수 있다. 결국 집합의 카테고리는 각 대상을 데카르트 곱(Cartesian Product)의 형태로 곱할 수 있는 카테고리라는 것이다. 이에 대한 자세한 정의는 추후 다시 논의해보도록 하자.</p>\n<p>Haskell에서는 곱 타입을 더 일반적인 방식으로 정의할 수 있는 방법을 제공하고 있다. 나중에 다시 보겠지만 이런 방법은 특히 곱 타입이 합 타입과 합쳐질 때 빛을 발하게 된다. 이 방법은 여러 개의 인자를 받는 생성자로 표현되는데, 쌍의 경우는 아래와 같이 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Pair</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">P</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">Pair a b</code>는 매개변수화된 두 개의 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>, 그리고 데이터 생성자인 <code class=\"language-text\">P</code>를 의미한다. 우리는 <code class=\"language-text\">Pair</code> 타입 생성자에 두 개의 타입을 전달함으로써 간단하게 쌍이라는 타입을 생성할 수 있다. 그리고 <code class=\"language-text\">P</code>에는 정의해둔 타입에 맞는 두 값을 전달하여 쌍 타입의 값을 생성할 수 있다.</p>\n<p>한번 <code class=\"language-text\">String</code>과 <code class=\"language-text\">Bool</code>의 쌍으로 값을 정의해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">stmt</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Pair</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">stmt</span> <span class=\"token operator\">=</span> <span class=\"token constant\">P</span> <span class=\"token string\">\"This statements is\"</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>첫 번째 줄은 타입 선언부이다. 여기서 <code class=\"language-text\">Pair</code> 타입 생성자를 사용하며, 일반화했었던 <code class=\"language-text\">Pair</code> 정의의 매개변수인 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 대신에 <code class=\"language-text\">String</code>과 <code class=\"language-text\">Bool</code>을 직접 넘겨준다. 두 번째 줄은 데이터 생성자 <code class=\"language-text\">P</code>를 사용하여 구체적인 문자열과 부울값을 전달하여 실제 값을 정의하고 있다. 타입 생성자는 타입을 생성할 때 사용되고, 데이터 생성자는 해당 타입을 가진 값을 생성할 때 사용되는 것이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>완전히 동일하지는 않지만, 위 Haskell 코드를 TypeScript로 표현해보자면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 데이터 생성자</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">P</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 타입 생성자</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Pair<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> ReturnType<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> <span class=\"token constant\">P</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> \n\n<span class=\"token keyword\">const</span> stmt<span class=\"token operator\">:</span> Pair<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token constant\">P</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This statements is\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</blockquote>\n<p>Haskell에서는 타입 생성자와 데이터 생성자의 네임스페이스가 분리되어있기 때문에 아래와 같이 동일한 이름도 종종 사용되고는 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Pair</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Pair</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>더 깊게 들여다보면 <code class=\"language-text\">Pair</code>를 이항 연산자인 <code class=\"language-text\">(,)</code>으로 대체하고 있는 것 또한 결국은 빌트인 쌍(Pair) 타입의 선언을 변형한 것이라고 볼 수 있다. 실제로 <code class=\"language-text\">(,)</code>을 전위 연산자로 표현하여 타입 생성자처럼 사용할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">stmt</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"This statement is\"</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이와 유사하게 <code class=\"language-text\">(,,)</code>을 사용하면 트리플(원소가 3개인 튜플)을 생성할 수 있으며, 같은 방법으로 계속 해서 튜플을 확장해나갈 수도 있다. 또한 일반적인 쌍이나 튜플 대신 원하는 곱 타입을 정의할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Stmt</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Stmt</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Bool</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 타입은 단순히 <code class=\"language-text\">String</code>과 <code class=\"language-text\">Bool</code>의 곱이지만 이 타입은 자체적인 이름과 생성자를 가지고 있다. 이러한 선언 방법의 장점은 동일한 내용을 가지지만 의미와 기능이 다른 타입을 다양하게 정의할 수 있다는 것이다. 또한 이렇게 선언된 각 타입들은 서로 대체될 수 없다.</p>\n<p>이처럼 튜플과 다중 인자 생성자를 사용하는 생성자는 각 구성 요소가 무엇을 나타내고 있는지 추적하기 어렵기 떄문에 종종 혼란스러운 표현이 되기 쉽고 오류가 발생하기도 쉽다. 그래서 때로는 각 구성 요소에 이름을 지정해주는 것이 나을 수도 있다. 이처럼 이름이 지정된 필드를 가진 곱 타입을 Haskell에서는 <code class=\"language-text\">record</code>라고 하며, C에서는 <code class=\"language-text\">struct</code>라고 한다.</p>\n<h2 id=\"62-레코드records\" style=\"position:relative;\">6.2 레코드(Records)<a href=\"#62-%EB%A0%88%EC%BD%94%EB%93%9Crecords\" aria-label=\"62 레코드records permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>본격적인 설명에 앞서 간단한 예시를 먼저 살펴보도록 하자. 우리는 화학 원소들을 설명하기 위해 원소의 이름과 원소 기호로 이루어진 두 개의 문자열과 원자 번호를 표현하는 하나의 정수가 결합된 데이터 구조를 만드려고 한다. 먼저 <code class=\"language-text\">(String, String, Int)</code>와 같이 튜플을 사용하여 각 구성 요소를 표현해볼 수 있다. 그 다음 원소 기호가 원소 이름의 접두사가 맞는지 확인하는 함수로 패턴 매칭하여 구성 요소들을 추출할 것이다. 아래는 <code class=\"language-text\">He</code>가 <code class=\"language-text\">Helium</code>의 접두사인지 확인하는 함수이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">name</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">isPrefixOf</span> <span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">name</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러나 이 코드는 에러가 발생할 가능성이 있고 유지 보수하기도 쉽지 않은 코드이다. 이런 경우에는 레코드를 정의하는 것이 훨씬 더 낫다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Element</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">name</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span>\n                       <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span>\n                       <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">atomicNumber</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위 표현과 튜플을 사용한 표현은 동형(Isomorphic)이다.이는 서로 역함수의 관계를 가지는 두 개의 변환 함수를 통해 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">tupleToElem</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Element</span>\n<span class=\"token hvariable\">tupleToElem</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Element</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">name</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">n</span>\n                                <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">s</span>\n                                <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">atomicNumber</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token hvariable\">elemToTuple</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">elemToTuple</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">name</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">atomicNumber</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서 레코드 필드의 이름은 필드에 액세스하기 위한 함수로도 작동한다는 사실에 주목하도록 하자. 예를 들어 <code class=\"language-text\">atomicNumber e</code>라는 표현은 <code class=\"language-text\">e</code>에서 <code class=\"language-text\">atomicNumber</code>필드를 검색한다. 이처럼 <code class=\"language-text\">e</code>라는 레코드의 필드에 액세스하는 <code class=\"language-text\">atomicNumber</code> 함수의 타입은 다음과 같이 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">atomicNumber</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Element</code>의 레코드 문법을 사용하면 이제 <code class=\"language-text\">startWithSymbol</code> 함수도 더 읽기 쉬운 형태로 다시 표현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">isPrefixOf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">name</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>심지어 Haskell이 제공하는 트릭을 사용하여 함수인 <code class=\"language-text\">isPrefixOf</code>를 중위 연산자로 표현하여 거의 하나의 자연어 문장처럼 읽히도록 만들어 볼 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">`isPrefixOf`</span> <span class=\"token hvariable\">name</span> <span class=\"token hvariable\">e</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2 id=\"63-합-타입sum-types\" style=\"position:relative;\">6.3 합 타입(Sum Types)<a href=\"#63-%ED%95%A9-%ED%83%80%EC%9E%85sum-types\" aria-label=\"63 합 타입sum types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>집합의 카테고리의 곱 연산에서 곱 타입을 유도할 수 있듯이, 합 연산에서 합 타입을 유도해볼 수도 있다. Haskell에서 합 타입을 표현하는 전형적인 방법은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Right</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>쌍과 마찬가지로 <code class=\"language-text\">Either</code>도 두 연산 대상이 동형성(Isomorphic)인 경우에 한해 교환 법칙을 만족하고 중첩도 가능하다. 또한 두 대상이 동형이라는 전제 하에 중첩 순서 또한 중요하지 않다. 그런 이유로 다음과 같이 세 개의 구성 요소를 가진 합 타입을 정의해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">OneOfThree</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Sinistral</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Medial</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Dextral</span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 집합의 카테고리가 합을 기준으로 대칭적인 모노이드 카테고리라는 것이 밝혀졌다. 여기서 이항 연산의 역할은 서로소 합에 의해 수행되며 단위 원소의 역할은 초기 대상에 의해 수행된다.</p>\n<p>타입 관점에서 바라보면 <code class=\"language-text\">Either</code>는 모노이드 연산자, 그리고 Uninhabited(아무런 값도 가질 수 없는) 타입인 <code class=\"language-text\">Void</code>는 이 연산에 대한 항등원으로 볼 수 있다. <code class=\"language-text\">Either</code>를 덧셈으로, <code class=\"language-text\">Void</code>를 0이라고 생각해보자. 실제로 <code class=\"language-text\">Void</code>를 합 타입에 추가하더라도 해당 타입의 내용은 변하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token constant\">Void</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 정의는 <code class=\"language-text\">a</code>와 동형(Isomorphic)이다. 그 이유는 <code class=\"language-text\">Void</code>는 아무런 값도 가질 수 없는 타입이기 때문에 이 합 타입에서 <code class=\"language-text\">Right</code> 생성자 부분을 채워넣을 방법이 없기 때문이다. <code class=\"language-text\">Either a Void</code> 타입을 가질 수 있는 유일한 값은 <code class=\"language-text\">Left</code> 생성자를 사용하여 생성되기 때문에 결과적으로는 그저 타입 <code class=\"language-text\">a</code>의 값을 캡슐화하는 역할만 하게 될 것이다. 따라서 형식적으로 <code class=\"language-text\">a + 0 = a</code>와 같은 관점이 성립한다.</p>\n<p>이처럼 Haskell에서는 합 타입이라는 개념이 일상적으로 사용되지만, C++의 합 타입이라고 할 수 있는 <code class=\"language-text\">union</code>이나 <code class=\"language-text\">variants</code>은 Haskell처럼 일상적으로 사용되지는 않는다.</p>\n<p>이에는 여러 이유가 있다. 일단 C++에서 간단한 합 타입은 굳이 <code class=\"language-text\">union</code>을 사용하지 않더라도 <code class=\"language-text\">enum</code> 키워드를 사용하여 선언하는 열거형(Enumerations)으로 표현할 수 있다.</p>\n<p>Haskell에서 합 타입을 표현하는 방법을 다시 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Color</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Red</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Green</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Blue</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 합 타입을 C++에서 다시 표현해보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">enum</span> <span class=\"token punctuation\">{</span> Red<span class=\"token punctuation\">,</span> Green<span class=\"token punctuation\">,</span> Blue <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>마찬가지로 Haskell에서는 간단한 합 타입 중 하나인 <code class=\"language-text\">Bool</code>을 아래와 같이 합 타입임을 명시하여 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Bool</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span> <span class=\"token operator\">|</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>하지만 C++에서 이러한 합 타입은 그저 원시 자료형인 <code class=\"language-text\">bool</code>일 뿐이다.</p>\n<p>C++에서 값의 존재나 부재를 인코딩하는 간단한 합 타입은 여러가지 트릭과 빈 문자열, 음수, Null 포인터와 같이 “불가능한” 값들을 사용하여 다양하게 구현되고 있다. 이렇게 선택적으로 값이 존재할 수 있는 경우 Haskell에서는 <code class=\"language-text\">Maybe</code> 타입을 사용하여 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Maybe</code> 타입은 두 타입의 합 타입으로 구성되어있다. Maybe 타입을 구성하는 두 생성자를 각각의 개별적인 타입으로 분리하면 아래와 같이 보일 것이다. 먼저 첫 번째 생성자를 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">NothingType</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 타입은 값이 단 하나뿐인 열거형(Enumeration)이며, <code class=\"language-text\">Nothing</code>이라는 하나의 값만 가지고 있다. 다시 말해 이 타입은 싱글톤, 즉 단일 원소 집합이며 이는 유닛 타입인 <code class=\"language-text\">()</code>와 동등하다.</p>\n<p>이제 두 번째 생성자도 한번 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">JustType</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사실 위 타입은 그저 타입 <code class=\"language-text\">a</code>를 캡슐화한 것에 불과하다. 결과적으로 우리는 <code class=\"language-text\">Maybe</code> 타입을 다음과 같이 표현할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>C++에서 이보다 더 복잡한 합 타입을 표현하고 싶을 때는 포인터를 사용하여 일종의 모방을 한다. 포인터는 <code class=\"language-text\">null</code>이거나 특정 타입인 값을 가리킬 수 있다. 예를 들어 Haskell의 <code class=\"language-text\">List</code> 타입은 재귀적인 합 타입으로 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Cons</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>C++에서 이 표현을 모방하려면 Null 포인터 트릭을 사용하여 빈 리스트를 구현하는 방법으로 시도해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">List</span> <span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> _head<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">List</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_head</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// Nil</span>\n    <span class=\"token function\">List</span><span class=\"token punctuation\">(</span>A a<span class=\"token punctuation\">,</span> List<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> l<span class=\"token punctuation\">)</span>       <span class=\"token comment\">// Cons</span>\n      <span class=\"token operator\">:</span> <span class=\"token function\">_head</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token generic-function\"><span class=\"token function\">Node</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 개의 Haskell 생성자인 <code class=\"language-text\">Nil</code>과 <code class=\"language-text\">Cons</code>는 오버로딩된 두 개의 <code class=\"language-text\">List</code> 생성자로 번역된다. <code class=\"language-text\">List</code> 클래스는 합 타입의 두 구성 요소를 구별하는데 별도의 태그가 필요하지는 않지만, 리스트의 헤드를 의미하는 <code class=\"language-text\">_head</code>를 <code class=\"language-text\">nullptr</code>로 초기화함으로써 <code class=\"language-text\">Nil</code> 생성자를 표현하고 있다.</p>\n<p>Haskell과 C++ 타입 간의 주요한 차이는 Haskell의 데이터 구조가 불변(Immutable)하다는 점에서 발생한다. 특정한 생성자를 사용하여 객체를 생성하면 해당 객체는 자신을 생성할 때 어떤 생성자가 사용되었는지, 그리고 어떤 인수가 전달되었는지 영원히 기억하고 있다. 따라서 <code class=\"language-text\">Just \"energy\"</code>로 생성된 <code class=\"language-text\">Maybe</code> 객체는 절대 <code class=\"language-text\">Nothing</code>으로 변하지 않는다는 것이다. 마찬가지로 빈 리스트는 영원히 빈 상태로 유지되며, 세 개의 원소를 가진 리스트는 영원히 동일한 세 개의 원소를 가진다.</p>\n<p>이러한 불변성은 구성 자체를 뒤집을 수 있도록 만들어주기도 한다. 주어진 객체를 항상 해당 구성에 사용된 부분으로 분해할 수 있다는 뜻이다. 이러한 분해에는 패턴 매칭이 사용되며 주어진 생성자를 패턴으로 다시 사용한다. 생성자에 인자가 주어진 경우 해당 인자는 변수로 대체된다.</p>\n<p><code class=\"language-text\">List</code> 데이터 타입은 두 개의 생성자를 가지고 있기 때문에 <code class=\"language-text\">List</code>를 해체할 때는 해당 생성자들에 각각 대응하는 두 가지 패턴을 사용해야 한다. 하나는 빈 <code class=\"language-text\">Nil</code> 리스트와 매칭될 것이고 다른 하나는 <code class=\"language-text\">Cons</code>로 생성된 리스트와 매칭될 것이다. 아래는 <code class=\"language-text\">List</code>에 대한 간단한 함수의 정의들이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">maybeTail</span> <span class=\"token operator\">::</span> <span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">maybeTail</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token hvariable\">maybeTail</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Cons</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">t</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">maybeTail</code>의 정의의 첫 번째 부분은 <code class=\"language-text\">Nil</code> 생성자를 패턴으로 사용하여 <code class=\"language-text\">Nothing</code>을 반환하고 있다. 두 번째 부분은 <code class=\"language-text\">Cons</code> 생성자를 패턴으로 사용하고 있는데, 생성자에게 주어진 첫 번째 인자는 필요없기 때문에 와일드 카드인 <code class=\"language-text\">_</code>로 대체하고 있다. 생성자에게 주어진 두 번째 인자는 변수 <code class=\"language-text\">t</code>에 바인딩되며 최종 반환 값은 <code class=\"language-text\">Just t</code>이다. 이제 <code class=\"language-text\">List</code>가 어떻게 생성되었느냐에 따라 두 정의 중 하나와 패턴 매칭이 될 것이다. 만약 <code class=\"language-text\">Cons</code>를 사용하여 생성되었다면 생성자에 전달된 두 인자 중 두 번째인자가 검색될 것이고 이후 <code class=\"language-text\">Just t</code>의 형태로 반환될 것이다.</p>\n<p>C++에서 이보다 더 복잡한 합 타입은 다형적인 클래스 계층을 사용하여 구현한다. 공통 조상을 가진 클래스 패밀리는 숨겨진 태그로 이해될 수 있으며, Haskell에서 생성자에 대한 패턴 매칭을 통해 수행되는 작업은 C++의 vtable 포인터를 기반으로 가상 함수 호출을 디스패치함으로써 수행된다.</p>\n<p>사실 C++에서는 합 타입을 온전하게 구현하기 어려운 여러가지 제약 때문에 <code class=\"language-text\">union</code>이 많이 사용되지는 않는다. 심지어 <code class=\"language-text\">string::std</code>이 복사 생성자(Copy Constructor)를 가지고 있기 때문에 <code class=\"language-text\">std::string</code>를 <code class=\"language-text\">union</code>에 넣을 수 조차 없다.</p>\n<h2 id=\"64-타입의-대수학\" style=\"position:relative;\">6.4 타입의 대수학<a href=\"#64-%ED%83%80%EC%9E%85%EC%9D%98-%EB%8C%80%EC%88%98%ED%95%99\" aria-label=\"64 타입의 대수학 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>곱 타입과 합 타입 모두 각각 데이터 구조를 정의할 때 유용하게 사용할 수 있지만, 실질적인 강점은 이 둘을 결합할 때 나타난다. 여기서 다시 한번 우리는 합성의 힘을 느끼게된다.</p>\n<p>먼저 우리가 지금까지 발견한 내용을 요약해보도록 하자. 타입 시스템의 기초에는 교환 법칙을 만족하는 두 가지 모노이달(Monoidal) 구조가 있다. 바로 <code class=\"language-text\">Void</code>를 항등원으로 가지는 합 타입과 유닛 타입인 <code class=\"language-text\">()</code>을 항등원으로 가지는 곱 타입이다. 우리는 이 개념들을 덧셈과 곱셉에 비유해서 생각해보려고 한다. 이 비유에서 <code class=\"language-text\">Void</code>는 덧셈의 항등원인 0, 그리고 <code class=\"language-text\">()</code>는 곱셈의 항등원인 1에 해당할 것이다.</p>\n<p>이 비유를 한번 어디까지 확장해서 적용할 수 있는지 보도록 하자. 우리는 이미 어떤 수에 0을 곱하게 되면 0이라는 결과를 얻는다는 사실을 알고 있다. 그렇다면 곱 타입인 쌍의 한 요소가 <code class=\"language-text\">Void</code>라면 이 타입은 Void와 동형일까? 예를 들면 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Void</code>를 구성요소로 가진 쌍을 만드는 것이 가능하냐는 것이다.</p>\n<p>쌍이라는 타입을 가진 값을 생성하기 위해서는 쌍의 구성 요소가 될 두 개의 값이 필요하다. 문제는 정수는 쉽게 만들 수 있지만 문제는 <code class=\"language-text\">Void</code> 타입의 값이 존재하지 않는다는 것이다. 따라서 모든 타입 <code class=\"language-text\">a</code>에 대해 타입 <code class=\"language-text\">(a, Void)</code>는 값을 가질 수 없는 타입(Uninhabited Type)이며, 결과적으로 <code class=\"language-text\">Void</code>와 동등하다. 다시 말해 <code class=\"language-text\">a*0 = 0</code>인 것이다.</p>\n<p>덧셈과 곱셈을 연결하는 또 다른 속성은 분배 법칙이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>곱셈과 덧셈의 분배 법칙이라는 속성은 일반적으로 곱 타입과 합 타입에도 적용될 수 있다. 위 식의 좌변은 아래와 같은 타입에 해당한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 우변은 아래와 같은 타입에 해당한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>좌변과 우변에 해당하는 타입들은 아래와 같은 방법을 통해 상호 변환될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">prodToSum</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">prodToSum</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">case</span> <span class=\"token hvariable\">e</span> <span class=\"token keyword\">of</span>\n      <span class=\"token constant\">Left</span>  <span class=\"token hvariable\">y</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Left</span>  <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>\n      <span class=\"token constant\">Right</span> <span class=\"token hvariable\">z</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한 위 함수의 역함수도 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">sumToProd</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">sumToProd</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">case</span> <span class=\"token hvariable\">e</span> <span class=\"token keyword\">of</span>\n      <span class=\"token constant\">Left</span>  <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Left</span>  <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>\n      <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Right</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">case of</code> 문은 함수 내에서 패턴 매칭에 사용된다. 주어진 변수가 화살표 왼쪽의 패턴과 일치한다면 화살표 오른쪽의 표현식이 실행되는 것이다. 예를 들어 <code class=\"language-text\">prodToSum</code> 함수를 호출해보는 상황을 한번 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">prod1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Float</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">prod1</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Left</span> <span class=\"token string\">\"Hi!\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">case e</code> 구문의 <code class=\"language-text\">e</code>는 <code class=\"language-text\">Left \"Hi!\"</code>에 해당한다. 이는 <code class=\"language-text\">Left y</code>라는 패턴과 일치하기 때문에 <code class=\"language-text\">y</code>는 <code class=\"language-text\">“Hi!”</code>라는 값으로 대체된다. 이 경우 <code class=\"language-text\">x</code>는 <code class=\"language-text\">2</code>에 매칭될 것이기 때문에 <code class=\"language-text\">case</code> 문을 사용한 전체 함수의 결과는 <code class=\"language-text\">Left(2, \"Hi!\")</code>가 되는 것이다.</p>\n<p>여기서 굳이 이 두 함수가 서로의 역함수임을 증명할 생각은 없지만, 가만 생각해보면 이 두 함수는 서로의 역함수여야하는 것이 당연하다. 왜냐하면 이 두 함수는 그저 자신이 받은 두 데이터 구조의 내용을 간단하게 재포장하는 것에 불과하기 때문이다. 즉, 데이터는 동일하지만 표현 방식이 다른 것 뿐이다.</p>\n<p>수학자들은 이처럼 얽혀있는 두 개의 모노이드에 대해 반환(Semiring)이라는 이름을 붙혔다. 이것은 이 경우 타입 간의 뺄셈에 대해서는 정의할 수 없기 때문에 완전한 “환(Ring)”이라고 말할 수는 없는 것이다.</p>\n<p>반환(Semiring)은 환(Ring)에서 음의 요소(<strong>N</strong>egative) n이 빠진 것이므로, 말장난처럼 “Rig”라고 부르기도 한다.</p>\n<p>하지만 음의 요소가 빠진 반환만으로도 자연수의 관한 명제를 타입에 관한 명제로 번역하여 많은 이점을 얻을 수 있다. 여기 몇 가지 흥미로운 항목들을 담은 번역 표가 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Numbers</th>\n<th>Types</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">0</code></td>\n<td><code class=\"language-text\">Void</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">1</code></td>\n<td><code class=\"language-text\">()</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">a+b</code></td>\n<td>`Either a b = Left a</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">a*b</code></td>\n<td><code class=\"language-text\">(a, b)</code> or <code class=\"language-text\">Pair a b = Pair a b</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">2=1+1</code></td>\n<td>`data Bool = True</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">1+a</code></td>\n<td>`data Maybe = Nothing</td>\n</tr>\n</tbody>\n</table>\n<p>리스트 타입은 특히 더 흥미로운데, 이 타입은 방정식의 해로 정의되기 때문이다. 우리가 정의하려는 타입은 일종의 방정식이며 아래와 같이 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Cons</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 방정식의 <code class=\"language-text\">List a</code>를 <code class=\"language-text\">x</code>로 치환해서 이 식을 일반화하면 아래와 같은 방정식을 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>하지만 타입의 세계에는 뺄셈이나 나눗셈이 없으니 우리는 이 문제를 전통적인 대수적 방법론으로는 해결할 수 없다. 하지만 이 식에 표현되어있는 녀석들을 치환하는 것 정도는 할 수 있다. 우변에 있는 <code class=\"language-text\">x</code>를 <code class=\"language-text\">(1 + a * x)</code>로 계속 해서 치환하고 분배 법칙을 사용해보자. 그러면 이제 이러한 식으로 이어질 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span>\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span>\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">...</span>\n\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">...</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>결국 이 식은 무한한 곱(튜플)의 합으로 끝나게 되는데, 이것은 리스트가 빈 경우 <code class=\"language-text\">1</code>, 단일 값인 경우 <code class=\"language-text\">a</code>, 쌍인 경우는 <code class=\"language-text\">a*a</code>, 트리플인 경우 <code class=\"language-text\">a*a*a</code>처럼 무한히 나아갈 것이라고 해석할 수 있다. 이게 결국 리스트의 정의 그 자체이다.</p>\n<p>이외에도 리스트에 대한 더 많은 내용들이 있지만, 다른 내용들에 대해서는 추후 펑터(Functor)와 고정점(Fixed Point)에 대해서 배운 후에 리스트와 같은 기타 재귀적인 데이터 구조에 대해서 다시 다룰 때 이야기를 해볼 것이다.</p>\n<p>결국 이처럼 기호로 표현되는 변수를 사용하여 어떠한 방정식을 해결하는 것이 바로 대수(Algebra)이며, 대수학으로 표현할 수 있는 타입에 이름을 붙힌 것이 대수적 데이터 타입(Algebraic Data Type)이다.</p>\n<p>마지막으로 타입의 대수에 대한 아주 중요한 해석 중 하나를 이야기하려고 한다. 두 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 곱 타입에는 <code class=\"language-text\">a</code> 타입의 값과 <code class=\"language-text\">b</code> 타입의 값이 모두 포함되어야 하지만, 두 타입의 합 타입에는 <code class=\"language-text\">a</code> 타입이나 <code class=\"language-text\">b</code> 타입의 값이 둘 중 하나라도 포함되어 있으면 충분하다. 이는 논리식인 AND와 OR도 반환(Semiring)을 형성한다는 것을 의미하며, 결국 논리식 또한 타입 이론으로 매핑될 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Logic</th>\n<th>Types</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">Void</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">()</code></td>\n</tr>\n<tr>\n<td>`a</td>\n<td>b`</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">a &amp;&amp; b</code></td>\n<td><code class=\"language-text\">(a, b)</code></td>\n</tr>\n</tbody>\n</table>\n<p>논리식과 타입 이론 간의 유사성은 이외에도 더 깊게 이어질 수 있으며, 커리-하워드 동형성(Curry-Howard Isomorphism)의 기초라고 할 수 있다. 이 내용에 대해서는 추후 함수 타입에 대해 이야기할 때 다시 살펴보도록 하겠다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240305-category-theory-for-programmers-6-simple-algebraic-data-types","path":"/2024/03/05/category-theory-for-programmers-6-simple-algebraic-data-types/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 6. 단순한 대수적 타입","subTitle":null,"date":"Mar 05, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"9562ca4b-c2f9-5e2e-b14c-225a051f1690","tableOfContents":"<ul>\n<li><a href=\"#51-%EC%B4%88%EA%B8%B0-%EB%8C%80%EC%83%81initial-object\">5.1 초기 대상(Initial Object)</a></li>\n<li><a href=\"#52-%EC%A2%85%EA%B2%B0-%EB%8C%80%EC%83%81terminal-object\">5.2 종결 대상(Terminal Object)</a></li>\n<li><a href=\"#53-%EC%8C%8D%EB%8C%80%EC%84%B1duality\">5.3 쌍대성(Duality)</a></li>\n<li><a href=\"#54-%EB%8F%99%ED%98%95%EC%84%B1isomorphisms\">5.4 동형성(Isomorphisms)</a></li>\n<li><a href=\"#55-%EA%B3%B1products\">5.5 곱(Products)</a></li>\n<li><a href=\"#56-%ED%95%A9coproduct\">5.6 합(Coproduct)</a></li>\n<li><a href=\"#57-%EB%B9%84%EB%8C%80%EC%B9%AD%EC%84%B1asymmetry\">5.7 비대칭성(Asymmetry)</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"고대 그리스의 시인 에우리피데스가 “사귀는 친구를 보면 그 사람을 알 수 있다.”라고 말했듯이, 우리의 존재는 우리가 가진 관계를 통해 정의된다. 카테고리 이론에서는 이 개념이 더더욱 중요하다. 만약 우리가 어떤 카테고리 내에 존재하는 특정 대상에 대해 명확하게 설명하기 위해서는 그 대상과 다른 대상들과의 관계까지도 함께 보아야 하기 때문이다. 그리고 이러한 관계는 사상(Morphism)에 의해 정의된다. (물론 여기서 관계라 함은 항등 사상으로 표현되는 자기 자신과의 관계 또한 포함된다.) 카테고리 이론에는 “보편적 구성(Uni…","html":"<p>고대 그리스의 시인 에우리피데스가 “사귀는 친구를 보면 그 사람을 알 수 있다.”라고 말했듯이, 우리의 존재는 우리가 가진 관계를 통해 정의된다. 카테고리 이론에서는 이 개념이 더더욱 중요하다. 만약 우리가 어떤 카테고리 내에 존재하는 특정 대상에 대해 명확하게 설명하기 위해서는 그 대상과 다른 대상들과의 관계까지도 함께 보아야 하기 때문이다. 그리고 이러한 관계는 사상(Morphism)에 의해 정의된다. (물론 여기서 관계라 함은 항등 사상으로 표현되는 자기 자신과의 관계 또한 포함된다.)</p>\n<p>카테고리 이론에는 “보편적 구성(Universal Construction)”이라고 불리는 방법이 존재한다. 이 구조는 각 대상들이 가지고 있는 관계를 통해 대상 자체를 정의하는 방법 중 하나이다. 이 방법은 먼저 특정 대상, 그리고 그 대상과 다른 대상 간의 관계를 나타내는 사상으로 구성된 특별한 패턴을 선택하고, 이 패턴이 카테고리 안에서 어떤 방식으로 나타나는지를 찾아내는 방식으로 진행된다. 만약 이 패턴이 일반적이고 카테고리의 크기가 충분히 크다면 이 패턴과 매칭되는 결과 또한 매우 많을 것이다. 결국 이 구성 방법의 핵심은 이렇게 찾아낸 무수한 결과들을 특정한 기준으로 평가하고 랭킹을 매겨 가장 적합한 결과를 찾아내는 것이다.</p>\n<p>이 과정은 마치 웹에서 검색을 하는 방식과 유사하다. 검색 쿼리는 일종의 패턴이다. 만약 이 쿼리가 매우 일반적인 쿼리라면 무수히 많은 쿼리 결과가 노출될 것이다. 이 결과 중 일부는 우리가 질의한 쿼리와 관련이 있을 수도 있지만 어떤 것들은 관련이 없을 수도 있다. 결국 우리는 관련없는 결과들을 제외하기 위해 쿼리를 더 세밀하게 다듬어가며 검색의 정확도를 높혀나간다. 최종적으로 검색 엔진은 이렇게 질의된 검색 결과들에게 랭킹을 매겨 결과를 순위 별로 나열하고, 사용자가 가장 관심을 가질만한 결과를 검색 결과 리스트의 최상단에 위치시킬 것이다.</p>\n<h2 id=\"51-초기-대상initial-object\" style=\"position:relative;\">5.1 초기 대상(Initial Object)<a href=\"#51-%EC%B4%88%EA%B8%B0-%EB%8C%80%EC%83%81initial-object\" aria-label=\"51 초기 대상initial object permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>카테고리 내에서 가장 단순한 형태는 단일 대상 그 자체이다. 아마 이렇게 단순한 형태의 패턴을 가진 무언가를 카테고리 내에서 찾아본다면, 당연히 패턴에 매칭되는 결과는 매우 많을 것이다.</p>\n<p>이처럼 일반적인 패턴을 사용하면 너무 많은 매칭 결과가 나오기 때문에, 우리는 이 결과들에 랭킹을 매길 수 있는 기준을 정하고 이 랭킹에서 비롯된 계층구조 내에서 가장 최상위에 있는 대상을 찾아야 한다. 앞서 말했듯이 이러한 대상을 정의하기 위해 우리가 사용해볼 수 있는 유일한 수단은 바로 사상이다.</p>\n<p>사상을 대상에서 다른 대상으로 향하는 일종의 화살표라고 생각해보자. 이 경우 카테고리의 한쪽 끝에서 다른쪽 끝으로 향하는 전반적인 화살표의 흐름이 존재할 수 있고, 만약 카테고리가 부분순서(Partial Order)와 같이 정렬되었다면 이 가정은 반드시 참이다. 그렇다면 어떠한 대상 <code class=\"language-text\">a</code>에서 다른 대상 <code class=\"language-text\">b</code>로 향하는 화살표(사상)가 존재하는 경우, “<code class=\"language-text\">a</code>가 <code class=\"language-text\">b</code>보다 더 초기적(Initial)이다”라고 정의하여 대상의 선행성이라는 개념을 일반화해볼 수 있다.</p>\n<p>이제 우리는 초기 대상이라는 개념을 “다른 모든 대상들로 향하는 화살표를 가진 대상”이라고 정의할 것이다. 물론 카테고리 내에 이런 대상이 반드시 존재하리란 보장은 없겠지만, 사실 이 문제보다는 오히려 이런 성질을 가진 대상이 너무 많을 수 있다는 것이 문제가 될 것이다. 다시 말해 쿼리의 검출율(Recall)은 높지만 정밀도(Precision)가 부족하다는 뜻이다.</p>\n<p>이 문제의 해결책에 대한 힌트는 정렬되어있는 카테고리(Ordered Categories)에서 얻을 수 있다. 대상 간의 순서가 명확하게 정의된 카테고리에서는 두 대상 간 최대 하나의 화살표만 허용되기 때문이다. 이러한 카테고리에서 어떤 대상이 다른 대상보다 작거나 같을 수 있는 방법은 하나 뿐이다. 이러한 사실을 토대로 우리는 초기 대상에 대해 다음과 같은 정의를 내려볼 수 있다.</p>\n<blockquote>\n<p>👉  “초기 대상”은 해당 카테고리 내에서 다른 대상으로 향하는 단 하나의 사상을 가진 유일한 대상이다.</p>\n</blockquote>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 608px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/38374193f4fa1493e2383b55a5a4734c/640be/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 105%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAVABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAMCBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7kaQjcFSoGIP/8QAGxABAAICAwAAAAAAAAAAAAAAAgABERIDEyH/2gAIAQEAAQUCa1I5d1Eveo0ohmYqA6V//8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAHBAAAgICAwAAAAAAAAAAAAAAABEBIQIQElFh/9oACAEBAAY/AmmKNcWO1jqqnsn0R//EABwQAQADAAMBAQAAAAAAAAAAAAEAESExUWEQQf/aAAgBAQABPyGyup+EEQK7v4NsGt3SWAeZUNJzV3A1nU9QaSvrP//aAAwDAQACAAMAAAAQF8g8/8QAFREBAQAAAAAAAAAAAAAAAAAAIHH/2gAIAQMBAT8Qo//EABcRAAMBAAAAAAAAAAAAAAAAAAERIEH/2gAIAQIBAT8QLyP/xAAdEAEBAAMAAgMAAAAAAAAAAAABEQAhMRBBUWGB/9oACAEBAAE/EHMP11nzlQ4V2z6k741a2UdCBr97gej2OlltNuIBGjswmbIQIHq50EPQ65C6qq1Vz//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/38374193f4fa1493e2383b55a5a4734c/640be/1.jpg\" srcset=\"/static/38374193f4fa1493e2383b55a5a4734c/0913d/1.jpg 160w,\n/static/38374193f4fa1493e2383b55a5a4734c/cb69c/1.jpg 320w,\n/static/38374193f4fa1493e2383b55a5a4734c/640be/1.jpg 608w\" sizes=\"(max-width: 608px) 100vw, 608px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>그러나 비록 이렇게 초기 대상에 대해 정의를 했고 실제로 초기 대상이 카테고리 안에 존재하는 것이 확인되었다고 해서 초기 대상이 카테고리 내에 유일하게 존재한다는 사실을 보장하는 것은 또 다른 이야기이다. 초기 대상의 유일성을 보장하기 위해 우리가 사용해볼 수 있는 유용한 아이디어는 바로 동형성(Isomorphism)이다. 동형성은 카테고리 이론에서 굉장히 중요한 부분을 차지하기 때문에 조만간 이에 대해서도 다룰테지만, 일단 지금은 동형성에 따라 초기 대상의 유일성을 보장할 수 있다는 점만 언급하고 넘어가도록 하겠다.</p>\n<p>간단한 예시를 한 번 보자. Poset이라고도 부르는 부분순서집합(Paritally Ordered Set)에서의 초기 대상은 이 집합에서 가장 작은 요소이다. 물론 이 개념이 모든 Poset에 적용되는 것은 아니고, 모든 정수(양수, 0, 음수)의 집합에 “작거나 같음” 관계를 적용한 특정 Poset같은 경우는 초기 대상이 존재하지 않는다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>초기 대상은 카테고리 내의 다른 모든 대상으로 향하는 사상을 가져야 한다. 그러나 “작거나 같음”이라는 사상을 가진 정수 집합은 무한 집합이기 때문에 “모든 정수에 대해 작거나 같기만 하는 관계를 가진 대상”이 존재할 수 없으므로 초기 대상이 존재하지 않는 것이다.</p>\n</blockquote>\n<p>반면 집합과 함수로 이루어진 카테고리에서 초기 대상은 공집합으로 정의할 수 있으며, 공집합은 Haskell에서의 <code class=\"language-text\">Void</code> 타입에 해당한다. 지난 챕터에서 우리가 <code class=\"language-text\">Void</code> 타입에서 임의의 다른 타입 <code class=\"language-text\">a</code>로 나아가는 <code class=\"language-text\">absurd</code> 함수를 정의했던 것을 기억하는가?</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">absurd</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Void</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>바로 이러한 종류의 사상들이 타입으로 이루어진 카테고리에서 <code class=\"language-text\">Void</code>를 초기 대상으로 만들어주는 녀석들이다.</p>\n<h2 id=\"52-종결-대상terminal-object\" style=\"position:relative;\">5.2 종결 대상(Terminal Object)<a href=\"#52-%EC%A2%85%EA%B2%B0-%EB%8C%80%EC%83%81terminal-object\" aria-label=\"52 종결 대상terminal object permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 단일 대상에 대한 패턴 이야기를 계속 해보자. 이번에는 대상에 대한 랭킹을 매기는 방식을 변경해볼 것이다. 우리는 어떠한 대상 <code class=\"language-text\">b</code>에서 대상 <code class=\"language-text\">a</code>로 향하는 사상이 있는 경우 ”<code class=\"language-text\">a</code>가 <code class=\"language-text\">b</code>보다 더 종결적(Terminal)이다”라고 이야기할 수 있다. 앞서 보았던 초기 대상과는 방향이 정반대라는 점에 주목하자. 우리는 카테고리 안에서 다른 대상들보다 더 많이 종결적인 대상을 찾아볼 것이다. 그리고 다시 한번 말하지만 이 검색 결과는 고유성을 가져야 한다.</p>\n<blockquote>\n<p>👉 종결 대상은 카테고리 내의 모든 객체로부터 오는 유일한 화살표를 가진 유일한 대상이다.</p>\n</blockquote>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ccbd3fc68e5ce8c978d1487a138556c0/c08c5/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 99.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIDBQT/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB2oy4k0EiqiLRX//EABwQAAICAgMAAAAAAAAAAAAAAAECAAMQMREhIv/aAAgBAQABBQJt8mDVillq6OAvqf/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABkQAAIDAQAAAAAAAAAAAAAAABARAAEhMf/aAAgBAQAGPwJHLU6y9H//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEQITFhof/aAAgBAQABPyFqBZADT7HezuVu324X5WRHZVwXH//aAAwDAQACAAMAAAAQW8i8/8QAFhEAAwAAAAAAAAAAAAAAAAAAESAh/9oACAEDAQE/EKU//8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EFA1iT//xAAdEAEBAAEFAQEAAAAAAAAAAAABEQAQITFRYYGx/9oACAEBAAE/EA77GMfuIS6yrQJ3vjhuDZxk8nYOvzJRZXiW+i+GEDYnmj05igC8un//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/ccbd3fc68e5ce8c978d1487a138556c0/c08c5/2.jpg\" srcset=\"/static/ccbd3fc68e5ce8c978d1487a138556c0/0913d/2.jpg 160w,\n/static/ccbd3fc68e5ce8c978d1487a138556c0/cb69c/2.jpg 320w,\n/static/ccbd3fc68e5ce8c978d1487a138556c0/c08c5/2.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>초기 대상과 마찬가지로 종결 대상 또한 동형성에 따라 카테고리 내에서 유일하게 존재한다고 이야기할 수 있다. 이에 대해서는 조만간 다시 설명하겠다.</p>\n<p>먼저 몇 가지 예제를 한번 살펴보도록 하겠다. 만약 Poset 내부에 종결 대상이 존재한다면 이는 아마 가장 큰 요소일 것이다. 집합의 카테고리에서의 종결 대상은 단일원소집합이다. 이미 우리는 단일원소집합에 대해서도 한번 이야기를 했었는데, 단일원소집합은 C++의 <code class=\"language-text\">void</code> 타입, Haskell에서는 <code class=\"language-text\">()</code>로 표현되는 Unit 타입에 해당한다.</p>\n<p>이것은 단 하나의 값만을 가진 타입으로, C++에서는 이러한 사실을 암묵적으로 표현하지만 Haskell에서는 <code class=\"language-text\">()</code> 라는 빈 괄호의 형태를 통해 명시적으로 표현하고 있다. 또한 이전 챕터에서 어떤 임의의 타입에서 Unit 타입으로 향하는 순수 함수는 단 하나만 존재할 수 있다는 사실 또한 언급했었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">unit</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">unit</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이렇게 종결 대상에 대한 모든 조건이 만족되었다.</p>\n<p>종결 대상에 대한 예시에서 유일성에 대한 조건이 중요한 이유는 결국 공집합을 제외한 다른 모든 집합들도 각각의 집합으로부터 오는 사상을 가질 수 있기 때문이다. 예를 들면 모든 타입을 받을 수 있고 <code class=\"language-text\">Boolean</code> 타입의 값을 반환하는 사상인 Predicate 함수가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">yes</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">yes</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러나 <code class=\"language-text\">Bool</code> 타입은 종결 대상이 아니다. 다른 타입에서 Bool 타입으로 향하는 함수는 <code class=\"language-text\">yes _ = True</code> 외에도 하나가 더 있기 때문에 유일한 사상이라고 말할 수 없기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">no</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">no</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, 우리는 종결 대상은 유일해야한다는 조건을 통해 종결 대상의 정의를 단 하나의 타입으로 좁힐 수 있는 정밀도를 만들어낼 수 있다.</p>\n<h2 id=\"53-쌍대성duality\" style=\"position:relative;\">5.3 쌍대성(Duality)<a href=\"#53-%EC%8C%8D%EB%8C%80%EC%84%B1duality\" aria-label=\"53 쌍대성duality permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여기까지 오면 여러분은 아마 초기 대상과 종결 대상을 정의하는 방식 간에 대칭성이 존재한다는 사실을 눈치챘을 것이다. 이 두 정의 사이의 유일한 차이점은 그저 사상의 방향 뿐이었다. 여기서 한발짝 더 나아가보자면 이제 우리는 어떤 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>가 가진 모든 사상의 방향을 반대로 뒤집어서 반대 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>를 정의할 수도 있을 것이다.</p>\n<p>반대 카테고리는 그저 특정 카테고리의 사상의 방향을 반대로 뒤집은 것 뿐이니 당연히 사상의 합성 규칙이나 다른 요구사항도 만족한다. 만약 원래 카테고리에서 사상 <code class=\"language-text\">f::a->b</code>와 <code class=\"language-text\">g::b->c</code>가 사상 <code class=\"language-text\">h::a->c</code>로 합성되었다면, 반대 카테고리의 뒤집힌 사상인 <code class=\"language-text\">f^op::b->a</code>와 <code class=\"language-text\">g^op::c->b</code>  또한 <code class=\"language-text\">h^op::c->a</code>로 합성된다는 것이다. 그리고 각 대상에 대한 항등사상을 반대로 뒤집는 것은 의미가 없으므로, 항등사상은 그대로 유지된다.</p>\n<p>쌍대성(Duality)이라는 개념은 수학자들이 카테고리 이론을 사용할 때의 생산성을 두 배로 높혀주기 때문에 꽤 중요한 속성으로 취급된다. 우리가 구성한 모든 것들에는 그와 대응하는 것들이 존재하며, 증명하는 모든 정리들에 대응하는 정리들 또한 자동으로 따라오기 때문이다.</p>\n<p>반대 카테고리의 구성 요소들은 곱(product)와 쌍대곱(coproduct), 모나드(monad)와 쌍대모나드(comonad), 콘(cone)과 쌍대콘(cocone), 극한(limit)과 쌍대극한(colimit)과 같이 “co 또는 쌍대”라는 접두사가 붙어있다. 그러나 cocomonad와 같은 개념은 존재하지 않는다. 왜냐하면 화살표를 두 번 뒤집으면 다시 원래 상태로 돌아오기 때문이다.</p>\n<p>즉, 위의 정의에 따라 반대 카테고리에서의 초기 대상은 종결 대상이다.</p>\n<h2 id=\"54-동형성isomorphisms\" style=\"position:relative;\">5.4 동형성(Isomorphisms)<a href=\"#54-%EB%8F%99%ED%98%95%EC%84%B1isomorphisms\" aria-label=\"54 동형성isomorphisms permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리는 프로그래머로서 같다는 개념, 즉 동등성(Equality)을 정의한다는 것이 쉽지 않다는 것을 이미 잘 알고 있다. 두 개의 대상이 같다는 것은 무엇을 의미하는 걸까? 메모리에서 동일한 위치를 차지하는 것을 의미할까? 이 대상이 집합이라면 원소들이 전부 동일하면 같다고 봐야할까? 혹은 하나는 실수부와 허수부로 표현되고, 다른 하나는 크기와 각도로 표현되는 복소수라면 이 두 복소수는 같다고 봐야할까?</p>\n<p>아마 여러분은 수학자들이 이미 동등성에 대한 의미를 찾아냈을 것이라고 생각하겠지만, 사실 수학자들도 아직 동등성이 무엇인가에 대한 명확한 정의를 내리지 못 했다. 동등성에 대한 정의에는 명제 동등성, 의미 동등성, 확장 동등성, 호모토피 유형 이론에서의 경로로 정의되는 동등성 등 여러가지 방법이 제시된다. 그리고 동등성보다 더 약한 개념인 동형성, 그리고 동형성보다도 더 약한 개념인 등가성이라는 개념도 있다.</p>\n<p>우선 동형에 대해 직관적으로 이해해보자면 동형이라는 의미는 동일한 형태를 가지고 있다는 말이니 동형인 대상들은 서로 비슷하게 보일 것이다. 비슷하게 보인다는 것은 어떤 한 대상의 각 부분들이 다른 대상의 어떠한 부분과 일대일로 대응된다는 것을 의미한다. 즉, 상대적인 상황에 따라 조금씩 달라질 수는 있지만 대체로 동형인 두 대상은 서로 완벽한 복사본처럼 보일 수 있다는 것이다.</p>\n<p>수학적으로 이야기해보자면 어떤 대상 <code class=\"language-text\">a</code>에서 대상 <code class=\"language-text\">b</code>로의 매핑이 존재하고 대상 <code class=\"language-text\">b</code>에서 대상 <code class=\"language-text\">a</code>로 향하는 매핑이 존재하며, 이 두 매핑이 서로의 역함수라는 것을 의미한다. 또한 우리는 이미 카테고리 이론에서 이러한 매핑을 사상이라고 한다는 것을 잘 알고 있다. 정리해보자면 두 대상이 동형이라는 의미는 두 대상이 서로에게 향하는 사상을 가지고 있고, 이 사상들이 서로의 반대 개념인 역사상(Inverse Morphism)이 되어야 한다는 것이다.</p>\n<p>이러한 역사상에 대한 개념은 합성과 항등이라는 개념을 통해 이해하는 것이 쉽다. 사상 <code class=\"language-text\">g</code>가 사상 <code class=\"language-text\">f</code>의 역사상이라면, 이 두 사상의 합성사상은 항등사상이 되어야 한다. 이러한 관계를 나타낼 수 있는 식은 총 두 가지가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">id</span>\n<span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">id</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>앞서 필자가 초기 대상이나 종결 대상이 동형성을 기준으로 했을때 카테고리 내에 유일하게 존재한다고 말한 것은 어떤 두 초기 대상 또는 종결 대상이 서로 동형(Isomorphic) 관계에 있다는 것을 의미한다는 설명이었다.</p>\n<p>말이 조금 어렵게 느껴지지만 조금만 생각해보면 쉽게 이해할 수 있다. 한번 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>과 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>라는 두 초기 대상이 있다고 가정해보자. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>은 초기 대상이니 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 향하는 유일한 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>가 존재할 것이다. 마찬가지로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>또한 초기 대상이니 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 향하는 유일한 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>가 존재한다. 그렇다면 이 두 사상의 합성은 무엇일까?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 320px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/516e915f7161e4ca2ff7bc7baff41e50/cb69c/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdp0ihh//8QAGRABAAMBAQAAAAAAAAAAAAAAARESIQAi/9oACAEBAAEFAre1qGkE1zv/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAADAQAAAAAAAAAAAAAAAAAAESAh/9oACAEBAAY/AkbP/8QAGhABAQEBAQEBAAAAAAAAAAAAAREAITFRcf/aAAgBAQABPyEdPt8y08335m0SOWpNPHf3BCG//9oADAMBAAIAAwAAABBgz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQADAQEBAAAAAAAAAAAAAAEAESExQbH/2gAIAQEAAT8QBkLPmqxH7ET2uHLOQSLgg3TCVxCqeTW1W3rTYAAAcDyf/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/516e915f7161e4ca2ff7bc7baff41e50/cb69c/3.jpg\" srcset=\"/static/516e915f7161e4ca2ff7bc7baff41e50/0913d/3.jpg 160w,\n/static/516e915f7161e4ca2ff7bc7baff41e50/cb69c/3.jpg 320w\" sizes=\"(max-width: 320px) 100vw, 320px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이 다이어그램에 존재하는 모든 사상은 전부 유일하게 존재한다.</small>\n</center>\n<p>위 그림을 보면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>를 합성한 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> 사상은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>에서 출발해 다시 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 돌아가는 사상이 된다. 그러나 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>은 초기 대상이니 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 향하는 사상은 반드시 항등 사상 하나만 존재해야하는데, 모든 카테고리에는 항등 사상이 반드시 존재해야 하기 때문에 이 사상을 제거할 수는 없다. 결국 이러한 제약으로 인해 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>는 항등 사상일 수 밖에 없는 것이다. 마찬가지로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 향하는 사상도 결국 하나만 존재할테니, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">f\\circ g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>도 항등사상이라고 할 수 있다. 이렇게 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>가 서로의 역이 되어야 한다는 것이 입증됨으로써 어떤 두 초기 대상이든 모두 동형 관계에 놓인다는 사실 또한 증명되었다.</p>\n<p>위 증명 과정에서는 초기 대상에서 다시 자기 자신에게 향하는 사상의 유일성을 사용했다. 만약 이 유일성이 보장되지 않는다면 “동형성을 기준으로 유일하다”라는 명제를 증명할 수 없다.</p>\n<p>그런데 왜 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>의 유일성이 필요한걸까? 그 이유는 두 초기 대상이 동형이라는 가정에서 출발하여 초기 대상의 유일함을 증명하기 위해서는 이 동형성마저도 유일하다는 조건이 만족되어야 하기 때문이다. 원칙적으로는 두 대상 간의 여러 개의 동형성이 존재할 수 있겠지만, 이번에 살펴본 예시에서의 두 초기 대상은 서로에게 동형이 될 수 있는 케이스가 단 하나만 존재한다. 이처럼 “유일한 동형성을 기준으로 유일하다”는 것은 보편적 구성의 매우 중요한 특징이다.</p>\n<h2 id=\"55-곱products\" style=\"position:relative;\">5.5 곱(Products)<a href=\"#55-%EA%B3%B1products\" aria-label=\"55 곱products permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>다음으로 살펴볼 보편적 구성은 바로 곱의 개념이다. 우리는 두 집합의 데카르트 곱(Cartesian Product)이 쌍으로 이루어진 집합이라는 것을 알고 있다. 그렇다면 곱 집합과 곱 집합 내부의 쌍을 이루는 구성 요소 집합들을 연결해주는 패턴은 무엇일까? 우리가 이 패턴을 이해할 수만 있다면 이제 다른 카테고리에도 일반화해서 적용해볼 수 있을 것이다.</p>\n<blockquote>\n<p><strong>💡 역주</strong></p>\n<p>만약 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">A = \\{1, 2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span></span>이고, 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">B = \\{a, b\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">}</span></span></span></span></span>라면 이 두 집합의 데카르트 곱은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">A\\times B = \\{(1,a),(1,b),(2,a),(2,b)\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)}</span></span></span></span></span>와 같이 각 집합의 원소로 구성된 튜플을 원소로 가진 집합으로 정의된다. 즉, 구성 요소 집합이라는 의미는 데카르트 곱 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\times B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>의 원소들인 각 튜플을 구성하고 있는 값들의 집합이라는 의미이며, 결국 곱 연산의 재료로 사용된 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>와 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>를 의미하는 것이다.</p>\n<p>여기서 역자가 데카르트 곱의 원소가 쌍(Pair)이 아닌 튜플(Tuple)이라고 설명한 이유는, 데카르트 곱이 이항연산이 아니기 때문이다. 즉, 이 연산에는 두 개 이상의 집합이 사용될 수 있으며 데카르트 곱의 원소의 형태도 (x, y, z, …)처럼 계속 길어질 수 있다는 의미이다. 쌍이란 순서가 있는 2개의 구성요소를 가진 개념이고, 튜플은 n개의 구성요소를 가진 개념이므로 엄밀한 정의는 튜플이라고 하는 것이 맞다.</p>\n<p>다만 작가는 여기서 “두 집합의 데카르트 곱”이라는 전제를 깔고 있기 때문에 데카르트 곱의 원소들이 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(1,a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span></span>와 같은 쌍의 형태라고 말하고 있는 것이다.</p>\n</blockquote>\n<p>일단 우리가 당장 확실하게 이야기할 수 있는 것은 곱 집합에서 각 구성 요소로 향하는 두 개의 함수, 즉 투영 사상(Projections)이 존재한다는 것이다. Haskell에서는 이 두 함수를 <code class=\"language-text\">fst</code>와 <code class=\"language-text\">snd</code>라고 부르며, 이 함수들은 각각 쌍의 첫 번째와 두 번째 구성요소를 선택한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fst</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">fst</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token builtin\">snd</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n<span class=\"token builtin\">snd</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">y</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수들은 인자를 패턴 매칭하는 형태로 정의된다. 임의의 쌍에 매칭되는 패턴은 위 코드의 <code class=\"language-text\">(x, y)</code>이며, 최종적으로는 이렇게 매칭된 쌍에 접근하여 각 구성요소를 변수 <code class=\"language-text\">x</code>와 <code class=\"language-text\">y</code>로 추출한다.</p>\n<p>이 정의는 와일드카드(<code class=\"language-text\">_</code>)를 사용하면 더 간단하게 표현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fst</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n<span class=\"token builtin\">snd</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">y</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>C++에서 이와 같은 동작은 템플릿 함수를 사용하여 구현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span> A\n<span class=\"token function\">fst</span><span class=\"token punctuation\">(</span>pair<span class=\"token operator\">&lt;</span>A<span class=\"token punctuation\">,</span> B<span class=\"token operator\">></span> <span class=\"token keyword\">const</span> <span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 내용을 토대로 집합의 카테고리에서 두 집합 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 곱집합을 구성할 수 있는 대상과 사상의 패턴을 정의해보겠다.</p>\n<p>이 패턴은 대상 <code class=\"language-text\">c</code>와 그것을 각각 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>에 연결해주는 두 개의 사상 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>로 구성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">q</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 417px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/21474f37fbfc536731aa732ab1037274/6eca5/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB70aahiK//8QAGxABAAICAwAAAAAAAAAAAAAAARESAAIQITH/2gAIAQEAAQUCWMs68V7SQ8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAADAAMAAAAAAAAAAAAAAAAAECEBEYH/2gAIAQEABj8CLxWmsr//xAAbEAEAAwADAQAAAAAAAAAAAAABABEhEDFRQf/aAAgBAQABPyEaX9gLPbW9eNWeGw8hv0MuabfZ/9oADAMBAAIAAwAAABALD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABYRAAMAAAAAAAAAAAAAAAAAABARIf/aAAgBAgEBPxBUf//EAB0QAAIBBAMAAAAAAAAAAAAAAAERACExQVEQYdH/2gAIAQEAAT8QNtW2BFx4Cy4u+8rXF7ahCnpYMFkSBFFGCCF2ic//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/21474f37fbfc536731aa732ab1037274/6eca5/4.jpg\" srcset=\"/static/21474f37fbfc536731aa732ab1037274/0913d/4.jpg 160w,\n/static/21474f37fbfc536731aa732ab1037274/cb69c/4.jpg 320w,\n/static/21474f37fbfc536731aa732ab1037274/6eca5/4.jpg 417w\" sizes=\"(max-width: 417px) 100vw, 417px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이 패턴에 부합하는 모든 <code class=\"language-text\">c</code>는 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 곱집합의 후보라고 볼 수 있다. 하지만 문제는 이런 후보들이 한두개가 아니라는 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/497145782e1ce89bc605805e3ade82a8/c08c5/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 50.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAduNwA//xAAZEAEAAgMAAAAAAAAAAAAAAAABAAIQITH/2gAIAQEAAQUCbbVhzP8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAgMAAAAAAAAAAAAAAAAAAREAICH/2gAIAQEABj8CQjOV/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARQSAh/9oACAEBAAE/IazQsEHoMyKw8f/aAAwDAQACAAMAAAAQMM//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAEAAQUBAAAAAAAAAAAAAAABEQAQITFBof/aAAgBAQABPxDIoyo1M0BmUrzlaIycsk2//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/497145782e1ce89bc605805e3ade82a8/c08c5/5.jpg\" srcset=\"/static/497145782e1ce89bc605805e3ade82a8/0913d/5.jpg 160w,\n/static/497145782e1ce89bc605805e3ade82a8/cb69c/5.jpg 320w,\n/static/497145782e1ce89bc605805e3ade82a8/c08c5/5.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>예를 들어 두 개의 Haskell 타입, <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Bool</code>을 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>라고 생각하고 이 타입(집합)들에 대한 곱집합 후보를 한번 살펴보자.</p>\n<p>자, <code class=\"language-text\">Int</code> 타입은 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Bool</code> 타입의 곱집합 후보가 맞을까? 맞다. 아래 투영 사상들을 한번 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">p</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token hvariable\">q</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">q</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 정의는 단순 그 자체이지만, 우리가 정의했던 기준에는 부합한다. 그러면 이번에는 세 개의 구성 요소로 이루어진 튜플인 <code class=\"language-text\">(Int, Int, Bool)</code>을 살펴보자. 이 튜플 또한 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Bool</code>의 곱집합이 될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Bool</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">p</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token hvariable\">q</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Bool</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">q</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>아마도 이미 눈치챘겠지만 우리가 찾아낸 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Bool</code>의 곱집합 후보 중 첫 번째 후보는 곱의 Int 차원만을 다루고 있어 너무 작다고 느껴지고, 두 번째 후보는 Int 차원을 중복시켜놓았으니 너무 크다고 느껴진다.</p>\n<p>이제 보편적 구성(Universal Construction)의 랭킹 개념이 등장할 차례이다. 이제 우리는 패턴에 일치되어 뽑힌 두 결과 후보를 비교해볼 수 있을 것이다.</p>\n<p>우선 <code class=\"language-text\">c</code>가 <code class=\"language-text\">c'</code>보다 “더 나은 경우”를 설명하고 싶은 상황이라고 가정하고, 하나의 후보 대상인 <code class=\"language-text\">c</code>와 이 대상의 투영 사상 <code class=\"language-text\">p</code>, <code class=\"language-text\">q</code>를 다른 후보 대상인 <code class=\"language-text\">c'</code>와 이 대상의 투영 사상 <code class=\"language-text\">p'</code>, <code class=\"language-text\">q'</code>와 비교해보려고 한다.</p>\n<p>만약 <code class=\"language-text\">c'</code>에서 <code class=\"language-text\">c</code>로 향하는 임의의 사상 <code class=\"language-text\">m</code>이 존재한다면 경우 <code class=\"language-text\">c</code>가 더 낫다고 말할 수 있겠지만, 그래도 이런 설명은 너무 빈약하다. 우리는 대상 뿐 아니라 이 대상이 가진 투영 사상들에 대해서도 어떤 것이 더 낫다고 설명할 수 있어야하기 때문이다. 즉, 투영 사상 <code class=\"language-text\">p'</code>와 <code class=\"language-text\">q'</code> 또한 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>, 그리고 사상 <code class=\"language-text\">m</code>의 합성을 통해 구성될 수 있어야 한다는 의미이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">p</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m</span>\n<span class=\"token hvariable\">q'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">q</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 541px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/064dcc92871175f26dde24e634e3cce2/8af7b/6.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 81.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHeWVHkB//EABkQAQACAwAAAAAAAAAAAAAAAAEAEgIRIv/aAAgBAQABBQJdQy6jZaIE/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAgMAAAAAAAAAAAAAAAAAARAAElH/2gAIAQEABj8CeCGq/8QAGxAAAwEAAwEAAAAAAAAAAAAAAREhABAxUUH/2gAIAQEAAT8h+jUMHtAcBHD2vFk02+4mKFv/2gAMAwEAAgADAAAAELPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAIDAQEAAAAAAAAAAAAAAREhADFBURD/2gAIAQEAAT8QAjK2KMVpCDbGJs578isZsOxyvMiA4LTTU6oxBUfR5n//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"\" src=\"/static/064dcc92871175f26dde24e634e3cce2/8af7b/6.jpg\" srcset=\"/static/064dcc92871175f26dde24e634e3cce2/0913d/6.jpg 160w,\n/static/064dcc92871175f26dde24e634e3cce2/cb69c/6.jpg 320w,\n/static/064dcc92871175f26dde24e634e3cce2/8af7b/6.jpg 541w\" sizes=\"(max-width: 541px) 100vw, 541px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이 방정식을 바라보는 다른 방법은 사상 <code class=\"language-text\">m</code>이 투영 사상 <code class=\"language-text\">p'</code>와 <code class=\"language-text\">q'</code>를 인수분해한다고 보는 것이다. 이 방정식들의 변수들이 함수가 아니라 자연수, 그리고 함수의 합성을 의미하는 점(<code class=\"language-text\">.</code>)이 곱셉 연산 기호라고 가정해보자. 결국 <code class=\"language-text\">m</code>은 <code class=\"language-text\">p'</code>와 <code class=\"language-text\">q'</code>가 공유하는 공통 인수라는 사실을 알 수 있다.</p>\n<p>좀 더 직관적인 이해를 위해, <code class=\"language-text\">fst</code>, <code class=\"language-text\">snd</code> 라는 두 표준 투영 사상을 가진 <code class=\"language-text\">(Int, Bool)</code> 쌍이 앞서 알아봤던 두 개의 후보보다 더 나은 후보가 맞는지를 직접 보여주겠다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 320px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/bff3233c699c3f1604778632826dfb07/cb69c/7.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 69.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHdgMsEH//EABoQAAICAwAAAAAAAAAAAAAAAAABAhEQEiH/2gAIAQEAAQUCbFzCiaCuv//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAAMBAAAAAAAAAAAAAAAAAAAQIQH/2gAIAQEABj8Cd1U//8QAGxAAAgMAAwAAAAAAAAAAAAAAAREAIUEQMaH/2gAIAQEAAT8hQV7DHQtnTfBbuZahBECqyKDU/9oADAMBAAIAAwAAABCjD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEAAwEBAAAAAAAAAAAAAAERADFBIRD/2gAIAQEAAT8QTSCVT4ZE4J0Pia2ENThjWUsTxgCQglO5/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"7\" title=\"\" src=\"/static/bff3233c699c3f1604778632826dfb07/cb69c/7.jpg\" srcset=\"/static/bff3233c699c3f1604778632826dfb07/0913d/7.jpg 160w,\n/static/bff3233c699c3f1604778632826dfb07/cb69c/7.jpg 320w\" sizes=\"(max-width: 320px) 100vw, 320px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>첫 번째 후보를 위한 사상 <code class=\"language-text\">m</code>은 다음과 같이 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Bool</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">m</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">True</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 두 투영 사상 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>는 다음과 같이 재구성될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fst</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">m</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n<span class=\"token hvariable\">q</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">snd</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">m</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또한 두 번째 후보의 <code class=\"language-text\">m</code> 또한 아래와 같이 유일한 형태로 결정된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이렇게 <code class=\"language-text\">(Int, Bool)</code>이 다른 두 곱집합 후보보다 더 낫다는 사실을 보였다. 그럼 이제 반대 경우가 성립하지 않는 이유를 살펴보도록 하자. <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>에서 <code class=\"language-text\">fst</code>와 <code class=\"language-text\">snd</code>를 재구성할 수 있는 <code class=\"language-text\">m’</code>을 찾을 수 있을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fst</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">p</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m'</span>\n<span class=\"token builtin\">snd</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">q</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>첫 번째 곱집합 후보에서 <code class=\"language-text\">q</code>는 항상 <code class=\"language-text\">True</code>를 반환했지만, 우리는 이미 두 번째 요소가 <code class=\"language-text\">False</code>인 쌍 또한 존재할 수 있다는 사실을 알고 있다. 결국 이에 따라 <code class=\"language-text\">q</code>를 통해 <code class=\"language-text\">snd</code>를 재구성할 수는 없다는 것을 알 수 있다.</p>\n<p>두 번째 예제는 조금 다르다. 두 번째 예제는 <code class=\"language-text\">p</code> 또는 <code class=\"language-text\">q</code> 중 하나를 실행한 이후에도 충분한 정보들을 유지하고 있지만, 이번에는 <code class=\"language-text\">fst</code>와 <code class=\"language-text\">snd</code>를 인수분해하는 방법이 너무 많다는 것이 문제가 된다.</p>\n<p>두 번째 후보의 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>는 모두 3개의 구성요소 중 두 번째 요소를 무시하기 때문에 <code class=\"language-text\">m'</code> 에 어떤 값을 넣어도 전부 말이 된다. 즉 아래와 같은 예시들이 있을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m'</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 또는</span>\n<span class=\"token hvariable\">m'</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 기타 등등...</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>정리해보자면 어떤 두 투영 사상 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>를 가지는 타입 <code class=\"language-text\">c</code>가 주어졌을 때 이들을 인수분해할 수 있는 <code class=\"language-text\">m</code>은 유일하게 존재해야하는 후보가 가장 적합한 곱집합 후보라고 볼 수 있다. 사실 이 <code class=\"language-text\">m</code>은 단순히 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>를 하나의 쌍으로 결합하는 녀석이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">m</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">p</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">q</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이러면 결국 데카르트 곱 <code class=\"language-text\">(a, b)</code>가 가장 최적의 선택이 되며, 결국 이는 어떠한 두 집합의 곱을 선택하는 것과 동일하므로 이러한 보편적 구성이 집합 카테고리 위에서 제대로 작동한다는 것을 의미한다.</p>\n<p>자 이제 집합에 대한 것은 모두 잊어버리고, 동일한 보편적 구성을 이용하여 임의의 카테고리에서 두 대상에 대한 곱을 정의해보도록 하자. 이러한 곱이 항상 존재한다고 말하기는 어렵지만, 만약 존재한다면 독특하게 유일한 동형성(Isomorphism)을 가지게 된다.</p>\n<blockquote>\n<p>👉 두 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 곱은 “두 투영 사상을 갖춘 대상 <code class=\"language-text\">c</code>“이며, 다른 “두 투영 사상을 갖춘 대상 <code class=\"language-text\">c'</code>“에 대해 그 투영 사상들을 인수분해하는 유일한 사상 <code class=\"language-text\">m</code>이 존재하는 경우를 의미한다.</p>\n</blockquote>\n<p><code class=\"language-text\">c</code>와 <code class=\"language-text\">c'</code> 두 후보로부터 인수분해 사상 <code class=\"language-text\">m</code>을 생성하는 고차함수는 <code class=\"language-text\">factorizer</code>라고 불린다. 앞서 살펴본 예시의 경우에는 아래와 같은 함수가 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorizer</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">factorizer</span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">q</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">p</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">q</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h2 id=\"56-합coproduct\" style=\"position:relative;\">5.6 합(Coproduct)<a href=\"#56-%ED%95%A9coproduct\" aria-label=\"56 합coproduct permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>카테고리의 모든 구성 요소들과 마찬가지로 곱(Product)에도 대응되는 개념이 존재하는데, 이를 반대곱(Coproduct) 또는 합이라고 한다. 앞서 살펴보았던 곱의 패턴에서 화살표를 반대로 하면 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>에서부터 <code class=\"language-text\">c</code>로 향하는 두 개의 삽입 사상을 가진 대상 <code class=\"language-text\">c</code>를 만들어볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">i</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span>\n<span class=\"token hvariable\">j</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 616px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d472bf852bdba883d0bdeac5212604c2/4ae3a/8.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 62.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7WWnDDlf/8QAGxAAAgIDAQAAAAAAAAAAAAAAAQIAERASITH/2gAIAQEAAQUCphC1xeKfFTXH/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAgMBAQAAAAAAAAAAAAAAAREAECECYf/aAAgBAQAGPwI6xFyjkDo+1//EABsQAQEBAAIDAAAAAAAAAAAAAAERABAxIVGB/9oACAEBAAE/IT4Svea3R9usECqHnVUY4mxWrx//2gAMAwEAAgADAAAAEMsP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHhABAAICAQUAAAAAAAAAAAAAAREhAFEQMUFhcZH/2gAIAQEAAT8Qb0EehuXvkgQGbFouL38wYggrtjzgQSBTExl5UggB64//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"8\" title=\"\" src=\"/static/d472bf852bdba883d0bdeac5212604c2/4ae3a/8.jpg\" srcset=\"/static/d472bf852bdba883d0bdeac5212604c2/0913d/8.jpg 160w,\n/static/d472bf852bdba883d0bdeac5212604c2/cb69c/8.jpg 320w,\n/static/d472bf852bdba883d0bdeac5212604c2/4ae3a/8.jpg 616w\" sizes=\"(max-width: 616px) 100vw, 616px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이는 단지 곱의 패턴에서 화살표를 반대로 뒤집은 것 뿐이므로 랭킹 또한 역전된 형태를 띈다. 대상 <code class=\"language-text\">c</code>가 삽입 사상 <code class=\"language-text\">i’</code>와 <code class=\"language-text\">j’</code>를 갖춘 대상 <code class=\"language-text\">c’</code>보다 더 낫다고 이야기하려면, 삽입 사상을 인수분해하는 사상 <code class=\"language-text\">m</code>이 존재해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">i'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">i</span>\n<span class=\"token hvariable\">j'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">j</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 575px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/64afd72f0aa385b61631a29cde698ded/8c797/9.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 83.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9uaYxq6VYFB//8QAGRABAAMBAQAAAAAAAAAAAAAAAQACERIg/9oACAEBAAEFAnR7ldxNlB8//8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGxAAAQQDAAAAAAAAAAAAAAAAAAEQEiEgMWH/2gAIAQEABj8C4UXtllj/AP/EABsQAAIDAAMAAAAAAAAAAAAAAAABESExIJGh/9oACAEBAAE/IWyy3hF5bjaKJISyUiY++P8A/9oADAMBAAIAAwAAABCIxwD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAfEAACAgIBBQAAAAAAAAAAAAABESExAFFxIEFhgcH/2gAIAQEAAT8QhW0hlrzj6JUFFy64vBrbEotTg0Owv3lcDQhBbkl/On//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"9\" title=\"\" src=\"/static/64afd72f0aa385b61631a29cde698ded/8c797/9.jpg\" srcset=\"/static/64afd72f0aa385b61631a29cde698ded/0913d/9.jpg 160w,\n/static/64afd72f0aa385b61631a29cde698ded/cb69c/9.jpg 320w,\n/static/64afd72f0aa385b61631a29cde698ded/8c797/9.jpg 575w\" sizes=\"(max-width: 575px) 100vw, 575px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이렇게 찾아낸 가장 잘 들어맞는 대상, 다른 패턴으로 연결되는 유일한 사상을 가지고 있는 대상을 합이라고 하며, 만약 카테고리 내에 합이 존재한다면 이 합은 카테고리 내에서 특정한 두 대상의 결합을 나타내는 유일한 방법을 제공한다는 것을 의미한다.</p>\n<blockquote>\n<p>👉 두 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 합은 두 개의 삽입 사상을 가진 대상 <code class=\"language-text\">c</code>로 정의된다. 만약 다른 대상 <code class=\"language-text\">c'</code> 또한 두 삽입 사상을 갖추고 있다면, <code class=\"language-text\">c</code>에서 <code class=\"language-text\">c'</code>로 향하는 유일한 사상 <code class=\"language-text\">m</code>이 존재하며, 이는 <code class=\"language-text\">c</code>가 가진 삽입 사상 <code class=\"language-text\">i</code>와 <code class=\"language-text\">j</code>를 인수분해한다.</p>\n</blockquote>\n<p>집합의 카테고리에서 합은 두 집합의 서로소 합집합(Disjoint Union)이다. 집합 <code class=\"language-text\">a</code>와 집합 <code class=\"language-text\">b</code>의 서로소 합집합의 원소는 모두 <code class=\"language-text\">a</code>의 원소이거나 <code class=\"language-text\">b</code>의 원소이다. 만약 두 집합이 겹치는 경우, 서로소 합집합에는 겹치는 부분의 두 복사본이 포함된다. 즉, 서로소 합집합의 원소는 원본을 나타내는 식별자로 일종의 태그가 지정된 것이라고 생각해볼 수 있다.</p>\n<p>프로그래머에게는 타입 관점에서 합을 이해하는 것이 더 쉽게 다가올 수 있다. 이는 두 타입의 태그가 지정된 유니온(Tagged Union)이다. C++은 유니온을 지원하지만, 이들은 태그가 없다. 이는 프로그램에서 어떻게든 어떤 유니온 멤버가 유효한지, 어떻게 추적할지 관리해야 한다는 것을 의미한다.</p>\n<p>태그가 지정된 유니온을 생성하려면 먼저 Enum(tag)을 정의하고 유니온과 결합해야한다. 예를 들어 <code class=\"language-text\">int</code>와 <code class=\"language-text\">char const *</code>의 태그가 지정된 유니온은 아래와 같이 구현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Contact</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">enum</span> <span class=\"token punctuation\">{</span> isPhone<span class=\"token punctuation\">,</span> isEmail <span class=\"token punctuation\">}</span> tag<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> phoneNum<span class=\"token punctuation\">;</span> <span class=\"token keyword\">char</span> <span class=\"token keyword\">const</span> <span class=\"token operator\">*</span> emailAddr<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이때 두 삽입 사상은 생성자 또는 함수로 구현할 수 있다. 예를 들어 첫 번째 삽입 사상을 함수 <code class=\"language-text\">PhoneNum</code>으로 구현해본다면 아래와 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Contact <span class=\"token function\">PhoneNum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tContact c<span class=\"token punctuation\">;</span>\n\t\tc<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">=</span> isPhone<span class=\"token punctuation\">;</span>\n\t\tc<span class=\"token punctuation\">.</span>phoneNum <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 정수를 <code class=\"language-text\">Contact</code>에 삽입하는 역할을 한다.</p>\n<p>이렇게 태그가 지정된 유니온은 때로 변형(Variant)라고도 불리며, <code class=\"language-text\">boost:variant</code> 클래스 템플릿에서 이러한 변형에 대한 기능을 제공받을 수 있다.</p>\n<p>Haskell에서는 수직바(<code class=\"language-text\">|</code>)로 데이터 생성자를 구분하여 어떤 데이터 형식이든 태그가 지정된 유니온으로 결합할 수 있다. 방금 C++로 만들어본 <code class=\"language-text\">Contact</code>는 Haskell에서 아래와 같은 선언으로 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Contact</span> <span class=\"token operator\">=</span> <span class=\"token constant\">PhoneNum</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">|</span> <span class=\"token constant\">EmailAddr</span> <span class=\"token constant\">String</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">PhoneNum</code> 과 <code class=\"language-text\">EmailAddr</code>은 생성자(삽입 사상)와 패턴 매칭에 대한 태그로 사용된다. 아직 잘 이해가 되지 않겠지만 이는 나중에 더 알아보도록 하겠다.</p>\n<p>예를 들어 전화번호를 사용하여 연락처를 생성하는 방법은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">helpdesk</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Contact</span><span class=\"token punctuation\">;</span>\n<span class=\"token hvariable\">helpdesk</span> <span class=\"token operator\">=</span> <span class=\"token constant\">PhoneNum</span> <span class=\"token number\">2222222</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Haskell에 기본적으로 내장된 곱의 표준 구현과 다르게 합의 표준 구현은 <code class=\"language-text\">Either</code>라는 데이터 타입이며, 이는 표준 Prelude에 정의되어있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Right</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Either</code>는 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 두 타입을 나타내는 매개변수와 두 생성자를 가진 데이터 타입이다. <code class=\"language-text\">Left</code>는 <code class=\"language-text\">a</code> 타입의 값을 나타내며 <code class=\"language-text\">Right</code>는 <code class=\"language-text\">b</code> 타입의 값을 나타낸다.</p>\n<p>우리가 곱에 대해서 <code class=\"language-text\">factorizer</code>라는 함수로 정의한 것과 마찬가지로, 합에 대해서도 함수를 정의해볼 수 있다. 후보 대상인 <code class=\"language-text\">c</code>와 두 후보 삽입 사상 <code class=\"language-text\">i</code>, <code class=\"language-text\">j</code>가 주어진다면, <code class=\"language-text\">Either</code>를 사용하여 함수를 만들어볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorizer</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span>\n<span class=\"token hvariable\">factorizer</span> <span class=\"token hvariable\">i</span> <span class=\"token hvariable\">j</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Left</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">i</span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">factorizer</span> <span class=\"token hvariable\">i</span> <span class=\"token hvariable\">j</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Right</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">j</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h2 id=\"57-비대칭성asymmetry\" style=\"position:relative;\">5.7 비대칭성(Asymmetry)<a href=\"#57-%EB%B9%84%EB%8C%80%EC%B9%AD%EC%84%B1asymmetry\" aria-label=\"57 비대칭성asymmetry permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇게 쌍대성을 가진 두 개의 집합을 살펴보았다. 종결 대상의 정의는 초기 대상의 정의에서 화살표의 방향을 반대로 하여 얻을 수 있으며, 이와 유사하게 합의 정의는 곱의 정의를 뒤집음으로써 만들어볼 수 있다.</p>\n<p>하지만 집합의 카테고리에서 초기 대상은 최종 대상과는 매우 다르며, 합 또한 곱과 다르다. 추후 우리는 곱셈처럼 작동하는 곱집합의 정의에서 종결 대상이 1의 역할을 하고, 덧셈처럼 작동하는 합집합의 정의에서는 초기 대상이 0의 역할을 하는 것을 살펴볼 것이다.</p>\n<p>특히 유한 집합의 경우 곱집합의 크기는 개별 집합의 크기를 곱한 것과 같으며, 합집합의 크기는 개별 집합의 크기를 더한 것과 같다. 이는 집합의 카테고리가 화살표의 반전에 대해서 대칭적으로 작동하지 않는다는 사실을 보여준다.</p>\n<p>여기서 주의해야 할 점은 공집합이 어떤 집합에 대해 고유한 사상(<code class=\"language-text\">absured</code> 함수)을 가질 수는 있지만, 이 사상에 대한 역사상은 존재하지 않는다는 것이다. 단일원소집합은 어떤 집합에서 자신에게로 향하는 고유한 사상을 가지고 있지만, 자신에게서 공집합을 제외한 다른 모든 집합으로 향하는 사상 또한 가지고 있다. 종결 대상에서부터 다른 곳으로 향하는 사상은 다른 집합의 원소를 선택하는 매우 중요한 역할을 하지만, 공집합에는 원소가 없기 때문에 선택할 수 있는 것이 없다.</p>\n<p>바로 이러한 단일원소집합과 곱집합의 관계가 합집합과의 차별점이다. Unit 타입 <code class=\"language-text\">()</code> 으로 표현되는 단일원소집합을 곱 패턴의 후보로 생각해보자. 그럼 이제 단일원소집합은 자신으로부터 구성 요소 집합으로 향하는 투영 사상 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>를 가지게 된다.</p>\n<p>결국 이 두 사상들이 표현하고 있는 행위는 곱집합의 원소를 구성하는 구성요소 중 하나를 선택하는 것이다. 또한 곱집합은 보편적 구성을 따르기 때문에 우리가 정한 후보인 단일원소집합으로부터 곱집합으로 향하는 유일한 사상 <code class=\"language-text\">m</code>도 존재할 것이다. 이 사상은 곱집합에서 특정 원소, 즉 구체적인 하나의 쌍을 선택할 것이며, 이 사상으로 두 투영 사상을 인수분해할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fst</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m</span>\n<span class=\"token hvariable\">q</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">snd</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이를 단일원소집합의 유일한 원소인 값 <code class=\"language-text\">()</code>에 대입해보면 위의 식은 아래와 같이 변형될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fst</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">m</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">q</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">snd</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">m</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">m ()</code>은 사상 <code class=\"language-text\">m</code>에 의해 선택된 곱집합의 원소이므로 이 식들은 <code class=\"language-text\">p</code>가 첫번째 집합에서 선택한 요소, 즉 <code class=\"language-text\">p ()</code>가 <code class=\"language-text\">m</code>에 의해 선택된 쌍의 첫번째 구성요소와 동일하다는 것을 나타낸다. 마찬가지로 <code class=\"language-text\">q ()</code>는 두번째 구성요소와 동일할 것이다. 이는 곱집합의 원소가 각 구성 집합의 원소로 이루어진 쌍이라는 개념과 완전히 일치한다.</p>\n<p>하지만 합에 대해서는 이렇게 간단한 해석이 불가능하다. 물론 단일원소집합을 합의 후보로 삼아 원소를 추출하려고 해볼 수는 있겠지만, 여기에는 단일원소집합에서 다른 구성요소집합으로 향하는 두 투영 사상이 아니라 다른 구성요소집합에서 단일원소집합으로 향하는 두 삽입 사상이 필요하다. 하지만 이 삽입 사상들은 원본의 정보에 대해 아무것도 알려주지 않을 것이다. 이는 앞서 살펴본 삽입 사상의 <code class=\"language-text\">factorizer</code>의 구현을 보면 이 함수가 입력된 매개변수 중 하나를 무시하고 있다는 사실에서 알 수 있다. 마찬가지로 합집합에서 단일원소집합으로 향하는 유일한 사상도 아무런 정보를 주지 못한다.</p>\n<p>결국 집합의 카테고리는 초기 대상의 방향에서 바라볼 때와 종결 대상의 방향에서 바라볼 때 다르게 보일 수 있다는 것이다. 이것은 일반적으로 수학에서의 집합이 가지는 본질적인 특성이라기보다는 모든 집합이 대상으로 정의되는 카테고리 이론에서 사상으로 사용되는 함수의 특성이다.</p>\n<p>함수는 일반적으로 비대칭적이다. 함수는 정의역 집합의 모든 원소에 대해서 정의되어야 한다만, 공역 집합의 모든 원소에 대해 대응될 필요는 없다. 방금 우리는 이러한 함수의 특성 중 극단적인 몇 가지를 살펴본 것이다. 결국 단일원소집합을 정의역으로 가지는 함수들은 공역 집합에서 딱 하나의 원소만 선택하는 함수들이다.</p>\n<p>우리는 종종 정의역 집합의 크기가 공역 집합의 크기보다 훨씬 작을 때, 이러한 함수들이 정의역 집합을 공역 집합에 포함시키는 행위라고 생각한다. 예를 들어 우리는 단일원소집합을 정의역으로 가진 함수가 정의역 집합이 가진 단 하나의 원소를 공역 집합에 포함시키는 것이라고 생각할 수 있다. 필자는 이들을 포함 함수(Embedding Functions)라고 부르지만, 수학자들은 이와 반대 시각을 가진 개념을 통해 이름을 부여했다. 이렇게 정의역을 공역에 꽉 채워넣을 수 있는 함수들을 “전사 함수(Surjective Functions)” 또는 “위로의 함수(Onto Functions)”라고 한다.</p>\n<p>다른 비대칭성의 원인은 함수가 정의역 집합 있는 여러 원소들을 공역 집합에 있는 하나의 원소로도 매핑할 수 있다는 점이다. 즉 함수는 이러한 원소들을 축소할 수 있다고 보는 것이다. 이에 대한 극단적인 예시는 정의역 집합에 있는 모든 원소를 공역 집합의 단 하나의 원소로 매핑하는 함수들이다. 이전에 보았던 <code class=\"language-text\">unit :: a -> ()</code>의 정의를 가진 다형적 유닛 함수(Polymorphic Unit Function)이 바로 이 역할을 한다. 이러한 축소 행위는 합성을 통해 더 강화될 수 있다. 두 개의 축소 함수를 합성하는 것은 각각의 개별 함수보다 더 많은 축소 행위를 만들어낼 수 있다. 수학자들은 이렇게 축소되지않는 함수에 대해서 특별한 이름을 붙혔는데, 이를 “단사 함수(Injective Functions)” 또는 “일대일 함수(One-to-one Functions)”라고 부른다.</p>\n<p>물론 이렇게 포함도 축소도 아닌 일부 함수들도 존재한다. 이들은 “전단사 함수(Bijection Functions)”라고 불린다. 이 함수들은 전사, 단사 함수와는 다르게 대칭적이며, 이에 따라 역함수도 존재할 수 있다. 집합의 카테고리에서는 동형사상(Isomorphism)이 전단사 함수와 동일한 개념이다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240227-category-theory-for-programmers-5-products-and-coproducts","path":"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 5. 곱과 합","subTitle":null,"date":"Feb 27, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"610888fd-70a9-5b54-a6f0-bbcaf8d1d8c9","tableOfContents":"<ul>\n<li><a href=\"#41-writer-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\">4.1 Writer 카테고리</a></li>\n<li><a href=\"#42-%ED%95%98%EC%8A%A4%EC%BC%88%EC%9D%98-writer\">4.2 하스켈의 Writer</a></li>\n<li><a href=\"#43-%ED%81%AC%EB%9D%BC%EC%9D%B4%EC%8A%AC%EB%A6%AC-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACkleisli-categories\">4.3 크라이슬리 카테고리(Kleisli Categories)</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"우리는 지금까지 타입과 순수 함수들을 카테고리로 모델링하는 방법을 살펴봤다. 앞서 필자는 카테고리 이론에서 사이드 이펙트나 순수하지 않은 함수를 모델링하는 방법이 있다고 이야기했었는데, 어떠한 실행과정을 추적하거나 로깅하는 함수를 예시로 들어 이 방법에 대해 한번 살펴보도록 하자. 우리가 명령형 언어를 사용하여 무언가를 구현할 때는 일반적으로 전역 상태를 선언하고 변경해가며 구현하게 된다. 이 함수는 자신의 외부 세계에 선언되어있는 를 변경한다는 사이드이펙트를 가지고 있기 때문에 순수함수가 아니다. 모던 프로그래밍의 세계에서는 가…","html":"<p>우리는 지금까지 타입과 순수 함수들을 카테고리로 모델링하는 방법을 살펴봤다. 앞서 필자는 카테고리 이론에서 사이드 이펙트나 순수하지 않은 함수를 모델링하는 방법이 있다고 이야기했었는데, 어떠한 실행과정을 추적하거나 로깅하는 함수를 예시로 들어 이 방법에 대해 한번 살펴보도록 하자.</p>\n<p>우리가 명령형 언어를 사용하여 무언가를 구현할 때는 일반적으로 전역 상태를 선언하고 변경해가며 구현하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">string logger<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     logger <span class=\"token operator\">+=</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span>b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 자신의 외부 세계에 선언되어있는 <code class=\"language-text\">logger</code>를 변경한다는 사이드이펙트를 가지고 있기 때문에 순수함수가 아니다.</p>\n<p>모던 프로그래밍의 세계에서는 가급적이면 변경 가능한 전역 상태를 사용하지 않기 위해 노력하는데, 다른 것은 둘째치고 동시성의 복잡성때문에라도 이러한 행위는 최대한 피해야 한다. 아마 독자 여러분도 이런 코드를 라이브러리에 넣고 싶지는 않을 것이라 생각한다.</p>\n<p>다행히도 이 함수는 순수함수로 변경될 수 있는 가능성이 있다. 그저 함수에게 <code class=\"language-text\">logger</code>를 명시적으로 전달하기만 하면 된다. 즉, 함수에 하나의 문자열 인수를 추가함으로써 함수의 출력과 로그가 포함된 문자열을 짝지어볼 수 있는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">,</span> string logger<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>b<span class=\"token punctuation\">,</span> logger <span class=\"token operator\">+</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이제 이 함수는 사이드 이펙트를 발생시키지 않기 때문에 순수하다. 동일한 인수가 주어졌을 때 항상 동일한 값의 쌍을 출력하며, 이러한 특성으로 인해 필요한 경우에는 메모이제이션 할 수도 있다. 그러나 메모이제이션을 할 경우 이전 값을 토대로 다음 값을 생성한다는 누산적인 로그의 특성으로 인해, 결국은 이 함수가 호출되기까지의 모든 이력을 메모이제이션해야 할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"It was the best of times. \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 또는</span>\n<span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"It was the worst of times. \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p><strong>💡 역주</strong></p>\n<p>여기서 작가는 누산적인 연산을 한다는 로그의 특성으로 인해 메모이제이션을 하나마나라는 이야기를 하고 있다. negate 함수는 “이전 로그”를 받아 “Not so! “라는 문자열을 이어붙히는 방식으로 새로운 로그 문자열을 생성하여 반환하는데, 이는 결국 negate 함수가 반환하는 로그 문자열이 negate 함수가 호출되기 이전의 로그 상태의 영향을 받는다는 의미이다.</p>\n<p>아무리 negate 함수가 참조 투명성을 보장하는 순수함수라도, 결국 함수의 호출 맥락이라는 것은 상황에 따라 달라질 수 있기 때문에 negate 함수가 반환하는 로그 문자열 또한 매번 달라질 가능성이 크다. 그로 인해 이를 메모이제이션하는 것은 큰 의미가 없어지는 것이다.</p>\n</blockquote>\n<p>이러한 설계는 라이브러리 함수로써 좋은 설계라고 볼 수도 없다. 함수 호출자는 이 함수가 반환하는 로그 문자열을 무시할 수 있으니 출력 형태에 대해서는 큰 문제가 없겠지만, 입력에 대해서는 다르다. 로그가 필요없는 상황에도 매번 호출자가 특정한 로그 문자열을 함수에게 직접 전달해줘야 하기 때문이다.</p>\n<p>그렇다면 관심사를 분리하는 방법을 통해 이 함수를 조금 더 편하게 호출할 수 있는 방법은 없을까? 결국 위 예시에서 negate 함수의 주 목적은 인수로 받은 하나의 Boolean 값을 다른 Boolean 값으로 변환하는 것이며, 로깅은 그저 보조적인 역할만 수행한다. 물론 이 로그에 기록되는 메세지가 함수의 목적에 특화되어 있기는 하지만, 결국 어떠한 메세지를 하나의 로그로 통합하는 작업 자체는 negate 함수의 주 목적과는 별개의 관심사이다. 즉, 우리는 로깅에 대한 관심사를 분리해야 한다.</p>\n<p>그렇다면 이런 방법으로 타협을 볼 수 있을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>b<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>결국 이 아이디어는 함수가 호출될 때마다 로그를 계속 쌓는다는 컨셉에서 출발한다. 이제 이 아이디어를 어떻게 구현할 수 있을지 알아보기 위해 약간 더 현실적인 예제를 보도록하자.</p>\n<p>여기 어떤 문자열을 받아 소문자를 대문자로 변경하는 함수가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">string <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    string result<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>toupper<span class=\"token punctuation\">;</span> <span class=\"token comment\">// toupper is overloaded</span>\n    <span class=\"token function\">transform</span><span class=\"token punctuation\">(</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">back_inserter</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 두번째 함수는 인수로 받은 문자열을 공백을 기준으로 나누어 벡터를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">toWords</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">words</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">toWords</code> 함수의 실제 동작은 <code class=\"language-text\">words</code> 함수에서 수행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">words</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> result<span class=\"token punctuation\">{</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">=</span> <span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">!=</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isspace</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+=</span> <span class=\"token operator\">*</span>i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>우리는 <code class=\"language-text\">toUpper</code> 함수와 <code class=\"language-text\">toWords</code> 함수를 수정하여 문자열 메세지를 이 함수들의 반환값과 함께 묶어 표현하고 싶다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 300px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/01933c7eafd8f72afd7f176b92dbd607/f93b5/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 106.87500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAVABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAMFAQIE/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAbblngSyC41CQH//xAAbEAACAgMBAAAAAAAAAAAAAAABAgMRABASIv/aAAgBAQABBQKVqwSt0DYkj9MrYBQYWOBr/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAHBAAAgEFAQAAAAAAAAAAAAAAAREAAhASIWEy/9oACAEBAAY/Ava5A2LCqlDe3AMwYooOW//EAB4QAAICAgIDAAAAAAAAAAAAAAERACExQRBhcYGx/9oACAEBAAE/IVXg03CwWsFK4JwIPiKNuwIZaidfYIYagXH6iaV04//aAAwDAQACAAMAAAAQtA88/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHhABAQACAgIDAAAAAAAAAAAAAREAMSFBYXEQgaH/2gAIAQEAAT8QhUlUC8usmlWJB+3XnBhjVVL3iSBF0F6d/nnOM1+Lt9nzkRIJqYjQDusGIVogL7+P/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/01933c7eafd8f72afd7f176b92dbd607/f93b5/1.jpg\" srcset=\"/static/01933c7eafd8f72afd7f176b92dbd607/0913d/1.jpg 160w,\n/static/01933c7eafd8f72afd7f176b92dbd607/f93b5/1.jpg 300w\" sizes=\"(max-width: 300px) 100vw, 300px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>우리는 이제 이 함수들의 반환값을 아름답게 꾸며볼 것이다. 가장 먼저 임의의 타입 A인 값이 첫 번째 요소이고 문자열이 두 번째 요소인 쌍을 캡슐화하는 템플릿 <code class=\"language-text\">Writer</code>를 정의함으로써 이 문제를 일반화하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">using</span> Writer <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>A<span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이제 <code class=\"language-text\">Writer</code>를 사용하여 각 함수들을 꾸며줄 차례이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    string result<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>toupper<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">transform</span><span class=\"token punctuation\">(</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">back_inserter</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token string\">\"toUpper \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nWriter<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">toWords</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token function\">words</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"toWords \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 이 두 함수를 조합하여 문자열을 대문자로 변환하고 공백을 기준으로 나눠주는 함수를 꾸며보자. 바로 이 과정에서 이 작업에 대한 로그를 생성할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">auto</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">auto</span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">toWords</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 처음의 목표를 달성했다. 각각의 로그를 합치는 것은 이제 더 이상 개별 함수들의 관심사가 아니다. 각 함수들은 자체적으로 자신과 관련된 메세지를 생성할 뿐이고, 이 개별 함수들의 외부에서 이러한 메세지들을 합쳐 더 큰 로그를 만들어낸다.</p>\n<p>이제 이러한 스타일로 작성된 거대한 프로그램을 한번 상상해보자. 아마 이러한 패턴을 계속해서 반복하게되면 오류가 발생하기 쉬운 악몽과도 같은 코드가 될 것이다. 하지만 우리는 프로그래머이기 때문에 이런 반복적인 코드를 추상화를 사용하여 우아하게 해결하는 일에 이미 익숙하다. 그러나 이것은 우리가 지금까지 알던 추상화와는 약간 다르다. 바로 함수의 합성이라는 개념 자체를 추상화해야하기 때문이다.</p>\n<p>결국 합성이라는 개념은 카테고리 이론의 본질이니, 코드를 더 작성하기 전에 일단 카테고리 이론의 관점에서 이 문제를 한번 분석해보자.</p>\n<h2 id=\"41-writer-카테고리\" style=\"position:relative;\">4.1 Writer 카테고리<a href=\"#41-writer-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\" aria-label=\"41 writer 카테고리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수들의 반환 타입을 꾸며 추가 기능을 끼워넣을 수 있다는 아이디어는 우리에게 큰 가치를 가져다준다. 이제 이에 대한 더 많은 예제를 한번 보도록 하자. 대상을 타입으로 가지고 사상은 우리가 꾸며주었던 함수로 가지는 일반적인 카테고리에서부터 시작해보는 것이 좋겠다.</p>\n<p>예를 들어 <code class=\"language-text\">int</code> 타입에서 <code class=\"language-text\">bool</code> 타입으로 향하는 <code class=\"language-text\">isEven</code> 함수를 꾸며본다고 생각해보자. 가장 먼저 카테고리의 사상을 우리가 앞서 꾸며보았던 함수로 다시 표현해볼 것이다. 여기서 중요한 점은 이 함수가 비록 <code class=\"language-text\">pair&lt;bool, string></code> 타입을 반환한다고 해도 카테고리 내에서는 여전히 <code class=\"language-text\">int</code> 대상과 <code class=\"language-text\">bool</code> 대상 사이의 화살표로 간주된다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">isEven</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"isEven \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>카테고리 법칙에 의하면 우리는 이 사상을 다른 사상과 합성하여 대상 <code class=\"language-text\">bool</code>에서 다른 대상으로 향하는 사상을 만들 수 있어야 한다. 여기서는 앞서 정의했던 <code class=\"language-text\">negate</code> 함수와 합성하는 상황을 한번 보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>b<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>물론 <code class=\"language-text\">isEven</code> 함수와 <code class=\"language-text\">negate</code> 함수는 서로의 입력과 출력 타입이 일치하지 않기 때문에 이 두 개의 사상을 일반적인 함수와 같은 방식으로 합성할 수는 없다. 이 두 사상의 합성은 아래와 같이 표현해줘야 할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">isOdd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">isEven</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tpair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 카테고리에서 두 개의 사상을 합성하는 과정은 다음과 같다.</p>\n<hr>\n<ol>\n<li>첫 번째 사상에 해당하는 함수를 실행시킨다. 위 예시에서는 <code class=\"language-text\">isEven(n)</code>에 해당한다.</li>\n<li>첫 번째 함수가 반환한 값의 쌍에서 첫 번째 요소를 추출하고, 이 요소를 두 번째 사상에 해당하는 함수에 전달한다. 위 예시에서는 <code class=\"language-text\">negate(p1.first)</code>에 해당한다.</li>\n<li>첫 번째 사상과 두 번째 사상이 반환한 로그 문자열, 즉 각 함수가 반환한 쌍에서 두 번째 요소를 추출하여 직접 연결해준다.</li>\n<li>위 과정을 통해 얻어낸 값과 연결한 로그 문자열을 사용하여 새로운 쌍을 만들어 반환한다. 위 예시에서는 <code class=\"language-text\">make_pair(p2.first, p1.second + p2.second)</code>에 해당한다.</li>\n</ol>\n<hr>\n<p>만약 이 과정을 C++의 고차함수로 추상화하려면 이 카테고리가 가진 세 개의 대상을 타입 변수로 표현한 템플릿을 사용해야한다. 그리고 결과값과 로그 문자열 쌍을 반환하는 두 개의 함수를 가져와 합성하고, 마지막으로 새로운 쌍을 만드는 함수를 반환하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token operator\">></span>\n\nfunction<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">Writer</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>C<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>function<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">Writer</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> m1<span class=\"token punctuation\">,</span>\n                               function<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">Writer</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>C<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> m2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>m1<span class=\"token punctuation\">,</span> m2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>A x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">m1</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">m2</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기까지 왔으면 이제 거의 끝났다. 이제 이 템플릿을 사용하여 원래 우리가 합성하려고 했던 <code class=\"language-text\">toUpper</code> 함수와 <code class=\"language-text\">toWords</code> 함수의 합성을 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> string<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span></span></span><span class=\"token punctuation\">(</span>toUpper<span class=\"token punctuation\">,</span> toWords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>하지만 아직도 <code class=\"language-text\">compose</code> 템플릿에 타입을 전달하는 과정이 번거로워 보인다. 이는 C++14 호환 컴파일러에서 지원하는 반환 타입 추론 기능을 지원하는 람다 함수를 사용함으로써 해결해볼 수 있다. (아래 코드의 작성자는 Eric Niebler이다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> <span class=\"token keyword\">const</span> compose <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> m1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">auto</span> m2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>m1<span class=\"token punctuation\">,</span> m2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">m1</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">m2</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 타입 추론을 지원하도록 정의된 <code class=\"language-text\">compose</code> 함수를 사용하여 함수를 더 간단하게 합성해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>toUpper<span class=\"token punctuation\">,</span> toWords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>아직 끝난 것이 아니다. 우리는 지금까지 카테고리 내 사상의 합성만 정의한 것이고 아직 항등 사상에 대한 것은 정의하지 않았다. 이 항등 사상은 일반적인 항등 함수와는 약간 다르다. 이들은 타입 A로부터 다시 타입 A로 돌아가는 사상이기 때문에 아래와 같은 타입 선언을 가질 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token function\">identity</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 항등 사상은 합성에 대한 항등원처럼 작동해야한다. 우리가 정의해놓은 로직의 합성 과정에 의하면 이 항등 사상은 자신이 인수로 받은 값을 변경하지도 않고, 로그에는 빈 문자열만 기록하는 방식으로 정의해야 할 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span> Writer<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token function\">identity</span><span class=\"token punctuation\">(</span>A x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 정의한 카테고리는 카테고리가 지켜야하는 모든 조건들을 만족하고 있다. 특히 이 카테고리의 합성은 명확하게 결합법칙을 만족하고 있다. 각 함수들이 반환하는 값의 쌍 중 첫 번째 요소만 보면 일반적인 함수의 합성으로 바라볼 수 있으며, 이 연산은 결합법칙을 만족한다. 또한 두 번째 요소인 로그 문자열에 대한 연산은 그저 문자열의 연결일 뿐이니 이 또한 결합법칙을 만족한다.</p>\n<p>여기서 영리한 독자라면 우리가 이 구조를 문자열 모노이드 뿐 아니라 어떤 모노이드에던 일반화해서 적용할 수 있다는 사실을 알아차렸을 것이다. <code class=\"language-text\">compose</code> 함수에서 <code class=\"language-text\">+</code> 연산자 대신 <code class=\"language-text\">mappend</code>를, 그리고 <code class=\"language-text\">identity</code> 함수에서는 <code class=\"language-text\">\"\"</code>라는 값 대신에 <code class=\"language-text\">mempty</code>를 사용하기만 하면 된다.</p>\n<p>반드시 문자열을 다룰 때에만 한해서 로깅을 한다는 법은 없다. 좋은 라이브러리 작성자는 라이브러리가 동작하는 데 필요한 최소한의 제약 조건을 식별할 수 있어야 한다. 우리가 만든 로깅 라이브러리의 유일한 요구 사항은 그저 로그라는 개념이 모노이드적인 특성을 가져야 한다는 것이다.</p>\n<h2 id=\"42-하스켈의-writer\" style=\"position:relative;\">4.2 하스켈의 Writer<a href=\"#42-%ED%95%98%EC%8A%A4%EC%BC%88%EC%9D%98-writer\" aria-label=\"42 하스켈의 writer permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 구현했던 것들을 Haskell에서는 조금 더 간결하게 작성할 수 있고 컴파일러로부터 더 많은 도움을 받을 수 있기도 하다.</p>\n<p>일단 <code class=\"language-text\">Writer</code> 타입을 정의하는 것부터 시작해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서는 단순히 타입 별칭(Type Alias)을 정의하고 있으며, 이것은 C++의 <code class=\"language-text\">typedef</code> 또는 <code class=\"language-text\">using</code>과 동일한 기능이다. <code class=\"language-text\">Writer</code> 타입은 타입 변수 <code class=\"language-text\">a</code>를 받아 <code class=\"language-text\">a</code> 타입과 <code class=\"language-text\">String</code> 타입의 쌍을 반환한다. 이 문법은 쌍을 의미하는 괄호 안에 두 개의 요소가 존재하고, 이 요소들이 쉼표로 부분되는 최소한의 형태로만 이루어져있다.</p>\n<p>이 카테고리에서의 사상은 임의의 타입에서 다른 타입을 매개변수로 가지는 <code class=\"language-text\">Writer</code> 타입으로 나아가는 함수라고 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 “fish”라고도 불리는 재미있는 중위 연산자(Infix Operator)를 사용하여 합성을 정의할 차례이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">>=></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 연산자는 두 개의 인수를 받아 합성하는 함수이며, 이 인수들은 합성의 대상이 되는 함수들이고 최종적으로는 합성된 함수를 반환한다. 첫 번째 인수는 <code class=\"language-text\">(a -> Writer b)</code> 타입, 두 번째 인수는 <code class=\"language-text\">(b -> Writer c)</code> 타입이며, 최종 반환 결과는 <code class=\"language-text\">(a -> Writer c)</code> 타입을 가진다.</p>\n<p>아래 예시는 <code class=\"language-text\">m1</code> 이라는 인수와 <code class=\"language-text\">m2</code>라는 인수를 받았을 때 이 중위 연산자가 어떻게 작동하는지를 보여준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m1</span> <span class=\"token operator\">>=></span> <span class=\"token hvariable\">m2</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m1</span> <span class=\"token hvariable\">x</span>\n        <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m2</span> <span class=\"token hvariable\">y</span>\n    <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>연산의 결과는 <code class=\"language-text\">x</code>라는 하나의 인수를 받는 람다 함수이다. 람다 함수는 역슬래시(<code class=\"language-text\">\\</code>)로 표현할 수 있다. 기억하기 어렵다면 다리를 하나 잃은 그리스 문자 λ(Lambda)라고 생각하자.</p>\n<p><code class=\"language-text\">let</code> 표현을 사용하면 함수 내의 지역변수를 선언할 수 있다. 여기서 <code class=\"language-text\">m1</code> 함수의 호출 결과는 <code class=\"language-text\">(y, s1)</code> 변수에 담기고, 이 변수에서 가져온 <code class=\"language-text\">y</code> 인자를 사용하여 호출된 <code class=\"language-text\">m2</code> 함수의 호출 결과는 <code class=\"language-text\">(z, s2)</code> 변수에 담긴다.</p>\n<p>이처럼 Haskell에서는 C++에서 <code class=\"language-text\">p1.first</code> 같이 접근자를 사용했던 것과는 다르게, <code class=\"language-text\">(y, s1) = m1 x</code> 처럼 패턴 매칭하여 쌍을 분해하는 방법을 주로 사용한다. 이 외에도 두 언어의 기능 간에는 이렇게 직관적으로 대응해볼 수 있는 관계가 꽤 존재한다.</p>\n<p>위 함수의 <code class=\"language-text\">let</code> 표현식에서 선언된 변수들은 함수 동작의 구현을 의미하는 <code class=\"language-text\">in</code>절에서 접근할 수 있다. 즉 <code class=\"language-text\">in</code>절 내부에서 접근한 변수들은 <code class=\"language-text\">let</code> 표현식 내부에서 선언된 값들이며, 최종적으로 첫 번째 요소는 <code class=\"language-text\">z</code> 이고, 두 번째 요소는 두 문자열의 연결인 <code class=\"language-text\">s1 ++ s2</code>로 구성된 쌍을 만들어내고 이쓴 것이다.</p>\n<p>이런 합성 외에도 우리의 카테고리 내부에 존재해야하는 항등 사상도 정의를 해야하겠지만 이건 조금 이따 보도록 하겠다. 일단 항등사상은 <code class=\"language-text\">return</code> 이라고 네이밍하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">return</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">return</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>자 이제 원래 합성하려고 했던 대상인 <code class=\"language-text\">upCase</code> 와 <code class=\"language-text\">toWords</code> 함수의 Haskell 버전을 추가하면 거의 다 완성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">upCase</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">upCase</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">map</span> <span class=\"token builtin\">toUpper</span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"upCase \"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token hvariable\">toWords</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">toWords</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">words</span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"toWords \"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">map</code> 함수는 C++의 <code class=\"language-text\">transform</code>에 해당한다. 이 함수는 문자열 <code class=\"language-text\">s</code> 에 <code class=\"language-text\">toUpper</code> 함수를 적용한다. 그리고 <code class=\"language-text\">words</code> 함수는 표준 Prelude 라이브러리에 이미 정의되어있다.</p>\n<p>최종적으로 이 두 함수의 합성은 앞서 정의했던 fish 연산자를 사용하여 간단하게 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">process</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">process</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">upCase</span> <span class=\"token operator\">>=></span> <span class=\"token hvariable\">toWords</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h2 id=\"43-크라이슬리-카테고리kleisli-categories\" style=\"position:relative;\">4.3 크라이슬리 카테고리(Kleisli Categories)<a href=\"#43-%ED%81%AC%EB%9D%BC%EC%9D%B4%EC%8A%AC%EB%A6%AC-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACkleisli-categories\" aria-label=\"43 크라이슬리 카테고리kleisli categories permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이러한 카테고리는 필자가 직접 고안해낸 것이 아니다. 이는 모나드라는 개념에서 기반한 크라이슬리 카테고리(Kleisli Category)의 한 예시이다. 아직 우리가 모나드에 대해 자세히 논의하기에는 조금 이르긴 하지만, 모나드가 어떤 역할을 하는지에 대해서 간략하게 살펴봤다고 생각하면 된다.</p>\n<p>크라이슬리 카테고리는 프로그래밍 언어의 타입들을 대상으로 가진다. 그리고 타입 A에서 타입 B로 나아가는 사상은 타입 A에서 특정 “장식(Embellishment)”를 적용하여 B로 나아가는 함수라고 볼 수 있다.</p>\n<p>모든 크라이슬리 카테고리는 이러한 사상들을 고유한 방법으로 합성하는 방법을 정의하고, 이러한 합성에 대한 항등 사상 또한 정의할 수 있다. (추후 이 애매한 “장식”이라는 용어가 카테고리의 엔도펑터(Endofunctor)라는 개념을 의미한다는 사실을 설명하겠다.)</p>\n<p>이 챕터에서 함수들의 실행 과정을 추적하고 로깅하기 위해 만들었던 Writer 모나드는 순수함수들의 연산 결과에 이펙트를 포함하기 위한 일반적인 매커니즘의 예시이기도 하다.</p>\n<p>우리는 이전 챕터에서 프로그래밍 언어에서 bottom을 제외한 일반 타입들과 함수들을 집합으로 구성된 카테고리로 모델링하는 방법에 대해서 알아봤다. 그리고 이번에는 이 모델을 기반으로 함수들의 합성이라는 행위가 단지 한 함수의 출력을 다른 함수의 입력으로 전달하는 것뿐 아니라 조금 더 다양한 기능을 포함할 수 있는 카테고리로 발전시켜보았다.</p>\n<p>이제 우리는 함수의 합성을 가지고 놀 때 조금 더 자유로운 아이디어를 표현해볼 수 있게 되었다. 바로 우리가 앞서 알아본 개념들이 지금까지 명령형 언어들이 사이드이펙트를 사용하여 구현해왔던 프로그램에도 표시적 의미론(Denotational Semantics)을 적용할 수 있는 자유를 선물해준 것이다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240220-category-theory-for-programmers-4-kleisli-category","path":"/2024/02/20/category-theory-for-programmers-4-kleisli-category/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 4. 크라이슬리 카테고리","subTitle":null,"date":"Feb 20, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}],"pageInfo":{"currentPage":1,"pageCount":8}}},"pageContext":{"limit":15,"skip":0,"lang":"ko","totalCount":107}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}