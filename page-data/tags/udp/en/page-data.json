{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/udp/en/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"aa2d548e-4eb6-5e1b-804f-7cb6a2a8c809","tableOfContents":"<ul>\n<li>\n<p><a href=\"#a-brief-introduction-to-http3\">A Brief Introduction to HTTP/3</a></p>\n</li>\n<li>\n<p><a href=\"#why-is-tcp-considered-slow\">Why Is TCP Considered Slow?</a></p>\n<ul>\n<li><a href=\"#3-way-handshake\">3-Way Handshake</a></li>\n<li><a href=\"#holb-head-of-line-blocking\">HOLB (Head-of-Line Blocking)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#why-http3-uses-udp\">Why HTTP/3 Uses UDP</a></p>\n<ul>\n<li><a href=\"#udp-is-a-blank-canvas\">UDP Is a Blank Canvas</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#how-http3-improves-over-previous-protocols-by-using-udp\">How HTTP/3 Improves Over Previous Protocols by Using UDP</a></p>\n<ul>\n<li><a href=\"#reduced-latency-in-connection-setup\">Reduced Latency in Connection Setup</a></li>\n<li><a href=\"#faster-packet-loss-detection\">Faster Packet Loss Detection</a></li>\n<li><a href=\"#multiplexing-support\">Multiplexing Support</a></li>\n<li><a href=\"#connections-survive-ip-changes\">Connections Survive IP Changes</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#wrapping-up\">Wrapping Up</a></p>\n</li>\n<li>\n<p><a href=\"#references\">References</a></p>\n</li>\n</ul>","excerpt":"HTTP/3 is the third major version of HTTP (Hypertext Transfer Protocol). Unlike HTTP/1 and HTTP/2, it communicates using QUIC, a UDP-based protocol. The biggest difference between HTTP/3 and its predecessors is that it runs on UDP instead of TCP. I first learned about HTTP/3 after reading a post someone shared: HTTP/3: the past, the present, and the future. My honest first reaction when I saw the title was:","html":"<p>HTTP/3 is the third major version of HTTP (Hypertext Transfer Protocol). Unlike HTTP/1 and HTTP/2, it communicates using QUIC, a UDP-based protocol. The biggest difference between HTTP/3 and its predecessors is that it runs on UDP instead of TCP.</p>\n<p>I first learned about HTTP/3 after reading a post someone shared: <a href=\"https://blog.cloudflare.com/http3-the-past-present-and-future/\" target=\"_blank\" rel=\"nofollow\">HTTP/3: the past, the present, and the future</a>. My honest first reaction when I saw the title was:</p>\n<!-- more -->\n<blockquote>\n<p>Wait, HTTP/2 was only released about 4 years ago. HTTP/3 already? Isn’t it just in the design phase?</p>\n</blockquote>\n<p>But after reading the post, I was surprised to learn that Google Chrome had already shipped a Canary build with HTTP/3 support — it was at the point where you could actually try it. It took roughly 15 years to go from HTTP/1 to HTTP/2, yet just 4 years later, the next major version was already usable.</p>\n<p>On top of that, the global adoption rate of HTTP/2 was still only around 40% at the time. That’s how recent HTTP/2 still was.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABKklEQVR42pWS2W6DMBBF+f8vzAPYHryUBLyw2NikD70JqJGatErR0WgYrrnjsatt287nZO2ntdc3ce46DGVZSjVNM2OjUkXK/BKlnil1HYchVuM4CTEZs2ldjHmBlIXogLHSNIVzLEazsQph5DxApHVu20z0gLFc14gr5ysiaNtVylUpJNH7m/N8OoWmge5QfEN0SLU+QL6/ChGdi9U8L2h73wzMn3neM4pEaXeeOB/3X8LnHaA8nLGYsXAf7P8XL0vkfHp1Hr/yaBt7xrT3tt8EAyO6O6eEwY445D+sftwZiOHsXKq893X9IYQlsm3rhBiI3B0rZUCCT1L6HaVQgcByPvS9h3OKMeacQ/BCcK0VkUBUSgohLpczcmN0132g3nWm7/t8e9aU0hd/j8r0CkmYvgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ce http2\" title=\"\" src=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png\" srcset=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/69538/ce-http2.png 160w,\n/static/8a0a69c0fbc05eba2198cd4f552845d4/72799/ce-http2.png 320w,\n/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png 600w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>HTTP/2 adoption rate as of August 2019, surveyed by W3Techs.com</small>\n</center>\n<p>With programming languages and frameworks, the publisher pushes an update and users upgrade — done. But protocols are agreements, requiring coordination between software vendors, so I assumed such rapid changes wouldn’t happen often.</p>\n<p>Technology moves fast, sure, but HTTP is a foundational web protocol. The fact that such a dramatic change happened in just 4 years was genuinely surprising. (Web developers who had just adopted HTTP/2 a few months earlier were in tears.)</p>\n<p>The other thing that surprised me was that HTTP/3 uses UDP instead of TCP. There’s no rule saying web protocols <em>must</em> use TCP, but from what we learn in school to what we use in practice, HTTP being defined on top of TCP was so deeply ingrained that using UDP felt novel. I couldn’t help but wonder: “Why abandon TCP when it works perfectly fine?”</p>\n<p>Technically, HTTP/3 hadn’t been formally released yet — it was still in the testing phase. But as mentioned above, Chrome already had a Canary build with HTTP/3 support, Mozilla Firefox was planning to support it in Nightly builds soon, and cURL was offering HTTP/3 as an experimental feature. It seemed very likely that HTTP/3 would become the main protocol in the near future.</p>\n<p>If you want to try HTTP/3 in Google Chrome, you can launch it from the terminal with the <code class=\"language-text\">--enable-quic</code> and <code class=\"language-text\">--quic-version=h3-23</code> flags:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">open</span> <span class=\"token parameter variable\">-a</span> Google<span class=\"token punctuation\">\\</span> Chrome <span class=\"token parameter variable\">--args</span> --enable-quic --quic-version<span class=\"token operator\">=</span>h3-23</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/1d6e0c652510ca8a97827fff1fad7575/5a6dd/http3-demo.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60.62500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACTElEQVR42lWRSXPTQBCF/QcgS0EVBwriRIvtaLVkS9Y20mixExNClkMqcQrHCVVw4sbff/S0i5AcXnVP98yn162elBK1rDB2bXiO9azAsxH6ziupWlNLnH1ZIokmnC+Xp8jSGXzXwjTw0Gtuf8NabPA5u4Em7qCVK+jVPd6Fl3jrfsWOd44d95zyc7yxz6i3woFYYZd6ZvMdo24DjWqmvMf7yRV6d7/+IOxuYJfXcOU1jotv+OgI7Bsz7GgRdrUYe5Tvmwl29RjD9Ayf/BZ7lFviAra4hFVcwKmu8MEq0fv5Y4OTroHIE8iygMgSBGQ/Ivtx6CEi+fYQI6PPytOYeyovixRS5BS3bz17gN7m8RGyaZHmAhmplA1yUUFUNeft/BRJlkM3DOi6jiTNEYRTOuvIihJFKSkK5GWFY8sm4GaDum7pYkbAAgXBFFhBgzBEOJnC98cM0zSN76m6rmtIs//3CwJaloXeIzmcL04IULKqmsanr6oLChaEEziuC88bwzBMBoZUM8hxzg4rioLfWDY5fHh4QNvNnyHxLEUQhPB8nx2ocSbTiOoJQ1R/HITsWPUKMrGNNPIxOVyv12jajoGy6Rg2Go34wdHREUuNqpMUMKV9KuemaTKEjRBU7dx2nC2wJtAsyXjctltgfrKE47gMeKntDnNeg/qgWpH4N3Iltzt8enqiP7lgoLqsonIxjWIMBoNXYof049QKTNNgSEnOlFNlRpngHfKBFt/vH+Dw8JBin0dVLl5KOZzQuK7rcT6NY96tihHF4XCEv+fijBWB+5EDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"http3 demo\" title=\"\" src=\"/static/1d6e0c652510ca8a97827fff1fad7575/6af66/http3-demo.png\" srcset=\"/static/1d6e0c652510ca8a97827fff1fad7575/69538/http3-demo.png 160w,\n/static/1d6e0c652510ca8a97827fff1fad7575/72799/http3-demo.png 320w,\n/static/1d6e0c652510ca8a97827fff1fad7575/6af66/http3-demo.png 640w,\n/static/1d6e0c652510ca8a97827fff1fad7575/5a6dd/http3-demo.png 802w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>The entries showing http/2+quic/46 are connections using the HTTP/3 protocol</small>\n</center>\n<p>As a web developer, I couldn’t just ignore the fact that HTTP was getting a major update. I was also curious about what using UDP actually meant. So I dug into HTTP/3, and this post is a summary of what I found.</p>\n<h2 id=\"a-brief-introduction-to-http3\" style=\"position:relative;\">A Brief Introduction to HTTP/3<a href=\"#a-brief-introduction-to-http3\" aria-label=\"a brief introduction to http3 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>HTTP/3 was originally called “HTTP-over-QUIC.” Mark Nottingham, chair of both the HTTP and QUIC working groups within the IETF (Internet Engineering Task Force), proposed renaming the protocol to HTTP/3. The proposal was accepted in November 2018, and the name changed from HTTP-over-QUIC to HTTP/3.</p>\n<p>In other words, HTTP/3 is HTTP running on top of a protocol called QUIC. QUIC stands for “Quick UDP Internet Connection” — literally, a protocol that establishes internet connections using UDP. (It’s pronounced just like “quick,” by the way.)</p>\n<p>HTTP/3 uses QUIC, and QUIC uses UDP, so we can say HTTP/3 uses UDP.</p>\n<p>So what exactly is QUIC, and why can it achieve faster transmission speeds than TCP? To understand that, we first need to know why TCP is considered slow and what advantages UDP offers.</p>\n<h2 id=\"why-is-tcp-considered-slow\" style=\"position:relative;\">Why Is TCP Considered Slow?<a href=\"#why-is-tcp-considered-slow\" aria-label=\"why is tcp considered slow permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>When I first learned about the differences between TCP and UDP in a networking class, my professor said it would definitely be on the exam, so I memorized this table:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Connection</td>\n<td>Connection-oriented</td>\n<td>Connectionless</td>\n</tr>\n<tr>\n<td>Packet exchange</td>\n<td>Virtual circuit</td>\n<td>Datagram</td>\n</tr>\n<tr>\n<td>Order guarantee</td>\n<td>Guaranteed</td>\n<td>Not guaranteed</td>\n</tr>\n<tr>\n<td>Reliability</td>\n<td>High</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Speed</td>\n<td>Slow</td>\n<td>Fast</td>\n</tr>\n</tbody>\n</table>\n<p>From this table, the takeaway is roughly “TCP is reliable but slow” and “UDP is unreliable but fast.” The “reliability” here refers to whether all data sent by the sender arrives intact at the receiver — by checking packet ordering, detecting packet loss, and so on.</p>\n<p>TCP uses several mechanisms to ensure reliable communication between client and server. But these mechanisms are themselves communications between client and server, so they inevitably add latency. And since these processes have been part of the TCP standard since its inception, you can’t just skip them.</p>\n<p>To reduce latency, you’d need to touch things outside of TCP’s defined features — but there are many constraints. No matter how much you increase bandwidth, the data we need to transmit keeps growing with advancing technology, so things will eventually get slow again. And even if you increase the raw transmission speed, you can’t go faster than the speed of light.</p>\n<p>This is exactly why HTTP/3 chose QUIC, a UDP-based protocol — it opted to modify the protocol itself to overcome these constraints. But TCP is such an old protocol, deeply defined at the low level down to the kernel, that overhauling it would be a massive undertaking. So they chose UDP instead.</p>\n<p>Let’s look at why the mechanisms TCP uses for reliable communication are considered slow.</p>\n<h3 id=\"3-way-handshake\" style=\"position:relative;\">3-Way Handshake<a href=\"#3-way-handshake\" aria-label=\"3 way handshake permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>TCP is an extremely polite protocol. Before starting or ending communication, it always asks whether both sides are ready, establishes packet ordering, and only then begins the actual data transfer.</p>\n<p>The process at the start of communication is called the 3-Way Handshake, and the process at the end is called the 4-Way Handshake. Since the purpose of this post isn’t to cover these in detail, I’ll only explain how the 3-Way Handshake works.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.74999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA9gAAAPYAF6eEWNAAACX0lEQVR42k1S227aQBD1//9EH/LQqhSpJNCE2IAvwXfWxvLd611fARHRgBSJW7A7wEvnYTS7O2fm7JlhTqdz27bb7Ycyldfr9fl8Ph6OTdO0/9nlcjkcDvCUpqltWbvdDhLgyCiKMpnwgiAihBzHCYIA/HK5BExzMwjKspzP557n2bataxrPC7wgTmWZEUW+8/MHxw0JwUmSYJwAvijKe8M7OM/zoijquoaiGGOOe+12O5I0YTx3riqS50Fpa2bOLAuZpllV9b0zwCEAtsPhkGVfx+NxHMfI1gWB8/w5A5TCMABKPM8PBgOWZf88PyfJtfNqtd5sPiAghMg3myGUxFhjPfaXYk19JooSWdaCIPZ93zCN668MI4qK/b5FqAj81R2sqSo8aRpkhqHrz3QjDkOGZdHDw/CpP03iCKGZaRqSJOVZBpjPz/3m7+fHtuUnCc9PBFBVkqIoTlLsuE61qJk0jZGlJ0kI5YG8YRij0SjPr+C5EUQOaY+thzA34uAevmZb9nOH6357El5Epi7r0I/LvAIlQBhCKQTEq067dk3279m+OYPaWYpxlmWQQAn1HM9UjSgIGNVRBmJ/oo+kN1EUhF7vd78/sJTqcmqrugbNrmpj/PjYAy0ty8rynGTE9d2yKpmRMey9dYbqE6UpMAflXc+lWXk8tba9CIJ3AGNMQSdCKDSnlBa0DNxgUS2YZb1c1Svwt03Iq6oCbuAB8/XVnE7NdttOp1TTVF3XLdvGBI8MtjvuyPM3BrZihkzQ2brZdVS6fgffFqy5jYrK8hTmZJowI7037na57y/C4z+QeJZeh7viqwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3way handshake\" title=\"\" src=\"/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png\" srcset=\"/static/dd7f29fecd14fe5feebc6cf562123c48/69538/3way-handshake.png 160w,\n/static/dd7f29fecd14fe5feebc6cf562123c48/72799/3way-handshake.png 320w,\n/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png 550w\" sizes=\"(max-width: 550px) 100vw, 550px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>The 3-Way Handshake process when starting communication</small>\n</center>\n<p>As shown above, when a client first creates a TCP connection to a server, they exchange <code class=\"language-text\">SYN</code> and <code class=\"language-text\">ACK</code> packets. The values inside these packets allow client and server to verify packet ordering and confirm that packets were properly received.</p>\n<p>This process requires 3 round trips of communication. If you’re on macOS or Linux, you can observe this process directly using the <code class=\"language-text\">tcpdump</code> utility in your terminal.</p>\n<p>Note that running <code class=\"language-text\">tcpdump</code> without options will monitor all packets on the device, making it hard to find what you want. So I captured only the communication with a blog server running on loopback:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> tcpdump <span class=\"token function\">host</span> localhost <span class=\"token parameter variable\">-i</span> lo0\nIP localhost.53920 <span class=\"token operator\">></span> localhost.terabase: Flags <span class=\"token punctuation\">[</span>S<span class=\"token punctuation\">]</span>, <span class=\"token function\">seq</span> <span class=\"token number\">1260460927</span>, win <span class=\"token number\">65535</span>\nIP localhost.terabase <span class=\"token operator\">></span> localhost.53920: Flags <span class=\"token punctuation\">[</span>S.<span class=\"token punctuation\">]</span>, <span class=\"token function\">seq</span> <span class=\"token number\">3009967847</span>, ack <span class=\"token number\">1260460928</span>, win <span class=\"token number\">65535</span>\nIP localhost.53920 <span class=\"token operator\">></span> localhost.terabase: Flags <span class=\"token punctuation\">[</span>.<span class=\"token punctuation\">]</span>, ack <span class=\"token number\">3009967848</span>, win <span class=\"token number\">6379</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>sender > receiver: Flags [flag type], header values</p>\n</blockquote>\n<p>The original output contains more information, but I’ve trimmed it to what’s needed for the explanation. The key fields here are <code class=\"language-text\">Flag</code>, <code class=\"language-text\">seq</code>, and <code class=\"language-text\">ack</code>. Let’s break them down.</p>\n<p><code class=\"language-text\">localhost.53920</code> is the client, and <code class=\"language-text\">localhost.terabase</code> is the server. Each line’s first field shows <code class=\"language-text\">sender > receiver</code>, so the first packet is from client to server, the second from server to client. Each line also has a <code class=\"language-text\">Flag</code> that indicates what type of packet it is:</p>\n<table>\n<thead>\n<tr>\n<th>Flag</th>\n<th>Name</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S</td>\n<td>SYN</td>\n<td>Client sends a sequence number to the server to initiate connection</td>\n</tr>\n<tr>\n<td>S.</td>\n<td>SYN-ACK</td>\n<td>Server generates an ACK value and responds to the client</td>\n</tr>\n<tr>\n<td>.</td>\n<td>ACK</td>\n<td>Response using the ACK value</td>\n</tr>\n</tbody>\n</table>\n<p>After this communication, client and server can establish a reliable TCP connection. Since it takes 3 exchanges, it’s called a 3-Way Handshake.</p>\n<p>What happens during this process that creates a reliable connection? Looking more closely, the client and server go through roughly this flow:</p>\n<blockquote>\n<p>Line 1: Client sends a sequence number in the <code class=\"language-text\">seq</code> field to the server<br />\nLine 2: Server increments the client’s sequence number by 1 and sends it back in the <code class=\"language-text\">ack</code> field<br />\nLine 3: Client increments the server’s sequence number by 1 and sends it back in its own <code class=\"language-text\">ack</code> field<br /></p>\n</blockquote>\n<p>The 3-Way Handshake begins when a client sends a random sequence number to the server to create a new TCP connection. This sequence number later serves as the ordering guide when the receiver reassembles packets from the sender.</p>\n<p>Both client and server increment the received <code class=\"language-text\">seq</code> (sequence number) by 1 and place it in their own <code class=\"language-text\">ack</code> (acknowledgment number) field, essentially saying: “This packet follows the sequence number you sent earlier.”</p>\n<p>These 3 exchanges are the 3-Way Handshake. Through this process, client and server inform each other that they’re ready to exchange data and establish the sequence numbers needed for subsequent data transfer. Ending a connection goes through a similar 4-Way Handshake process, requiring 4 exchanges.</p>\n<p>In short, as long as you’re using TCP, you must go through this tedious process before any real communication can begin.</p>\n<p>HTTP/1 processed only one request per TCP connection and then closed it, so this handshake had to happen with every single request. HTTP/2 changed this by maintaining a single TCP connection and handling multiple requests over it, minimizing handshakes.</p>\n<p>Even in the transition from HTTP/1 to HTTP/2, the handshake process itself was left untouched — they only minimized how often it occurred to reduce latency. This is because handshaking is mandatory as long as TCP is in use.</p>\n<p>HTTP/3, however, chose UDP, eliminating the handshake process entirely and securing connection reliability through other means.</p>\n<h3 id=\"holb-head-of-line-blocking\" style=\"position:relative;\">HOLB (Head-of-Line Blocking)<a href=\"#holb-head-of-line-blocking\" aria-label=\"holb head of line blocking permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>There’s another problem with HTTP over TCP: Head-of-Line Blocking (HOLB). While HTTP-level HOLB and TCP-level HOLB technically mean different things, they share the same essence — a bottleneck in one request increases overall latency.</p>\n<p>In TCP communication, packets must be processed in exact order. The receiver must reassemble packets using the sequence numbers exchanged with the sender.</p>\n<p>If a packet is lost mid-transmission, the data can’t be fully reassembled, so it’s never ignored. The sender must confirm that the receiver got every packet, and if any packet wasn’t received, it must be retransmitted.</p>\n<p>Since packets must be processed in order, subsequent packets can’t be processed until previous ones are parsed. When a packet is lost or the receiver’s parsing speed is slow, this bottleneck is called “HOLB.” This is a fundamental TCP issue affecting not just HTTP/1 but HTTP/2 as well.</p>\n<p>To solve these problems, HTTP/3 chose to run on QUIC, a protocol built on UDP. Let’s now look at what QUIC actually is and what advantages UDP offers over TCP.</p>\n<h2 id=\"why-http3-uses-udp\" style=\"position:relative;\">Why HTTP/3 Uses UDP<a href=\"#why-http3-uses-udp\" aria-label=\"why http3 uses udp permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Since HTTP/3 runs on QUIC, understanding HTTP/3 means focusing on QUIC. QUIC is a UDP-based protocol developed by Google to solve TCP’s problems and break through latency limitations.</p>\n<p>QUIC was designed from the start with a focus on optimizing TCP’s handshake process, and it achieved this by using UDP.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/e8950/quic.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC3klEQVR42o1U/UuTURT2H4gI+iGTgqB+S5McFqlJZDaz0LK0NHSpSYkmlbNiH1okiC00h6SULjQykrWK/MyVpqFoUzIlNXP4rdkHfmzpdren+95t2mxbXTjcc+8553mfe597XjcAC86MEOJy/YfNUTNTq3eDk2E2m9k8O69DQ1sX5nR6u/1VucTqNrs5A1oyGFHV1IYD0Slw38lHcEwq6lo6/spzCWhL0v1axCNVDbb5H8WWM2Lwyt9ia4IEG31CEHvxBj4OaO3yHQISk4nNlbWNOJYsQux1OQIq3oHXoIVPqRretYPg0dmDL8Am/wg8a2hZrnMMSCyAIlkx1vidgG/TGHaUqBEnkiFbdhfh6TnwftCIXXTf/aAA4tvF1jriGlCadx/r/I5jj6oLPGUnAkUFEOYWoVjxGOICBUIVdVgbEIVMmucS0GQ98vuefuyLuYANu8OwXVIEn5p+eKk+4EihElLKPrdQAQkF0/QMWOvM/xZlnj6RgjIlPPdHwSM4Dl6Z97CeHtPrsACvWjv/X2X2RZpoYzsyNYNLN+XwDDoJYbYco5Nfl0/DMXMKaDQa6bszMDMaLTFuNlkUxMTMj+VXwOXY2Blo3aKlzjnD1VdgY8sxMjnoEocMa5vbkZyVTy0P1bQ7uPHpyzCKKl4wv6SyCh3dfcyXlz/F1Mx35iuUNUgQ3YL0jmIFUE+7IiA6FWWqOjx8Xg/fiHMs8rpVg9CzV5gfmZbFYtwIPJ0G7dgkej9rWZ2qvhnqVs0K4NyCHv6nUjAyMY3x6W8IElxmkTf0h8BPyGB3GU47p+Klmu3z44VMHE1vP0ISM8ARon1vd2STJL+U0CA5lHSVbN4bSdq7+8jP2XkSK8wmYedFJCJVSgaHx4mRvuL4azmEMiQLOj1JFOWS4Ph0kiSWLVlFb2R3aLaagXZLS2cPhkYnV0Qxc7Nz4bg4FcyO4RDVcQirjJKxW1O1Xa0HqXEsnvwGZ3Pl7+F/khcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"quic\" title=\"\" src=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/6af66/quic.png\" srcset=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/69538/quic.png 160w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/72799/quic.png 320w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/6af66/quic.png 640w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/d9199/quic.png 960w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/21b4d/quic.png 1280w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/e8950/quic.png 2000w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>As the name “User Datagram Protocol” suggests, UDP uses a datagram approach with independent packets that have no inherent ordering. Since datagrams only need a destination — they don’t care about the intermediate path — there’s no end-to-end connection setup either. In other words, no handshake is needed.</p>\n<p>The bottom line is that UDP is faster because it skips the many steps TCP takes to ensure reliability. But does using UDP mean we lose the reliability and data integrity that TCP provided?</p>\n<p>No. Even with UDP, you can implement all the features TCP has. UDP’s real advantage is that it’s highly customizable.</p>\n<h3 id=\"udp-is-a-blank-canvas\" style=\"position:relative;\">UDP Is a Blank Canvas<a href=\"#udp-is-a-blank-canvas\" aria-label=\"udp is a blank canvas permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>In school, I was taught that the biggest difference between UDP and TCP is “UDP is faster but less reliable than TCP.” This is half right and half wrong.</p>\n<p>UDP has no features defined beyond data transmission itself, so it’s true that the protocol doesn’t guarantee reliability on its own. But put differently, it’s a blank-slate protocol with nothing but data transmission capability. To get a sense of how many features TCP packs in for reliability and congestion control, just look at its header:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ac69210c44cd473bcb737665d590b124/c7bb6/tcp-header.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 33.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABWUlEQVR42j2P147CMBRE8/9/x4IQkEKq4zi9YofA7NjS7sOR43jKvV6YSMh2xbJs6PoR47Rg5vc0rxjGGbKq8fADVKpx/5q2d5o/rKbtBvTDhO2l4V0fCcK0gpAKWSGRCYkozvBMcqR5ibQoIVWLsmrce5wWjuvNx+0RIMkEYmr9KEHbD/ByoVz7/j6gzU4M20ZOucLsb9cqK4W8ENTVWLeXo6N5GCfnsTpNzL7DS3PJ9hrLurmQhUyzXWfGwDWSNEMYPSFK6mQFVTeuxIZuRGuDF9mIYbib0K7UsLHuejwZkNEsaVRtB9W06DiJOQ4c3y/eZKXZvlv9y05ntyOGeGFcoMwKHFxTM0A3HaoogopjTJxoYvggSow8F65uTxGEKMOIuif6vIC2wSw23MwTNSdIUnx9H0cQ4BOG2Pk9ns+O6XJx9KfT/338OaPjXd/v+LLcej7WrxR+AYjFDnQh+N9MAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tcp header\" title=\"\" src=\"/static/ac69210c44cd473bcb737665d590b124/6af66/tcp-header.png\" srcset=\"/static/ac69210c44cd473bcb737665d590b124/69538/tcp-header.png 160w,\n/static/ac69210c44cd473bcb737665d590b124/72799/tcp-header.png 320w,\n/static/ac69210c44cd473bcb737665d590b124/6af66/tcp-header.png 640w,\n/static/ac69210c44cd473bcb737665d590b124/d9199/tcp-header.png 960w,\n/static/ac69210c44cd473bcb737665d590b124/21b4d/tcp-header.png 1280w,\n/static/ac69210c44cd473bcb737665d590b124/c7bb6/tcp-header.png 1986w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>TCP's header, already packed with information</small>\n</center>\n<p>TCP was designed a long time ago and includes so many features that its header is nearly full. If you want to implement custom features beyond TCP’s built-in ones, you’d use the <code class=\"language-text\">Options</code> field at the bottom, but since it can’t grow infinitely, it’s capped at <code class=\"language-text\">320 bits</code>.</p>\n<p>And the later-defined options like <code class=\"language-text\">MSS (Maximum Segment Size)</code>, <code class=\"language-text\">WSCALE (Window Scale Factor)</code>, and <code class=\"language-text\">SACK (Selective ACK)</code> already take up most of that options space, leaving barely any room for custom features.</p>\n<p>UDP, on the other hand, was designed with a sole focus on data transmission, so its header is practically empty:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/73dae/udp-header.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 13.750000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAq0lEQVR42j2O226DMBAF+f/P60vTkNoO2GAuBoxNopJEky1S+zDSzh7tpVCVx0+ZdLszxcSSNtbtfhDzjXlN6KpGXesjiykTpoW4Zqm3gzmuTHNkkfnio3Qo7QjW4U1Nf7U0yqBOZ5pvg9cVvfQ7wTUdVqidp7Ytn6eS8qKxbU8l/kvRjYEwjOxy5WeJPOSjLN5q8+9/2T6OPIVXCOz9QPt1Zjbm8KfseQwDb9HI4QyOb6OzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"udp header\" title=\"\" src=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/6af66/udp-header.png\" srcset=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/69538/udp-header.png 160w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/72799/udp-header.png 320w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/6af66/udp-header.png 640w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/d9199/udp-header.png 960w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/21b4d/udp-header.png 1280w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/73dae/udp-header.png 2122w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Compared to TCP, UDP's header is noticeably bare</small>\n</center>\n<p>UDP’s header contains only source port, destination port, packet length, and checksum. The checksum is used for verifying packet integrity, but unlike TCP’s mandatory checksum, UDP’s checksum is optional.</p>\n<p>In other words, while the UDP protocol itself is less reliable than TCP and lacks flow control, depending on how a developer implements the application layer, it can achieve TCP-like functionality.</p>\n<p>Sure, it’s convenient that TCP provides all those reliability features out of the box. But the unfortunate part is that these features are mandatory processes defined in the protocol itself — developers can’t customize them. This makes it nearly impossible to even attempt reducing the latency they introduce.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e0bf6f0a79b033925a91b04e4653d7af/e2310/tcp-tls.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 102.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAADtklEQVR42s2TbUxTVxjHsWwuRMbclmWGKZoN3USigsFJ1A9kWZZJsixmbPHLFr84i2lLaUtf0uaEVpcimkDGQjYVBTK23ESBZnTicLp0AtG2lL5cyu1tb+9tb6G0lHaoHVR6dm4DRnRu9sOSneRJ7n2ec375n/P8n5yc/3IJBIICoVC4VSqVviWRSDbX1dW9WV9fvwnlihoaGjbKZLJCPp+/icuLRKL1y7XX0dE1q0AYBnO5UCi+elUuB1sAABuXgeUItEOr1W7V6XSb1Wr1dg4gFovfUCj4LwOgL5LJQCGEMBfFc6uhN0C+sllZqmxVvsb9Awh5T7sJBA9rPK1Wv0MJwDurNty5M9kyMkzYzL/jt1wW0jwViQ5csAY+PKb/9iUPjpcHg8GjDMMcpWm6hts/KLlcCnJq1vqmUx8RzPwEPX3PNhVJVj0Edl2yD7WfGoEXVFdT174zw5nYQqSfjB/JqEkmtyDYCYIgakmSPIYxWF5Pbc+7bvsUFp39M3U/uZRegjAdu5uC1vEZUQbonIgPOYgktDHzKR99D17rsET7iOgn3cbRAjYQEPn9/hORSIQfDoWlOIl/0S3o3nf7FiO1k3+kTWb2wc1RJm3xJhZ/tYU/yABn5lP6u6kl08JS2hhL3L9uHqaw86OB6isDv2xDykQul+szpPJjpPBIcDpY2av6abegWPDCb65Eo2ViDjqJWMpiC9X//YNDmLGA6opzby1oy08kIm+zLNuAVMpCodCXXK1H3ldmbDUWcN9zc3D3/AIs5c4hd/BWIJm2c2E2w+e5nOZHR8U57OorLEsfQCA+RVHHUVOOOwlnyQ+NvQe7JF3rHhPC+0eFwnOWnSMWx3afz/cNUncKx3Hd+Ph4u5/xSzvVxrK2Wiz/ETG5T52WFaCmw1oRjieLY+Hwrng8vndxcbECXf2g1z9Z/XO36dOaErD2mcZv5R1Of2+vnJ6Jtnk9nkuoGc1ut/uM3W4/zYYCHe7bDHhi3P5NoeKMaU9np6Fo0uU6xCmbnZ3dj6xTheobWoT9O8/L+l7MCqhqGiqn6UghgjUiy+i9Xq+OcBOtoXDg8681hspmyeC6rIBy7c0yg8FUhOPOk6jDOnRlDUGQzYEQdbhJZihvAzfyswJqNIN7jEaigKI8VUhdNTL3IYfNcdiOW99vaex976x4OC8roFp+fZfTSpSQpAfzeDw9KNopyt8ZYOm6JtXQsytEyAwQKAa2XbyIbRgbG1u/bHreit+Aor/4rBjLy/k/rDXZnvgLm+tNcqo265oAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tcp tls\" title=\"\" src=\"/static/e0bf6f0a79b033925a91b04e4653d7af/6af66/tcp-tls.png\" srcset=\"/static/e0bf6f0a79b033925a91b04e4653d7af/69538/tcp-tls.png 160w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/72799/tcp-tls.png 320w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/6af66/tcp-tls.png 640w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/d9199/tcp-tls.png 960w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/e2310/tcp-tls.png 968w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>If you add TLS on top of TCP, you have to go through all of this before communication even begins</small>\n</center>\n<p>To reduce latency, you’d need to modify things outside the protocol. But as I mentioned, the areas a typical developer can touch in the communication process are limited. (We just have to wait for the telecom giants to lay down the infrastructure.)</p>\n<p>If the difference between TCP and UDP still isn’t clicking, think of it as “a heavy, full-featured library” versus “a lightweight library with only the essentials.”</p>\n<p>For example, <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"nofollow\">lodash</a> in the JavaScript world is incredibly feature-rich and convenient, but most people don’t use every single method. It’s handy, but you’re bundling features you’ll never use.</p>\n<p>A small library with a single purpose has fewer features than lodash, but you can pick exactly what you need. The tradeoff is that anything the library doesn’t support, you have to implement yourself. In this analogy, lodash is TCP and the small single-purpose library is UDP.</p>\n<p>This is why Google chose UDP when building QUIC: TCP was too difficult to modify, and the blank-slate nature of UDP made it easy to extend QUIC’s capabilities.</p>\n<h2 id=\"how-http3-improves-over-previous-protocols-by-using-udp\" style=\"position:relative;\">How HTTP/3 Improves Over Previous Protocols by Using UDP<a href=\"#how-http3-improves-over-previous-protocols-by-using-udp\" aria-label=\"how http3 improves over previous protocols by using udp permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>So far we’ve briefly covered why QUIC, the backbone of HTTP/3, chose UDP over TCP. What concrete benefits does using UDP actually bring? Is HTTP/3 truly better than the old HTTP + TCP + TLS approach?</p>\n<p>The answer can be found in the Chromium Projects’ <a href=\"https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit\" target=\"_blank\" rel=\"nofollow\">QUIC Overview</a> document. Let’s look at the advantages Google describes.</p>\n<h3 id=\"reduced-latency-in-connection-setup\" style=\"position:relative;\">Reduced Latency in Connection Setup<a href=\"#reduced-latency-in-connection-setup\" aria-label=\"reduced latency in connection setup permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Since QUIC doesn’t use TCP, it doesn’t need the tedious 3-Way Handshake to start communication. A cycle where the client sends a request and the server processes and responds is called an “RTT (Round Trip Time).” TCP requires at least 1 RTT to create a connection, and if you add TLS encryption, the TLS handshake adds up to a total of 3 RTTs.</p>\n<p>QUIC, on the other hand, requires only 1 RTT for the initial connection setup. The client sends a signal to the server, the server responds, and real communication begins immediately. The connection setup time is roughly halved.</p>\n<center>\n  <img src=\"/95f5c7e411d0b7f96d182abe284be551/gcp-cloud-cdn-performance.gif\" width=\"100%\">\n  <br>\n</center>\n<p>How is this possible? The reason is simpler than you’d expect. During the first handshake, QUIC sends the data along with the connection setup information. TCP + TLS exchanges all the information needed for a reliable connection and encryption, validates it, and <em>then</em> exchanges data. QUIC just fires off the data immediately.</p>\n<p>This process is explained in detail in the session ”<a href=\"https://youtu.be/vXgbPZ-1-us\" target=\"_blank\" rel=\"nofollow\">How Secure and Quick is QUIC?</a>” presented at the 2015 IEEE Symposium.</p>\n<p><div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.49999999999999%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <div class=\"embedVideo-container\"> <iframe title=\"\" src=\"https://www.youtube.com/embed/vXgbPZ-1-us?rel=0\" class=\"embedVideo-iframe\" style=\"border:0; position: absolute; top: 0; left: 0; width: 100%; height: 100%; \" loading=\"eager\" allowfullscreen=\"\" sandbox=\"allow-same-origin allow-scripts allow-popups\"></iframe> </div> </div></p>\n<center>\n  <small>Start watching from 3:33.<br />The presenter's swagger, hand in pocket, is hard to miss.</small>\n  <br />\n  <br />\n</center>\n<p>The key point of the video is this: TCP + TLS must exchange session keys and establish an encrypted connection before data can be exchanged with those session keys. QUIC can exchange data <em>before</em> session keys are even exchanged, which is why connection setup is faster.</p>\n<p>However, when a client sends its first request to the server, it doesn’t yet know the server’s session key. So it encrypts the communication using an Initial Key generated from the destination server’s Connection ID. For a detailed explanation, see the QUIC working group’s <a href=\"https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2\" target=\"_blank\" rel=\"nofollow\">Using TLS to Secure QUIC</a> document.</p>\n<p>Once a connection succeeds, the server caches the configuration and uses it for the next connection, enabling communication to start with 0 RTT. This is how QUIC achieves lower latency compared to TCP + TLS.</p>\n<p>Note that this session was presented before TLS 1.3 was released, so it wasn’t mentioned. Today, using TCP Fast Open with TLS 1.3, you can achieve a similar connection setup process, giving TCP some of the same benefits.</p>\n<p>However, TCP SYN packets are limited to about <code class=\"language-text\">1460 bytes</code> per packet, while QUIC can include all the data in the first round trip. So for large payloads, QUIC still has the advantage.</p>\n<h3 id=\"faster-packet-loss-detection\" style=\"position:relative;\">Faster Packet Loss Detection<a href=\"#faster-packet-loss-detection\" aria-label=\"faster packet loss detection permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Like TCP, QUIC also needs flow control for transmitted packets. Both QUIC and TCP are fundamentally ARQ-based protocols — ARQ (Automatic Repeat Request) means recovering from errors through retransmission.</p>\n<p>TCP uses “Stop and Wait ARQ”: after sending a packet, the sender starts a timer, and if the receiver doesn’t respond within a certain time, the packet is considered lost and retransmitted.</p>\n<p>According to Google’s 2017 <a href=\"https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1\" target=\"_blank\" rel=\"nofollow\">QUIC Loss Detection and Congestion Control</a>, QUIC detects packet loss similarly to TCP but with several improvements.</p>\n<p>A major issue with TCP’s packet loss detection is dynamically calculating how long to wait after sending a packet — when to trigger a timeout. This timeout is called the RTO (Retransmission Time Out), and the data it needs is a collection of RTT (Round Trip Time) samples.</p>\n<p>You measure how long it takes to receive an acknowledgment after sending a packet, then dynamically determine the timeout. To measure RTT samples, you must receive an ACK from the sender. Under normal conditions this isn’t a problem, but when a timeout occurs and a packet is retransmitted, the RTT calculation becomes ambiguous:</p>\n<blockquote>\n<p>Send packet → Timeout → Retransmit packet → ACK received!<br />\n(But is this ACK for the first packet or the second one?)</p>\n</blockquote>\n<p>To determine which packet the ACK corresponds to, you need additional methods like timestamps on packets, plus extra packet inspection. This is called Retransmission Ambiguity.</p>\n<p>To solve this, QUIC assigns a separate packet number space in its header. This packet number represents only the transmission order itself. Unlike sequence numbers (which remain the same on retransmission), packet numbers increase monotonically with each transmission, making it possible to clearly identify packet ordering.</p>\n<p>With TCP, if timestamps are available, you can determine transmission order through them. If not, you’re left implicitly inferring order from sequence numbers. QUIC eliminates this unnecessary ambiguity through unique per-packet numbers, reducing the time needed for packet loss detection.</p>\n<p>QUIC uses roughly 5 additional techniques to speed up packet loss detection. For details, I recommend reading Chapter “3.1 Relevant Differences Between QUIC and TCP” in <a href=\"https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1\" target=\"_blank\" rel=\"nofollow\">QUIC Loss Detection and Congestion Control</a>.</p>\n<h3 id=\"multiplexing-support\" style=\"position:relative;\">Multiplexing Support<a href=\"#multiplexing-support\" aria-label=\"multiplexing support permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Multiplexing is crucial because it prevents the HOLB problem mentioned earlier as a TCP drawback. With multiple streams, even if packets are lost in one stream, only that stream is affected — the others continue running fine.</p>\n<p>Note that multiplexing doesn’t mean creating multiple TCP connections. It’s a technique for sending multiple data flows without mixing them up within a single connection. Each individual data flow is called a stream.</p>\n<p>HTTP/1 used only one stream per TCP connection, so it couldn’t escape the HOLB problem. And since the connection closed after each transfer, you had to go through the handshake all over again.</p>\n<p>The <code class=\"language-text\">keep-alive</code> option could maintain a connection for a certain time, but if there was no access within that window, the connection would still close.</p>\n<p>HTTP/2 introduced multiplexing — handling multiple streams within a single TCP connection — to boost performance. With a single TCP connection carrying multiple data transfers, the number of handshakes dropped and data transfer became more efficient.</p>\n<center>\n  <img src=\"/40cb0bc1d62eba25c2e351d213d1700d/multiplexing.svg\">\n  <br>\n  <small>HTTP/3 supports the same multiplexing as HTTP/2.</small>\n  <br>\n  <br>\n</center>\n<p>QUIC also supports multiplexing like HTTP/2, carrying over these benefits. Even if one stream encounters a problem, the other streams are unaffected.</p>\n<h3 id=\"connections-survive-ip-changes\" style=\"position:relative;\">Connections Survive IP Changes<a href=\"#connections-survive-ip-changes\" aria-label=\"connections survive ip changes permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>TCP identifies connections using the source IP and port plus the destination IP and port. If the client’s IP changes, the connection breaks. A broken connection means going through the tearful 3-Way Handshake all over again, adding more latency.</p>\n<p>This is especially noticeable today because people frequently use mobile internet — switching from Wi-Fi to cellular, or moving between different Wi-Fi networks, all of which change the client’s IP.</p>\n<p>QUIC, on the other hand, uses a Connection ID to establish connections with the server. A Connection ID is just a random value completely unrelated to the client’s IP, so even if the client’s IP changes, the existing connection is maintained. This means you can skip the handshake that would otherwise be needed to create a new connection.</p>\n<h2 id=\"wrapping-up\" style=\"position:relative;\">Wrapping Up<a href=\"#wrapping-up\" aria-label=\"wrapping up permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>To properly explain HTTP/3 and QUIC, foundational networking knowledge is essential, so there were parts that were hard to cover in depth in this single post. I tried to be as detailed as possible, but the post was getting quite long, so I had to trim things down.</p>\n<p>After studying HTTP/3 and digging through various resources, my main takeaway was: “How did so much change?” Granted, once you throw out TCP, a lot is bound to change. But as someone who had only adopted HTTP/2 a few months earlier, it was a bit overwhelming. (The fact that they built HTTP but threw out TCP still blows my mind.)</p>\n<p>Honestly, whether developers use HTTP/2 or HTTP/3, users in countries with excellent internet infrastructure might not notice much difference. The small geographic size and strong infrastructure can cover up handshake latency and then some. But in countries with weaker infrastructure, the difference could be quite significant.</p>\n<p>In this post, I only talked about the advantages of HTTP/3 and UDP. Many people are concerned about abandoning TCP for UDP, and of course no technology is perfect — there will be issues.</p>\n<p>But as an attempt to break through the limitations of existing HTTP and TCP, it seems like a great move.</p>\n<p>That concludes this post on why HTTP/3 chose UDP.</p>\n<h2 id=\"references\" style=\"position:relative;\">References<a href=\"#references\" aria-label=\"references permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46403.pdf\" target=\"_blank\" rel=\"nofollow\">The QUIC Transport Protocol: Design and Internet-Scale Deployment</a></li>\n<li><a href=\"https://medium.com/codavel-blog/quic-vs-tcp-tls-and-why-quic-is-not-the-next-big-thing-d4ef59143efd\" target=\"_blank\" rel=\"nofollow\">QUIC vs TCP+TLS - and why QUIC is not the next big thing</a></li>\n<li><a href=\"https://blog.cloudflare.com/http3-the-past-present-and-future/\" target=\"_blank\" rel=\"nofollow\">HTTP/3: the past, the present, and the future</a></li>\n<li><a href=\"https://www.saturnsoft.net/network/2019/03/21/quic-http3-1/\" target=\"_blank\" rel=\"nofollow\">QUIC과 HTTP/3 - 1.UDP기반 전송 프로토콜의 대두</a></li>\n<li><a href=\"https://www.chromium.org/quic\" target=\"_blank\" rel=\"nofollow\">QUIC, a multiplexed stream transport over UDP</a></li>\n<li><a href=\"https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2\" target=\"_blank\" rel=\"nofollow\">Using TLS to Secure QUIC</a></li>\n<li><a href=\"https://blog.cloudflare.com/the-road-to-quic/\" target=\"_blank\" rel=\"nofollow\">The Road to QUIC</a></li>\n</ul>","fields":{"slug":"20191008-what-is-http3-en","path":"/2019/10/08/what-is-http3/en/","lang":"en"},"frontmatter":{"title":"Why Did HTTP/3 Choose UDP?","subTitle":"The web standard is changing. HTTP/3 picks UDP for speed.","date":"Oct 08, 2019","categories":["Programming","Network"],"tags":["HTTP3","TCP","UDP","Network"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/3a812/thumbnail.jpg","srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/3a812/thumbnail.jpg 320w,\n/static/70cbe98ca5682a8f70aa5afe9a5533ed/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/fc5c5/thumbnail.webp 320w,\n/static/70cbe98ca5682a8f70aa5afe9a5533ed/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/2d839/thumbnail.jpg","srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"UDP","lang":"en"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}