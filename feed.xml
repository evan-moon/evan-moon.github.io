<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Evan&#39;s Tech Blog</title>
    <link>https://evan-moon.github.io/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>글쓰기를 즐기는 우주 덕후 개발자의 블로그입니다. 사소한 생각 정리부터 튜토리얼, 삽질기 정도를 주로 끄적이고 있습니다.</description>
    <pubDate>Sun, 15 Mar 2020 13:27:12 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>서버의 상태를 알려주는 HTTP 상태 코드</title>
      <link>https://evan-moon.github.io/2020/03/15/about-http-status-code/</link>
      <guid>https://evan-moon.github.io/2020/03/15/about-http-status-code/</guid>
      <pubDate>Sun, 15 Mar 2020 12:57:03 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;최근의 모던 어플리케이션은 완전히 네트워크 위에서 돌아가는 프로그램이라고 해도 과언이 아닐 정도로 프로그램의 비즈니스 로직에서 통신이 차지하는 비중이 높다. 클라이언트 어플리케이션은 백엔드에 위치한 서버와 통신하여 현재 로그인한 사용자의 정보를 받아오거나, 새로운 게시글을 생성하기도 하고, 때로는 Web Socket을 통해 서버에서 발생한 이벤트를 구독하여 푸시 메세지나 채팅과 같은 기능을 구현하기도 한다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>최근의 모던 어플리케이션은 완전히 네트워크 위에서 돌아가는 프로그램이라고 해도 과언이 아닐 정도로 프로그램의 비즈니스 로직에서 통신이 차지하는 비중이 높다. 클라이언트 어플리케이션은 백엔드에 위치한 서버와 통신하여 현재 로그인한 사용자의 정보를 받아오거나, 새로운 게시글을 생성하기도 하고, 때로는 Web Socket을 통해 서버에서 발생한 이벤트를 구독하여 푸시 메세지나 채팅과 같은 기능을 구현하기도 한다.</p><a id="more"></a><p>이 과정에서 프론트엔드와 백엔드는 어떤 방식으로 통신을 할 것인지부터 시작하여 리소스의 생성과 삭제는 어떻게 정의할 것인지, 프론트엔드에서 요청한 백엔드 작업의 성공/실패 여부는 어떻게 알려줄 것인지 등 많은 규칙들을 정의해야한다.</p><p>그래서 이러한 규칙들을 정의할 때 도움을 주는 몇 가지 가이드라인들이 존재하는데, 이때 등장하는 것들이 HTTP 메소드나 상태 코드같은 표준과 REST 같은 녀석들이다.</p><p>이번 포스팅에서는 이 중에서  프론트엔드와 백엔드 간의 통신을 할 때 조금 더 명확한 정의를 위해 필요한 요소 중 하나인 HTTP 상태 코드를 파헤쳐보는 시간을 가져보려고 한다.</p><h2 id="굳이-이러한-가이드라인을-지켜야-하나요"><a href="#굳이-이러한-가이드라인을-지켜야-하나요" class="headerlink" title="굳이 이러한 가이드라인을 지켜야 하나요?"></a>굳이 이러한 가이드라인을 지켜야 하나요?</h2><p>사실 HTTP 메소드나 상태 코드, 그리고 REST 같은 것들은 말 그대로 가이드라인에 불과하다. 이것들을 지키지 않는다고 해서 프로그램이 작동하지 않는 것도 아니고 사용자가 프로그램을 사용하던 도중 런타임 에러가 발생하는 슬픈 일도 발생하지 않는다.</p><p>즉, 지키지 않아도 사실 프로그램을 작성하는데는 아무런 지장이 없다는 것이다.</p><center><br>  <img src="/2020/03/15/about-http-status-code/ebichu.jpeg" width="500"><br>  <small>그럼 굳이 안 지켜도 상관없는 것 아닌가요?</small><br>  <br><br></center><p>음, 이러한 규칙들을 지키지 않는 것은 자유지만 그로 인해 발생하는 사이드 이펙트들을 생각해보면 되도록이면 지켜주는 것이 좋다고 이야기하고 싶다.</p><h3 id="표준-인터페이스의-존재-이유를-생각해보자"><a href="#표준-인터페이스의-존재-이유를-생각해보자" class="headerlink" title="표준 인터페이스의 존재 이유를 생각해보자"></a>표준 인터페이스의 존재 이유를 생각해보자</h3><p>산업 표준은 불특정 다수에 의해 생산되는 제품들의 호환성을 맞추고, 제품 생산자들 간의 커뮤니케이션을 원활하게 하기 위해서 제정되며, 이렇게 각자 다른 객체들을 호환하기 위해 정의하는 일련의 표준 규격을 우리는 <code>인터페이스(Interface)</code>라고 부른다.</p><p>이 인터페이스라는 개념은 꽤나 광범위해서 뭐든 연결해주기만 할 수 있다면 인터페이스라고 생각하면 된다. 모니터와 컴퓨터를 연결하는 HDMI, 저장 장치에 사용되는 SATA, USB와 같은 친구들도 전부 인터페이스다. 심지어 UI(User Interface)같은 경우에는 기계와 기계가 아니라 인간과 기계를 이어준다는 개념으로까지 사용된다.</p><p>그 중 개발자들에게 가장 친숙한 인터페이스는 바로 <code>API(Application Programming Interface)</code>이다. API는 응용 프로그램을 제작할 때 필요한 기능들을 일련의 인터페이스로 제공된 것을 의미한다.</p><p>이때 API를 사용하는 쪽에서는 API의 사용법만 알면 되고 그 이면에 어떤 거대한 로직들이 숨어있는지는 일절 관심을 끊어도 되기 때문에 굉장히 편리하다는 장점이 있다. 대표적인 API의 한 종류로는 C에서 제공하는 Windows 운영체제의 API가 있다.</p><figure class="highlight c hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string"><Windows.h></span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string"><tchar.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> APIENTRY _tWinMain(</span><br><span class="line">  HINSTANCE hInstance,</span><br><span class="line">  HINSTANCE hPrevInstance,</span><br><span class="line">  LPTSTR lpCmdLine,</span><br><span class="line">  <span class="hljs-keyword">int</span> nCmdShow</span><br><span class="line">) {</span><br><span class="line">    MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"Hello, Windows!"</span>), TEXT(<span class="hljs-string">"App"</span>), MB_OK);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>개발자는 Windows 운영체제가 어떻게 저 메세지박스를 렌더하는지 모르더라도 단지 <code>MessageBox</code>라는 API의 함수를 사용함으로써 간단하게 메세지박스를 사용할 수 있다. 그리고 이 과정은 필자가 작성하는 C 어플리케이션과 운영체제, 전혀 다른 두 프로그램 간의 통신이기도 하다.</p><p>즉, API는 프로그램 간의 통신을 위한 인터페이스라고 할 수 있다. 마찬가지로 클라이언트가 서버에게 뭔가를 요청할 때도 특정 규칙으로 정의된 API를 사용하여 서버의 리소스를 사용하게 되는데, HTTP를 사용하여 통신하는 대부분의 모던 어플리케이션에서는 이 API를 엔드포인트(endpoint)라고 불리는 특정한 URL을 사용하여 정의하게되며, 서버는 일관된 방식으로 이 엔드포인트로 들어온 클라이언트 요청에 대한 응답을 보내줘야한다.</p><p>이때 HTTP 상태 코드는 클라이언트가 보냈던 요청의 수행 결과를 의미하는 일종의 약속이며, API를 구성하는 중요한 요소 중 하나이다.</p><h3 id="백엔드는-잘-모르는-프론트엔드의-슬픈-사정"><a href="#백엔드는-잘-모르는-프론트엔드의-슬픈-사정" class="headerlink" title="백엔드는 잘 모르는 프론트엔드의 슬픈 사정"></a>백엔드는 잘 모르는 프론트엔드의 슬픈 사정</h3><p>이 섹션에서는 잘못 정의된 API를 사용하는 프론트엔드 개발자라면 한번쯤은 겪어보았음직한 일을 한번 짧게 이야기해보려고 한다. 아마 백엔드 개발자들은 프론트엔드 어플리케이션의 소스를 직접 보는 경우가 드물기 때문에 이런 상황이 있다는 사실조차 모를 수 있을 것 같다.</p><p>바로 HTTP 상태 코드를 잘못 사용하고 있는 경우인데, 이런 상황에 대한 대표적인 예시는 바로 요청이 실패했을 때에도 상태 코드를 요청 성공을 의미하는 <code>200 Ok</code>로 내려주는 것이다.</p><figure class="highlight hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/users/123</span><br></pre></td></tr></tbody></table></figure><figure class="highlight hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="hljs-number">200</span> OK</span><br><span class="line">{ "success": false }</span><br></pre></td></tr></tbody></table></figure><p>이렇게 설계한 API의 경우, 위 예시처럼 HTTP 응답 바디에 요청의 성공/실패 여부나 실패 이유를 함께 담아서 보내주는 경우가 대다수인데, 그러면 프론트엔드 어플리케이션에서는 처리가 약간 애매해지는 상황이 발생한다.</p><p>프론트엔드에서는 이런 비동기 요청을 Promise를 통해서 처리하게 되는데, 문제는 대부분의 HTTP 통신 라이브러리나 API들은 백엔드에서 보내주는 요청의 상태 코드에 따라 요청의 성공/실패 여부를 판단하고, 요청이 실패했을 경우에만 에러를 던진다는 것이다.</p><p>그래서 일반적인 경우, 프론트엔드 어플리케이션에서는 대략 이런 느낌으로 통신을 담당하는 코드를 작성한다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchUsers</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">try</span> {</span><br><span class="line">    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'/api/users/123'</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> response.json();</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">catch</span> (e) {</span><br><span class="line">    alert(<span class="hljs-string">'요청이 실패했어요!'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>서버로 보냈던 요청이 실패했다면 서버는 반드시 <code>400</code>이나 <code>500</code>번대의 상태 코드를 보내줄 것이고, 그렇게 되면 <code>fetch</code> API는 에러를 발생시킨다. 그래서 <code>fetch</code>를 사용할 때는 단순히 외부에서 <code>try/catch</code> 구문을 사용하는 것만으로도 간단하게 통신에 대한 에러를 핸들링할 수 있는 것이다.</p><p>하지만 위의 잘못된 예시처럼 백엔드 어플리케이션에서 요청이 실패했음에도 불구하고 상태 코드로 <code>200</code>번대 코드를 내려준다면 프론트엔드 어플리케이션의 코드에는 이런 슬픈 상황이 발생한다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchUsers</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">try</span> {</span><br><span class="line">    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'/api/users/123'</span>);</span><br><span class="line">    <span class="hljs-keyword">const</span> { success } = <span class="hljs-keyword">await</span> response.json();</span><br><span class="line">    <span class="hljs-keyword">if</span> (!success) {</span><br><span class="line">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();</span><br><span class="line">    }</span><br><span class="line">  } <span class="hljs-keyword">catch</span> (e) {</span><br><span class="line">    alert(<span class="hljs-string">'요청이 실패했어요'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>아까 전에는 없던 <code>if (!success)</code>가 생긴 것을 볼 수 있다. 즉, 불필요한 예외 처리가 한번 더 발생한 것인데, 이런 불필요한 예외처리는 코드의 가독성을 해치지만 프론트엔드 입장에서는 딱히 선택권이 없다. 그렇다고 서버가 보내주는 에러를 무시하고 핸들링을 안 할수도 없지 않은가?</p><p>게다가 백엔드 어플리케이션이 미처 핸들링하지 못한 에러가 발생하거나 서버가 아예 죽어버리기라도 하면 응답의 상태 코드에는 에러 코드인 <code>500</code>이나 <code>502</code>가 내려올 것이기 때문에 <code>try/catch</code> 구문을 사용하지 않을 수도 없다.</p><p>클라이언트에서 사용하는 모든 HTTP 통신 라이브러리들은 올바른 HTTP 상태 코드의 사용을 가정하고 설계되었기 때문에, 서버가 올바르지 않은 상태 코드를 사용한다면 이런 슬픈 상황이 발생할 수도 있다는 점을 이야기해두고 싶다. 그리고 사실 백엔드 어플리케이션에서 상황에 맞는 올바른 상태 코드를 내려주는 것이 그렇게 어려운 일도 아니다. <small>(다만 조금 귀찮을 뿐이다)</small></p><p>클라이언트와 마찬가지로 대부분의 서버 프레임워크에서 제공하는 통신 라이브러리들도 모든 상황에 맞는 HTTP 상태 코드들을 제공하고 있으니 되도록이면 알맞은 상황에 맞는 상태 코드를 사용하는 것을 추천한다.</p><p>자, 그럼 이제 본격적으로 이 수많은 HTTP 상태 코드들이 정확히 어떤 상태를 의미하는지 알아보도록하자.</p><h2 id="작업의-수행-상태를-알려주는-HTTP-상태-코드"><a href="#작업의-수행-상태를-알려주는-HTTP-상태-코드" class="headerlink" title="작업의 수행 상태를 알려주는 HTTP 상태 코드"></a>작업의 수행 상태를 알려주는 HTTP 상태 코드</h2><p>클라이언트가 서버에게 작업을 요청하면 서버는 요청받은 작업을 수행한 후 작업의 수행 결과를 응답으로 보내주는데, 이때 HTTP 상태 코드를 사용하여 작업의 성공/실패 여부와 작업이 실패했다면 어떤 이유로 실패했는지도 알려주게 된다. 위에서 보았던 잘못된 예시처럼 HTTP 응답 바디에 작업의 실패 여부를 담아서 응답해주는 경우도 있지만, 더 좋은 방법은 바로 올바른 HTTP 상태 코드를 사용하는 것이다.</p><p>HTTP 상태 코드는 <code>200 = 성공</code>, <code>400 = 클라이언트가 요청 잘못함</code>, <code>500 = 서버가 잘못함</code>과 같이 각 상황에 맞는 코드가 표준으로 정해져있으며, 웹 상에서 돌아가는 기본적인 프로그램의 동작이나 프론트엔드, 백엔드 프레임워크들의 설계 또한 이 표준을 기준으로 만들어져 있기 때문에 되도록이면 이 표준을 지켜주는 것이 좋다.</p><p>HTTP 프로토콜을 사용하는 대표적인 프로그램인 웹 브라우저 또한 이러한 상태 코드 표준을 엄격하게 지키는 녀석 중 하나인데, 실제로 브라우저는 서버가 어떤 상태 코드를 응답으로 내려주는지에 따라 이번에 자신이 보낸 요청의 성공/실패 여부를 구분하고, 이를 시각적으로 표현해주기도 한다.</p><center><br>  <img src="/2020/03/15/about-http-status-code/browser-response.png" width="500"><br>  <small>브라우저는 200번대의 상태 코드와 400, 500번대의 상태 코드를 전혀 다르게 인식한다</small><br>  <br><br></center><p>이런 상황에서 서버가 상태 코드는 <code>200</code>인데 응답의 바디로만 에러를 표현한다고 하면, 브라우저는 요청이 성공했다고 생각하지만 실제로는 요청이 실패한, 요상한 상황이 발생하게 된다.</p><p>심지어 서버가 응답의 상태 코드로 <code>301</code>과 같은 코드를 내려준다면, 브라우저는 자동으로 사용자를 다른 페이지로 리다이렉트(Redirect)해버리기 때문에 서버가 제대로 된 상태 코드를 응답에 담아주지 않는다면 브라우저가 예측하지 못한 동작을 일으킬 수도 있다.</p><p>자, 그럼 이제 각 HTTP 상태 코드가 어떤 상태들을 의미하는 것인지 하나씩 살펴보도록 하자. HTTP 상태 코드는 100번대 부터 500번대까지로 이루어져 있으며 꽤나 다양한 상태들을 정의할 수 있지만, 이걸 다 알 필요도 없고 설명하려면 너무 길기도 하니, 필자가 단 한번이라도 사용해보았던 상태 코드들을 기준으로 설명을 진행하려고 한다.</p><h3 id="100번대"><a href="#100번대" class="headerlink" title="100번대"></a>100번대</h3><p>100번대 코드는 프로토콜을 교체해도 된다거나 계속 요청을 보내도 된다거나하는 식의 정보성을 띄고 있는 상태를 의미하지만, 실제로 필자가 어플리케이션을 개발하며 이 상태 코드들을 만나본 사례는 아직 단 한번도 없기 때문에 건너뛰도록 하겠다.</p><h3 id="200번대"><a href="#200번대" class="headerlink" title="200번대"></a>200번대</h3><p>200번대 코드들은 클라이언트가 요청한 작업을 서버가 성공적으로 수행했다는 상태라는 것을 알려주는 코드이다. 200번대 코드들은 브라우저의 콘솔의 네트워크 탭에서도 깔끔한 초록색으로 표시해준다.</p><p>물론 “요청한 작업이 성공”이라는 응답만으로도 클라이언트가 원하는 정보를 모두 만족시킬 수 있긴 하지만, 조금 더 디테일한 상태를 정의해야하는 상황이라면 이 200번대의 상태 코드를 적극적으로 사용하여 클라이언트에게 더 자세한 정보를 알려줄 수도 있다.</p><p><strong>200 OK</strong><br>상태 코드 <code>200</code>은 단순히 작업이 성공했음을 의미한다. 대부분의 경우 클라이언트는 자신이 요청한 작업이 정확히 어떤 작업인지 알고 있기 때문에, 서버에서 “니가 보낸 요청이 성공했어”라는 정보만 알려주면 굳이 그 이상의 디테일한 정보는 알 필요가 필요없다. 그래서 이 상태 코드 하나만으로 모든 API 응답 성공 상태를 퉁치는 경우가 대다수이다.</p><p><strong>201 Created</strong><br>상태 코드 <code>201</code>은 말 그대로 요청이 정상적으로 수행되었고, 그로 인해 리소스가 새롭게 생성되었다는 것을 의미한다. 클라이언트가 서버에게 요청을 보내서 새로운 리소스를 생성하는 상황은 굉장히 흔한데, 그 중 필자가 경험했던 대표적인 사례는 바로 “회원가입”이다. 결국 클라이언트의 회원가입 요청으로 인해 데이터베이스에 새로운 유저의 로우가 생성되었기 때문에, 이런 경우가 <code>201</code> 상태 코드가 아주 잘 들어맞는 케이스라고 볼 수 있다.</p><p><strong>204 No Content</strong><br>상태 코드 <code>204</code>는 요청이 정상적으로 수행되었고, 이 요청과 관련되었던 컨텐츠 또한 더 이상 깔끔하게 존재하지 않음을 의미한다. 이 상태 코드는 클라이언트가 서버에게 요청을 보내서 뭔가를 삭제해야하는 응답으로 사용될 수 있고, 실제로 필자가 경험했던 사례 또한 게시글을 삭제하는 API였다.</p><p>참고로 이때 이 삭제 작업이 <code>Soft Delete</code>냐 <code>Hard Delete</code>냐와는 아무런 상관이 없다. 서버에서 어떤 방식으로 리소스의 삭제를 표현하던 클라이언트가 알아야할 정보는 “이 리소스는 삭제되었고, 더 이상 사용할 수 없다” 뿐이라는 사실을 명심하자.</p><h3 id="300번대"><a href="#300번대" class="headerlink" title="300번대"></a>300번대</h3><p>300번대 코드들은 리다이렉션에 관련된 상태들을 의미한다. 클라이언트가 요청한 리소스가 옮겨졌거나 리소스가 삭제되었거나해서 정상적인 방법으로는 더 이상 해당 리소스에 접근할 수 없고 다른 URL을 통해서 그 리소스에 접근해야하는 경우 서버는 “여기로 가면 니가 찾는 리소스가 있어!”라는 정보를 알려줄 수 있는데, 이때 사용되는 상태 코드들이 바로 300번대 코드들이다.</p><p><strong>301 Moved Permanetly</strong><br>상태 코드 <code>301</code>은 <code>301 Redirect</code>라는 별칭으로 불리기도 할 만큼 리다이렉션을 위한 코드 중 가장 많이 사용되는 녀석이다. 브라우저는 자신의 대한 요청의 응답으로 <code>301</code>을 받으면 HTTP 헤더에 들어있는 <code>Location</code> 필드를 찾아보고, 해당 필드가 존재할 경우 <code>Location</code> 필드에 담긴 URL로 자동으로 리다이렉션한다.</p><figure class="highlight http hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="hljs-number">301</span> Moved Permanetly</span><br><span class="line"><span class="hljs-attribute">Location</span>: https://evan/moved-contents/1234</span><br></pre></td></tr></tbody></table></figure><p>또한 구글과 같은 검색 엔진의 봇들은 특정 페이지에 접근했는데 응답으로 <code>301</code> 상태 코드를 받을 경우 자동으로 페이지 정보를 갱신하기도 하기 때문에, SEO(Search Engine Optimization) 관점에서도 이 상태 코드를 올바르게 사용하는 것은 매우 중요하다.</p><p>이런 리다이렉션 설정은 보통 서버 엔진의 설정 파일 내에서도 할 수 있고, 백엔드 어플리케이션 내에서 직접 할 수도 있다. 일반적인 경우 이 상태코드는 HTTP 프로토콜로 접속한 사용자를 HTTPS 프로토콜을 사용해야만 접근 가능한 포트로 보내버릴 때에도 많이 사용된다.</p><figure class="highlight nginx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">server</span> {</span><br><span class="line">    <span class="hljs-attribute">listen</span>         <span class="hljs-number">80</span>;</span><br><span class="line">    <span class="hljs-attribute">server_name</span>    evan.com;</span><br><span class="line">    <span class="hljs-attribute">return</span>         <span class="hljs-number">301</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">server</span> {</span><br><span class="line">    <span class="hljs-attribute">listen</span>         <span class="hljs-number">443</span> ssl;</span><br><span class="line">    <span class="hljs-attribute">server_name</span>    evan.com;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>이 경우 <code>80</code> 포트로 접속한 사용자를 발견한 Nginx는 HTTPS 프로토콜을 사용해야만 접근할 수 있는 <code>443</code> 포트로 리다이렉트시켜서 해당 프로토콜 사용을 강제할 수 있다.</p><p><strong>304 Not Modified</strong><br>상태 코드 <code>304</code>는 클라이언트가 요청한 리소스가 이전 요청떄와 비교해보았을 때 전혀 달라진 점이 없다는 것을 의미한다. 즉, 말 그대로 Not Modified, 수정되지 않음이다.</p><p>서버가 응답으로 이 상태 코드를 보내주면 클라이언트는 굳이 서버에게 리소스를 재전송받아야할 필요가 없기에 자신이 캐싱해놓았던 리소스를 사용하게되며, 이 과정에서 불필요한 통신 페이로드의 낭비를 줄일 수 있다.</p><p>이 과정에서 클라이언트는 서버로부터 요청된 리소스를 받은 것이 아니라 자신의 캐싱해놓았던 리소스를 사용하는 것이므로 이 또한 캐싱된 리소스로 리다이렉션되었다고 치는 것이다. 그런 이유로 <code>304</code> 상태 코드는 암묵적인 리다이렉션으로 불리기도 한다.</p><p>브라우저 역시 이 응답을 위한 자체 캐싱 기능을 가지고 있으며, 만약 <code>304</code> 상태 코드를 응답으로 받았는데 캐싱된 리소스가 없는 경우에는 빈 화면을 띄우거나 에러 화면이 노출된다. 그러니 이런 상황을 만나면 “브라우저에 Cached Resource가 없는 거 아님?”이라는 킹리적 갓심을 발휘해볼 수 있다.</p><h3 id="400번대"><a href="#400번대" class="headerlink" title="400번대"></a>400번대</h3><p>400번대의 코드들은 클라이언트가 서버에게 보낸 요청이 잘못된 경우를 의미한다. 만약 이 상태 코드를 발견한다면 높은 확률로 프론트엔드 개발자가 예외 처리를 제대로 안 했거나 요청에 이상한 값이 묻은 경우가 많으니, 프론트엔드 개발자의 멱살을 잡도록 하자. <small><strike>(낮은 확률로 백엔드의 잘못인 경우도 있다…)</strike></small></p><p><strong>400 Bad Request</strong><br>상태 코드 <code>400</code>는 가장 많이 만날 수 있는 400번대 코드 중 하나이며, 밑도 끝도 없이 “클라이언트가 요청 잘못 날림”을 의미한다. 이때 뭘 어떻게 잘못 날렸는지는 보통 HTTP 응답 바디에 담아서 알려주는 경우도 있지만, 그렇지 않은 경우에는 백엔드 어플리케이션의 로그를 까봐야하는 슬픈 상황이 펼쳐질 수도 있다.</p><p><strong>401 Unauthorized</strong><br>상태 코드 <code>401</code>는 인증되지 않은 사용자가 인증이 필요한 리소스를 요청하는 경우에 “너 인증 필요함”이라고 알려주는 상태 코드이다. 보통 로그인이 필요한 API를 비로그인 사용자가 호출했을 때 많이 사용된다.</p><p>클라이언트에서는 서버가 <code>401</code>을 응답으로 보내준 경우, 로그인이 필요하다는 것으로 판단하고 로그인 페이지로 사용자를 리다이렉션하기도 한다.</p><p><strong>403 Forbidden</strong><br>상태 코드 <code>403</code>는 클라이언트가 접근이 금지된 리소스를 요청했음을 의미한다. 이 상태 코드는 간혹 <code>401 Unauthorized</code>와 헷갈리고는 하는데, 상태 코드의 의미만 보면 확실히 애매모호하지만, 사실 분명한 한 가지 차이점이 있다.</p><p><code>401</code>은 말 그대로 인증되지 않았다는 것을 의미하며, 인증이 되지 않았다는 것은 백엔드 어플리케이션이 현재 요청한 사용자가 누구인지 알 수가 없다는 것을 의미한다. 즉 이때 서버는 클라이언트에게 “너의 신원을 밝혀!”라고 말하고 있는 것이다.</p><p>그러나 <code>403</code>의 경우, 백엔드 어플리케이션은 현재 리소스를 요청한 사용자가 누구인지 전혀 신경쓰지 않는다. 클라이언트가 현재 자신이 누구인지 밝혔던 밝히지 않았던, 인증이 되었던 안 되었던 간에, 이 리소스를 요청하는 것은 무조건 금지라고 말하고 있는 것이다.</p><p>HTTPS 프로토콜로만 접근해야하는 리소스에 HTTP 프로토콜을 사용하여 접근했을 경우에 서버에서 <code>403</code> 응답을 보내주기도 한다.</p><p><strong>404 Not Found</strong><br>상태 코드 <code>404</code>는 말 그대로 요청한 리소스가 존재하지 않다는 것을 의미한다.</p><p><strong>405 Method Not Allowed</strong><br>상태 코드 <code>405</code>는 현재 리소스에 맞지않는 메소드를 사용했음을 의미한다. 백엔드 프레임워크의 경우 특정 컨트롤러에 해당 메소드를 사용하는 로직이 없다면 자동으로 <code>405</code>를 내려주기도 한다.</p><p><strong>406 No Acceptable</strong><br>상태 코드 <code>406</code>은 <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation#%EC%84%9C%EB%B2%84_%EC%A3%BC%EB%8F%84_%EC%BB%A8%ED%85%90%EC%B8%A0_%ED%98%91%EC%83%81" rel="external nofollow noopener noreferrer" target="_blank">서버 주도 컨텐츠 협상</a>을 진행했음에도 불구하고 알맞은 컨텐츠 타입이 없다는 것을 의미한다.</p><p>사실 클라이언트는 서버에게 리소스를 요청할 때, HTTP 헤더의 <code>Accept</code> 필드를 사용하여 어떤 컨텐츠 타입의 리소스를 원하는지도 함께 이야기해준다. 일반적으로 이 필드를 명시하지않을 경우 브라우저는 자동으로 <code>text/html</code>을 비롯한 몇 가지 타입들을 스스로 정의해서 헤더에 담아주고는 한다.</p><figure class="highlight hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET http://evan.com/</span><br><span class="line"><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml,*/*</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>이런 요청을 받은 서버는 클라이언트가 보낸 요청의 <code>Accept</code> 필드를 보고 앞에서부터 하나씩 찾아가며 요청받은 리소스와 알맞은 컨텐츠 타입이 있는지 하나씩 살펴보게 되고, 이후 알맞은 컨텐츠 타입이 있다면 HTTP 응답 헤더의 <code>Content-Type</code> 필드에 해당 컨텐츠 타입을 명시해주게 된다.</p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></tbody></table></figure><p>이 과정에서 어떤 컨텐츠 타입의 리소스를 응답으로 내려줄 것인지는 전적으로 서버가 결정하게 되므로 이 과정을 “서버 주도 컨텐츠 협상”이라고 하는 것이다. 위의 예시의 경우 클라이언트가 받기를 원했던 컨텐츠 타입 중 첫 번째 우선순위를 가진 <code>text/html</code>를 받아왔지만, 만약 서버에 <code>text/html</code> 타입의 리소스가 존재하지 않는 경우, 서버는 <code>application/xhtml+xml</code>, <code>application/xml</code> 순서로 리소스를 탐색하게 된다.</p><p>만약 앞에 나열된 모든 컨텐츠 타입이 없는 경우 클라이언트가 요청했던 컨텐츠 타입 중 가장 마지막인 <code>*/*</code> 와일드 카드에 걸리기 때문에, 서버는 리소스가 어떤 컨텐츠 타입인지 상관하지 않고 그대로 응답해줄 것이다. 그러나 만약 클라이언트가 요청한 컨텐츠 타입을 모두 탐색했는데도 불구하고 알맞은 리소스가 없을 경우 서버는 <code>406</code> 상태 코드와 함께 “니가 찾는 컨텐츠 타입과 맞는 리소스가 없어”라는 응답을 주는 것이다.</p><p><strong>408 Request Timeout</strong><br>상태 코드 <code>408</code>은 클라이언트와 서버의 연결은 성사되었지만 요청의 본문이 계속 서버에 도착하지 않는 상황을 의미한다.</p><p>HTTP 프로토콜을 사용하여 통신을 할 때는 반드시 클라이언트와 서버 간의 연결을 생성하고, 그 이후에 요청 본문에 해당하는 데이터를 전송하게 되는데, <code>408</code> 상태 코드는 이 과정에서 연결은 제대로 생성되었지만 서버가 아무리 기다려도 클라이언트가 보냈던 요청 본문을 받지 못하는 경우에 발생하게 된다.</p><p><strong>429 Too Many Requests</strong><br>상태 코드 <code>429</code>는 클라이언트가 서버에 너무 요청을 많이 보내는 경우에 발생한다. 너무 많이 보냈다는 것은, 너무 짧은 시간 안에 빠르게 요청을 마구 날려대서 서버가 “워워 진정해”라고 하는 경우일수도 있고, 유료 API를 사용하는 경우에는 현재 금액으로 사용할 수 있는 API 요청 횟수를 초과해서 “돈을 더 내세요”라는 의미로 사용되기도 한다.</p><p>서버에서는 <code>429</code> 상태 코드와 함께 응답 헤더의 <code>Retry-After</code>라는 필드를 사용하여 “이 시간 이후에 재요청해봐”라는 의미를 전달할 수도 있다.</p><h3 id="500번대"><a href="#500번대" class="headerlink" title="500번대"></a>500번대</h3><p>500번대의 코드들은 클라이언트가 아닌 서버에서 뭔가 말썽이 일어난 경우이다. 만약 이 상태 코드를 발견했다면 서버에서 뭔가 박살났다는 의미이므로 다소곳이 백엔드 개발자의 멱살을 잡아보도록 하자. </p><p><strong>500 Internal Server Error</strong><br>상태 코드 <code>500</code>은 백엔드 어플리케이션 내에서 뭔가 알 수 없는 에러가 발생했다는 의미이다. 대부분 제대로 핸들링되지 않은 에러가 발생한 경우가 많으므로, 에러의 원인을 클라이언트에게 알려주지 않는다.<small><strike>(라기 보다 알려줄 수 없는 상태인 경우가 많다)</strike></small></p><p>또한 이렇게 핸들링되지 않은 에러의 원인을 클라이언트에게 고스란히 알려주는 것은 보안 사고가 발생할 가능성이 너무 크므로, <code>500</code> 상태 코드로 에러의 발생 자체만을 알려주는 경우가 대부분이다. 만약 이 상태 코드를 만난다면, 바로 서버 로그를 까보거나 <a href="https://sentry.io/welcome/" rel="external nofollow noopener noreferrer" target="_blank">Sentry</a>나 <a href="https://www.bugsnag.com/" rel="external nofollow noopener noreferrer" target="_blank">Bugsnag</a>과 같은 에러 모니터링 솔루션을 적극 활용하는 것을 추천한다.</p><p><strong>502 Bad Gateway</strong><br>상태 코드 <code>502</code>를 만날 수 있는 가장 흔한 상황은 바로 백엔드 어플리케이션이 죽은 상황이다. 근데 왜 <code>Server Died</code>와 같이 직접적인 메세지가 아니라 <code>Bad Gateway</code>와 같은 메세지를 보내주는 것일까?</p><p>그 이유는 백엔드 아키텍처가 아무리 간단한 구조라고 해도 절대 어플리케이션 1개로만 구성되지 않기 때문이다. 여기서 말하는 게이트웨이는 어플리케이션 간의 추상적인 연결점을 의미하는데, 이 메세지가 의미하듯 백엔드의 아키텍처는 최소 2개 이상의 어플리케이션으로 구성된 경우가 대부분이다.</p><p>일반적인 경우 클라이언트가 보낸 요청은 곧바로 백엔드 어플리케이션에 전달되는 것이 아니다. 사실 백엔드 어플리케이션에 앞단에는 아파치나 Nginx 같은 서버 엔진이나 로드밸런서 같은 친구들이 대신 요청을 받아서 백엔드 어플리케이션으로 전달해주는 경우가 대부분이다.</p><figure class="highlight nginx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">server</span> {</span><br><span class="line">    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-attribute">server_name</span> evan.com;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-attribute">location</span> / {</span><br><span class="line">        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:3000;</span><br><span class="line">        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;</span><br><span class="line">        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">'upgrade'</span>;</span><br><span class="line">        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;</span><br><span class="line">        <span class="hljs-attribute">proxy_cache_bypass</span> <span class="hljs-variable">$http_upgrade</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Nginx를 사용하면 일반적으로 이런 설정을 사용하게 되는데, 이렇게 되면 Nginx는 <code>80</code>번 포트에서 대기하며 HTTP 프로토콜을 사용한 요청을 받아 <code>3000</code>번 포트에서 대기하고 있는 백엔드 어플리케이션에게 전달해주는 역할을 수행하게 된다.</p><p>이런 아키텍처를 사용하는 이유는 보안과 처리 효율 때문이다. 백엔드 어플리케이션 자체가 완전무결한 친구가 아니기 때문에 모든 요청을 안심하고 백엔드 어플리케이션에게 먹여줄 수가 없는 것이다. 그렇다고 누가 사용하는 지도 모르는 클라이언트에서 안전한 요청만 보내줄 것이라는 기대 또한 어불성설이다.</p><p>게다가 뭔가 연산이 필요한 요청이 아닌, 파일을 찾아서 보내주기만 하는 간단한 요청 같은 경우는 굳이 안 그래도 바쁜 백엔드 어플리케이션에게 시킬 필요가 없으므로 이런 서버 엔진이 대신 처리해주기도 한다.</p><p>그래서 백엔드에서는 앞 단에 아예 프록시 서버를 두어서 문지기 역할을 시키는 것이다. 이때 이 프록시 서버와 백엔드 어플리케이션 간의 연결된 추상적인 통로를 “게이트웨이”라고 부르는 것이다. 백엔드 어플리케이션이 죽어버릴 경우 앞 단의 문지기인 프록시 서버는 백엔드 어플리케이션에게 아무런 응답을 받지 못하게 되고, 클라이언트에게 <code>502 Bad Gateway</code>라는 응답을 보내주는 것이다.</p><p><strong>503 Service Unavailable</strong><br>상태 코드 <code>503</code>은 서버가 요청을 처리할 준비가 되지 않았음을 의미한다. 간혹 <code>502 Bad Gateway</code>와 비슷한 느낌으로 사용되기는 하지만, <code>503</code>은 보다 “일시적인 상황”을 의미하는 상태 코드이며, 일반적으로 서버에 부하가 심해서 현재 요청을 핸들링 할 수 있는 여유가 없는 경우에 많이 사용된다.</p><p>AWS Lambda에서는 요청을 처리할 때 컨테이너의 동시 실행 갯수를 초과할 정도의 리소스가 필요하거나 어떤 작업의 처리 시간이 Lambda에 설정된 컨테이너의 최대 수명 시간을 초과했을 경우에 발생하기도 한다.</p><p>이렇듯이 <code>503</code>은 일시적인 상황을 의미하므로 <code>429 Too Many Requests</code>와 동일하게 응답 헤더의 <code>Retry-After</code> 필드를 사용하여 “이 시간 이후에 다시 요청해봐”라는 의미를 클라이언트에게 전달해줄 수 있다.</p><p><strong>504 Gateway Timeout</strong><br>상태 코드 <code>504</code>는 <code>408</code>과 마찬가지로 요청에 대한 타임아웃을 의미한다. 그러나 <code>504</code> 상태 코드는 클라이언트에서 보낸 요청 때문에 타임아웃이 발생하는 것이 아니라 백엔드 아키텍처 내부에서 서버끼리 주고받는 요청에서 발생한다.</p><p>앞서 이야기했듯이 백엔드의 아키텍처는 단순히 백엔드 어플리케이션 하나로만 구성된 것이 아니기 때문에, 클라이언트의 요청이 서버에 닿은 뒤에도 백엔드 어플리케이션끼리의 통신이 발생하게 된다. 만약 프록시 서버 역할을 맡은 Nginx가 백엔드 어플리케이션에 클라이언트의 요청을 전달했는데, 백엔드 어플리케이션이 일정 시간 동안 응답을 하지 않는 경우 Nginx는 클라이언트에게 <code>504 Geteway Timeout</code>을 내려주게 되는 것이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 이번 포스팅에서는 HTTP 상태 외에도 RESTful API에 대한 내용도 함께 이야기하려고 했지만, 다시 한번 분량 조절에 대실패하면서 포스팅을 나누어 작성하게 되었다.<small>(점점 빈도가 잦아진다…)</small></p><p>앞서 이야기했듯이 이런 상태 코드와 같은 요소들은 딱히 안 지킨다고 해서 프로그램에서 에러가 발생하는 것도 아니기 때문에 가볍게 생각하고 넘어가기 쉽상이지만, 보다 명확한 인터페이스를 정의하게되면 프로그램의 작동을 예측하기도 쉬워지고, 프론트엔드와 백엔드 개발자 간의 커뮤니케이션에도 큰 도움이 되기 때문에 되도록이면 표준을 지켜주는 것을 권장한다.</p><p>이상으로 서버의 상태를 알려주는 HTTP 상태 코드 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2020/03/15/about-http-status-code/#disqus_thread</comments>
    </item>
    
    <item>
      <title>나는 프론트엔드를 안다고 말할 수 있을까?</title>
      <link>https://evan-moon.github.io/2020/03/02/what-is-knowing/</link>
      <guid>https://evan-moon.github.io/2020/03/02/what-is-knowing/</guid>
      <pubDate>Sun, 01 Mar 2020 16:32:57 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;이번 포스팅에서는 개발보다는 약간 철학적인 고민 이야기를 해보려고 한다. 사실 이 고민은 필자가 처음 개발을 시작할 때부터 가지고 있던 고민인데, 아직도 해답을 찾지 못했던 질문이기에, 이번 포스팅은 필자의 생각을 제시하는 것이 아니라 질문을 던지는 느낌으로 끄적여볼까한다.&lt;/p&gt;
&lt;p&gt;필자가 개발을 시작하고 나서 6년 동안이나 하고 있는 이 고민은 바로 “안다는 것은 무엇인가?”이다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>이번 포스팅에서는 개발보다는 약간 철학적인 고민 이야기를 해보려고 한다. 사실 이 고민은 필자가 처음 개발을 시작할 때부터 가지고 있던 고민인데, 아직도 해답을 찾지 못했던 질문이기에, 이번 포스팅은 필자의 생각을 제시하는 것이 아니라 질문을 던지는 느낌으로 끄적여볼까한다.</p><p>필자가 개발을 시작하고 나서 6년 동안이나 하고 있는 이 고민은 바로 “안다는 것은 무엇인가?”이다.</p><a id="more"></a><p>사실 필자가 이런 고민을 하게 된 이유는 주변 개발자들의 평가로부터 출발한다. 약 5년 정도 여러 조직에서 프론트엔드 개발자로 일을 하게 되면서 다양한 동료들의 평가나 피드백을 받을 수 있었는데, 그 중 감사하게도 필자를 높게 사주시는 몇몇 분들이 “에반은 프론트엔드를 잘 한다”라는 평가를 해주셨을 때 도저히 자신있게 “아유 그럼요”라는 말을 할 수가 없었기 때문이다.</p><p>그 이유는 단순하게도 필자가 스스로 프론트엔드 개발을 잘 못한다고 생각하기 때문이다. 그리고 다른 사람들이 결정하는 주관적 가치에 대한 신뢰가 없기 때문이기도 하다. 필자는 누가 봐도 인정할 수 있을 정도의 객관적인 가치를 가진 “잘 하는 개발자”가 되고 싶었고, 지금도 바라고 있다.</p><p>물론 사람마다 기준은 다르겠지만, 객관적인 기준의 “잘 한다”라는 것은 어떤 지식에 대해 통달했다는 의미라고 생각한다. 하지만 필자가 프론트엔드 개발에 통달했냐고 묻는다면 대답은 당연히 “No”다. 아직도 모르는 것이 너무 많고, 매일 새로운 문제에 쩔쩔매며 구글신에게 기도드리는 일상을 보내고 있기 때문이다.</p><p>그래서 필자는 6년 동안이나 “진정한 앎이란 무엇인가?”에 대한 고민을 하고 있다.</p><h2 id="나는-잘-하는-개발자”였다”"><a href="#나는-잘-하는-개발자”였다”" class="headerlink" title="나는 잘 하는 개발자”였다”"></a>나는 잘 하는 개발자”였다”</h2><p>사실 필자도 처음부터 이런 고민을 했던 것은 아니였다. 지금 생각해보면 상당히 우습고 거만하지만 처음 개발을 시작할 때는 스스로 실력이 좋고 학습 속도가 굉장히 빠른 편이라고 생각하고 있었다. </p><p>2015년 당시 필자는 사운드 엔지니어로 어떤 연예기획사에서 일을 하고 있었는데, 그때 회사에서 만난 동료와 함께 어떤 제품을 만들고 싶다는 이야기를 나누게 되었다.</p><p>하지만 당시 필자와 그 친구는 웹 개발에 대한 지식이 너무나도 부족했기에 가진 인맥을 총동원해서 이 제품을 함께 만들 친구들을 구하게 되었고, 그게 바로 필자가 지금 6년째 활동하고 있는 토이 프로젝트 팀인 <a href="https://lubycon.github.io/" target="_blank" rel="noopener">루비콘</a>의 시작이다.</p><center><br>  <img src="/2020/03/02/what-is-knowing/lubycon.png"><br>  <br><br></center><p>당시 이 팀에서 필자가 맡게 된 포지션이 바로 프론트엔드 개발자였고, 그때 처음으로 프로그래밍을 독학으로 공부하기 시작하며 제품을 만들기 시작했다. 이후 회사를 그만두고 학교에도 다시 복학을 하며 전공 수업을 통해 부족한 CS(Computer Science) 지식을 보충하면서 실력이 쑥쑥 자라던 시기였다.</p><h3 id="어깨를-으쓱거리던-시절"><a href="#어깨를-으쓱거리던-시절" class="headerlink" title="어깨를 으쓱거리던 시절"></a>어깨를 으쓱거리던 시절</h3><p>2015년 당시 Angular가 조금씩 떠오르고 있긴 했지만 지금의 React나 Vue처럼 대부분의 개발자들이 알 정도로 유명하지는 않았기 때문에 필자는 자연스럽게 jQuery를 사용했었다.</p><p>비록 요즘 jQuery가 퇴물 취급받기는 하지만, 당시에는 CSS 셀렉터와 동일한 문법으로 간단하게 DOM 요소를 선택하고 조작할 수 있는 라이브러리였기 때문에 나름 혁신적인 평가를 받는 라이브러리였고, 필자는 이 친구를 사용하여 뷰를 만드는 것에 대해 생각보다 빠른 속도로 익숙해질 수 있었다. <small>(<code>document.getElementById('foo')</code>가 <code>$('#foo')</code>로 줄어드는 매직…)</small></p><p>당시 루비콘이 서비스에는 웹 상에 <code>obj</code>나 <code>fbx</code> 같은 3D 모델 파일을 업로드하고 자유롭게 이리저리 돌려볼 수 있는 뷰어 기능과 마테리얼이나 배경 스카이박스도 설정할 수 있는 간단한 모델 에디터 기능을 구현해야 했었는데, 필자는 이 과정에서 WebGL이라는 기술을 처음 접하고 사용하게 되었다.</p><center><br>  <img src="/2020/03/02/what-is-knowing/3dmodel.JPG" width="500"><br>  <small>추억의 OBJ Parser 개발하던 시절…</small><br>  <br><br></center><p>사실 WebGL은 일반적인 서비스 개발자들이 크게 사용할 일이 없는 기술인데다가, 자유자재로 사용하려면 컴퓨터 그래픽스, 선형대수학에 대한 기본적인 이해가 필요하기 때문에 러닝커브가 완만한 편은 아니다. 그래서 그런지 다른 개발자들을 만나서 “저 WebGL로 이런 거 만들고 있어요”라고 이야기하면 대부분 “호에? 그거 겁나 어렵지 않아요?”라는 반응을 보였었다.</p><p>이런 반응을 자주 듣다보니 필자의 어깨는 저절로 으쓱거렸고, 점차 “나는 잘 하는 개발자다”라는 건방진 생각을 하게 된 것이다. 그러나 이런 귀여운 생각을 하루 아침에 개박살내는 사건이 있었는데, 이 사건이 지금까지 계속된 필자의 고민의 시작이었다.</p><h3 id="사실-나는-아는-게-없었다"><a href="#사실-나는-아는-게-없었다" class="headerlink" title="사실 나는 아는 게 없었다"></a>사실 나는 아는 게 없었다</h3><p>어느 날 필자는 친구의 소개로 <a href="http://codeforseoul.org/" target="_blank" rel="noopener">Code For Seoul</a>이라는 밋업에 참여하게 되었는데, 막상 가봤더니 필자같이 꼬꼬마 개발자는 별로 없었고 경력이 지긋하신 시니어 개발자 분들이 대다수였다. <small>(분위기는 진짜 가족같은 따뜻한 분위기라서 좋았다)</small></p><p>그렇게 모여 앉아 맛있는 다과를 먹으며 기술에 대한 이야기를 도란도란 나누던 중에 늘 듣던 그 질문이 다시 나오게 되었다.</p><blockquote><p>동욱님은 토이 프로젝트 하신다던데, 어떤 걸 만드시는 거에요?</p></blockquote><p>이 질문을 들은 필자는 평소대로 “WebGL을 사용해서 간단한 웹 에디터랑 뷰어를 만들고 있어요”라고 대답했지만, 그 이후에 그 분들이 보여주신 반응은 평소에 필자가 겪던 상황과 많이 달랐다.</p><p>필자의 대답을 들은 아저씨들은 “호에?” 같은 반응 대신 WebGL이 가지고 있는 퍼포먼스 이슈나 캔버스 렌더링 시 발생하는 메모리 릭과 같은 문제점을 어떻게 해결하고 있는지에 대한 질문을 쏟아내기 시작했지만, 필자는 애초에 그런 이슈들이 있는 줄도 몰랐기 때문에 어벙벙하고 있을 수 밖에 없었다.</p><p>게다가 저 질문들을 던지신 분이 개발자도 아니고 DA(Data Analyst)였다는 점도 충격이었다. 이때 필자는 한 가지 중요한 사실을 깨달았다.</p><center><br>  <img src="/2020/03/02/what-is-knowing/yureka.jpeg"><br>  <small>세상은 넓고 굇수는 많구나…난 우물 안 개구리도 아니고 그냥 올챙이 새끼였구나…</small><br>  <br><br></center><p>그도 그럴 것이 대학교에 다니는 학생들과 실무에서 10년 넘게 경력을 쌓아온 개발자의 짬밥 차이는 어마무시하다. 필자는 학교 안에서는 “꽤 잘하는 학생”이었지만, 학교 밖 정글에서는 그저 한 마리 올챙이에 불과했던 것이다.</p><p>물론 질문을 하셨던 아저씨는 “모를 수도 있지 허허허” 하면서 넘어가셨지만, 필자는 이 상황이 너무 부끄러워서 어디 쥐구멍에라도…아니 쥐구멍을 만들어서라도 숨고 싶었다.</p><p>필자는 러닝커브가 가파른 WebGL이라는 기술을 사용하고 있다는 것만으로 거들먹거렸지만, 사실은 단지 WebGL API를 사용할 수 있었을 뿐이지 이 기술들에 대해서 제대로 알고 있지 않았던 것이다.</p><p>이 사건 이후 벌써 6년이 지났지만, 아직도 필자는 어디 가서 뭘 잘 한다는 이야기를 하지 못하고 있다. 누군가 필자에게 “에반 잘 하잖아요!”라고 하면 “잘 하는 것과 할 줄 아는 것은 다르죠”라고 대답하는 것이 거의 습관이 되어버릴 정도다.</p><p>그리고 이때 처음으로 스스로에게 이런 질문을 던지게 되었다.</p><blockquote><p>내가 뭘 잘 한다는 이야기를 하려면 얼마나 알고 있어야 하는 걸까…?</p></blockquote><h2 id="나는-프론트엔드-개발자인가"><a href="#나는-프론트엔드-개발자인가" class="headerlink" title="나는 프론트엔드 개발자인가?"></a>나는 프론트엔드 개발자인가?</h2><p>이처럼 내가 스스로 잘 알고 있다고 생각했던 것들이 사실은 제대로 모르고 있다는 것임을 깨닿는 경험을 비단 필자만 겪었던 것은 아닐 것이라고 생각한다.</p><p>사실 이 고민의 시작은 “얼마나 알고 있어야 한다는 것일까?”였지만, 이러한 고민을 계속 반복하다보니 결국은 “그래서 안다는 게 뭔데…?”라는 고민까지 오게 된 것이다.</p><p>자, 필자와 함께 앎에 대한 깊은 고민을 해보기 전에 이런 경험이 없으신 분들은 앎이라는 것이 얼마나 모호한 개념인지 공감이 잘 되지 않을 수도 있으니 간단하게 예시를 하나 들어볼까 한다. 필자가 여러분에게 던지고 싶은 질문은 바로 이것이다.</p><blockquote><p>프론트엔드 개발자와 퍼블리셔는 같은 포지션인가?</p></blockquote><p>아마 이 업계에서 일을 하시는 분들이라면 이 포지션들이 굳이 무엇인지 설명하지 않아도 다들 아실 것이라고 생각한다. 그리고 이 포지션들에 대한 의견들도, 이 질문에 대한 대답들도 각자 가지고 있을 것이다.</p><p>물론 필자가 실제로 개발자들을 모아놓고 이런 질문을 던져보지는 않았지만, 채용 사이트에 올라와 있는 포지션들이나 구글링을 통해 읽어본 정보들을 보면 실제로 많은 사람들이 프론트엔드 개발자와 퍼블리셔를 구분하고 있다는 사실을 알아내는 것은 그리 어려운 일이 아니다.</p><p>그럼 여기서 다시 질문을 던져보겠다.</p><blockquote><p>여러분은 이 두 개의 포지션을 구분할 수 있는가?<br>만약 그렇다면 어떠한 기준으로 이 두 개의 포지션을 구분하는가?</p></blockquote><p>이 질문을 던짐으로써 여러분에게 묻고 싶은 것은 말 그대로 프론트엔드 개발자와 퍼블리셔를 구분하는 명확한 기준이 무엇인지에 대한 것이다.</p><p>사실 이 두 포지션은 모두 웹 클라이언트를 만드는 포지션이다. 그러나 방금 이야기했듯이 사람들은 꽤 철저하게 이 두 포지션을 구분하고 있다. 즉, 구분하는 방법을 알고 있다는 것이다.</p><p>일반적으로 프론트엔드 개발자는 웹 브라우저에서 작동하는 클라이언트 프로그램을 작성하는 개발자를 의미한다. HTML을 사용하여 DOM 구조를 정의하고, 자바스크립트를 사용하여 백엔드 시스템과 데이터를 주고 받거나 스탠드얼론 클라이언트 프로그램을 만들기도 하고, 때로는 CSS를 사용하여 사용자에게 유려한 UI/UX를 제공하기도 하는 개발자말이다.</p><p>하지만 이렇게 놓고 보자니 왠지 퍼블리셔와도 비슷한 부분이 많은 것 같다. 아니, 실제 직장에서 하는 일을 생각해보면 비슷한 정도가 아니라 똑같다.</p><p>혹자는 퍼블리셔는 React나 Vue같은 기술을 모르기 때문에 프론트엔드 개발자가 아니라고도 한다. 그렇다면 예전에 jQuery를 사용하여 복잡한 웹 클라이언트를 개발하던 사람들은 퍼블리셔였을까? 하지만 당시 업계에는 분명히 “프론트엔드 개발자”라는 포지션이 인식되고 있었고, 실제로 필자도 그렇게 불렸었다.</p><p>또 어떤 사람은 퍼블리셔는 자바스크립트나 컴퓨터 공학에 대한 기본 지식이 프론트엔드 개발자보다 부족하다고도 한다. 음… 그렇다면 이런 질문을 한번 던져볼 수 있겠다.</p><blockquote><p>퍼블리셔가 자바스크립트를 어디까지 알아야 프론트엔드 개발자라고 할 수 있는가?<br>퍼블리셔가 단순히 CS에 대한 지식을 얻기만 하면 바로 그 사람은 프론트엔드 개발자가 되는 것인가?</p></blockquote><p>이런 질문을 던지면 이제 사람들마다 답이 갈리게 된다. 어떤 사람은 클로저 정도는 알아야한다고 할 수도 있고, 어떤 사람은 클로저는 몰라도 되는데 CORS 정책 위반 정도는 스스로 해결할 수 있어야 한다고 대답할 수도 있다.</p><p>한 발 물러서서 클로저를 능숙하게 사용할 수 있으면 프론트엔드 개발자라고 치자. 그렇다면 클로저의 대략적인 원리를 알고 사용만 할 수 있어도 되는 것인가? 아니면 자바스크립트 엔진 내에서 함수 스코프와 클로저가 어떤 방식으로 생성되는 정도까지는 알아야 되는 것인가? 애매모호하다.</p><p>여러분은 어떤 기준으로 이 두 개의 포지션을 나누고 있었는가? 여러분은 정확히 그 기준을 알고 나누고 있었던 것이 맞는가? 아니면 이 포지션을 나누는 것 자체가 처음부터 의미가 없었던 일인가?</p><h2 id="소피스트가-아닌-소크라테스가-되어야-한다"><a href="#소피스트가-아닌-소크라테스가-되어야-한다" class="headerlink" title="소피스트가 아닌 소크라테스가 되어야 한다"></a>소피스트가 아닌 소크라테스가 되어야 한다</h2><p>만약 이 질문들에 제대로 대답하지 못했다면 사실 여러분은 퍼블리셔와 프론트엔드의 차이를 정확히 알지 못하고 있는 것이다. 아니 어쩌면 사실은 이러한 차이 자체가 존재하지 않았을지도 모르는 일이다.</p><p>필자는 이 예시를 통해 우리가 사실은 잘 알고 있었다고 생각한 것들이 정작 자세히 들여다보려고 하면 정확하게 알고 있는 것이 아닐 수 있다는 이야기를 하고 싶었다.</p><p>마치 우리가 프론트엔드, 퍼블리셔, 풀스택 개발자와 같은 포지션이 명확히 나누어져 있는 것처럼 인식하고 있지만, 막상 이것들이 정확히 어떤 기준으로 나눠지는지 고찰해보면 쉽게 대답하지 못하거나 사람마다 다른 답변이 나오는 등 정확한 기준이 없는 것처럼 말이다.</p><p>사실 우리의 삶이나 우리가 사랑하는 프로그래밍 속에는 이런 문제들이 굉장히 많이 널려있다. 단지 우리가 “알고 있다”라고 생각하기 때문에 고찰해보지 않았을 뿐이다.</p><p>고대 그리스의 소크라테스는 이런 문제에 대해 깊게 고민했던 사람 중 하나인데, 이 아저씨는 진정한 앎이 무엇인지, 현명하다는 것이 무엇인지 알기 위해 당대 똑똑하다고 소문났던 소피스트들을 찾아가 질문을 던지는 짓을 했던 것으로 유명한 아저씨다.</p><h3 id="소피스트는-나름-똑똑한-사람들이었다"><a href="#소피스트는-나름-똑똑한-사람들이었다" class="headerlink" title="소피스트는 나름 똑똑한 사람들이었다"></a>소피스트는 나름 똑똑한 사람들이었다</h3><p>소크라테스가 활동하던 당시의 아테네는 진짜 말 그대로 “말빨”로 먹고 사는 사회였다. 아테네 한 가운데 있는 아고라에서는 늘 토론이 활발하게 일어났으며, 연설을 통해 시민들의 지지를 얻음으로써 정치적 기반 또한 만들 수 있었다.</p><p>게다가 아테네에서는 시민들 간의 소송도 활발하게 이루어졌었는데, 변호사같이 전문가가 대리 변호를 해준다는 개념도 없었기 때문에 법정에서도 스스로 자신의 변호를 해야했다. 결국 지식이 부족하고 말을 잘 못하는 것만으로도 실질적인 손해를 입을 수 있는 사회였던 것이다.</p><center><br>  <img src="/2020/03/02/what-is-knowing/sophist.jpg"><br>  <small>본격 입 털어서 먹고 사는 시대였던 고대 아테네</small><br>  <br><br></center><p>그래서 아테네 시민들은 논쟁에 필요한 지식과 말빨을 중요하게 생각할 수 밖에 없었고, 이때 등장하는 사람들이 바로 아테네의 고액 과외 선생님들인 “소피스트”다.</p><p>소피스트들은 시민들에게 수사학, 변론술, 웅변술 등을 가르쳐 주면서 돈을 받았는데, 남을 가르치려면 당연히 많은 지식을 가지고 있어야 했으니 대부분의 소피스트들은 당대 유명한 웅변가나 철학가들이었다.</p><p>사실 소크라테스도 달변가로 유명했기 때문에 충분히 소피스트로 활동할 수 있는 지식 수준이 되었지만 소크라테스는 자신이 사람들을 가르치는 것이 아니라 그저 사람들이 본래 알고 있던 것을 질문을 통해 끌어내기만 하는 것이라는 신념을 가지고 있었기에 공짜로 사람들을 가르쳐 주었고, 이 때문에 소크라테스는 다른 소피스트들에게 약간 밉상같은 존재였다.</p><p>그러던 어느 날 소크라테스는 델포이 신전에서 우연히 한 가지 신탁을 받게 되는데, 이 신탁이 소크라테스가 앎에 대한 탐구를 본격적으로 시작하게 된 계기가 되었다.</p><h3 id="나는-내가-모른다는-것을-알고-있다"><a href="#나는-내가-모른다는-것을-알고-있다" class="headerlink" title="나는 내가 모른다는 것을 알고 있다"></a>나는 내가 모른다는 것을 알고 있다</h3><p>소크라테스는 델포이 신전에서 “아테네에서 가장 현명한 사람은 소크라테스다”라는 신탁을 받게된다. 이 시대는 아직 신화적인 사고를 하던 시대였기 때문에 신탁은 거의 법이나 마찬가지였지만, 소크라테스는 절대 그럴 리가 없다며 직접 자신보다 현명한 사람을 찾아내겠다는 다짐을 하게 된다.</p><p>이때부터 소크라테스는 당대 용하다는 고액 과외 선생님들인 소피스트들을 찾아다니며 질문을 하며 그 사람이 얼마나 현명한 사람인지 알아보기 시작했는데, 소크라테스가 소피스트들에게 했던 질문의 흐름을 앞서 이야기했던 퍼블리셔와 프론트엔드에 대한 주제에 대입해보면 이런 느낌이다.</p><blockquote><p><strong>Q</strong>: 프론트엔드 개발자는 어떤 사람인가?<br><strong>A</strong>: 웹 클라이언트를 만드는데 필요한 지식을 알고, 웹 클라이언트를 실제로 구현할 수 있는 사람입니다.</p><p><strong>Q</strong>: 그럼 퍼블리셔도 프론트엔드 개발자 아닌가?<br><strong>A</strong>: 아닙니다.</p><p><strong>Q</strong>: 그렇다면 프론트엔드와 퍼블리셔의 차이는 무엇인가?<br><strong>A</strong>: 퍼블리셔는 프론트엔드보다 컴퓨터 공학 지식이 적다고 생각합니다.</p><p><strong>Q</strong>: 그럼 퍼블리셔가 컴퓨터 공학 지식을 공부하기만 하면 프론트엔드 개발자가 되는 것인가?<br><strong>A</strong>: 프론트엔드 개발자로 이직까지 해야 프론트엔드 개발자라고 할 수 있을 것 같습니다.</p><p><strong>Q</strong>: 그렇다면 회사에서 정해주는 포지션이 영향을 준다는 것인가?<br><strong>A</strong>: …그런 것 같습니다.</p><p><strong>Q</strong>: 그럼 유명한 IT기업에서 일하던 프론트엔드 개발자가 웹 에이전시의 퍼블리셔로 이직하면 그 사람은 프론트엔드 개발자인가 퍼블리셔인가?<br><strong>A</strong>: …. (모순 발생)</p></blockquote><p>이렇게 소크라테스는 소피스트들에게 원론적인 질문들을 던지고 그 사람이 답변을 하면 다시 의문이 드는 부분에 대해서 질문을 던지는 식의 대화법을 사용했는데, 이렇게 소크라테스의 질문을 몇 번 받은 소피스트들은 어느 순간 답변이 막히게 되며 자신이 알고 있는 것이 사실 오류가 있는 개념임을 깨닿고 당황하거나 화를 내었다고 한다. </p><center><br>  <img src="/2020/03/02/what-is-knowing/ship.jpg" width="500"><br>  <small>이렇게 배가 좌초된 것처럼 모순과 난제에 빠진 상태를 아포리아라고 한다</small><br>  <br><br></center><p>결국 이렇게 소피스트들을 찾아다니며 질문을 해도 자신의 질문에 제대로 끝까지 대답하는 사람이 없자, 소크라테스는 “이들이 제대로 아는 것은 없다”라는 결론을 내리게 된다.</p><p>여러분은 어떤가? 소크라테스가 여러분에게 프로그래밍에 대한 질문이나 프론트엔드와 퍼블리셔를 구분하는 기준에 대한 질문을 던지면 끝까지 대답할 수 있을까?</p><p>만약 대답할 수 있다면, 여러분은 적어도 그 지식에 대해서는 소크라테스를 이긴 사람이다. 하지만 만약 소크라테스가 필자에게 저런 질문을 건네온다면 필자는 열심히 대답하다가 결국 아포리아 상태에 빠지고 말 것 같다는 생각이 든다.</p><p>그리고 이러한 질문법은 비단 소피스트들 뿐 아니라 소크라테스가 스스로에게 던지는 질문이기도 했다. 결국 소크라테스는 이 짓을 계속 반복하다가 한 가지를 깨닿게 된다.</p><blockquote><p>내가 알고 있는 단 한 가지는 내가 아무것도 모르고 있다는 사실이다</p></blockquote><p>이 말은 소크라테스 자신에게 하는 말이기도 했으며, 다른 소피스트들에게 하는 말이기도 했다. 너나 나나 제대로 아는 것은 하나도 없지만, 나는 적어도 “내가 모른다는 것”은 알고 있다는 것이다.</p><p>근데 소크라테스의 이런 결론이 딱히 틀린 것도 아닌게, 자신이 모른다는 것을 인정해야 더 깊은 진리를 탐구할 수도 있기 때문이다. 애초에 “난 알고 있다”라고 생각하고 있는 사람이 그 주제에 대해서 더 깊은 탐구를 하지는 않을테니 말이다.</p><p>당연히 소크라테스의 이런 태도는 소피스트들에게 곱게 보일리가 없었고 결국 소크라테스는 “아테네의 전통을 해치고 젊은이들을 타락시켰다”라는 죄목으로 기소되었다.</p><p>뭐 사실 법원에서도 눈치 잘 보고 입만 잘 털면 살아남을 수 있었지만 소크라테스가 스스로의 신념을 끝까지 굽히지 않았고, 배심원들을 자극하는 변론을 하며 자충수를 두는 바람에 사형당해버렸다. <small>(다른 도시국가로 망명 신청도 할 수 있었는데, 그냥 독약을 마신 상남자…)</small></p><center><br>  <img src="/2020/03/02/what-is-knowing/socrates.jpg"><br>  <small>결국 이 아저씨는 독약을 먹게 된다</small><br>  <br><br></center><p>이렇게 똑똑했던 아저씨도 결국 그 긴 고민 끝에 내린 결론이 “나는 아무것도 모른다”라니, 약간은 허무하기 그지 없는 결론이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이렇게 긴 이야기를 풀어내다보니 필자의 질문은 “앎이란 무엇인가?”에서 “우리가 알고 있는 것이 정말로 알고 있다는 것인가?”로 바뀌게 되었을 뿐 결국 어떠한 답을 찾아내지는 못했다.</p><p>뭐 4대 성인으로 불리는 소크라테스 아저씨도 결국 저런 허무한 결론을 낸 질문이니 필자가 이 질문에 대해 쉬이 대답하지는 못할 것 같다는 생각도 들지만, 필자가 궁극적으로 목표하는 “객관적인 기준으로 잘하는 개발자”가 되기 위해서는 반드시 이 질문에 대한 나름의 해답을 정의해야하기에, 앞으로도 이 고민은 계속 될 것이다.</p><p>애초에 이 포스팅은 답변을 제시하기 위한 포스팅이 아니다. 이 포스팅을 쓰기 전에도 필자는 6년 정도 이런 고민을 계속 해왔지만 점점 질문에 질문이 꼬리를 물고 깊어져 갈 뿐, 어떠한 해답의 실마리 조차 잡지 못했기 때문이다.</p><p>물론 필자도 늘 바쁘게 일하고 공부하다보면 이런 철학적인 고민은 쉽사리 잊혀지기 마련이라는 것은 알고 있다. 이런 것보다 당장 내일 출근해서 신경써야하는 것들이 많다는 것도 알고 있다. <small>(필자도 일 오지게 밀려있다…)</small></p><p>그러나 가끔은 프로그래밍에 대한 직접적인 고민보다 이렇게 한 걸음 물러선 시선에서 바라보는 고민이 오히려 더 도움이 될 때도 있는 것 같기에 여러분도 필자와 같은 고민을 한번 쯤은 해봤으면 하는 마음으로 필자의 고민을 공유하려고 한다.</p><p>이상으로 “나는 프론트엔드를 안다고 말할 수 있을까?” 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2020/03/02/what-is-knowing/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Question Driven Thinking - 스스로 질문하며 학습하기</title>
      <link>https://evan-moon.github.io/2020/02/11/question-driven-thinking/</link>
      <guid>https://evan-moon.github.io/2020/02/11/question-driven-thinking/</guid>
      <pubDate>Mon, 10 Feb 2020 16:16:13 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;처음 프로그래밍을 배우던 시절을 떠올려보자. 아닌 사람도 있겠지만 대부분의 사람들은 처음 프로그래밍을 배울 때 학교나 학원에서 누군가에게 가르침을 받으며 공부했을 것이다. 프로그래밍을 처음 접하는 입문자에게 독학의 길은 너무 멀고 험난하기 때문이다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>처음 프로그래밍을 배우던 시절을 떠올려보자. 아닌 사람도 있겠지만 대부분의 사람들은 처음 프로그래밍을 배울 때 학교나 학원에서 누군가에게 가르침을 받으며 공부했을 것이다. 프로그래밍을 처음 접하는 입문자에게 독학의 길은 너무 멀고 험난하기 때문이다.</p><a id="more"></a><p>그러나 입문자 시절이 끝나고 개발자로써 취업도 하고나면 이야기는 달라진다. 이제는 나를 가르쳐줄 선생님이 없기 때문에 스스로 나의 실력을 키워나가야하는 상황이 되어버린 것이다. 이런 환경 속에 갑자기 놓인 사람들은 다시 프로그래밍을 처음 시작할 때처럼 막막한 기분이 든다.</p><center><br>  <img src="/2020/02/11/question-driven-thinking/unnamed.png" width="500"><br>  <br><br></center><p>주변 사람을 붙잡고 물어보기는 하지만 그것도 하루이틀이지, 비슷한 수준의 질문을 계속 하게된다면 돌아오는 것은 <code>RTFM(Read the fucking menual)</code>이나 구글링을 해보라는 냉랭한 대답 뿐일 것이다. 그렇다고 구글링을 하자니 어떤 키워드로 검색을 해야하는지 조차 막막하다.</p><p>이런 경험은 개발자라면 누구든지 겪어보았을 것이라고 생각한다. 공부해야할 것은 산더미이지만 뭐부터 공부해야할지, 어떻게 공부해야할지도 감이 안 오는 상황말이다. 누군가 친절하게 커리큘럼을 짜주는 것도, 알려주는 것도 아니다. 결국 나 스스로 정보를 찾아내고 골라내어 씹어먹어야하는 것이다.</p><h2 id="현실부터-한번-보자"><a href="#현실부터-한번-보자" class="headerlink" title="현실부터 한번 보자"></a>현실부터 한번 보자</h2><p>본격적인 이야기에 들어가기에 앞서 도대체 이 “막막한 기분”이 정확히 뭔지 한 번 짚고 넘어가자. 이 기분을 만드는 것은 그렇게 어렵지 않을 것 같다. 필자는 프론트엔드 개발자이니, 간단한 웹 프론트엔드 어플리케이션을 만들어야하는 상황을 한번 가정해보도록 하겠다.</p><p>우선 뷰와 모델을 연동하여 UI를 그려줄 라이브러리나 프레임워크를 선택해야한다. 이 역할을 하는 도구 중 유명한 것은 <code>React</code>, <code>Vue</code>, <code>Angular</code> 정도가 있겠다. 일반적으로는 생태계가 가장 두터운 리액트를 주로 선택하지만, 사실 뭘로 만들든 원하는 기능을 구현하는데는 아무런 문제가 없다.</p><p>그리고 최근의 웹 어플리케이션에서는 클라이언트에게 복잡한 상태 관리 수준을 요구하기 때문에 상태를 수월하게 관리할 수 있는 라이브러리도 선택해야한다. 이 쪽 계열에서 유명한건 <code>Redux</code>, <code>Mobx</code> 정도가 있으니 입맛대로 골라보자. 만약 UI프레임워크로 <code>Vue</code>를 선택했다면 그냥 <code>Vuex</code>를 사용하는 것이 정신 건강에 좋다.</p><p>그리고 복잡한 객체 상태를 관리하려면 불변 상태를 유지하게 도와주는 라이브러리인 <code>ImmutableJS</code>나 <code>Immer</code>도 사용하면 좋을 것 같다.</p><p>만약 상태 관리 라이브러리로 <code>Redux</code>를 사용한다면 비동기 처리를 도와주는 <code>redux-thunk</code>, <code>redux-saga</code> 등의 미들웨어도 선택해야한다. 아니면 최근 많이 사용하는 <code>RxJS</code>는 어떨까? <code>Redux</code>와 편하게 함께 사용할 수 있도록 <code>redux-observable</code>과 같은 미들웨어로도 제공하고 있다.</p><p>패키지 관리자는 <code>npm</code>이나 <code>yarn</code> 중에 선택해서 사용하면 되고, 유닛 테스트 도구는 <code>Mocha</code>, <code>Jest</code> 중에 고르면 될 것 같다. <code>eslint</code>의 룰은 <code>airbnb</code>나 <code>standard</code> 중에 입맛에 맞는 걸로 고르고 적당히 커스터마이징해서 쓰자.</p><p>음, 그리고 생각해보니 자바스크립트보다는 정적 타이핑 언어인 타입스크립트를 사용하는 것도 나쁘지 않을 것 같다. 이왕 만드는 거 조금 더 단단하게 만들면 좋으니까. 그렇다면 위에서 이야기했던 라이브러리들이 타입스크립트를 지원하는지 알아봐야한다.</p><center><br>  <img src="/2020/02/11/question-driven-thinking/what.jpg" width="400"><br>  <small>간단한 어플리케이션 만든다매…?</small><br>  <br><br></center><p>방금 이야기한 수많은 도구들은 필자가 잘난척하려고 줄줄 읊어댄 것이 아니라, 실제로 회사에서 일을 하거나 사이드 프로젝트를 진행할 때 프론트엔드 개발자들이 매번 고민하는 것들이다. 물론 저 도구들은 전부 사용해도 되고 안해도 되는 도구들이지만, 사용 방법만 익힌다면 생산성이 훨씬 높아지기 때문에 대부분의 프론트엔드 개발자들은 저 정도는 차려놓고 사용한다.</p><p>그리고 사실 저런 도구들을 제대로 사용하기 위해서는 클로저나 이벤트 루프와 같은 자바스크립트의 디테일한 개념, 가상돔, 데이터 바인딩, MVVM 패턴, Flux 패턴, 함수형 프로그래밍 등에 대한 지식도 필요하다. </p><p>최근 들어 프론트엔드 분야에 유독 새로운 게 많이 나오기는 하지만, 다른 직군의 개발자들도 알아야하는 지식의 양은 대부분 비슷비슷하다. 다만 각 직군에 맞게 특화되어 있을 뿐이다.</p><p>사실 이 길고 긴 이야기를 통해 필자가 하고 싶은 말은 딱 이거 하나다.</p><blockquote><p>“이 많은 걸 친절하게 다 알려줄 수 있는 사람은 없다.”</p></blockquote><h2 id="결국-정보는-스스로-찾아야한다"><a href="#결국-정보는-스스로-찾아야한다" class="headerlink" title="결국 정보는 스스로 찾아야한다"></a>결국 정보는 스스로 찾아야한다</h2><p>저렇게 많은 것을 다 알려줄 수 있는 사람이 과연 존재할까? 개인적으로 필자는 없을 것이라고 본다.</p><p>만약 수학처럼 100년 전에 누군가 만든 공식이 100년 후에도 그대로 사용되는 학문이라면 누군가 체계적인 커리큘럼을 만들어서 저런 것들을 모두 가르쳐줄 수 있을지 모르지만, 필자가 이야기했던 저 도구들 중 많은 수는 당장 내년이 되면 사라질 수도 있는 녀석들이다. 즉, 지식의 생명이 굉장히 짧다는 것이다.</p><p>그리고 같은 역할을 하는 저 많은 도구들 중에서 뭐가 더 좋고 나쁘고를 가리기도 애매하다. 당장 근처에 있는 프론트엔드 개발자에게 <code>React가 좋아? Vue가 좋아?</code>라고 물어본다면 뭐라고 대답할까? 아마 둘 다 좋다거나 둘 다 구리다거나, 아니면 자기 맘에 드는 것 하나를 골라서 이야기할 것이다.</p><p>그런 이유들 때문에 프로그래밍은 특정한 커리큘럼을 만들기가 꽤나 어려운 분야이다. 물론 처음 프로그래밍을 배우는 단계에서는 커리큘럼을 어느 정도 만들어줄 수 있지만, 나중에 가면 사실 커리큘럼이라는 것 자체가 별로 의미가 없다.</p><p>기껏 학원에서 3개월동안 열심히 Vue를 학습했는데 막상 이직한 직장은 React를 쓰고 있다면 어떻게 할 것인가? 그렇다고 회사에 양해를 구하고 학원에 가서 React를 3개월 동안 다시 배울 수는 없는 노릇이다.</p><p>결국 개발자들은 속해있는 조직의 상황이나 배우고 싶은 기술 등에 맞춰서 자신에게 필요한 정보들을 스스로 찾아서 학습해나가는데 익숙해질 수 밖에 없고, 그래서 개발자들에게 뭔 질문만 했다하면 구글링을 해보라는 대답이 돌아오는 것이다.</p><p>하지만 구글이나 스택오버플로우에서 정보를 스스로 찾아 주워먹는 식의 능동적인 학습을 하기 위해서는 적절한 키워드를 선택하여 구글링을 할 수 있는 능력과 좋은 정보와 나쁜 정보를 가릴 수 있는 식별력까지 겸비해야 올바른 정보를 주워먹어가며 학습할 수 있기 때문에 생각보다 쉽지 않다. <small><strike>(영어도 잘 해야 한다)</strike></small> 게다가 이건 누가 알려줄 수 있는 것도 아니라서 스스로 연습하고 연구해야한다.</p><p>하지만 당장 구글에 뭘 검색해야할지, 뭘 공부해야 좋을 지도 모르겠는데 무작정 구글링을 하라고 할 수는 없는 법이니 필자가 자주 사용하는 아주 간단한 방법을 한번 공유해보려고 한다.</p><h2 id="모든-키워드는-연결되어-있다"><a href="#모든-키워드는-연결되어-있다" class="headerlink" title="모든 키워드는 연결되어 있다"></a>모든 키워드는 연결되어 있다</h2><p>우리는 보통 공부를 할 때 “암기”를 한다. 암기를 통한 학습은 좁은 폭의 정보를 빠르게 습득할 수 있게 해주기 때문에 늘 새로운 트렌드에 쫓기며 사는 개발자들에게는 꽤나 잘 맞는 학습 방법이라고 할 수 있다.</p><p>뭐, 순수 함수의 특징 4가지를 외운다던가, TCP나 UDP의 특징과 장단점을 외운다던가 하는 것들 말이다. 또는 새로운 라이브러리나 프레임워크가 나오면 공식 문서를 한번 쭉 흝어보고 코딩을 해보며 연습하는 것도 일종의 암기라고 할 수 있다.</p><p>그러나 이런 단순 암기를 통한 학습 방법은 빠르다는 장점도 있는 반면, 학습 키워드의 습득이 단편적이라는 단점도 가지고 있다. 키워드의 습득이 단편적이라는 말은 어떠한 키워드를 습득했을 때 자연스럽게 다음 레벨의 키워드로 연결되기가 어렵다는 말이다. 아마 이렇게 공부를 하다보면 어느 순간 이런 생각이 들 때가 있었을 것이다.</p><center><br>  <img src="/2020/02/11/question-driven-thinking/budda.jpg" width="300"><br>  <small>좋아… 여기까진 완벽해… 근데 다음엔 뭘 공부해야하지…?</small><br>  <br><br></center><p>분명히 머리로는 내가 공부한 것들이 아직 한참 모자라다는 것을 알고는 있지만 그 다음에 뭘 공부해야하는지도 모르겠고, 그렇다고 전혀 다른 키워드를 찾아서 공부하기에는 괜히 여기저기 찔러보기만 하는 것 같은 기분 말이다. 이는 단순한 암기를 통해서 학습한 지식들이 서로 “연결”되지 않았기 때문에 나타나는 현상이다.</p><p>사실 지식이라는 것은 일종의 키워드 마인드맵이라고 할 수 있으며, 마인드맵 안에 있는 모든 키워드는 밀접하게 관련이 있는 다른 키워드들과 연결되어 있다. 결국 능동적인 학습은 이렇게 연결된 키워드를 찾아나서는 탐구 과정의 연속이라고 할 수 있다.</p><center><br>  <img src="/2020/02/11/question-driven-thinking/mindmap.jpg" width="350"><br>  <br><br></center><p>단순 암기를 통한 학습은 이 마인드맵의 키워드 하나하나를 직접 찾아내어 학습하는 것이다. 그러나 저 많은 키워드들을 스스로 전부 찾아내어 공부한다는 건 꽤나 어려운 일이다. 그래서 우리는 하나의 키워드를 공부하며 그 속에서 자연스럽게 다음 키워드를 찾아낼 수 있는 방법을 생각해야한다.</p><p>그리고 이렇게 하나의 키워드에 대해서 학습하며 다음 키워드를 찾는 행위를 반복하다보면 단순 암기를 통해 저장했던 파편적인 정보들 간의 연결고리도 자연스럽게 생성되기 때문에 더 기억이 오래가는 효과도 누릴 수 있으므로 일석이조의 효과를 누릴 수도 있다.</p><p>그렇다면 어떤 과정을 통해 연결된 키워드를 찾아낼 수 있을까?</p><h2 id="스스로에게-질문을-던져보자"><a href="#스스로에게-질문을-던져보자" class="headerlink" title="스스로에게 질문을 던져보자"></a>스스로에게 질문을 던져보자</h2><p>우리가 어떤 주제에 대해서 공부하면서 연관된 키워드를 찾아내지 못하는 이유 중 하나는 그저 암기를 통해 정리되어있는 지식을 받아들이기만 한다는 것에 있다. “A는 B다”라고 외우기만 한다면 그 속에 숨어있는 다른 키워드들을 찾을 기회조차 놓치게 되어버리는 것이다.</p><p>필자가 제시하는 방법은 바로 “질문”이다. 단, 이 질문은 남들에게 질문하는 것이 아니라 스스로에게 하는 질문이다. <small>(남들에게 질문하는 것은 가장 최후의 보루로 남겨놓도록 하자)</small></p><p>스스로에게 “왜 이렇게 되는데?”, “어떻게 이게 가능한데?”와 같은 질문을 던지며 공부하고 있는 키워드에 대해서 자신이 모르는 것이 무엇인지 하나씩 찾아가는 것이다. 그리고 자신이 모르는 것이 무엇인지 알았다면 이제 구글링을 통해 그 질문에 대한 답을 찾아보면 된다. 이렇게 몇 번 반복하다보면 아마 그 질문에 대한 답을 쥐고 있는 새로운 키워드를 찾아낼 수 있을 것이다.</p><p>리액트 훅의 <code>useState</code>를 한번 예로 들어보겠다. 리액트의 useState는 함수형 컴포넌트에서 상태를 저장하고 기억하고 싶을 때 사용하는 훅이다.</p><figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> (</span><br><span class="line">    <></span><br><span class="line">      <div>{count}<<span class="hljs-regexp">/div></span></span><br><span class="line"><span class="hljs-regexp">      <button onClick={() => setCount(count++)}>+</</span>button></span><br><span class="line">    <<span class="hljs-regexp">/></span></span><br><span class="line"><span class="hljs-regexp">  );</span></span><br><span class="line"><span class="hljs-regexp">}</span></span><br></pre></td></tr></tbody></table></figure><p>사실 useState라는 훅을 사용하면 함수형 컴포넌트 내에서 상태를 관리할 수 있다는 사실만 알고 있어도 코딩을 하고 어플리케이션을 만드는 데에는 아무 지장이 없고, 시간에 쫓기는 학습을 해야하는 상황이라면 이쯤에서 학습을 접고 코딩을 해도 된다. 그러나 단지 useState 훅을 사용할 수 있다는 사실만으로 만족할 수 없다면 이쯤에서 새로운 질문을 하나 던져봐야한다.</p><p>필자는 처음 리액트의 함수형 컴포넌트를 접하고 이 훅을 알게 되었을 때 이런 원초적인 궁금증이 들었었다.</p><blockquote><p>useState 훅은 어떻게 상태를 저장할 수 있는걸까?</p></blockquote><p>사실 이런 질문은 그렇게 대단한 질문도 아니다. “useState 훅을 사용하면 함수형 컴포넌트 안에서도 상태를 저장할 수 있다”는 단순한 암기에서 조금만 더 호기심을 가지고 앞으로 나아갔을 뿐이다.</p><p>물론 보자마자 useState 훅의 원리를 바로 알 수 있을 정도로 자바스크립트에 대한 지식이 많은 분이라면 질문의 난이도도 더 높았을테지만, 당시 필자는 이 훅의 원리에 대해 전혀 감을 잡지 못했었다.</p><p>자, 어쨌든 이렇게 스스로 질문을 했으니 이제 답을 찾아야한다. 당연히 이 질문에 답해줄 수 있는 선생님은 내 곁에 없으니 갓 구글에 이 질문을 그대로 검색해보도록 하자.</p><p>필자가 선택한 검색 키워드는 <code>useState 원리</code>이다. 검색 키워드를 바꿔서 재시도한다고 과금되는 것도 아니니 그냥 손 가는대로 마음 가는대로 때려넣어보자. 사실 구글링에 무슨 대단한 스킬이 필요한 것도 아니다.</p><center><br>  <img src="/2020/02/11/question-driven-thinking/googled.png" width="500"><br>  <small>역시 구글신께서는 모든 걸 알고 계신다</small><br>  <br><br></center><p>구글에 해당 키워드를 검색해보니 이미 다른 분들이 리액트 훅에 대해 자세히 정리해놓은 포스팅들이 보인다. 만약 한글로 구글링을 진행했는데 원하는 자료가 나오지 않는다면 <code>Principle of useState</code>와 같은 영어 키워드로 다시 한번 검색해보면 대부분 원하는 자료를 찾아낼 수 있다. 사실 한글로 검색했을 때와 영어로 검색했을 때 찾을 수 있는 정보량의 차이는 어마무시하기 때문에 되도록이면 영어로 검색하는 습관을 들이는 것이 좋기는 하다.</p><p>사실 리액트의 <code>useState</code> 훅은 자바스크립트 클로저의 성질을 이용하여 함수 내부에 상태를 저장할 수 있도록 만든 것이기 때문에 조금만 검색해보면 여러분은 <code>클로저(Closure)</code>라는 키워드를 얻어낼 수 있다.</p><p>이렇게 클로저라는 새 키워드를 얻었을 때 여러분이 클로저가 무엇인지 안다면 <code>useState</code> 훅을 직접 만들어 보며 공부해봐도 좋고, 아니면 다른 질문을 던져서 다시 새로운 키워드를 찾으면 된다.</p><p>만약 클로저가 무엇인지 잘 모른다면 <code>자바스크립트 클로저</code>와 같은 검색 키워드로 다시 구글링해서 해당 내용에 대한 학습을 진행하면 된다. 아마 클로저를 공부하다보면 또 다른 질문을 던져볼 수 있을 것이고 그로 인해 더 깊숙한 곳에 있는 새로운 키워드를 또 찾을 수 있을 것이다.</p><p>이 글을 읽으신 독자분들께서는 “당장 공부하고 사용하기만 해도 벅찬데 더 어려운 원리를 언제 다 이해해?”라고 생각할 수도 있겠다. 그러나 “키워드를 이해할 수 있는 능력”과 “키워드를 찾을 수 있는 능력”은 엄연히 다르다는 것을 알아야한다.</p><p>애초에 키워드를 이해할 수 있는 능력은 사실 몇 개의 팁만으로 단기간 안에 키울 수 있는 능력이 아니다. 어떤 분야의 키워드를 빠르게 이해할 수 있는 능력은 일정 수준 이상의 해당 분야 지식을 기반으로 하기 때문이다.</p><p>하지만 “키워드를 찾을 수 있는 능력”은 다르다. 딱히 일정 수준 이상의 지식이 필요한 것도 아니고, 그저 구글에 검색어를 칠 수 있는 손가락만 있으면 된다. 그리고 만약 새로운 키워드를 획득했는데 이해하기가 너무 어렵다고 느껴진다면 굳이 바로 학습하지 않아도 된다.</p><p>키워드를 획득한다는 것이 가지는 가장 작은 의미는, 적어도 “세상에 이런 것도 존재하는구나”라는 정도의 지식은 얻을 수 있다는 것이다. 이런 키워드가 존재한다는 것을 알고 있다면 나중에 자신이 학습한 지식의 깊이가 더 깊어지고나서 그 키워드를 다시 꺼내보면 되는 것이고, 그렇게 학습을 다시 진행하며 다음 키워드를 또 찾아내는 과정을 반복하면 된다. <small>(개발자로 일하다 보면 분명히 언젠가 그 키워드에 대해서 학습해야할 날이 온다)</small></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 제목을 Question Driven Thinking이라고 거창하게 쓰기는 했지만, 앞서 말했듯이 이렇게 질문을 통해 지식을 습득하는 학습 방법은 필자가 처음 이야기하는 것이 아니라 꽤나 유명한 학습 방법 중 하나이다.</p><p>이렇게 질문을 통해 조금씩 답을 찾아나가는 방법은 고대 그리스 시절부터 계속 해서 사용해오던 굉장히 유명한 교수법 중 하나이며, 스스로에게 질문을 함으로써 자신이 모르고 있는 것을 계속 해서 찾아나가고 해답을 찾아가는 과정은 과거 소크라테스 형님도 많이 사용하던 방법이었다.</p><center><br>  <img src="/2020/02/11/question-driven-thinking/socrates.jpg" width="500"><br>  <small>내가 아무것도 모른다는 것을 안다는 것이 제일 현명한 것이라는 띵언을 남기신 형님</small><br>  <br><br></center><p>사실 우리는 어릴 때부터 교과서에 나오는 수학 공식, 영어 단어, 시험문제 유형 같은 것들을 달달 외우는 학습을 거의 10년 동안 받아왔기 때문에 단순 암기하는 학습에 더 익숙하다. 오히려 학교에서는 질문을 하면 괜히 수업시간 더 길어지게 만드는 이상한 놈 취급을 받기 일쑤였던 것 같다. <small>(나대는 놈이라는 칭호도 함께 얻을 수 있다)</small></p><p>하지만 단순히 “왜?”라는 질문을 던짐으로써 “A는 B다”라고 기억되던 평면적인 지식을 “A는 ~기 때문에 B다”와 같은 심층적인 지식으로 바꿀 수 있기 때문에 우리는 이제 질문에 익숙해져야한다. 질문을 던지며 내가 모르는 것이 무엇인지 찾아내고 그 질문에 대한 해답을 찾아내어 다시 대답하는 과정을 반복하며 키워드를 계속 만들어나가는 것이다.</p><p>그리고 스스로에게 질문을 하게 되면 생각에 생각이 계속 해서 꼬리를 물며 깊어질 수 있기 때문에, 공부할 때 뿐만 아니라 생각을 정리할 때도 좋은 방법이므로 한번쯤 도전해보는 것을 권한다.</p><p>이상으로 Question Driven Thinking 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2020/02/11/question-driven-thinking/#disqus_thread</comments>
    </item>
    
    <item>
      <title>어떻게 하면 안전하게 함수를 합성할 수 있을까?</title>
      <link>https://evan-moon.github.io/2020/01/27/safety-function-composition/</link>
      <guid>https://evan-moon.github.io/2020/01/27/safety-function-composition/</guid>
      <pubDate>Mon, 27 Jan 2020 08:07:29 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;함수형 프로그래밍에서 코드를 작성한다는 것은 프로그램에서 수행해야하는 여러가지 행위들을 함수로 표현하고, 또 그 함수들을 요리조리 잘 합성해가며 거대한 프로그램을 만들어나가는 패러다임이다.&lt;/p&gt;
&lt;p&gt;결국 함수형 프로그래밍에서 함수를 합성하는 행위라는 것은 이 패러다임의 근간이 되는 개념이기 때문에 굉장히 큰 의미를 가질 수 밖에 없는데, 문제는 이렇게 함수를 합성하는 과정에서 크고 작은 현실적인 문제들이 빵빵 터진다는 것이다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>함수형 프로그래밍에서 코드를 작성한다는 것은 프로그램에서 수행해야하는 여러가지 행위들을 함수로 표현하고, 또 그 함수들을 요리조리 잘 합성해가며 거대한 프로그램을 만들어나가는 패러다임이다.</p><p>결국 함수형 프로그래밍에서 함수를 합성하는 행위라는 것은 이 패러다임의 근간이 되는 개념이기 때문에 굉장히 큰 의미를 가질 수 밖에 없는데, 문제는 이렇게 함수를 합성하는 과정에서 크고 작은 현실적인 문제들이 빵빵 터진다는 것이다.</p><a id="more"></a><p>이런 문제가 빵빵 터지는 가장 큰 이유는 간단하다. 아무리 우리가 순수 함수를 사용한다고 해도 수학의 함수와 완벽하게 똑같을 수는 없기 때문이다. 애초에 프로그래밍과 수학은 비슷하지만 엄연히 다른 학문이다.</p><p>그래서 전 세계의 똑똑이들은 이런 문제들을 해결하기 위해 <code>펑터(Functor)</code>나 <code>모나드(Monad)</code>와 같은 수학의 개념들을 끌고 와서 사용하기 시작했는데, 문제는 이 개념들이 직관적으로 이해하기에는 너무나도 추상적이고 난해한 녀석들이라는 것이다.</p><center><br>  <img src="/2020/01/27/safety-function-composition/functor-example.png" width="500"><br>  <small>보기만 해도 눈물이 절로 나오는 펑터 설명 다이어그램…</small><br>  <br><br></center><p>필자가 펑터나 모나드에 대한 공부를 하면서 구글링을 하면서 찾아본 많은 자료들은 대략 두 가지 정도로 나누어졌는데, 바로 “겁나 어려운 수학적인 설명”과 “코드로 된 예시”였다.</p><p>문제는 이 수학적인 설명과 코드로 된 예시 사이를 이어주는 자료가 별로 없었다는 것이다. 즉, 펑터나 모나드가 정확히 프로그래밍의 어떤 문제를 해결하기 위해 도입된 것인지 쉽게 풀어서 설명해놓은 자료가 별로 없었다. <small>(남들은 다 이해하는데 필자가 멍청해서 이해를 못한 것일수도 있다)</small></p><p>하지만 그렇다고해서 제대로 된 이유도 모르고 펑터나 모나드를 사용하고 싶지는 않았기에 직접 조사해보고 조져보기로 했다.</p><p>그래서 이번 포스팅에서는 함수형 프로그래밍에서 별 생각없이 함수를 조합하면 어떤 문제들이 발생하는지, 그리고 그 문제들을 어떤 방식으로 해결할 수 있는 지에 대한 이야기를 해보려고 한다.</p><h2 id="모든-것은-함수의-합성으로-이루어진다"><a href="#모든-것은-함수의-합성으로-이루어진다" class="headerlink" title="모든 것은 함수의 합성으로 이루어진다"></a>모든 것은 함수의 합성으로 이루어진다</h2><p>다시 한번 이야기하지만 함수형 프로그래밍은 프로그램에서 수행해야하는 어떠한 행위들을 함수로 표현하고, 또 그 함수들을 이렇게 저렇게 잘 합성하여 거대한 프로그램을 만들어나가는 패러다임이다.</p><p>즉, 이러한 함수형 프로그래밍의 정의에서 가장 중요한 키워드는 역시 “함수의 합성”이라고 말할 수 있다. 함수형 프로그래밍에서 그토록 사이드 이펙트를 경계하는 이유도 결국 함수를 안전하게 합성하기 위해서는 함수의 입력과 출력을 예측할 수 있어야하기 때문이다.</p><p>함수형 프로그래밍의 세계에서는 프로그램 내부에서 발생하는 모든 행위들을 함수로 표현하고 있기 때문에 변수에 값을 할당하거나 간단한 사칙연산 조차도 함수로 표현된다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 명령형 프로그래밍</span></span><br><span class="line"><span class="hljs-keyword">const</span> foo: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;</span><br><span class="line">foo + <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 함수형 프로그래밍</span></span><br><span class="line"><span class="hljs-keyword">const</span> foo = ((): <span class="hljs-function"><span class="hljs-params">number</span> =></span> <span class="hljs-number">1</span>)();</span><br><span class="line"><span class="hljs-keyword">const</span> add2 = (x: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">number</span> =></span> x + <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">add2(foo);</span><br></pre></td></tr></tbody></table></figure><p>이 프로그램은 <code>number</code> 타입의 변수를 선언하고, 그 값에 2를 더하는 초 간단한 프로그램이다.</p><p>명령형 프로그래밍으로 작성된 코드에서는 단순히 <code>foo = 1</code>과 같이 표현할 수 있었던 변수의 할당은 <code>1</code>을 반환하는 함수로, <code>foo + 2</code>로 표현하던 연산은 <code>add2(foo)</code>와 같은 함수로 표현되었다.</p><p>우리가 이 코드에서 주목해야할 부분은 바로 가장 마지막 줄의 <code>add2(foo)</code>이다.</p><p><code>add2(foo)</code>라는 것은 <code>foo</code> 변수에 할당되었던 익명 함수의 출력 값인 <code>1</code>을 <code>add2</code> 함수의 입력 값으로 사용하겠다는 의미이며, 이러한 행위가 바로 함수의 합성이다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 조금 더 간단하게 표현한 모습은 이렇다</span></span><br><span class="line"><span class="hljs-keyword">const</span> add2 = <span class="hljs-function"><span class="hljs-params">x</span> =></span> x + <span class="hljs-number">2</span>;</span><br><span class="line">add2( <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params"></span>) => 1</span>)<span class="hljs-params">()</span> );</span></span><br></pre></td></tr></tbody></table></figure><p>변수에 값을 할당하고 더하는 간단한 연산 조차도 함수로 표현해야하는 함수형 프로그래밍의 세계에서 거대한 프로그램을 견고하게 만든다는 것은 여러가지 복잡한 함수들을 어떻게 잘 합성해서 사용할 수 있는지에 따라 좌지우지될 수 있다는 뜻이다.</p><p>이렇게 보면 굉장히 간단한 개념이지만, 사실 아무 함수끼리나 막 합성할 수 있는 것은 아니다. 함수의 합성에는 아주 중요한 규칙이 한 가지 정해져있는데, 바로 합성하려하는 함수들의 “정의역과 치역이 서로 일치해야한다는 것”이다.</p><h3 id="정의역과-치역이-일치해야-함수를-합성할-수-있다"><a href="#정의역과-치역이-일치해야-함수를-합성할-수-있다" class="headerlink" title="정의역과 치역이 일치해야 함수를 합성할 수 있다"></a>정의역과 치역이 일치해야 함수를 합성할 수 있다</h3><p>이전에 작성했던 <a href="/2019/12/29/about-pure-functions/" title="수학에서 기원한 프로그래밍 패러다임, 순수 함수">수학에서 기원한 프로그래밍 패러다임, 순수 함수</a> 포스팅에서 한 차례 이야기한 적이 있지만, 함수형 프로그래밍에서는 함수의 사이드 이펙트를 최대한 없애버리기 위해 <code>순수 함수</code>를 사용한다.</p><p>대표적인 순수 함수의 특징은 대략 이 두 가지이다.</p><blockquote><ol><li>함수 외부의 상태를 변경하거나 참조하지 않는다!</li><li>동일한 입력을 넣었으면 항상 동일한 출력을 반환해야 한다!</li></ol></blockquote><p>이런 순수 함수를 사용하면 개발자가 함수의 행동을 예측하기 쉬워지기 때문에 디버깅이 편리하다는 장점도 있지만, 사실 애초에 저 규칙들이 지켜지지 않는다면 함수를 합성할 수 없기 때문에 모든 행위를 함수로 표현하고 조합해서 프로그래밍을 만드는 짓을 할 수 조차 없다.</p><p>왜 저 규칙들을 준수해야 함수의 합성이 가능하다는 것일까? 일단 순수 함수는 수학의 함수를 프로그래밍으로 구현한 개념이니, 한번 수학의 함수가 어떤 느낌으로 작동하는 녀석인지부터 살펴보도록 하자.</p><p>일단 수학의 함수는 함수의 입력으로 사용할 수 있는 값들의 집합인 정의역과, 함수의 출력으로 사용할 수 있는 값들의 집합인 치역을 가지고 있다.</p><p>그리고 정의역에 있는 원소 하나와 치역에 있는 원소 하나는 무조건 <code>1:1</code>로 매칭되어야한다. 즉, 동일한 입력을 함수에 넣었으면 항상 동일한 출력을 반환해야 한다는 말이다. 만약 이 규칙이 깨져버리면 그건 더 이상 함수라고 부를 수 없는 변태같은 무언가가 되어버린다.</p><center><br>  <img src="/2020/01/27/safety-function-composition/functions.png" width="500"><br>  <br><br></center><p>쉽게 말해 함수의 입력으로 사용할 수 있도록 정해져 있는 값들 중에 하나를 뽑아서 함수에 던지면, 반드시 출력으로 사용할 수 있도록 정해져 있는 값들 중에 하나가 튀어나온다는 것이다.</p><p>그렇다면 이 개념을 그대로 프로그래밍으로 구현한 순수 함수에게도 정의역과 치역이라고 부를 수 있을만한 무언가가 있다는 말인데, 프로그래밍의 세계에서 살고 있는 순수 함수의 정의역과 치역은 무엇이 될 수 있을까?</p><center><br>.<br>.<br>.<br><br><br></center><blockquote><p>바로 <strong>타입(Type)</strong>이다.</p></blockquote><p>사실 프로그래밍에서 사용하는 타입이라는 녀석도 잘 생각해보면 일종의 집합이라고 볼 수 있다. <code>number</code>라는 집합은 <code>{-1, 0, 0,1, 1, 2, NaN, Infinity...}</code>과 같이 모든 숫자 값을 원소로 가지고 있는 집합이고, <code>boolean</code>이라는 집합은 <code>{true, false}</code>를 원소로 가지는 집합, <code>string</code>이라는 집합은 프로그래밍으로 만들어 낼 수 있는 모든 문자열들을 가지고 있는 집합이라는 이야기이다.</p><p>위에서 예시로 들었던 <code>add2</code> 함수를 다시 한번 가져와서 살펴보면, 이 함수는 <code>number</code> 타입을 가진 값을 받아서 다시 <code>number</code> 타입의 값을 반환하고 있다는 것을 알 수 있다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> add2 = (x: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">number</span> =></span> x + <span class="hljs-number">2</span>;</span><br></pre></td></tr></tbody></table></figure><p>이때 <code>add2</code> 함수는 <code>number</code> 집합을 정의역과 치역으로 가지고 있다고 볼 수 있는 것이다. 여기에 더 나아가서 다른 형태의 함수들의 정의역과 치역도 모두 동일한 규칙으로 정의해볼 수 있다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> f = (): <span class="hljs-function"><span class="hljs-params">number</span> =></span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 정의역: number, 치역: string</span></span><br><span class="line"><span class="hljs-keyword">type</span> g = (): <span class="hljs-built_in">Array</span><<span class="hljs-built_in">string</span>> => <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 정의역: Array<string>, 치역: boolean</span></span><br><span class="line"><span class="hljs-keyword">type</span> h = (): <span class="hljs-function"><span class="hljs-params">string</span> =></span> <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 정의역: string, 치역: boolean</span></span><br></pre></td></tr></tbody></table></figure><p>이제 슬슬 수학의 함수와 프로그래밍의 순수 함수 간의 공통점이 조금 더 보이기 시작한다.</p><p>그럼 이제 원래 본론이었던 함수의 합성에 대해 한번 이야기해보자. 사실 수학의 세계에서 함수를 합성하는 상황은 굉장히 흔한 일이며, 심지어 함수의 합성을 나타내는 전용 기호도 준비되어있다.</p><p>$f$ 함수와 $g$ 함수를 합성한 합성함수 $h$는 이런 간단한 수식으로 나타낼 수 있다.</p><p><br><br><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>h</mi><mo>=</mo><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}h = g\circ f\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.010000000000000009em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit">h</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mbin">∘</span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span><br><br></p><p>갑자기 수식이 나와서 머리가 아프다면 그냥 $f$ 함수는 밥먹기, $g$ 함수는 그릇 치우기, 합성함수 $h$는 밥먹고 그릇 치우기 정도로 이해해도 아무 문제가 없다. 원래 함수란 그렇게 추상적인 느낌이다.</p><p>이 식에서 함수의 실행 순서는 오른쪽에서 왼쪽이다. 즉, 합성된 함수인 $h$ 함수를 $h(x)$와 같이 사용한다는 것은 사실 $g(f(x))$와 같이 함수를 합성해서 사용하는 것과 동일하다는 것이다.</p><p>하지만 이런 식으로 함수를 겹쳐가면서 합성을 표현한다면 많은 함수를 합성하는 공식을 보았을 때 괄호만 보일 게 뻔하므로 저 동그란 연산자를 사용하여 합성된 함수들을 펼쳐서 읽을 수 있도록 해주는 것이다. <small>(콜백과 async/await의 차이를 생각해보자)</small></p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 함수 합성 연산자가 없다면 대충 이런 느낌이 되어 버리지 않을까...?</span></span><br><span class="line">foo(b(a(h(f(g(x))))));</span><br></pre></td></tr></tbody></table></figure><p>이때 함수를 합성하기 위해서는 첫 번째 함수인 $f$의 치역과 그 다음 함수인 $g$의 정의역이 동일해야 한다는 중요한 원칙이 있다.</p><p>방금 위에서 순수 함수의 정의역과 치역은 타입이라고 했으니, 첫 번째 함수의 출력 값의 타입과 그 다음 함수의 입력 값의 타입이 동일해야한다고 말할 수도 있을 것 같다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 합성이 가능하다!</span></span><br><span class="line">f: <span class="hljs-function"><span class="hljs-params">number</span> =></span> <span class="hljs-built_in">number</span></span><br><span class="line">g:           <span class="hljs-function"><span class="hljs-params">number</span> =></span> <span class="hljs-built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 이건 합성이 불가능...</span></span><br><span class="line">f: <span class="hljs-function"><span class="hljs-params">number</span> =></span> <span class="hljs-built_in">string</span></span><br><span class="line">g:           <span class="hljs-function"><span class="hljs-params">number</span> =></span> <span class="hljs-built_in">number</span></span><br></pre></td></tr></tbody></table></figure><p>정의역과 치역 어쩌고하면 조금 복잡해보일지 몰라도 타입으로 바꿔보니 굉장히 당연하기 짝이 없는 이야기가 되어버렸다. 그렇다면 순수 함수를 사용하면서 이 규칙만 잘 적용해주면 아무 문제가 없을까?</p><p>음, 대부분의 경우에는 가능하겠지만 슬프게도 모든 케이스를 커버할 수는 없다. 프로그래밍의 세계에는 <code>함수의 실패</code>라던가 <code>불확실성</code>과 같이 수학의 세계에는 없는 케이스들이 존재하기 때문이다.</p><p>수학의 함수를 프로그래밍적으로 구현한 순수 함수라 할 지라도 프로그래밍의 세계에 존재하는 이상 이런 케이스들을 모두 피해갈 수는 없다.</p><p>결국 아무리 순수 함수를 사용한다고 해도 이런 문제점들이 여전히 존재하기 때문에 전세계의 똑똑이들이 “도대체 어떻게 하면 안전하게 함수를 합성할 수 있을까?”라는 고민을 하게 된 것이고, 그 고민을 통해 도입된 것이 바로 펑터나 모나드와 같은 수학의 개념들인 것이다.</p><h3 id="순수-함수에도-사이드-이펙트는-존재한다"><a href="#순수-함수에도-사이드-이펙트는-존재한다" class="headerlink" title="순수 함수에도 사이드 이펙트는 존재한다"></a>순수 함수에도 사이드 이펙트는 존재한다</h3><p><code>사이드 이펙트(Side-Effect)</code>라는 단어는 한국어로 직역하면 <code>부수 효과</code>이다.</p><p>즉, 함수에게 기대하고있는 행위 외에 발생하는 모든 부수 효과들을 우리는 사이트 이펙트라고 하는 것이다. 함수가 외부 상태에 영향을 받는 것은 대표적인 사이드 이펙트 중 하나에 불과하다.</p><p>사실 순수 함수를 수학의 함수와 비교해보면 “같은 값을 입력받으면 늘 같은 출력을 반환한다”라는 규칙이 보장되는 것 외에는 허술하기 짝이 없는 함수이다. 예를 들어 문자열을 입력받은 후 그 문자열의 가장 첫번째 글자를 반환하는 함수가 있다고 생각해보자.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFirstLetter</span> (<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> s[<span class="hljs-number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>일단 이 함수도 순수 함수는 맞다. 함수의 출력 값은 인자에만 영향을 받고 있고, 늘 같은 입력 값에는 같은 출력을 반환하고, 외부 상태에 전혀 영향도 받고 있지 않기 때문이다.</p><p><code>getFirstLetter</code> 함수는 주어진 문자열의 첫 글자를 반환하는 순수 함수이지만, 만약 빈 문자열이 인자로 주어질 경우 <code>string</code>형이 아닌 <code>undefined</code>를 반환할 것이다.</p><p>우리가 과연 이 함수를 사용할 때 “반드시 <code>string</code> 타입이 반환될꺼야”라고 장담할 수 있을까?</p><p>만약 이렇게 <code>getFirstLetter</code> 함수가 반드시 <code>string</code> 타입을 반환할 것이라고 장담하고 함수를 합성했다면 아마 이런 타입 에러를 만날 수 있을 것이다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStringLength</span> (<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> s.length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getStringLength(getFirstLetter(<span class="hljs-string">''</span>));</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="hljs-built_in">TypeError</span>: Cannot read property <span class="hljs-string">'length'</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><p>사실 이 에러 조차 사이드 이펙트라고 할 수 있다. 어찌되었든 우리의 순수 함수에게 기대했던 효과가 아니라 부수적으로 발생하고 있는 효과이기 때문이다.</p><p>이렇게 여러 개의 함수가 합성되어 있는 상황에서 단 하나의 함수라도 에러가 발생하면 합성 함수로 구성된 연산 전체가 망해버리기 때문에 우리는 이 사이드 이펙트를 반드시 관리해줘야 한다.</p><p>사실 <code>getFirstLetter</code> 함수의 치역은 <code>string</code>이 아니라, <code>string</code> 집합과 <code>undefined</code> 집합이 합쳐져 있는 <code>string|undefined</code> 집합이다. 그러니 우리는 이 두 함수의 정의역과 치역을 다시 설정해주고 예외 처리를 추가함으로써 이 문제를 해결할 수 있다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFirstLetter</span> (<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span>|<span class="hljs-title">undefined</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> s[<span class="hljs-number">0</span>];</span><br><span class="line">}</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStringLength</span> (<span class="hljs-params">s: <span class="hljs-built_in">string</span>|<span class="hljs-literal">undefined</span></span>): <span class="hljs-title">number</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">if</span> (!s) {</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">return</span> s.length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>하지만 이렇게 어떤 함수가 여러 개의 집합이 합쳐진 치역을 가지기 시작하면 이 함수와 합성하기 위한 모든 함수의 정의역도 여러 개의 집합이 합쳐진 치역을 가져야하기 때문에, 결국 <code>type|undefined</code>처럼 암 걸리는 타입이 모든 함수에 적용되어야 할 것이다.</p><p>게다가 이런 상황이 발생할 때마다 함수 내부에서 매번 조건 검사를 통해 값의 유무를 검사하는 것은 너무나도 귀찮은 일이고, 여기저기서 동일한 코드가 계속 커플링되기 때문에 이 방법이 근본적인 해결책은 아닌 것 같다.</p><p>이렇게 함수에서 어떤 타입이 반환될지 장담할 수 없다는 불확실성 또한 결국 정의역과 치역을 일치시켜야하는 함수의 합성 과정에서 명확한 타입의 사용을 저해하는 요소가 되기 때문에 반드시 믿고 걸러야하는 사이드 이펙트라고 할 수 있다.</p><h2 id="그럼-사이드-이펙트를-어떻게-관리해야할까"><a href="#그럼-사이드-이펙트를-어떻게-관리해야할까" class="headerlink" title="그럼 사이드 이펙트를 어떻게 관리해야할까?"></a>그럼 사이드 이펙트를 어떻게 관리해야할까?</h2><p>이런 상황이 발생하는 이유는 그냥 “컴퓨터는 수학이 아니니까”라고 말할 수 밖에 없다. 어쨌든 프로그램에서 돌아가는 모든 함수는 저런 문제들을 가지고 있다. 심지어 순수 함수라고 할지라도 말이다.</p><p>즉, 근본적으로 이 문제는 함수들 간의 합성 과정에서 어쩔 수 없이 발생하는 사이드 이펙트를 어떻게 하면 잘 관리해가면서 합성할 수 있을지에 대한 고민이다.</p><p>함수를 합성할 때 중간에 껴있는 함수에서 에러가 발생하더라도 합성된 함수의 연산을 안전하게 끝낼 수 있을 지, 불확실한 함수의 출력을 어떻게 하면 명확하게 만들어서 다음 함수로 전달할 수 있을 지 말이다.</p><p>그렇다면 함수를 다른 함수로 한번 감싸서 안전하게 예외처리를 진행하거나, 혹은 중간에 이상한 값이 나오면 그대로 다음 함수를 지나치게 만들면 되지 않을까?</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> StringFunction = <span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safety</span> (<span class="hljs-params">x: <span class="hljs-built_in">string</span>|<span class="hljs-literal">undefined</span>, fn: StringFunction</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> x ? fn(x) : x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">safety(getFirstLetter(<span class="hljs-string">'Hi'</span>), getStringLength);</span><br><span class="line">safety(getFirstLetter(<span class="hljs-string">''</span>), getStringLength);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><p>하지만 이런 방식은 수많은 타입의 입출력을 가진 함수들에게 모두 적용하기에는 약간 무리가 있어보이니 제네릭 타입을 사용하여 조금 더 유연하게 만들어 보자.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safety</span> <<span class="hljs-title">T</span>, <span class="hljs-title">U</span>>(<span class="hljs-params">x: T|<span class="hljs-literal">undefined</span>, fn: (x: T) => U</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> x ? fn(x) : x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">safety<<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>>(getFirstLetter(<span class="hljs-string">'Hi'</span>), getStringLength);</span><br><span class="line">safety<<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>>(getFirstLetter(<span class="hljs-string">''</span>), getStringLength);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><p>오호 조금 그럴싸해졌다. 결국 <code>safety</code> 함수는 <code>T</code>또는 <code>undefined</code>의 값을 인자로 받은 후 이 인자가 <code>undefined</code>이라면 그대로 <code>undefined</code>을 반환하고, 만약 아니라면 <code>T</code> 타입을 인자로 받아서 <code>U</code> 타입을 반환하는 함수에게 인자를 넘겨주고 그 함수의 실행 결과를 반환한다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">값이 있다: T -> fn<U></span><br><span class="line">값이 없다: T -> <span class="hljs-literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><p>결국 우리는 <code>getFirstLetter</code> 함수의 치역과 <code>getStringLength</code> 함수의 정의역을 바로 연결해버리는 것이 아닌, <code>x ? fn(x) : x</code>라는 로직을 통해 함수의 사이드 이펙트를 한번 감싸준 다음 함수를 안전하게 합성한 것이다.</p><p>그렇다면 이 개념을 조금 더 확장해서 함수가 출력한 값을 사용할 때 일종의 안전장치 역할을 하는 함수가 늘 값을 감싸고 있다면 어떨까? 이런 느낌으로 함수의 정상적인 결과와 사이드 이펙트를 감싸줄 수 있는 무언가를 만들 수 있으면 이 문제를 해결할 수 있지 않을까?</p><center><br>  <img src="/2020/01/27/safety-function-composition/set.png" width="300"><br>  <br><br></center><p>만약 저 추상적인 무언가가 함수의 사이드 이펙트를 관리해주면서 다른 함수와의 합성을 진행할수만 있다면, 함수를 합성하는 과정에서 일일히 저런 예외 처리를 해주지 않아도 되고, 함수들의 입출력에 대한 타입 안정성도 가져가며 마음 놓고 합성을 쭉쭉 해나갈수 있을 것 같다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 이런 느낌으로 말이다!</span></span><br><span class="line">f: Something<<span class="hljs-built_in">number</span>> -> Something<<span class="hljs-built_in">number</span>></span><br><span class="line">g:                      Something<<span class="hljs-built_in">number</span>> -> Something<<span class="hljs-built_in">number</span>></span><br></pre></td></tr></tbody></table></figure><p>함수는 제대로 된 치역에 해당하는 값을 반환할 수도 있고 사이드 이펙트를 일으킬 수 있는 <code>null</code>이나  <code>undefined</code> 같은 값을 반환할 수도 있지만, 뭐가 되었든 저 <code>Something</code>이라는 녀석이 알아서 예외를 핸들링할 수 있도록 만들기만 한다면 우리는 그런 자잘한 건 신경쓰지 않고 함수를 쭉쭉 합성할 수 있기 때문이다.</p><p>그리고 이런 느낌이라면 <code>null</code>이나 <code>undefined</code>를 관리하는 것 외에도, 다양한 로직을 값에다가 감싸서 사용하면 되니까 나름 확장성도 좋은 개념인 것 같다. 뭐 대충 이런 느낌으로 말이다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Maybe<T> = 값이 있을 수도 있고 없을 수도 있다</span><br><span class="line"><span class="hljs-built_in">Promise</span><T> = 지금은 값이 없는데 나중에 값이 생기면 값을 준다</span><br><span class="line">List<T> = 같은 속성의 값을 여러 개 가지고 있을 수도 있다</span><br></pre></td></tr></tbody></table></figure><p>그리고 이렇게 값을 감싸고 있는 무언가를 효율적으로 사용하려면 내부에 있는 값을 자유롭게 변경할 수 있어야 하므로 <code>Maybe<T> -> Maybe<U></code>와 같은 동작을 수행할 수 있는 무언가도 필요할 것 같다.</p><p>이런 고민 끝에 프로그래머들은 이런 비슷한 역할을 수행하는 수학의 한 개념을 차용하게 되는데, 그 개념이 바로 <code>펑터(Functor)</code>이다.</p><h2 id="펑터란-무엇일까"><a href="#펑터란-무엇일까" class="headerlink" title="펑터란 무엇일까?"></a>펑터란 무엇일까?</h2><p>펑터는 보통 값을 품고 있는 어떠한 박스의 형태로 설명되고는 한다. 방금 위에서 설명한 것과 같이 함수의 정상적인 결과와 사이드 이펙트를 감싸서 처리할 수 있는 무언가를 설명하기에는 박스가 적절한 예시이기 때문이다.</p><center><br>  <img src="/2020/01/27/safety-function-composition/fmap_just.png"><br>  <small>[출처] <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">Functors, Applicatives, And Monads In Pictures</a></small><br>  <br><br></center><p>저 박스는 결국 안전하게 값을 사용할 수 있도록 도와주는 로직을 가지고 있거나, 혹은 여러 개의 값을 처리할 수 있는 로직을 가지고 있거나, 아직은 값이 결정되지 않았지만 나중에 값이 결정되고 나면 값을 사용할 수 있는 로직을 가지고 있는 등, 값을 사용할 때 도움을 주는 여러가지 로직을 담고 있는 마법의 박스라고 할 수 있다.</p><p>이때 이 박스는 역할이 고정된 것이 아니라 <code>Maybe</code>, <code>Promise</code> 등 다양한 기능을 가질 수도 있기 때문에 <code>문맥(Context)</code>이라는 이름으로 불리기도 한다.</p><p>우리가 방금 만들었던 <code>safety</code> 함수도 값을 감싸고 있는 일종의 박스라고 생각해볼 수 있다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safety</span> <<span class="hljs-title">T</span>, <span class="hljs-title">U</span>>(<span class="hljs-params">x: T|<span class="hljs-literal">undefined</span>, fn: (x: T) => U</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> x ? fn(x) : x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><center><br>  <img src="/2020/01/27/safety-function-composition/box.png" width="200"><br>  <small><code>x</code> 값이 있으면 <code>fn(x)</code>를 실행하고, 없으면 그대로 <code>x</code>를 반환하는 박스</small><br>  <br><br></center><p>즉, <code>x</code>라는 값을 바로 사용하는 것이 아니라 <code>safety</code> 함수에 <code>x</code>라는 값을 넣어서 사용하고 있으므로 <code>safety</code> 함수를 일종의 박스라고 생각하자는 것이 저 설명의 취지이다.</p><p>사실 펑터의 개념적인 내용은 이게 전부라고 할 수 있고, 이후 펑터를 구현하는 방법만 익혀도 펑터를 사용함에 있어서는 아무런 지장이 없다. 그러나 이번 포스팅의 목적은 펑터가 무엇인지 조금 더 깊숙하게 조져보는 것이므로 필자는 조금 더 근본적인 펑터의 개념에 대해서 이야기해볼까한다.</p><h3 id="카테고리-Category"><a href="#카테고리-Category" class="headerlink" title="카테고리(Category)"></a>카테고리(Category)</h3><p><code>펑터(Functor)</code>는 수학의 <code>카테고리 이론(Category Theory)</code>에 등장하는 개념이며, 동일한 구조를 가지고 있는 카테고리들의 관계를 정의할 수 있는 구조체라고 정의된다.</p><p>그렇기 때문에 펑터가 본질적으로 무엇인지, 왜 <code>Something<type></code>이라는 것을 통해 함수를 안전하게 합성하기위해 펑터가 필요하다는 것인지 알기 위해서는 카테고리라는 개념에 대해 알고 있어야 한다.</p><p>사실 수학에서 이야기하는 카테고리라는 개념은 우리가 일상 생활 속에서 사용하는 카테고리의 의미와 크게 다르지 않다. 뭐 비슷한 것들을 묶어놓은 그런 개념이랄까…?</p><p>이렇게 마음을 가볍게 먹은 후 카테고리 이론을 위키피디아에 검색해보면 아래와 같은 검색 결과를 만날 수 있게 된다.</p><blockquote><p>범주 $\mathcal {C}$는 다음과 같은 데이터로 구성된다.</p><ul><li>대상(對象, 영어: object)들의 모임 $ob(C)$. 이 모임의 원소를 $C$의 “대상”이라고 한다.</li><li>임의의 두 대상 $a,b \in ob(C)$에 대하여, $a$를 정의역으로, $b$를 공역으로 하는 사상(寫像, 영어: morphism)들의 모임 $f\colon a\to b$로 쓰고, $f$를 $a$에서 $b$로 가는 사상’이라고 한다. $C$의 사상의 모임을 $\hom(C)$로 나타낸다.</li><li>임의의 세 대상 $a,b,c\in ob(C)$에 대하여, 이항 연산 $\hom(a,b)\times \hom(b,c)\to \hom(a,c)$. 이를 사상의 합성(合成, 영어: composition)이라고 한다. $f\colon a\to b$와 $g\colon b\to c$의 합성은 $g\circ f$ 또는 $gf$ 등으로 나타낸다.<br>…</li></ul><footer><strong>위키피디아</strong><cite><a href="https://ko.wikipedia.org/wiki/%EB%B2%94%EC%A3%BC_(%EC%88%98%ED%95%99)" target="_blank" rel="noopener">범주(수학)</a></cite></footer></blockquote><center><br>  <img src="/2020/01/27/safety-function-composition/what.jpeg" width="500"><br>  <small>읭…?</small><br>  <br><br></center><p>사실 카테고리 이론의 개괄적인 내용은 누구나 다 간단하게 이해할 수 있는 수준의 내용이다. 단지 추상적인 학문인 수학의 특성 상 일상적인 언어로 풀어서 설명하면 너무 길어지고 복잡해지니 간단하게 축약할 수 있는 단어와 기호들로 표현한 것 뿐이다. <small>(사실 이게 수포자가 생기는 원인 중 하나)</small></p><p>일단 위에서 이야기 했듯이 수학에서 이야기하는 카테고리는 쇼핑몰 사이트에 있는 그 카테고리가 맞다. 다만 수학의 카테고리는 조금 더 추상적인 개념이기 때문에 물건으로 구성되는 카테고리일수도 있고 자연수로 구성된 카테고리일수도 있으며, 때로는 함수로 구성된 카테고리가 될 수도 있다는 차이점이 있다.</p><p>위의 수학적 정의에서 카테고리는 <code>대상(Object)</code>과 <code>사상(Morphism)</code>이라는 것으로 구성된다고 이야기하고 있다.</p><p>대상이라는 것은 그냥 카테고리 안에 있는 하나의 객체이다. 만약 패션 쇼핑몰의 상품 카테고리라면 대상은 셔츠, 맨투맨, 아우터, 코트가 될 것이고, 자연수로 이루어진 카테고리라면 1, 2, 3과 같은 수가 될 것이다. 여기까지는 우리가 일상적으로 사용하는 카테고리라는 단어와 비슷한 느낌이기 때문에 이해가 그리 어렵지 않다.</p><p>그러나 수학에서의 카테고리는 대상 외에도 <code>사상</code>이라는 한 가지 데이터를 더 가지고 있다.</p><p>위의 수학적 정의를 다시 보면 사상은 임의의 두 대상 $a,b \in ob(C)$에 대하여, $a$를 정의역으로, $b$를 공역으로 하는 무언가라고 한다. 사실 $a,b \in ob(C)$라는 말은 $a$와 $b$라는 대상이 카테고리 $C$안에 있다는 것을 의미하는 것이니 그냥 넘어가도록 하고, 우리가 집중해야할 단어는 <code>정의역</code>과 <code>공역</code>이다.</p><p>정의역과 공역이라는 단어를 듣고 가장 먼저 생각나는 단어가 무엇일까? 바로 <code>함수</code>이다. $a$를 정의역으로, $b$를 공역으로 한다는 이야기는, $a$라는 대상에 어떤 사상(함수)를 적용하면 $b$가 된다는 것을 이야기하고 있는 것이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> 대상A = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> 사상add1 = <span class="hljs-function"><span class="hljs-params">x</span> =></span> x + <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 대상 A에게 add1이라는 사상을 적용하면...</span></span><br><span class="line">사상add1(대상A);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">2</span> <span class="hljs-comment">// 대상 B가 된다</span></span><br></pre></td></tr></tbody></table></figure><p>즉, 사상이라는 것은 대상과 대상 간의 관계를 나타낼 수 있는 일종의 함수라고 생각하면 된다. 그래서 수학적 표현으로는 $f: a \to b$라고 표현할 수 있는 것이고 프로그래밍적으로는 그냥 람다 함수로 <code>(a) => b</code>이라고 표현할 수 있는 것이다. <small>(대상의 종류에 따라 사상이 함수가 아닌 경우도 있지만, 거기까진 생각하지 말자)</small></p><p>여기까지 이해했다면 보다 쉬운 설명을 위해 간단한 카테고리를 하나 가져와서 가지고 놀아보도록 하겠다.</p><center><br>  <img src="/2020/01/27/safety-function-composition/category.png" width="300"><br>  <br><br></center><p>대충 이런 구조를 가진 카테고리 $\mathcal {C}$가 있다고 생각해보자. 이 카테고리에서 대상은 자전거, 자동차, 비행기이고 사상은 객체들 사이에 있는 <code>빠름</code>이라는 화살표이다.</p><p>즉, 이 카테고리에서 자전거에 <code>빠름</code>이라는 사상을 적용하면 자동차가 되고, 자동차에 다시 <code>빠름</code>라는 사상을 적용하면 비행기가 된다는 뜻이다. 사상으로 객체들 간의 관계를 표현할 수 있다는 말은 이런 의미이다. 자전거가 빨라지면 자동차가 되고, 자동차가 빨라지면 비행기가 되는 것이니 말이다.</p><p>그리고 사상을 적용한다는 것은 함수를 적용한다는 말과 같으므로 간단한 코드로 이 카테고리의 구조를 표현해볼 수도 있겠다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> 카테고리 = [<span class="hljs-string">'자전거'</span>, <span class="hljs-string">'자동차'</span>, <span class="hljs-string">'비행기'</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> 빠름 (<span class="hljs-params">카테고리, 대상</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> index = 카테고리.findIndex(<span class="hljs-function"><span class="hljs-params">v</span> =></span> v === 대상);</span><br><span class="line">  <span class="hljs-keyword">return</span> 카테고리[index + <span class="hljs-number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">빠름(카테고리, <span class="hljs-string">'자전거'</span>);</span><br><span class="line">빠름(카테고리, <span class="hljs-string">'자동차'</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">'자동차'</span></span><br><span class="line"><span class="hljs-string">'비행기'</span></span><br></pre></td></tr></tbody></table></figure><p>그리고 자전거에서 비행기로 바로 그어진 빠름 $\circ$ 빠름 사상은 빠름 사상 두 개를 합성한 것을 의미하니까, 코드로는 함수 두 개를 합성한 형태인 <code>빠름(빠름(자전거)) === '비행기'</code>로 표현할 수 있다.</p><p>결국 사상의 합성이라는 것을 프로그래밍으로 표현하면 그냥 함수를 합성하는 것 그 이상도 이하도 아니다. 이 간단한 걸 수학적인 정의로 이야기하면 이렇게 복잡해보이는 이야기가 되는 것이다.</p><blockquote><p>임의의 세 대상 $a,b,c\in ob(C)$에 대하여, 이항 연산 $\hom(a,b)\times \hom(b,c)\to \hom(a,c)$. 이를 사상의 합성(合成, 영어: composition)이라고 한다. $f\colon a\to b$와 $g\colon b\to c$의 합성은 $g\circ f$ 또는 $gf$ 등으로 나타낸다.</p></blockquote><p>이 정의에서 이야기하는 임의의 세 대상은 각각 위 카테고리의 자전거, 자동차, 비행기라고 생각하면 된다. 그리고 $hom(a,b)$라는 말에서 나오는 $hom$이라는 녀석은 여러 개의 사상을 가지고 있는, 사상의 집합을 의미한다.</p><p>이 정의에서 사상이 하나가 아닌 여러 개라고 이야기하는 이유는 간단하다. 위의 카테고리만 보더라도 자전거와 자동차 간의 관계가 단지 <code>빠름</code>이라는 것만 있지는 않을 것이니 말이다.</p><blockquote><ol><li>자전거 -<strong>빠름</strong>-> 자동차</li><li>자전거 -<strong>비쌈</strong>-> 자동차</li><li>자전거 -<strong>크기가 큼</strong>-> 자동차</li><li>자전거 -<strong>엔진이 달림</strong>-> 자동차</li></ol></blockquote><p>뭐 이런 식으로 어떤 대상과 대상 사이에는 여러 개의 사상이 존재할 수 있기 때문에, 이 사상들의 집합을 퉁쳐서 $hom$라고 표현한 것이다.</p><p>뭐 이딴 것까지 하나하나 다 신경쓰고 있냐고 할 수도 있지만, 수학은 분명히 정답이 존재해야하고, 절대 예외를 허용하지 않는 논리적인 학문이기 때문에 이렇게 모든 케이스를 전부 고려한 정의를 만들어줘야한다.</p><p>그리고 $f\colon a\to b$ 라는 표현은 $hom$에 있는 여러 개의 사상 중에서, $a$ 대상과 $b$ 대상에 단 하나의 사상만 적용한 경우를 말한다. 저 사상들 중 무슨 사상을 적용할지는 모르겠는데, 어쨌든 적용할 때는 한번에 하나만 적용해야하기 때문이다. <small>(여러 개를 동시에 적용할거야!는 양자 컴퓨터가 아니면 불가능하다)</small></p><p>그리고 마지막으로 우리가 자전거에다 빠름 사상을 두 번 적용한 것과 같이 사상을 합성한 것을 $f: a\to b$ 사상과 $g: b\to c$ 사상이 합성된 $g\circ f$, 사상의 합성이라고 표현하는 것이다.</p><p>즉, 자전거라는 대상에 사상 $f$를 적용하고, 다시 사상 $g$를 적용하면 비행기라는 대상이 된다는 것을 이야기 하는 것이며, 이것도 그냥 코드로 표현하면 그냥 <code>g(f(자전거)) === '비행기'</code>라고 할 수 있겠다.</p><p>이렇듯이 카테고리 이론은 굉장히 추상적인 이론이라 프로그램 안에서 벌어지는 일을 전부 저런 카테고리 모델로 표현해낼 수 있으며, 마찬가지로 우리가 함수형 프로그래밍을 하면서 어떤 값에 함수를 적용하고 합성하는 과정 또한 일종의 카테고리 모형으로 표현할 수 있는 것이다.</p><center><br>  <img src="/2020/01/27/safety-function-composition/category-example.png" width="300"><br>  <small>프로그램 내에서 벌어지는 모든 일은 이렇게 카테고리로 표현할 수 있다</small><br>  <br><br></center><p>필자는 개인적으로 여기까지가 펑터를 조금 더 쉽게 이해하기위한 카테고리 이론의 전부라고 생각한다. 프로그램에서 발생하는 일들을 일종의 카테고리로 정의할 수 있다는 사실까지 받아들이고 나면 펑터를 이해하는 것이 간단해지기 때문이다.</p><h3 id="펑터-Functor"><a href="#펑터-Functor" class="headerlink" title="펑터(Functor)"></a>펑터(Functor)</h3><p>자, 이제 방금 만들었던 간단한 카테고리를 이제 조금 추상적인 모델로 바꿔보도록 하자. 비행기, 자동차, 자전거와 같은 이름은 변수 <code>x, y, z</code>로 변경하고 사상 <code>빠름</code> 역시 변수인 <code>f</code>와 <code>g</code>로 변경하겠다.</p><center><br>  <img src="/2020/01/27/safety-function-composition/absolute-category.png" width="300"><br>  <br><br></center><p>아까 우리가 만든 카테고리를 이렇게 추상적인 구조로 변경하고나니, 이런 구조를 가진 카테고리는 왠지 카테고리 $C$ 말고도 더 있을 것 같다는 생각이 든다.</p><p>그도 그럴것이 저런 구조의 대상과 사상을 가지는 카테고리는 굉장히 흔하고, 솔직히 어디다가 가져다 붙혀도 왠만한 정의에는 껴맞출 수 있는 보편적인 카테고리이기 때문이다.</p><p>그렇다면 대상에 사상을 적용하여 다른 대상으로 만들 수 있듯이, 카테고리에도 사상을 적용하여 다른 카테고리로 만들 수 있지 않을까?</p><p>이때 등장하는 것이 바로 <code>펑터(Functor)</code>이다. 즉, 펑터는 카테고리를 다른 카테고리로 변경할 수 있는 사상(함수)인 것이다.</p><center><br>  <img src="/2020/01/27/safety-function-composition/functor-category.png"><br>  <br><br></center><p>카테고리 $C$가 아무리 복잡하게 구성되어있다고 해도 우리는 $F(C)$와 같이 카테고리에 펑터를 덮어 씌우기만 하면 간단하게 펑터를 사용할 수 있다. 그러면 펑터가 적용된 카테고리 내부에 있는 모든 대상과 사상들 또한 $F$라는 함수로 감싸져 있는 형태로 변경된다.</p><p>여기서 가장 중요한 것은 펑터로 감싸도 카테고리 자체의 구조는 절대 변하지 않는다는 점이다. 위 그림에서도 대상과 사상들에게 $F$라는 함수가 적용되었을 뿐 화살표 자체의 모양은 변하지 않은 것을 볼 수 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> 대상x = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> 대상y = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> 사상f = <span class="hljs-function"><span class="hljs-params">x</span> =></span> x + <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">사상f(대상x) === 대상y; <span class="hljs-comment">// true</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> 대상x = 펑터(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> 대상y = 펑터(<span class="hljs-number">2</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> 사상f = 펑터(<span class="hljs-function"><span class="hljs-params">x</span> =></span> x + <span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line">사상f(대상x) === 대상y; <span class="hljs-comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>즉, 펑터를 사용하더라도 카테고리가 가지고 있는 규칙 자체는 절대 변경되지 않는다. 쉽게 말해 안전하게 대상이나 사상을 감싸기만 할 뿐, 그 외에 아무런 사이드 이펙트를 일으키지 않는다는 것이다.</p><p>아까 전에 프로그래밍에서 발생하는 모든 일도 일종의 카테고리로 표현할 수 있다고 했던 것을 기억하는가?</p><p>아무리 복잡한 카테고리라고 해도, 단순히 펑터로 감싸기만 하면 기존 카테고리의 구조를 전혀 건드리지 않으면서 다른 카테고리로 변경할 수 있기 때문에 우리가 찾고있던 “값을 감싸서 안전하게 값을 사용하고 싶다”라는 니즈에 부합하는 개념인 것이다.</p><h2 id="펑터를-직접-만들어보자"><a href="#펑터를-직접-만들어보자" class="headerlink" title="펑터를 직접 만들어보자!"></a>펑터를 직접 만들어보자!</h2><p>펑터라는 것은 그렇게 거창한 개념이 아니다. 간단하게 말해서 카테고리를 다른 카테고리로 바꿔주는 행위를 할 수 있으면 펑터인 것이다.</p><p>이때 펑터가 카테고리를 변경하는 행위를 <code>매핑(mapping)</code>이라고 하며, 조금 더 자세히 말해 카테고리에 함수를 적용하여 다른 카테고리로 변경하는 행위라고 할 수도 있다.</p><p>이렇게 추상적인 개념을 가진 펑터이기에, 누구는 펑터를 이래서 쓴다, 누구는 펑터를 저래서 쓴다와 같이 이야기가 전부 다른 것이다. 사실 펑터 자체는 그저 매핑이라는 행위를 할 수 있는 무언가에 불과하기 때문에 펑터를 어떤 방식으로 응용하냐에 따라 그 사용 방법 또한 무궁무진하다.</p><p>사실 펑터라는 개념 자체는 특정 메소드를 통해 펑터 내부의 값을 변경할 수 있도록 만들어주기만 하면 되기 때문에 프로그래밍으로 표현하는 것이 그렇게 어렵지는 않다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> Functor<T> {</span><br><span class="line">  map<U><span class="hljs-function">(<span class="hljs-params">f: (<span class="hljs-params">x: T</span>) => U</span>): <span class="hljs-params">Functor</span><<span class="hljs-params">U</span>></span></span><br><span class="line"><span class="hljs-function">}</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Function<T></code>: 이 펑터는 <code>T</code> 타입의 값을 가지고 있다.<br><code>map<U></code>: 이 펑터의 사상을 적용하면 <code>U</code> 타입의 값을 가진 새로운 펑터를 얻는다.<br><code>f: (x: T) => U</code>: 이 펑터의 사상이 작동하는 방식은 <code>T</code> 타입의 값을 입력으로 받아 <code>U</code> 타입의 값을 출력하는 것이다.</p></blockquote><p><code>map</code> 메소드는 인자로 받은 <code>(x: T) => U</code> 꼴의 함수를 펑터 내부의 값에 적용하고, 변경된 값을 감싸고 있는 새로운 펑터를 반환한다.</p><p>결국 <code>map</code> 메소드에 인자로 넘기는 이 함수가 실질적으로 펑터 내부의 값을 변경하는 역할을 하는 것이며, 값을 실질적으로 변경하는 역할을 하는 이 함수를 <code>트랜스폼(Transform)</code> 함수라고 부른다.</p><p>매핑을 하고 난 뒤 변경된 값 자체가 아니라 변경된 값을 감싸고 있는 펑터가 반환되는 이유는 펑터라는 것이 본질적으로 <code>카테고리 -> 카테고리</code>로 변경하는 구조체일 뿐, 카테고리를 부숴버리고 내부에 있는 대상을 꺼내는 역할을 하는 게 아니기 때문이다.</p><p>그리고 펑터는 단지 새로운 카테고리를 표현하는 수단이기 때문에 기존 카테고리의 대상을 변경해서는 안된다. 그렇기 때문에 기존 펑터의 값을 업데이트하는 것이 아니라 변경된 값을 담고 있는 새로운 펑터를 생성해서 반환해야하는 것이다.</p><p>이 개념이 약간 혼란스럽게 느껴진다면 <code>Array.prototype.map</code> 메소드를 생각해보자. 잘 생각해보면 배열도 어떠한 박스 안에 값을 담고 있는 일종의 펑터라고 할 수 있다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Functor<number></span></span><br><span class="line"><span class="hljs-keyword">const</span> array: <span class="hljs-built_in">Array</span><<span class="hljs-built_in">number</span>> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 트랜스폼 함수: (x: number) => string</span></span><br><span class="line"><span class="hljs-keyword">const</span> toString = <span class="hljs-function"><span class="hljs-params">v</span> =></span> v.toString();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 매핑!</span></span><br><span class="line">array.map(toString);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 새로운 펑터 Functor<string></span></span><br><span class="line">[<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>]</span><br></pre></td></tr></tbody></table></figure><p>우리는 트랜스폼 함수인 <code>toString</code> 함수를 사용하여 배열이라는 펑터 내부의 값을 변경할 수는 있지만, 배열이라는 박스 자체를 없애버리지는 않는다.</p><p>일반적으로 우리가 자주 사용하는 <code>map</code>이라는 메소드가 <code>Array</code>에 물려있기 때문에 매핑이라는 행위를 이터레이션과 연결지어 생각하기 쉬운데, 매핑은 그렇게 구체적인 행위가 아니다.</p><p>뭐 <code>map</code> 메소드 내부에서 이터레이션을 돌던 북을 치던 브레이크댄스를 추던 최종적으로 <code>Functor<T> -> Functor<U></code>라는 변환만 수행할 수 있으면 되는 것이다. 이제 펑터가 어떤 느낌으로 돌아가는 개념인지 살짝 감을 잡을 수 있을 것이다.</p><p>자, 이제 펑터를 직접 구현해볼 시간이다. 펑터라는 게 워낙 추상적인 개념인 만큼 어떻게 응용하냐에 따라 무궁무진한 펑터를 만들 수 있지만, 이미 포스팅이 꽤나 길어졌기 때문에 많은 펑터를 선보이기는 힘들 것 같다. 그리고 펑터를 사용한 구현체들은 다른 분들이 작성해주신 포스팅에도 많으니 궁금하신 분들은 그 쪽을 참고해보도록 하자.</p><p>이 포스팅에서는 가장 간단한 형태의 펑터인 <code>Just</code> 펑터와 <code>Nothing</code> 펑터를 만들어보고, 이 두 펑터를 조합하여 값의 유무로 인한 사이드 이펙트를 관리할 수 있는 <code>Maybe</code> 펑터만 만들어보도록 하겠다.</p><h3 id="Just"><a href="#Just" class="headerlink" title="Just"></a>Just</h3><p><code>Just</code> 펑터는 아무런 추가적인 기능없이 값을 그냥 감싸고 있기만 하고 <code>map</code> 메소드를 통해서 그 값을 변경할 수 있는 펑터이다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Just<T> <span class="hljs-keyword">implements</span> Functor<T> {</span><br><span class="line">  value: T;</span><br><span class="line">  <span class="hljs-keyword">constructor</span> (<span class="hljs-params">value: T</span>) {</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = value;</span><br><span class="line">  }</span><br><span class="line">  map<U> <span class="hljs-function">(<span class="hljs-params">f: (<span class="hljs-params">x: T</span>) => U</span>) {</span></span><br><span class="line"><span class="hljs-function">    <span class="hljs-params">return</span> <span class="hljs-params">new</span> <span class="hljs-params">Just</span><<span class="hljs-params">U</span>>(<span class="hljs-params">f(<span class="hljs-params"><span class="hljs-keyword">this</span>.value</span>)</span>);</span></span><br><span class="line"><span class="hljs-function">  }</span></span><br><span class="line"><span class="hljs-function">}</span></span><br></pre></td></tr></tbody></table></figure><p><code>Just</code>는 자신 내부에 값을 가지고 있는 단순한 펑터이다. 이 펑터의 <code>map</code> 메소드를 사용한다는 것은 펑터가 가지고 있는 <code>T</code> 타입의 값을 <code>U</code> 타입의 값으로 변경하고, 이 값을 다시 새로운 <code>Just</code> 펑터에 감싸서 반환하는 것을 의미한다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">new</span> Just(<span class="hljs-number">3</span>)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">v</span> =></span> v + <span class="hljs-number">1000</span>)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">v</span> =></span> v.toString)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">v</span> =></span> v.length);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Just { <span class="hljs-attr">value</span>: <span class="hljs-number">4</span> }</span><br></pre></td></tr></tbody></table></figure><h3 id="Nothing"><a href="#Nothing" class="headerlink" title="Nothing"></a>Nothing</h3><p><code>Nothing</code> 펑터는 이름 그대로 내부에 어떠한 값도 가지고 있지 않은 펑터를 의미한다. 그리고 펑터 내부에 값이 없으니 트랜스폼 함수를 적용할 수도 없으므로 이 펑터의 <code>map</code> 메소드는 아무 행동도 하지 않고 그대로 <code>Nothing</code> 펑터를 반환하기만 한다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Nothing <span class="hljs-keyword">implements</span> Functor<<span class="hljs-literal">null</span>> {</span><br><span class="line">  map () {</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Nothing();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">new</span> Nothing().map().map().map();</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nothing {}</span><br></pre></td></tr></tbody></table></figure><p>굳이 이렇게 값의 유무를 표현하는 펑터가 필요한 이유는 무엇일까?</p><p>한번 펑터를 사용하여 함수를 합성하기 시작하면 그 연산 과정에서 필요한 모든 값들 또한 펑터로 감싸져 있어야하기 때문이다. 만약 펑터로 감싸진 값에 그냥 함수를 적용하려고 하면 당연히 에러가 발생한다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Just(<span class="hljs-number">3</span>);</span><br><span class="line">foo + <span class="hljs-number">2</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Operator <span class="hljs-string">'+'</span> cannot be applied to types <span class="hljs-string">'Just<number>'</span> and <span class="hljs-string">'number'</span>.</span><br></pre></td></tr></tbody></table></figure><p>그렇기 때문에 한번 펑터를 사용하여 함수를 합성하기 시작했다면 합성이 끝날 때까지 계속 펑터를 사용해야한다. 애초에 펑터를 사용하는 이유는 함수를 합성하는 동안 타입 안정성을 유지하고 사이드 이펙트를 관리하기 위해서인데, 이 과정에서 펑터가 아닌 녀석이 하나라도 끼어들게 되면 합성한 연산 전체의 안정성을 보장할 수 없기 때문이다. <small>(미꾸라지 한 마리가 물을 흐린다)</small></p><p>이렇게 들으면 뭔가 불편하다고 느껴질 수도 있지만 아까 위에서 대표적인 펑터라고 이야기했던 <code>Array</code>를 사용하는 경우를 생각해보면 이게 그렇게 특이한 개념이 아니라는 사실을 알 수 있다.</p><p>만약 <code>new Array(3)</code>이라는 배열이 있을 때 이 배열이 가지고 있는 값에 2를 더하고 싶다면 어떻게 해야할까? 단, 함수형 프로그래밍의 세계에서는 상태의 변경을 허용하지 않으므로 <code>new Array(3)[0] += 2</code>와 같은 개념으로 접근해서는 안된다는 사실을 잊지말자.</p><p>즉, 불변성을 중시하는 함수형 프로그래밍의 세계에서 배열 내부의 값을 변경하고 싶다면, “변경된 값을 가지고 있는 새로운 배열”을 생성할 수 밖에 없다.</p><p>그래서 우리는 불변성을 지키며 배열 내부의 값을 변경하기위해 무조건 <code>map</code>이라는 메소드를 사용해야하는 것이다. 이제 펑터의 <code>map</code> 메소드가 왜 값을 변경한 후 새로운 펑터를 생성해서 반환하는지 조금은 이해가 갈 거라고 생각한다.</p><h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><p>자, 여기까지 이해했다면 조금 더 복잡한 펑터를 만들어보도록 하자. <code>Maybe</code>라는 펑터의 <code>map</code> 메소드는 펑터 내부에 값이 있다면 인자로 받은 함수를 값에 적용하고, 값이 없다면 값이 없음을 의미하는 펑터인 <code>Nothing</code> 펑터를 반환하는 펑터이다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Maybe<T> <span class="hljs-keyword">implements</span> Functor<T> {</span><br><span class="line">  value: Just<T> | Nothing;</span><br><span class="line">  <span class="hljs-keyword">constructor</span> (<span class="hljs-params">value?: T</span>) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (value) {</span><br><span class="line">      <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">new</span> Just<T>(value);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">else</span> {</span><br><span class="line">      <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">new</span> Nothing();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  map<U> <span class="hljs-function">(<span class="hljs-params">f: (<span class="hljs-params">x: T|<span class="hljs-literal">null</span></span>) => U</span>) {</span></span><br><span class="line"><span class="hljs-function">    <span class="hljs-params">if</span> (<span class="hljs-params"><span class="hljs-keyword">this</span>.value <span class="hljs-keyword">instanceof</span> Just</span>) {</span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-params">return</span> <span class="hljs-params">this</span>.<span class="hljs-params">value</span>.<span class="hljs-params">map</span><<span class="hljs-params">U</span>>(<span class="hljs-params">f</span>);</span></span><br><span class="line"><span class="hljs-function">    }</span></span><br><span class="line"><span class="hljs-function">    <span class="hljs-params">else</span> {</span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-params">return</span> <span class="hljs-params">new</span> <span class="hljs-params">Nothing</span><span class="hljs-params">()</span>;</span></span><br><span class="line"><span class="hljs-function">    }</span></span><br><span class="line"><span class="hljs-function">  }</span></span><br><span class="line"><span class="hljs-function">}</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> getFirstLetter = <span class="hljs-function"><span class="hljs-params">s</span> =></span> s[<span class="hljs-number">0</span>];</span><br><span class="line"><span class="hljs-keyword">const</span> getStringLength = <span class="hljs-function"><span class="hljs-params">s</span> =></span> s.length;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Maybe(<span class="hljs-string">'hi'</span>)</span><br><span class="line">  .map(getFirstLetter)</span><br><span class="line">  .map(getStringLength);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> bar = <span class="hljs-keyword">new</span> Maybe(<span class="hljs-string">''</span>)</span><br><span class="line">  .map(getFirstLetter)</span><br><span class="line">  .map(getStringLength);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// Just { value: 1 }</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(bar); <span class="hljs-comment">// Nothing {}</span></span><br></pre></td></tr></tbody></table></figure><p><code>Maybe</code> 펑터를 사용하면 우리는 중간에 <code>null</code>이나 <code>undefined</code>가 반환되어 함수의 합성이 깨져버리는 걱정 없이 안심하고 함수를 합성할 수 있다.</p><p>물론 최종적으로 연산 결과가 <code>Just</code>인지 <code>Nothing</code>인지 구분하려면 <code>if</code> 문을 통해서 조건 검사를 해야하기는 하지만, 적어도 함수를 합성하는 중간중간마다 검사하지는 않는다. 즉, 함수를 합성할 때는 합성에만 집중할 수 있다는 뜻이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 펑터가 없다면 함수를 함부로 합성할 수 없다</span></span><br><span class="line"><span class="hljs-keyword">const</span> firstLetter = getFirstLetter(<span class="hljs-string">''</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (firstLetter) {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(getStringLength(firstLetter));</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">else</span> {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'함수 합성 실패'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Maybe 펑터를 사용하면 마음놓고 합성이 가능하다</span></span><br><span class="line"><span class="hljs-keyword">const</span> result =</span><br><span class="line">  <span class="hljs-keyword">new</span> Maybe(<span class="hljs-string">''</span>)</span><br><span class="line">  .map(getFirstLetter)</span><br><span class="line">  .map(getStringLength);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> Just) {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(result);</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">else</span> {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'함수 합성 실패'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>이렇게 단순히 값을 감싸고, 내부에 있는 값을 변경할 수 있다는 단순한 개념만으로 우리는 함수의 안전한 합성을 할 수 있게 되었다.</p><p>이 포스팅에서는 값의 유무로 인한 사이드 이펙트를 관리할 수 있는 <code>Maybe</code> 펑터 만을 예시로 들었지만, 여러 번 이야기 했듯이 펑터는 그냥 값을 감싸고 있는 박스이기 때문에 어떤 로직을 구현하냐에 따라 천차만별로 다른 펑터를 만들어낼 수 있다.</p><p>예를 들면 현재에는 아직 값이 없지만 미래에 값이 결정되는 것을 약속해주는 <code>Promise</code> 같은 개념도 일종의 펑터라고 볼 수 있고, 여러 개의 값을 순차적으로 저장할 수 있는 <code>Array</code>도 일종의 펑터라고 할 수 있다.</p><p>펑터라는 것은 추상적인 개념일 뿐이지 구체적으로 특정 로직만을 수행하는 구현체가 아니라는 말이다. 말 그대로 코에 붙히면 코걸이고 귀에 붙히면 귀걸이기 때문에 단순히 뭔가로 값을 감싸고 그 값을 변환할 수 있다는 개념만으로도 마음껏 상상의 나래를 펼치며 다양한 펑터 구현체들을 만들어낼 수 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이 포스팅을 읽는 독자 분들 중 펑터에 대한 설명을 읽으면서 “어? 이거 모나드 아닌가?”라고 하신 분들도 있을 것이라 생각한다.</p><p>정확히 말하면 반은 맞고 반은 틀리다. 모나드도 결국 함수를 안전하게 합성하기 위한 펑터의 한 종류이기 때문이다. 간단하게 말하면 모나드라는 것은 수학적으로 특별한 몇 가지 조건을 만족시키는 두 개의 펑터 사이의 사상이라고 할 수 있다.</p><p>어플리케이티브 펑터나 모나드를 이 포스팅에서 따로 설명하지는 않았지만, 뭐 원리가 어쩌고 저쩌고를 떠나서 그냥 이런 개념들을 추가적으로 사용하는 이유는 그냥 딱 한 가지 밖에 없다.</p><blockquote><p>어 뭐여…? 펑터로도 해결이 안되네…?</p></blockquote><p>함수의 안전한 합성이라는 목표를 이루기 위해 펑터를 사용했지만 사실 프로그래밍을 하다보면 펑터로 해결이 안되는 케이스도 수두룩하기 때문이다. 뭐 펑터로 여러 번 감싸져 있는 값에 매핑해야한다거나 하는 케이스말이다. 이런 경우에는 펑터의 매핑만으로는 함수를 합성할 수 없다.</p><p>결국 어플리케이티브 펑터나 모나드는 펑터로도 해결되지 않는 예외 상황들까지 모두 커버할 수 있도록 더 추상적이고 강력하게 만든 펑터라고 생각하면 된다.</p><p>사실 이번 포스팅에서 모나드의 개념까지 설명을 해보려고 했지만, 이 포스팅에서 펑터를 설명했던 방식으로 모나드를 설명하기 위해서는 개요 수준의 카테고리 이론이 아니라 조금 더 깊숙한 설명이 필요하기 때문에 포기했다. <small>(모나드는 다음 포스팅에서 한 번 조져보겠다)</small></p><p>물론 함수의 합성과 펑터와의 관계를 파악하는 것은 꽤나 추상적인 개념이기 때문에 이해하기에 조금 어렵긴 하다. 그런 이유로 어떤 개발자들은 펑터와 모나드의 사용 방법 정도만 익히고 프로그래밍하기도 하지만, 개인적으로는 이러한 개념들이 왜 사용되는 것인지, 어디서 아이디어를 얻은 것인지 알고 있다면 프로그래밍이 더 재밌어지지 않을까라는 생각이 든다.</p><p>이상으로 어떻게 하면 안전하게 함수를 합성할 수 있을까? 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2020/01/27/safety-function-composition/#disqus_thread</comments>
    </item>
    
    <item>
      <title>변하지 않는 상태를 유지하는 방법, 불변성(Immutable)</title>
      <link>https://evan-moon.github.io/2020/01/05/what-is-immutable/</link>
      <guid>https://evan-moon.github.io/2020/01/05/what-is-immutable/</guid>
      <pubDate>Sun, 05 Jan 2020 14:48:21 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;이번 포스팅에서는 순수 함수에 이어 함수형 프로그래밍에서 중요하게 여기는 개념인 &lt;code&gt;불변성(Immutable)&lt;/code&gt;에 대한 이야기를 해보려고 한다.&lt;/p&gt;
&lt;p&gt;사실 순수 함수를 설명하다보면 불변성에 대한 이야기가 꼭 한번은 나오게 되는데, 대부분 “상태를 변경하지 않는 것”이라는 짧은 정의로 설명하거나, 혹은 불변성을 해치는 행위들을 예시로 들고 이런 행위들을 금지 행위로 규정하며 설명을 진행하게된다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>이번 포스팅에서는 순수 함수에 이어 함수형 프로그래밍에서 중요하게 여기는 개념인 <code>불변성(Immutable)</code>에 대한 이야기를 해보려고 한다.</p><p>사실 순수 함수를 설명하다보면 불변성에 대한 이야기가 꼭 한번은 나오게 되는데, 대부분 “상태를 변경하지 않는 것”이라는 짧은 정의로 설명하거나, 혹은 불변성을 해치는 행위들을 예시로 들고 이런 행위들을 금지 행위로 규정하며 설명을 진행하게된다.</p><a id="more"></a><p>그러나 개인적으로 이런 설명 방식은 상태와 메모리에 대한 개념이 확실하게 정립되지 않은 사람에게 별로 와닿지 않는 방식일 수도 있다고 생각한다. 그래서 이번 포스팅에서는 정확히 <code>불변</code>이라는 것이 무엇을 의미하는지에 대한 이야기를 해보려고 한다.</p><h2 id="순수-함수와-불변성은-무슨-관계인가요"><a href="#순수-함수와-불변성은-무슨-관계인가요" class="headerlink" title="순수 함수와 불변성은 무슨 관계인가요?"></a>순수 함수와 불변성은 무슨 관계인가요?</h2><p>저번에 작성했던 <a href="/2019/12/29/about-pure-functions/" title="수학에서 기원한 프로그래밍 패러다임, 순수 함수">수학에서 기원한 프로그래밍 패러다임, 순수 함수</a>에서 한 번 이야기 했듯이, 순수 함수는 수학의 함수를 프로그래밍의 세계로 가져온 모델이다.</p><p>프로그래밍의 세계에는 무언가를 저장하고 변경하고 불러올 수 있는 상태라는 개념이 존재하지만, 수학의 세계에는 그런 개념이 없기 때문에 모든 함수는 함수 외부의 무언가에 절대 영향을 받지 않고 독립적으로 존재한다.</p><p>그렇기 때문에 상태라는 개념 자체가 존재하지 않는 수학의 함수를 프로그래밍으로 구현한 모델인 순수 함수 또한 함수 외부의 상태에 영향을 받지 않아야한다는 규칙을 가질 수 밖에 없는 것이다.</p><p>또한 수학의 세계에는 상태라는 개념이 없기에 당연히 상태를 변경한다는 개념도 없을 수 밖에 없고, 우리는 이를 <code>불변성(Immutable)</code>이라고 부른다.</p><p>하지만 프로그래밍의 세계에서 상태를 변경하지 않는다는 것은 꽤나 신경을 많이 써줘야 하는 일이다. 그래서 우리는 “변수에 값을 재할당하지 않는다”와 같은 몇 가지 규칙들을 정해놓고 프로그래밍을 하면서 불변성을 유지한다.</p><p>하지만 프로그램에서 <code>변이(Mutation)</code>가 발생하는 근본적인 원인을 파악하고 불변성을 스스로 지켜나간다면, 이러한 규칙들이 커버할 수 없는 변태같은 상황을 마주치더라도 대응할 수 있기 때문에 우리는 <code>불변(Immutation)</code>이 정확히 무엇을 의미하는 지 알아야 할 필요가 있다.</p><h2 id="불변성이란"><a href="#불변성이란" class="headerlink" title="불변성이란?"></a>불변성이란?</h2><p>보통 불변성의 의미는 <code>상태를 변경하지 않는 것</code>이라는 간단한 정의로 설명된다.</p><p>그러나 대부분 불변성에 대한 설명을 할 때, “함수 외부의 변수에 접근, 재할당해서는 안된다”, “함수의 인자를 변경하면 안 된다”와 같이 상태를 변경하는 행위를 금지하는 예시 정도만 설명하고, 상태를 변경한다는 것이 정확히 무엇을 의미하는지는 자세히 설명하지 않는다.</p><p>그래서 이런 설명 방식은 상태를 변경한다는 것이 정확히 어떤 의미인지 모르는 사람에게는 잘 와닿지 않을 수 있다고 생각한다.</p><p>그렇다면 불변성이 이야기하고 있는 <code>상태의 변경</code>이라는 것이 정확히 어떤 행위를 의미하는 것일까? 단순히 프로그램의 변수를 변경하거나 재할당 하지 않는 것을 이야기하는 것일까?</p><p>사실 불변성이 이야기하는 상태의 변경이라는 것은 단순한 변수의 재할당을 이야기하는 것이 아니다. 정확히 말하면 메모리에 저장된 값을 변경하는 모든 행위를 의미하며, 여기에 변수의 재할당과 같은 행위도 포함되는 것이다.</p><p>즉, 상태의 변경이라는 행위를 제대로 이해하기 위해서는 컴퓨터가 값을 어떤 방식으로 메모리에 저장하고 접근하는지에 대한 간단한 지식이 필요하다.</p><h3 id="우리는-변수를-통해-메모리에-접근한다"><a href="#우리는-변수를-통해-메모리에-접근한다" class="headerlink" title="우리는 변수를 통해 메모리에 접근한다"></a>우리는 변수를 통해 메모리에 접근한다</h3><p>대부분의 프로그래밍 언어에서는 메모리의 특정 공간에 저장된 값에 조금 더 쉽게 접근할 수 있도록 도와주는 변수라는 기능을 제공하고 있다.</p><p>변수라는 개념은 프로그래밍을 배울 때 가장 처음 배우는 것이기 때문에, 개발자라면 누구나 다 알고 있는 개념일 것이다. 한번 간단한 변수를 선언해보도록 하자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> a;</span><br><span class="line">a = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(a);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span></span><br></pre></td></tr></tbody></table></figure><p>필자는 <code>a</code>라는 변수를 “선언”하고, 그 다음 라인에서 <code>a</code> 변수에 <code>1</code>이라는 값을 “할당”했다.</p><p>일반적으로는 <code>let a = 1;</code>와 같이 선언과 동시에 할당을 진행하지만, 엄밀히 말해서 선언과 할당은 다른 행위이기에 조금 더 편한 이해를 위해 코드를 나눠서 작성했다.</p><p><code>let a;</code>라는 명령을 사용하여 변수를 선언하면 자바스크립트는 메모리에 <code>a</code>라는 변수를 통해 접근할 수 있는 메모리 공간을 마련한다. 필자는 변수를 선언만 하고 값을 할당하지 않았으니 이때 <code>a</code> 변수에 접근하려 한다면, “아무것도 정의되지 않았다”라는 의미의 <code>undefined</code>를 뱉어낼 것이다.</p><p>그 후 필자는 <code>a = 1</code>이라는 명령을 사용하여 마련된 메모리 공간에 <code>1</code>이라는 값을 저장했고, 그 이후부터 필자가 <code>a</code>라는 변수를 통해 해당 메모리 공간에 접근하면 저장되어 있던 <code>1</code>이라는 값을 얻어낼 수 있는 것이다.</p><center><br>  <img src="/2020/01/05/what-is-immutable/memory-value.png" width="500"><br>  <br><br></center><p>즉, 변수라는 것은 메모리에 저장되어 있는 어떠한 값에 접근하는 일종의 단축어같은 개념이며, 만약 변수가 없다면 우리는 일일히 <code>0x0018fa</code>와 같은 메모리 주소를 사용하여 메모리에 값을 저장할 공간을 마련하고 값을 저장하거나 접근해야한다는 것이다.</p><p>만약 필자가 <code>a = 2</code>처럼 해당 변수의 값을 다시 할당한다면, <code>0x0018fa</code>라는 주소를 가진 메모리 공간에 저장되어 있는 값을 변경하는 것이며, 상태를 변경하는 행위라고 말할 수 있는 것이다.</p><p>자바스크립트는 재할당 할 수 있는 변수를 선언하는 <code>let</code> 키워드와 재할당 할 수 없는 <code>const</code> 키워드를 구분하여 제공함으로써 개발자가 실수로 메모리 공간에 저장되어있는 값을 변경하는 행위를 방어할 수 있는 기능을 제공한다.</p><p>그렇다면 우리가 변수를 재할당하지만 않는다면 불변이라는 개념을 지킬 수 있는 것일까?</p><center><br>  <img src="/2020/01/05/what-is-immutable/nope.jpg" width="300"><br>  <br><br></center><p>슬프게도 그렇지 않다. 프로그램이 변수가 가리키고 있는 메모리 공간에 있는 값을 불러오고 사용하는 방법은 그렇게 단순하지 않기 때문이다.</p><p>바로 여기서 그 유명한 <code>값에 의한 호출(Call by value)</code>과 <code>참조에 의한 호출(Call by reference)</code>이 등장한다.</p><h3 id="값에-의한-호출과-참조에-의한-호출"><a href="#값에-의한-호출과-참조에-의한-호출" class="headerlink" title="값에 의한 호출과 참조에 의한 호출"></a>값에 의한 호출과 참조에 의한 호출</h3><p>값에 의한 호출과 참조에 의한 호출은 특정 컨텍스트에서 다른 컨텍스트에게 변수를 넘길 때 어떤 방식으로 값을 넘겨줄 것인지에 대한 방법들이다.</p><p>이렇게 컨텍스트 간 변수를 넘기는 상황은 함수 외부의 스코프에서 함수에게 인자를 넘겨주는 상황으로 많이 표현되며, 또 실제로도 그런 상황이 대부분이다.</p><p>이에 대해서 조금 더 쉽게 알아보기 위해 간단한 함수를 선언해보도록 하겠다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">s</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>foo</code> 함수는 문자열을 인자로 받아서 가장 앞의 두 글자만 잘라내어 반환하는 순수 함수이다. 즉, <code>foo</code> 함수는 자신의 인자로 받은 값을 재료로 하여 자신의 반환 값을 만들어내는 셈이다.</p><p>그럼 <code>foo</code> 함수를 한번 사용해보도록 하자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'Hello, World!'</span>;</span><br><span class="line">foo(str);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">He</span><br></pre></td></tr></tbody></table></figure><p><code>foo</code> 함수는 자신의 인자로 받은 문자열을 잘라서 반환하기 때문에, 마치 인자로 받은 <code>str</code> 변수를 직접 수정하는 것처럼 보인다.</p><p>하지만 <code>foo</code> 함수의 인자로 사용했던 <code>str</code> 변수를 콘솔에 출력해보면 처음 필자가 할당했던 값인 <code>Hello, World!</code>가 그대로 저장되어 있는 것을 확인할 수 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(foo(str));</span><br><span class="line"><span class="hljs-built_in">console</span>.log(str);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">He</span><br><span class="line">Hello, World!</span><br></pre></td></tr></tbody></table></figure><p>이게 어떻게 된 것일까? 정답은 <code>str</code> 변수의 자료형인 <code>string</code>형의 호출 방식이 <code>값에 의한 호출</code> 방식을 사용하기 때문이다.</p><p>자바스크립트에서 <code>string</code>, <code>number</code>, <code>boolean</code>과 같이 원시 자료형을 사용하는 변수들은 모두 값에 의한 호출 방식을 사용한다.</p><p>값에 의한 호출 방식은 함수의 인자로 어떤 변수를 넘길 때 해당 변수가 가지고 있는 값을 그대로 복사하여 함수에게 넘겨주는 방식을 의미하기 때문에, 기존에 <code>str</code> 변수가 가리키고 있는 메모리 공간에 있는 값을 함수에 인자로 넘기는 것이 아니라 그 값을 복사하여 새로운 메모리 공간에 저장하고나서 넘겨준다는 뜻이다.</p><center><br>  <img src="/2020/01/05/what-is-immutable/call-by-value.png" width="500"><br>  <br><br></center><p>결국 <code>foo(str)</code>라는 코드로 함수를 호출하며 인자로 넘긴 <code>str</code>이라는 변수가 가지고 있는 값과, <code>foo</code> 함수 내부에서 <code>s</code>라는 변수를 통해 접근하는 값은 전혀 다른 메모리 공간에 저장되어 있는 새로운 값이다.</p><p>그렇기 때문에 <code>foo</code> 함수가 아무리 자신의 인자로 받은 변수를 지지고 볶아도 원본 변수는 절대로 영향을 받지 않는다. 심지어 <code>foo</code> 함수 내부에서 <code>s</code> 변수를 재할당하더라도 원본 변수에 담겨져 있는 값은 변하지 않는다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'Hello, World!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">s</span>) </span>{</span><br><span class="line">  s = <span class="hljs-string">'재할당합니다'</span>;</span><br><span class="line">  <span class="hljs-keyword">return</span> s.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo(str);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(str);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></tbody></table></figure><p><code>foo</code> 함수는 인자로 넘어온 변수에 값을 재할당했음에도 함수 외부에 있는 <code>str</code> 변수의 값은 변하지 않았다.</p><p>즉, 불변성을 유지한다는 것은 단순히 “함수의 인자를 변경하지 않는다”라던가 “변수를 재할당하지 않는다”는 개념이 아닌 것이다. 포인트는 메모리에 이미 담겨있는 값을 변경하지 않는 것이다.</p><p>반면 값에 의한 호출 방식을 사용하지 않는 <code>Array</code>, <code>Object</code>와 같은 객체들은 조금 상황이 다르다.</p><p>이번에는 인자로 배열을 받은 후 그 배열에 <code>hi</code>라는 문자열 원소를 추가하는 간단한 함수를 선언하고, 어떤 결과가 나오는지 살펴보도록 하겠다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span> (<span class="hljs-params">a</span>) </span>{</span><br><span class="line">  a.push(<span class="hljs-string">'hi'</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> arr;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>원시 자료형이었던 <code>str</code> 변수는 값에 의한 호출 방식을 사용하지만, 객체인 <code>Array</code>는 참조에 의한 호출 방식을 사용한다. 그럼 함수를 사용해보고 원본 변수가 어떻게 되는지 확인해보자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> array = [];</span><br><span class="line">bar(array);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(array);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="hljs-string">'hi'</span>]</span><br></pre></td></tr></tbody></table></figure><p>함수 내부에서 인자를 지지고 볶아도 원본 변수에는 전혀 영향이 없었던 <code>foo</code> 함수와 다르게, 이번에는 <code>bar</code> 함수의 인자로 넘겼던 <code>array</code> 변수의 값이 변경된 것을 확인해볼 수 있다.</p><p>함수의 인자로 변수를 넘길 때 값을 복사하여 새로운 공간에 저장한 후 넘겨주는 값에 의한 호출 방식과 다르게, 참조에 의한 호출 방식은 “변수가 가리키고 있는 메모리 공간의 주소”를 넘기는 방식이다.</p><p>즉, <code>array</code> 변수가 가리키고 있는 메모리 공간에 저장된 배열과 <code>bar</code> 함수가 인자로 받은 배열은 정확히 같은 메모리 공간에 저장되어 있는, “같은 배열” 이라는 것이다.</p><center><br>  <img src="/2020/01/05/what-is-immutable/call-by-reference.png" width="500"><br>  <br><br></center><p>즉, <code>bar</code> 함수의 인자로 받은 배열은 참조에 의한 호출 방식을 사용하는 객체이기 때문에, 함수 내에서 이 배열을 지지고 볶아 버린다면 원본 배열 자체가 지지고 볶아지는 것이다.</p><p>이 경우에는 메모리 공간에 저장되어있던 배열을 직접 변경해버리는 것이므로, 상태가 변경되었다고 말할 수 있고, 불변성이 깨져버린 것이다.</p><p>똑같이 함수의 내부에서 인자를 수정하는 행위지만 인자가 값에 의한 호출 방식을 사용하는 자료형인지 참조에 의한 호출 방식을 사용하는 자료형인지에 따라 결과는 큰 차이가 나기 때문에, 불변성을 지키고 싶다면 항상 이 점을 염두에 두고 코드를 작성해야한다.</p><h2 id="불변성을-지키면-어떤-점이-좋은가요"><a href="#불변성을-지키면-어떤-점이-좋은가요" class="headerlink" title="불변성을 지키면 어떤 점이 좋은가요?"></a>불변성을 지키면 어떤 점이 좋은가요?</h2><p>프로그래밍을 하면서 상태의 불변성을 지키려면 자연스럽게 이것저것 신경써줘야하는 것들이 늘어날 수 밖에 없다. 그럼에도 불구하고 불변이라는 개념은 현재 많은 개발자들에게 환영받고 있는 개념이라는 것이 사실이다.</p><p>도대체 상태가 변경되지 않게 함으로써 얻을 수 있는 것이 무엇이길래, 다들 이렇게 불변불변하는 것일까?</p><h3 id="무분별한-상태의-변경을-막는다"><a href="#무분별한-상태의-변경을-막는다" class="headerlink" title="무분별한 상태의 변경을 막는다"></a>무분별한 상태의 변경을 막는다</h3><p>상태는 프로그램의 현재 상황을 보여주는 좋은 역할도 하지만, 여기저기서 무분별하게 이 상태를 참조하거나 변경하는 경우, 개발자조차 현재 프로그램이 어떻게 돌아가는지 파악하기 힘든 슬픈 상황이 발생할 수도 있다.</p><p>그래서 개발자들은 상태를 변경하는 행위에 특정한 규칙과 제약을 정해서 무분별한 상태 변화를 최대한 피하고, 이런 변화를 추적할 수 있는 상황을 선호할 수 밖에 없다.</p><p>무분별한 상태 변경 때문에 프로그램이 터지게 되는 가장 대표적인 상황은 바로 “전역 변수의 남용”이다. 자바스크립트에서 전역 변수의 사용을 아예 금지하는 컨벤션을 추천하는 것도 바로 이 이유이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> greeting = <span class="hljs-string">'Hi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setName</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  name = <span class="hljs-string">'Evan'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {</span><br><span class="line">  greeting = <span class="hljs-string">'Hello'</span>;</span><br><span class="line">}, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">setName();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${greeting}</span>, <span class="hljs-subst">${name}</span>`</span>);</span><br></pre></td></tr></tbody></table></figure><p><code>greeting</code> 변수는 전역 스코프에서 선언된 전역 변수이고, <code>setName</code> 함수 내부에서도 암묵적으로 전역 변수를 선언하고 있으며, <code>setTimeout</code>의 콜백 함수 내에서도 전역 변수인 <code>greeting</code>의 값을 재할당하고 있다.</p><p>이런 상황에서는 어디서 어떤 놈이 <code>greeting</code>이라는 전역 변수의 상태를 변경했는지 추적이 거의 불가능하며, 갑자기 콘솔에 <code>Hi, Evan</code>이 아닌 <code>Get out, Evan</code>이라고 출력된다고 해도 전혀 이상할 것이 없다.</p><p>개발자가 이런 상황을 만났을 때 야근을 하는 이유는, 슬프게도 이게 버그가 아니기 때문이다. 이 코드들은 콘솔에는 어떠한 에러도 출력되지 않는 지극히 정상적인 로직이다. <small>(차라리 에러라도 나는 것이 디버깅은 더 쉽다)</small></p><p>불변성을 유지하며 순수 함수를 사용한다는 것은 함수 외부의 상태에 접근하여 이미 메모리에 할당되어 있는 값을 변경하지 않는다는 의미이므로, 이렇게 예측하지 못한 상태의 변경을 방어할 수 있다.</p><h3 id="상태의-변경을-추적하기가-쉽다"><a href="#상태의-변경을-추적하기가-쉽다" class="headerlink" title="상태의 변경을 추적하기가 쉽다"></a>상태의 변경을 추적하기가 쉽다</h3><p>일반적으로 자바스크립트의 객체의 프로퍼티나 배열의 원소를 변경해야하는 경우, 필연적으로 불변성이 깨질 수 밖에 없다.</p><p>애초에 배열이나 객체가 처음 나왔을 때, 어딘가에 구조화된 데이터를 저장해놓고 상태를 유지하고 변경해가며 사용하고자 하는 목적을 가지고 있었기 때문이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Evan'</span> };</span><br><span class="line">evan.name = <span class="hljs-string">'Not Evan'</span>; <span class="hljs-comment">// 상태 변화!</span></span><br></pre></td></tr></tbody></table></figure><p>하지만 이렇게 기존에 메모리에 저장되어있는 값을 변경하는 행위는 불변의 법칙을 정면으로 위반하는 것이기 때문에, 불변성을 유지하고 싶은 개발자는 이런 식으로 객체의 프로퍼티나 배열의 원소를 변경할 수 없다.</p><p>게다가 방금 보았던 무분별한 전역 변수의 사용과 마찬가지로 객체나 배열의 상태 변화 또한 추적할 수 없는 문제이기 때문에, 어디서 이상한 놈이 엄한 객체나 배열의 상태를 변경하여 버그가 발생하더라도 개발자가 이를 디버깅하기란 쉽지 않은 문제이다.</p><p>그렇다고 객체의 프로퍼티나 배열의 원소를 변경하지 못하도록 할 수도 없는 노릇이다. 그럼 어떻게 이 문제를 해결해야할까?</p><p>한번 객체의 프로퍼티를 변경하는 간단한 함수를 통해 객체의 프로퍼티를 변경할 때 발생하는 상태 변화의 재현과 해결 방법을 알아보도록 하자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertToJohn</span>(<span class="hljs-params">person, name</span>) </span>{</span><br><span class="line">  person.name = <span class="hljs-string">'John'</span>;</span><br><span class="line">  <span class="hljs-keyword">return</span> person;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>convertToJohn</code> 함수는 객체를 인자로 받아, 해당 객체의 <code>name</code> 프로퍼티에 <code>John</code>이라는 문자열을 할당하는 역할을 하는 함수이다. 즉, 이 함수는 객체의 상태를 변경하는 역할을 하고 있다.</p><p>일단 결론부터 이야기하자면 이 함수는 순수 함수가 아닌데, 그 이유는 함수가 참조에 의한 호출 방식을 사용하는 객체의 프로퍼티를 직접 변경하면 함수 외부에 있는 원본 객체의 상태도 변경되기 때문이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Evan'</span> };</span><br><span class="line"><span class="hljs-keyword">const</span> john = convertToJohn(evan);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(john);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span> } <span class="hljs-comment">// ?</span></span><br><span class="line">{ <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span> }</span><br></pre></td></tr></tbody></table></figure><p><code>convertToJohn</code> 함수를 사용하는 사람은 함수의 이름만 보고 “오호, 이 함수는 어떤 객체를 존 객체로 바꿔주는 함수로군?”이라고 생각하겠지만, 이 함수는 개발자 몰래 자신의 인자로 받은 객체까지 변경해버리는 나쁜 함수였다.</p><p>이렇게 의도하지않은 객체의 프로퍼티가 변경되는 것도 문제지만, 사실 더 큰 문제는 이런 상태의 변화를 전혀 추적할 수 없다는 것이다. 당장 위 예시의 <code>evan</code> 객체와 <code>john</code> 객체를 비교해보면 자바스크립트는 두 객체가 같은 객체라고 평가해버린다.</p><p>두 객체는 메모리 공간에 접근할 수 있는 변수명만 다를 뿐, 실제로는 같은 메모리 공간에 저장되어 있는 같은 객체이기 때문이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(evan === john);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">true</span></span><br></pre></td></tr></tbody></table></figure><p>이런 상황에서 개발자는 “의도하지 않은 객체의 상태 변화”와 “상태의 변화를 추적할 수 없다”는 고약한 문제를 떠안게 된다. 그렇다면 이 문제를 어떻게 해결할 수 있을까?</p><p>이 문제는 생각보다 간단하게 해결할 수 있는데, <code>name</code>을 <code>John</code>으로 가지는 객체를 그냥 새로 생성해버리면 된다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertToJohn</span> (<span class="hljs-params">person</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> newPerson = <span class="hljs-built_in">Object</span>.assign({}, person);</span><br><span class="line">  newPerson.name = <span class="hljs-string">'John'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> newPerson;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> evan = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Evan'</span> };</span><br><span class="line"><span class="hljs-keyword">const</span> john = convertToJohn(evan);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(john);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="hljs-attr">name</span>: <span class="hljs-string">'Evan'</span> }</span><br><span class="line">{ <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span> }</span><br></pre></td></tr></tbody></table></figure><p>변경된 <code>convertToJohn</code> 함수는 더 이상 인자로 받은 <code>person</code> 객체에 직접 접근해서 값을 수정하지 않는다. 다만 <code>Object.assgin</code> 메소드를 사용하여 <code>person</code> 객체와 동일한 구조를 가진 새로운 객체를 생성하고 <code>name</code> 프로퍼티를 <code>John</code>으로 변경한 후 반환할 뿐이다.</p><p>이런 과정이 너무 불편하게 느껴진다면 ES6의 <code>spread</code> 연산자를 사용하면 더 간단한 문법으로 변경할 수도 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertToJohn</span> (<span class="hljs-params">person</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> {</span><br><span class="line">    ...person,</span><br><span class="line">    name: <span class="hljs-string">'John'</span>,</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>이렇게 새로운 객체를 생성하게 되면 의도하지 않은 객체의 상태 변화도 방어할 수 있고 상태 변화를 추적할 수도 있게 된다. 왜냐하면 <code>convertToJohn</code> 함수가 뱉어낸 객체는 <code>evan</code> 객체와는 전혀 다른, 새로운 객체이기 때문이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(evan === john);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>객체의 상태를 변화시킬때, “상태가 변화된 객체”를 새로 생성한다면 우리는 이전 상태를 가진 객체와 다음 상태를 가진 객체를 비교하며 <code>false</code>가 나온다는 사실을 이용하며 객체의 상태가 변화되었음을 알 수 있는 것이다.</p><p>이런 원리는 웹 프론트엔드의 UI 라이브러리인 <code>리액트(React)</code>에서 상태의 변화를 감지하는 데에도 사용되고 있는데, 리액트는 개발자가 <code>setState</code>와 같은 메소드를 사용하여 상태를 변경했을 때 <code>Object.is</code> 메소드를 사용하여 이전 상태와 다음 상태를 비교하고 두 객체가 같지 않다고 평가되면 상태가 변이되었다고 판단하고 컴포넌트를 다시 렌더한다.</p><p>또한 상태 관리 라이브러리인 <code>리덕스(Redux)</code> 또한 동일한 원리로 상태의 변화를 판단하기 때문에, 리듀서를 작성할 때는 기존 <code>state</code> 객체의 프로퍼티를 직접 변경하지 않고 새로운 객체를 생성해서 반환해야한다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span> (<span class="hljs-params">state, action</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">switch</span> (action.type) {</span><br><span class="line">    <span class="hljs-keyword">case</span> SET_NAME:</span><br><span class="line">      <span class="hljs-keyword">return</span> {</span><br><span class="line">        ...state,</span><br><span class="line">        name: action.payload,</span><br><span class="line">      };</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>이러한 불변성의 특징들은 참조에 의한 호출을 사용하는 자료형들의 상태 변화를 쉽게 감지할 수 있도록 만들어주기 때문에 개발자가 예상하지 못하는 방향으로 버그가 발생하는 것을 어느 정도 막을 수 있다.</p><p>또한 불변성은 멀티 쓰레딩을 사용할 때도 매우 유용한데, 여러 개의 쓰레드가 한 개의 상태를 정신없이 수정하고 참조하게되면 어느 순간부터는 도대체 쓰레드가 참조한 게 어떤 값인지 파악하기가 힘들기 때문이다.</p><p>이건 마치 하나의 종이에 여러 명의 화가가 물감을 칠하면서 그림을 완성해가는 느낌이라고 할 수도 있을 것 같다. 그러나 불변성이 제대로 지켜진다면 각자 쓰레드마다 종이를 주고 그림을 그려서 제출하라는 상황과 비슷하다.</p><p>개발자는 각 쓰레드가 그림을 제출할 때마다 상태가 변경되었음을 감지할 수도 있고, 이를 이용하여 그림의 상태가 변경되는 로그를 쌓을 수도 있다. 이후 그 그림들을 어떻게 취합하던, 필요없는 그림은 버리던 그건 그 후의 문제로 분리하면 되는 것이다.</p><h2 id="현실적인-불변성의-상황"><a href="#현실적인-불변성의-상황" class="headerlink" title="현실적인 불변성의 상황"></a>현실적인 불변성의 상황</h2><p>이렇게 불변성을 지키면서 프로그래밍을 하면 상태 변화를 쉽게 추적할 수 있고 관리할 수 있다는 점에서 더할 나위 없이 좋지만, 그렇다고 해서 장점만 있는 것은 아니다.</p><p>불변성의 가장 큰 문제는 기존의 객체지향 프로그래밍과의 접점을 만들기 어렵다는 것이다.</p><p>불변성을 지향한다는 함수형 프로그래밍의 특징은 기존에 우리가 익숙하게 사용하는 객체지향 프로그래밍과는 많이 다르다.</p><p>객체지향 프로그래밍은 <code>private</code>과 같은 접근 제한자로 상태를 외부에 노출시키지 않음으로써 사용자가 단순한 인터페이스를 접할 수 있도록 하지만, 함수형 프로그래밍은 아예 프로그램의 상태를 변경하지 않는 불변성을 지향하면서 프로그램의 동작을 예측하기 쉽고 단순하게 만든다.</p><center><br>  <img src="/2020/01/05/what-is-immutable/oop_fp.png" width="500"><br>  <br><br>  <small>OOP는 변경 가능한 상태를 감추며 단순함을 만들어내지만,</small><br>  <small>FP는 아예 변경 가능한 상태를 없앰으로써 단순함을 만들어낸다</small><br>  <br><br></center><p>즉, 객체지향 프로그래밍과 함수형 프로그래밍은 상태를 바라보는 관점 자체가 다르다는 것이다. 애초에 객체지향 프로그래밍은 상태를 “잘 변경하는 것”에 초점을 맞추는 패러다임이기 때문에 불변성과는 약간 거리가 있다.</p><p>또한 아직까지 우리가 사용하는 대부분의 API나 라이브러리들은 객체지향 프로그래밍을 기반으로 설계되고 있기 때문에 우리는 객체지향 프로그래밍에서 완벽하게 독립할 수 없는 상황이다.</p><p>문제는 이렇게 객체지향 프로그래밍을 기반으로 설계된 것들을 불변의 법칙으로 관리하려면 꽤 많은 비용이 들 수도 있다는 것이다.</p><p>쉬운 이해를 위해 웹 오디오 API를 사용하여 객체를 하나 생성하고, 이 객체의 상태를 변경해야하는 상황을 살펴보도록 하자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> AudioContext();</span><br><span class="line"><span class="hljs-keyword">let</span> state = {</span><br><span class="line">  node: context.createGain(),</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>상태를 표현하기 위해 간단한 객체를 생성하고 그 안에 <code>게인 노드(GainNode)</code>를 할당했다. 게인 노드는 오디오 신호의 크기를 키웠다 줄였다 할 수 있는 값인 <code>gain</code> 프로퍼티를 가지고 있고, 개발자는 이 프로퍼티의 값을 변경함으로써 간단하게 오디오 신호를 조작할 수 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.node.gain = <span class="hljs-number">1.2</span>;</span><br></pre></td></tr></tbody></table></figure><p>그러나 이렇게 객체에 직접 접근하여 프로퍼티를 변경하는 행위는 불변성을 위배한다. 이 상황에서 불변성을 만족하기 위해서는 <code>gain</code> 프로퍼티의 값을 변경할 때마다 새로운 게인 노드 객체를 생성해줘야 하는 것이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> setGain = <span class="hljs-function">(<span class="hljs-params">value</span>) =></span> {</span><br><span class="line">  <span class="hljs-keyword">const</span> newGain = context.createGain();</span><br><span class="line">  newGain.gain = value;</span><br><span class="line">  <span class="hljs-keyword">return</span> newGain;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">state = {</span><br><span class="line">  ...state,</span><br><span class="line">  node: setGain(value),</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>물론 이렇게 불변성을 지켜주면 게인 노드의 상태 변화를 추적할 수 있다는 장점을 가지지만, 객체를 생성하는 비용이 클 경우에는 문제는 발생할 수 있다.</p><p>웹 오디오 API가 제공하는 게인 노드 객체는 멤버 변수와 메소드를 가지고 있는 엄연한 인스턴스이며, <code>{ gain: 1 }</code>처럼 간단한 프로퍼티만을 가지고 있는 객체가 아니다.</p><p>만약 인스턴스가 가지고 있는 멤버 변수와 메소드가 많거나 객체를 생성할 때 무거운 작업이 동반되어야 한다면, 프로퍼티를 변경할 때마다 객체를 생성하는 것은 퍼포먼스에 상당한 부담이 될 수도 있다.</p><p>이미 생성된 객체를 복사하는 방법도 있겠지만, 저렇게 생성자를 통해 생성된 객체는 복사한 후에 프로토타입 링크도 전부 다시 연결해줘야하기 때문에, 일반 객체를 복사하는 것에 비해 그리 가벼운 작업은 아니다.<small>(실제로 몇 번 해봤는데, 퍼포먼스가 생각보다 안 나온다)</small></p><p>이런 상황에서 섣불리 불변성을 유지한답시고 저런 코드를 작성하면 프로그램 전체의 퍼포먼스가 크게 저하될 수도 있기 때문에 각 상황에 맞는 현명한 판단이 필요하다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 이번 포스팅에서는 불변성에 대한 설명과 더불어, 일급 시민이라는 개념을 사용한 커링과 같이 기술적인 부분에 대한 이야기도 함께 하려고 했는데, 또 분량 조절에 실패해버렸다.</p><p>아무래도 요즘 관심을 많이 가지고 있는 내용이다보니 자꾸 내용이 길어지는 듯 하다.</p><p>최근 불변성이라는 키워드가 프론트엔드 쪽에서 많이 주목받고 있기는 하지만 사실 불변성이 프론트엔드에서만 주목받는 키워드는 아니다. 본래 불변성이 주목받기 시작한 이유는 변경 가능한 상태를 여러 곳에서 공유하게 됨으로써 발생하는 여러가지 문제를 해결하기 위함이었기 때문이다.</p><p>일반적으로 이런 문제는 멀티 쓰레딩과 같은 동시성 프로그래밍을 사용할 때 많이 발생했는데, 기존에는 상태에 접근할 수 있는 권한을 의미하는 일종의 <code>락(Lock)</code>을 걸어놓고 락이 풀린 상태에만 쓰레드가 상태에 접근할 수 있도록 허가하는 방식을 주로 사용했었다.</p><p>그러나 이러한 상태가 한두개도 아닐 뿐더러, 실수로 락을 잘못 걸어서 상태가 꼬여버려도 개발자가 알아차리기 힘든 것은 매한가지이기 때문에, 변경 가능한 상태를 아예 없애버리는 불변의 개념이 각광받기 시작한 것이다.</p><p>오히려 <code>Erlang</code>이나 <code>Rust</code> 같은 언어들은 자바스크립트보다 더 빡빡한 방법으로 불변성을 지원하고 있기 때문에, 이 키워드에 관심이 많으신 분들은 해당 언어를 한 번 체험해보는 것도 좋겠다는 생각이 든다. <small>(필자는 Rust를 한번 해볼까 생각 중이다)</small></p><p>하지만 자바스크립트 또한 특유의 자유로운 언어의 성격 때문에 ES5 시절부터 무분별한 상태 관리에 많은 개발자들이 고통받았었고, 점점 더 웹 프론트엔드 어플리케이션이 고도화되고 복잡한 상태 관리를 요구하게 되면서 이런 개념을 사용하게 되었다.</p><p>실제로 필자 또한 상태의 변화를 추적할 수 없는 상황에서 발생한 버그를 디버깅하느라 고생한 적이 너무나도 많았기 때문에, 이러한 불변의 개념을 처음 알았을 때 꽤나 관심있게 지켜봤던 기억이 있다.</p><p>하지만 앞서 이야기했듯이 불변성을 유지하며 프로그래밍을 한다는 것이 모든 상황에서의 정답이 될 수는 없다.</p><p>필자도 현재 작업 중인 토이 프로젝트인 <a href="https://github.com/evan-moon/simple-waveform-visualizer" target="_blank" rel="noopener">Web Audio 에디터</a>에 아무 생각없이 리덕스를 붙혔다가 위에서 이야기했던 객체 생성 비용 문제때문에 퍼포먼스가 안 나와서 고생 중이다.<small>(위에서 예로 든 상황은 필자의 경험담이었다)</small></p><p>늘 이야기하는 것이지만 모든 상황에 맞아떨어지는 절대적인 기술이라는 것은 없기 때문에, 불변성이 무조건 좋다고 이야기하기보다 그저 각 상황에 맞는 현명한 의사결정을 통해 불변성을 이용하면 된다고 생각한다.</p><p>이상으로 변하지 않는 상태를 유지하는 방법, 불변성 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2020/01/05/what-is-immutable/#disqus_thread</comments>
    </item>
    
    <item>
      <title>수학에서 기원한 프로그래밍 패러다임, 순수 함수</title>
      <link>https://evan-moon.github.io/2019/12/29/about-pure-functions/</link>
      <guid>https://evan-moon.github.io/2019/12/29/about-pure-functions/</guid>
      <pubDate>Sun, 29 Dec 2019 08:29:15 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;이전에 작성했던 &lt;a href=&quot;/2019/12/15/about-functional-thinking/&quot; title=&quot;기존의 사고 방식을 깨부수는 함수형 사고&quot;&gt;기존의 사고 방식을 깨부수는 함수형 사고&lt;/a&gt; 포스팅에 이어, 이번 포스팅에서는 함수형 프로그래밍이 지향하는 관점을 실제 프로그램에 구현하기 위해 알고 있어야하는 필수적인 개념 중 하나인 &lt;code&gt;순수 함수(Pure functions)&lt;/code&gt;에 대한 이야기를 해볼까 한다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>이전에 작성했던 <a href="/2019/12/15/about-functional-thinking/" title="기존의 사고 방식을 깨부수는 함수형 사고">기존의 사고 방식을 깨부수는 함수형 사고</a> 포스팅에 이어, 이번 포스팅에서는 함수형 프로그래밍이 지향하는 관점을 실제 프로그램에 구현하기 위해 알고 있어야하는 필수적인 개념 중 하나인 <code>순수 함수(Pure functions)</code>에 대한 이야기를 해볼까 한다.</p><a id="more"></a><p>2017년 쯤, 함수형 프로그래밍이라는 패러다임이 떠오르면서 순수 함수라는 개념 또한 함께 주목받기 시작했고, 지금도 구글에 <code>순수 함수</code>라고 검색하면 많은 개발자 분들이 순수 함수의 특징에 대한 포스팅을 작성해놓은 것을 볼 수 있다.</p><p>일반적으로 우리가 순수 함수에 대해서 공부하려고 하면 다음과 같은 두 가지 특징을 가지는 함수라고 정의하는 경우를 많이 볼 수 있다.</p><blockquote><ol><li>동일한 인풋(인자)에는 항상 동일한 결과를 내야한다.</li><li>함수 외부의 상태를 변경하거나, 외부의 상태에 영향을 받아서는 안된다.</li></ol></blockquote><p>그러나 이렇게 공부하게 되면 “순수 함수는 이런저런 특징을 가지고 있는 함수”라고 외우게 되기 쉬운데, 사실 순수 함수는 이렇게 접근할 필요가 없는, 더 심플한 개념이다.</p><p>뭐 그냥 이렇게만 외워놔도 순수 함수가 어떤 것인지 이해하고 사용하는 데는 전혀 무리가 없지만, 필자는 순수 함수의 이러한 특징이 어디서 나온 것인지, 순수 함수라는 것이 정확하게 무엇을 의미하는지에 대해 조금 더 근본적인 이야기를 해보려고 한다.</p><h2 id="순수-함수는-그냥-수학적-함수다"><a href="#순수-함수는-그냥-수학적-함수다" class="headerlink" title="순수 함수는 그냥 수학적 함수다"></a>순수 함수는 그냥 수학적 함수다</h2><p>우리가 순수 함수라고 이름을 붙히고 순수 함수의 특징은 이러이러한 것들이 있다고 공부하기 때문에 뭔가 특별한 함수인 것 같지만, 사실 순수 함수는 그냥 수학에서 사용하는 함수를 프로그래밍의 세계에 똑같이 구현해놓은 것에 불과하다.</p><p>위키 백과의 함수형 프로그래밍의 정의를 보면 이 개념에 대해 조금 더 자세하게 작성된 설명을 볼 수 있다.</p><blockquote><p><strong>함수형 프로그래밍</strong>(functional programming)은 자료 처리를 <strong>수학적 함수</strong>의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다. 명령형 프로그래밍에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다.</p><footer><strong>함수형 프로그래밍 - 위키 백과</strong><cite><a href="https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D" target="_blank" rel="noopener">원문 링크</a></cite></footer></blockquote><p>이 설명에서 가장 중요한 키워드는 바로 <code>수학적 함수</code>라는 단어이다. 우리가 이런저런 특징을 외우며 공부하는 순수 함수라는 녀석은 말 그대로 순수한 함수, 즉 수학에서 사용하는 함수를 의미하는 것이다.</p><p>우리가 수학의 세계와 프로그래밍의 세계에서 동일하게 함수라는 개념을 사용하고 있기 때문에 간혹 잊어버리긴 하지만, 사실 프로그래밍에서의 함수는 수학의 그것과는 다른 점이 상당히 많다.</p><p>그럼 수학적인 함수와 프로그래밍의 함수 간 차이점을 알아보기 위해, 수학적인 함수의 정의부터 다시 한번 확실하게 짚고 넘어가도록 하자.</p><h3 id="수학에서의-함수"><a href="#수학에서의-함수" class="headerlink" title="수학에서의 함수"></a>수학에서의 함수</h3><p>우리가 중학생 때 배웠던 함수라는 녀석은 대략 다음과 같은 정의를 가지는 개념이다.</p><blockquote><p>임의의 $x \in X$에 대하여 그에 대응하는 $y \in Y$가 <strong>유일하게 존재하는</strong> 대응 관계</p></blockquote><p>수학이라는 학문 특유의 어려워 보이는 문법을 사용하긴 했지만 뜯어보면 별 거 없다. 이 정의에서 등장하는 $X$는 정의역, $Y$는 치역이라고 하며, 각각 정의역은 함수의 <code>input</code>, 치역은 함수의 <code>output</code>에 사용될 수 있는 값의 집합이라고 생각하면 된다.</p><p>즉, 정의역은 함수의 인자로 사용되는 값들, 치역은 함수의 결과물로 사용되는 값들이라는 뜻이라고 봐도 무방하다.</p><p>하지만 이 정의에서 가장 중요한 것은 정의역이니 치역이니 하는 개념이 아니라, 함수의 인자로 사용되는 값 하나에 대응하는 함수의 결과 값이 <code>유일하게 존재한다</code>라는 개념이다.</p><p>어떤 값을 함수에 던지면 반드시 하나의 값을 반환하는 것, 이것이 본래 함수의 정의다.</p><center><br>  <img src="/2019/12/29/about-pure-functions/functions.png" width="500"><br>  <br><br>  <small>오른쪽 그림처럼 정의역의 원소에 대응하는 치역의 원소가 없거나 2개 이상인 경우는<br>함수의 정의에서 벗어나게 된다</small><br>  <br><br></center><p>조금 더 편한 이해를 위해 인자로 받은 값에 2를 곱하는 간단한 함수를 생각해보자. 우리는 이런 함수를 정의할 때 $f(x) = 2x$와 같은 식으로 나타낸다.</p><p>이제 이 함수의 인자인 $x$를 1이라고 생각해보면 우리는 $f(1) = 2 \times 1 = 2$라는 결과를 얻을 수 있다. 만약 어느 날 갑자기 $f(1) = 3$이 되어버린다면, 이 함수는 특정한 정의역의 원소에 맞대응되는 치역의 원소가 유일하지 않으므로 더 이상 함수라고 부를 수 없는 것이다.</p><p>일반적으로 이야기하는 순수 함수의 특징들은 바로 이러한 수학적 함수의 성질에서 기원한다.</p><h3 id="프로그래밍에서의-함수"><a href="#프로그래밍에서의-함수" class="headerlink" title="프로그래밍에서의 함수"></a>프로그래밍에서의 함수</h3><p>그러나 프로그래밍에서의 함수에는 이러한 제약이 전혀 없다. 이런 저런 예시를 들 것도 없이, 어떤 값도 반환하지 않는 <code>void</code>형 함수가 있지 않은가?</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">x</span>): <span class="hljs-title">void</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> y = x * <span class="hljs-number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo(<span class="hljs-number">1</span>));</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><p>수학적인 함수의 정의로 비춰볼 때 이러한 <code>void</code>형 함수는 함수가 아니다. 정의역의 원소인 <code>x</code>와 맞대응하는 치역의 원소가 없기 때문이다. 그래서 프로그래밍에서의 함수라는 개념이 수학의 함수와 약간 다르다고 이야기하는 것이다.</p><p>사실 프로그래밍의 함수는 수학의 함수에서 “어떤 값을 던져주면 뭔가를 계산한다”라는 개념만 들고 온 것에 불과하며, 수학적인 관점에서 바라보면 프로그래밍의 함수는 사실 함수가 아닌 경우가 더 많다.</p><p>무엇보다 수학의 함수와 프로그래밍에서의 함수가 가장 큰 차이를 보이는 점은 바로 함수의 동작이 일관되지 않을 수 있다는 것이다.</p><p>아까 예시로 들었던 $f(x) = 2x$라는 수학의 함수는 내부 구현이 어떻게 되어있던 항상 $x$로 1을 받으면 2를 뱉어내는 것이 보장되어 있지만, 프로그래밍에서는 그렇지 않은 함수도 얼마든지 만들어 낼 수 있다.</p><p>예를 들면 <code>Math.random</code>이라던가, <code>Date.prototype.getTime</code>과 같은 메소드들을 사용한 함수 같은 것들 말이다. 이 메소드들은 함수의 동작과 전혀 상관없는 값을 만들어내기 때문에, 함수의 연산이 이러한 값들에 종속되어 버린다면 개발자는 이 함수가 어떤 값을 뱉어낼 지 절대 예측할 수가 없다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> x + <span class="hljs-built_in">Math</span>.random();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sum(<span class="hljs-number">1</span>);</span><br><span class="line">sum(<span class="hljs-number">1</span>);</span><br><span class="line">sum(<span class="hljs-number">1</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">5</span> <span class="hljs-comment">// ?</span></span><br><span class="line"><span class="hljs-number">4</span> <span class="hljs-comment">// ?</span></span><br><span class="line"><span class="hljs-number">9</span> <span class="hljs-comment">// ?</span></span><br></pre></td></tr></tbody></table></figure><p>이런 개념은 특정한 의미를 가지는 값들을 저장, 할당, 호출할 수 있는 프로그래밍의 세계에서만 존재하는 것들이며, 수학의 세계에서는 이런 개념 자체가 없다.</p><p>이렇게 특정한 의미를 가지는 값들을 우리는 <code>상태(State)</code>라고 부른다. 상태는 프로그램의 현재 상황을 보여주는 좋은 역할도 하지만, 여기저기서 무분별하게 이 상태를 참조하거나 변경하는 경우, 개발자조차 현재 프로그램이 어떻게 돌아가는지 파악하기 힘든 슬픈 상황이 발생할 수도 있다.</p><p>그래서 개발자들은 상태를 변경하는 행위에 특정한 규칙과 제약을 정해서 무분별한 상태 변화를 최대한 피하고, 이런 변화를 추적할 수 있는 상황을 선호한다.</p><p>문제는 프로그래밍에서의 함수는 이런 상태들, 더 정확히 이야기하자면 <code>함수 외부의 상태</code>들과 뭔가 썸씽이 생기는 경우가 많다는 것이다. 여기 인자로 받은 수를 함수 외부에 선언된 변수와 더한 후 반환하는 <code>addState</code>라는 간단한 함수가 있다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> state = <span class="hljs-number">3</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addState</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> state + x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">addState(<span class="hljs-number">1</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">4</span></span><br></pre></td></tr></tbody></table></figure><p><code>addState</code> 함수는 자신 외부에 있는 <code>state</code>라는 값을 참조하여 자신이 인자로 받은 수를 더해주는 간단한 일을 한다.</p><p>즉, 이 함수의 결과 값은 함수의 외부 상태인 <code>state</code> 변수에 종속되어 있다는 것이며, 이런 상황은 프로그래머가 함수의 동작을 예측할 수 없게 만드는 위험 요소로 작용할 수 있다.</p><p>만약 다른 곳에서 <code>state</code> 변수의 값을 변경이라도 하면 상황은 더욱 꼬이기 시작할 것이다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state = <span class="hljs-number">10</span>;</span><br><span class="line">addState(<span class="hljs-number">1</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">11</span></span><br></pre></td></tr></tbody></table></figure><p>이전과 같은 함수에 같은 인자를 사용했지만, 결과값은 전혀 다르게 나왔다. 이 함수는 외부 상태의 변화에 따라 자신의 결과 값도 변경되기 때문에, 개발자는 이 함수의 동작을 전혀 예측할 수 없는 것이다.</p><p>이렇게 함수가 함수 외부 상태에 영향을 받거나, 함수 외부 상태를 직접 변경하는 행위를 <code>사이드 이펙트(Side Effect)</code>라고 하며, 사이드 이펙트를 발생시키는 함수는 프로그래머가 예측하지 못한 버그를 발생시키는 위험 요소 중 하나이다.</p><p>그런 이유로 자바스크립트와 같은 언어에서는 전역 변수의 선언 및 할당을 최대한 지양하는 컨벤션을 내놓기도 하며, React Hooks에서는 사이드 이펙트를 발생시키는 동작을 따로 구분하기 위해 <code>useEffect</code>라는 훅을 제공하기도 한다.</p><figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TestComponent</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {</span><br><span class="line">    localStorage.setItem(<span class="hljs-string">'greeting'</span>, <span class="hljs-string">'Hi'</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =></span> {</span><br><span class="line">      localStorage.removeItme(<span class="hljs-string">'greeting'</span>);</span><br><span class="line">    };</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>TestComponent<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>지금 이게 간단한 함수인데다가 의도적으로 연출한 상황이라 부자연스러워 보일 수도 있지만, 실제 어플리케이션에는 이거보다 훨씬 복잡하고 이상한 짓들을 하는 함수가 수두룩하다.</p><p>예를 들면 API 서버와 통신한 결과물을 뱉어내는 간단한 함수 또한 순수하지 않은 함수의 일종이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUsers</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">try</span> {</span><br><span class="line">    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'/api/users'</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> response.json();</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">catch</span> (e) {</span><br><span class="line">    <span class="hljs-keyword">throw</span> e;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>딱 봐도 <code>getUsers</code>는 호출할 때마다 항상 같은 값을 반환하는 함수는 아니다. 현재 데이터베이스의 상태에 따라 유저 리스트는 매번 달라질 수 있기 때문이다.</p><p>이렇게 순수하지 않은 함수는 개발자가 함수의 결과를 예측하는 것이 불가능하기 때문에, 함수의 동작을 검사하는 테스트를 작성하는 것 또한 불가능하다. 애초에 아웃풋으로 뭘 내보낼 지도 감이 안오는 변덕스러운 녀석을 어떤 기준으로 검사한단 말인가?</p><p>이렇듯 프로그래밍의 세계에서 이야기하는 함수는 수학의 함수보다 더 변수가 많고, 결과를 예측하기가 힘든 개념이다.</p><h2 id="순수한-수학적-함수로-회귀하자"><a href="#순수한-수학적-함수로-회귀하자" class="headerlink" title="순수한 수학적 함수로 회귀하자"></a>순수한 수학적 함수로 회귀하자</h2><p>자, 이제 수학의 세계에서 말하는 함수와 프로그래밍의 세계에서 말하는 함수의 차이를 살펴보았으니, 다시 순수 함수의 정의를 가져와보자.</p><blockquote><ol><li>동일한 인풋(인자)에는 항상 동일한 결과를 내야한다.</li><li>함수 외부의 상태를 변경하거나, 외부의 상태에 영향을 받아서는 안된다.</li></ol></blockquote><p>앞서 이야기 했듯이, 수학의 세계에서 함수는 단순히 인풋을 받으면 뭔가 계산을 해서 단 하나의 결과를 내는 개념이다.</p><p>그리고 수학의 세계에는 뭔가 값을 저장해놓고 할당도 하고 호출할 수도 있는 상태라는 개념이 없으니, 함수가 함수 외부 상태에 영향을 주고 받는 사이드 이펙트라는 것도 당연히 존재할 수가 없다.</p><p>즉, 수학에서의 함수를 프로그래밍에 그대로 적용하면 순수한 함수의 특성인 “함수의 결과는 함수의 인자에만 영향을 받는다”라는 조건과 “함수 외부의 상태를 변경하거나 영향을 받아선 안된다”라는 조건이 자연스럽게 충족되는 것이다.</p><p>그리고 함수형 프로그래밍에서 이야기하는 <code>불변성(immutable)</code> 또한 수학과 맞닿아 있는 지점인데, 애초에 상태라는 개념이 존재하지 않는 수학의 함수를 프로그래밍으로 구현한 순수 함수를 사용하고 있으니, 상태를 변경한다는 개념 또한 없어야 하는 것이다.</p><p>하지만 프로그래밍의 세계에는 엄연히 상태라는 개념이 존재하기 때문에, “함수의 인자를 직접 수정해서는 안된다”와 같은 제약들을 스스로 정의하고 지켜나갈 수 있도록 저런 개념을 명시적으로 이야기하는 것이다.</p><p>또한 순수 함수를 사용함으로써 따라오는 장점들인 “테스트가 쉬워진다”, “참조 투명성이 보장된다”와 같은 이야기들도 수학적인 개념에서의 함수를 생각하면 사실 당연하기 그지 없는 이야기들이다.</p><p>앞서 잠깐 이야기 했지만, 매번 다른 값이 나오는 함수에 대한 유닛 테스트를 짠다고 생각해보면 진짜 답이 없다. 애초에 개발자가 함수의 동작을 예측할 수 없으니 함수의 동작에 대한 모법 답안을 제시할 수도 없을 것이고, 당연히 테스트 작성도 불가능 하다.</p><p>또한 순수 함수를 사용하면 참조 투명성이 보장된다는 말도 결국 우리가 수학에서 사용하고 있는 <code>=</code> 기호의 의미를 생각해보면 그렇게 특별한 말이 아니다.</p><center><br>  <span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>x</mi></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd></mtr><mtr><mtd><mrow><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd></mtr><mtr><mtd><mrow><mo>∴</mo><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}f(x) = 2x\\\\f(1) = 2\\\\\therefore f(1) + 1 = 3\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:3.25em;"></span><span class="strut bottom" style="height:6em;vertical-align:-2.7500000000000004em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathit">x</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">2</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mrel amsrm">∴</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span><br>  <small>참조 투명성이라는 것은 $f(1)$(함수의 실행부)를 $2$(함수의 결과물)로 치환해도<br>계산 결과가 변하지 않는다는 것을 의미하는데, 애초에 우리는 예전부터 수학에서 그 개념을 사용하고 있었다</small><br>  <br><br></center><p>이렇듯 순수 함수는 어떤 인자를 사용했을 때 어떤 결과 값이 나올 지 동작을 예측할 수 있고, 상태라는 것을 아예 없애버린 개념이기 때문에, 개발자가 예측 가능한 어플리케이션을 개발하기 쉽게 만들어준다.</p><p>또한 함수 자체가 함수 외부의 상태와 관계 없이 순수하게 단일한 연산에만 집중하고 있으니, 한 어플리케이션에서 선언한 순수 함수는 다른 어플리케이션에다가 가져다 붙혀도 반드시 동일한 동작을 한다는 것이 보장된다. 즉, 좋은 모듈화의 조건 중 하나인 <code>높은 응집도</code>에도 부합한다.</p><p>이렇게 순수 함수를 사용하여 작성된 어플리케이션은 개발자가 구조와 동작을 쉽게 이해할 수 있기 때문에, 굳이 함수형 프로그래밍 패러다임이 아니더라도 전반적인 어플리케이션 설계에 꽤나 도움이 되는 개념이라고 할 수 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>필자는 처음 순수 함수라는 개념을 접했을 때 구글링과 다른 분들이 작성해주신 포스팅들을 통해 순수 함수의 특징, 장점, 단점 등을 먼저 접하게 되었는데, 당시에는 “또 새롭게 공부할게 나왔구만”이라는 생각이었다.</p><center><br>  <img src="/2019/12/29/about-pure-functions/study.jpg" width="300"><br>  <small>또 새로운 공부거리가 생겨버렸네…</small><br>  <br><br></center><p>사실 순수 함수와 같은 패러다임을 처음 접하게 되면 습관처럼 구글링을 통해 정보를 습득하고 공부를 하게 되는데, 이때 일반적으로 다른 사람들이 정리해놓은 포스팅을 보고 공부하게 되는 경우가 많았다.</p><p>그러나 이렇게 공부를 하는 경우, 해당 패러다임의 근본적인 발생 이유나 원리에 대해서 깊이 파악하기 보다는 몇 가지 특징이나 장단점을 먼저 학습하게 되는 경우가 많았던 것 같다.</p><p>그래서 순수 함수도 “새롭게 공부해야하는 것”이라는 느낌으로 받아들였었지만, 나중에 곰곰히 생각해보니 그냥 어릴 때 배웠던 수학적인 함수의 개념을 그대로 프로그래밍으로 구현한 것이라는 개념이라는 것을 깨닿고 꽤나 허무했던 기억이 있다.</p><p>그래서 필자는 이 포스팅에서 “순수 함수는 이런저런 특징을 가진 함수”라고 설명하지 않았던 것이다. 개인적인 생각이기는 하지만, 대부분의 사람들은 어릴 때 이미 학교에서 함수에 대한 정의와 개념을 학습했기 때문에, “수학적인 함수”라는 키워드로 접근하는 것이 오히려 이해가 빠를 것이라고 생각했다.</p><p>어쨌든 필자는 이 포스팅을 통해 순수 함수는 전혀 새로운 개념이 아니라는 이야기를 하고 싶었고, 대한민국 의무 교육을 받은 사람이라면 누구든지 다 익숙하게 받아들일 수 있는 개념이라는 것을 이야기하고 싶었다.</p><p>물론 순수 함수를 사용하여 어떤 식으로 프로그램을 설계하는 것이 훌륭한 설계인지와 같은 이야기는 의무 교육과정에 없기 때문에 별도로 공부를 해야겠지만, 적어도 함수형 프로그래밍에서 중요한 키워드로 이야기하고 있는 <code>순수 함수</code>와 <code>불변성</code>에 대한 이해 정도는 그렇게 어려운 것은 아닐 것이라고 생각한다.</p><p>다음 포스팅에서는 순수 함수와 함께 함수형 프로그래밍에서 중요한 개념 중 하나인 <code>불변성</code>에 대한 이야기를 해보려고 한다.</p><p>이상으로 수학에서 기원한 프로그래밍 패러다임, 순수 함수 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/12/29/about-pure-functions/#disqus_thread</comments>
    </item>
    
    <item>
      <title>20대의 마지막, 2019년을 돌아보며</title>
      <link>https://evan-moon.github.io/2019/12/22/2019-retrospective/</link>
      <guid>https://evan-moon.github.io/2019/12/22/2019-retrospective/</guid>
      <pubDate>Sun, 22 Dec 2019 14:23:26 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;이제 필자의 마지막 20대를 보내는 2019년도 어느덧 10일 정도 밖에 남지 않았다. 물론 서른이 된다고 해서 크게 달라지는 것은 없지만, 스무살이 되었을 때 이후 처음으로 나이 앞 자리가 바뀌는 만큼 기분이 싱숭생숭 하기도 하다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>이제 필자의 마지막 20대를 보내는 2019년도 어느덧 10일 정도 밖에 남지 않았다. 물론 서른이 된다고 해서 크게 달라지는 것은 없지만, 스무살이 되었을 때 이후 처음으로 나이 앞 자리가 바뀌는 만큼 기분이 싱숭생숭 하기도 하다.</p><a id="more"></a><p>작년에 비해서 올해는 필자에게 많은 의미를 가지는 해였다. 이것 저것 도전해보았고, 또 도전으로 인한 결실을 얻기도 했던 해였다. 그 도전들 중에서는 개발과 관련된 것도 있고, 그냥 필자가 해보고 싶어서 했던 것들도 있는데 뭐가 되었든 작년에 비해 도전 자체를 많이 해봤다는 게 의미있는 것 같다.</p><p>그래서 이번 포스팅에서는 필자가 올해 겪었던 대표적인 일들을 시간 순서대로 나열하고 돌아보는 회고를 한 번 작성해보려고 한다.</p><h2 id="1년-동안-집필했던-책-출간"><a href="#1년-동안-집필했던-책-출간" class="headerlink" title="1년 동안 집필했던 책 출간"></a>1년 동안 집필했던 책 출간</h2><p>먼저 첫 번째로, 작년부터 친구와 함께 집필했었던 <a href="http://www.yes24.com/Product/Goods/76639545" target="_blank" rel="noopener">커피 한 잔 마시며 끝내는 Vue.JS</a>책이 2019년 7월 말 출간되었다.</p><p>제목이 조금 특이하다보니 많은 분들이 “진짜 커피 한 잔만에 끝낼 수 있냐”라고 물어보시는데, 사실 제목은 출판사에서 정해준거라 필자도 잘 모르겠다. <small>(커피 한 잔이 몇 리터라고는 말 안했다)</small></p><center><br>  <img src="/2019/12/22/2019-retrospective/my-book.JPG" width="450"><br>  <br><br></center><p>처음 집필 제의를 받은 것이 2018년 8월 쯤이고, 책 출간이 2019년 7월 31일에 되었으니 총 1년 정도의 기간이 소요된 셈이다. 물론 처음 한 두달 정도는 책의 내용을 기획하고 공동 집필하는 친구와 의견 일치를 보는 기간이었으니 대략 10개월 정도 집필을 했다.</p><p>사실 처음에는 내용이 많은 블로그 포스팅 정도로 가볍게 보고 시작했는데, 생각보다 블로그와 다른 점이 굉장히 많았던 것 같다. 블로그 포스팅은 기껏해야 200줄에서 300줄 정도의 짧은 내용을 담고 있지만, 400페이지에 달하는 내용이 한 호흡에 이어져야하는 글쓰기는 굉장히 낯선 경험이었다.</p><p>게다가 블로그 포스팅과는 다르게 명확한 기한이 정해져있는 프로젝트였기 때문에, 평일에 퇴근하고 아무리 피곤해도 책을 집필해야해서 집중력을 유지하기가 꽤나 힘들었다.</p><p>그리고 책의 내용 뿐 아니라, 책에 들어가는 예제인 SPA 어플리케이션 2개와 API 서버 어플리케이션까지 직접 작성하고 테스트해야하다보니, 아무리 두 명이 함께 한다고 해도 힘든 작업이었다.</p><center><br>  <img src="/2019/12/22/2019-retrospective/postman.png" width="450"><br>  <small>작성한 API는 Postman을 통해서 서로 공유했다</small><br>  <br><br></center><p>그런 이유로 필자와 친구는 최대한의 효율을 내기 위해 여러가지 방법을 모색했는데, 그 중 하나가 Git과 마크다운을 사용하여 책을 집필하자는 아이디어였다.</p><p>원래 출판사에서는 MS 워드로 작성해서 보내달라고 했으나, MS 워드는 헤딩이나 각주 등의 스타일 포맷을 지정할 때 일일히 마우스로 클릭해주거나 단축키를 눌러야 해야한다는 문제가 있었다. 그러나 마크다운은 나중에 <code>css</code>를 사용하여 통일된 스타일을 일괄 적용할 수 있기 때문에 훨씬 효율이 좋았다.</p><p>그리고 최종 집필을 마친 후에는 <a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a>이라는 라이브러리를 사용하여 <code>*.md</code> 파일을 <code>*.docx</code> 파일로 변경해서 출판사로 보냈다.</p><p>또한 둘 다 직장이든 사이드 프로젝트든 항상 Git을 사용하고 있어 익숙하기 때문에, 예제 어플리케이션과 책 집필 모두 Git을 사용하여 버전 관리를 진행할 수 있었고, 덕분에 많은 작업 시간을 단축하고 버그나 놓친 부분을 잡아낼 수 있었다.</p><p>또한 책의 모든 내용은 마크다운으로 작성되고, 코드 리뷰를 통과한 이후에만 마스터 브랜치로 머지될 수 있기 때문에 그 과정에 서로의 의견이 맞지 않는 부분을 합의하고 넘어가기도 좋았던 것 같다.</p><center><br>  <img src="/2019/12/22/2019-retrospective/code-review.png" width="450"><br>  <small>SSR 서버가 프론트엔드의 영역이냐 아니냐로 치열하게 의견 교환 중</small><br>  <br><br></center><p>함께 공동 집필했던 친구는 필자와 굉장히 친한 친구인데, 평소에는 사이드 프로젝트 정도만 함께 하고 이렇게 공적인 업무를 함께 하는 것은 처음이었기 때문에 책을 집필하는 과정에서 서로 일하는 스타일이 안 맞아서 약간의 갈등이 있기도 했다.</p><p>그러나 오히려 이런 시간을 통해 서로의 업무 스타일을 제대로 파악할 수 있었고, 서로 안 맞는 부분을 맞춰나갔던 과정 또한 좋은 추억으로 남을 수 있었다.</p><p>책 집필 과정에 대한 자세한 내용과 회고는 <a href="/2019/07/21/vuejs-book-retrospective/" title="흔한 개발랭이의 작가 입문기">흔한 개발랭이의 작가 입문기</a>라는 포스팅으로 따로 작성했으니 여기서 확인해볼 수 있다.</p><h2 id="블로그를-본격적으로-시작하다"><a href="#블로그를-본격적으로-시작하다" class="headerlink" title="블로그를 본격적으로 시작하다"></a>블로그를 본격적으로 시작하다</h2><p>사실 필자는 블로그를 열심히 쓰는 사람은 아니었다. 필자의 아카이브를 보면 2019년 6월부터 급격하게 포스팅 양이 늘기 시작한 것을 볼 수 있는데, 이때가 딱 책 집필이 거의 마무리되고 리뷰어들에게 책에 대한 리뷰를 받고 있던 시점이었다.</p><p>또한 2019년 6월 이전 포스팅들은 행성의 궤도 계산하기, 간단한 인공신경망 만들기와 같이 필자가 공부했던 내용들을 남겨놓기 위한 아카이브의 느낌이 강했다면, 2019년 6월 이후 작성된 포스팅들은 자바스크립트, Git과 같이 조금 더 일반적인 내용들에 대해 작성하기 시작한 것을 볼 수 있다.</p><p>이때 블로그 포스팅의 양이 늘고 주제가 바뀌기 시작한 이유에는 책을 집필하며 필자의 글쓰기 스킬이 성장했다는 것도 있지만, 더 큰 이유는 이 시점 이후로 필자가 블로그 포스팅을 대하는 마음 가짐에 약간의 변화가 있었다는 점이다.</p><p>필자는 기본적으로 자신의 스킬에 대한 자신감이 많은 사람은 아니다. 그래서 필자는 “내가 알고 있는 것 정도는 남들도 다 알고 있을거야”라는 생각을 가지고 있었지만, 책을 집필하면서 진행했던 스터디로 인해 생각이 변하게 되었다.</p><p>필자와 친구는 책을 집필하며 중간 중간 집필한 내용을 가지고 다른 분들과 함께 <code>VueJS</code>에 대한 스터디 겸 책에 대한 리뷰를 진행했었는데, 그때 함께 스터디를 했던 분들이 책의 내용이 공부에 많은 도움이 되었다는 이야기를 해주셔서 “내가 알고 있는 지식이 다른 개발자들에게 도움이 되는구나”라는 생각을 처음으로 하게 되었던 것 같다.</p><p>그 이후 지금까지 필자의 공부만을 위해 작성했던 블로그 포스팅의 주제를 “필자가 알고 있는 지식의 정리와 공유” 쪽으로 변경하게 되었고, 그렇게 작성한 블로그 포스팅을 다른 사람들에게 공유하게 되었다.</p><p>그렇게 대략 5개월 정도 블로그 포스팅을 공유하다보니, 필자의 포스팅을 읽은 분들이 페이스북 메세지나 링크드인, 이메일과 같은 채널을 통해 “잘 읽었다”, “도움이 되었다”와 같은 피드백을 보내주시는 경우도 생기게 되었는데, 이런 메세지들을 받으면서 블로그 포스팅 작성에 대한 동기부여가 되었던 것 같다.</p><center><br>  <img src="/2019/12/22/2019-retrospective/organic.png" width="500"><br>  <small>나름 성장하고 있는 Organic 유입 그래프</small><br>  <br><br></center><p>그리고 필자는 기술과 관련된 내용만 작성하는 것이 아니라 가끔 에세이 포스팅도 작성하곤 하는데, 이 과정에서 생각을 정리하거나 싱숭생숭한 마음을 정리할 수도 있어서 멘탈 관리에도 꽤나 도움이 되는 것 같다.</p><p>이제 필자에게 블로그 포스팅은 단순히 공부한 내용을 정리하거나 공유하거나 하는 느낌이라기보다 “글쓰기”라는 취미 생활에 가까워진 것 같은 느낌이다.</p><p>앞으로도 한 주에 한 개정도의 포스팅을 꾸준히 작성할 예정이고, 이런 식으로 몇 년동안 글이 쌓여나가면 나중에는 좋은 추억으로 남을 것 같다는 생각도 든다.</p><h2 id="2년-반-동안-정들었던-직장을-떠나다"><a href="#2년-반-동안-정들었던-직장을-떠나다" class="headerlink" title="2년 반 동안 정들었던 직장을 떠나다"></a>2년 반 동안 정들었던 직장을 떠나다</h2><center><br>  <img src="/2019/12/22/2019-retrospective/soomgo.png" width="500"><br>  <br><br></center><p>2019년 8월을 마지막으로 지난 2년 반동안 즐겁게 일했던 정든 브레이브모바일을 떠나게 되었다. 직원 수 고작 10명 남짓이었던 작은 회사가 Series A, B를 투자 받으며 성장하는 과정을 경험하면서 많은 것들을 배웠고, 좋은 동료들도 만날 수 있었다.</p><p>기억을 되돌아보면 필자는 이 회사에 입사하기 전, 1년도 채 안되는 짧은 스타트업 근무 경험과 한 번의 창업 경험만을 가지고 있던 햇병아리 개발자였고, 사이드 프로젝트로 특이한 것을 많이 만들기는 했지만 그렇다고 코딩을 남들보다 잘하는 편은 또 아니였다. 프로그램을 잘 만드는 것보다 만든다는 것 자체에 흥미를 느끼던 시절이랄까.</p><p>그러나 대학을 졸업하고 필자가 경험했던 모든 근무 환경들은 누군가 시키는 일을 하는 환경이 아닌 스스로 문제를 찾아내고 해결해가는 과정의 연속이었기 때문에, 자연스럽게 어떤 문제에 대한 의사결정을 내리는 것에 익숙해질 수 있었고, 그에 따른 책임을 지는 것 또한 두려워하지 않을 수 있었다.</p><p>초기 스타트업은 늘 인적 자원도 부족하고 누군가 의사결정을 일일히 내려주는 시스템이 아니기 때문에 각자의 책임 범위 안에서 스스로 리더가 되어야하는 경우가 많은데, 필자의 이런 경험들이 당시 작은 규모의 스타트업이었던 브레이브모바일에 잘 맞아들어갔기 때문에 더 재밌게 일할 수 있었던 것 같다.</p><p>그래서 필자는 입사 초반부터 프론트엔드 어플리케이션에 대한 전반적인 의사결정권을 가지고 수 없이 많은 의사결정을 거치며 일을 했었다. 뭐 그 중에는 잘한 선택도 있고 못한 선택도 있지만, 결과가 어찌되었든 필자같은 햇병아리 개발자에게 이런 경험은 굉장히 좋은 성장의 양분이 될 수 있었다.</p><p>처음 필자가 입사했던 2017년에 숨고라는 서비스는 프론트엔드 프레임워크도 붙어있지 않은 전통적인 MPA 어플리케이션이었다. 입사를 하고 처음 열어본 소스 코드에는 <code>React</code>를 붙히려다가 실패했던 흔적과 보일러 플레이트로 기본적인 스캐폴딩만 되어있는 <code>Vue</code>가 덩그러니 있었던 기억이 난다.</p><p>즉 입사 후 필자에게 주어진 첫 미션은 Django로 작성된 MPA 어플리케이션에 Vue를 어떻게든 적용하는 것이었는데, 당시에 이런 방법으로 Vue를 사용하는 레퍼런스도 많지 않아서 고생했던 기억이 난다. <small>(억울하게도 지금은 구글링하면 레퍼런스가 꽤 많이 나오는 편이다)</small></p><p>이후 시간이 지나고 조금씩 여유가 생기며, <code>Express</code>를 사용하여 직접 SSR 서버도 만들고 타입스크립트도 도입하면서 점점 어플리케이션을 단단하게 만들어 갔는데, 이런 과정 또한 아무것도 만들어져있지 않은 초기 스타트업에서 겪을 수 있는 꽤나 값진 경험 중 하나라고 생각한다.</p><p>또한 프론트엔드 어플리케이션에 대한 의사결정권이 필자에게 있었던 만큼, 백엔드 개발자 뿐 아니라 디자이너, PO, 마케터 등 다양한 직군과의 잦은 커뮤니케이션도 필수적으로 발생했는데, 이런 경험 또한 나름 재미있었다. 덕분에 개발 뿐만 아니라 다른 직군들이 하는 일에 대해서도 알 수 있었고 팀워크에 대한 생각도 많이 해볼 수 있었던 기회였던 것 같다.</p><p>그리고 브레이브모바일은 효율적인 <code>애자일 프로세스</code>에 대해서 깊은 고민을 하는 조직이었기 때문에, 비싼 돈 들여서 유명한 애자일 코치님에게 코칭을 받는 호사도 누릴 수 있었고, 이때 애자일 코칭을 받으며 배웠던 것들을 <a href="/2019/07/02/what-is-agile/" title="애자일이 도대체 뭐길래?">애자일이 도대체 뭐길래?</a> 라는 포스팅으로 정리했었다.</p><p>하지만 시간이 갈수록 익숙한 사람들과 함께 반복되는 업무를 처리하는 일상이 이어지며 새로운 경험을 할 수 있는 횟수가 점점 줄어들게 되었고, 성장에 대한 갈증이 더 커지게 되었다. 또한 필자의 위시리스트 중 “20대가 끝나기 전에 혼자 해외여행을 가보자”라는 조건을 만족시킬 수 있는 기한이 딱 올해까지였기 때문에 오랜 고민 끝에 퇴사를 결정하게 되었다.</p><p>필자가 퇴사할 당시 작성한 <a href="/2019/08/17/leave-the-company/" title="2년 동안 근무했던 회사를 떠나며">2년 동안 근무했던 회사를 떠나며</a> 포스팅에 더 자세한 내용이 있으니, 궁금하신 분들은 이 포스팅을 읽어보도록 하자.</p><h2 id="프라하에서-한-달-살기"><a href="#프라하에서-한-달-살기" class="headerlink" title="프라하에서 한 달 살기"></a>프라하에서 한 달 살기</h2><p>브레이브모바일을 퇴사한 후 20살 때부터 줄곧 꿈꿔왔던 “혼자 해외 여행해보기”를 실행에 옮겼다. 사실 필자는 해외여행을 그렇게 많이 가본 사람도 아니고, 해외여행을 가더라도 항상 친구나 가족들과 함께 다녔기 때문에 막상 혼자 한국을 벗어날 생각을 하니 조금 무섭기도 했지만, 막상 비행기표를 예매하고나니까 갑자기 마음이 굳어져서 일사천리로 하루 만에 모든 예약을 진행해버렸다.</p><p>그리고 이번에는 휴가를 내는 것이 아니라 아예 퇴사하고 자유로운 상태로 여행을 떠나는 것이기 때문에 굳이 4박 5일과 같은 빡빡한 일정을 잡을 필요도 없었고, 개인적으로도 급한 일정 속에 관광 스팟을 찍으면서 돌아다니는 스타일의 여행을 선호하지 않기 때문에 이번 여행의 컨셉을 “한 달 살기”로 잡았다.</p><p>필자는 살면서 유럽이라고는 모스크바밖에 가본 적이 거의 없기 때문에 이번에는 조금 더 유럽 냄새를 맡아보고 싶었고, 퇴사하면서 브레이브모바일과 2개월 간의 외주 계약을 체결한 상태였기 때문에, “유럽이지만 인터넷이 빵빵해야한다”라는 조건을 토대로 여행지를 알아보고 있었다.</p><p>그렇게 리서치를 해보던 중 <code>프라하</code>와 <code>부다페스트</code>가 도시도 아름답고 유럽치고 인터넷도 빵빵하다는 정보를 입수하게 되었는데, 최종적으로는 <code>프라하</code>에서 한 달 동안 지내는 것으로 결론을 내렸다.</p><p>문제는 필자가 프라하에 대해서 알고 있는 정보가 <code>체코 필하모닉 오케스트라</code>와 <code>프라하의 연인</code> 정도 밖에 없었다는 것이다. 당시 필자의 생각은 이랬다.</p><blockquote><p>어차피 한 달동안 살 건데, 가서 알아보면 되겠지 뭐 ㅎㅎ (행복회로 가동 중)</p></blockquote><center><br>  <img src="/2019/12/22/2019-retrospective/real.jpg" width="500"><br>  <small>행복회로 돌리지 말고 제대로 알아보고 갑시다</small><br>  <br><br></center><p>필자가 크게 놓쳤던 것 중 한 가지는 바로 2015년형 15인치 맥북 프로의 기내 반입 금지 사항이었다. 당시 미국에서 배터리 폭발 사고가 발생해서 각 국가 정부의 지침이나 항공사의 안전관리규정에 따라 맥북 프로를 비행기에 반입하지 못하는 이슈가 있었는데, 필자가 이걸 놓치고 만 것이다.</p><p>필자는 이 사실을 출발 하루 전 저녁에 우연히 알게되어 체코 항공에 메일로 문의를 했지만, 이때는 주말이었기 때문에 당연히 비행기를 탈 때까지 아무런 답변도 받을 수 없었다.</p><p>유럽항공안전청 홈페이지를 확인해보니 EU는 비행기 내에서 전원만 끄면 반입할 수 있다는 입장이었지만, 그래도 항공사마다 안전관리규정이 다른데다가 혹시 한국으로 돌아올 때 지침이 더 강화되면 맥북 프로를 체코에 놓고 와야할 수도 있다는 생각에 결국 2009년형 골동품 맥북 프로를 가져갔다. <small>(덕분에 프라하에서 맥둥이가 고장나서 수리도 했다)</small></p><p>그리고 또 한 가지는 생각보다 영어가 잘 통하지 않았다는 것이다. 체코는 러시아어랑 비슷한 느낌인 <code>체코어</code>를 사용하기는 하지만, 프라하가 워낙 관광지로 유명한 만큼 다들 영어를 잘 할줄 알고 방심했다.</p><p>하지만 필자의 숙소는 관광지 근처가 아니었기 때문에 영어를 잘 하는 사람이 생각보다 많이 없었고, 덕분에 의사소통할 때 꽤나 어려움을 겪었다. 그래서 다음부터는 영어권이 아닌 다른 국가를 여행할 때 기본적인 단어나 문법 정도는 그 나라의 언어로 말할 수 있을 정도로 공부를 하고 갈 계획이다.</p><p>이때 필자가 프라하에서 고생하며 얻어낸 정보는 <a href="/2019/09/06/life-in-prague-tip/" title="프라하에서 디지털 노마드로 살아남기">프라하에서 디지털 노마드로 살아남기</a>라는 포스팅으로 정리했다.</p><h2 id="개발자들과의-의미있는-스몰-토크-모임"><a href="#개발자들과의-의미있는-스몰-토크-모임" class="headerlink" title="개발자들과의 의미있는 스몰 토크 모임"></a>개발자들과의 의미있는 스몰 토크 모임</h2><center><br>  <img src="/2019/12/22/2019-retrospective/chit-chat.jpg" width="500"><br>  <br><br></center><p>2019년 11월에는 대학생때부터 친구들과 함께 운영하고 있는 토이 프로젝트팀인 루비콘에서 <code>Chit Chat</code>이라는 스몰 토크 모임을 개최했다.</p><p>개발자들은 다른 직군에 비해 컨퍼런스나 네트워킹과 같은 모임이 많은 편이긴 하지만 이런 모임들의 주제는 대부분 기술 그 자체에 집중되어 있고, 공식적으로 각자의 생각이나 가치관을 나눠볼 수 있는 기회는 그리 많지 않기 때문에 기술 외적인 주제에 대해서 이야기를 나눠볼 수 있는 자리가 있었으면 좋겠다고 생각했다.</p><p>그런 이유로 <code>소프트 스킬</code>에 대해서 서로의 이야기를 나눠볼 수 있는 스몰 토크 모임을 기획하게 되었고, 다양한 경력과 다양한 직군의 개발자들이 모여서 두 시간동안 소프트 스킬에 대한 각자의 생각을 나누는 좋은 경험을 해볼 수 있었다.</p><p>하지만 역시 태어나서 처음 진행해보는 행사이다보니, 걱정되는 부분도 있었다. 사실 필자는 낯을 조금 가리는 성격이라 평소에 네트워킹이나 컨퍼런스에 자주 참여하는 편이 아닌데, 이번에는 직접 토론의 사회자 역할까지 맡아야 한다고 생각하니 부담스럽기도 했다.</p><p>그러나 막상 사람들이 모이고 토론을 시작하자 다들 열정적으로 자신의 의견을 이야기해주셔서 생각보다 사회자로써 할 일은 많지 않았고, 그냥 필자도 토론 자체를 즐기며 재밌는 시간을 보냈던 것 같다.</p><p><code>Chit Chat</code>에서 어떤 주제로 어떤 이야기를 나누었는지 궁금하신 분들은 루비콘 팀 블로그에 올려놓은 <a href="https://lubycon.github.io/magazines/2019/11/18/1st-chit-chat-retrospective" target="_blank" rel="noopener">Lubycon 1st Chit Chat 후기</a> 포스팅에서 확인해볼 수 있다.</p><h2 id="새로운-시작"><a href="#새로운-시작" class="headerlink" title="새로운 시작"></a>새로운 시작</h2><center><br>  <img src="/2019/12/22/2019-retrospective/toss.jpg" width="500"><br>  <br><br></center><p>블로그를 통해 공식적으로 이야기한 적은 없지만, 필자는 지난 12월 9일부터 토스라는 금융 서비스를 만드는 <code>비바리퍼블리카</code>에 입사하게 되었다.</p><p>이 회사를 선택한 이유에는 여러가지가 있겠지만, 역시 가장 큰 이유는 토스팀은 “재미있게 일하는 조직”이라는 생각이 들어서였다.</p><p>필자는 아직 이 회사에서 많은 것을 경험하지 못 했고 이제 하나하나 배워가는 단계이지만, 확실히 토스팀 자체가 활력적인 에너지가 느껴지는 팀이라는 것이 느껴지기는 한다.</p><p>게다가 일이든 개발이든 잘하시는 분들이 워낙 많다보니 자극도 받을 수 있어서 좋다. 최근 필자가 올렸던 Pull Request에는 피드백이 20개 정도 달렸는데, 이렇게 누군가가 내 코드에 대해 상세하게 읽어보고 피드백을 주는 경험이 오랫만이라서 기분도 좋았고, 이런 사람들과 같은 프로덕트를 만든다는 것이 든든하기도 했다.</p><p>물론 아직 <code>3 Month Review</code>라는 난관이 하나 남아있기는 하지만, 딱히 신경 안 쓰고 열심히 자기 할 일만 잘 해보려고 한다. 혹여나 떨어지더라도 최선을 다 했다면 후회는 없을 것이라는 생각이 든다.</p><h2 id="20대를-마치며"><a href="#20대를-마치며" class="headerlink" title="20대를 마치며"></a>20대를 마치며</h2><p>2019년은 필자의 마지막 20대였고, 내년부터는 이제 30대의 길로 접어든다. 어릴 적 필자에게 서른이라는 나이는 뭔가 “어른”이라는 이미지였지만, 막상 서른을 코 앞에 둔 지금 나 자신을 바라보면 딱히 어른이 되었다는 생각은 들지 않는다. 그냥 나이만 한 살 더 먹은 느낌이랄까.</p><p>올해 필자는 이런 저런 도전을 많이 했고 나름의 결실도 이뤄냈다. 책도 내고 유럽에서 한 달 동안 살아도 봤으며 새로운 직장으로 이직도 했다. 중요한 것은 이런 것들이 뭔가 예전부터 계획된 일들이 아니였고, 그때 그때 하고 싶은 대로 했다는 점이다.</p><p>사실 17살 때부터 필자는 스스로에게 다짐한 한 가지 원칙을 가지고 있었는데, 바로 “하고 싶은 것만 하면서 살기”이다. 이런 이야기를 하면 철이 없다고 말씀하시는 분도 있고, 현실과 타협할 줄 알아야 어른이라고 말씀하시기도 하지만, 그런 의미의 어른이라면 딱히 되지 않아도 괜찮을 것 같다는 생각이 든다.</p><p>하고 싶은 것만 하면서 산다는 것이 그냥 내 맘대로 산다는 의미는 아니다. 현실 속에서 하고 싶은 것만 하면서 산다는 것이 쉬운 일이 아니라는 것은 다들 알고 있을 것이라 생각한다. 당연히 그에 따른 많은 노력이 동반되어야 한다.</p><p>코딩이 너무 재밌어서 개발자로 일하고 싶었기 때문에, 공부를 열심히 해서 개발자가 되었다. 내가 알고 있는 지식을 사용하여 다른 사람들에게 도움이 되고 싶었기 때문에 블로그 포스팅을 꾸준히 작성하고 있다.</p><p>필자는 이런 작은 도전과 노력들이 모여서 “하고 싶은 건 반드시 한다”라는 현실을 만들어 낼 수 있다고 생각한다. 뭐, 앞으로는 어떤 어려운 일이 또 닥칠지 모르기 때문에 장담할 수는 없겠지만 되도록이면 이 가치관을 관짝에 들어갈 때까지 가져가보려고 한다.</p><p>그런 이유로 2020년에는 “발표”나 “강의”와 관련된 도전을 한 번 해볼까 생각 중이다. 발표나 강의하시는 분들을 보면 참 대단하다고 생각이 들면서도, 남들 앞에 서서 뭔가를 이야기한다는 게 조금 무섭기도 해서 매번 미루고 있었는데 올해에는 한 번 용기를 내보려고 한다.</p><p>이상으로 20대의 마지막, 2019년을 돌아보며 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/12/22/2019-retrospective/#disqus_thread</comments>
    </item>
    
    <item>
      <title>기존의 사고 방식을 깨부수는 함수형 사고</title>
      <link>https://evan-moon.github.io/2019/12/15/about-functional-thinking/</link>
      <guid>https://evan-moon.github.io/2019/12/15/about-functional-thinking/</guid>
      <pubDate>Sun, 15 Dec 2019 13:06:03 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;최근 많은 언어들이 함수형 프로그래밍 패러다임을 도입하며, 이에 대한 개발자들의 관심 또한 나날히 높아지고 있다. 필자 또한 &lt;code&gt;함수형 사고&lt;/code&gt;라는 책을 읽으면서 기존의 패러다임과 사뭇 다른 함수형 프로그래밍에 대해 많은 관심을 가지게 되었던 기억이 있다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>최근 많은 언어들이 함수형 프로그래밍 패러다임을 도입하며, 이에 대한 개발자들의 관심 또한 나날히 높아지고 있다. 필자 또한 <code>함수형 사고</code>라는 책을 읽으면서 기존의 패러다임과 사뭇 다른 함수형 프로그래밍에 대해 많은 관심을 가지게 되었던 기억이 있다.</p><a id="more"></a><center><br>  <img src="/2019/12/15/about-functional-thinking/functional_thinking_book.jpg" width="400"><br>  <small>재밌어서 여러 번 읽고 있는 귀여운 다람쥐 책</small><br>  <br><br></center><p>물론 이 책을 읽었다고 해서 함수형 프로그래밍을 자유롭게 할 수 있는 것은 아니다. 함수형 프로그래밍에서 사용하는 커링, 모나드, 고계 함수와 같은 개념와 기법들은 열심히 공부해서 이해하고 많이 써보면 금방 익숙해질 수 있는 것들이지만, 앞서 이야기했듯이 어떤 패러다임을 사용하여 프로그램을 제대로 설계하기 위해서는 말 그대로 사고 방식 자체를 바꿔야하기 때문이다.</p><p>그런 이유로 이번 포스팅에서는 함수형 프로그래밍의 스킬들보다는 함수형 프로그래밍이 왜 이렇게 각광받는지, 또 이 패러다임이 어떤 개념들을 사용하여 프로그램을 바라보고 있는지에 대한 이야기를 해보려고 한다.</p><h2 id="함수형-프로그래밍을-왜-알아야하나요"><a href="#함수형-프로그래밍을-왜-알아야하나요" class="headerlink" title="함수형 프로그래밍을 왜 알아야하나요?"></a>함수형 프로그래밍을 왜 알아야하나요?</h2><p>사실 객체지향적 사고와 명령형 프로그래밍을 사용하기만 해도 왠만한 프로그램을 설계하고 작성하는 데는 무리가 없다. 우리는 이미 몇십 년간 이러한 사고방식으로 거대한 프로그램을 만들어왔지 않은가?</p><p>그러나 함수형 프로그래밍이 이렇게 주목받는 이유는 분명 기존의 그것들과는 분명한 차이가 있기 때문이고, 그 차이로 인해 개발자들이 조금 더 생산성있는 프로그래밍을 할 수 있기 때문일 것이다.</p><p>그렇다면 도대체 함수형 프로그래밍의 어떤 점이 개발자들의 마음을 움직였던 것일까?</p><p>뭐 개발자마다 각자 다른 이유들을 가지고 있겠지만, 일단 필자가 느꼈던 함수형 프로그래밍의 대표적인 장점은 바로 이런 것들이다.</p><blockquote><ol><li>높은 수준의 추상화를 제공한다</li><li>함수 단위의 코드 재사용이 수월하다</li><li>불변성을 지향하기 때문에 프로그램의 동작을 예측하기 쉬워진다</li></ol></blockquote><p>아마 함수형 프로그래밍에 대해 설명하는 다른 블로그 포스팅이나 책들을 봐도 비슷한 점을 함수형 프로그래밍의 장점으로 이야기하고 있을 것이다.</p><p>이 장점들 중에서 불변성에 대한 것은 함수형 프로그래밍 자체의 장점이라기보다는 <code>순수 함수(Pure Functions)</code>를 사용함으로써 자연스럽게 따라오는 장점에 가깝기 때문에, 여기에 대한 이야기는 추후 순수 함수에 대한 설명을 할 때 다시 이야기하도록 하고, 이번 포스팅에서는 <code>높은 수준의 추상화</code>와 <code>함수 단위의 재사용</code>라는 키워드에 대해 초점을 맞춰서 이야기해보려고 한다.</p><h2 id="높은-수준의-추상화"><a href="#높은-수준의-추상화" class="headerlink" title="높은 수준의 추상화"></a>높은 수준의 추상화</h2><p>기본적으로 함수형 프로그래밍은 <code>선언형 프로그래밍</code>의 특성을 함수들의 조합을 사용하여 구현하는 패러다임이고, 선언형 프로그래밍의 대표적인 장점 중 하나가 바로 명령형 프로그래밍이나 객체지향 프로그래밍에서 사용하는 방법들보다 높은 수준의 추상화를 통해 개발자가 문제 해결에만 집중할 수 있게 해준다는 점이다.</p><p>선언형 프로그래밍이 제공한다는 높은 수준의 추상화라는 것이 정확히 무엇을 의미하는 것이고 어떤 장단점이 있는지 이해하기 위해 먼저 <code>추상화</code>에 대한 개념적인 정리가 먼저 필요할 것 같다.</p><h3 id="추상화의-정확한-개념"><a href="#추상화의-정확한-개념" class="headerlink" title="추상화의 정확한 개념"></a>추상화의 정확한 개념</h3><p>아마 객체지향 프로그래밍을 알고 있는 분들이라면 추상화가 현실에 존재하는 무언가의 특징을 뽑아내어 정리하는 행위라고 이야기할지도 모르겠다. 뭐 이것도 틀린 말은 아니고, 객체지향 프로그래밍을 처음 공부할 때는 이렇게 이해하는 것이 더 편하기도 하다.</p><p>하지만 사실 추상화라는 단어의 근본적인 의미는 단순히 객체의 특징을 정리하여 클래스를 정의하는 것보다 훨씬 넓은 범위의 개념이다.</p><p>추상화의 근본적인 의미는 어떤 작업을 수행할 때 그 이면에 존재하는 복잡한 것들을 간단한 것처럼 보이게 만들어주는 것들에 가깝다. 객체지향 프로그래밍에서 객체를 추상화하여 클래스를 정의하는 행위 또한 근본적으로는 이 정의에 부합한다.</p><p>자, 이름을 가지고 있고 자신의 이름을 말할 수 있는 사람을 추상화한 <code>Human</code> 클래스를 사용하여 객체를 생성하고 메소드를 사용한다고 생각해보자.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Human {</span><br><span class="line">  <span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">constructor</span> (<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">public</span> say (): <span class="hljs-built_in">string</span> {</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>.`</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> me = <span class="hljs-keyword">new</span> Human(<span class="hljs-string">'Evan'</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(me.say());</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, I am Evan.</span><br></pre></td></tr></tbody></table></figure><p>여기서 중요한 사실이 하나 있다. 대부분의 경우 우리가 직접 클래스도 만들고 객체도 만들기 때문에 쉽게 지나치는 사실이지만, 사실 <code>Human</code> 클래스가 어떻게 구현되었는지 전혀 모르는 상태라도 이 클래스를 사용하여 객체를 생성하고 메소드를 사용하는데는 아무 문제가 없다는 것이다.</p><p>그냥 이 클래스가 외부로 노출하는 기능이 무엇인지만 알고 있으면 객체를 생성하고 메소드를 호출하여 원하는 동작을 이끌어낼 수 있다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">interface</span> {</span><br><span class="line">  <span class="hljs-keyword">constructor</span>: (<span class="hljs-params"><span class="hljs-built_in">string</span></span>) => Human;</span><br><span class="line">  say: <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">string</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>객체지향 프로그래밍에서는 사용자에게 높은 수준의 추상화를 제공하기 위해 <code>public</code>, <code>private</code>과 같은 접근 제한자를 사용하여 클래스 외부로 노출시키고 싶은 것만 노출시키는 캡슐화라는 기법을 사용한다.</p><p>또한 클래스 외에 일반적으로 우리가 사용하는 라이브러리들도 일종의 추상화된 모듈이라고 할 수 있다.</p><p>만약 우리가 <code>React</code>나 <code>RxJS</code>와 같은 라이브러리를 사용할 때 해당 라이브러리의 구현체를 전부 파악해야만 사용할 수 있다면 굉장히 힘들것이다. 그러나 우리는 라이브러리의 구현 소스를 일일히 파악하지 않더라도 공식 문서를 통해 기능을 파악하기만 한다면 일단 사용하는 데는 별 지장이 없다. <small><strike>(잘 쓰려면 봐야한다는 게 함정)</strike></small></p><p>그리고 우리가 프로그램을 작성할 때 유용하게 사용하고 있는 OS API나 브라우저 API와 같은 API들도 일종의 추상화된 기능 리스트이다. 이런 추상화된 기능 리스트가 있기에 우리는 어떤 API가 어떤 동작을 하는 지만 알고 있다면, 로우 레벨의 동작을 직접 다루지 않더라도 컴퓨터에게 편하게 명령을 내릴 수 있는 것이다.</p><center><br>  <img src="/2019/12/15/about-functional-thinking/abstraction.png" width="300"><br>  <small>추상화된 OS API만 안다면 하드웨어 구조를 모르더라도 프로그램을 만들 수 있다</small><br>  <br><br></center><p>만약 개발자가 아닌 분이라면 여러분이 평소에 사용하는 일반적인 프로그램을 생각해보면 된다.</p><p>예를 들어 여러분이 포토샵을 사용하여 컬러 사진을 흑백 사진으로 변경한다고 생각해보자. 포토샵은 이미지 프로세싱이라는 복잡한 연산을 수행하는 프로그램이지만, 우리는 포토샵이 제공하는 여러가지 기능들을 사용하여 <code>사진 보정</code>이라는 행위에만 집중할 수 있다.</p><p>실제로 컬러 사진을 흑백 사진으로 변경할 때는 행렬로 이루어진 사진의 픽셀 데이터를 순회하며 RGB 값의 평균을 내거나하는 등의 과정을 수행해야한다. 하지만 그런 복잡하고 귀찮은 과정이 추상화되어있기 때문에 사용자는 그저 포토샵이 외부로 노출해준 기능인 <code>Image > Adjustments > Desaturate</code>을 사용하면 되는 것이다.</p><p>즉, <code>추상화</code>란 복잡한 무언가에서 핵심적인 개념이나 기능을 간추려내어 단순하게 만드는 것을 의미하며, 추상화가 잘 되어있는 프로그램을 사용하는 사용자는 자신과 맞닿은 추상 계층 밑에 무엇이 있고 어떻게 작동하는지 모르더라도 해당 기능을 편하게 사용할 수 있다.</p><h3 id="추상화의-수준이-높으면-좋은-건가요"><a href="#추상화의-수준이-높으면-좋은-건가요" class="headerlink" title="추상화의 수준이 높으면 좋은 건가요?"></a>추상화의 수준이 높으면 좋은 건가요?</h3><p>방금 알아본 바와 같이 추상화란, 복잡한 무언가를 단순해보이도록 만들어주는 행위를 의미한다. 즉, 추상화의 수준이 높다는 것은 복잡한 것을 단순해보이도록 만드는 행위 자체의 수준이 높아졌다는 것을 의미하는 것이다.</p><p>그런 의미에서 보면 확실히 추상화의 수준이 높을 수록 사용자가 편하긴 하다. 이 <code>편하다</code>는 의미가 잘 감이 안오시는 분들을 위해 더 쉽게 이야기해보면, 우리가 사용하는 프로그래밍 언어를 예시로 들어볼 수 있겠다.</p><p>우리는 프로그램을 만들 때 <code>0</code>과 <code>1</code>로 이루어진 기계어를 사용할 수도 있고, 어셈블리를 사용할 수도, 자연어에 가까운 고급 언어인 자바를 사용할 수도 있다.</p><p>만약 길가는 개발자를 붙잡고 “기계어로 코딩할래? 어셈블리로 코딩할래?”라고 묻는다면 기계어로 코딩하고 싶다는 변태는 거의 없을 것이다. 기계어는 거의 추상화되지 않은 날 것이나 마찬가지이기 때문에 사람이 이해하기 너무 어렵기 때문이다.</p><p>또한 “어셈블리로 코딩할래? 자바로 코딩할래?”라고 물어본다면 어셈블리라고 대답하는 변태 또한 그렇게 많지 않을 것이다. 이 경우에는 어셈블리가 자바에 비해 추상화 수준이 매우 낮기 때문에, 자바로 코딩하는 것이 사람에게는 더 편한 것이다. 이게 바로 대표적인 추상화 수준의 차이이다.</p><p>어셈블리로 거대한 프로그램을 작성하게 되면 개발자가 신경써줘야하는 것이 너무나도 많지만, 자바를 사용하면 <code>for</code>, <code>if</code> 등의 문법과 다양한 API를 사용하고 조합하여 프로그램을 작성함으로써 어셈블리보다 좀 더 편하게 프로그래밍 할 수 있다. 메모리에 값을 할당하고 레지스터로 모았다가 다시 빼내고하는 잡다한 일은 <code>JRE(Java Runtime)</code>가 다 알아서 해줄 것이기 때문이다.</p><p>이렇게 예전의 기술보다 높은 수준의 추상화를 제공하며 사용자에게 편의를 안겨주는 경우는 함수형 프로그래밍이 처음이 아니고, 오히려 컴퓨터 공학 역사에서 굉장히 빈번하게 발생되었던 일이다. 이렇게 기술이 발전하며 추상화 수준을 높혀감으로써 점점 더 복잡한 프로그램을 만들 수 있게 되는 것이다.</p><p>그러나 추상화의 수준이 높다는 것이 장점만 있는 것은 아니다. 이런 높은 추상화를 장점으로 내세우는 기술이 발표되면 높은 확률로 “성능이 안 좋다”, “이렇게 추상화해버리면 최적화는 어떻게 하냐”와 같은 논란에 휩싸이게 되는데, 이런 논란에 휩쓸렸던 대표적인 친구들이 바로 <code>자바</code>나 <code>가비지 컬렉터</code>이다. <small>(그리고 어셈블리가 있다…)</small></p><center><br>  <img src="/2019/12/15/about-functional-thinking/von_neumann.gif" width="300"><br>  <small>존 폰 노이만 (1903 ~ 1957)</small><br>  <small>괜히 어셈블리 같은 걸 만들어서 컴퓨터 성능 낭비하지 말라고 하신 분</small><br>  <br><br></center><p>자바의 경우에는 바이트 코드와 <code>JVM(Java Virtual Machine)</code>이라는 개념을 사용하여 한번만 코드를 작성해도 모든 OS에서 동작하는 프로그램을 작성할 수 있다는 점이 굉장한 강점이었다. OS나 CPU에 종속되어있던 기존의 프로그래밍 언어들에 비해 추상화 수준이 높아진 것이다. 그러나 처음 자바가 나왔을 당시에는 C에 비해서 너무 느려서 못 써먹을 물건이라고 상당히 많이 까였다.</p><p>또한 가비지 컬렉터도 개발자가 일일히 메모리를 할당하고 해제하지 않아도 되는 편리함을 제공하지만 GC가 객체의 메모리 해제 시점을 매번 추적하고 있어야하는 성능 문제나, 개발자가 객체가 메모리에서 해제되는 시점을 정확히 알기 어렵다던가, <a href="https://ko.wikipedia.org/wiki/%EC%B0%B8%EC%A1%B0_%ED%9A%9F%EC%88%98_%EA%B3%84%EC%82%B0_%EB%B0%A9%EC%8B%9D" target="_blank" rel="noopener">참조 횟수 계산 방식</a>을 사용할 때 순환 참조 객체를 해제하지 못하는 등 문제들이 여전히 존재하기 때문에 늘 완벽하게 동작하지는 않는다.</p><p>하지만 그렇다고 자바나 가비지 컬렉터나 자바를 사용할 수 있는 환경에서 굳이 C를 사용하고 수동으로 메모리를 관리하고 싶어하는 사람이 많지는 않을 것이다. 애초에 이런 높은 수준의 추상화를 제공하는 기술이 가지는 성능 상의 단점을 머신이 어느 정도 커버할 수 있기 때문에 사람들이 많이 사용하는 것이기도 하다.</p><p>함수형 프로그래밍도 높은 수준의 추상화를 지향하는 패러다임인 만큼 어느 정도 성능 면에서 불리한 점이 있긴 하다. 사실 함수 단위로 프로그램을 추상화하는 개념은 1958년에 <a href="https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%ED%94%84" target="_blank" rel="noopener">LISP</a>가 발표되었을 때부터 시작되었지만, 당시에는 아마 이런 개념이 사치로 느껴졌을 것이다. 메모리가 너무 부족해서 당장 작업 하나 하기도 빡센 데 추상화는 무슨 추상화란 말인가.</p><p>그러나 요즘 머신의 성능은 함수형 프로그래밍이 지향하는 추상화 레벨을 충분히 커버할 수 있을 정도로 예전에 비해 많이 좋아졌기 때문에 성능에 관한 문제는 크게 중요하지 않다고 느껴진다.</p><p>그리고 만약 성능이 진짜 중요한 프로그램을 작성할 때는 굳이 함수형 프로그래밍을 고집하지 않아도 된다. 애초에 이런 패러다임은 어떤 정답이라고 할 게 없기 때문이다. 지금도 최적화를 위해 C나 어셈블리를 사용하는 경우가 있는 것처럼, 함수형 프로그래밍도 상황에 따라 적재적소에 잘 사용하면 된다.</p><p>그럼 함수형 프로그래밍이 제공하는 높은 수준의 추상화가 우리에게 어떤 형태로 나타나는지 알아보기 위해, 기존에 우리에게 익숙한 패러다임인 <code>명령형 프로그래밍</code>과 함수형 프로그래밍의 상위 개념인 <code>선언형 프로그래밍</code>을 한번 비교해보도록 하자.</p><h2 id="명령형과-선언형은-사고-방식이-다르다"><a href="#명령형과-선언형은-사고-방식이-다르다" class="headerlink" title="명령형과 선언형은 사고 방식이 다르다"></a>명령형과 선언형은 사고 방식이 다르다</h2><p>명령형 프로그래밍은 문제를 <code>어떻게 해결해야 하는지</code> 컴퓨터에게 명시적으로 명령을 내리는 방법을 의미하고, 선언형 프로그래밍은 <code>무엇을 해결할 것인지</code>에 보다 집중하고 어떻게 문제를 해결하는 지에 대해서는 컴퓨터에게 위임하는 방법을 의미한다.</p><p>처음 프로그래밍이라는 개념이 등장했을 때부터 비교적 최근까지도 우리는 컴퓨터에게 명시적으로 명령을 내리는 방법인 명령형 프로그래밍을 주로 사용해왔지만, 함수형 프로그래밍은 문제를 해결하는 방법에 더 집중하고 사소한 작업은 컴퓨터에게 넘겨버리는 선언형 프로그래밍의 일종이다.</p><p>이처럼 컴퓨터에게 사소한 작업들을 위임해버리는 패러다임의 특성 상, 선언형 프로그래밍에는 필연적으로 <code>높은 수준의 추상화</code>라는 키워드가 따라오는 것이다. 추상화 수준이 낮다면 저 사소한 작업들을 개발자가 일일히 다 컨트롤해줘야한다는 이야기니 말이다.</p><p>자, 그럼 명령형 프로그래밍과 선언형 프로그래밍을 사용하여 문제를 해결하는 과정을 비교해보며 이 두 패러다임 간의 추상화 수준의 차이에 대해서 한번 살펴보도록 하자. 우리가 해결해야하는 문제는 바로 이것이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'evan'</span>, <span class="hljs-string">'joel'</span>, <span class="hljs-string">'mina'</span>, <span class="hljs-string">''</span>];</span><br></pre></td></tr></tbody></table></figure><blockquote><p>배열을 순회하며 빈 문자열을 걸러내고, 각 원소의 첫 글자를 대문자로 변경해라.</p></blockquote><h3 id="어떻게-문제를-해결할까-명령형-프로그래밍"><a href="#어떻게-문제를-해결할까-명령형-프로그래밍" class="headerlink" title="어떻게 문제를 해결할까? (명령형 프로그래밍)"></a>어떻게 문제를 해결할까? (명령형 프로그래밍)</h3><p>명령형 프로그래밍은 말 그대로 컴퓨터에게 <code>어떻게 작업을 수행할 지</code>에 대한 자세한 명령을 내리는 것이다. 더 정확히 말하자면, 어떻게 문제를 해결하는지 일일히 명령을 내리면서 내가 원하는 결과를 만들어나가는 방식이라고 할 수 있다.</p><p>사실 오늘날 현업에서 일하고 있는 대부분의 개발자는 처음 프로그래밍을 접할 때 전통적인 패러다임인 명령형 프로그래밍으로 공부를 시작했던 경우가 많기 때문에, 필자를 포함한 많은 개발자들에게 익숙한 방법이라고도 할 수 있다.</p><p>대부분의 개발자는 이런 문제를 만났을 때, <code>for</code>문과 같은 반복문을 사용하여 순차적으로 배열의 원소를 탐색하고 작업하는 코드를 떠올릴 것이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> newArr = [];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < arr.length; i++) {</span><br><span class="line">  <span class="hljs-keyword">if</span> (arr[i].length !== <span class="hljs-number">0</span>) {</span><br><span class="line">    newArr.push(</span><br><span class="line">      arr[i].charAt(<span class="hljs-number">0</span>).toUpperCase() + arr[i].substring(<span class="hljs-number">1</span>)</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>이렇게 <code>for</code>문을 사용하여 특정 행위를 반복하는 코드를 작성하는 일은 눈 감고도 작성할 수 있을 정도로 개발자들에게 익숙한 로직이지만, 너무 익숙한 나머지 이 짧은 코드 안에도 많은 명령이 들어가 있다는 사실을 간과하고는 한다.</p><p>필자가 위 코드를 작성할 때 필자가 떠올렸던 생각을 대충 정리해보자면 이런 느낌이다.</p><blockquote><ol><li>변수 <code>i</code>를 <code>0</code>으로 초기화</li><li><code>i</code>가 <code>arr</code> 배열의 길이보다 작다면 구문을 반복 실행</li><li><code>for</code>문 내부의 코드의 실행이 종료될 때마다 <code>i</code>에 <code>1</code>씩 더함</li><li><code>arr</code> 배열의 <code>i</code> 번째 원소에 접근</li><li>만약 원소의 길이가 <code>0</code>이 아니라면 원소의 첫 번째 글자를 대문자로 변경</li><li>이렇게 합쳐진 문자열을 <code>newArr</code> 배열에 삽입</li></ol></blockquote><p>필자가 코드를 작성할 때 생각했던 사고의 흐름은 필자가 컴퓨터에게 내려야하는 명령과 정확하게 매칭된다.</p><p>즉, 필자는 <code>i</code>라는 상태를 직접 관리해야하며, 매 루프 때마다 <code>i</code>에 1을 더 해가면서 배열의 어느 인덱스까지 탐색했는지도 신경써줘야 하는 상황인 것이다. 게다가 배열의 원소에 접근할 때도 <code>i</code>를 사용하여 직접 접근 명령을 내려야하고 이 원소가 빈 문자열인지 아닌지 여부도 검사해줘야한다.</p><p>이렇게 컴퓨터에게 일일히 명령을 내려서 자신이 원하는 결과를 만들어가는 과정을 통해 프로그램을 작성하는 방식을 명령형 프로그래밍이라고 하는 것이다.</p><p>자 이 쯤에서 우리가 해결해야하는 문제를 다시 한번 보자.</p><blockquote><p>배열을 순회하며 빈 문자열을 걸러내고, 각 원소의 첫 글자를 대문자로 변경해라.</p></blockquote><p>저 명령들을 쭉 읽어보고 바로 이 문제를 떠올릴 수 있을까? 물론 이 문제는 굉장히 간단한 문제이기 때문에 바로 알아챌 수도 있겠지만, 이 문제보다 더 복잡한 문제라면 아마 몇 번은 읽어보고 그림도 그려봐야하지 않을까?</p><p>즉, 명령형 프로그래밍은 사람이 생각하는 방식보다 컴퓨터가 생각하는 방식에 가깝기 때문에 그리 인간 친화적인 방식은 아니다. 그렇기 때문에 개발자들은 알고리즘 문제 풀이 등을 통해 이런 방식의 사고를 하는 것을 꾸준히 연습하기도 한다.</p><p>자, 그럼 선언형 프로그래밍으로 같은 일을 수행하는 코드를 작성하면 어떻게 바뀔까?</p><h3 id="무엇을-해결할까-선언형-프로그래밍"><a href="#무엇을-해결할까-선언형-프로그래밍" class="headerlink" title="무엇을 해결할까? (선언형 프로그래밍)"></a>무엇을 해결할까? (선언형 프로그래밍)</h3><p>반면 선언형 프로그래밍은 컴퓨터에게 <code>나 이거 할거야!</code>라고 알려주기만 하는 느낌이다. 잡다한 일 처리는 컴퓨터가 알아서 하도록 위임해버리고 개발자는 문제 해결을 위해 무엇을 할 지만 신경쓰면된다.</p><p>즉, 함수형 프로그래밍은 이런 선언형 프로그래밍의 특성을 함수를 통해 구현하게되는 패러다임이라고 할 수 있는 것이다. 그럼 방금 전과 같은 문제를 선언형 프로그래밍을 사용하여 구현해보도록 하자.</p><blockquote><p>배열을 순회하며 빈 문자열을 걸러내고, 각 원소의 첫 글자를 대문자로 변경해라.</p></blockquote><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convert</span> (<span class="hljs-params">s</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> s.charAt(<span class="hljs-number">0</span>).toUpperCase() + s.substring(<span class="hljs-number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> newArr2 = arr</span><br><span class="line">  .filter(<span class="hljs-function"><span class="hljs-params">v</span> =></span> v.length !== <span class="hljs-number">0</span>)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">v</span> =></span> convert(v));</span><br></pre></td></tr></tbody></table></figure><p>이 코드에서 사용된 <code>filter</code> 메소드는 배열을 순회하며 콜백 함수의 반환 값이 참이 아닌 원소를 걸러낸 새로운 배열을 생성 후 반환하는 역할을, <code>map</code> 메소드는 배열을 순회하며 콜백 함수의 반환 값을 사용한 새로운 배열을 생성한다.</p><p>이 코드를 작성할 때 필자의 사고의 흐름은 다음과 같았다.</p><blockquote><ol><li>인자로 받은 문자열의 첫 글자만 대문자로 변경하는 함수를 선언</li><li><code>arr</code> 배열에서 원소의 길이가 0이 아닌 것들을 걸러냄</li><li>걸러진 배열을 순회하면서 1번에서 선언한 함수를 사용하여 원소의 첫글자를 대문자로 변경</li></ol></blockquote><p>분명 같은 작업을 수행하는 코드를 작성했지만 사고의 흐름이 많이 다른 것을 볼 수 있다. 물론 내부적으로는 아까 명령형 프로그래밍을 사용할 때의 필자 사고 방식과 유사한 방법으로 처리되겠지만, 적어도 필자가 자잘한 인덱스 변수의 선언이나 관리에 대해서 생각할 필요는 없어졌다.</p><p>그리고 더 중요한 점은 필자가 해결해야하는 문제와 사고 방식의 흐름이 비슷해졌다는 것이다.</p><blockquote><p>배열을 순회하며 빈 문자열을 걸러내고(filter), 각 원소의 첫 글자를 대문자로 변경해라(convert + map).</p></blockquote><p>이렇게 선언형 프로그래밍은 개발자가 문제의 본질에 집중할 수 있게 만드는 것에 초점을 맞추고 있고, 결국 함수형 프로그래밍은 이런 선언형 프로그래밍의 패러다임을 함수를 사용하여 구현하는 것이다.</p><p>하지만 이렇게 사소한 제어를 컴퓨터에게 맡겨버린다는 것이 장점만 있는 것은 아니다. 여기서 발생하는 대표적인 트레이드오프는 바로 추상화를 설명할 때 이야기했던 <code>성능</code>이다.</p><p>필자가 명령형 프로그래밍을 사용하여 이 작업들을 수행한 경우 필자는 단 한 번의 루프 안에서 여러가지 작업을 수행했지만, 선언형 프로그래밍으로 작성한 예시는 <code>filter</code>와 <code>map</code> 메소드가 각각 전체 배열을 순회하기 때문에 성능 상 손해가 발생할 수 있는 것이다.</p><p>아무리 요즘 머신의 성능이 좋아져서 저 정도의 추상화 레벨을 커버할 수 있다지만 만약 탐색해야하는 원소의 개수가 10억개라면 이런 사소한 차이가 전체 프로그램의 성능에 지대한 영향을 끼칠 수도 있다. 그래서 필자가 함수형 프로그래밍도 상황에 따라 적재적소에 잘 사용해야한다고 이야기 했던 것이다.</p><h2 id="객체로-이루어진-프로그램과-함수로-이루어진-프로그램"><a href="#객체로-이루어진-프로그램과-함수로-이루어진-프로그램" class="headerlink" title="객체로 이루어진 프로그램과 함수로 이루어진 프로그램"></a>객체로 이루어진 프로그램과 함수로 이루어진 프로그램</h2><p>자, 여기까지 명령형 프로그래밍을 사용할 때와 선언형 프로그래밍을 사용할 때 발생하는 사고의 차이에 대해 알아보았다.</p><p>위에서 이야기했듯이 함수형 프로그래밍은 선언형 프로그래밍이라는 패러다임을 함수들의 집합과 연산으로 구현한 것이기 때문에 명령형 프로그래밍과도 많이 비교당하지만, 프로그램을 객체들의 집합과 관계로 정의하는 <code>객체지향 프로그래밍</code>과도 많이 비교를 당하게 된다.</p><p>명령형 프로그래밍과 선언형 프로그래밍을 다루며 이야기했던 것과 마찬가지로, 객체지향 프로그래밍과 함수형 프로그래밍 간에도 어떠한 우위는 없다. 다만 서로의 차이에 따른 각기 다른 장단점이 있을 뿐이다.</p><p>그렇다면 객체지향 프로그래밍을 사용하지 않고 함수형 프로그래밍을 사용함으로써 가져갈 수 있는 장점은 무엇일까?</p><p>물론 여기에도 여러가지 장단점이 있겠지만 필자는 개인적으로 <code>함수 단위의 코드 재사용</code>이 더욱 쉬워진다는 것이 가장 큰 장점이라고 생각한다.</p><h3 id="더-작게-쪼개어-생각할-수-있다"><a href="#더-작게-쪼개어-생각할-수-있다" class="headerlink" title="더 작게 쪼개어 생각할 수 있다"></a>더 작게 쪼개어 생각할 수 있다</h3><p>기존의 객체지향 프로그래밍에 익숙한 개발자는 어떤 프로그램의 요구 사항을 들었을 때 머릿 속에 객체의 설계도가 떠오르게 된다. 그리고 이러한 객체들의 관계를 정의하여 거대한 프로그램을 만들기 위한 기반을 다져나간다.</p><p>객체지향패턴에서 객체란 멤버 변수(상태)와 메소드(행위)로 이루어진, 프로그램을 구성하는 최소 단위이기 때문에, 객체지향패턴을 사용할 때 우리는 이 객체보다 더 작은 무언가를 사용하여 프로그램을 설계할 수 없다.</p><p>우리가 객체지향패턴을 사용할 때는 객체를 생성하기 위해, 객체를 추상화하여 일종의 설계 도면 역할을 하는 클래스를 사용하여 객체가 가질 상태와 행위를 정의하게 된다.</p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Queue<T> {</span><br><span class="line">  <span class="hljs-keyword">private</span> queue: T[] = []; <span class="hljs-comment">// 내부 상태</span></span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// 메소드로 표현된 큐의 행위</span></span><br><span class="line">  <span class="hljs-keyword">public</span> enqueue (value: T): T[] {</span><br><span class="line">    <span class="hljs-keyword">this</span>.queue[<span class="hljs-keyword">this</span>.queue.length] = value;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queue;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">public</span> dequeue (): T {</span><br><span class="line">    <span class="hljs-keyword">const</span> head = <span class="hljs-keyword">this</span>.queue[<span class="hljs-number">0</span>];</span><br><span class="line">    <span class="hljs-keyword">const</span> length = <span class="hljs-keyword">this</span>.queue.length;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < length - <span class="hljs-number">1</span>; i++) {</span><br><span class="line">      <span class="hljs-keyword">this</span>.queue[i] = <span class="hljs-keyword">this</span>.queue[i + <span class="hljs-number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">this</span>.queue.length = length - <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> head;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> myQueue = <span class="hljs-keyword">new</span> Queue<<span class="hljs-built_in">number</span>>();</span><br><span class="line">myQueue.enqueue(<span class="hljs-number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p><code>Queue</code> 클래스는 하나의 배열을 내부 상태로 가지고 이 배열에 원소를 추가하고 제거하는 큐의 기능을 구현한 클래스이다. 이때 이 클래스의 메소드를 통하지않고 클래스의 내부 상태인 <code>queue</code> 배열을 외부에서 맘대로 접근해서 수정하는 행위를 막기위해 <code>private</code> 접근제한자를 사용하여 외부에서의 접근을 막아주었다.</p><p>사실 이 정도만 해도 일반적인 프로그래밍을 할 때 딱히 불편하거나 어려운 점은 없다. 하지만 여기에서 필자가 <code>Stack</code>이라는 클래스를 새로 만들면 어떻게 될까?</p><p>간단히 생각해보면 큐의 동작인 <code>dequeue</code>는 그대로 사용하고 <code>enqueue</code>의 동작만 반대로 바꿔줘도 훌륭한 스택이 구현될 것 같다. 그러나 이미 클래스의 메소드로 구현되어버린 <code>dequeue</code>를 다른 클래스에서 가져다 자신의 메소드처럼 사용할 수 있는 방법은 상속 밖에 없는데, 그렇다고 큐를 상속한 스택을 만들어버리면 객체 간의 관계가 꼬이기 시작할 것이다.</p><p>즉, 객체지향 프로그래밍에서 어떤 존재를 추상화하여 표현하고 재사용할 수 있는 최소 단위는 <code>객체</code>이기 때문에 그 이상 작게 쪼개기 힘들어지는 것이다. 하지만 함수형 프로그래밍에서는 객체로 표현된 큐나 스택이 아닌, 이 존재들이 자료를 다루는 동작에만 집중한다.</p><blockquote><ol><li>배열의 꼬리에 원소를 추가하는 동작 (push)</li><li>배열의 머리에서 원소를 빼오고 남은 원소를 앞으로 한 칸씩 당겨주는 동작 (shift)</li></ol></blockquote><p>이처럼 자바스크립트의 빌트인 메소드인 <code>push</code>와 <code>shift</code>를 사용하면 굳이 클래스나 객체를 선언하거나, 필자가 위에서 구현한 것처럼 명령형 프로그래밍으로 큐의 동작을 구구절절 작성하지 않더라도 큐의 동작을 완벽하게 구현할 수 있다. 또한 추가적으로 스택을 구현하고 싶다면, <code>shift</code> 메소드를 사용하여 원소를 빼오고 <code>push</code> 메소드 대신 <code>unshift</code> 메소드를 사용하여 원소를 추가하면 된다.</p><figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> queue: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="line">queue.push(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> head = queue.shift();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> stack: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="line">stack.unshift(<span class="hljs-number">0</span>);</span><br><span class="line">stack.shift();</span><br></pre></td></tr></tbody></table></figure><p>굉장히 당연하다고 느껴지겠지만, 이것이 객체 단위로 요소를 구성하는 것과 함수 단위로 요소를 구성하였을때 누릴 수 있는 근본적인 장점이다. 어떤 요소를 재사용할 수 있는 범위가 넓어지는 것이다.</p><p>다만 이렇게 작은 단위의 함수를 넓은 범위로 재사용하게 되면 프로그램의 복잡성이 빠르게 증가하기 때문에 이를 방어하기 위해서 함수가 함수 외부에 있는 값을 수정하면 안된다거나, 동일한 인자를 받은 함수는 동일한 값을 반환해야 한다거나 하는 몇 가지 제약 조건이 필요하게 된다.</p><p>이런 제약을 가진 함수를 바로 <code>순수 함수(Pure Functions)</code>라고 부르는 것이다. 근데 보통 순수 함수라는 개념을 설명하다보면 방금 필자가 이야기한 것처럼 “몇 가지 제약 조건이 있는 함수”라는 개념으로 설명하게 되는데, 이거 근본적으로 그냥 수학에서 사용하는 함수랑 거의 동일한 개념이다.</p><p>컴퓨터 공학의 함수는 수학의 함수에서 유래되기는 했지만, 이 두 개의 학문이 추구하는 방향과 발전되어온 과정이 꽤나 다르기 때문에 함수라는 개념도 이름만 똑같을 뿐, 사실은 서로 다른 부분이 많다. 즉, 순수 함수는 수학에서 이야기했던 함수의 본질 그 자체로 회귀하여 단순함을 확보하자는 개념에서 시작하는 것이다.</p><p>그런 이유로 필자는 개인적으로 순수 함수를 프로그래밍적인 관점에서 접근하여 이해하는 것보다 수학적인 관점에서 접근하여 이해하는 것이 더 쉽고 빠르다고 생각한다.</p><p>일단 이 포스팅의 주제는 함수형 프로그래밍보다는 함수로 사고하는 방식의 장단점과 특징에 대한 이야기이므로, 순수 함수나 불변성에 대한 이야기는 다음에 함수형 프로그래밍의 특징과 스킬을 설명할 때 조금 더 자세히 이야기해보도록 하겠다. <small>(이것도 은근히 꿀잼이다)</small></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>필자는 사실 얼마 전까지만 해도 함수형 프로그래밍에 대한 관심이 깊은 편이 아니었다. 명령형 프로그래밍과 객체지향적인 사고만으로도 대부분의 어플리케이션은 충분히 설계할 수 있다고 생각했기 때문이다.</p><p>하지만 이건 필자가 학교에서 처음 배웠던 패러다임이 명령형 프로그래밍과 객체지향 프로그래밍이었기 때문에 몸에 더 익어서 그랬던 것이다. 사실 어떤 패러다임을 자유자재로 다룰 수 있다는 것은 해당 패러다임이 요구하는 사고 방식에 이미 익숙해졌다는 이야기이기 때문에, 새로운 설계 패턴이나 패러다임을 익힌다는 것은 이런 기존의 사고 방식을 깨야하는 상황이기도 하다.</p><p>개인적으로 커링이나 고계 함수, 모나드 같은 것들을 익히는 것보다 이런 사고 방식을 바꾸는 것이 훨씬 더 어렵다는 생각을 한다. 솔직히 말하면 어느 정도 함수형 프로그래밍에 대해 공부하고 마음이 열린 상태인 지금도 어떤 요구사항을 들었을 때 명령형과 객체지향을 먼저 떠올리고 있기도 하고 말이다.</p><p>물론 포스팅에서 여러 번 이야기했듯이 함수형 프로그래밍이 객체지향 프로그래밍이나 명령형 프로그래밍을 대체하는 패러다임도 아닐 뿐더러, 이 패러다임들간에는 어떠한 우위도 없다. 각자의 장단점만 있을 뿐이고 상황에 따라 적당히 골라쓰면 되는 것이다.</p><p>게다가 아직까지 많은 라이브러리들이 객체지향적인 개념으로 설계되었고, 사용 방법 또한 대부분 멤버 변수와 메소드를 내장한 객체를 생성하여 사용하는 방법을 채택하고 있기 때문에, 이런 라이브러리와 내 프로그램을 연동하려면 프로그램의 전체적인 아키텍쳐 또한 객체지향으로 설계하는 것이 편하다는 점도 무시할 수는 없다.</p><p>일례로 자바스크립트 진형에서 상태관리 라이브러리로 자주 사용하는 <code>Redux</code>의 경우 순수 함수와 불변성을 기반으로 하여 상태 변경을 감지하게 되는데, 필자는 Web Audio API를 사용한 토이 프로젝트를 진행할 때 <code>AudioNode</code> 객체들의 상태를 <code>Redux</code>로 관리하는 것에 상당히 애를 먹고 있기도 하다. <small><strike>(이건 그냥 필자가 Redux를 못 쓰는 걸 수도…)</strike></small></p><p>하지만 함수형 프로그래밍이 가져다주는 높은 수준의 추상화나 더 작은 수준의 코드 재사용과 같은 장점들은 분명히 복잡한 프로그램을 작성할 때 크게 도움이 되는 것들이다. 결국 함수형 프로그래밍을 잘 사용한다는 것은 단순히 이 패러다임을 깊게 이해하는 것보다는 이 패러다임이 어떤 상황에 적합한지 판단할 수 있는 능력 또한 포함하는 이야기라고 생각한다.</p><p>다음 포스팅에서는 함수형 프로그래밍에서 빼놓을 수 없는 키워드인 순수 함수, 불변성, 지연 평가와 같은 개념들과 프로그램의 복잡도를 낮추기 위해 사용하는 다양한 스킬들을 소개하는 포스팅을 작성할 예정이다.</p><p>이상으로 기존의 사고 방식을 깨부수는 함수형 사고 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/12/15/about-functional-thinking/#disqus_thread</comments>
    </item>
    
    <item>
      <title>솔직한 피드백으로 좋은 팀워크를 만들 수 있을까? - 파워풀을 읽고</title>
      <link>https://evan-moon.github.io/2019/12/04/about-honestly-feedback/</link>
      <guid>https://evan-moon.github.io/2019/12/04/about-honestly-feedback/</guid>
      <pubDate>Tue, 03 Dec 2019 16:01:32 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;최근 4일 동안 심한 몸살에 걸려 침대에만 누워있으면서, 컴퓨터를 멀리 하고 오랜만에 책을 읽었다. 마침 입사 예정인 회사에서 “린 스타트업”과 “파워풀” 두 권의 책을 보내주었기 때문에 무엇을 읽어볼까하는 고민을 할 시간을 줄일 수 있었다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>최근 4일 동안 심한 몸살에 걸려 침대에만 누워있으면서, 컴퓨터를 멀리 하고 오랜만에 책을 읽었다. 마침 입사 예정인 회사에서 “린 스타트업”과 “파워풀” 두 권의 책을 보내주었기 때문에 무엇을 읽어볼까하는 고민을 할 시간을 줄일 수 있었다.</p><a id="more"></a><p>그런 이유로 넷플릭스의 기업 문화를 주도했던 패티 맥코드의 “파워풀”이라는 책을 먼저 읽어보았는데, 평소에 필자가 회사를 다니면서 고민했던 많은 문제들에 대해서 나름 명쾌한 해답을 제시해주는 것 같았다.</p><p>이 책은 총 8개의 챕터를 통해 넷플릭스가 지향하는 기업 문화인 “자유와 책임”에 대해서 이야기하고 있는데, 그 중에서 필자에게 많은 생각이 들게 했던 부분은 바로 3장의 “극도로 솔직해져라”라는 챕터였다.</p><h2 id="극도로-솔직해져라"><a href="#극도로-솔직해져라" class="headerlink" title="극도로 솔직해져라"></a>극도로 솔직해져라</h2><p>패티 맥코드는 넷플릭스의 핵심 기업 문화 중 한 가지로 “솔직한 진심을 나눠야한다”라고 이야기한다. 그것이 같은 직원이던 경영진이던 동일하게 말이다.</p><p>넷플릭스의 솔직함에는 “상대방에게 직접 말할 것”, “피드백을 환영할 것”, “실수를 인정할 것” 등의 몇 가지 키워드가 있다. 최근 국내에서도 다양한 회사들이 이런 문화를 적극적으로 받아들여 기업의 자산 현황을 직원들에게 공개하거나 직급 여하와 상관없이 자신의 의견을 자유롭게 말할 수 있는 분위기를 조성하고 있다.</p><p>파워풀에서 이야기하고 있는 솔직함에 대한 내용 중에서 필자가 생각이 많아진 부분은 바로 “솔직한 피드백”이었다.</p><p>물론 서로 가감없이 솔직한 피드백을 주고 받을 수 있는 문화는 굉장히 좋은 문화라고 생각한다. 상대방의 발전을 기원하며 서로 건네는 피드백이 건강하게 작용한다면 구성원의 학습의 질을 높은 수준으로 끌어올릴 수 있기 때문이다.</p><p>필자도 전 직장에서 팀원들 간에 이런 피드백을 주고 받으며, 서로에게 조언도 해주고 책이나 아티클도 공유했던 좋은 기억이 있다. 심지어 필자가 이번 이직 때 직장을 선택하는 기준 중에 하나도 이런 피드백을 통해 정하게 되었을 정도이다.</p><p>그렇다면 이런 건강한 피드백 문화를 만들기 위해 필요한 것이 정말 “솔직함” 뿐일까?</p><p>그러나 필자는 개인적으로 이러한 피드백 주고받기 문화를 “솔직함”이라는 키워드만 바라보고 그대로 현실에 적용하기에는 조금 애매하다고 생각한다. 불가능하지는 않지만 이런 문화가 조직에 성공적으로 정착하기까지 넘어야 할 장애물이 몇 가지 있다.</p><h2 id="사람은-감정을-100-배제하고-생각할-수-없다"><a href="#사람은-감정을-100-배제하고-생각할-수-없다" class="headerlink" title="사람은 감정을 100% 배제하고 생각할 수 없다"></a>사람은 감정을 100% 배제하고 생각할 수 없다</h2><p>패티 맥코드는 피드백에 관련된 내용을 이야기할 때 주로 “피드백을 주는 쪽”의 입장을 많이 이야기했다. 상대방이 너의 피드백을 무시하거나 상처받을 것이라고 생각하지말고 “너의 팀원을 믿어라”라는 식으로 말이다.</p><p>필자가 이 책을 읽으며 아쉬웠던 점은, 피드백을 받는 사람의 현재 감정 상태를 딱히 고려하지 않는다는 점이었다. 오히려 패티 맥코드는 “감정없이 대화하는 법”에 대한 내용을 언급한다.</p><p>물론 업무적인 이야기를 할 때 불필요한 감정은 배제하기 위해 노력하는 것이 프로페셔널한 자세인 것은 맞지만 사람이 감정을 완전히 배제하고 생활한다는 것이 가능한 일일까?</p><p>책의 흐름을 보았을 때, 패티 맥코드가 말하는 감정은 부정적인 감정을 의미하는 것일테다. 그러나 책에서는 이에 대해 직접적으로 이야기하지 않았고, 특정 상황을 예시로 들며 상대방을 배려하는 말투로 피드백을 주라고 간접적으로 이야기하고 있다.</p><p>음, 필자는 감정이 팀워크에 미치는 영향에 대해서 꽤나 중요하게 생각하는 사람이기 때문에 이에 대한 이야기를 조금 더 해보려고 한다.</p><p>지난 6월에 작성한 <a href="/2019/06/06/what-is-good-programmer/" title="좋은 프로그래머란 무엇일까?">좋은 프로그래머란 무엇일까?</a> 포스팅에서도 한 차례 언급한 바 있지만, 감정이라는 것은 기본적으로 두뇌의 신호를 받아 호르몬이 분비된 결과물이다. 그 말인 즉슨, 사람이 의도적으로 감정을 컨트롤한다는 것이 결코 쉬운 일이 아니라는 것이다.</p><p>아무리 회사고 공적인 조직이라고 하지만, 회사도 결국은 사람들이 모여서 함께 뭔가를 이루기위해 노력하는 커뮤니티이다. 사람들이 모여서 서로 소통하며 뭔가를 하는 이상 그 속에서 감정을 100% 배제하는 것은 불가능하다.</p><p>그래서 필자는 상호 간의 커뮤니케이션에서 중요한 점을 하나 뽑으라고 한다면 제일 먼저 “존중”이라는 키워드를 뽑는다. 그리고 이 존중이라는 단어 안에는 상대방의 직무, 감정에 대한 배려가 숨어있다.</p><p>문제는 피드백이라는 것이 대부분 부정적인 의견을 전달하는 용도의 커뮤니케이션이라는 것이다.</p><p>물론 건강한 피드백은 상대방이 어떠한 단점을 보완하여 더욱 더 발전했으면 하는 마음에서 나오는 것이나, 피드백을 받아들이는 사람이 어떻게 생각할 지는 며느리도 모르는 일이다.</p><p>아무리 채용 과정에서 피드백에 대한 부정적인 관점을 가지지 않는 사람이라는 것이 어느 정도 입증되었다고 해도, 사람 마음이라는 것이 늘 한결 같은 것도 아니고, 그 날의 상황에 따라서 기분이 좋지 않을 수도 있지 않은가?</p><p>예를 들어 평소 회사에서 일을 하면서 하루에 100명 정도에게 피드백을 듣는다고 생각해보자. 사실 필자는 이 정도 피드백은 아무렇지 않다. 평소의 필자는 피드백을 들었을 때 “이 단점을 보완하자”와 같은 이펙트를 내는 타입이기 때문이다.</p><p>하지만 갑자기 가족이 투자 사기를 당해서 집이 하루 아침에 파산했다면 어떤가? 그래도 다음 날 아무렇지 않게 100명의 피드백을 받아들이고 평소처럼 “단점을 보완해야지”라는 긍정적인 생각을 할 수 있을까?</p><p>물론 가능한 사람도 있겠지만, 필자는 아닐 것 같다. 머릿 속에 설상가상(雪上加霜)이라는 단어가 떠오르면서 “요즘 일이 잘 안풀리네”라는 부정적인 생각이 들 것만 같다.</p><p>이렇듯 사람 마음이라는 것이 외부 환경에 독립적인 요소가 아닌 만큼, 상황에 따라서 같은 자극에도 다른 반응이 나타날 수 있는 것이다. 또한 필자가 이런 상황을 다른 사람들에게 말하지 않는 이상 다른 사람은 필자의 현재 심리 상태를 알기 힘들다.</p><p>사실 회사 뿐 아니라 모든 조직의 커뮤니케이션에서 가장 어려운 문제가 이처럼 “상대방의 마음”을 도통 알 수가 없다는 것이다. 우리는 프로토스처럼 칼라를 통해 소통하는 종족도 아니지 않은가?</p><center><br>  <img src="/2019/12/04/about-honestly-feedback/khala.gif" width="500"><br>  <small>프로토스는 칼라를 통해 감정과 생각을 공유하지만 인간은 아니다</small><br>  <br><br></center><p>다른 사람과의 커뮤니케이션은 언제나 이런 불확실성 속에서 진행되는 것이기 때문에 어려운 것이고, 그 불확실성에는 그 사람의 감정이 크게 기여한다고 생각한다. 이런 이유로 전 직장에서는 아침마다 “체크인”이라는 활동을 통해 자신의 현재 컨디션을 1과 10 사이의 숫자로 표현하는 방법을 사용하기도 했다.</p><p>건강한 피드백 문화라는 것은 단순히 솔직함이라는 키워드 만으로 만들어지는 것이 아니다. 여기에는 “솔직하게” 그리고 “따뜻하게” 상대방을 배려하고 존중하면서 피드백을 줄 수 있는 문화가 함께 동반되어야한다.</p><h2 id="부드러운-어투로-피드백을-주면-된다"><a href="#부드러운-어투로-피드백을-주면-된다" class="headerlink" title="부드러운 어투로 피드백을 주면 된다?"></a>부드러운 어투로 피드백을 주면 된다?</h2><p>여기까지 이야기를 하고나면 많은 분들이 “그럼 부드러운 어투로 피드백을 주면 되는 것 아닌가?”라고 하실텐데, 사실 이것도 굉장히 애매한 부분이다. “부드럽게 말하다”의 기준 또한 사람마다 주관적이기 때문이다.</p><p>필자는 전 직장에서 딱 한번 말투로 인해서 피드백을 받았던 적이 있었다. 필자는 당시 모든 팀이 이슈 관리용으로 사용하는 JIRA라는 솔루션을 관리하고 있었는데, 어느 날 살펴보니 팀이나 개인 단위로 무분별하게 보드를 생성해서 어떤 것이 진짜 사용하는 보드이고 어떤 것이 사용하지 않는 보드인지 한 눈에 파악하기가 힘들었다.</p><p>그래서 필자는 각 팀에게 현재 이 보드를 사용하고 있는지에 대한 여부를 물어보고 더 이상 사용하지않는 보드는 백업 후 삭제하는 작업을 하게되었는데, 문제는 CX(고객경험)팀에 필자가 질문을 하러 갔을 때 발생했다.</p><blockquote><p> - 똑똑똑 -<br><strong>에반</strong>: 저기 죄송한데, 혹시 CX팀에서 SCX 보드 현재 사용하시나요?<br><strong>CX 팀원</strong>: 네…? (놀람) 아뇨 저희 지금 안 쓰고 있어요.<br><strong>에반</strong>: 넵 감사함다.</p></blockquote><p>필자는 확인도 받았으니 해당 보드를 백업하고 삭제했는데, 조금 시간이 지난 뒤에 CX 팀원으로부터 “저희가 혹시 뭐 잘못 했나요…?”라는 슬랙 메세지를 받았다.</p><p>메세지를 받고 순간 “왜…?”라는 생각이 들었는데, 조금 생각해보니 그럴만 했다는 결론을 내렸다. CX팀 입장에서는 갑자기 개발자가 자기네 부서에 오더니 아무런 앞 뒤 설명없이 “이 보드 쓰세요?”라고 물어보고 간 상황이었던 것이다.</p><p>게다가 보통 개발자가 다른 팀에 이런 질문을 하는 경우는 다른 팀에서 뭔가 만졌는데 데이터가 꼬였다던가 하는 경우 였음을 생각해보면 필자에게 저런 질문을 하는 것이 이상한 일도 아니였다. 필자 입장에서는 저 작업 외에도 일이 많고 바쁘기 때문에 용건만 간단히 물어본 것이지만, 듣는 사람 입장에서는 당황스러웠을 것이다. <small>(지금 생각해보니 표정도 딱딱했던 것 같다)</small></p><p>물론 이후에 자초지종을 설명하고 오해가 풀렸지만, 이 사건은 필자가 커뮤니케이션에 대해서 깊은 고민을 하게 만드는 기폭제가 되기도 했다.</p><p>사실 필자는 스스로 말투가 그렇게 부드러운 편이 아니라는 사실을 알고 있었다. 그래서 필자에 대해서 잘 모르는 사람들과 이야기할때는 나름 말투에 신경을 쓰는 편이고, CX팀에 가서 저 질문을 했을때도 나름대로 신경쓴 편이었다. 하지만 CX팀에서는 필자의 말투가 너무 딱딱해서 무섭다고 했다.</p><p>결국은 “내가 받아들이는 것”과 “상대방이 받아들이는 것”이 다를 수 있다는 것이며, 원활한 커뮤니케이션을 위해서는 이 사실을 인지하고 있어야한다는 것이다. 그리고 이런 경우, 필자가 아무리 신경을 썼다고 해도 상대방이 딱딱한 말투라고 느꼈다면 필자가 더 부드럽게 말하거나 표정같은 비언어적인 커뮤니케이션을 사용하여 보완하는 것이 맞다.</p><p>“부드러운 말투로 피드백을 준다”라는 말도 결국 마찬가지다. 내 입장에서는 아무리 부드럽게 말한다고 해도 상대방이 그렇게 받아들이지 않을 확률은 늘 존재하며, 솔직한 피드백을 주고 받는 문화가 성공적으로 정착하려면 이런 이슈들에 대한 구성원들의 성숙한 고민과 발전이 끊임없이 계속 되어야한다.</p><p>물론 패티 맥코드도 “적대적이거나 거들먹거리는 말투”로 피드백을 주지 말라는 이야기는 간단히 언급했으나 필자는 개인적으로 이런 상대방에 배려와 존중 또한 솔직함이라는 키워드와 동일하게 중요하다고 생각하는 편이라서, 이 책에서는 너무 “솔직함”에만 집중한 것이 아쉽다는 생각이 들었다.</p><h2 id="경영진과-직원-사이의-피드백"><a href="#경영진과-직원-사이의-피드백" class="headerlink" title="경영진과 직원 사이의 피드백"></a>경영진과 직원 사이의 피드백</h2><p>패티 맥코드는 직급의 고하와 상관없이 피드백을 주고 받을 수 있어야 한다고 말하며, 이런 피드백 매커니즘은 위에서 아래로 내려오는 탑다운(Top-Down)으로 전파되어야 한다고 한다. 음, 하지만 현실적으로 이게 제일 어려운 부분이 아닐까?</p><p>아무리 의사결정을 각 실무자에게 위임하고 수평적인 의사소통을 지향한다고 해도 경영진이라는 자리는 회사 전체를 리딩하는 자리인 만큼 가지는 책임이나 권한이 일반적인 직원보다 크기도 하고, 20년 넘게 학교나 알바, 군대 등 온갖 수직적인 구조를 겪으며 살아온 우리에게는 아직 “사장님과 수평적인 관계”라는 사실 자체가 어색하니 말이다. <small>(이건 특별히 한국이라서 그런게 아니라 만국 공통이다)</small></p><p>그런 이유로 직원의 입장에서 경영진에게 피드백을 건넨다는 것은 솔직히 부담스러울 수 밖에 없다. 물론 많은 기업들이 수평적인 문화를 지향하고 또 실제로 그런 문화를 실천하고 있기는 하지만, 경영진이라는 타이틀을 가진 사람을 내 동료처럼 편하게 대한다는 것은 꽤나 어려운 일이다.</p><center><br>  <img src="/2019/12/04/about-honestly-feedback/friends.jpg" width="500"><br>  <small>직원이 경영진을 “동료”로 느끼게 만드는 일은 생각보다 쉬운 일이 아니다</small><br>  <br><br></center><p>그래서 패티 맥코드 또한 이런 피드백 매커니즘을 정착시키려면 탑다운으로 전파되어야한다고 했던 것이다. 여기서 말하는 탑다운은 “명령”이 아니라, 경영진이 먼저 다가서라는 의미이다.</p><p>당연히 수평적인 문화를 지향하는 많은 회사의 대표들도 이런 사실을 알고 있기에 꾸준하게 “저한테 편하게 대해주세요”라는 제스처를 취한다. 하지만 이상하게도 직원들 마음은 그렇게 쉽게 열리지 않는 경우가 많다. 그 이유는 무엇일까?</p><p>이건 마치 연애와 비슷한 느낌인데, 말로는 사랑한다고 하지만 상대방에게 무심한 행동만 보여준다면 상대방이 진짜 이 사람이 자신을 사랑한다고 믿을 수 있을까? 오히려 말로는 사랑한다고 하지 않아도 늘 따뜻하고 배려있는 행동을 보여준다면 더 믿을 수 있을 것 같다. <small>(오히려 이런 츤데레가 더 매력적일 수도 있다)</small></p><p>마찬가지로 필자는 경영진이 정말 수평적인 커뮤니케이션과 피드백을 원한다면 “편하게 대해달라”라는 말보다는, 경영진이 먼저 직원들에게 편하게 다가오고 주기적인 교육을 통해 우리는 수평적인 관계라는 사실을 이야기하며, 실제로 피드백을 받았을 때도 긍정적인 반응을 보이는 등의 행동을 실천함으로써 직원들에게 꾸준한 신뢰를 줘야한다고 생각한다.</p><p>그 신뢰란, 내가 이 사람에게 피드백을 줘도 나에게 불이익이 없을 것이라는 신뢰, 그리고 내 피드백이 이 사람에게 받아들여질 수 있다는 신뢰, 이 피드백으로 인해 우리 조직이 전체적으로 발전할 수 있을 것이라는 신뢰다.</p><p>그래서 직급과 관계없이 자유롭게 피드백을 주고 받는 문화를 가지고 있는 기업들을 보면 주기적으로 타운홀 미팅을 하면서 공개적으로 직원들에게 피드백을 받거나, 대표가 먼저 피드백에 대해서 물어보고, 피드백에 대한 교육을 실시하는 등 지속적으로 노력하고 있는 모습을 볼 수 있다.</p><p>즉, 직원과 경영진 간 투명한 피드백을 주고받는 문화는 “솔직함” 뿐만 아니라 경영진이 직접 노력하는 모습을 보여줌으로써 직원들과 신뢰를 쌓는 과정 또한 중요하다고 할 수 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>패티 맥코드의 파워풀은 넷플릭스의 핵심 기업 문화인 “자유와 책임”에 대한 전반적인 내용을 재미있게 설명하고 있는 책이다. 필자 또한 지금까지 스타트업에서 일을 해오면서 자연스럽게 자유와 책임을 함께 가져야하는 문화를 몸에 익혔기 때문에 여러모로 공감이 갔다.</p><p>그리고 패티 맥코드가 이야기한 “솔직함”에 대한 내용 또한 많은 공감이 갔다. 뒤에서 이야기하지말고 당사자에게 직접 이야기하라는 것이나, 서로의 발전을 위해 솔직한 피드백을 주고 받으라는 것, 조직 내의 모든 사람은 비즈니스에 대해 뭐든지 질문하고 대답할 수 있어야한다는 것들 말이다.</p><p>넷플릭스는 이러한 자유와 책임이라는 기업 문화를 이끌어나가기 위해 직원들을 프로페셔널리즘을 가진 “어른”으로 대하고, 또 그런 사람을 채용하려고 많은 노력을 기울인다.</p><p>그러나 어른이라고 한들 감정이 없는 로봇은 아니라는 점을 잊어서는 안된다.</p><p>사실 프로페셔널한 어른이라면 자기 감정 정도는 스스로 컨트롤하고 건설적인 마인드로 일을 한다. 하지만 위에서 언급했듯이 감정을 도저히 숨기기 힘든 상황도 있을 것이다. 그럴때는 솔직한 피드백보다는 커피 한잔과 함께 건네는 따뜻한 위로가 팀워크를 더 향상시켜줄 수도 있지 않을까?</p><p>우리는 사회에서 많은 사람과 일을 하고 경험을 쌓으며 무의식적으로 상대방의 감정을 건드리는 선을 넘지 않는 법을 배운다. 그러나 무의식적으로 선을 넘지 않는 것과 의식적으로 동료를 배려하고 존중하는 마음은 엄연히 다른 것이다.</p><p>함께 일을 하면서 서로에게 자극이 되는 동료, 어려운 문제를 함께 해결할 수 있는 동료도 물론 좋지만, 단순히 그것만으로 팀워크가 돈독해지지는 않는다. 튼튼한 팀워크를 만들기 위해서는 훌륭한 동료라는 조건 저변에 팀원에 대한 인간적인 신뢰도 함께 동반되어야한다고 생각한다.</p><p>이상으로 솔직한 피드백으로 좋은 팀워크를 만들 수 있을까? 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/12/04/about-honestly-feedback/#disqus_thread</comments>
    </item>
    
    <item>
      <title>사이 좋게 네트워크를 나눠 쓰는 방법, TCP의 혼잡 제어</title>
      <link>https://evan-moon.github.io/2019/11/26/tcp-congestion-control/</link>
      <guid>https://evan-moon.github.io/2019/11/26/tcp-congestion-control/</guid>
      <pubDate>Tue, 26 Nov 2019 08:23:57 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;혼잡 제어란, 말 그대로 네트워크의 혼잡 상태를 파악하고 그 상태를 해결하기 위해 데이터 전송을 제어하는 것을 이야기한다.&lt;/p&gt;
&lt;p&gt;네트워크는 워낙 광대한 블랙박스이기 때문에 정확히 어디서 어떤 이유로 전송이 느려지는지는 파악하기 힘들지만, 단순히 &lt;code&gt;느려지고있다&lt;/code&gt; 정도는 각 종단에서도 충분히 파악할 수 있다. 그냥 데이터를 보냈는데 상대방으로부터 응답이 늦게 오거나 안오면 뭔가 문제가 있다는 것이니 말이다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>혼잡 제어란, 말 그대로 네트워크의 혼잡 상태를 파악하고 그 상태를 해결하기 위해 데이터 전송을 제어하는 것을 이야기한다.</p><p>네트워크는 워낙 광대한 블랙박스이기 때문에 정확히 어디서 어떤 이유로 전송이 느려지는지는 파악하기 힘들지만, 단순히 <code>느려지고있다</code> 정도는 각 종단에서도 충분히 파악할 수 있다. 그냥 데이터를 보냈는데 상대방으로부터 응답이 늦게 오거나 안오면 뭔가 문제가 있다는 것이니 말이다.</p><a id="more"></a><p>이때 위에서 이야기한 흐름 제어나 오류 제어 기법들만을 사용하다보면 자연스럽게 <code>재전송</code>이라는 작업이 계속 반복될 수 밖에 없다.</p><p>이게 한 두 녀석이 그러면 별 문제가 안될지도 모르지만, 네트워크는 워낙 다양한 친구들이 함께 이용하는 공간이다보니까 한번 네트워크가 뻑나기 시작하면 여기저기서 <code>나도 재전송할꺼야!</code>가 반복되면서 문제가 점점 악화될 것이다. 이를 네트워크의 혼잡 붕괴라고 부른다.</p><p>그래서 이런 식으로 네트워크의 혼잡 상태가 감지되면, 이런 최악의 상황을 최대한 회피하기 위해 송신 측의 윈도우 크기를 조절하여 데이터의 전송량을 강제적으로 줄이게 되는데, 이것이 바로 <code>혼잡 제어</code>인 것이다.</p><h2 id="혼잡-윈도우-Congestion-Window-CWND"><a href="#혼잡-윈도우-Congestion-Window-CWND" class="headerlink" title="혼잡 윈도우(Congestion Window, CWND)"></a>혼잡 윈도우(Congestion Window, CWND)</h2><p>필자는 <a href="/2019/11/22/tcp-flow-control-error-control/" title="패킷의 흐름과 오류를 제어하는 TCP">패킷의 흐름과 오류를 제어하는 TCP</a> 포스팅에서 TCP의 흐름 제어를 설명할 때 송신 측의 윈도우 크기는 수신 측이 보내준 윈도우 크기와 네트워크 상황을 함께 고려해서 정해진다는 이야기를 했었다.</p><p>송신 측은 자신의 최종 윈도우 크기를 정할 때 수신 측이 보내준 윈도우 크기인 <code>수신자 윈도우(RWND)</code>, 그리고 자신이 네트워크의 상황을 고려해서 정한 윈도우 크기인 <code>혼잡 윈도우(CWND)</code> 중에서 더 작은 값을 사용한다.</p><p>즉, 아래 후술할 혼잡 제어 기법들이 늘였다 줄였다 하는 윈도우 크기는 송신 윈도우가 아니라 송신 측이 가지고 있는 <code>혼잡 윈도우 크기</code>인 것이다.</p><p>참고로 RWND나 CWND가 그냥 윈도우라는 의미를 가지고 있기 때문에, 슬라이딩 윈도우에서 사용하는 윈도우와 같은 개념이라고 생각할 수 있는데, 얘네는 각각 수신자 윈도우 크기와 혼잡 윈도우 크기를 의미하는 숫자다.</p><p>그럼 통신 중에는 어떻게든 네트워크의 혼잡도를 파악해서 혼잡 윈도우 크기를 유연하게 변경한다고 해도, 통신을 시작하기 전에는 이 혼잡 윈도우 크기를 어떻게 초기화하는 것일까?</p><h3 id="혼잡-윈도우-크기-초기화하기"><a href="#혼잡-윈도우-크기-초기화하기" class="headerlink" title="혼잡 윈도우 크기 초기화하기"></a>혼잡 윈도우 크기 초기화하기</h3><p>통신을 하는 중간에는 ACK가 유실된다거나 타임아웃이 난다거나 하는 등의 정보를 사용하여 네트워크의 혼잡 상황을 유추할 수 있지만, 통신을 시작하기 전에는 그런 정보가 하나도 없기 때문에 혼잡 윈도우의 크기를 정하기가 조금 애매하다. 여기서 등장하는 것이 바로 <code>MSS(Maximum Segement Size)</code>이다.</p><p>MSS는 한 세그먼트에 최대로 보낼 수 있는 데이터의 양을 나타내는 값인데, 대략 다음과 같은 계산을 통해 구할 수 있다.</p><blockquote><p><strong>MSS</strong> = MTU - (IP헤더길이 + IP옵션길이) - (TCP헤더길이 + TCP옵션길이)</p></blockquote><p>여기서 등장하는 <code>MTU(Maximum Transmission Unit)</code>라는 친구는 <code>한번 통신 때 보낼 수 있는 최대 단위</code>를 의미한다.</p><p>즉, MSS는 한번 전송할 때 보낼 수 있는 최대 단위가 정해져있는 상황에서 IP 헤더, TCP 헤더 등 데이터가 아닌 부분을 전부 발라내고 진짜 데이터를 담을 수 있는 공간이 얼마나 남았는지를 나타내는 것이다.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/mtu-setting.png" width="500"><br>  <small>시스템 환경 설정에서 잘 찾아보면 기본 MTU를 변경할 수 있는 설정이 있다</small><br>  <br><br></center><p>OSX 같은 경우는 MTU 기본 값으로 이더넷 표준인 <code>1500 bytes</code>가 설정되어있다. 이때 TCP와 IP의 헤더크기가 각각 20 bytes라고 하면 MSS는 <code>1500 - 40 = 1460 bytes</code>가 되는 것이다.</p><p>송신 측은 처음 통신을 시작할 때 이렇게 계산한 MSS를 사용하여 혼잡 윈도우의 크기를 <code>1 MSS</code>로 설정한다. 이후 통신을 하면서 네트워크의 혼잡 상황을 고려하며 혼잡 윈도우 크기를 증가시키거나 감소시키는 것이다.</p><h2 id="혼잡-회피-방법"><a href="#혼잡-회피-방법" class="headerlink" title="혼잡 회피 방법"></a>혼잡 회피 방법</h2><p>할배 프로토콜인 TCP는 지난 50년 동안 지속적으로 개선된 다양한 혼잡 제어 정책들을 가지고 있다.</p><p>각 혼잡 제어 정책은 어떤 시점을 혼잡한 상태라고 파악할 것인지, 혼잡 윈도우 크기를 줄이거나 키우는 방법을 개선하여 점점 발전해왔지만, 가장 기본적인 혼잡 제어 방법은<code>AIMD</code>와 <code>Slow Start</code>라는 혼잡 회피 방법을 상황에 맞게 조합하는 것이다.</p><p>그래서 이 포스팅에서도 기본적인 혼잡 회피 방법인 <code>AIMD</code>와 <code>Slow Start</code>를 먼저 설명하고나서 대표적인 혼잡 제어 정책인 <code>Tahoe</code>와 <code>Reno</code>를 이야기할 것이다.</p><h3 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h3><p><code>AIMD(Additive Increase / Multicative Decrease)</code> 방식은 우리 말로 직역하면 합 증가 / 곱 감소 방식이라는 뜻이다. 즉, 네트워크에 아직 별 문제가 없어서 전송 속도를 더 빠르게 하고 싶다면 혼잡 윈도우 크기를 1씩 증가시키지만, 중간에 데이터가 유실되거나 응답이 오지 않는 등의 혼잡 상태가 감지되면 혼잡 윈도우 크기를 반으로 줄인다.</p><p>늘어날 때는 <code>ws + 1</code>, 줄어들 때는 <code>ws * 0.5</code>이므로 말 그대로 <code>합 증가 / 곱 감소</code>인 것이다. 이렇게 늘어날 때는 선형적으로 조금씩 늘어나고 줄어들 때는 반으로 확 줄어드는 AIMD 방식의 특성 상, 이 방식을 사용하는 연결의 혼잡 윈도우 크기를 그래프로 그려보면 다음과 같은 톱니 모양이 나타난다.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/aimd.png" width="500"><br>  <br><br></center><p>이 방식은 굉장히 심플하지만 생각보다 공평한 방식이다. 예를 들어 여러 친구들이 이미 네트워크를 점유하고 있는 상태에서 한 친구가 뒤늦게 이 네트워크에 합류했다고 생각해보자.</p><p>당연히 나중에 진입한 쪽의 혼잡 윈도우 크기가 작기 때문에 처음에는 불리하다. 그러나 네트워크가 혼잡해지면 혼잡 윈도우 크기가 작은 놈보다 혼잡 윈도우 크기가 큰 놈이 무리하게 데이터를 왕창 보내려다가 유실될 확률도 더 크다.</p><p>이런 상황이라면 네트워크에 일찍 참여해서 이미 혼잡 윈도우 크기가 큰 놈은 자신의 윈도우 크기를 줄여서 혼잡 상황을 해결하려고 할 것이고, 이때 남은 대역폭을 활용하여 나중에 들어온 놈들이 자신의 혼잡 윈도우 크기를 키울 수 있는 것이다.</p><p>그런 이유로 시간이 가면 갈수록 네트워크에 참여한 순서와 관계 없이 모든 호스트들의 윈도우 크기가 평행 상태로 수렴하게 되는 것이다.</p><p>그러나 AIMD의 문제점은 네트워크 대역이 펑펑 남아도는 상황에도 윈도우 크기를 너무 조금씩 늘리면서 접근한다는 것이다. 그런 이유로 AIMD 방식은 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 조금 걸린다.</p><h4 id="윈도우-크기가-수렴한다고"><a href="#윈도우-크기가-수렴한다고" class="headerlink" title="윈도우 크기가 수렴한다고?"></a>윈도우 크기가 수렴한다고?</h4><p>사실 AIMD는 워낙 단순한 방식이다 보니 간단한 예제를 통해 네트워크의 상황을 재현해볼 수도 있다. 이렇게 직접 구현해보면 말로만 들었을 때는 애매한 <code>호스트들의 윈도우 크기가 평행으로 수렴한다는 것</code>이 어떤 의미인지 직접 눈으로 확인해볼 수도 있다.</p><p>코드를 직접 포스팅에 첨부하려고 했는데, 최대한 실제 네트워크와 비슷한 환경을 재현하려고 하다보니 코드가 생각보다 길어져서 결과만 첨부하려고 한다. 우선 필자의 실험 방식은 다음과 같다.</p><blockquote><ol><li>네트워크의 혼잡도 최고치는 <code>50</code>이며, 이 혼잡도는 네트워크에 참여한 호스트들이 가진 혼잡 윈도우 크기의 총합으로 결정된다.</li><li>네트워크에 호스트를 <code>300ms</code>에 하나씩 생성해서 추가한다.</li><li>각 호스트는 <code>100 ~ 200ms</code> 마다 네트워크의 현재 혼잡도를 계산하고 자신의 윈도우 크기를 조절한다.</li><li>각 호스트는 윈도우 크기 조절을 300회까지 수행하고 네트워크를 빠져나간다.</li></ol></blockquote><p>참고로 이 테스트에는 약간의 허점이 있다. 필자는 호스트들의 연산에 동시성을 부여하기 위해 <code>setInterval</code>을 사용했는데, <code>setInterval</code>의 콜백도 이벤트 루프를 거친 후 결국 콜 스택을 쌓아가며 수행되기 때문에 실제 네트워크처럼 호스트들의 연산에 완전한 병렬성이 보장되지는 않는다.</p><p>그래서 테스트의 목적인 네트워크에 늦게 참여한 호스트들도 충분한 혼잡 윈도우 크기를 가질 수 있는지 확인하는 용도로는 딱히 별 문제가 없기 때문에 그대로 진행했다.</p><p>이에 대한 자세한 개념은 <a href="/2019/08/01/nodejs-event-loop-workflow/" title="로우 레벨로 살펴보는 Node.js 이벤트 루프">로우 레벨로 살펴보는 Node.js 이벤트 루프</a>에 자세히 설명되어있으니 확인해보도록 하자.</p><p>어쨌든 이렇게 테스트를 해보고 나온 데이터들을 시계열 그래프로 시각화해보았다. 먼저 각 호스트들의 혼잡 윈도우 크기 변화를 살펴보자.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/cwnd-chart.png"><br>  <br><br></center><p>그래프를 살펴보니 먼저 네트워크에 들어와있던 호스트들과 뒤늦게 네트워크에 합류한 호스트들의 혼잡 윈도우 크기에 그렇게 큰 차이가 없는 모습을 확인할 수 있었다. 마지막에 혼자 치솟고 있는 친구는 다른 호스트들이 다 빠져나간 후에 네트워크가 텅텅 비어서 그런 것이다.</p><p>이런 식으로 시각화를 해보니 각 호스트들의 혼잡 윈도우 크기가 큰 차이 없이 어느 부분에 수렴하고 있다는 것을 확인할 수 있었다. 그렇다면 네트워크에 들어와있는 호스트들의 전체 윈도우 크기는 시계열 그래프로 시각화해보면 어떨까?</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/total-cwnd-chart.png"><br>  <br><br></center><p>확실히 네트워크 내 전체 호스트의 혼잡 윈도우 크기를 보니 필자가 설정해놓은 네트워크 혼잡도인 <code>50</code>을 넘어가지 않는 선에서 자기들끼리 엎치락뒤치락 윈도우 크기를 조절하고 있는 모습을 확인할 수 있었다.</p><p>마찬가지로 이 그래프를 확인해보아도 호스트들이 네트워크에 입퇴장하는 초반부와 후반부를 제외하면 중간 즈음에서는 각 호스트들의 혼잡 윈도우 크기가 크게 차이나지 않는다.</p><p>이렇게 직접 상황을 시뮬레이션해보고 데이터를 확인하니 말로만 들었을 때는 잘 와닿지 않았던 <code>윈도우 크기가 평행 상태로 수렴한다</code>는 이야기를 조금 더 잘 이해할 수 있었다.</p><p>만약 이 코드를 직접 실행시켜서 모든 과정을 확인하고 싶은 분들은 필자가 올려놓은 <a href="https://github.com/evan-moon/tcp-congestion-test" target="_blank" rel="noopener">깃허브 레파지토리</a>에서 클론받아서 실행시켜보면 된다.</p><h3 id="Slow-Start"><a href="#Slow-Start" class="headerlink" title="Slow Start"></a>Slow Start</h3><p>위에서 이야기했듯이 AIMD 방식은 윈도우 크기를 선형적으로 증가시키기 때문에, 제대로 된 속도가 나오기까지 시간이 조금 걸리는 단점이 있다.</p><p>사실 요즘에는 네트워크의 대역폭이 워낙 넓고 통신 인프라도 좋다보니 예전에 비해서 네트워크의 혼잡 상황 발생하는 빈도가 많이 줄어들었기 때문에, 혼잡이 발생하지도 않았는데 제대로 속도를 내는데까지 오래걸리는 AIMD 방식의 단점이 점점 부각되었다.</p><p>반면, <code>Slow Start</code>는 기본적인 원리는 AIMD와 비슷하지만 윈도우 크기를 증가시킬 때는 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 <code>1</code>로 줄여버리는 방식이다.</p><p>이 방식은 보낸 데이터의 ACK가 도착할 때마다 윈도우 크기를 증가시키기 때문에 처음에는 윈도우 크기가 조금 느리게 증가할지 몰라도, 시간이 가면 갈수록 윈도우 크기가 점점 빠르게 증가한다는 장점이 있다.</p><p>기본적으로 AIMD와 어떤 방식으로 윈도우 크기를 증가시키냐, 감소시키냐의 차이만 존재하기 때문에, 위에서 작성한 예시에서 윈도우 사이즈를 변경하는 부분만 변경하면 Slow Start의 차트를 그려볼 수 있다.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/slow-start-chart.png"><br>  <br><br></center><p>데이터를 확인해보면 필자가 정해놓은 네트워크 혼잡도의 최고치인 <code>50</code>보다 호스트들의 혼잡 윈도우 크기가 커지는 경우가 발생하는데, 이건 자바스크립트가 <code>setInterval</code>의 콜백을 처리하는 과정에서 발생한 문제이므로 실제 네트워크에서는 이러지 않는다. <small>(애초에 혼잡도를 이렇게 간단히 계산하지도 않는다)</small></p><p>AIMD와 Slow Start 그래프의 가장 큰 차이점은 네트워크 혼잡도의 최고치에 도달하는 시간이다.</p><p>AIMD는 윈도우 크기를 선형적으로 키워나가기 때문에 다른 호스트들이 새로 들어올 때 많은 부분을 점유할 수 없었지만, Slow Start 방식을 사용하면 처음에는 윈도우 크기를 느리게 키우다가 아직 여유가 있다고 판단되면 지수적으로 팍팍 증가시킬 수 있으므로 결과적으로 AIMD보다 윈도우 크기를 더 빠르게 키울 수 있는 것이다.</p><p>최근의 TCP에서 사용하고 있는 <code>Tahoe</code>나 <code>Reno</code>와 같은 정책들은 AIMD와 Slow Start를 적절히 섞어서 사용하되, 네트워크 혼잡 상황이 발생했을 때 어떻게 대처하는 지에 따라서 나뉘어지게 된다.</p><h2 id="혼잡-제어-정책"><a href="#혼잡-제어-정책" class="headerlink" title="혼잡 제어 정책"></a>혼잡 제어 정책</h2><p>TCP에는 Tahoe, Reno, New Reno, Cubic, 최근 나온 Elastic-TCP까지 일일히 나열하기에도 숨 가쁠 정도로 다양한 혼잡 제어 정책이 존재한다.</p><p>이러한 혼잡 제어 정책들은 공통적으로 <code>혼잡이 발생하면 윈도우 크기를 줄이거나, 혹은 증가시키지 않으며 혼잡을 회피한다</code>라는 전제를 깔고 있고, 최근에 나온 방법은 예전 방법들에 비해서 더 똑똑하게 혼잡 상황을 감지하고 네트워크 대역을 최대한 빠르고 안전하게 활용할 수 있는 방향으로 개발된 것이다.</p><p>하지만 이 친구들을 이 포스팅에서 전부 설명하기는 힘드니, 이 중에서 가장 대표적이고 유명한 정책인 <code>Tahoe</code>와 <code>Reno</code>를 위주로 혼잡 제어의 기본 방식에 대해서 설명하려고 한다.</p><p><code>Tahoe</code>와 <code>Reno</code>는 기본적으로 처음에는 Slow Start 방식을 사용하다가 네트워크가 혼잡하다고 느껴졌을 때는 AIMD 방식으로 전환하는 방법을 사용하는 정책들이다.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/taheo_reno.png" width="500"><br>  <small>붉은 색이 Tahoe, 녹색이 Reno의 윈도우 크기를 나타낸다</small><br>  <br><br></center><p>위 그래프의 Y축은 혼잡 윈도우, X축은 시간으로 하여 Tahoe와 Reno의 작동 방식을 설명하고 있다. 본격적으로 Tahoe와 Reno를 알아보기에 앞서, 일단 이 그래프가 뭘 설명하고 있는지 빠르게 이해하기 위해 간단한 용어를 몇 가지만 짚고 넘어가도록 하겠다.</p><p>그래프가 꺾이는 곳에 적혀있는 <code>3 ACK Duplicated</code>, <code>Timeout</code>과 그래프의 상승 폭이 변하고 있는 <code>Threshold</code>에 대해서 알아보도록 하자. <small>(그림의 철자가 이상한 이유는 영어가 아니라 이탈리아어라서 그런 것이니 신경쓰지말자)</small></p><p><strong>3 ACK Duplicated, Timeout</strong><br>일단 두 방식 모두 <code>3 ACK Duplicated</code>와 <code>Timeout</code>이라는 두 가지 시나리오가 발생하면 윈도우 크기를 줄이는 것을 확인해볼 수 있다. 즉, 이 두 상황이은 혼잡 제어 정책들이 <code>혼잡 발생</code>을 감지하는 기본적인 상황인 것이다.</p><p>타임아웃은 말 그대로 여러가지 요인으로 인해 송신 측이 보낸 데이터 자체가 유실되었거나, 수신 측이 응답으로 보낸 ACK가 유실되는 경우를 뜻하는 것이다.</p><p><code>3 ACK Duplicated</code>, 즉 송신 측이 3번 이상 중복된 승인 번호를 받은 상황 또한 정상적으로 데이터가 전송된 상황은 아닌데, 수신 측은 자신이 정상적으로 처리한 데이터에 대해서만 ACK를 보내기 때문에 동일한 승인 번호를 세 번이나 받은 상황은 어떤 이유로 인해 수신 측이 특정 시퀀스 번호 이후의 데이터를 제대로 처리하지 못한 상황이라고 볼 수 있다.</p><p>단, 패킷 전송 방식을 사용하는 TCP의 특성 상 수신 측이 받는 패킷의 순서가 늘 순서대로 받으리라는 보장은 없으므로, 한 두개의 중복 승인 번호가 발생했다고 해서 바로 네트워크가 혼잡하다고 판단하지는 않는다.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/fast-transmit.png" width="500"><br>  <br><br></center><p>TCP는 현재까지 누적된 정상 데이터 중 가장 마지막 데이터에 대한 승인 번호를 보내주는 <code>누적 승인 방식(Cumulative Acknowledgement)</code>를 사용하기 때문에, 송신 측이 같은 승인 번호를 계속 중복해서 받는다면 해당 데이터까지는 정상적으로 전송되었으나 그 이후부터는 뭔가 문제가 발생했다고 알 수 있는 것이다.</p><p>이때 3번의 중복 승인 번호로 인해 송신 측이 바로 해당 승인 번호에 해당하는 데이터를 전송하고나면 수신 측은 Go back N이나 Selective Repeat과 같은 오류 제어 방식에 따라서 다음에 어떤 패킷부터 보내줘야하는지 알려줄 것이다.</p><p>이런 상황일 경우, 송신 측은 자신이 설정한 타임아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있는데, 이 기법을 <code>빠른 재전송(Fast Transmit)</code>이라고 한다.</p><p>만약 빠른 재전송 기법을 사용하지 않는다면, 송신 측은 자신이 설정한 타임아웃 시간이 지난 이후에야 대처할 수 있기 때문에 에러난 데이터를 재전송하기까지 시간이 낭비되게 될 것이다.</p><p><strong>Slow Start 임계점(ssthresh)</strong></p><p>Tahoe와 Reno를 비교하는 그래프를 보면 <code>Threshold(임계점)</code>이라는 단어가 꽤 많이 등장하고 있는 것을 볼 수 있는데, 이 임계점은 <code>Slow Start Threshold(ssthresh)</code>를 뜻하는 것으로, <code>여기까지만 Slow Start를 사용하겠다</code>라는 의미를 가진다.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/ssthresh.png" width="500"><br>  <br><br></center><p>이 값을 사용하는 이유는 Slow Start를 사용하며 윈도우 크기를 지수적으로 증가시키다보면 어느 순간부터는 윈도우 크기가 기하급수적으로 늘어나서 제어가 힘들어지기도 하고, 네트워크의 혼잡이 예상되는 상황에서는 빠르게 값을 증가시키는 것보다 돌다리 두들겨 건너듯이 조금씩 증가시키는 편이 훨씬 안전하기 때문이다.</p><p>쉽게 생각해서 현재 윈도우 크기가 <code>10</code>이고 현재 네트워크에 남은 공간이 <code>15</code>라고 할 때, Slow Start 방식으로 윈도우 크기를 증가시키면 <code>20</code>을 넘겨버리지만 합 증가를 하게 되면 앞으로 한 5번은 윈도우 크기를 더 증가시킬 수 있다.</p><p>그래서 특정한 <code>임계점(Threshold)</code>를 정해놓고, 임계점을 넘어가게되면 AIMD 방식을 사용하여 선형적으로 윈도우 크기를 증가시킨다. 그래서 이 임계점을 칭하는 단어가 <code>ssthresh(Slow Start Threshold)</code>인 것이다.</p><p>송신 측은 본격적인 통신이 시작하기 전에 ssthresh 값을 자신의 혼잡 윈도우의 절반 크기인 <code>0.5 MSS</code>으로 초기화하고, 이후 어떤 혼잡 제어 방법을 사용하냐에 따라 다르게 대처하게된다.</p><h3 id="TCP-Tahoe"><a href="#TCP-Tahoe" class="headerlink" title="TCP Tahoe"></a>TCP Tahoe</h3><p>TCP Tahoe는 Slow Start를 사용한 혼잡 제어 정책의 초기 버전으로, 위에서 설명한 <code>빠른 재전송(Fast Transmit)</code> 기법이 처음으로 도입된 방법이다. Tahoe 이후의 혼잡 제어 정책은 Tahoe와 마찬가지로 빠른 재전송 기법을 기본으로 사용하되, 효율을 위해 몇 가지 양념을 더 치게 된다.</p><p>참고로 TCP Tahoe는 미국 네바다주에 있는 타호 호수의 이름을 따서 지어졌으므로 그냥 <code>타호</code>라고 읽으면 된다. <small>(타호에가 아니다!)</small></p><center><br>  <img src="/2019/11/26/tcp-congestion-control/lake_tahoe.jpeg" width="500"><br>  <small>왜 여기서 이름을 따왔는지는 모르겠지만 호수가 이쁘긴 하다</small><br>  <br><br></center><p>Tahoe는 처음에는 Slow Start를 사용하여 자신의 윈도우 크기를 지수적으로 빠르게 증가시키다가 ssthresh를 만난 이후부터는 AIMD에서 사용하는 합 증가 방식을 사용하여 선형적으로 윈도우 크기를 증가시킨다.</p><p>그러다가 위에서 언급한 ACK Duplicated나 Timeout이 발생하면 네트워크에 혼잡이 발생했다고 판단하고, ssthresh와 자신의 윈도우 크기를 수정하게 된다. 조금 더 편한 이해를 위해 Tahoe의 혼잡 윈도우 크기 변화 그래프를 살펴보도록 하자.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/tahoe-ssthresh.png" width="500"><br>  <br><br></center><p>위 그래프에서 청록색 선은 송신 측의 혼잡 윈도우 크기를, 굵은 검정선은 ssthresh 값을 보여주고 있다. 이 시나리오에서 송신 측의 혼잡 윈도우 크기는 <code>8</code>로 초기화되었고, 그에 따라 ssthresh는 <code>8 * 0.5 = 4</code>로 설정된 것을 볼 수 있다.</p><p>송신 측은 임계점을 만나기 전까지 Slow Start 방식을 사용하여 자신의 윈도우 크기를 지수적으로 증가시키다가 ssthresh를 넘어선 이후부터는 선형적으로 증가시키고 있다. 이때 <code>3 ACK Duplicated</code>나 <code>Timeout</code>과 같은 혼잡 상황이 발생하면 어떻게 될까?</p><p>그래프를 보면 가장 처음 혼잡 상황이 발생한 상태의 혼잡 윈도우 크기는 <code>6</code>이다. 이때 송신 측은 ssthresh를 6의 절반인 <code>3</code>으로 변경하고, 자신의 혼잡 윈도우 크기를 다시 <code>1</code>로 변경하는 모습을 확인할 수 있다. 이후 다시 Slow Start로 시작하여 임계점에 도달하면 합 증가로 변경하는 방법을 반복하게 된다.</p><p>즉, 이전에 한 대 맞았던 지점을 기억하고 그 지점이 가까워지면 조금씩 몸을 사리는 원리인 것이다. 이런 접근법은 나름 합리적인 방법이다.</p><p>그러나 실버 불렛은 없는 법. Tahoe의 단점은 초반의 Slow Start 구간에서 윈도우 크기를 키울때 너무 오래 걸린다는 것이다. 물론 전체적으로 보았을 때 합 증가 방식보다는 지수 증가 방식이 빠르겠지만, 그래도 혼잡 상황이 발생했을 때 다시 윈도우 크기를 <code>1</code>부터 키워나가야 한다는 점은 어찌보면 낭비일 수도 있다.</p><p>그래서 나온 방법이 <code>빠른 회복(Fast Recovery)</code> 방식을 활용한 <code>TCP Reno</code>이다.</p><h3 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h3><p>TCP Reno는 TCP Tahoe 이후에 나온 정책으로, Tahoe와 마찬가지로 Slow Start로 시작하여 임계점을 넘어서면 합 증가로 변경하는 방법이다.</p><p>그러나 Tahoe는 명확한 차이가 있는데, 바로 <code>3 ACK Duplicated</code>와 <code>Timeout</code>을 구분한다는 것이다. Reno는 3개의 중복 ACK가 발생했을 때, 윈도우 크기를 1로 줄이는 것이 아니라 AIMD처럼 반으로만 줄이고 sshthresh를 줄어든 윈도우 값으로 정하게 된다.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/reno-ssthresh.png" width="500"><br>  <br><br></center><p>위 그래프는 앞서와 마찬가지로 청록색으로 송신 측의 혼잡 윈도우 크기를, 굵은 검정선으로 ssthresh를 표현하고 있다.</p><p>Reno는 Tahoe와 다르게 3개의 중복 ACK가 발생했을 때는 혼잡 윈도우 크기를 1로 줄이는 것이 아니라 반으로 줄인 후 합 증가를 하게 되는데, 이 방식은 혼잡 윈도우 크기를 1로 줄이고 처음부터 다시 시작하는 Tahoe에 비해서 빠르게 원래 윈도우 크기에 도달할 수 있기 때문에 <code>빠른 회복(Fast Recovery)</code>라고 불린다.</p><p>이때 ssthresh는 줄어든 윈도우의 크기와 동일하게 설정하게 된다. 위 그래프에서도 혼잡 상황이 발생하자 혼잡 윈도우 크기를 <code>6</code>에서 <code>3</code>으로 줄이고 ssthresh 또한 <code>3</code>으로 설정하는 모습을 볼 수 잇다.</p><p>그러나 만약 타임아웃에 의해 데이터가 손실되면 Tahoe와 마찬가지로 윈도우 크기를 바로 1로 줄여버리고 Slow Start를 진행하고 이때는 ssthresh를 변경하지 않는다.</p><p>즉, ACK가 중복된 상황과 타임아웃이 발생한 상황을 구분하면서 대처를 다르게 하고 있는 것이다. ACK 중복은 타임아웃에 비해 그리 큰 혼잡이 아니라고 가정하고 혼잡 윈도우 크기를 <code>1</code>로 줄이지도 않는다는 점에서 어느 정도 혼잡 상황에 경중을 따지고 있다는 것도 알 수 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번에는 TCP의 혼잡 제어 정책에 대해서 알아보았다. 사실 필자가 포스팅에서 소개한 Taheo와 Reno 같은 혼잡 제어 정책은 최근에는 많이 사용되지 않는 구식이다.</p><p>예전에 개발된 Tahoe나 Reno 같은 경우는 말 그대로 예전의 네트워크 환경을 고려하며 설계된 친구들이라 최근의 대역폭 빵빵한 네트워크에는 다소 맞지 않는 것이 현실이다.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/cubic_vs_tahoe.png" width="500"><br>  <small>높은 대역폭에서의 Tahoe와 CUBIC의 효율 차이를 보면 어마무시하다</small><br>  <br><br></center><p>사실 Tahoe나 Reno가 개발된 시절의 네트워크 대역폭에 비교하면 최근의 네트워크 대역폭은 적어도 1,000배는 더 여유가 있지 않을까?</p><p>그 말인 즉슨, 송신 측이 자신의 혼잡 윈도우 크기를 마음 놓고 팍팍 늘렸을 때 문제가 발생할 확률이 예전보다 많이 낮아졌다는 뜻이다. 그래서 최근의 혼잡 제어 정책들은 얼마나 더 빠르게 혼잡 윈도우 크기를 키우고, 어떻게 혼잡 감지를 더 똑똑하게 할 것이냐에 대해 초점이 맞춰져있다.</p><center><br>  <img src="/2019/11/26/tcp-congestion-control/cubic_function.gif" width="400"><br>  <small>3차 함수의 특성을 사용하는 TCP CUBIC은</small><br>  <small>혼잡을 회피할 때는 거의 윈도우 크기를 증가시키지 않다가, 혼잡이 해결되면 다시 폭발적으로 증가시킬 수 있다</small><br>  <br><br></center><p>그러나 필자가 굳이 예전 방식인 Tahoe와 Reno를 소개한 이유는 TCP 사용 초반에 개발된 혼잡 제어 방식인 만큼 원리가 간단하기도 하고, 이후 개발된 방식들도 큰 틀은 Tahoe와 Reno와 같은 매커니즘에서 크게 벗어나지 않기 때문이다.</p><p>이 포스팅은 다양한 혼잡 제어 정책을 알아보는 것이 아니라, 혼잡 제어라는 매커니즘 자체가 어떤 식으로 흘러가는지 아는 것이 목표이므로 굳이 다른 혼잡 제어 정책은 소개하지 않았다.</p><p>만약 최근에 사용하는 혼잡 제어 정책이 궁금하신 분들은 아래 첨부한 링크에서 조금 더 살펴보도록 하자.</p><blockquote><ul><li><a href="http://squidarth.com/rc/programming/networking/2018/08/01/congestion-cubic.html" target="_blank" rel="noopener">CUBIC</a></li><li><a href="http://squidarth.com/rc/programming/networking/2018/08/01/congestion-red.html" target="_blank" rel="noopener">RED</a></li><li><a href="https://ieeexplore.ieee.org/document/8642512" target="_blank" rel="noopener">Elastic TCP</a></li></ul></blockquote><p>이상으로 사이 좋게 네트워크를 나눠 쓰는 방법, TCP의 혼잡 제어 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/11/26/tcp-congestion-control/#disqus_thread</comments>
    </item>
    
    <item>
      <title>패킷의 흐름과 오류를 제어하는 TCP</title>
      <link>https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/</link>
      <guid>https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/</guid>
      <pubDate>Fri, 22 Nov 2019 07:46:25 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;code&gt;TCP(Transmission Control Protocol)&lt;/code&gt;은 원활한 통신을 위해 전송하는 데이터 흐름을 제어하고 네트워크의 혼잡 상태를 파악해서 대처하는 기능을 프로토콜 자체에 포함하고 있다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p><code>TCP(Transmission Control Protocol)</code>은 원활한 통신을 위해 전송하는 데이터 흐름을 제어하고 네트워크의 혼잡 상태를 파악해서 대처하는 기능을 프로토콜 자체에 포함하고 있다.</p><a id="more"></a><p>만약 TCP가 이런 기능들을 제공해주지 않는다면 개발자가 일일히 데이터를 어떤 단위로 보낼 것인지 정의해야하고, 패킷이 유실되면 어떤 예외처리를 해야하는 지까지 신경써야하기 때문에 TCP가 제공해주는 이러한 기능들 덕분에 우리는 온전히 상위 레이어의 동작에만 집중할 수 있는 것이다.</p><p>보통 TCP의 전송 제어 방법은 전송되는 데이터의 양을 조절하는 <code>흐름 제어</code>, 통신 도중에 데이터가 유실되거나 잘못된 데이터가 수신되었을 경우 대처하는 방법인 <code>오류 제어</code>, 네트워크 혼잡에 대처하는 <code>혼잡 제어</code>로 나누어진다.</p><p>물론 TCP 같은 전송 계층의 프로토콜을 어플리케이션 레이어에서 활동하는 개발자가 건드릴 일은 많이 없다. 그러나 혹시라도 이 부분에서 뭔가 문제가 발생했을 경우, TCP가 어떤 식으로 작동하는지 모른다면 고치는 건 둘째치고 원인 파악조차 하지 못하는 슬픈 상황이 발생할 수 있으므로 여러모로 알아두는 것이 좋다고 생각한다. <small>(더불어 야근도 따라올 것이다)</small></p><p>그런 의미에서 이번 포스팅에서는 TCP의 흐름 제어 기법들과 오류 제어 기법들에 대한 이야기를 한번 해보려고 한다.</p><h2 id="TCP의-흐름-제어"><a href="#TCP의-흐름-제어" class="headerlink" title="TCP의 흐름 제어"></a>TCP의 흐름 제어</h2><p>송신 측과 수신 측이 서로 데이터를 주고 받을 때, 여러가지 요인에 따라 이 두 친구들의 처리 속도가 달라질 수 있다. 이때 데이터를 받는 수신 측의 처리 속도가 송신 측보다 빠른 경우는 사실 별 문제가 없다.</p><p>주는 족족 빠르게 처리해주니 딱히 문제될 것이 없는 것이다. 그러나 수신 측의 처리 속도보다 송신 측이 더 빠른 경우 문제가 생긴다.</p><p>송신 측과 수신 측은 모두 데이터를 저장할 수 있는 버퍼를 가지고 있다. 이때 수신 측이 자신의 버퍼 안에 있는 데이터를 처리하는 속도보다 송신 측이 데이터를 전송하는 속도가 더 빠르다면, 당연히 수신 측의 버퍼는 언젠가 꽉 차버릴 것이기 때문이다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/overflow.jpg" width="400"><br>  <small>마치 꽉 찬 물컵에 물을 계속 붓는 상황이랄까</small><br>  <br><br></center><p>수신 측의 버퍼가 꽉 찬 상태에서 도착한 데이터는 더 이상 담아둘 공간이 없기 때문에 폐기 처분된다. 물론 이런 상황에서는 송신 측이 다시 데이터를 보내주기는 하겠지만, 데이터 전송이라는게 네트워크 환경에 따라 변수가 워낙 많은 작업이기 때문에 사실 이 작업을 줄일 수 있으면 줄이는 것이 가장 좋다.</p><p>그래서 송신 측은 수신 측의 데이터 처리 속도를 파악하고 자신이 얼마나 빠르게, 많은 데이터를 전송할 지 결정해야한다. 이것이 바로 TCP의 흐름 제어인 것이다.</p><p>수신 측은 자신이 처리할 수 있는 데이터의 양을 의미하는 <code>윈도우 크기(Window Size)</code>를 자신의 응답 헤더에 담아서 송신 측에게 전해주게 되고, 송신 측은 상대방에게 데이터를 보낼 때 이 윈도우 크기와 네트워크의 현재 상황을 참고해서 알맞은 양의 데이터를 보냄으로써 전체적인 데이터의 흐름을 제어하게 된다.</p><h3 id="Stop-and-Wait"><a href="#Stop-and-Wait" class="headerlink" title="Stop and Wait"></a>Stop and Wait</h3><p><code>Stop and Wait</code> 방식은 이름 그대로 상대방에게 데이터를 보낸 후 잘 받았다는 응답이 올 때까지 기다리는 모든 방식을 통칭하는 말이다. 이때 데이터를 받는 수신 측은 <code>잘 받았어!</code>와 <code>못 받았어...</code> 등의 대답을 해주게 되는데, 수신 측이 어떤 대답을 해주냐에 따라 사용할 수 있는 오류 제어 방법이 나눠지기도 한다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/stop-and-wait.png" width="300"><br>  <br><br></center><p>Stop and Wait로 흐름 제어를 할 경우의 대원칙은 단순히 <code>상대방이 응답을 하면 데이터를 보낸다</code>이기 때문에 구현 자체도 간단하고 프로그래머가 어플리케이션의 작동 원리를 파악하기도 쉬운 편이다.</p><p>기본적인 <code>ARQ(Automatic Repeat Request)</code>를 구현한다고 생각해보면, 수신 측의 윈도우 크기를 1 byte로 설정하고 <code>처리 가능 = 1</code>, <code>처리 불가능 = 0</code>과 같은 식으로 대충 구현해도 돌아가기는 하기 때문이다.</p><p>하지만 서로 <code>처리 가능</code>, <code>처리 불가능</code> 정도의 의미만 주고받는 방식은 간단한만큼 비효율적이라고 할 수도 있다. 왜냐하면 송신 측은 자신이 직접 데이터를 보내봐야 이 데이터를 수신 측이 처리할 수 있는지 알 수 있기 때문이다. 쉽게 말해서 이런 기초적인 Stop and Wait 방식은 그냥 될 때까지 주구장창 보내는 방식이라고 봐도 무방하다.</p><p>그런 이유로 Stop and Wait 방식을 사용하여 흐름 제어를 할 경우에는, 이런 비효율성을 커버하기 위해 이런 단순한 구현이 아닌 여러가지 오류 제어 방식을 함께 도입해서 사용한다.</p><h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><p>방금 알아본 바와 같이 Stop and Wait를 사용하여 흐름 제어를 하게 되면 비효율적인 부분이 있기 때문에, 오늘날의 TCP는 특별한 경우가 아닌 이상 대부분 <code>슬라이딩 윈도우(Sliding Window)</code> 방식을 사용한다. </p><p>슬라이딩 윈도우는 수신 측이 한 번에 처리할 수 있는 데이터를 정해놓고 그때그때 수신 측의 데이터 처리 상황을 송신 측에 알려줘서 데이터의 흐름을 제어하는 방식이다.</p><p>Stop and Wait과 여러 가지 차이점이 있겠지만, 사실 가장 큰 차이점은 송신 측이 <code>수신 측이 처리할 수 있는 데이터의 양</code>을 알고 있다는 점이다. 이 정보를 알고 있기 때문에 굳이 수신 측이 <code>처리 가능</code>이라는 대답을 일일히 해주지 않아도 데이터를 보내기 전에 이게 처리될 지 어떨지 어느 정도 예측이 가능하다는 말이다.</p><p>송신 측과 수신 측은 각각 데이터를 담을 수 있는 버퍼를 가지고 있고, 별도로 <code>윈도우</code>라는 일종의 마스킹 도구를 가지고 있다. 이때 송신 측은 이 윈도우에 들어있는 데이터를 수신 측의 응답이 없어도 연속적으로 보낼 수 있다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/window.png" width="500"><br>  <small>윈도우 안에 들어있는 프레임은 수신 측의 응답이 없이도 연속으로 보낼 수 있다</small><br>  <br><br></center><p>송신 측의 윈도우 크기는 맨 처음 TCP의 연결을 생성하는 과정인 3 Way Handshake 때 결정된다. 이때 송신 측과 수신 측은 자신의 현재 버퍼 크기를 서로에게 알려주게 되고, 송신 측은 수신 측이 보내준 버퍼 크기를 사용하여 <code>음, 대충 이 정도 처리 가능하겠군</code>이라는 과정을 통해 자신의 윈도우 크기를 정하게 된다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localhost.initiator > localhost.receiver: Flags [S], seq 1487079775, win 65535</span><br><span class="line">localhost.receiver > localhost.initiator: Flags [S.], seq 3886578796, ack 1487079776, win 65535</span><br><span class="line">localhost.initiator > localhost.receiver: Flags [.], ack 1, win 6379</span><br></pre></td></tr></tbody></table></figure><p><code>tcpdump</code>를 통해 3 Way Handshake를 관찰해보면 처음의 <code>SYN</code>과 <code>SYN+ACK</code> 패킷에는 각자 자신의 버퍼를 알려준 후 마지막 <code>ACK</code> 패킷 때 송신 측이 자신이 정한 윈도우 사이즈를 상대방에게 통보하는 것을 볼 수 있다.</p><p>이때 송신 측과 수신 측 모두 자신의 버퍼 크기라 <code>65535</code>라고 이야기했지만 최종적으로 송신 측이 정한 자신의 윈도우 크기는 <code>6379</code>이다. 왜 송신 측은 수신 측 버퍼 크기의 10분의 1로 자신의 윈도우 크기를 정한 것일까?</p><p>사실 송신 측의 윈도우 크기는 수신 측의 버퍼 크기로만 정하는 것이 아니라 다른 여러가지 요인들을 함께 고려해서 결정된다. 상대방이 보낸 버퍼 크기만 믿고 자신의 윈도우 크기를 정하기에는 네트워크는 너무나도 험난한 환경이기 때문이다. 이때 사용하는 대표적인 값이 바로 패킷의 왕복 시간을 의미하는 <code>RTT(Round Trip Time)</code>이다.</p><p>송신 측은 자신이 처음 <code>SYN</code> 패킷을 보내고, 다시 수신 측이 <code>SYN+ACK</code> 패킷으로 응답하는 시간을 재고, 이 값을 통해 현재 네트워크 상황을 유추한다. 이때 이 값이 너무 크다면 왕복 시간이 느리다는 것이므로 네트워크 상태가 좋지 않다고 생각하고 윈도우 크기를 조금 더 줄이게 되는 것이다.</p><p>그리고 이때 정해진 윈도우 크기는 고정이 아니라 통신을 하는 과정 중간에도 계속 네트워크의 혼잡 환경과 수신 측이 보내주는 윈도우 크기를 통해 동적으로 변경될 수 있다. 윈도우의 크기, 즉 연속적으로 보낼 데이터의 양을 변경해가면서 유연하게 흐름 제어를 할 수 있다는 말이다.</p><p>윈도우에 대해 대략적으로 이해를 했다면 이제 이 기법을 왜 <code>슬라이딩 윈도우</code>라고 하는 지 한번 살펴보도록 하자.</p><p>먼저, 송신 측이 <code>0 ~ 6</code>번의 시퀀스 번호를 가진 데이터를 상대방에게 전송하고 싶어하는 상황을 상상해보자. 이때 송신 측의 버퍼에는 전송해야할 데이터들이 이렇게 담겨져 있을 것이다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/sw-0.png" width="500"><br>  <br><br></center><p>이때 송신 측은 수신 측에게 받은 윈도우 크기와 현재 네트워크 상황을 고려하여 윈도우 크기를 3으로 잡았고, 윈도우 안에 있는 데이터를 우선 주르륵 전송한다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/sw-1.png" width="500"><br>  <br><br></center><p>이때 윈도우 안에 들어있는 데이터는 어떤 상태일까? 일단 데이터를 전송하기는 했지만 아직 수신 측으로부터 잘 받았다는 응답을 받지 못한 상태일 것이다.</p><p>즉, 윈도우에 들어있는 데이터들은 항상 <code>전송은 했지만, 상대방이 처리했는지는 모르는 상태</code>라고 할 수 있다. 물론 데이터를 윈도우에 넣고 나서 블록킹이 걸려 데이터를 처리하지 못하는 상태도 존재할 수 있지만, 그런 것까지 다 고려하면 너무 복잡하니까 간단하게 생각하도록 하자.</p><p>이후 수신 측은 자신의 처리 속도에 맞게 데이터를 처리한 후 응답으로 현재 자신의 버퍼에 남아있는 공간의 크기를 알려준다. 만약 수신 측이 응답으로 <code>Window Size: 1</code>을 보냈다면 “내 버퍼 공간이 1 byte만큼 남았으니까 그 만큼만 더 보내봐”라는 의미가 된다.</p><p>이제 송신 측은 자신이 데이터 한 개를 더 보낼 수 있다는 사실을 알았으니, 자신의 윈도우를 한 칸 옆으로 밀고 새롭게 윈도우에 들어온 3번 데이터를 수신 측에게 전송한다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/sw-2.png" width="500"><br>  <br><br></center><p>이때 윈도우를 옆으로 이동시키며 새로 들어온 데이터를 전송하기 때문에 <code>슬라이딩 윈도우</code>라고 하는 것이다. 만약 수신 측이 윈도우 크기를 1이 아니라 더 큰 수를 보냈다면, 송신 측은 그 만큼 윈도우를 옆으로 밀고 더 많은 데이터를 연속적으로 전송할 수 있을 것이다.</p><p>단, 이 경우 송신 측의 윈도우 크기가 3이기 때문에 수신 측이 4를 보냈다고 해서 4칸을 밀지는 않고, 자신의 윈도우 크기인 3만큼만 밀 수 있다. 그러나 이 경우에는 송신 측이 수신 측의 퍼포먼스가 더 좋아졌다는 것을 알았으니 자신의 윈도우 크기를 늘리는 방법으로 대처할 수 있을 것이다.</p><p>이렇게 데이터를 전송하는 송신 측의 버퍼는 대략 3가지 상태로 나눠질 수 있다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/sw-3.png" width="500"><br>  <br><br></center><p>즉 슬라이딩 윈도우 방식은 <code>보내고 -> 응답받고 -> 윈도우 밀고</code>를 반복하면서, 현재 자신이 보낼 수 있는 데이터를 최대한 연속적으로 보내는 방법이라고 할 수 있다.</p><p>이게 지금 <code>0 ~ 6</code> 밖에 안되는 단순화된 그림으로 봐서 잘 와닿지 않을 수도 있지만, 아무런 옵션도 적용하지 않은 TCP의 최대 윈도우 크기는 <code>65,535 bytes</code>이고, WSCALE 옵션을 최대로 적용하면 <code>1GB</code>로 설정하는 것도 가능하다.</p><p>게다가 연속적으로 한번에 보내는 데이터도 이렇게 한 개, 두 개 정도가 아니라 몇 백 바이트 단위로 보내는 경우가 많기 때문에 실제 환경에서는 Stop and Wait로 흐름 제어를 하는 것과 비교해봤을때 상당히 좋은 효율을 뽑아낼 수 있다. 즉, 이론적으로는 수신 측의 ACK 응답 없이도 최대 1GB를 연속적으로 전송할 수 있다는 말이다.</p><p>이렇게 슬라이딩 윈도우 방식은 일일히 하나 보내고, 응답 받고 하는 Stop and Wait보다 확실히 전송 속도 측면에서 빠르기도 하고, 송신 측과 수신 측의 지속적인 커뮤니케이션을 통해 윈도우 크기 또한 유연하게 조절할 수 있기 때문에 최근의 TCP에서는 기본적으로 슬라이딩 윈도우를 사용하여 흐름 제어를 하고 있다.</p><h2 id="TCP의-오류-제어"><a href="#TCP의-오류-제어" class="headerlink" title="TCP의 오류 제어"></a>TCP의 오류 제어</h2><p>TCP는 기본적으로 <code>ARQ(Automatic Repeat Request)</code>, 재전송 기반 오류 제어를 사용한다. 말 그대로 통신 중에 뭔가 오류가 발생하면 송신 측이 수신 측에게 해당 데이터를 다시 전송해야한다는 말이다.</p><p>하지만 이 <code>재전송</code>이라는 작업 자체가 했던 일을 또 해야하는 비효율적인 작업이기 때문에, 이 재전송 과정을 최대한 줄일 수 있는 여러가지 방법을 사용하게 된다.</p><h3 id="오류가-발생했다는-것은-어떻게-알-수-있나요"><a href="#오류가-발생했다는-것은-어떻게-알-수-있나요" class="headerlink" title="오류가 발생했다는 것은 어떻게 알 수 있나요?"></a>오류가 발생했다는 것은 어떻게 알 수 있나요?</h3><p>TCP를 사용하는 송수신 측이 오류를 파악하는 방법은 크게 두 가지로 나누어진다.</p><p>수신 측이 송신 측에게 명시적으로 <code>NACK(부정응답)</code>을 보내는 방법, 그리고 송신 측에게 <code>ACK(긍정응답)</code>가 오지 않거나, 중복된 ACK가 계속 해서 오면 오류가 발생했다고 추정하는 방법이다.</p><p>간단히 생각해보면 왠지 NACK를 사용하는 방법이 더 명확하고 간단할 것 같지만, NACK를 사용하게되면 수신 측이 상대방에게 ACK를 보낼 지 NACK를 보낼 지 선택해야하는 로직이 추가적으로 필요하기 때문에, 일반적으로는 ACK만을 사용해서 오류를 추정하는 방법이 주로 사용되고 있다.</p><p>이때 타임아웃은 말 그대로 송신 측이 보낸 데이터가 중간에 유실되어, 수신 측이 아예 데이터를 받지 못해 ACK를 보내지도 않았거나, 수신 측은 제대로 응답했지만 해당 ACK 패킷이 유실되는 경우에 발생하게 된다.</p><p>어쨌든 두 경우 모두 송신 측은 데이터를 전송했는데 수신 측이 응답하지 않고 일정 시간이 경과한 경우라고 생각하면된다.</p><p>그리고 두 번째 방법인 송신 측이 중복된 ACK를 받는 경우 오류라고 판별하는 방법은 대략 이런 느낌이다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/duplicated-ack.png" width="500"><br>  <br><br></center><p>이 상황을 조금 더 쉽게 풀어보자면, 송신 측은 이미 <code>SEQ 2</code> 데이터를 보낸 상황인데 수신 측이 계속 <code>야, 이번에 2번 보내줄 차례야</code>라고 말하는 상황인 것이다. 그럼 송신 측은 자신이 보낸 2번 데이터에 뭔가 문제가 발생했음을 알 수 있다.</p><p>단, 패킷 기반 전송을 하는 TCP의 특성 상 각 패킷의 도착 순서가 무조건 보장되는 것이 아니기 때문에 위 예시처럼 중복된 ACK를 한 두번 받았다고 해서 바로 에러라고 판별하지는 않고, 보통 3회 정도 받았을 때 에러라고 판별하게 된다.</p><h3 id="Stop-and-Wait-1"><a href="#Stop-and-Wait-1" class="headerlink" title="Stop and Wait"></a>Stop and Wait</h3><p><code>Stop and Wait</code>는 흐름 제어 때 한번 살펴보았던, 한번 데이터를 보내면 <code>제대로 받았다</code>라는 응답이 올 때까지 대기하고 있다가 다음 데이터를 보내는 방식이다.</p><p>이 친구가 오류 제어에서 다시 나오는 이유는 그냥 이렇게만 해도 기본적인 오류 제어가 가능하기 때문이다. 일석이조랄까. 애초에 제대로 받았다는 응답이 오지 않는다면 제대로 받을 때까지 계속 데이터를 재전송하는 방법이니까 흐름 제어도 되지만 오류 제어도 가능하다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/stop-and-wait-error.png" width="300"><br>  <br><br></center><p>그러나 위에서 살펴본 <code>슬라이딩 윈도우</code>를 사용하여 흐름 제어를 하는 경우에는 윈도우 안에 있는 데이터를 <code>연속적</code>으로 보내야 하기 때문에, 오류 제어에 Stop and Wait를 사용해버리면 슬라이딩 윈도우를 쓰는 이점을 잃어버린다.</p><p>그런 이유로 일반적으로는 이런 단순한 방법보다 조금 더 효율적이고 똑똑한 ARQ를 사용하게 된다.</p><h3 id="Go-Back-N"><a href="#Go-Back-N" class="headerlink" title="Go Back N"></a>Go Back N</h3><p><code>Go Bank N</code> 방법은 데이터를 연속적으로 보내다가 그 중 <code>어느 데이터부터 오류가 발생했는지</code>를 검사하는 방식이다.</p><p>위에서 이야기했듯이 오류를 판별하는 방법에는 ACK의 이상 징후를 파악하는 방법을 더 많이 사용하기는 하지만, NACK를 사용하고 있다고 가정하는 것이 다이어그램을 이해하기가 편하므로 오류 제어 기법을 설명할 때는 수신 측이 NACK를 사용하고 있다고 가정할 것이다.</p><p>이 섹션에서는 오류 제어 기법을 설명하는 것이 목적이니, 오류를 어떻게 판별하는지보다는 오류를 어떻게 제어하는지에 대해서만 집중해보도록 하자.</p><p>Go Back N 방식을 사용하면 데이터를 연속적으로 보낸 후 한 개의 ACK나 NACK만을 사용하여 수신 측의 처리 상황을 파악할 수 있으므로, 연속적으로 데이터를 보낼 수 있는 흐름 제어 방식인 슬라이딩 윈도우와 아주 잘 들어맞는다고 할 수 있다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/go-back-n.png" width="300"><br>  <br><br></center><p>위 그림을 보면 수신 측이 4번 데이터부터 에러가 발생함을 감지하고 송신 측에게 <code>4번부터 다시 보내줘</code>라고 하고 있다.</p><p>Go back N 방식에서 수신 측이 4번 데이터에서 에러가 발생했음을 감지하면, 4번 데이터 이후 자신이 받았던 모든 데이터를 폐기하고 송신 측에게 NACK를 보내게 된다. </p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/go-back-n-example.png" width="500"><br>  <small>에러가 발생하면 그 뒤에 있던 멀쩡한 데이터도 같이 날려버리는 쏘쿨한 방식이다</small><br>  <br><br></center><p>즉, 송신 측은 수신 측으로 NACK를 받고나면 오류가 발생한 4번 데이터와 그 이후 전송했던 모든 데이터를 다시 전송해줘야 한다는 말이 된다. 이때 송신 측은 비록 5번까지 전송했지만 오류가 발생하면, 오류가 발생한 4번 데이터로 되돌아가서 다시 전송해야하므로 <code>Go Back N</code>이라고 부르는 것이다.</p><h3 id="Selective-Repeat"><a href="#Selective-Repeat" class="headerlink" title="Selective Repeat"></a>Selective Repeat</h3><p><code>Selective Repeat</code>은 말 그대로 <code>선택적인 재전송</code>을 의미한다. Go Back N 방법도 Stop and Wait에 비하면 많이 효율적인 방법이지만, 에러가 발생하면 그 이후에 정상적으로 전송되었던 데이터까지 모두 폐기 처분되어 다시 전송해야한다는 비효율이 아직 존재한다.</p><p>그래서 나온 방식이 <code>에러난 데이터만 재전송해줘</code> 방식인 것이다.</p><center><br>  <img src="/2019/11/22/tcp-flow-control-error-control/selective-repeat.png" width="300"><br>  <br><br></center><p>얼핏 보면 이 방식이 굉장히 효율적이고 좋기만 한 것 같지만 Stop and Wait와 Go Back N 방식과 다르게, 이 방식을 사용하는 수신 측의 버퍼에 쌓인 데이터가 연속적이지 않다는 단점이 존재한다.</p><p>위 예시만 봐도 수신 측의 버퍼에는 <code>0, 1, 2, 3, 4, 5</code>가 순차적으로 들어있는 것이 아니라, 중간에 폐기 처분된 4를 제외한 <code>0, 1, 2, 3, 5</code>만 버퍼에 존재할 것이기 때문이다. 이때 송신 측이 4를 재전송하게되면 수신 측은 이 데이터를 버퍼 중간 어딘가에 끼워넣어서 데이터를 정렬해야한다.</p><p>이때 같은 버퍼 안에서 데이터를 정렬할 수는 없으니, 별도의 버퍼가 필요하게 된다.</p><p>결국 재전송이라는 과정이 빠진 대신 재정렬이라는 과정이 추가된 것인데, 이 둘 중에 재전송이 좀 더 이득인 상황에서는 Go Bank N 방식을, 재정렬이 좀 더 이득인 상황에서는 Selective Repeat 방식을 사용하면된다.</p><p>만약 TCP 통신에서 Selective Repeat 방식을 사용하고 싶다면, TCP의 옵션 중 <code>SACK</code> 옵션을 1로 설정하면 된다…만 사실 기본적으로 켜져 있는 경우가 많다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.inet.tcp | grep sack:</span><br><span class="line">net.inet.tcp.sack: 1</span><br></pre></td></tr></tbody></table></figure><p>OSX 같은 경우, <code>sysctl</code> 명령어를 사용하여 TCP와 관련된 커널 변수들을 확인해보면 그 중 <code>net.inet.tcp.sack</code> 값이 1로 잡혀있는 것을 확인할 수 있다.</p><p>아무래도 대부분의 경우에는 정글이나 다름 없는 네트워크를 다시 사용하는 쪽보다는 그냥 수신 측이 재정렬을 하는 것이 이득인 경우가 많다보니 기본적으로 Selective Repeat을 사용하는 것이 아닌가싶다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>필자가 최근에 TCP에 대해 공부하면서 가장 어려운 점은, TCP라는 주제 안에 굉장히 다양한 개념들이 서로 얶혀있다는 점이다.</p><p>아무래도 개발된 지 50년이 다 되어가는 할배 프로토콜이다보니 초반에 개발된 버전에 비해서 개선사항도 굉장히 많고 옵션 또한 다양하다. 그래서 TCP의 어떤 동작 하나를 파헤쳐보려고해도 무슨 줄줄이 소세지처럼 이것저것 전부 엮여나온다.</p><p>예를 들어 슬라이딩 윈도우 기법을 설명할 때 나왔던 <code>윈도우 크기</code>의 경우, 단순히 수신 측이 보내준 윈도우 크기를 사용하는 것이 아니라 RTT, MTU, MSS 등 네트워크의 상황과 관련된 다양한 변수를 종합적으로 고려하여 결정된다. 정확히 말하면 수신 측이 보내준 윈도우 크기와 송신 측이 네트워크 혼잡도를 고려해서 정한 윈도우 크기 중 더 작은 값이 송신 측의 최종 윈도우 크기가 되는 식이다.</p><p>또한 오류 제어 섹션에서 이야기했던 오류 판별 기법은 사실 혼잡 제어에서도 중요한 부분으로 설명되며, 이후 방금 말한 로직을 통해 송신 윈도우 크기를 재설정하고 송수신 측이 합의본 오류 제어 기법을 사용하여 패킷을 재전송하는 과정으로 진행된다.</p><p>결국 이 포스팅에서는 다루지 않았지만 흐름 제어라는 주제 안에 혼잡 제어와 관련된 내용도 섞여있는 것이다.</p><p>개인적으로 흐름, 혼잡, 오류와 같이 주제를 나눠놓아서 오히려 더 헷갈리는 것도 있는 것 같다. 그래서 이런 구분없이 따로 정리해서 포스팅을 작성하려고도 했었지만, 아무래도 이런 구분이 모두에게 익숙한 상황이니 그냥 필자도 거기에 편승하기로 했다.</p><p>사실 이런 점 때문에 혼잡 제어도 함께 포스팅에 작성하려고 했지만 포스팅 라인 수가 500줄이 넘어가는 것을 보고 그냥 분리했다. 글이 너무 길어지면 읽는 사람도 힘들다.</p><p>다음 포스팅에서는 마지막으로 TCP의 혼잡제어에 대한 이야기를 한 번 해보려고 한다.</p><p>이상으로 패킷의 흐름과 오류를 제어하는 TCP 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TCP가 연결을 생성하고 종료하는 방법, 핸드쉐이크</title>
      <link>https://evan-moon.github.io/2019/11/17/tcp-handshake/</link>
      <guid>https://evan-moon.github.io/2019/11/17/tcp-handshake/</guid>
      <pubDate>Sun, 17 Nov 2019 10:56:06 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;저번에 작성했던 &lt;a href=&quot;/2019/11/10/header-of-tcp/&quot; title=&quot;TCP의 헤더에는 어떤 정보들이 담겨있는걸까?&quot;&gt;TCP의 헤더에는 어떤 정보들이 담겨있는걸까?&lt;/a&gt; 포스팅에 이어 이번에는 TCP의 핸드쉐이크 과정과 그 속에서 변화하는 TCP 상태에 대해서 한번 알아보려고 한다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>저번에 작성했던 <a href="/2019/11/10/header-of-tcp/" title="TCP의 헤더에는 어떤 정보들이 담겨있는걸까?">TCP의 헤더에는 어떤 정보들이 담겨있는걸까?</a> 포스팅에 이어 이번에는 TCP의 핸드쉐이크 과정과 그 속에서 변화하는 TCP 상태에 대해서 한번 알아보려고 한다.</p><a id="more"></a><p>TCP는 신뢰성있는 연결을 추구하기 때문에 연결을 생성하고 종료하는 순간에도 나름의 신뢰성 확보를 위해 <code>핸드쉐이크(Handshake)</code>라고 하는 특별한 과정을 거치게 된다. TCP를 사용하여 통신을 하는 각 종단은 핸드쉐이크 과정을 통해 어떤 TCP 옵션들을 사용할 지, 패킷의 순서 번호 동기화와 같이 통신에 필요한 몇 가지 정보를 주고 받는다.</p><p>하지만 말로만 설명하면 재미가 없으니, C를 사용하여 직접 간단한 클라이언트와 서버를 작성해보고 이 친구들이 핸드쉐이크 과정에서 주고 받는 패킷을 몰래 엿본 결과물도 조금씩 첨부하려고 한다.</p><h2 id="연결-지향의-의미에-대해서"><a href="#연결-지향의-의미에-대해서" class="headerlink" title="연결 지향의 의미에 대해서"></a>연결 지향의 의미에 대해서</h2><p>핸드쉐이크를 이야기하기에 앞서, TCP가 생성하고 종료하는 <code>연결</code>에 대한 이야기를 먼저 하려고 한다. 아마 TCP에 대해서 공부해보신 분들은 TCP의 대표적인 특징 중 하나인 <code>연결 지향(Connection Oriented)</code>이라는 키워드에 대해서 들어보았을 것이다.</p><p>연결 지향은 말 그대로 연결되어 있는 상태를 지향한다는 의미이다. 사실 <code>연결</code>과 <code>비연결</code>은 네트워크를 공부하다보면 여러 번 마주치게 되는 단어인데, 필자는 개인적으로 이 단어들의 의미가 조금 헷갈렸었다.</p><p>상식적으로 두 기기가 통신을 하려면 케이블이든 뭐든 연결이 되어있어야 할텐데, 굳이 왜 <code>연결 지향</code>과 <code>비연결 지향</code>을 나누어 놓은 것인지 이해가 되지 않았기 때문이다.</p><p>이게 헷갈리는 이유는 <code>물리적인 연결</code>과 <code>논리적인 연결</code>의 차이 때문이다.</p><p>우리가 일반적으로 기기와 다른 기기를 연결했다고 할 때 떠올리는 생각은 컴퓨터와 모니터를 연결하거나, USB와 컴퓨터를 연결하는 등의 상황이다. 즉, 기기 간의 물리적인 연결이다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/physical-connection.png" width="500"><br>  <small>케이블을 사용하여 두 개의 장치를 물리적으로 연결한다</small><br>  <br><br></center><p>반면, 연결 지향이라는 단어에서 사용하고 있는 연결의 의미는 <code>논리적인 연결(Logical Connection)</code>을 의미한다. 이때 당연히 여러 개의 기기가 서로 통신을 하기위해서는 물리적인 연결 또한 동반되어야한다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/logical-connection.png" width="500"><br>  <br><br></center><p>조금 더 쉽게 이야기해보자면, 두 기기가 서로 연결되어 있는 상태를 유지하는 것이다.</p><p>전화를 예로 들자면, 전화가 전화선에 연결되어있는 것이 물리적인 연결이고 실제로 다른 전화와 통화를 하고 있는 상황이 논리적인 연결, 즉 <code>연결되어 있는 상태</code>인 것이다.</p><p>그렇다면 왜 TCP는 이런 연결 상태를 유지하는 걸까? 그 이유는 간단하다. 바로 <code>연속적인 데이터 전송의 신뢰성</code>을 위해서이다.</p><p>기본적으로 TCP는 패킷 전송 방식을 사용하기 때문에 보내려고 하는 데이터를 여러 개의 패킷으로 쪼개서 보낸다. 이때 네트워크를 통해 모든 데이터를 한번에 팍! 보내는 것이 아니라 일정 단위로 묶어서 스트림처럼 상대방에게 흘려보내게 된다.</p><p>그럼 한번 데이터를 받는 수신자 입장에서 생각해보자. 패킷 전송 방식의 장점 중 하나는 회선을 점유하지 않고 적은 양의 회선으로도 동시에 통신을 할 수 있다는 점이다.</p><p>그렇다는 것은 각 종단이 동시다발적으로 여러 기기들과 패킷을 주고 받고 있다는 의미인데, 이때 <code>누가 보낸 몇 번째 패킷</code>이라는 정보가 없다면 수신 측은 굉장히 혼란스러울 것이다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/pipes.png" width="500"><br>  <small>연결 상태가 없는 패킷을 구분한다는 것은 한 양동이에 담긴 물을 구분하고 싶다는 말과 같다</small><br>  <br><br></center><p>위 그림에서 파이프는 물리적인 연결, 각 파이프 끝의 구멍은 포트, 양동이는 패킷을 처리할 프로세스라고 생각해보자. 이때 연결 상태에 대한 구분을 하지 않고 패킷을 구분하고 싶다는 것은 마치 한 양동이에 담긴 물 중에서 어떤 한 파이프 구멍에서 나온 물을 구분해내고 싶다는 말과 비슷하다.</p><p>그렇기 때문에 TCP는 <code>A와 B의 연결 상태</code>, <code>A와 C의 연결 상태</code> 등 각 기기간의 연결 상태를 따로 구분하고 있는 것이다. 이때 TCP는 상대방과 연결 상태를 만들거나 해제하기 위해 특별한 과정을 거치는데, 이 과정을 <code>핸드쉐이크(Handshake)</code>라고 한다.</p><h2 id="3-Way-Handshake"><a href="#3-Way-Handshake" class="headerlink" title="3 Way Handshake"></a>3 Way Handshake</h2><p>먼저, 연결을 만드는 과정부터 살펴보도록 하자. 연결을 생성할 때 거치는 핸드쉐이크 과정을 <code>3 Way Handshake</code>라고 하는데, 3 Way라는 말 그대로 총 3번의 통신 과정을 거친다.</p><p>이 과정을 거치면서 통신을 하는 양 종단은 내가 누구랑 통신하고 있는지, 내가 받아야할 데이터의 시퀀스 번호가 몇 번인지와 같은 정보를 주고 받으면서 연결 상태를 생성하게 된다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/3way-handshake.png" width="400"><br>  <br><br></center><p>이때 <code>요청자(Initiator)</code>는 연결 생성 요청을 먼저 보낸 쪽, <code>수신자(Receiver)</code>는 연결 생성 요청을 받은 쪽을 의미한다. 이렇게 표현하는 이유는 일반적으로 우리가 생각하는 클라이언트와 서버, 둘 중에 어느 쪽이든 자유롭게 먼저 연결 생성 요청을 보낼 수 있기 때문이다.</p><p>그럼 한 번 각각의 상태가 어떤 것을 의미하는지, 두 기기가 서로 주고 받고 있는 <code>SYN</code>과 <code>ACK</code>는 무엇을 의미하는지 살펴보도록 하자.</p><h3 id="CLOSED"><a href="#CLOSED" class="headerlink" title="CLOSED"></a>CLOSED</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-closed.png" width="400"><br>  <br><br></center><p>아직 연결 요청을 시작하지 않았기 때문에 아무런 연결도 없는 상태이다.</p><h3 id="LISTEN"><a href="#LISTEN" class="headerlink" title="LISTEN"></a>LISTEN</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-listen.png" width="400"><br>  <br><br></center><p>수신자가 요청자의 연결 요청을 기다리고 있는 상태이다.</p><p>이후 요청자가 연결 요청을 보내기 전까지 수신자는 계속 이 상태로 대기하게 된다. 즉, 적극적으로 상대방에게 대시하지 않는다는 것인데, 그래서 이 상태를 <code>수동 개방(Passive Open)</code>이라 하고, 수신자를 <code>Passive Opener</code>라고도 한다.</p><p>소켓 프로그래밍을 할 때, 소켓 바인딩을 한 후 <code>listen</code> 함수를 호출하게 되면 수신자가 LISTEN 상태로 들어가게 된다.</p><figure class="highlight c hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> ((listen(sockfd, <span class="hljs-number">5</span>)) != <span class="hljs-number">0</span>) {</span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Listen failed...\n"</span>);</span><br><span class="line">  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">else</span> {</span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Server listening..\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>이후 수신자는 요청자의 연결 요청이 확인되면 <code>accept</code> 함수를 호출하여 다음 단계로 넘어가게 된다.</p><h3 id="SYN-SENT"><a href="#SYN-SENT" class="headerlink" title="SYN_SENT"></a>SYN_SENT</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-synsent.png" width="400"><br>  <br><br></center><p>요청자가 수신자에게 연결 요청을 하면서 랜덤한 숫자인 <code>시퀀스 번호</code>를 생성해서 SYN 패킷에 담아 보낸 상태이다. 이제 요청자와 수신자는 이 시퀀스 번호를 사용하여 계속 새로운 값을 만들고 서로 확인하며 연결 상태와 패킷의 순서를 확인하게 된다.</p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.initiator > localhost.receiver: Flags [S], seq 3414207244, win 65535</span><br></pre></td></tr></tbody></table></figure><p>TCP 세그먼트를 캡쳐할 수 있는 <code>tcpdump</code> 유틸리티로 이 과정을 확인해보면 요청자가 패킷의 플래그를 SYN 패킷을 의미하는 <code>S</code>로 설정하고 시퀀스 번호로 <code>3414207244</code>라는 값을 생성해서 수신자에게 보내고 있음을 알 수 있다.</p><p>이 경우는 요청자가 수신자에게 연결을 생성하자고 적극적으로 대시하는 상황이므로 이 상태를 <code>능동 개방(Active Open)</code>이라고 하고, 요청자를 <code>Active Opener</code>라고도 한다.</p><h3 id="SYN-RECV"><a href="#SYN-RECV" class="headerlink" title="SYN_RECV"></a>SYN_RECV</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-synrecv.png" width="400"><br>  <br><br></center><p><code>SYN_RECV</code>는 요청자가 보낸 SYN 패킷을 수신자가 제대로 받은 상태를 의미한다.</p><p>이후 수신자는 제대로 된 시퀀스 번호를 받았다는 확인의 의미인 <code>승인 번호(Acknowledgement)</code> 값을 만들어서 다시 요청자에게 돌려줘야한다. 이때 승인 번호는 처음 <code>요청자가 보낸 시퀀스 번호 + 1</code>이 된다.</p><p>이 승인 번호 만드는 과정은 어렵게 생각할 필요가 없는게, 저번 포스팅에서 이야기했듯이 TCP를 사용하여 실제로 데이터를 주고 받을 때에는 <code>상대방이 보낸 시퀀스 번호 + 상대방이 보낸 데이터의 byte</code>를 합쳐서 승인 번호를 만들어낸다. 즉, 내가 여기까지 받았으니, 다음에는 여기부터 보내달라는 일종의 마킹인 것이다.</p><p>그러나 이런 핸드쉐이크 과정에서는 아직 데이터를 주고 받지 않기 때문에 시퀀스 번호에 더할게 없다. 그렇다고해서 시퀀스 번호를 같은 번호로 주고 받자니 패킷의 순서를 구분할 수 없지 않은가? 그래서 그냥 1을 더하는 것이다.</p><p>방금 전과 마찬가지로 tcpdump 유틸리티를 사용하여 이 과정을 확인해볼 수 있다.</p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.receiver > localhost.initiator: Flags [S.], seq 435597555, ack 3414207245, win 65535</span><br></pre></td></tr></tbody></table></figure><p>수신자가 요청자에게 보내는 패킷을 캡처해보았더니 패킷의 플래그가 <code>S.</code>로 설정되어있다. 이때 <code>.</code>가 의미하는 것은 헤더의 <code>ACK</code> 플래그 필드가 1이라는 것이므로 이 패킷에는 유효한 승인 번호가 담겨있음을 알 수 있다.</p><p>수신자는 이번 통신을 통해 요청자에게 <code>3414207245</code> 이라는 승인 번호를 전달하고 있는데, 이 값은 방금 전 요청자가 보냈던 시퀀스 번호인 <code>3414207244</code>에 1을 더한 값이다.</p><p>또한 랜덤한 수로 자신의 시퀀스 번호인 <code>435597555</code>를 다시 생성하여 함께 요청자에게 보내주고 있는 것을 확인할 수 있다.</p><h3 id="ESTABLISHED-요청자"><a href="#ESTABLISHED-요청자" class="headerlink" title="ESTABLISHED(요청자)"></a>ESTABLISHED(요청자)</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-established-client.png" width="400"><br>  <br><br></center><p>요청자는 자신이 맨 처음에 보냈던 시퀀스 번호와 수신자가 응답으로 보내준 승인 번호, 즉 <code>내 시퀀스 번호 + 1</code>를 사용하여 연결이 제대로 성립되었는지 확인할 수 있다. 자신이 보냈던 시퀀스 번호와 이번에 받은 승인 번호의 차가 1이라면 제대로 연결이 되었다고 판단하는 것이다.</p><p>이후 요청자는 연결이 성립되었다고 판단하고 <code>ESTABLISHED</code> 상태로 들어가면서, 이번에는 수신자가 새롭게 만들어서 보내줬던 시퀀스 번호에 1을 더한 값을 다시 승인 번호로 사용하여 다시 수신자에게 보내준다.</p><p>즉, 마지막으로 수신자가 보내줬던 시퀀스 번호인 <code>435597555</code>에 1을 더한 값인 <code>435597556</code>이 요청자의 승인 번호가 될 것이다…만 tcpdump의 동작은 필자의 예상과 달랐다.</p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.initiator > localhost.receiver: Flags [.], ack 1, win 6379</span><br></pre></td></tr></tbody></table></figure><center><br>  <img src="/2019/11/17/tcp-handshake/why.jpg" width="500"><br>  <small>왜 1이 거기서 나와…?</small><br>  <br><br></center><p>원래대로라면 <code>435597556</code>이 되어야할 요청자의 마지막 승인 번호가 뜬금없이 <code>1</code>이 되었다. <small>(처음엔 진심 당황했다)</small></p><p>사실 이건 TCP의 자체 동작은 아니고 tcpdump가 제공하는 기능이다. tcpdump가 패킷들의 시퀀스 번호를 알아보기 쉽게끔 <code>상대적인 위치</code>로 알려주기 때문이다. 이후 이 두 종단이 주고 받는 데이터를 tcpdump로 캡처해보면 이게 무슨 말인지 조금 더 쉽게 알 수 있다.</p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.initiator > localhost.receiver: Flags [P.], seq 1:81, ack 1, win 6379, length 80: HTTP</span><br></pre></td></tr></tbody></table></figure><p>원래대로라면 요청자가 마지막으로 보내는 승인 번호는 <code>435597556</code>이 될 것이기 때문에 첫 번째로 전송하는 데이터의 시퀀스 번호의 범위 또한 <code>435597556:435597637</code>로 출력되어야한다.</p><p>그러나 인간이 이렇게 큰 숫자를 계속 보면서 분석하기는 쉽지 않기 때문에 승인 번호를 <code>1</code>로 보여주고, 이후 주고받는 첫 번째 시퀀스 번호를 1부터 시작해서 알아보기 쉽게 만들어주는 것이다. 확실히 <code>435597556:435597637</code>보다는 <code>1:81</code>이 알아보기 쉽다.</p><p>하지만 이건 인간이 알아보기 쉽게 tcpdump가 친절함을 베푼 것일뿐 실제로 값이 1로 변경된 것은 아니기 때문에 tcpdump의 <code>-S</code> 옵션을 사용하여 이 기능을 비활성화하면 원래 승인 번호와 시퀀스 번호를 그대로 출력할 수도 있다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tcpdump -S</span><br><span class="line">localhost.initiator > localhost.receiver: Flags [.], ack 435597556, win 6379</span><br></pre></td></tr></tbody></table></figure><h3 id="ESTABLISHED-수신자"><a href="#ESTABLISHED-수신자" class="headerlink" title="ESTABLISHED(수신자)"></a>ESTABLISHED(수신자)</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-established-server.png" width="400"><br>  <br><br></center><p>요청자와 마찬가지로 수신자 또한 자신이 보냈던 시퀀스 번호와 이번에 받은 승인 번호의 차가 1이라면 제대로 연결이 되었다고 판단하고 <code>ESTABLISHED</code> 상태로 들어가게된다. 여기까지 오면 요청자와 수신자는 안전하고 신뢰성있는 연결이 생성되었다고 판단하고 본격적인 통신을 시작할 수 있다.</p><h2 id="4-Way-Handshake"><a href="#4-Way-Handshake" class="headerlink" title="4 Way Handshake"></a>4 Way Handshake</h2><p>연결을 생성할 때와 마찬가지로, 연결을 종료할 때도 특정한 과정을 거쳐서 연결을 종료해야한다.</p><p>그냥 연결을 끊어버리면 안되냐고 할 수도 있지만, 한 쪽에서 일방적으로 연결을 끊어버리면 다른 한 쪽은 연결이 끊어졌는지 지속되고 있는지 알 방법이 없다.</p><p>또한 연결을 종료하기 전에 아직 다 처리하지 못한 데이터가 있을 수도 있기 때문에 양 쪽이 다 정상적으로 연결을 종료할 준비가 되었는 지를 확인하는 과정이 필요한 것이다.</p><p>이때 요청자와 수신자가 총 4번의 통신 과정을 거치기 때문에, 이 과정을 <code>4 Way Handshake</code>라고 부른다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/4way-handshake.png" width="400"><br>  <br><br></center><p>이번에도 <code>요청자(Initiator)</code>와 <code>수신자(Receiver)</code>라는 용어를 사용하고 있는데, 3 Way Handshake와 마찬가지로 클라이언트와 서버, 둘 중에 어느 쪽이든 연결 종료 요청을 시작할 수 있기 때문에 이런 용어를 사용하는 것이다.</p><p>먼저 연결 생성 요청을 했던 쪽이 먼저 연결 종료 요청을 보낼 수도 있고, 반대로 처음에는 연결 생성 요청을 당했던 쪽이 이번에는 먼저 연결 종료 요청을 보낼 수도 있다.</p><p>사실 개발자들은 3 Way Handshake보다 연결을 종료하는 과정인 4 Way Handshake에 더 예민하게 반응할 수 밖에 없는데, 연결을 생성하는 과정에서 문제가 발생하여 연결이 생성되지 않는다면 다시 시도하면 그만이지만, 이미 생성된 연결을 종료하는 과정인 4 Way Handshake에서 문제가 발생하면 그대로 연결이 남아있기 때문이다.</p><p>게다가 4 Way Handshake는 3 Way Handshake처럼 순차적으로 주고받는 방식이 아니라 상대방이 응답을 줄 때까지 대기하는 과정이 포함되어있기 때문에 중간에 뭐 하나 엇나가면 서로 계속 대기만 하고 있는 <code>데드락(Deadlock)</code> 상황이 연출될 수도 있다.</p><p>물론 조건에 따라 일정 시간이 지나면 타임아웃이 되며 연결을 강제로 종료하거나 다음 단계로 넘어갈 수도 있지만 그래도 그 시간 동안 프로세스가 메모리와 포트를 점유하고 있으므로 트래픽이 많은 서버라면 이로 인해 병목이 발생할 가능성은 늘 있다.</p><h3 id="FIN-WAIT-1"><a href="#FIN-WAIT-1" class="headerlink" title="FIN_WAIT_1"></a>FIN_WAIT_1</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-finwait1.png" width="400"><br>  <br><br></center><p>먼저 연결을 종료하고자 하는 요청자가 FIN 패킷을 상대방에게 보내면서 <code>FIN_WAIT1</code> 상태로 들어서게 된다.</p><p>이때 FIN 패킷에도 시퀀스 번호가 포함되어있긴한데, 이번에는 랜덤한 값으로 생성해서 보내는 것이 아니다. 3 Way Handshake는 시퀀스 번호가 없는 상황에서 새로 만들어야하는 상황이라 랜덤한 값으로 초기화했지만, 이번에는 시퀀스 번호를 새롭게 생성할 필요가 없으므로 그냥 자신이 이번에 보내야할 순서에 맞는 시퀀스 번호를 사용하면 되는 것이다.</p><blockquote><ul><li>요청자 —<strong>SEQ: 1</strong>—> 수신자</li><li>요청자 <—<strong>ACK: 2</strong>— 수신자</li><li>요청자 —<strong>FIN: 2</strong>—> 수신자</li></ul></blockquote><p>즉, FIN 플래그만 1로 변경해서 보낸다고 생각하는 게 편하다. 이 플래그의 의미를 쉽게 얘기해보자면 “나 더 이상 할 말 없음” 정도이다.</p><p>이때 요청자가 먼저 적극적으로 연결 종료 요청을 보내는 것이기 때문에 요청자를 <code>Active Closer</code>, 이 상태를 <code>능동 폐쇄(Active Close)</code>라고 한다.</p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.initiator > localhost.receiver: Flags [F.], seq 701384376, ack 4101704148, win 6378</span><br></pre></td></tr></tbody></table></figure><p>하지만 요청자가 수신자에게 보낸 연결 종료 요청 패킷을 캡처해보니 <code>F</code> 플래그가 아니라 <code>FIN+ACK</code>를 의미하는 <code>F.</code> 플래그가 설정되어있다. tcpdump를 사용하여 패킷을 캡처한 다른 블로그를 봐도 대부분 필자와 같은 상황을 겪고 있음을 알 수 있었다.</p><p>분명 이론적으로는 FIN 패킷을 보내야하는데 왜 승인 번호를 함께 묶어서 FIN+ACK로 보내고 있는 것일까?</p><h4 id="Half-Close-기법"><a href="#Half-Close-기법" class="headerlink" title="Half-Close 기법"></a>Half-Close 기법</h4><p>요청자가 FIN+ACK 패킷을 보내는 이유는 바로 <code>Half-Close</code>라는 기법을 사용하고 있기 때문이다. Half-Close 기법은 말 그대로 연결을 종료하려고 할 때 완전히 종료하는 것이 아니라 반만 종료하는 것이다.</p><p><code>Half-Close</code>를 사용하면 요청자가 처음 보내는 FIN 패킷에 승인 번호를 함께 담아서 보내게 되는데, 이때 이 승인 번호의 의미는 “일단 연결은 종료할 건데 귀는 열어둔다. 이 승인 번호까지 처리했으니까 마저 보낼 거 있으면 보내”라는 의미가 된다.</p><p>즉, 반만 닫겠다는 말의 의미는 연결을 종료할 때 전송 스트림과 수신 스트림 중 하나만 우선 닫겠다는 것을 의미하는 것이다.</p><p>이후 수신자는 미처 못 보낸 데이터가 있다면 열심히 보낼 것이고, 이에 요청자는 아직 살아있는 수신 스트림을 사용하여 데이터를 처리한 후 <code>ACK</code> 패킷을 응답으로 보낼 수 있다. 이후 수신자가 모든 데이터를 처리하고나면 다시 요청자에게 FIN 패킷을 보냄으로써 모든 데이터가 처리되었다는 신호를 보내준다.</p><p>그럼 요청자는 그때 나머지 반을 닫으면서 조금 더 안전하게 연결을 종료할 수 있는 것이다.</p><p>소켓 프로그래밍을 할 때 연결 종료 함수로 <code>close()</code>와 <code>shutdown()</code>을 사용할 수 있는데, 이때 <code>shutdown()</code> 함수를 사용하면 Half-Close를 사용할 수 있다.</p><figure class="highlight c hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown(sockfd, SHUT_WR);</span><br></pre></td></tr></tbody></table></figure><p>만약 요청자가  <code>close()</code> 함수를 사용하면 호출 즉시 OS에게 소켓의 리소스를 반환하며 모든 스트림이 파기되므로 FIN 패킷을 받은 수신자가 미처 못 보낸 데이터를 뒤늦게 전송하더라도 더 이상 처리할 수 없는 상황이 된다.</p><p>위의 예제에서는 <code>SHUT_WR</code> 값을 두 번째 인자로 사용함으로써 전송 스트림만 우선 닫겠다고 선언한 것이다.</p><p>이와 관련된 더 자세한 정보는 구글에 <code>Half-Close</code>나 <code>우아한 종료</code> 등의 키워드로 검색하면 많은 자료가 나오니 한번 살펴보도록 하자.</p><h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-closewait.png" width="400"><br>  <br><br></center><p>요청자으로부터 FIN 패킷을 받은 수신자는 <code>요청자가 보낸 시퀀스 번호 + 1</code>로 승인 번호를 만들어서 다시 요청자에게 응답해주면서 <code>CLOSE_WAIT</code> 상태로 들어간다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.receiver > localhost.initiator: Flags [.], ack 701384377, win 6378</span><br></pre></td></tr></tbody></table></figure><p>아까 요청자가 FIN 패킷의 시퀀스 번호로 <code>701384376</code>을 보냈으니 이번에 수신자가 응답해줄 승인 번호는 <code>701384377</code>이 되는 것이다.</p><p>이후 수신자는 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한 후, 모든 전송이 끝났다면 명시적으로 <code>close()</code>나 <code>shutdown()</code>과 같은 함수를 호출하여 다음 단계로 넘어갈 것이다.</p><p>즉, 요청자는 언제 수신자의 데이터 처리가 끝날지 모르는 상태이기 때문에 수신자가 작업을 마치고 다시 연결 종료 승인을 의미하는 FIN 패킷을 보내줄 때까지 대기해야한다는 말이 된다.</p><p>만약 이 단계에서 수신자의 데이터 처리가 끝나도 연결 종료 함수가 명시적으로 호출되지 않으면 다음 상태로 넘어갈 수 없기 때문에 데드락이 발생할 가능성이 있다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/deadlock.png" width="500"><br>  <small>구글의 자동 완성 검색어가 개발자들의 심정을 대변해주고 있다</small><br>  <br><br></center><p>이때 수신자는 상대방으로부터 연결 종료 요청을 받은 후에야 수동적으로 연결을 종료할 준비를 하기 때문에 수신자를 <code>Passive Closer</code>, 이 상태를 <code>수동 폐쇄(Passive Close)</code>라고 한다.</p><h3 id="FIN-WAIT-2"><a href="#FIN-WAIT-2" class="headerlink" title="FIN_WAIT_2"></a>FIN_WAIT_2</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-finwait2.png" width="400"><br>  <br><br></center><p>요청자는 수신자로부터 승인 번호를 받고 자신이 보냈던 시퀀스 번호와 승인 번호의 차가 1이 맞는지 확인한다. 하지만 아직 수신자의 데이터 전송이 전부 끝나지 않았을 수도 있기에 <code>FIN_WAIT2</code> 상태로 들어가서 수신자가 연결 종료를 허락하는 <code>FIN</code> 패킷을 보내줄 때까지 기다린다.</p><p>방금 CLOSE_WAIT 섹션에서 설명했듯이 여기서부터는 수신자가 다시 FIN 패킷을 보내줄 때까지 요청자는 계속 대기하는 시간이다.</p><p>하지만 CLOSE_WAIT와 다르게 무한정 대기만 하는 것은 아니고 커널 파라미터로 타임아웃이 정해져있는 경우, 일정 시간이 경과하면 자동으로 다음 단계로 넘어갈 수 있다.</p><h3 id="LAST-ACK"><a href="#LAST-ACK" class="headerlink" title="LAST_ACK"></a>LAST_ACK</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-lastack.png" width="400"><br>  <br><br></center><p>수신자는 자신이 처리할 데이터가 더 이상 없다면 연결을 종료하는 함수를 명시적으로 호출하고, 아까 요청자가 보냈던 연결 종료 요청에 합의한다는 의미로 요청자에게 다시 <code>FIN</code> 패킷을 보낸다.</p><p>이때 수신자가 보내는 FIN 패킷에 담기는 시퀀스 넘버는 자신이 이번에 전송해야 하는 데이터의 시퀀스 번호를 그대로 사용하며, 승인 번호는 마지막으로 자신이 응답했던 승인 번호를 그대로 사용한다.</p><p>이후 수신자는 <code>LAST_ACK</code> 상태로 들어가며 요청자가 다시 승인 번호를 보내줄 때까지 대기한다.</p><h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-timewait.png" width="400"><br>  <br><br></center><p>수신자가 보낸 FIN 패킷을 받은 요청자는 다시 <code>수신자가 보낸 시퀀스 번호 + 1</code>로 승인 번호를 생성하여 수신자에게 ACK 패킷으로 응답한다. 이후 요청자는 <code>TIME_WAIT</code> 상태로 들어가며, 실질적인 연결 종료 과정에 들어가게 된다. 이때 TIME_WAIT의 역할은 의도하지 않은 에러로 인해 연결이 데드락에 빠지는 것을 방지하는 것이다.</p><p>TIME_WAIT에서 대기하는 시간은 <code>2 MSL(Maximum Segement Lifetime)</code>으로 정의되어 있으며, 정확한 MSL의 시간 값은 커널 파라미터로 정의되어있다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.inet.tcp | grep msl</span><br><span class="line">net.inet.tcp.msl: 15000</span><br></pre></td></tr></tbody></table></figure><p>필자의 컴퓨터인 OSX의 MSL은 15초로 설정되어있다. 즉, 필자의 컴퓨터는 TIME_WAIT 상태에서 30초 정도 대기한다는 것이다. 참고로 이 값은 변경할 수 없기 때문에 TIME_WAIT에서 소비되는 시간은 변경할 수 없다.</p><p>보통 TCP 타임아웃 파라미터로 많이 언급되는 <code>net.ipv4.tcp_fin_timeout</code>은 FIN_WAIT2의 타임아웃을 조절할 수 있는 값이라 TIME_WAIT 상태에는 해당 사항이 없다.</p><p>하지만 CLOSE_WAIT와 마찬가지로 여기서도 데드락이 발생할 수 있다. 그런 이유로 많은 네트워크 엔지니어들이 여기서 소비되는 시간을 줄이거나 운 나쁘게 발생한 데드락을 없애기 위해 <code>tcp_tw_reuse</code> 커널 파라미터를 변경하는 등 여러가지 방법을 사용하고 있다. <small>(데드락 피하자고 만든 상태인데 데드락이 발생하는 현실)</small></p><p>하지만 역시 그냥 가만 냅두는 게 제일 좋다고들 한다.</p><h3 id="CLOSED-수신자"><a href="#CLOSED-수신자" class="headerlink" title="CLOSED(수신자)"></a>CLOSED(수신자)</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-closed-server.png" width="400"><br>  <br><br></center><p>요청자가 보낸 ACK 패킷을 받은 수신자는 <code>CLOSED</code> 상태로 들어가며 연결을 완전히 종료한다.</p><h3 id="CLOSED-요청자"><a href="#CLOSED-요청자" class="headerlink" title="CLOSED(요청자)"></a>CLOSED(요청자)</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-closed-client.png" width="400"><br>  <br><br></center><p><code>TIME_WAIT</code> 상태에서 2 MSL만큼 시간이 지나면 요청자도 <code>CLOSED</code> 상태로 변경된다. 위에서 설명했듯이 이 시간은 커널 파라미터에 고정되어 있고, 필자가 사용하고 있는 OSX의 경우 30초 정도이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이렇게 두 번째 TCP 주제인 핸드쉐이크에 대한 포스팅을 마쳤다. TCP에 대해서 학교에서 배우긴 했지만 이렇게 각 상태에 대해서 자세히 공부하진 않았기 때문에 나름 새로운 경험이었다.</p><p>이 포스팅을 작성하면서 TCP가 단순히 연결을 생성하고 종료하는데만 해도 신뢰성을 확보하기 위해 얼마나 많은 작업을 하는지 알 수 있었다. <small>(더불어 구글이 왜 HTTP/3에 UDP를 사용했는지 알 것 같았다…)</small></p><p>처음에는 필자 블로그 로컬 서버와 브라우저의 핸드쉐이크를 캡처해보려고 했는데, 이 친구들은 단순한 몇 개의 메세지를 주고 받는 수준이 아니라 대량의 데이터를 주고 받는 사이다보니 필자가 원하는 부분을 추적하기가 쉽지 않았다.</p><p>그래서 오랜만에 간단한 소켓 프로그래밍을 하게 되었는데, 음… 하도 오랜만에 C를 사용하다보니 손에 안 익어서 꽤나 고생하긴 했지만 나름 재미있었다. C는 역시 가끔 해야 재밌는 것 같다.</p><p>혹시 필자가 예제로 사용한 어플리케이션을 직접 실행해보고 싶으신 분은 필자의 <a href="https://github.com/evan-moon/simple-tcp-example" target="_blank" rel="noopener">깃허브 레파지토리</a>에서 클론 받을 수 있다. 간단한 메세지만 서로 주고 받는 어플리케이션이니 <code>tcpdump</code>를 사용해서 패킷을 들여다보기도 한결 편할 것이다.</p><p>이상으로 TCP가 연결을 생성하고 종료하는 방법, 핸드쉐이크 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/11/17/tcp-handshake/#disqus_thread</comments>
    </item>
    
    <item>
      <title>불안한 마음 정면으로 마주보기</title>
      <link>https://evan-moon.github.io/2019/11/16/the-way-to-control-anxiety/</link>
      <guid>https://evan-moon.github.io/2019/11/16/the-way-to-control-anxiety/</guid>
      <pubDate>Sat, 16 Nov 2019 08:17:57 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;지난 달, 다니고 싶었던 회사의 면접에서 기초 실력 부족으로 시원하게 박살났다. 다행히 면접이 끝난 직후 필자가 대답하지 못했던, 풀어내지 못했던 질문들과 문제를 깃허브에 정리해두었기 때문에 어떤 것을 공부해야하는지 바로 알 수 있었고, 한 달동안 컴퓨터 사이언스의 기초에 대한 내용을 집요하게 파헤쳤다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>지난 달, 다니고 싶었던 회사의 면접에서 기초 실력 부족으로 시원하게 박살났다. 다행히 면접이 끝난 직후 필자가 대답하지 못했던, 풀어내지 못했던 질문들과 문제를 깃허브에 정리해두었기 때문에 어떤 것을 공부해야하는지 바로 알 수 있었고, 한 달동안 컴퓨터 사이언스의 기초에 대한 내용을 집요하게 파헤쳤다.</p><a id="more"></a><p>대학생 시절 이후로 꺼내보지 않았던, 먼지 쌓인 전공 서적을 다시 펼쳐놓고 정독하기 시작했고, 자바스크립트의 기초 지식을 닥치는대로 구글링하면서 스크랩했다. 사실 작성한 포스팅들의 주제만 봐도 지난 한 달 동안 필자가 공부한 것들이 어떤 주제였는지 대충 보인다.</p><p>필자가 프라하에서 지냈던 한 달 동안 5편의 에세이 포스팅과 1편의 기술 포스팅을 작성한 것과 비교해보면 최근 한 달간의 포스팅들은 전부 기술 포스팅이다. 그것도 기초적인 내용들인 힙, JS 프로토타입, 수학으로 알고리즘 문제 풀기, 최근의 TCP 집중 분석까지…</p><p>그렇게 한 달동안 미친듯이 컴퓨터 사이언스의 기초를 공부하다가, 오늘 오전에 다른 회사의 면접 기술 과제를 만들기 위해 IDE를 켰는데 문득 이런 생각이 스쳤다.</p><blockquote><p>내가 마지막으로 뭘 만들어 본게 언제였지?</p></blockquote><center><br>  <img src="/2019/11/16/the-way-to-control-anxiety/commit.jpeg" width="300"><br>  <br><br></center><p>지난 한 달동안 필자는 어플리케이션을 개발한 적이 없었던 것이다. 만드는 것이 너무 즐거워서 개발자가 되었건만, 정작 한 달동안이나 아무것도 만들지 않고 있었다.</p><p>필자의 지난 한 달은 기초에 대한 공부의 연속이었고, 지금까지 놓치고 있었던 것들을 다시 한번 살펴보는 복습의 시간이었다. 하지만 딱히 공부를 하면서 즐겁지는 않았던 것 같다. 아니, 사실 즐겁게 공부하려는 마음도 없었다고 말하는 게 맞을지도 모른다.</p><p>여기까지 생각이 닿고나니 갑자기 현타가 와서 잠시 공부를 접고 스스로를 돌아보는 시간을 가지려고 한다.</p><h2 id="나는-불안했다"><a href="#나는-불안했다" class="headerlink" title="나는 불안했다"></a>나는 불안했다</h2><p>지난 한 달 동안 필자는 현실에 쫓기고 있었다. 프라하에서 다짐했던 <code>여유를 가지며 살자</code>라는 마음은 서울에 도착하고 몇 주가 지나자 온데 간데 없어져버렸다.</p><p>사실 이런 불편한 감정의 근본적인 원인은 바로 <code>불안감</code>이다. 이런 불안감은 필자의 일상을 흑백으로 바꿔버렸다. 친구들을 만나면 순간순간은 즐거웠지만, 틈만 나면 빨리 집에 가서 바로 책과 노트북을 피고 공부해야한다는 생각이 떠올랐다.</p><p>그냥 딱 봐도 건강한 마음의 상태는 아니다. 물론 겉으로는 아닌 척하고 있지만 속에서부터 곪아가고 있는 상태인 것이다. 그래서 필자는 공부를 잠깐 멈추고, 도대체 무엇 때문에 이렇게 불안해하며 쫓기고 있는 것인지 생각해보기 시작했다.</p><p>물론 간만에 면접에서 털려보면서 필자의 약점을 날 것으로 마주하게 되었다는 이유가 크겠지만, 단순히 이것 때문에 이 정도까지 불안한 마음이 생긴다는 것은 조금 이상했다. 솔직히 면접 털려본 것이 한 두번도 아니니 말이다.</p><p>그렇게 하루 정도 깊게 고민을 해보고나니 몇 가지 불안 요인이 정리가 되었고, 이후 필자는 이 요인들을 리스트업하고 하나씩 살펴보기 시작했다.</p><h3 id="현실과-이상의-괴리"><a href="#현실과-이상의-괴리" class="headerlink" title="현실과 이상의 괴리"></a>현실과 이상의 괴리</h3><p>어릴 때 부모님이나 어른들이 했던 이야기 중에서 가장 이해되지 않았던 말은 <code>하고 싶은 것만 하면서 살 수는 없다</code>였다. <small>(물론 여기에는 반드시 “공부해라”라는 말이 따라온다)</small></p><p>시간이 지나 군대를 다녀오고 대학교에 복학하면서 당시 어른들이 했던 이 말의 의미를 조금씩 이해하게 되었다. 세상 만사 내 맘대로 되는 일만 있는 것은 아니니 어느 정도는 마음을 내려놓으라는 가르침이었으리라.</p><p>죽어도 공부하기 싫은 날에도 장학금을 위해 밤새워가며 공부를 해야했고, 군대에 가기 싫었지만 국방의 의무 때문에 23개월동안 구르다 왔던 경험을 하고 나니 <code>음, 그 말이 바로 이런 느낌이군</code>이라는 생각을 했던 것 같다.</p><p>그래도 하기 싫은 일을 돈 때문에 억지로 하면서 평생 살고 싶지는 않았기에, 내 인생의 행복을 위해서는 <code>하고 싶은 일</code>을 가장 우선 순위로 높게 잡고 있었고, 다행히도 개발자라는 직업을 가지게 되면서 사회의 일원으로써의 자리와 직장인으로써의 안정적인 수입, 그리고 내가 즐기며 할 수 있는 일까지 거머쥔 덕업일치의 생활을 할 수 있었다.</p><p>그러나 개발자로 일을 하게되면 행복하기만 할 것이라는 필자의 생각과는 달리 개발자로의 삶은 치열했다. 이제부터는 시험 등수나 장학금을 위한 경쟁이 아닌 진짜 생존을 건 경쟁이 시작된 것이다.</p><p>아직 성 차별, 학력 차별 등 여러가지 문제가 산재하기는 하지만 기본적으로 2019년의 대한민국은 모든 사람에게 평등한 기회를 주려고 노력하는 사회이고, 그런 기회는 보통 개인의 능력이나 실력으로 거머쥘 수 있다.</p><p>그 중에서도 특히 IT업계의 대표적인 전문직인 개발자는 진짜 실력 하나로 비벼서 먹고 살아가는 실력몰빵주의라고 할 수 있다. 도태되지 않기 위해서는 끊임없이 공부를 하면서 빠르게 변화하는 기술 트렌드나 패러다임을 따라가야하는 것이다. 그래서 개발자들 사이에서는 치킨 집을 차리기 전까지는 계속 공부해야한다는 자조섞인 농담을 나누기도 한다.</p><p>그래도 필자는 프로그래밍 공부를 한다는 것 자체가 너무 재밌고 좋았다. 애초에 내가 하고 싶은 일을 선택한 것이기도 하고 공부하면 할수록 내가 만든 어플리케이션이 더 좋은 구조, 좋은 성능을 가질 수 있으니까.</p><p>하지만 앞서 이야기 했듯이, 최근 한 달 동안 컴퓨터 사이언스의 기초를 공부하면서 필자는 마냥 즐겁지만은 않았다.</p><p>사실 필자가 즐겁지 않은 공부를 하며 가장 의아했던 부분은 이렇게 기초를 공부하는 과정은 이미 대학생 때 한번 겪었던 경험인데 그때 당시와 지금 느끼는 감정이 너무나도 다르다는 것이었다. 당시에는 똑같은 공부를 해도 하나하나 신기하고 너무 재미있었기 때문이다.</p><p>그럼 대학생 때는 그렇게 재미있었던 내용들이 왜 지금와서는 재미가 없어진 것일까?</p><p>그 이유는 바로 <code>공부의 동기</code> 때문이다. <a href="/2019/08/26/how-does-developer-study/" title="개발자가 공부로 살아남는 방법">개발자가 공부로 살아남는 방법</a> 포스팅에서도 한 번 이야기한 적이 있지만, 사실 공부라는 것은 주제의 난이도보다도 건강한 동기 부여가 더 중요하다.</p><p>하지만 필자는 현재 자의적으로 컴퓨터 사이언스 기초에 대한 공부를 하는 것이 아니라 구직 중이라는 외부 상황에 떠밀려서 공부를 하고 있는 상황이다. 더 쉽게 이야기해보자면, 필자가 원하는 주제를 필요에 따라 공부하는 것이 아니라 당장 하고 싶지 않은데 외부 상황 때문에 억지로 하고 있는 공부인 것이다.</p><center><br>  <img src="/2019/11/16/the-way-to-control-anxiety/study-motivation.jpg" width="300"><br>  <small>어차피 나중에 공부할건데 엄마가 지금 공부하라고 하면 왠지 더 하기 싫어지는 마음이랄까</small><br>  <br><br></center><p>사실 공부할 주제를 선택할 때 <code>이걸 공부하면 내가 어떤 점이 더 나아질까?</code>라는 생각으로 두근거려야 하는데, 최근 한 달간의 공부는 <code>이걸 면접에서 물어볼까?</code>라는 마음으로 주제를 선택했으니 재미있을리가 만무하다.</p><p>그래도 어릴 적 어른들이 이야기했던 하고 싶은 것만 하면서 살 수는 없다는 말처럼 필자가 면접에 합격하기 위해서 부족한 부분을 채우는 과정이 필요하다는 것 또한 분명한 사실이다.</p><p>필자는 일을 재미있게 하고 싶어서 개발자라는 직업을 선택했는데, 현실적인 상황 때문에 재미없게 공부를 하고 있는 이 상황에 대해서 괴리감과 불편함을 느끼기 시작한 것이다.</p><h3 id="스스로에-대한-실망감"><a href="#스스로에-대한-실망감" class="headerlink" title="스스로에 대한 실망감"></a>스스로에 대한 실망감</h3><p>사실 지금까지 필자는 별 생각없이 회사를 선택해왔었다. 재밌게만 일할 수 있으면 됐지, 어디서 일하느냐가 그렇게 중요하지 않다고 생각했기 때문이다.</p><p>그런 식으로 직장을 고르다보니까 스스로 좀 더 많은 권한을 부여받고 많은 일을 할 수 있는 작은 규모의 스타트업을 주로 다니게 되었다.</p><p>그러나 최근 주변에 있는 많은 개발자분들이 <code>작은 곳도 경험해보고 큰 곳도 경험해봐라</code>라는 조언을 많이 해주셨다. 조금 더 다양한 경험을 해보고 성장하라는 의미인 것이다. 그런 이유로 이번에는 지금까지 다녔던 직장보다는 조금 더 규모가 있는 곳을 목표로 잡고 있다.</p><p>그러나 큰 회사들의 경우, 채용 과정과 원하는 인재상까지 필자가 지금까지 다녔던 규모의 회사들과는 조금 다르다.</p><p>규모가 작은 스타트업의 경우 말 그대로 <code>일당백의 당장 일할 수 있는 개발자</code>가 필요하다. 만들어야하는 프로덕트는 산더미같은데 리소스는 늘 부족하다보니 한 사람 한 사람이 많은 역할을 할 수 밖에 없는 것이다. 게다가 리소스가 부족하다보니 누군가를 체계적으로 교육하거나 스스로 학습할 수 있는 여유도 큰 회사에 비해 상대적으로 부족한 경우가 많다.</p><p>이에 반해 큰 회사들은 당장 입사해서 일할 수 있는 개발자를 급하게 찾는 입장은 아니다. 물론 어떤 회사던지 개발자라는 자원은 많으면 많을수록 좋기 때문에 계속 채용을 하기는 하지만, 규모가 작은 스타트업에 비교해봤을 때 당장 일할 사람이 부족해서 허덕이고 있는 정도의 상황은 아닐 가능성이 높다.</p><p>게다가 시스템의 규모 또한 해당 개발팀의 규모에 비례해서 늘어날 수 있기 때문에, 이미 많은 개발자를 보유하고 있는 회사의 시스템은 크기도 방대하고 구조도 복잡한 경우가 많다.</p><p>이런 이유들로 인해 규모가 큰 곳일수록 특정 프레임워크에 익숙한지 물어보기보다는 <code>니가 이걸 진짜 제대로 알고 쓰는거니?</code>에 집중하는 경우가 많기 때문에 컴퓨터 사이언스나 사용하는 언어에 대한 기초를 깊게 물어보는 것이다.</p><p>필자도 당연히 이런 사실들을 알고는 있었지만, 한국에 돌아오고 처음 면접을 볼 때까지만 해도 솔직히 별 걱정이 없었다. 그냥 <code>붙으면 다니고 아니면 다른 데 가지 뭐</code> 정도의 마음이었던 것 같다. 실제로 첫 면접에 떨어진 직후에는 불안한 마음이고 뭐고 멘탈에 별 타격이 없었다.</p><p>그래도 면접에 떨어졌으니 필자가 현재 부족한 것이 무엇인지 알 수 있었고, 당연히 이 부분을 보완하고 싶다는 마음이 생기게 되었다. 하지만 이상하게도 공부를 하면 할수록 뭔가 마음이 싱숭생숭해지기 시작했다.</p><p>얼마 전 SNS에서 여친이랑 헤어진 남자의 심리 변화라는 짤을 본 적이 있다. 여친이랑 헤어진 직후는 후련하고 자유로운 기분이지만 시간이 지나면서 그리운 감정이 커지게되고 후회한다는 그런 내용이었다. 뭔가 그런 느낌이랄까.</p><p>공부를 하면 할수록 면접장에서 제대로 대답하지 못했던 상황들이 계속 떠올랐고, 뒤늦은 부끄러움과 후회가 밀려온 것이다. 그와 동시에 스스로에 대한 실망감도 들기 시작했다.</p><p>솔직히 말하자면 나름 컴퓨터 사이언스에 대해서 알고 있다고 생각했다. 학교에서도 이미 한 번씩 배운 내용들이고, 나름 이것저것 분석해보면서 쌓은 지식들도 있었기 때문이다. 그러나 현실은 달랐다.</p><center><br>  <img src="/2019/11/16/the-way-to-control-anxiety/snl.jpg" width="500"><br>  <br><br></center><p>막상 면접장에 들어서고나서 <code>GC에 대해서 설명해주세요</code>와 같은 질문을 들으면 머리가 하얘졌다. 이런 질문을 들을 때 마다 필자의 머릿 속에는 수많은 개념들과 그림들이 동시에 떠올랐지만 정작 이걸 말로 정리해서 말하지 못했다. 즉, 제대로 알고 있지 않은 것이다.</p><p>이런 경험을 몇 번 하고나니 지금까지 내가 알고있다고 생각했던 지식들이 사실은 제대로 알고 있는 것이 아니었다는 것을 깨닿게 되었고, 지금까지 헛공부한 게 아닌가라는 생각, 다른 개발자들에 비해서 내가 뒤쳐질 수도 있다는 불안감이 스물스물 피어나게 되었다.</p><h3 id="주목당하는-게-부담스럽다"><a href="#주목당하는-게-부담스럽다" class="headerlink" title="주목당하는 게 부담스럽다"></a>주목당하는 게 부담스럽다</h3><p>아이러니하게도 지금 글을 작성하고 있는 바로 이 블로그도 필자의 불안감의 요인 중 하나이다. 정확히 말하면 불안정한 필자의 심리 상태에 불을 붙혀서 불안감을 증폭시킨 요인이라고 할 수 있겠다.</p><p>지금까지 필자는 포스팅을 적고 다른 사람들과 내 지식과 생각을 공유하기 위한 목적으로 약간의 홍보를 통해 포스팅을 공유해왔다. 그러다보니 필자의 글을 재밌게 읽어주신 분들이 <code>포스팅 잘 읽었다</code>, <code>좋은 정보 공유 감사하다</code> 정도의 말씀을 해주시는 경우가 생기게 되었는데, 이때까지는 내 지식이 다른 사람들에게 도움이 될 수 있다는 사실에 그냥 기분이 좋았다.</p><p>하지만 최근 오프라인에서 필자를 알아보는 사람이 나타나는 경험을 몇 번 겪으면서 약간의 부담감이 스물스물 피어나게 되었다. <small>(이럴거라고는 진짜 상상도 못 했다)</small></p><p>이 감정이 최대로 증폭되는 경우는 바로 면접관이 <code>평소에 블로그 잘 보고 있어요</code>라고 하는 경우인데, 이때의 당혹감과 부담감이란 말로 표현할 수가 없다. 긴장을 안하고 있다가도 한 순간에 긴장하게 만들어버리는 마법의 단어인 것 같다.</p><p>그냥 사람들이 알아보는 것이 부담스럽다는 뜻은 아니다. 사람들이 필자를 알아보기 시작하면서 조금씩 <code>이 사람들이 날 어떻게 생각할까?</code>를 신경쓰기 시작했다는 것이 문제다.</p><p>사실 필자가 블로그 포스팅을 작성하는 이유는 필자의 지식을 타인에게 공유하고 싶다는 목적도 있지만 기본적으로는 공부한 내용을 정리하려는 목적이 크다. 자신의 지식을 글로 정리하는 과정에서 공부의 효율성을 높히고 기억에 오래 남는 효과를 기대하는 것이다.</p><p>하지만 필자가 엄청 뛰어난 기억력을 가지고 있지 않은 이상, 몇 번 공부한 내용이라고 한들 실제로 그 지식을 사용하지않고 오랜 기간이 지난다면 기억에서 점점 잊혀지기 마련이다. 결국 뭐가 되었든 공부의 기본은 반복 학습이고, 한 번 포스팅을 작성했다고 해서 그 지식이 온전히 필자의 것이 되는 게 아니라는 말이다.</p><p>그런 이유 때문에 필자는 계속 스스로 과거에 작성했던 포스팅을 읽어보면서 되새김질하기도 한다.</p><p>그러나 글을 읽는 독자 입장에서는 포스팅을 작성한 사람이 이 지식을 완벽하게 알고 있다는 생각이 들 수도 있다. 필자만 해도 다른 개발자 분들의 블로그 포스팅을 읽어보면서 막연하게 블로그 포스팅을 잘 쓰는 사람과 실력이 좋은 사람을 동일시했었다. 이 내용에 대해서 빠삭하게 잘 아니까 이렇게 글도 잘 쓰겠지라는 생각 때문이었다.</p><p>하지만 글을 잘 쓰고 정리를 잘 한다는 것이 필자의 프로그래밍 실력이 좋다는 것을 의미하진 않는다. 독자들이 생각하고 기대하는 것보다 필자의 실력이 만족스럽지 않을 수도 있다는 것이다.</p><p>필자가 느끼는 부담감은 이런 상황에서 비롯된 것이었다. 다른 사람이 <code>에반님 그때 정리해주신 그 내용 말이에요~</code>라고 운을 떼는 순간, <code>이거 대답 못하면 어쩌지?</code>라는 생각이 들 게 된다. 특히 그 사람이 면접관이라면 더 그렇다.</p><p>또한 간혹 고수, 존경과 같은 과분한 말을 해주시는 경우도 있는데, 애초에 필자는 고수도 아니고 누군가에게 존경받을 만한 사람은 더더욱 아닌, 그저 일개 4년차 꼬꼬마 개발자이기 때문에 감사한 마음과 동시에 약간의 부담감이 생기기도 햇다.</p><p>그래서 이런 상황들을 겪을 때마다 이런 생각이 들기 시작했다.</p><blockquote><ul><li>내 실력은 3 정도 밖에 안 되는데, 사람들이 내 실력을 6이나 7 정도로 생각하면 어떡하지?</li><li>내가 쓴 포스팅에 대한 질문에 제대로 답변하지 못하면 어떡하지?</li><li>난 존경받을만한 사람도 아니고 고수도 아닌데… 내가 이런 말을 들을 자격이 되는건가…?</li></ul></blockquote><p>그런 이유로 언젠가부터 점점 <code>사람들이 생각하는 나</code>라는 껍데기를 만들어야한다는 강박관념이 스물스물 피어나기 시작했고, 그 와중에 면접에서 거하게 털리면서 이 불안감 또한 함께 증폭된 것이다.</p><h2 id="결국은-마인드의-문제다"><a href="#결국은-마인드의-문제다" class="headerlink" title="결국은 마인드의 문제다"></a>결국은 마인드의 문제다</h2><p>사실 이런 불안한 마음들은 사람이라면 자연스럽게 생길 수 있는 마음이다. 그러나 이런 감정들은 막연하게 <code>불안하다</code> 정도의 느낌이라서, 명확하게 <code>무엇 때문에 내가 불안하다</code>라는 생각까지는 평소에 잘 생각하지 않는다.</p><p>하지만 자신이 불안한 이유를 확실히 파악하지 못하면 그 문제를 해결할 수 없다. 그래서 필자는 불안함의 원인에 대해서 리스트업을 하면서 이 문제들과 정면으로 마주한 것이다.</p><p>필자는 스스로 불안감의 요인에 대한 원인을 정리하고 리스트업하면서, 자연스럽게 이 문제에 대해 스스로 질문하고 답변하는 과정을 통해 나름의 해결 방법들을 정의할 수 있었다.</p><h3 id="동기-부여를-확실히-하자"><a href="#동기-부여를-확실히-하자" class="headerlink" title="동기 부여를 확실히 하자"></a>동기 부여를 확실히 하자</h3><p>앞서 이야기했듯이 필자가 컴퓨터 사이언스 기초 공부를 하며 재미없다고 느끼게 된 이유는 <code>하기 싫어도 해야한다</code>라는 마음 때문이다. 물론 현실적으로 보면 틀린 말은 아니다. 면접에 합격하기 위해서는 필자의 약점을 보완해야하니 말이다.</p><p>그러나 이번 한 번만 공부하고 말 것이 아니라면 이런 식의 동기 부여는 좋지 않다. 외압에 의한 동기 부여는 잠깐 동안 스스로를 몰아 세우며 빠르게 성장할 수는 있어도, 지속적인 성장에는 오히려 걸림돌이 된다.</p><p>사실 근본적으로 생각해보면 대학생 때나 지금이나 공부하고 있는 내용은 크게 다르지 않다. 하지만 그때는 기초 공부가 재미있었고 지금은 아니었던 이유가 바로 여기에 있다.</p><p>당시에는 내가 이걸 공부함으로써 성장할 수 있다는 사실이 동기가 되었지만, 지금은 면접에 붙어야한다는 사실이 동기가 되었기 때문에 같은 것을 공부해도 상당히 다른 느낌을 받을 수 밖에 없다는 것이다.</p><p>그래서 필자는 다시 초심으로 돌아가 <code>성장</code>에 초점을 맞춰 보려고 한다. 비록 빡센 기초 공부의 시작은 면접 때문이었을지 몰라도, 결과적으로는 필자가 성장할 수 있는 좋은 기회이기도 하기 때문이다.</p><h3 id="면접은-그냥-면접일-뿐"><a href="#면접은-그냥-면접일-뿐" class="headerlink" title="면접은 그냥 면접일 뿐"></a>면접은 그냥 면접일 뿐</h3><p>사실 기껏해야 한 두시간의 짧은 면접 시간 동안 한 사람의 역량을 오롯히 파악하는 것 자체가 굉장히 어려운 일이다.</p><p>그래서 대부분의 회사는 1차 기술, 2차 임원 등으로 면접 전형을 나눠서 평가하고 있지만, 이렇게 하더라도 컴퓨터 사이언스라는 학문의 범위가 너무 넓기 때문에 진짜 그 사람의 모든 강점과 약점을 파악한다는 것은 거의 불가능하다.</p><p>하지만 회사든 구직자든 면접 한번 보자고 서로 며칠 씩이나 붙어있을 수는 없는 노릇이니 최대한 짧은 시간 안에 객관적이고 효율적으로 실력을 평가할 수 있는 방법이나 질문을 통해 구직자를 평가하려고 노력하는 것이다.</p><p>당연히 이러한 사실은 회사도 알고 있기 때문에 면접관 스스로 혹은 회사의 가이드대로 어느 정도 객관성을 띄고 있는 질문을 준비하기는 하지만, 이 질문이 구직자의 강점이나 약점을 얼마나 캐낼 수 있는지는 며느리도 모르는 일이다.</p><p>그 말인 즉슨, 면접의 평가 결과는 어느 정도 단편성을 지니고 있을 수 밖에 없다는 것이다.</p><p>하지만 면접 과정에서 구직자가 면접관이 물어본 질문에 대답을 못했을 경우, 그 질문이 구직자의 약점을 관통했다는 것 자체는 물론 사실이다. 그래서 필자도 질문에 대답하지 못했던 내용을 정리하고 공부했던 것이다.</p><p>그러나 약점이 존재한다는 것이 실력없고 형편없다는 의미는 아니다. 약점은 보완하면 되는 것이고, 면접은 무슨 수능처럼 1년에 한 번만 볼 수 있는 것도 아니니까 다음 기회에 다시 도전하면 된다.</p><p>필자의 보컬 선생님 말을 빌리자면, 오히려 그런 기회를 통해 자신의 약점을 발견할 수 있음에 감사하라고 한다. 이런 기회조차 없는 상황이라면 오히려 더 성장하기 힘들 것이라는 이야기도 들었다.</p><p>이게 그저 정신승리라고 생각하는 사람도 있겠지만, 스스로 건강한 마음을 가질 수 있어야만 꾸준한 도전이 가능하기 때문에 이런 식의 멘탈 케어는 개인의 성장이나 발전에도 도움이 된다고 생각한다.</p><p>중요한 것은 면접에 떨어졌다는 것이 아니라, 면접을 통해 자신의 약점을 발견하고 올바른 동기 부여를 통해 꾸준한 공부를 할 수 있는 원동력을 확보하는 것이기 때문이다.</p><h3 id="블로그는-그냥-꾸준히-쓰자"><a href="#블로그는-그냥-꾸준히-쓰자" class="headerlink" title="블로그는 그냥 꾸준히 쓰자"></a>블로그는 그냥 꾸준히 쓰자</h3><p>필자는 애초에 자기 자신에게 후한 평가를 주는 성격은 아니다. 그냥 이건 필자 본연의 성격이기 때문에 개발자가 아니라 그냥 한 명의 인간으로써도 그렇다. 그래서 필자의 글을 읽은 분들이 칭찬과 격려의 의미로 해주시는 말들도 잘 받아들이지 못했던 것 같다. <small>(칭찬을 잘 안 받아들이는 타입이다)</small></p><p>사실 앞서 이야기했던 두 가지 케이스는 나름 혼자 생각해보면서 결론을 내렸지만, 이 문제만은 아직 명확한 결론을 내지 못한 상태이다. 그냥 다들 큰 의미없이 좋은 뜻으로 하는 말이니까 듣고 흘리라는 조언도 듣긴 했지만, 성격이 성격인지라 그러기도 쉽지 않기 때문이다.</p><p>그렇다고 블로그 작성을 그만 둘거냐면 그것도 아니다. 블로그 포스팅 작성은 공부와 공유의 목적도 있지만 그 전에 필자의 취미 생활이기도 하기 때문이다. 그래서 처음에는 포스팅은 꾸준히 쓰되 홍보를 하지말까라는 생각도 했었지만, 뭔가 명확한 결론이 나기  전까지는 그냥 하던대로 하는 것이 좋겠다는 결론을 내렸다.</p><p>사실 이건 필자 스스로 느끼는 부담감이고, 이것 외에는 블로그 포스팅 작성이 필자에게 득이 되었으면 되었지 실이 될 만한 것은 없기 때문이다. 그래서 이런 저런 생각보다는 글쓰기라는 행위 자체에만 집중하려고 한다. 그래서 지금도 아무 생각없이 일단 글을 쓰고 있다.</p><p>그리고 이런 이유 때문에 생기는 불안한 마음은 필자가 꾸준히 공부해서 점점 성장하고 자신감이 많이 붙게 된다면 자연스럽게 흐려질 것이라고 생각한다. 이런 과정 또한 필자가 성장하는 과정이고 컴포트 존을 벗어날 수 있는 좋은 기회일테니, 정면으로 부딫혀서 극복해봐야 하는 것 아닐까싶다.</p><p>일단 지금은 그냥 필자에게 관심을 가지고 지켜봐주시는 분들이 있다는 것에 감사하며 꾸준히 글이나 끄적이는 게 최선인 것 같다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번 포스팅은 어떻게 보면 실로 오랜만에 적어본, 남들을 위한 글이 아닌 나를 위한 글이었다. 글을 적으면서 생각을 정리하다보니 불안했던 마음도 어느 정도 사그러드는듯 하다.</p><p>비단 필자 뿐만 아니라, 필자와 비슷한 상황에 있는 다른 사람들도 비슷한 감정을 느낄 것이라고 생각한다. 일 안하고 하고 싶은 거 하면서 사는 백수 생활이라는 것이 물론 편하긴 하지만 그에 따른 부담감과 불안함도 당연히 따라오는 것이니 말이다.</p><p>게다가 이런 상태에서 발생한 불안감은 사소한 일상의 좌절만으로도 쉽게 증폭되기 때문에, 더욱 더 이런 멘탈 관리가 중요한 것 같다.</p><p>그래도 이렇게 글로 생각을 정리하는 과정을 거치면서 필자가 왜 불안한 마음이 드는 지 확실히 알 수 있었고, 이에 따른 나름의 해결책 또한 정의해볼 수 있었다. 이런 게 바로 글이 가진 매력이 아닐까.</p><p>물론 완전히 떨쳐내지는 못할 것이다. 사람인 이상 불확실한 미래를 걱정하며 불안한 감정이 생기는 것은 자연스러운 것이니까.</p><p>하지만 막연하게 불안함에 떨고 쫓기면서 하기 싫은 공부를 억지로 하거나 부담감을 가지고 포스팅을 작성하는 상황보다는 내가 이 공부를 함으로써 어떤 방향으로 성장할 수 있을 지 확실히 인지하고, 내가 작성한 글들이 타인에게 좋은 영향을 줄 수 있을거란 믿음을 가지는 것이 훨씬 건강한 마인드라는 것은 자명하다.</p><p>면접 떨어진 건 아쉽긴 하지만, 부족한 실력은 공부해서 채우면 된다. 어차피 백수니까 공부할 시간도 남아돈다. 사실 이 시간 또한 언젠가 다시 직장인이 되면 그리워질 시간일테니, 최대한 마음 편하게 즐겨보려고 한다.</p><p>이렇게 불안한 마음을 다스릴 수 있는 글쓰기라는 취미 생활을 가지고 있다는 것도 어찌보면 행복일지도.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/11/16/the-way-to-control-anxiety/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TCP의 헤더에는 어떤 정보들이 담겨있는걸까?</title>
      <link>https://evan-moon.github.io/2019/11/10/header-of-tcp/</link>
      <guid>https://evan-moon.github.io/2019/11/10/header-of-tcp/</guid>
      <pubDate>Sun, 10 Nov 2019 09:39:00 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;저번에 &lt;a href=&quot;/2019/10/08/what-is-http3/&quot; title=&quot;HTTP/3는 왜 UDP를 선택한 것일까?&quot;&gt;HTTP/3는 왜 UDP를 선택한 것일까?&lt;/a&gt; 포스팅을 진행하며 TCP에 대해 간단한 언급을 했었지만, 해당 포스팅에서는 기존의 HTTP에서 사용하던 TCP에 어떤 문제가 있었는지에 집중해서 이야기했었지만 이번에는 TCP 자체에 조금 더 집중해서 이야기해보려고 한다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>저번에 <a href="/2019/10/08/what-is-http3/" title="HTTP/3는 왜 UDP를 선택한 것일까?">HTTP/3는 왜 UDP를 선택한 것일까?</a> 포스팅을 진행하며 TCP에 대해 간단한 언급을 했었지만, 해당 포스팅에서는 기존의 HTTP에서 사용하던 TCP에 어떤 문제가 있었는지에 집중해서 이야기했었지만 이번에는 TCP 자체에 조금 더 집중해서 이야기해보려고 한다.</p><a id="more"></a><p>원래는 이 포스팅에서 TCP의 개괄적인 내용을 모두 다루려고 했으나 생각보다 양이 너무 많아서 몇 개의 포스팅으로 나누어 작성하려고 한다.<small>(파도파도 끝이 없는 이 놈의 할배 프로토콜…)</small></p><p>그런 이유로 이번 포스팅에서는 TCP의 헤더 안에 들어 있는 필드들이 어떤 의미를 가지고 있는지에만 집중해서 이야기 해보도록 하겠다.</p><h2 id="TCP-Transmission-Control-Protocol"><a href="#TCP-Transmission-Control-Protocol" class="headerlink" title="TCP, Transmission Control Protocol"></a>TCP, Transmission Control Protocol</h2><p><code>TCP(Transmission Control Protocol)</code>는 OSI 7계층 중 전송 계층에서 사용되고 있는 프로토콜로, 장비들 간의 통신 과정에서 정보를 안정적으로, 순서대로, 에러없이 교환할 수 있도록 하는 것에 목적을 둔 프로토콜이다.</p><p>컴퓨터 공학에서는 컴퓨터에게 가까운 부분일 수록 <code>낮다</code>거나 <code>뒤에 있다</code>는 표현을, 사람에게 가까운 <code>높다</code>거나 <code>앞에 있다</code>라는 표현을 자주 사용하는데, OSI 7계층에서도 마찬가지로 낮은 계층일수록 기계에 가까운 부분이고 높은 부분일수록 사람에게 가까운 부분이라고 생각하면 편하다.</p><center><br>  <img src="/2019/11/10/header-of-tcp/osi.png" width="500"><br>  <br><br></center><p>이때 우리에게 친숙한 <code>HTTP</code>, <code>SMTP</code>, <code>FTP</code>와 같은 프로토콜 친구들이 가장 높은 계층인 응용 계층에 위치한다. 그에 비해 더 낮은 계층에 존재하는 <code>TCP</code>, <code>UDP</code>, <code>IP</code> 같은 프로토콜들은 상대적으로 접할 일이 많이 없기는 하다.</p><p>이런 프로토콜들은 대부분 OS에서 알아서 처리해주기 때문에 상위 계층에서 프로그래밍을 하는 개발자가 굳이 여기서 일어나는 일까지 하나하나 신경쓸 필요가 없기 때문이다.</p><p>애초에 이게 레이어 모델이 존재하는 이유 중 하나이다. 네트워크라는 것이 수많은 기술의 집약체인 만큼 한 명의 개발자가 모든 것을 다 알기는 힘들다. 그래서 각 계층 간 철저한 역할 분담을 통해 어떤 작업을 할 때 신경써야하는 범위를 좁혀주는 것이다.</p><p>덕분에 우리는 HTTP를 사용할 때 DNS는 어디를 사용할지, 패킷은 어떻게 처리할지 등 여러 가지 작업을 한번에 신경쓸 필요가 없다.</p><p>하지만 아무리 레이어가 나누어져 있다고 한들 하위 레이어에서 일어나는 일을 전혀 모르고 있다면, 어플리케이션 레이어에서는 아무 문제 없지만 하위 레이어에서 문제가 발생했을 때 전혀 손도 못 대는 케이스도 발생할 수 있다.</p><p>이런 이유로 자신이 사용하고 있는 프로토콜의 대략적인 작동 원리와 개요 정도는 알고 있으면 좋다고 생각하기 때문에, 이번 포스팅을 작성하며 그 동안 대략적인 몇 가지 특징으로만 알고 있던 TCP를 조금 뜯어보려고 한다.</p><h2 id="TCP는-왜-만들어진걸까"><a href="#TCP는-왜-만들어진걸까" class="headerlink" title="TCP는 왜 만들어진걸까?"></a>TCP는 왜 만들어진걸까?</h2><p>개인적으로 어떤 기술을 공부할 때, 무작정 외우는 것이 아니라 <code>이게 왜 필요한 것인지</code>를 알고 그 이유에 대해 공감하며 공부하는 편이 효과적이라고 생각한다.</p><p>TCP는 워낙 옛날에 나온 기술이니 당시 상황을 100% 공감하기는 쉽지 않겠지만, 그래도 이 프로토콜이 개발된 이유를 살펴보면 당시 엔지니어들의 고충을 알아볼 수 있다.</p><h3 id="패킷-교환-방식을-사용해보자"><a href="#패킷-교환-방식을-사용해보자" class="headerlink" title="패킷 교환 방식을 사용해보자!"></a>패킷 교환 방식을 사용해보자!</h3><p>TCP는 방금 이야기 했듯이 1970년 냉전 당시 미 국방성이 개발하던 알파넷 프로젝트의 일부로 개발되었는데, 그 당시 알파넷을 연구할 때 관심을 가진 주제 중에 하나가 바로 <code>핵전쟁이 나도 살아남는 네트워크</code>였다.<small>(핵전쟁의 상대방은 당연히 마더 러씨아…)</small></p><p>왜냐하면 1970년대의 네트워크는 <code>회선 교환 방식</code>을 사용하고 있었기 때문에 중계국이 폭격을 맞아서 박살나거나 중간에 연결된 선이 하나가 잘려나가면 그대로 통신이 끊어져 버렸기 때문이다.</p><center><br>  <img src="/2019/11/10/header-of-tcp/old-telephone.jpg" width="500"><br>  <small>직접 보지는 않았지만 이런 느낌이지 않았을까…?</small><br>  <br><br></center><p>저 당시 중계국이 하는 일은 그냥 이거다. A가 중계국에 “B랑 연결해주세요!”라고 하면, 위의 사진과 같이 케이블이 마구 꽂혀있는 패치 테이블에서 A 라벨이 붙은 구멍과 B 라벨이 붙은 구멍을 찾아서 케이블로 연결해준다.</p><p>말 그대로 <code>회선을 교환하는 방식</code>인 것이다. 저러다가 A가 C랑 통신하고 싶으면 B 구멍에서 케이블을 빼서 C 구멍에 꽂으면 된다.</p><p>이렇게 회선 교환 방식의 경우에는 통신을 하고 싶은 상대방과 물리적으로 회선을 하나 딱 잡아놓고 계속 통신을 하는 것이기 때문에 회선의 효율이 낮을 수 밖에 없다. 우리가 전화를 걸 때 상대방이 통화 중이면 <code>상대방이 통화 중이니...</code> 어쩌고 나오는 것과 같은 원리이다.</p><p>물론 회선을 독점하기 때문에 대량의 데이터를 빠른 속도로 주르륵 보낼 수 있는 등의 장점도 있긴 하지만, 이때 미국에게 중요한 것은 <code>핵이 터져도 끊기지 않는 연결</code>이었기 때문에 하나의 회선에 전적으로 의존하는 연결이라는 건 큰 단점으로 다가왔을 것이다.</p><p>그래서 나온 아이디어가 바로 <code>패킷 교환 방식</code>이다. 데이터를 하나의 회선을 사용하여 보내다가 해당 회선이나 중계국이 개박살나면 전송되던 데이터와도 영원히 이별하게 되니, 데이터를 잘게 쪼갠 후 여러 개의 회선을 통해 보내자는 것이다. 일종의 분산투자랄까.</p><center><br>  <img src="/2019/11/10/header-of-tcp/packets.png" width="500"><br>  <small>이렇게 되면 노드 하나가 박살나도 모든 데이터가 유실되진 않을 것이다</small><br>  <br><br></center><p>최악의 경우 중간에 있는 회선이나 중계국이 박살나서 데이터가 약간 유실될 수는 있겠지만 전체 네트워크를 한 번에 타격하지 않는 이상 모든 데이터가 유실될 가능성은 적다. 또한 하나의 회선을 잡아놓고 계속 통신하는 것이 아니라 패킷에 목적지를 마킹해놓고 그냥 보내기만 하면 되니, 회선의 사용 효율 또한 높아질 수 있다.</p><p>이런 이유로 미 국방성은 이 아이디어를 채택하여 알파넷에 적용했고, 초기 테스트도 대성공하여 패킷 교환 방식의 실용성을 증명했다.</p><p>이후 몇 개의 대학과 군에서만 사용되던 알파넷이 대중들에게 공개되고 전 세계적으로 연결되며 인터넷으로 발전하게 되었고, 덩달아 알파넷의 통신 프로토콜이었던 TCP도 함께 떡상하게 된 것이다.</p><h3 id="패킷-교환-방식의-문제점"><a href="#패킷-교환-방식의-문제점" class="headerlink" title="패킷 교환 방식의 문제점"></a>패킷 교환 방식의 문제점</h3><p>하지만 패킷 교환 방식도 당연히 만능이 아니기에, 몇 가지 문제가 있었다. 우리가 TCP를 공부할 때 함께 따라오는 ARQ나 SYN, ACK 등의 개념들이 바로 이런 문제들을 해결하기 위해 과거의 엔지니어들이 머리를 싸맨 결과인 것이다.</p><blockquote><p>Q: 전송 중간에 패킷이 쥐도새도 모르게 사라지거나 훼손되면 어떡해요?<br>A: <strong>그럼 그 패킷만 다시 보내라고 해!(ARQ)</strong></p><p>Q: 송신 측이 패킷을 쪼갠 순서를 알아야 수신 측이 재조립할 수 있겠는데요?<br>A: <strong>그럼 순서번호를 패킷이랑 같이 보내!(시퀀스 번호)</strong></p><p>Q: 수신 측이 처리할 수 있는 속도보다 송신 측이 패킷을 빠르게 보내버리면 어떡하죠?<br>A: <strong>그럼 수신 측이 처리할 수 있는 양을 송신 측에 알려주고 그 만큼만 보내라고 해! (슬라이딩 윈도우)</strong></p></blockquote><p>TCP가지고 있는 많은 기능과 개념들은 마냥 글로만 봤을 땐 복잡해보이고 뭔가 외울 것도 많아보이지만, 당시 상황을 생각해보면 반드시 필요한 것들이었음을 알 수 있다.</p><p>그리고 이런 기능들은 상대방이 보낸 세그먼트의 헤더에 들어있는 정보를 파악하여 작동하기 때문에, 이 기능들을 하나씩 알아보기 전에 TCP의 헤더에는 어떤 정보들이 들어있고, 이 정보들이 의미하는 것이 무엇인지 살펴보려고 한다.</p><h2 id="TCP의-헤더를-까보자"><a href="#TCP의-헤더를-까보자" class="headerlink" title="TCP의 헤더를 까보자"></a>TCP의 헤더를 까보자</h2><p>HTTP, TCP, IP와 같은 프로토콜들은 각자 자신이 맡은 역할이 있고, 보내고자 하는 데이터에 자신의 헤더를 붙혀서 데이터의 정보를 표현한다.</p><p>TCP는 전송의 신뢰성과 흐름 제어, 혼잡 제어 등의 역할을 맡고 있는 프로토콜이기 때문에, TCP 헤더에도 이러한 기능을 사용하기 위한 여러가지 값들이 담겨있다.</p><p>즉, 이 헤더를 보면 개괄적인 TCP의 기능들을 한 차례 쓱 훑어볼 수 있다는 말이고, 그런 이유로 필자는 TCP 포스팅의 첫 번째 스텝으로 <code>헤더 까보기</code>를 골랐다.</p><center><br>  <img src="/2019/11/10/header-of-tcp/tcp-header.png"><br>  <br><br></center><p>TCP는 여러 개의 필드로 나누어진 <code>20 bytes</code>, 즉 <code>160 bits</code>의 헤더를 사용하며, 각 필드의 비트를 0 또는 1로 변경하여 전송하고자 하는 세그먼트의 정보를 나타낸다.</p><p>하지만 이 <code>20 bytes</code>라는 것은 아무 옵션도 없는 기본적인 헤더일 때의 용량이고, TCP의 여러가지 옵션들을 사용하면 헤더 맨 뒤에 옵션 필드들이 추가로 붙기 때문에 최대 <code>40 bytes</code>가 더해진 <code>60 bytes</code>까지도 사용할 수도 있다.</p><p>그럼 이 그림에 표기된 순서대로 각 필드가 어떤 정보를 담고 있는지 한번 살펴보도록 하자.</p><h3 id="Source-port-Destination-port"><a href="#Source-port-Destination-port" class="headerlink" title="Source port, Destination port"></a>Source port, Destination port</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-source-destination.png"><br>  <br><br></center><p>이 필드들은 세그먼트의 출발지와 목적지를 나타내는 필드로, 각각 16 bits 를 할당받는다. 이때 출발지와 목적지의 주소를 판별하기 위해서는 <code>IP 주소</code>와 <code>포트 번호</code>가 필요하다.</p><p>IP 주소는 당연히 한 계층 밑인 네트워크 계층에 있는 IP의 헤더에 담기기 때문에, TCP 헤더에는 IP 주소를 나타내는 필드가 없고 포트를 나타내는 필드만 존재한다.</p><h3 id="Sequence-Number"><a href="#Sequence-Number" class="headerlink" title="Sequence Number"></a>Sequence Number</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-sequence.png"><br>  <br><br></center><p>시퀀스 번호는 전송하는 데이터의 순서를 의미하며, 32 bits를 할당받는다. 최대 <code>4,294,967,296</code> 까지의 수를 담을 수 있기 때문에 시퀀스 번호가 그리 쉽게 중복되지는 않는다.</p><p>이 시퀀스 번호 덕분에, 수신자는 쪼개진 세그먼트의 순서를 파악하여 올바른 순서로 데이터를 재조립할 수 있게 된다.</p><p>송신자가 최초로 데이터를 전송할 때는 이 번호를 랜덤한 수로 초기화 하며, 이후 자신이 보낼 데이터의 1 bytes당 시퀀스 번호를 1씩 증가시키며 데이터의 순서를 표현하다 <code>4,294,967,296</code>를 넘어갈 경우 다시 0부터 시작한다.</p><h3 id="Acknowledgment-Number"><a href="#Acknowledgment-Number" class="headerlink" title="Acknowledgment Number"></a>Acknowledgment Number</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-ack.png"><br>  <br><br></center><p>승인 번호는 데이터를 받은 수신자가 예상하는 다음 시퀀스 번호를 의미하며, 32 bits를 할당받는다.</p><p>연결 설정과 연결 해제 때 발생하는 핸드쉐이크 과정에서는 <code>상대방이 보낸 시퀀스 번호 + 1</code>로 자신의 승인 번호를 만들어내지만, 실제로 데이터를 주고 받을 때는 <code>상대방이 보낸 시퀀스 번호 + 자신이 받은 데이터의 bytes</code>로 승인 번호를 만들어낸다.</p><p>예를 들어 1 MB짜리 데이터를 전송한다고 생각해보자. 이렇게 큰 데이터를 한번에 전송할 수는 없으므로, 송신자는 이 데이터를 여러 개의 세그먼트로 쪼개서 조금씩 전송해야한다. 이때 송신자가 한번에 전송할 수 있는 데이터 양은 네트워크나 수신자의 상태에 따라 가변적이긴 하지만, 그냥 <code>100 bytes</code>라고 가정해보자.</p><p>송신자는 첫 전송으로 100 bytes 만큼만 데이터를 전송하며 시퀀스 번호를 <code>0</code>으로 초기화한다. 시퀀스 번호는 1 bytes당 1씩 증가하기 때문에 첫 번째 바이트 뭉치는 0, 두 번째 바이트 뭉치는 1, 세 번째 바이트 뭉치는 2와 같은 순서로 매겨질 것이다.</p><p>즉, 이번 전송을 통해 수신자는 0~99까지 총 100개의 바이트 뭉치를 받았고, 그 다음 전송 때 받아야할 시퀀스 번호는 2가 아닌 100이 되는 것이다.</p><center><br>  <img src="/2019/11/10/header-of-tcp/ack.png"><br>  <small>100 bytes 만큼 하나의 세그먼트로 묶어서 전송한다</small><br>  <br><br></center><p><code>tcpdump</code>를 사용하여 패킷을 캡쳐해보면 실제로 송신 측이 보낸 데이터의 길이만큼 수신 측의 승인 번호가 증가하는 모습을 확인해 볼 수 있다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localhost.http-alt > localhost.49680: Flags [P.], seq 160:240, ack 161, win 6374, length 80</span><br><span class="line">localhost.49680 > localhost.http-alt: Flags [.], ack 240, win 6374</span><br></pre></td></tr></tbody></table></figure><p>송신 측이 보낸 세그먼트를 보면 시퀀스 번호가 <code>seq 160:240</code>로 찍혀있고, 수신 측은 자신의 승인 번호로 콜론 뒤 쪽의 값을 사용하고 있다.</p><p>이때 시퀀스 번호의 형식은 <code>n 이상:m 미만</code>의 범위를 나타낸다. 콜론 뒤쪽의 번호는 송신 측의 시퀀스 범위에 포함되지 않으므로 수신 측이 저 번호를 그대로 가져다 쓰는 것이다.</p><p>즉, 승인 번호는 <code>다음에 보내줘야하는 데이터의 시작점</code>을 의미한다는 것을 알 수 있다.</p><h3 id="Data-Offset"><a href="#Data-Offset" class="headerlink" title="Data Offset"></a>Data Offset</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-data-offset.png"><br>  <br><br></center><p>데이터 오프셋 필드에는 전체 세그먼트 중에서 헤더가 아닌 <code>데이터</code>가 시작되는 위치가 어디부터인지를 표시한다.</p><p>이 오프셋을 표기할 때는 <code>32비트 워드</code> 단위를 사용하며, 32 비트 체계에서의 <code>1 Word = 4 bytes</code>를 의미한다. 즉, 이 필드의 값에 4를 곱하면 세그먼트에서 헤더를 제외한 실제 데이터의 시작 위치를 알 수 있는 것이다.</p><p>이 필드에 할당된 4 bits로 표현할 수 있는 값의 범위는 <code>0000 ~ 1111</code>, 즉 <code>0 ~ 15 Word</code>이므로 기본적으로 <code>0 ~ 60 bytes</code>의 오프셋까지 표현할 수 있다. 하지만 옵션 필드를 제외한 나머지 필드는 필수로 존재해야 하기 때문에 최소 값은 20 bytes, 즉 <code>5 Word</code>로 고정되어 있다.</p><p>이 필드가 필요한 이유는, 밑에서 설명할 <code>옵션(Option)</code> 필드의 길이가 고정되어 있지 않기 때문이다.</p><h3 id="Reserved-3-bits"><a href="#Reserved-3-bits" class="headerlink" title="Reserved (3 bits)"></a>Reserved (3 bits)</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-reserved.png"><br>  <br><br></center><p>미래를 위해 예약된 필드로, 모두 <code>0</code>으로 채워져야 한다. 상단의 헤더 그림에도 그냥 <code>0 0 0</code>으로 찍혀있는 것을 확인해볼 수 있다.</p><h3 id="Flags-NS-FIN"><a href="#Flags-NS-FIN" class="headerlink" title="Flags (NS ~ FIN)"></a>Flags (NS ~ FIN)</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-flags.png"><br>  <br><br></center><p>9개의 비트 플래그이다. 이 플래그들은 현재 세그먼트의 속성을 나타낸다. 기존에는 6개의 플래그만을 사용했지만, 혼잡 제어 기능의 향상을 위해 <code>Reserved</code> 필드를 사용하여 <code>NS, CWR, ECE</code> 플래그가 추가되었다.</p><p>먼저 기존에 존재하던 플래그들의 의미는 다음과 같다.</p><table><thead><tr><th>필드</th><th>의미</th></tr></thead><tbody><tr><td>URG</td><td><code>Urgent Pointer(긴급 포인터)</code> 필드에 값이 채워져있음을 알리는 플래그. 이 포인터가 가리키는 긴급한 데이터는 높게 처리되어 먼저 처리된다. 요즘에는 많이 사용되지 않는다.</td></tr><tr><td>ACK</td><td><code>Acknowledgment(승인 번호)</code> 필드에 값이 채워져있음을 알리는 플래그. 이 플래그가 0이라면 승인 번호 필드 자체가 무시된다.</td></tr><tr><td>PSH</td><td><code>Push</code> 플래그. 수신 측에게 이 데이터를 최대한 빠르게 응용프로그램에게 전달해달라는 플래그이다. 이 플래그가 0이라면 수신 측은 자신의 버퍼가 다 채워질 때까지 기다린다. 즉, 이 플래그가 1이라면 이 세그먼트 이후에 더 이상 연결된 세그먼트가 없음을 의미하기도 한다.</td></tr><tr><td>RST</td><td><code>Reset</code> 플래그. 이미 연결이 확립되어 <code>ESTABLISHED</code> 상태인 상대방에게 연결을 강제로 리셋해달라는 요청의 의미이다.</td></tr><tr><td>SYN</td><td><code>Synchronize</code> 플래그. 상대방과 연결을 생성할 때, 시퀀스 번호의 동기화를 맞추기 위한 세그먼트임을 의미한다.</td></tr><tr><td>FIN</td><td><code>Finish</code> 플래그. 상대방과 연결을 종료하고 싶다는 요청인 세그먼트임을 의미한다.</td></tr></tbody></table><p>기존의 Reserved 필드를 사용하여 새롭게 추가된 <code>NS</code>, <code>CWR</code>, <code>ECE</code> 플래그는 네트워크의 <code>명시적 혼잡통보(Explicit Congestion Notification, ECN)</code>을 위한 플래그이다.</p><p>ECN을 사용하지 않던 기존의 네트워크 혼잡 상황 인지 방법은 타임아웃을 이용한 방법이었다. 그러나 처리 속도에 민감한 어플리케이션에서는 이런 대기 시간 조차 아깝기 때문에, 송신자와 수신자에게 네트워크의 혼잡 상황을 명시적으로 알리기 위한 특별한 매커니즘이 필요하게 되었는데, 이것이 바로 <code>ECN</code>이다.</p><p>이때 <code>CWR</code>, <code>ECE</code>, <code>ECT</code>, <code>CE</code> 플래그를 사용하여 상대방에게 혼잡 상태를 알려줄 수 있는데, 이 중 <code>CWR</code>, <code>ECE</code>는 TCP 헤더에 존재하고 <code>ECT</code>, <code>CE</code>는 IP 헤더에 존재한다.</p><table><thead><tr><th>필드</th><th>의미</th></tr></thead><tbody><tr><td>NS</td><td>ECN에서 사용하는 CWR, ECE 필드가 실수나 악의적으로 은폐되는 경우를 방어하기 위해 RFC 3540에서 추가된 필드</td></tr><tr><td>ECE</td><td><code>ECN Echo</code> 플래그. 해당 필드가 1이면서, SYN 플래그가 1일 때는 ECN을 사용한다고 상대방에게 알리는 의미. SYN 플래그가 0이라면 네트워크가 혼잡하니 세그먼트 윈도우의 크기를 줄여달라는 요청의 의미이다.</td></tr><tr><td>CWR</td><td>이미 ECE 플래그를 받아서, 전송하는 세그먼트 윈도우의 크기를 줄였다는 의미이다.</td></tr></tbody></table><p>ECN은 이 포스팅의 주제와는 또 다른 이야기이므로 궁금하신 분들은 MR.ZERO님의 <a href="https://mr-zero.tistory.com/20" target="_blank" rel="noopener">Explict Congestion Notification?</a> 블로그를 참고하길 바란다.</p><h3 id="Window-Size"><a href="#Window-Size" class="headerlink" title="Window Size"></a>Window Size</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-window-size.png"><br>  <br><br></center><p>윈도우 사이즈 필드에는 한번에 전송할 수 있는 데이터의 양을 의미하는 값을 담는다. $2^{16} = 65535$ 만큼의 값을 표현할 수 있고 단위는 바이트이므로, 윈도우의 최대 크기는 <code>64KB</code>라는 말이 된다.</p><p>하지만 이 최대 크기는 옛날 옛적에 생긴 기준이라 요즘같이 대용량 고속 통신 환경에는 맞지 않는 경우도 있다. 그래서 비트를 왼쪽으로 시프트하는 방식으로 윈도우 사이즈의 최대 크기를 키울 수 있는 방식도 사용하고 있으며, 몇 번 시프트할 지는 옵션 필드의 <code>WSCALE</code> 필드를 사용하여 표기한다.</p><h3 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-checksum.png"><br>  <br><br></center><p>체크섬은 데이터를 송신하는 중에 발생할 수 있는 오류를 검출하기 위한 값이다.</p><p>TCP의 체크섬은 전송할 데이터를 16 Bits씩 나눠서 차례대로 더해가는 방법으로 생성한다. 방식은 단순하지만 16 bits의 덧셈을 그대로 보자니 숫자가 너무 길어질 것이 뻔하므로 간단하게 반토막인 8 bits로만 한번 해보도록 하겠다.</p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  11010101</span><br><span class="line">+ 10110100</span><br><span class="line">-----------</span><br><span class="line"> 110001001</span><br></pre></td></tr></tbody></table></figure><p>앗, 8 bits인 두 수를 더 했더니 자리 수가 하나 올라가서 9 bits가 되었다. 이렇게 자리 수가 넘쳐버리면 체크섬 필드에 담을 수 없다.</p><p>이렇게 두 개의 수를 더했을 때 자리 수가 하나 올라간 부분을 <code>캐리(Carry)</code>라고 하는데, 계산 결과에서 이 부분만 떼어내서 다시 계산 결과에 더해주면 된다.</p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  10001001</span><br><span class="line">+        1 (방금 해에서 넘친 부분)</span><br><span class="line">-----------</span><br><span class="line">  10001010</span><br></pre></td></tr></tbody></table></figure><p>이런 방식을 <code>Warp Around</code>라고 한다. 이제 마지막 계산 결과에 <code>1의 보수</code>를 취해주면 체크섬이 된다. <code>1의 보수</code>라고 하면 뭐지 싶겠지만 그냥 비트를 반전하면 된다.</p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10001010</span><br><span class="line">01110101 (1의 보수를 취한 모습)</span><br></pre></td></tr></tbody></table></figure><p>이제 <code>01110101</code>이 이 데이터의 체크섬이 되는 것이다. 이 예제에서는 8 bits를 가지고 진행했기 때문에 8 bits짜리 체크섬이 나왔지만, 실제로는 16 bits 단위로 데이터를 잘라서 이 과정을 진행하기 때문에 16 bits인 체크섬 필드에 딱 들어맞는 이쁜 값이 나온다.</p><p>수신 측은 데이터를 받으면 위의 과정을 동일하게 거치되 1의 보수를 취하지 않은 값인 <code>10001010</code>까지만 만든 다음, 이 값과 송신 측이 보낸 체크섬을 더해서 모든 비트가 1이라면 이 데이터가 정상이라고 판단할 수 있다.</p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  10001010</span><br><span class="line">+ 01110101</span><br><span class="line">-----------</span><br><span class="line">  11111111</span><br></pre></td></tr></tbody></table></figure><p>만약 이 값에 0이 하나라도 있으면 송신 측이 보낸 데이터에 뭔가 변조가 있었음을 알 수 있다.</p><h3 id="Urgent-Pointer"><a href="#Urgent-Pointer" class="headerlink" title="Urgent Pointer"></a>Urgent Pointer</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-urgent.png"><br>  <br><br></center><p>말 그대로 긴급 포인터이다. URG 플래그가 1이라면 수신 측은 이 포인터가 가르키고 있는 데이터를 우선 처리한다.</p><h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-options.png"><br>  <br><br></center><p>옵션 필드는 TCP의 기능을 확장할 때 사용하는 필드들이며, 이 필드는 크기가 고정된 것이 아니라 가변적이다. 그래서 수신 측이 어디까지가 헤더고 어디서부터 데이터인지 알기 위해 위에서 설명한 데이터 오프셋 필드를 사용하는 것이다.</p><p>데이터 오프셋 필드는 <code>20 ~ 60 bytes</code>의 값을 표현할 수 있다고 했는데, 아무런 옵션도 사용하지 않은 헤더의 길이, 즉 Source Port 필드부터 Urgent Pointer 필드까지의 길이가 <code>20 bytes</code>이고, 옵션을 모두 사용했을 때 옵션 필드의 최대 길이가 <code>40 bytes</code>이기 때문이다.</p><p>만약 데이터 오프셋 필드의 값이 5, 즉 20 bytes보다 크지만 TCP의 옵션을 하나도 사용하고 있지 않다면, 초과한 bytes 만큼 이 필드를 0으로 채워줘야 수신 측이 헤더의 크기를 올바르게 측정할 수 있다.</p><p>대표적인 옵션으로는 윈도우 사이즈의 최대 값 표현을 확장할 수 있는 <code>WSCALE</code>, Selective Repeat 방식을 사용하기 위한 <code>SACK</code> 등이 있으며, 이외에도 거의 30개 정도의 옵션을 사용할 수 있기 때문에 이 친구들을 하나하나 설명하는 것은 조금 힘들 것 같다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이렇게 간략한 TCP의 개요와 헤더 구조에 대해서 알아보았다. 사실 이 내용들은 TCP라는 놈의 껍데기 한 겹 정도에 불과한 내용이지만, 이게 거의 50년 묵은 프로토콜이다보니 포스팅 하나로 정리하기에는 내용이 굉장히 방대하다.</p><p>서두에서 이야기 했듯이 TCP나 IP 같은 프로토콜은 소켓 프로그래밍이라도 하지 않는 이상 직접적으로 마주할 기회가 흔치 않은 것이 사실이다.</p><p>하지만 직접 마주하지 않더라도 필자는 매일 HTTP를 사용하는 웹 개발자이기 때문에, 자신이 매일 사용하는 프로토콜이 어떤 식으로 굴러가는 지 정도는 알고 있는 것이 좋다고 생각한다.</p><p>TCP가 커널에 어떻게 구현되어있는지 직접 확인해보고싶은 분은 깃허브에 올라가있는 리눅스 소스인 <a href="https://github.com/torvalds/linux/tree/master/net/ipv4" target="_blank" rel="noopener">linux/net/ipv4</a> 안에 있는 구현체들을 통해 확인해볼 수 있다.<small>(리눅스 소스 자체가 너무 커서 클론 받는 데 한 세월이라는 게 함정)</small></p><p>혹시 자신이 직접 TCP 통신 과정을 확인해보고 싶은 분은 간단한 <a href="https://github.com/evan-moon/simple-tcp-example" target="_blank" rel="noopener">TCP 예제 프로그램</a>과 <code>tcpdump</code>, <code>netstat</code> 등의 유틸리티를 통해 확인해볼 수 있다. <code>tcpdump</code>를 클라이언와 서버가 주고 받는 패킷의 내용을 확인해보고, <code>netstat</code>을 사용하여 클라이언트와 서버의 TCP 상태를 확인해볼 수도 있다.</p><p>다음 포스팅에서는 TCP의 핸드쉐이크나 흐름 제어, 혼잡 제어 기법에 대해서 한번 다뤄보도록 하겠다.</p><p>이상으로 TCP의 헤더에는 어떤 정보들이 담겨있는걸까? 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/11/10/header-of-tcp/#disqus_thread</comments>
    </item>
    
    <item>
      <title>수학과 함께 복잡한 문제를 단순하게 만들자!</title>
      <link>https://evan-moon.github.io/2019/10/30/make-simple-with-math/</link>
      <guid>https://evan-moon.github.io/2019/10/30/make-simple-with-math/</guid>
      <pubDate>Wed, 30 Oct 2019 13:38:26 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;최근 많은 IT 기업들이 개발자를 채용할 때 코딩 테스트를 시행하고 있다. 회사마다 어떤 스타일의 문제를 출제하는지 차이는 있지만, 대부분 간단한 알고리즘 풀이 또는 &lt;code&gt;Codility&lt;/code&gt;나 &lt;code&gt;프로그래머스&lt;/code&gt;와 같은 사이트처럼 실무에서 겪을 만한 상황을 살짝 섞어놓는 느낌의 문제를 선호하는 것 같다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>최근 많은 IT 기업들이 개발자를 채용할 때 코딩 테스트를 시행하고 있다. 회사마다 어떤 스타일의 문제를 출제하는지 차이는 있지만, 대부분 간단한 알고리즘 풀이 또는 <code>Codility</code>나 <code>프로그래머스</code>와 같은 사이트처럼 실무에서 겪을 만한 상황을 살짝 섞어놓는 느낌의 문제를 선호하는 것 같다.</p><a id="more"></a><p>이런 문제들의 특성 상 CS 기초와 문제 분석 능력, 직감 등을 다양하게 사용하여 해결해야 하기 때문에 단기간 연습한다고 실력이 확 느는 것은 아닌 것 같다.</p><p>이런 문제들은 우리에게 단순히 <code>너 이 알고리즘 알아?</code>라고 물어보는 것이 아니라 <code>어떤 방법을 사용해서 풀어볼래?</code>라고 물어본다.</p><p>사실 자료구조나 알고리즘 자체는 보면 공부하고 몇 번 구현해보면 어느 정도 숙달될 수 있지만, 이렇게 문제를 분석하고 단순화해서 적합한 방법을 선택할 수 있는 능력은 단순히 공부로 만들어 낼 수 있는 종류의 것은 아닌 것 같다.</p><p>필자는 최근 취업 준비를 하면서 이런 문제를 종종 풀어보고 있는데, 확실히 CS 기초도 부족하긴 하지만, 문제를 분석하고 좋은 방법을 선택할 수 있는 능력이 많이 부족함을 느꼈다.</p><p>그래서 자료구조나 알고리즘을 처음부터 다시 공부하면서, 동시에 문제 해결 능력을 기르기 위한 방법이 어떤 것이 있을지 고민해보기 시작했다.</p><h2 id="수학적인-사고-방식으로-문제를-단순화하자"><a href="#수학적인-사고-방식으로-문제를-단순화하자" class="headerlink" title="수학적인 사고 방식으로 문제를 단순화하자"></a>수학적인 사고 방식으로 문제를 단순화하자</h2><p>필자는 최근 면접에 거하게 털리고 나서 CS 기초나 자바스크립트 기초를 처음부터 다시 공부하기 시작했는데, 막상 이렇게 공부한 지식을 가지고 코딩 테스트 문제를 한번 풀어보려고 했더니, 생각처럼 잘 되지 않았다.</p><p>대부분 알고 있겠지만, 많은 코딩 테스트 문제은행 서비스에서는 문제를 해결하고 나면 다른 사람들은 이 문제를 어떤 방식으로 해결했는지도 함께 보여준다. 필자같은 경우는 사실 이게 궁금해서 문제를 푸는 것도 있는 것 같다.</p><p>그러던 와중에 대부분의 사람들이 완전탐색으로 풀었던 문제를 어떤 굇수 분이 단순한 산수 연산 몇 번으로 풀어내는 것을 본 적이 있었다.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/genius.jpg" width="350"><br>  <small>역시 세상은 넓고 굇수는 많다</small><br>  <br><br></center><p>당연히 필자도 해당 문제를 완전탐색으로 풀었고 그 방법 밖에 없을 것이라고 생각했지만, 그 굇수분은 문제의 패턴을 찾아내어 문제를 단순화 시킨 것이다.</p><p>물론 조금 난해한 감이 있어서 실무에서 사용하기에는 조금 이견이 갈릴 수 있는 코드이긴 했지만, 대부분의 사람들이 완전탐색으로 풀었던 복잡한 문제를 단순한 식 몇개로 풀어냈다는 사실이 충격이었다.</p><p>이때 필자가 느낀 점은, <code>수학적인 사고</code>에 대한 필요성이었다. 물론 알고리즘 역시 이런 수학적인 사고를 바탕으로 효율적인 해결 방식을 일반화한 것이긴 하지만, 필자가 원했던 것은 좀 더 근본적인 문제 해결 능력이었다.</p><p>물론 수학적인 사고라고 해서 문제를 읽고 막 복잡한 식을 세우는 것이 아니다. 자연어로 이루어진 문제를 분석하고, 해결 가능한 수준으로 나누고, 패턴을 찾아내는 과정 또한 수학적인 사고에서 비롯된다. 애초에 수학 자체가 복잡한 문제를 단순화하고 패턴을 찾아내어 일반화하는 학문이다.</p><p>그리고 <a href="/2019/07/17/programmer-with-math/" title="프로그래머는 수학을 잘해야할까?">프로그래머는 수학을 잘해야할까?</a> 포스팅에서 한번 이야기한 적 있지만, 필자가 이야기하고싶은 수학은 어려운 이론이나 공식을 말하는 것이 아니다.</p><p>개인적인 생각이기는 하지만, 필자는 <code>수의 성질</code>을 이해하는 것이 제일 중요하다고 생각했다. 예를 들면 홀수에 1을 더하면 짝수가 된다던가, 1부터 100까지의 합을 구할 때 <code>101 * 100 / 2</code>를 하면 된다던가와 같은 것들이 그렇다.</p><p>그런 이유로 최근 <a href="http://www.yes24.com/Product/goods/61791203" target="_blank" rel="noopener">프로그래머, 수학으로 생각하라</a>라는 책을 읽게 되었는데, 이 책의 초입부부터 재미있는 문제 해결 방법이 몇개 나와서 그 문제들과 해결 방법에 대해서 공유를 해볼까 한다.</p><h2 id="오늘로부터-100억일-후는-무슨-요일일까"><a href="#오늘로부터-100억일-후는-무슨-요일일까" class="headerlink" title="오늘로부터 100억일 후는 무슨 요일일까?"></a>오늘로부터 100억일 후는 무슨 요일일까?</h2><p>$n$일 후의 요일을 구하는 문제는 수학적인 사고를 필요로 하는 대표적인 문제 중 하나이다.</p><p>게다가 굳이 코딩 테스트까지 가지 않고 일상 속에서 비즈니스 로직만 만지고 있더라도 꽤나 자주 접할 수 있는 문제이다. 그래서 워밍업으로 상대적으로 익숙한 요일 구하기 문제를 먼저 살펴보려고 한다.</p><blockquote><p>필자가 이 글을 작성하고 있는 <code>2019년 10월 29일</code>은 <code>화요일</code>이다. 그럼 오늘로부터 100억일 후는 과연 무슨 요일일까?</p></blockquote><p>음, 단순하게 생각해보면… 오늘은 화요일이니까 1일 후는 수요일, 2일 후는 목요일과 같은 순차적인 방법으로 접근할 수도 있겠다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.time(<span class="hljs-string">'calc'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> week = [<span class="hljs-string">'일'</span>, <span class="hljs-string">'월'</span>, <span class="hljs-string">'화'</span>, <span class="hljs-string">'수'</span>, <span class="hljs-string">'목'</span>, <span class="hljs-string">'금'</span>, <span class="hljs-string">'토'</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> today = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> shift = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i <= <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>); i++) {</span><br><span class="line">  shift = i % week.length;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">today += shift;</span><br><span class="line"><span class="hljs-keyword">if</span> (today > week.length - <span class="hljs-number">1</span>) {</span><br><span class="line">  today -= week.length;</span><br><span class="line">}</span><br><span class="line"><span class="hljs-built_in">console</span>.log(week[today]);</span><br><span class="line"><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">'calc'</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">토</span><br><span class="line">calc: 60948.138ms</span><br></pre></td></tr></tbody></table></figure><p>아무리 요즘 컴퓨터가 연산 능력도 좋고 무보수로 일해주는 SCV라고 하지만 100억회를 반복하는 루프를 계산하게 하는 것은 너무나도 가혹한 처사이다. 이 알고리즘은 시간 복잡도가 $O(n)$이기에, 루프만 돌았을 뿐인데도 수행 시간이 1분이 넘는다.</p><p>이렇게 무식하게 풀어낼 수는 없으니, 다른 방법을 찾아야한다. 다행히 우리는 요일이 <code>7</code>일 마다 반복된다는 것을 알고 있다. 오늘이 화요일이라면 7일 후도 당연히 화요일이고, 14일 후도 화요일이다.</p><p>즉, 요일이 반복된다는 <code>주기성</code>이 존재한다는 것이다. <code>오늘부터 7의 배수만큼 지난 날은 무조건 화요일</code>이라는 패턴을 찾았다면 그 다음부터는 간단해진다.</p><p>어떤 수를 1씩 증가시켜가면서 계속 7로 나누면 <code>0~6</code>이 순차적으로 나타나는 주기성이 있으므로, 배수를 구할 때와 마찬가지로 <code>100억</code>을 <code>7</code>로 나누고 그 나머지를 확인하면 되기 때문이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.time(<span class="hljs-string">'calc'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> week = [<span class="hljs-string">'일'</span>, <span class="hljs-string">'월'</span>, <span class="hljs-string">'화'</span>, <span class="hljs-string">'수'</span>, <span class="hljs-string">'목'</span>, <span class="hljs-string">'금'</span>, <span class="hljs-string">'토'</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> today = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> shift = <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>) % week.length;</span><br><span class="line"></span><br><span class="line">today += shift;</span><br><span class="line"><span class="hljs-keyword">if</span> (today > week.length - <span class="hljs-number">1</span>) {</span><br><span class="line">  today -= week.length;</span><br><span class="line">}</span><br><span class="line"><span class="hljs-built_in">console</span>.log(week[today]);</span><br><span class="line"><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">'calc'</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">토</span><br><span class="line">calc: 0.156ms</span><br></pre></td></tr></tbody></table></figure><p>수행 시간이 <code>60000ms</code>에서 <code>0.156ms</code>로 줄었다. 이렇게 문제에서 주기성을 찾아내고, 나머지의 주기성과 연관지을 수만 있다면, 완전탐색을 하지 않고도 나머지를 사용하여 문제를 가볍게 풀 수 있다.</p><h3 id="10-100000000-일-후의-요일도-구해보자"><a href="#10-100000000-일-후의-요일도-구해보자" class="headerlink" title="$10^{100000000}$일 후의 요일도 구해보자"></a>$10^{100000000}$일 후의 요일도 구해보자</h3><p>자, 그럼 여기서 한번 더 나아가보자. 이런 방법으로 우리가 $10^{100000000}$일, 즉 <code>10의 1억승</code>일 이후의 요일도 구할 수 있을까? 10의 1억승을 뭐라고 부르는지는 모르겠지만, $10^{68}$이 무량대수라고 부르는 엄청 큰 숫자이니 쉽게 가늠이 안되는 수인 것은 분명하다.</p><p>당연히 $10^{100000000}$은 자바스크립트의 <code>Number.MAX_SAFE_INTEGER</code> 값을 아득히 넘어서는 숫자이기 때문에 위와 같은 방식으로는 계산이 불가능 하다. 여기서부터는 컴퓨터한테 계산을 맡기는 것보다는 문제를 단순화하고 주기성을 찾아내는 일이 더 중요해진다.</p><p>오늘은 <code>10월 29일 화요일</code>이니 오늘부터 $n$일 후의 요일을 쭉쭉 살펴보도록 하자. 방금 예제로 만들었던 로직을 활용하여 $10^{30}$일 이후까지 살펴보니, 대략 다음과 같은 패턴이 있다는 것을 알 수 있었다. 모든 결과를 적으면 너무 표가 길어지니, $10^{12}$일 이후의 결과만 기재하도록 하겠다.</p><table><thead><tr><th>일자</th><th>요일</th><th>인덱스</th></tr></thead><tbody><tr><td>$10^0$일 후</td><td>수</td><td>3</td></tr><tr><td>$10^1$일 후</td><td>금</td><td>5</td></tr><tr><td>$10^2$일 후</td><td>목</td><td>4</td></tr><tr><td>$10^3$일 후</td><td>월</td><td>1</td></tr><tr><td>$10^4$일 후</td><td>토</td><td>6</td></tr><tr><td>$10^5$일 후</td><td>일</td><td>0</td></tr><tr><td>$10^6$일 후</td><td>수</td><td>3</td></tr><tr><td>$10^7$일 후</td><td>금</td><td>5</td></tr><tr><td>$10^8$일 후</td><td>목</td><td>4</td></tr><tr><td>$10^9$일 후</td><td>월</td><td>1</td></tr><tr><td>$10^{10}$일 후</td><td>토</td><td>6</td></tr><tr><td>$10^{11}$일 후</td><td>일</td><td>0</td></tr><tr><td>$10^{12}$일 후</td><td>수</td><td>3</td></tr></tbody></table><p>필자는 이 과정에서 두 가지 정보를 얻을 수 있었다. 요일이 <code>수, 금, 목, 월, 토, 일</code>의 순서로 계속 반복되고 있다는 것과 오늘 요일인 <code>화요일</code>이 등장하지 않는다는 것이다.</p><p>즉, 10의 지수가 6 증가할 때마다 같은 요일이 돌아온다. 바꿔말하면 0의 개수가 6개씩 늘어날 때마다 같은 요일이 돌아온다는 말과 같다.</p><p>그렇다면 결국 10의 지수를 6으로 나눈 나머지 값을 사용하여 방금 전과 동일한 방법으로 요일을 구할 수 있다는 말이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> week = [<span class="hljs-string">'수'</span>, <span class="hljs-string">'금'</span>, <span class="hljs-string">'목'</span>, <span class="hljs-string">'월'</span>, <span class="hljs-string">'토'</span>, <span class="hljs-string">'일'</span>];</span><br><span class="line"><span class="hljs-keyword">const</span> exp = <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(week[exp % week.length]);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">토</span><br></pre></td></tr></tbody></table></figure><p>비록 $10^{100000000}$이라는 어마무시한 수를 컴퓨터가 담아낼 수 없기 때문에 직접 계산할 수는 없지만, 지수의 증가로 인한 요일의 주기를 파악함으로써 상상도 안가는 먼 미래의 요일을 구할 수 있게 되었다.<small>(사실 이걸 구하는 게 뭔 의미가 있겠냐만…)</small></p><p>만약 위에서 요일을 구했던 정직한 방법으로 이 문제를 풀려고 했다면 불가능했겠지만, 문제를 분석하고 주기성을 찾아냄으로써 어찌어찌 풀 수는 있었다.</p><h2 id="욕실-바닥에-타일-깔기"><a href="#욕실-바닥에-타일-깔기" class="headerlink" title="욕실 바닥에 타일 깔기"></a>욕실 바닥에 타일 깔기</h2><p>사실 방금 풀어보았던 요일 맞추기 문제처럼 눈에 띄게 일정한 주기를 가지고 반복되는 숫자를 찾아내는 문제는 익숙해지는데 그렇게 오랜 시간이 걸리지는 않는다.</p><p>그러나 우리가 일상에서 겪는 대부분의 문제는 저렇게 패턴을 대놓고 보여주지 않는 경우가 많다.</p><p>이때 필요한 것이 문제를 분석하고 패턴을 찾아내는 일이다. 사실 주기성이라는 수의 성질을 이용할 수 있다는 것의 진짜 의의는 바로 <code>패턴</code>을 만들고 찾아낼 수 있다는 것에 있다. 이번에는 그 패턴을 이용하여 유효성을 검사하는 문제이다.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/tile.png" width="500"><br>  <br><br></center><blockquote><p>에반은 타일 시공 업체에 취직해서 첫 욕실 바닥 시공을 하게 되었다.<br>그러나 에반은 실수로 가로 1cm, 세로 2cm의 직사각형 타일들만 챙겨나오게 되었다…</p><p>다행히 모든 욕실 바닥은 표준화가 되어있어서 가로 1cm, 세로 1cm의 정사각형 칸으로 이루어져있지만, 욕실 바닥 모양과 칸의 수는 모두 제각각이다.</p><p>에반은 자신의 직사각형 타일로 욕실 바닥을 빠짐없이 메꿔야하지만, 욕실 바닥의 모양에 따라 작업이 불가능한 곳도 있다.<br>게다가 에반은 힘이 없어서 타일을 반으로 쪼개서 사용할 수도 없다.</p><p>에반은 어떻게 작업의 가능 여부를 알 수 있을까?</p></blockquote><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> floor = [</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],</span><br><span class="line">];</span><br></pre></td></tr></tbody></table></figure><p>이 문제의 경우, 타일로 욕실 바닥을 채울 수 있는 경우의 수를 하나씩 검사해볼 수도 있겠지만, 그렇게 풀어내기에는 워낙 경우의 수가 많기도 하고 로직도 복잡해질 것이 뻔하다.</p><p>그렇다면 욕실 바닥에 있는 칸의 개수를 세어보면 어떨까? 만약 칸의 개수가 홀수라면 에반이 가진 타일로는 절대 바닥을 채울 수가 없을 것이다.</p><p>하지만 이 문제에 나와있는 바닥의 총 칸 수는 슬프게도 <code>34</code>칸이다. 게다가 홀수, 짝수 여부만으로는 해당 타일로 전부 바닥을 채울 수 있을지는 장담할 수 없다. 조금 더 확실한 검증 방법이 없을까?</p><p>이 문제는 주기성과 전혀 관련이 없을 것 같지만, 사실 굉장히 간단한 패턴이 숨어있다. 바로 에반이 가지고 있는 타일이 두개의 칸으로 이루어져 있다는 것이다.</p><p>조금 더 생각을 쉽게 하기 위해 타일과 바닥에 색을 칠해보도록 하자.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/tile-fill.png" width="500"><br>  <br><br></center><p>이렇게 색을 칠하고나니 에반이 가지고 있는 타일은 <code>검은색 1칸</code>과 <code>흰색 1칸</code>으로 이루어진 두 칸짜리 타일이 되었다. 즉, 만약 에반이 가지고 있는 타일로 욕실의 바닥을 빈틈없이 메꿀 수 있다면, 욕실 바닥의 검은색 칸의 수와 흰색 칸의 수가 같아야 한다는 것이다.</p><p>그러나 우리에게 주어진 욕실 바닥의 검은색 칸의 수는 <code>16</code>칸, 흰색 칸의 수는 <code>18</code>칸이다. 즉, 이 욕실 바닥은 에반이 가진 타일로는 채울 수 없는 바닥이라는 뜻이 된다.</p><p>이 문제는 단순히 두 칸으로 이루어진 에반의 타일에 <code>검은색</code>과 <code>흰색</code>이라는 주기성을 부여하여 풀어나가는 문제이다. 에반의 타일이 가지고 있는 색의 주기와 욕실 바닥의 주기가 동일하지 않다면 그 욕실 바닥은 <code>채울 수 없는 바닥</code>이 되는 것이다.</p><p>그럼 검은색 칸을 <code>-1</code>, 흰색 칸을 <code>1</code>으로 정의하고, 욕실 바닥의 해당 칸을 만날 때마다 <code>-1</code>과 <code>1</code>을 번갈아가며 더한 후 마지막에 값이 <code>0</code>이 되면 검은색 칸과 흰색 칸의 수가 동일하다고 생각할 수 있겠다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> floor = [</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],</span><br><span class="line">];</span><br><span class="line"><span class="hljs-keyword">const</span> tile = [<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> tileIndex = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">floor.forEach(<span class="hljs-function">(<span class="hljs-params">row, index</span>) =></span> {</span><br><span class="line">  tileIndex = <span class="hljs-built_in">Number</span>(index % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);</span><br><span class="line">  row.forEach(<span class="hljs-function"><span class="hljs-params">col</span> =></span> {</span><br><span class="line">    <span class="hljs-keyword">if</span> (col === <span class="hljs-number">1</span>) {</span><br><span class="line">      count += tile[tileIndex];</span><br><span class="line">    }</span><br><span class="line">    tileIndex = tileIndex === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;</span><br><span class="line">  });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`검은 타일과 흰 타일의 개수 차이는 <span class="hljs-subst">${<span class="hljs-built_in">Math</span>.abs(count)}</span> 입니다.`</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">검은 타일과 흰 타일의 개수 차이는 2 입니다.</span><br></pre></td></tr></tbody></table></figure><p>각 <code>row</code>를 순회할 때 <code>tileIndex</code>를 다시 교정해주는 이유는, 이 행렬의 컬럼의 개수가 짝수이기 때문이다. 타일의 주기 또한 짝수이기에 다음 줄에서는 이전 줄의 가장 마지막에 있던 타일의 색이 다시 한번 나오게 된다.<small>(컬럼을 홀수로 만들면 이 과정이 필요없는데, 문제 잘못 만들었다…)</small></p><p>문제만 보면 전혀 주기성과 관련이 없어보이는 문제였지만, 이렇게 문제 내에서 반복되는 패턴을 찾아내고 주기성을 부여함으로써 조금 더 간단한 방법으로 문제를 해결할 수 있다.</p><h2 id="한-붓-그리기-쾨니히스베르크의-다리-증명하기"><a href="#한-붓-그리기-쾨니히스베르크의-다리-증명하기" class="headerlink" title="한 붓 그리기, 쾨니히스베르크의 다리 증명하기"></a>한 붓 그리기, 쾨니히스베르크의 다리 증명하기</h2><p>쾨니히스베르크의 다리는 현대 위상 수학의 시작을 이끌었던 굉장히 유명한 문제로, 프로이센의 쾨니히스베르크<small>(현재 러시아 칼리닌그라드)</small>라는 도시에 있는 다리를 사용한 문제이다.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/Konigsberg_bridges.png" width="500"><br>  <br><br></center><blockquote><p>쾨니히스베르크의 한 가운데에는 프레골라 강이 흐르고 있고, 여기에는 가운데의 섬들과 연결되어있는 7개의 다리가 있다.</p><p>임의의 지점에서 출발하여 이 다리들을 한 번씩만 건너서 모든 다리를 건널 수 있을까?</p></blockquote><p>즉, 한 붓 그리기 문제인 것이다. 이 문제를 그대로 보면 생각하기가 어려우니, 조금 더 그림을 단순하게 그리고 각 지역에 식별자를 부여한 후, 문제의 조건들을 정리해보도록 하자.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/bridges.png" width="500"><br>  <br><br></center><blockquote><ul><li>임의의 지점에서 출발할 수 있다.</li><li>모든 다리를 건너야 한다.</li><li>한번 건넌 다리는 다시 건널 수 없다.</li><li>각 구역은 몇 번을 들리든 상관없다.</li><li>출발한 구역으로 다시 돌아와도 되고 안 돌아와도 상관없다.</li></ul></blockquote><p>사실 몇 번 펜으로 쭉쭉 그어보면 대충 불가능하다는 감이 온다. 하지만 <code>절대로 건널 수 없다</code>라는 결론을 내리기 위해서는 왜 불가능하다는 것인지 증명하는 과정이 필요하다. 혹시 방법이 있는데 단순히 못 찾을 것일수도 있으니 말이다.</p><p>우선 이 문제를 조금 더 쉽게 생각해보기 위해 복잡한 지도 모양의 그림이 아닌, 단순화된 그래프로 다시 그려보도록 하겠다.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/graph.png" width="150"><br>  <br><br></center><p>이때 그래프 내에서 A, B, C, D 구역의 역할을 하는 점을 <code>정점(Vertex)</code>이라고 하고, a~g 다리의 역할을 하는 선을 <code>간선(edge)</code>라고 하며, 각 정점에 붙어있는 간선의 개수를 <code>차수(Degree)</code>라고 한다.</p><p>쾨니히스베르크의 문제에서 다리를 건넌다는 것은 어떤 한 정점에서 다른 정점으로 넘어가는 것을 의미하며, 한번 건넌 다리는 다시 건널 수 없다는 것은 다른 정점으로 넘어갈 때 사용한 간선을 삭제해야한다는 것을 의미한다.</p><p>다리를 건너 이동할 수 있는 케이스를 한번 쭉 살펴보면 대략 <code>처음 출발할 때</code>, <code>마지막 도착할 때</code>, <code>통과할 때</code>의 3가지 케이스로 분류해볼 수 있는데, 이 3가지 케이스에서 간선이 삭제되는 개수에는 패턴이 숨어있다.</p><p><strong>처음 출발할 때</strong></p><center><br>  <img src="/2019/10/30/make-simple-with-math/start.png" width="500"><br>  <br><br></center><p>어느 정점에서 출발하던 다른 정점으로 이동하는 경우는 출구 역할을 하는 간선만 삭제될 것이다. 즉, 출발 정점의 차수가 <code>1</code> 줄어든다.</p><p><strong>마지막 도착할 때</strong></p><center><br>  <img src="/2019/10/30/make-simple-with-math/end.png" width="500"><br>  <br><br></center><p>출발할 때와는 반대로, 도착하는 정점은 입구의 역할을 했던 간선만 삭제하면 되므로, 해당 정점의 차수는 <code>1</code> 줄어든다.</p><p><strong>통과할 때</strong></p><center><br>  <img src="/2019/10/30/make-simple-with-math/cross.png" width="500"><br>  <br><br></center><p>통과할 때는 <code>입구</code>의 역할을 하는 간선과 <code>출구</code>의 역할을 하는 간선을 삭제해야하므로, 해당 정점의 차수가 <code>2</code>씩 줄어든다.</p><p>즉, 어떤 그래프에서 한 붓 그리기가 성공했다는 것은 정점을 순회하다가 더 이상 건널 수 있는 간선이 없어졌을 때, 반드시 <code>모든 정점의 차수가 0이어야 한다는 것</code>이다. 만약 차수가 0이 아닌 정점이 존재한다면 그 정점에는 아직 건너지 않았던 간선이 연결되어 있다는 말이 되므로 한 붓 그리기는 실패한 것이 된다.</p><p>이때 우리는 각 정점의 차수가 <code>1</code>이나 <code>2</code> 씩 줄어들고 있다는 점에서 이 문제를 풀 수 있는 힌트를 얻을 수 있다.</p><h3 id="차수의-홀짝-여부에-집중하자"><a href="#차수의-홀짝-여부에-집중하자" class="headerlink" title="차수의 홀짝 여부에 집중하자"></a>차수의 홀짝 여부에 집중하자</h3><p>차수가 1씩 줄어드는 경우는 한번 수행될 때마다 차수의 홀짝 여부가 변경되고, 2씩 줄어드는 경우는 차수의 홀짝 여부가 절대 변하지 않는다.</p><p>정점 차수의 홀짝 여부를 이야기하고 있는 이유는 바로 <code>0이 짝수</code>이기 때문이다.</p><p>즉, 정점에서 출발, 도착, 통과 시 변하는 차수의 홀짝 패턴을 파악하면 모든 경우의 수를 그려보지 않더라도 간단하게 이 그래프가 한 붓 그리기가 가능한 그래프인지 아닌지 알 수 있다.</p><h3 id="출발지와-도착지가-같은-경우"><a href="#출발지와-도착지가-같은-경우" class="headerlink" title="출발지와 도착지가 같은 경우"></a>출발지와 도착지가 같은 경우</h3><p>우선 위에서 살펴본 바와 같이 중간에 통과하는 정점의 차수는 무조건 2씩 줄어들기 때문에 몇 번을 통과하든 차수의 홀짝 여부가 절대 변하지 않는다.</p><p>즉, 어떤 방식으로 건너든 통과 정점의 차수가 0이 되려면, 해당 정점의 차수는 처음부터 <code>짝수</code>여야한다는 것이다.</p><p>만약 통과 정점의 차수가 홀수라면 반드시 마지막에는 차수가 1이 되고, 이 간선을 타고 해당 정점에 도착하게되면 더 이상 남아있는 간선이 없기 때문에 다른 정점으로 건너갈 수 없게 된다.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/cant-get-out.jpg" width="350"><br>  <small>차수가 홀수인 통과 정점에 들어서면 맘대로 나갈 수 없다</small><br>  <br><br></center><p>또한 출발지와 목적지가 같은 경우에는 맨 처음 출발할 때 출발 정점의 차수를 <code>1</code> 줄이고 도착할 때 다시 <code>1</code>을 줄여야하기 때문에 해당 정점의 차수가 총 <code>2</code>만큼 줄어들게 된다.</p><p>이 경우에도 출발 정점의 차수는 홀짝 여부가 변경될 수 없기 때문에 반드시 처음부터 짝수인 차수를 가지고 있어야 한다는 말이 된다. 즉, 출발지와 도착지가 같은 경우 한 붓 그리기가 성공하려면 <code>모든 정점의 차수가 짝수</code>여야 한다는 결론이 나온다.</p><h3 id="출발지와-도착지가-다른-경우"><a href="#출발지와-도착지가-다른-경우" class="headerlink" title="출발지와 도착지가 다른 경우"></a>출발지와 도착지가 다른 경우</h3><p>출발지와 도착지가 다른 경우에도 통과 정점의 차수는 처음부터 짝수여야 한다는 점은 달라지지 않지만, 이번에는 출발지와 도착지가 다르기 때문에 출발 정점과 도착 정점의 차수는 반드시 <code>홀수</code>여야 한다는 점이 다르다.</p><p>중간에 통과하는 정점은 반드시 차수가 <code>2</code> 씩 줄어들기 때문에 홀짝이 변하지 않지만, 출발과 도착 시에는 차수가 <code>1</code>만 줄어들기 때문에 홀짝 여부가 변하기 때문이다.</p><p>즉, 출발지와 도착지가 다른 경우는 <code>출발지와 도착지는 홀수 차수, 그 외 정점은 짝수</code>여야한다.</p><h3 id="쾨니히스베르크의-다리는-왜-한-붓-그리기가-불가능할까"><a href="#쾨니히스베르크의-다리는-왜-한-붓-그리기가-불가능할까" class="headerlink" title="쾨니히스베르크의 다리는 왜 한 붓 그리기가 불가능할까?"></a>쾨니히스베르크의 다리는 왜 한 붓 그리기가 불가능할까?</h3><p>이 두 가지 조건을 정리해보자면 그래프의 정점을 순회하며 한 붓 그리기가 가능한 경우는 <code>모든 정점이 짝수 차수를 가지고 있거나 홀수 차수가 2개인 경우</code>라고 정리해볼 수 있다. 다시 쾨니히스베르크의 다리를 도식화한 그래프를 살펴보고 이 조건에 맞아떨어지는지 확인해보자.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/graph.png" width="150"><br>  <br><br></center><p>이 그래프의 정점들의 차수를 정리해보면 <code>A=3, B=5, C=3, D=3</code>으로 모든 정점의 차수가 홀수이므로, 위에서 찾아낸 어떤 조건과도 맞지 않는다.</p><p>즉, 쾨니히스베르크의 다리는 한 붓 그리기가 불가능한 구조라는 것이 증명된 것이다.</p><p>그래프 이론에서 이렇게 한 붓 그리기, 즉, 그래프의 모든 경로를 단 한 번씩만 통과하는 경로를 <code>오일러 경로(Eulerian Trail)</code>라고 부르는데, 그 이유는 갓 레온하르트 오일러 형님이 이미 1735년에 이 문제를 증명하고 자기 논문에 써먹었기 때문이다.</p><p>해당 논문은 <a href="http://eulerarchive.maa.org//docs/originals/E053.pdf" target="_blank" rel="noopener">Solutio Problematis ad Geometriam Situs Pertinentis</a>에서 확인할 수 있지만… 제목에서도 느껴지듯이 이게 영어가 아니다. 이 시대의 가방끈 기신 분들이 작성한 논문이 다들 그러하듯 <code>라틴어</code>로 작성되어있기 때문에 읽어보는 건 사실 힘들다. 그래도 혹시 필자의 상상을 뛰어넘어 라틴어가 가능하신 굇수분들이 있을 수 있으니 일단 첨부하겠다.</p><p>어쨌든 오일러 형님의 문제 풀이에서 주목해야하는 아이디어는 각 정점의 차수를 조사할 때 차수 자체가 아닌 <code>수의 홀짝</code>에 주목했다는 점이다. 정점에서 출발할 때, 도착할 때, 통과할 때 정점이 가진 차수의 상태가 홀짝으로 변화하는 그 패턴을 파악하지 못했다면 이 문제를 해결하기는 힘들었을 것이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번 포스팅에서 살펴본 3개의 문제는 어려운 수학 공식을 사용하는 문제가 아니다.</p><p>7일마다 반복되는 패턴에서 착안하여 $10^{100000000}$일 후의 요일도 뭔가 패턴이 있을 것이라는 추론, 두 칸짜리 타일을 보고 검은색과 흰색이 반복되는 패턴을 떠올릴 수 있는 것, 그래프 순회의 모든 경우의 수를 따져보지 않고 각 정점의 차수가 홀짝으로 변화하는 패턴을 생각해낼 수 있는 것 등은 복잡한 수학 공식을 모르더라도 수의 성질만 알고 있다면 누구든지 접근할 수 있는 문제 해결 방식이다.</p><p>이렇게 수의 근본적인 성질을 파악하고 이용하면 복잡한 문제를 단순하게 풀 수 있다. 슬픈 점은 이게 단순히 공부로 얻어질 수 있는 능력이 아니라는 것이다. 이런 능력을 키우기 위해서는, 그냥 이렇게 생각하는 연습을 많이 해야하는 것 같다.</p><p>코딩 테스트를 많이 풀어보는 것도 물론 좋지만, 일상 속에서 겪는 다양한 문제들 속에서 이렇게 패턴을 찾아내고 분석해보는 것도 나름 도움이 되지 않을까? 예를 들면 친구가 <code>11월 10일</code>에 약속을 잡자고 했는데, 그때가 무슨 요일인지 핸드폰으로 확인하는 것이 아니라 한번 직접 계산해본다던가 하는 식으로 말이다.</p><p>이상으로 수학과 함께 복잡한 문제를 단순하게 만들자! 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/10/30/make-simple-with-math/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[JS 프로토타입] 프로토타입을 사용하여 상속하기</title>
      <link>https://evan-moon.github.io/2019/10/27/inheritance-with-prototype/</link>
      <guid>https://evan-moon.github.io/2019/10/27/inheritance-with-prototype/</guid>
      <pubDate>Sat, 26 Oct 2019 15:55:05 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;이번 포스팅에서는 &lt;a href=&quot;/2019/10/23/js-prototype/&quot; title=&quot;이전 포스팅&quot;&gt;이전 포스팅&lt;/a&gt;에 이어, 프로토타입을 사용한 다양한 상속 패턴에 대한 이야기를 해볼까 한다.&lt;/p&gt;
&lt;p&gt;사실 자바스크립트에는 상속이나 캡슐화와 같은 개념이 명시적으로 존재하지는 않기 때문에 자바나 C++ 같은 클래스 기반 언어를 사용하던 개발자들은 자바스크립트에 클래스가 없다는 사실에 혼란스러워한다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>이번 포스팅에서는 <a href="/2019/10/23/js-prototype/" title="이전 포스팅">이전 포스팅</a>에 이어, 프로토타입을 사용한 다양한 상속 패턴에 대한 이야기를 해볼까 한다.</p><p>사실 자바스크립트에는 상속이나 캡슐화와 같은 개념이 명시적으로 존재하지는 않기 때문에 자바나 C++ 같은 클래스 기반 언어를 사용하던 개발자들은 자바스크립트에 클래스가 없다는 사실에 혼란스러워한다.</p><a id="more"></a><p>즉, 자바스크립트에서의 상속이나 캡슐화 등은 <code>OOP(객체지향프로그래밍)</code>에 익숙한 개발자들이 자바스크립트에서도 이런 개념들을 가져다 사용하기 위해 프토토타입을 사용하여 이를 유사하게 구현한 일종의 디자인 패턴이라고 할 수 있다.</p><p>자바스크립트에서의 상속은 프로토타입 체인을 사용하여 구현하고, 캡슐화는 클로저를 사용해서 구현하게 되는데, 이번 포스팅에서는 이 중 프로토타입을 사용한 상속 패턴에 집중해서 설명해볼까 한다.</p><h2 id="프로퍼티와-메소드는-원본-객체를-통해-공유될-수-있다"><a href="#프로퍼티와-메소드는-원본-객체를-통해-공유될-수-있다" class="headerlink" title="프로퍼티와 메소드는 원본 객체를 통해 공유될 수 있다"></a>프로퍼티와 메소드는 원본 객체를 통해 공유될 수 있다</h2><p>객체의 상속을 알아보기 전에 객체를 생성할 때 프로퍼티와 메소드를 부여하는 방법에 대해서 알아보도록 하자. <a href="/2019/10/23/js-prototype/" title="이전 포스팅">이전 포스팅</a>에서 필자는 자바스크립트는 클래스가 아닌 <code>함수</code>를 사용하여 객체를 생성한다고 이야기 했었다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params"></span>) </span>{}</span><br><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br></pre></td></tr></tbody></table></figure><p>이때 <code>User</code> 함수를 생성자로 호출하면서 생성된 <code>evan</code> 객체는 <code>User.prototype</code> 객체를 원본 객체로 하여 복제된 객체이다.</p><p>이때 두 가지 방법을 사용하여 새롭게 생성되는 객체들에게 프로퍼티나 메소드를 부여할 수 있는데, 첫 번째는 생성자 함수 내에서 <code>this</code>를 사용하여 선언하는 방법, 두 번째는 새롭게 생성되는 객체들이 복사할 원본 객체인 <code>프로토타입 객체</code>에 선언하는 방법이다.</p><p>먼저, <code>this</code>를 사용하여 프로퍼티나 메소드를 정의하는 방법에 대해서 살펴보자.</p><h3 id="생성자-함수-내에서-this를-사용하는-방법"><a href="#생성자-함수-내에서-this를-사용하는-방법" class="headerlink" title="생성자 함수 내에서 this를 사용하는 방법"></a>생성자 함수 내에서 this를 사용하는 방법</h3><p>자바스크립트도 생성자 역할을 하는 함수 내에서 <code>this</code>를 사용하여 다른 언어와 비슷한 느낌으로 객체들에게 프로퍼티나 메소드를 부여할 수 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params">name</span>) </span>{</span><br><span class="line"><span class="hljs-meta">  'use strict'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.say());</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></tbody></table></figure><p>참고로 생성자 함수 내에서 <code>strict</code> 모드를 사용한 이유는, 해당 생성자 함수가 실수로 <code>new</code> 예약어 없이 호출되어 <code>this</code>가 전역 객체로 평가되는 불상사를 방어하기 위해서이다.<small>(이 내용은 프로토타입과는 관련이 없기 때문에 자세히 다루지는 않겠다)</small></p><p>이 방법은 일반적인 생성자의 사용 방법과 비슷해서 직관적으로 이해가 되는 편이다. 이때 생성자 함수 안의 <code>this</code>는 새롭게 생성된 객체를 의미하기 때문에, 함수 내에서 <code>this</code>를 통해 정의한 프로퍼티나 메소드는 이 생성자 함수를 사용하여 객체가 생성될 때마다 새롭게 정의된다.</p><p>무슨 말인지 조금 더 쉽게 알아보기 위해 생성자 함수를 통해 두 개의 새로운 객체를 생성하고, 이 객체들의 메소드를 비교해도록 하자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.say === john.say);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>생성자 함수가 호출될 때 <code>this</code>는 각각 <code>evan</code> 객체와 <code>john</code> 객체를 의미했을 것이고, <code>say</code> 메소드 또한 이 객체들에게 직접 할당되었을 것이다. 자바스크립트의 <code>완전할당연산자(===)</code>는 다른 메모리에 적재된 객체는 다르다고 평가하므로 이 두 객체의 메소드들은 각자 다른 메모리에 담긴, 전혀 다른 함수라고 할 수 있다.</p><p>이때 <code>evan</code> 객체나 <code>john</code> 객체를 출력해보면, 객체 내부에 <code>say</code> 메소드가 정의되어 있는 모습 또한 확인해볼 수 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(evan);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User {<span class="hljs-attr">say</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>}</span></span><br></pre></td></tr></tbody></table></figure><p>이 당연한 이야기를 하는 이유는 바로 밑에서 후술할 <code>프로토타입 객체에 정의하는 방법</code>과 차이점을 분명히 하기 위해서이다. 프로토타입 객체를 사용해서 프로퍼티나 메소드를 정의하게되면 지금과는 전혀 다른 결과가 나온다.</p><h3 id="프로토타입-객체에-정의하는-방법"><a href="#프로토타입-객체에-정의하는-방법" class="headerlink" title="프로토타입 객체에 정의하는 방법"></a>프로토타입 객체에 정의하는 방법</h3><p>이번에는 <code>User</code> 생성자 함수의 프로토타입 객체인 <code>User.prototype</code>을 사용하여 메소드를 한번 정의해보도록 하자. <code>this</code>를 통해서 정의하는 방법과 어떤 차이가 있을까?</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params">name</span>) </span>{}</span><br><span class="line">User.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.say());</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></tbody></table></figure><p>일단 <code>this</code>를 사용하여 정의했던 메소드와 동일한 느낌으로 작동하고 있다. 그래서 동일한 동작이라고 생각할 수도 있지만, 사실 두 방법들 사이에는 중요한 차이가 존재한다.</p><p>바로 생성자 함수를 통해 생성된 모든 객체들이 해당 메소드를 <code>공유하고 있냐, 없냐</code>의 차이이다. 이전과 마찬가지로 두 개의 객체를 생성하고, 두 객체의 메소드를 비교해보자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.say === john.say);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">true</span></span><br></pre></td></tr></tbody></table></figure><p>음? 이번에는 아까와는 다르게 두 객체의 메소드가 같다고 한다. 방금 전과는 다르게 이번에는 <code>evan.say</code>와 <code>john.say</code>가 객체에 따로따로 정의된 메소드가 아닌, 원본 객체의 메소드를 공유하고 있는 상황이기 때문이다.</p><p>생성된 <code>evan</code> 객체를 한번 콘솔에 출력해보면, 원본 객체의 프로퍼티나 메소드를 공유하고 있다는 말이 무엇인지 알 수 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(evan);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User {}</span><br></pre></td></tr></tbody></table></figure><p><code>evan</code> 객체를 출력해보니, 이 객체는 아무 메소드나 프로퍼티도 가지고 있지 않고 텅 비어있는 친구다.</p><p>즉, 생성자 함수 내에서 <code>this</code>를 사용하지 않고, 원본 객체에 메소드나 프로퍼티를 정의하게 되면 객체들에게는 해당 프로퍼티가 없고, 원본 객체의 프로퍼티나 메소드를 참조한다는 것이다.</p><p>이 특징을 제대로 인지하지 못하면 이런 상황도 발생할 수 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User.prototype.name = <span class="hljs-string">'Evan'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.name);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(john.name);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Evan</span><br><span class="line">Evan</span><br></pre></td></tr></tbody></table></figure><p>그렇기 때문에 각 객체마다 고유한 프로퍼티를 부여하고 싶다면 원본 객체에 정의하는 것이 아니라, 생성자 함수 내에서 <code>this</code>를 사용하여 정의해야한다. 다시 말하지만 원본 객체에 정의한 프로퍼티나 메소드는 생성된 객체들 끼리 <code>공유</code>된다.</p><p>한 가지 이상한 점은, 분명히 <code>evan</code> 객체에는 아무런 프로퍼티나 메소드도 없었는데, 필자는 분명히 <code>evan.say</code>를 통해 해당 메소드에 접근할 수 있었다는 것이다. 어떻게 이런 일이 가능한 것일까?</p><h2 id="프로토타입-룩업"><a href="#프로토타입-룩업" class="headerlink" title="프로토타입 룩업"></a>프로토타입 룩업</h2><p>그 질문에 대한 해답은 바로 자바스크립트가 객체 내에서 프로퍼티를 찾는 방법 중 하나인 <code>프로토타입 룩업(Prototype Lookup)</code>에서 알아볼 수 있다. 방금 전 자바스크립트가 <code>evan</code> 객체에서 <code>say</code> 메소드를 찾아냈던 과정은 다음과 같다.</p><center><br>  <img src="/2019/10/27/inheritance-with-prototype/prototype_lookup.png" width="500"><br>  <br><br></center><blockquote><ol><li><code>evan.say</code>로 접근 시도</li><li>어, <code>say</code> 프로퍼티가 없네? <code>__proto__</code>를 통해 원본 객체로 올라가보자!</li><li><code>User.prototype</code>객체야, 너는 <code>say</code> 프로퍼티 가지고 있니?</li><li>있네? Profit!</li></ol></blockquote><p>이런 식으로 우리가 어떤 객체의 프로퍼티에 접근을 시도했을 때, 자바스크립트는 먼저 그 객체가 해당 프로퍼티를 가지고 있는지를 확인하고, 해당 프로퍼티가 없다면 그 객체의 원본 객체로 거슬러 올라가서 다시 확인하게 된다.</p><p>이 집요한 확인 과정은 모든 객체의 조상인 <code>Object.prototype</code>에 다다를 때까지 계속되고, 만약 여기에도 존재하지 않는 프로퍼티라면 그때서야 <code>undefined</code>를 반환하게 된다.</p><p>이 말인 즉슨, 모든 객체는 자신의 프로토타입 체인 내에 있는 모든 원본 객체들의 프로퍼티나 메소드에 접근할 수 있다는 뜻이다.</p><p>쉽게 말해, 방금 생성한 <code>evan</code> 객체는 아무 프로퍼티나 메소드도 가지고 있지 않지만, 자신의 원본 객체인 <code>User.prorotype</code>에 정의된 <code>say</code> 메소드도 사용할 수 있고, <code>Object.prototype</code>에 있는 <code>toString</code>이나 <code>hasOwnProperty</code>와 같은 메소드도 사용할 수 있다는 것이다.</p><center><br>  <img src="/2019/10/27/inheritance-with-prototype/prototype_lookup2.png" width="150"><br>  <small>evan 객체는 프토토타입 체인 내에 있는 모든 원본 객체의 프로퍼티를 공유받는다</small><br>  <br><br></center><p>이 프로토타입 룩업 과정은 객체의 프로퍼티나 메소드에 접근하는 그 순간마다 수행되기 때문에, 클래스가 정의될 때 모든 상속관계가 함께 평가되는 클래스 기반 언어의 상속과는 조금 다른 느낌이다.</p><p>그러나 추상적으로 생각해보면 원본 객체(부모)의 속성을 물려받고 있다는 점에서 착안하여, 프로토타입 룩업을 토대로 상속을 구현할 수 있다.</p><h2 id="프로토타입을-사용한-상속"><a href="#프로토타입을-사용한-상속" class="headerlink" title="프로토타입을 사용한 상속"></a>프로토타입을 사용한 상속</h2><p>자바스크립트에서 프로토타입을 사용하여 상속을 구현하는 방법은 크게 <code>Object.create</code> 메소드를 사용하는 방법과 이 메소드를 사용하지않는 <small>(더러운)</small> 방법, 두 가지로 나누어질 수 있다.</p><p>사실 <code>Object.create</code>만 사용해도 프로토타입을 사용한 상속은 충분히 구현이 가능하다. 하지만 굳이 두 가지를 나눠서 이야기한 이유는, <code>Object.create</code> 메소드가 <code>Internet Explorer 9</code>부터 지원이 되기 때문이다.</p><p>하지만 필자는 필자의 행복을 위해 쓰는 포스팅에서 <code>IE 8</code> 이하 환경에 대한 자세한 이야기는 별로 하고 싶지 않으므로 <code>Object.create</code>를 사용하지 않는 방법에 대한 코드를 간단하게 <a href="https://gist.github.com/evan-moon/a7e5a51e20d22016ea443a03480765b7" target="_blank" rel="noopener">필자의 Github Gist 링크</a>로 첨부하겠다.</p><h3 id="Object-create를-사용하자"><a href="#Object-create를-사용하자" class="headerlink" title="Object.create를 사용하자"></a>Object.create를 사용하자</h3><p><code>Object.create</code> 메소드는 첫 번째 인자로 생성할 객체의 원본 객체가 될 객체, 두 번째 인자로 새로 생성할 객체에 추가할 프로퍼티를 객체 타입으로 받는다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Object</span>.create(proto: <span class="hljs-built_in">Object</span>, properties?: <span class="hljs-built_in">Object</span>);</span><br></pre></td></tr></tbody></table></figure><p>이때 두 번째 인자는 선택사항이며, 단순하게 <code>{ test: 1 }</code>처럼 넘기는 것이 아니라, <code>Object.defineProperties</code> 메소드를 사용할 때 처럼 데이터 서술자와 접근 서술자를 지정해줘야한다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Object</span>.create(User.prototype, {</span><br><span class="line">  foo: {</span><br><span class="line">    configurable: <span class="hljs-literal">false</span>,</span><br><span class="line">    enumerable: <span class="hljs-literal">true</span>,</span><br><span class="line">    value: <span class="hljs-string">'I am Foo!'</span>,</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>자세한 프로퍼티들의 의미는 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener">MDN Web Docs: Object.defineProperties</a>에서 확인해보도록 하자.</p><p>이 메소드에서 중요한 포인트는 <code>객체의 프로토타입 객체</code>를 지정할 수 있다는 것이며, 이 말인 즉슨 객체의 프로토타입 체인을 내 맘대로 만져줄 수 있다는 것이다. 심지어 동적으로 변경도 가능하다.<small>(사실 이게 JS의 변태적인 면…)</small></p><p>그럼 이제 <code>Object.create</code> 메소드와 프로토타입을 사용하여 상속을 한번 구현해보도록 하자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperClass</span> (<span class="hljs-params">name</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">}</span><br><span class="line">SuperClass.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>`</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>우선 부모 클래스 역할을 할 <code>SuperClass</code> 생성자 함수를 생성하고, 이 함수의 프로토타입 객체에 <code>say</code> 메소드를 정의했다. 그럼 이제 자식 클래스 역할을 할 생성자 함수를 구현하고, 이 두 개의 함수의 상속 관계도 함께 정의해보자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubClass</span> (<span class="hljs-params">name</span>) </span>{</span><br><span class="line">  SuperClass.call(<span class="hljs-keyword">this</span>, name);</span><br><span class="line">}</span><br><span class="line">SubClass.prototype = <span class="hljs-built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line">SubClass.prototype.constructor = SubClass;</span><br><span class="line">SubClass.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span> is running`</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>뭘 이것저것 많이 만진 것 같지만, 막상 하나하나 뜯어보면 별 거 없다.</p><p><strong>SuperClass.call(this)</strong><br><code>Function.prototype.call</code> 메소드는 호출된 함수의 실행 컨텍스트를 첫 번째 인자로 받은 녀석으로 변경한다. 즉, <code>this</code>의 타겟을 변경하는 것이다.</p><p>즉, <code>SuperClass.call(this, name)</code>의 의미는 부모 생성자 함수의 생성자를 호출하되, 실행 컨텍스트를 자식 생성자 함수로 변경하라는 의미이다. 자바로 치면 <code>super</code> 메소드를 호출하는 것과 비슷한 느낌이랄까.</p><p>필자는 이때 <code>call</code> 메소드를 사용했지만, 뭐가 됐든 부모 생성자 함수의 실행 컨텍스트만 변경해주면 장땡이기 때문에 <code>apply</code>나 <code>bind</code> 메소드를 사용해도 상관없다.</p><p><strong>SubClass.prototype 변경</strong><br>그 후 <code>Object.create</code> 메소드를 사용하여 <code>SuperClass.prototype</code> 객체를 원본 객체로 하는 새로운 객체를 생성하고, 이 객체를 <code>SubClass</code>의 프로토타입 객체로 할당해준다. 자식 생성자 함수의 프로토타입 객체와 부모 생성자 함수의 프로토타입 객체 간의 프로토타입 체인, 쉽게 말해 부모 자식 관계를 만들어 주는 것이다.</p><p><strong>SubClass.prorotype.constructor 변경</strong><br>우리는 부모 생성자 함수의 프로토타입 객체를 토씨 하나 안바꾸고 그대로 복제했기 때문에, 새롭게 생성한 자식 생성자 함수의 프로토타입 객체의  <code>constructor</code> 프로퍼티는 여전히 부모 생성자 함수인 <code>SuperClass</code>를 참조하고 있다.</p><p>하지만 자식 생성자 함수인 <code>SubClass</code>를 통해 생성된 객체가 <code>SuperClass</code>를 사용하여 생성된 것처럼 처리되면 안되므로, 다시 <code>constructor</code> 프로퍼티를 <code>SubClass</code>로 변경해줘야한다.</p><p>이런 과정들을 거치면 다음과 같은 관계가 성립된다.</p><center><br>  <img src="/2019/10/27/inheritance-with-prototype/extends.png" width="500"><br>  <br><br></center><p>이제 한번 <code>SubClass</code> 생성자 함수를 사용하여 객체를 생성해보고, 제대로 부모 생성자 함수의 속성들을 물려받았는지 확인해보자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> SubClass(<span class="hljs-string">'Evan'</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.__proto__);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.__proto__.__proto__)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubClass { <span class="hljs-attr">name</span>: <span class="hljs-string">'Evan'</span> } <span class="hljs-comment">// 에반 객체</span></span><br><span class="line">SubClass { <span class="hljs-attr">constructor</span>: [<span class="hljs-built_in">Function</span>: SubClass], <span class="hljs-attr">run</span>: [<span class="hljs-built_in">Function</span>] } <span class="hljs-comment">// 에반 객체의 원본 객체</span></span><br><span class="line">SuperClass { <span class="hljs-attr">say</span>: [<span class="hljs-built_in">Function</span>] } <span class="hljs-comment">// 에반 객체의 원본 객체의 원본 객체</span></span><br></pre></td></tr></tbody></table></figure><p><code>evan</code> 객체는 <code>SubClass</code>의 프로토타입 객체를 복제해서 정상적으로 생성되었고, <code>evan</code> 객체의 원본 객체와 원본 객체의 원본 객체도 잘 체이닝되어있다.</p><p>즉, <code>evan -> SubClass.prototype -> SuperClass.prototype</code>으로 이어지는 프로토타입 체인이 완성된 것이다. 이때 <code>evan</code> 객체의 <code>run</code>이나 <code>say</code> 메소드를 호출하면, 위에서 언급한 프로토타입 룩업을 통해 원본 객체의 메소드를 호출할 수 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p><a href="/2019/10/23/js-prototype/" title="이전 포스팅">이전 포스팅</a>에 이어 이번에는 자바스크립트에서 프로토타입을 활용한 상속 패턴에 대한 내용을 한번 다뤄보았다.</p><p>솔직히 말해서, 필자가 실무에서 이러한 패턴을 사용해서 상속을 구현해본 경험은 거의 없다. 필자가 개발자로 일을 시작하고 얼마 되지 않아 ES6가 나오기도 했었고, 필자는 당시 자바가 더 익숙했기 때문에 새로 추가된 <code>class</code> 키워드에 흠뻑 빠져있었다.</p><p>하지만 일을 시작하고 몇 년이 지나면서 레거시 코드에서 이 상속 패턴을 꽤 마주치기도 했고, 면접에서 이런 패턴에 대해서 물어보는 경우도 있었기 때문에 확실히 공부할 필요는 있는 것 같다.</p><p>아무리 요즘 ES5를 거의 사용하지 않는다고 하지만, 사실 이런 상속 패턴이 자바스크립트를 사용한 프로그램 아키텍처의 근간이기도 하니 말이다.</p><p>이상으로 프로토타입을 사용하여 상속하기 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/10/27/inheritance-with-prototype/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[JS 프로토타입] 자바스크립트의 프로토타입 훑어보기</title>
      <link>https://evan-moon.github.io/2019/10/23/js-prototype/</link>
      <guid>https://evan-moon.github.io/2019/10/23/js-prototype/</guid>
      <pubDate>Wed, 23 Oct 2019 12:29:01 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;이번 포스팅에서는 자바스크립트(JavaScript)하면 빠질 수 없는 &lt;code&gt;프로토타입(Prototype)&lt;/code&gt;에 대해서 한번 이야기해보려고 한다.&lt;/p&gt;
&lt;p&gt;프로토타입은 자바스크립트를 ES5 시절부터 사용해오던 분들에게는 매우 익숙하지만 ES6부터 시작하신 분들은 대부분 클래스를 사용하기 때문에 익숙한 개념은 아닐 것이라고 생각한다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>이번 포스팅에서는 자바스크립트(JavaScript)하면 빠질 수 없는 <code>프로토타입(Prototype)</code>에 대해서 한번 이야기해보려고 한다.</p><p>프로토타입은 자바스크립트를 ES5 시절부터 사용해오던 분들에게는 매우 익숙하지만 ES6부터 시작하신 분들은 대부분 클래스를 사용하기 때문에 익숙한 개념은 아닐 것이라고 생각한다.</p><a id="more"></a><p>필자가 처음 프론트엔드 개발을 시작했을때는 자바스크립트의 <code>ES5</code> 버전에서 막 <code>ES6</code>로 넘어가고 있던 시절이었는데, 기존에는 자바(Java)를 주로 사용하고 있던 필자가 프론트엔드 개발로 넘어오면서 제일 애먹었던 부분이 바로 이 프로토타입이었다.<small>(물론 애먹는 건 현재진행형이다)</small></p><p>물론 지금은 자바스크립트의 위상이 많이 올라가면서 프로토타입 패턴에 대한 관심도 많아지기 시작했지만, 그래도 당시나 지금이나 여전히 주류는 C 계열 언어나 Java에서 사용하는 클래스를 기반으로한 객체 생성 방식이다. </p><p>그래서 자바스크립트를 처음 접하는 개발자에게 프로토타입 기반 프로그래밍은 상대적으로 낯선 방식일 수 밖에 없고, 이로 인해 기존 개발자들이 자바스크립트로 진입하는데 어려움이 있었다. 그런 이유로 ES6에서는 <code>class</code> 예약어가 등장한 것이다.</p><p>사실 필자도 아직 클래스 기반의 객체 생성 방식이 익숙하기 때문에 프로토타입에 대한 공부가 더 필요하다.</p><p>그래서 이번 포스팅에서는 프로토타입 패턴이 무엇인지, 자바스크립트 내에서 프로토타입이 어떤 방식으로 사용되고 있는지에 집중해서 한번 이야기해보려고 한다.</p><h2 id="ES6부터-클래스를-지원하는데도-프로토타입을-굳이-알아야-하나요"><a href="#ES6부터-클래스를-지원하는데도-프로토타입을-굳이-알아야-하나요" class="headerlink" title="ES6부터 클래스를 지원하는데도 프로토타입을 굳이 알아야 하나요?"></a>ES6부터 클래스를 지원하는데도 프로토타입을 굳이 알아야 하나요?</h2><p>자바스크립트는 ES6부터 <code>class</code> 키워드를 사용하여 클래스를 지원하고 있다. 정확히 말하면 프로토타입으로 클래스를 흉내내서 구현한 것이라고 말하는 것이 맞다.</p><p>그런 이유로 많은 개발자들이 자바스크립트의 클래스를 단순한 <code>문법 설탕(Syntactic Sugar)</code>라고 이야기하지만, 사실 개인적으로 자바스크립트의 클래스는 ES5 시절 프로토타입을 사용하여 객체를 생성했던 방법보다 더 엄격한 제약을 가지고 있기 때문에 단순한 문법 설탕이라기보다는 <code>상위 요소(Superset)</code>라고 하는게 맞지 않나 싶다.</p><p>그러면 그냥 클래스를 쓰면 되는데 왜 프로토타입을 알아야 하는 것일까?</p><p>그 이유는 ES6에서 <code>class</code> 키워드를 통해 클래스를 지원하고 있기는 하지만, 이건 자바스크립트가 클래스 기반 언어가 되었다는 의미는 아니기 때문이다. 결국 자바스크립트 안에서의 클래스는 클래스의 탈을 쓴 프로토타입이다.</p><p>그리고 예전에 작성된 레거시 프론트엔드 코드의 경우에는 ES5로 작성된 것도 많기 때문에 아직까지 프론트엔드 개발자들은 ES5를 만져야하는 경우가 왕왕 있는 것이 현실이다. 물론 ES5를 ES6 이상의 버전으로 마이그레이션하려고 해도 기존의 프로토타입 기반의 객체 생성이나 상속이 구현된 코드를 이해할 수 없다면 마이그레이션 또한 불가능하다.</p><h2 id="프로토타입은-디자인-패턴이다"><a href="#프로토타입은-디자인-패턴이다" class="headerlink" title="프로토타입은 디자인 패턴이다"></a>프로토타입은 디자인 패턴이다</h2><p><code>프로토타입</code>이라고 하면 일반적으로 자바스크립트를 떠올리지만, 사실 프로토타입은 자바스크립트에서만 사용되는 것은 아니고, 그냥 일종의 디자인 패턴 중 하나이다. 자바스크립트 뿐만 아니라 <code>ActionScript</code>, <code>Lua</code>, <code>Perl</code> 등 프로토타입 기반 프로그래밍을 지원하는 다른 언어도 많다.</p><p>그래서 자바스크립트의 프로토타입을 자세히 알아보기 전에 디자인 패턴으로써의 프로토타입을 먼저 알아볼까 한다.</p><p>프로토타입 패턴은 <code>객체를 효율적으로 생성하는 방법</code>을 다루는 패턴 중 하나인데, 주로 객체를 생성하는 비용이 클 때 이를 회피하기 위해 사용된다.</p><p>객체를 생성할 때의 비용이 크다는 말은, 말 그대로 객체를 생성할 때마다 뭔가 일을 많이 해야한다는 뜻이다.</p><p>예를 들어 RPG 게임의 캐릭터를 하나 구현해본다고 생각해보자. 이 캐릭터는 여러가지 장비를 장착할 수 있는 기능을 가지고 있는데, 처음 캐릭터가 생성될 때 딸랑 맨 몸으로 시작하면 유저들이 싫어할 것 같으니 기본적인 장비 몇 가지를 장착한 상태로 생성될 수 있도록 만들어주려고 한다.</p><figure class="highlight java hljs"><figcaption><span>Player.java</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weapon</span> </span>{}</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Armor</span> </span>{}</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicSward</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weapon</span> </span>{}</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicArmor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Armor</span> </span>{}</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">public</span> Weapon weapon;</span><br><span class="line">    <span class="hljs-keyword">public</span> Armor armor;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Player</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">this</span>.weapon = <span class="hljs-keyword">new</span> BasicSward(); <span class="hljs-comment">// 초심자의 목도</span></span><br><span class="line">        <span class="hljs-keyword">this</span>.armor = <span class="hljs-keyword">new</span> BasicArmor(); <span class="hljs-comment">// 초보자용 갑주</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>간단하게 만들어보면 대충 이런 느낌이다. <code>Player</code> 객체는 자신이 생성될 때 <code>BasicSward</code> 객체와 <code>BasicArmor</code> 객체까지 함께 생성해야한다.</p><p>이런 경우 그냥 <code>Player</code> 객체만 생성하는 상황보다는 <code>객체의 생성 비용이 높다</code>고 할 수 있다. 게다가 캐릭터 생성 시 처음 부여하는 아이템의 종류가 많아질수록 <code>Player</code>의 객체의 생성 비용 또한 계속 높아질 것이다.</p><p>음… 근데 곰곰히 생각해보니 캐릭터가 처음 생성되며 가지고 있는 아이템이 항상 같다는 전제 조건이 있다면 생성 비용이 높은 <code>Player</code>객체를 딱 한번만 생성하고 그 다음부터는 생성된 객체를 복사해서 사용해도 될 것 같다는 생각이 든다.</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 이건 너무 객체 생성 비용이 높으니까...</span></span><br><span class="line">Player evan = <span class="hljs-keyword">new</span> Player();</span><br><span class="line">Player john = <span class="hljs-keyword">new</span> Player();</span><br><span class="line">Player wilson = <span class="hljs-keyword">new</span> Player();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 이런 방법으로 접근해보는 것은 어떨까?</span></span><br><span class="line">Player player = <span class="hljs-keyword">new</span> Player();</span><br><span class="line">Player evan = player.clone();</span><br><span class="line">Player john = player.clone();</span><br><span class="line">Player wilson = player.clone();</span><br></pre></td></tr></tbody></table></figure><p>이런 관점으로 접근하는 것이 바로 프로토타입 패턴이라고 할 수 있다. 프로토타입, 즉 <code>원본 객체</code>가 존재하고 그 객체를 복제해서 새로운 객체를 생성하는 방법인 것이다.</p><p>실제로 자바에서 프로토타입 패턴을 사용할때, 복제 대상이 되는 클래스는 보통 <code>Cloneable</code> 인터페이스를 사용하여 구현한다. Cloneable 인터페이스에는 <code>clone</code> 메소드가 정의되어 있기 때문에, 이 인터페이스를 사용하는 클래스는 반드시 <code>clone</code> 메소드를 오버라이딩해서 구현해야한다.</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>{</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Player <span class="hljs-title">clone</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>{</span><br><span class="line">      <span class="hljs-keyword">return</span> (Player)<span class="hljs-keyword">super</span>.clone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>clone</code> 메소드를 구현하고나면 이제 <code>Player</code> 객체는 복사 가능한 객체가 된다. 즉, 다른 객체들의 원본 객체가 될 수 있는 기능을 가지게 되었다는 것이다.</p><p>이제부터는 <code>Player</code> 객체를 추가로 생성하고 싶을 때는 기존에 생성되어 있던 객체를 그대로 복사하면 되기 때문에 높은 객체 생성 비용이 드는 것을 피할 수 있다.</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Player evan = <span class="hljs-keyword">new</span> Player();</span><br><span class="line">Player evanClone = evan.clone();</span><br></pre></td></tr></tbody></table></figure><p>또한 <code>Player</code> 객체는 복사되어 새로운 메모리 공간을 할당받지만, 깊은 복사를 하지 않는 이상 <code>Player</code>객체가 가지고 있는 <code>BasicSward</code> 객체와 <code>BasicArmor</code> 객체는 새롭게 생성되지 않고 기존에 이 객체들이 할당된 메모리 공간을 참조하기만 한다.</p><p>즉, 잘만 쓴다면 메모리 공간을 아낄 수도 있다는 것이다. 자바스크립트에서 원시 자료형은 <code>Call by value</code>, 그 외 자료형은 <code>Call by reference</code>를 사용하는 것과 동일한 원리이다.</p><p>여기까지 듣고 나서 예상하신 분들도 있겠지만, 그 말인 즉슨 잠깐 정신줄 놓고 코딩하다보면 이런 슬픈 상황도 발생할 수 있다는 뜻이다.</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Player evan = <span class="hljs-keyword">new</span> Player();</span><br><span class="line"><span class="hljs-keyword">try</span> {</span><br><span class="line">    Player evanClone = evan.clone();</span><br><span class="line">    evanClone.weapon.attackPoint = <span class="hljs-number">40</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="hljs-string">"에반 무기 공격력 -> "</span> + evan.weapon.attackPoint);</span><br><span class="line">    System.out.println(<span class="hljs-string">"에반 복사본 무기 공격력 -> "</span> + evanClone.weapon.attackPoint);</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception e) {</span><br><span class="line">    System.err.println(e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">에반 무기 공격력 -> 40</span><br><span class="line">에반 복사본 무기 공격력 -> 40</span><br></pre></td></tr></tbody></table></figure><center><br>  <img src="/2019/10/23/js-prototype/overtime_work.jpg" width="400"><br>  <small>디버깅 지옥이 펼쳐진다…</small><br>  <br><br></center><p>정리해보자면 프로토타입 패턴이란, <code>객체를 생성할 때 원본이 되는 객체를 복사해서 생성하는 패턴</code>이라고 할 수 있다.</p><p>물론 자바스크립트의 프로토타입은 단순히 몇 개의 객체가 복제 관계를 가지는 것이 아니라, 자바스크립트 내의 모든 객체 전체가 복제 관계로 얽혀있기 때문에 이것보다는 약간 더 복잡하긴 하지만, 근본적인 원리 자체는 프로토타입 패턴을 따라간다.</p><p>그럼 이제 자바스크립트가 객체를 생성할 때 프로토타입 패턴을 어떤 식으로 사용하고 있는 지 한번 알아보도록 하자.</p><h2 id="자바스크립트의-프로토타입"><a href="#자바스크립트의-프로토타입" class="headerlink" title="자바스크립트의 프로토타입"></a>자바스크립트의 프로토타입</h2><p>앞서 설명했듯이 프로토타입 패턴은 객체를 생성할 때 사용하는 패턴이다. 필자가 위에서 예시로 사용한 언어인 자바는 클래스 기반 프로그래밍을 지원하기 때문에, 특수한 패턴을 사용해야지만 프로토타입이라는 개념을 사용할 수 있다.</p><p>그러나 애초에 프로토타입 기반 프로그래밍을 지원하는 자바스크립트의 경우에는 애초에 모든 객체를 생성할 때 프로토타입을 사용하기 때문에, 객체를 생성하기만 해도 위에서 필자가 설명한 프로토타입 패턴이 적용된다.</p><p>그렇기 때문에 우선 자바스크립트에서 말하는 <code>객체(Object)</code>가 무엇인지, 그리고 그 객체가 생성된다는 것이 무엇을 의미하는 것인지 알아볼 필요가 있다.</p><h3 id="자바스크립트가-객체를-생성하는-방법"><a href="#자바스크립트가-객체를-생성하는-방법" class="headerlink" title="자바스크립트가 객체를 생성하는 방법"></a>자바스크립트가 객체를 생성하는 방법</h3><p>컴퓨터 공학에서의 <code>객체(Object)</code>는 <code>현실의 사물을 프로그램에 반영한 것</code>이다. 즉, 여러 개의 프로퍼티(특징)와 메소드(행위)를 가지고 현실의 사물을 흉내내는 존재인 것이다.</p><p>클래스 기반 언어에서는 클래스를 생성하고 그 클래스를 사용하여 객체를 생성해야하지만, 자바스크립트는 간단한 문법만으로 객체를 생성할 수 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = {</span><br><span class="line">  name: <span class="hljs-string">'Evan'</span>,</span><br><span class="line">  age: <span class="hljs-number">29</span>,</span><br><span class="line">  say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi, I am <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>!`</span>);</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>이런 방식을 우리는 <code>리터럴(Literal)</code>로 객체를 선언한다고 한다. 리터럴은 소스 코드의 고정된 값을 대표하는 일종의 단축어 같은 개념이기 때문에, 우리는 간단한 문법만으로 객체를 생성했다고 느끼지만 내부적으로는 객체를 생성하는 일련의 매커니즘이 작동하고 있다.</p><p>예를 들어, 다른 언어에서는 이런 리터럴 문법을 사용하여 객체를 생성할 때 내부적으로 <code>클래스</code>를 사용하게된다. 파이썬 같은 경우, 딕셔너리를 리터럴로 선언하고 타입을 찍어보면 <code>dict</code> 클래스가 출력되는 것을 볼 수 있다.</p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_dict = {</span><br><span class="line">    <span class="hljs-string">'name'</span>: <span class="hljs-string">'Evan'</span>,</span><br><span class="line">    <span class="hljs-string">'age'</span>: <span class="hljs-number">29</span></span><br><span class="line">}</span><br><span class="line">type(my_dict)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><class 'dict'></span><br></pre></td></tr></tbody></table></figure><p>우리는 <code>dict({ 'name': 'Evan', 'age': 29 })</code>와 같이 클래스를 명시적으로 사용하지않고 리터럴로 딕셔너리를 생성했지만 내부적으로는 제대로 <code>dict</code> 클래스를 사용해서 객체를 생성했다는 것이다.</p><p>자바 또한 리터럴 문법을 지원하는 <code>배열(Array)</code>을 선언한 후 출력해보면 결국 클래스를 기반으로 배열 객체를 생성한다는 것을 알 수 있다.</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = {<span class="hljs-string">"Evan"</span>, <span class="hljs-string">"29"</span>};</span><br><span class="line">System.out.println(array);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;@7852e922</span><br></pre></td></tr></tbody></table></figure><p>이 말인 즉슨, 다른 언어와 마찬가지로 자바스크립트의 객체도 갑자기 혼자서 뿅 하고 생성되는 것이 아니라 분명히 뭔가를 사용해서 만들어내고 있다는 말이다.</p><p>하지만 자바스크립트에는 클래스라는 개념 자체가 없는데 뭘 사용해서 객체를 만들어내고 있는 것일까?</p><blockquote><p>답은 바로 <code>함수(Function)</code>이다.</p></blockquote><p>자바스크립트에서 객체가 생성되는 원리를 조금 더 파헤쳐보기 위해서 위에서 리터럴로 선언했던 <code>evan</code> 객체를 이번에는 다른 방법으로 선언해보도록 하겠다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>({</span><br><span class="line">  name: <span class="hljs-string">'Evan'</span>,</span><br><span class="line">  age: <span class="hljs-number">29</span>,</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>왠지 클래스 기반 언어에서 클래스를 사용하여 객체를 생성하는 것과 유사한 문법이 나타났다. 이런 방식을 <code>생성자(Constructor)</code>를 사용하여 객체를 생성한다고 한다.</p><p>클래스 기반 언어라면 <code>Object</code>는 클래스겠지만, 자바스크립트에서는 클래스가 아닌 함수이다.</p><p>즉, 자바스크립트에서의 생성자는 함수가 가지고 있다는 것이다. 저게 진짜 함수인지 알고 싶으니, 브라우저 콘솔 창을 열고 <code>Object</code>를 한번 출력해보도록 하겠다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ƒ <span class="hljs-built_in">Object</span>() { [native code] }</span><br><span class="line"><span class="hljs-string">"function"</span></span><br></pre></td></tr></tbody></table></figure><p>음, 콘솔로 찍어보니 <code>Object</code>는 확실하게 빼박캔트 함수가 맞다.</p><p>필자가 처음 자바스크립트를 사용하기 시작했을 때 받아들이기 어려웠던 부분이 바로 이 부분이었다.</p><p>클래스 기반 프로그래밍에 익숙했던 필자에게 <code>new</code> 키워드와 생성자는 클래스만 가질 수 있는 것이었는데 갑자기 뜬금없이 함수가 나와버리니 받아들이기 힘들었던 것 같다.<small>(머리로는 알겠는데 마음이…)</small></p><p>어쨌든 이제 자바스크립트가 객체를 생성할 때 함수를 사용해서 생성한다는 것을 알게되었다. 지금까지 알아낸 내용을 정리해보자면 다음과 같다.</p><blockquote><ol><li>프로토타입 패턴이란 객체를 생성할 때 원본 객체를 복제하여 생성하는 방법이다.</li><li>자바스크립트는 객체를 생성할 때 프로토타입 패턴을 사용한다.</li><li>자바스크립트는 객체를 생성할 때 함수를 사용한다.</li></ol></blockquote><p>그렇다는 것은 자바스크립트가 함수를 사용하여 객체를 생성할 때 <code>뭔가</code>를 참조하고 복제해서 객체를 생성한다는 말이다. 이제부터 그 <code>뭔가</code>를 알아 볼 시간이다.</p><h3 id="도대체-뭘-복제해서-객체를-만드는-걸까"><a href="#도대체-뭘-복제해서-객체를-만드는-걸까" class="headerlink" title="도대체 뭘 복제해서 객체를 만드는 걸까?"></a>도대체 뭘 복제해서 객체를 만드는 걸까?</h3><p>사실 디자인 패턴으로써의 프로토타입 패턴은 생각보다 그렇게 어렵지 않다. 그저 객체를 생성할 때 원본 객체를 <code>복제</code>해서 생성한다는 개념이기 때문이다.</p><p>마찬가지로 자바스크립트 또한 뭔가를 복제해서 새로운 객체를 생성하고 있다. 그럼 이제 자바스크립트가 도대체 뭘 복제해서 객체를 생성하고 있는 것인지 알아보기 위해 간단한 함수를 하나 선언해보도록 하겠다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params"></span>) </span>{}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> evan);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User { <span class="hljs-attr">__proto__</span>: <span class="hljs-built_in">Object</span> }</span><br><span class="line">object</span><br></pre></td></tr></tbody></table></figure><p>위에서 이야기했듯이 자바스크립트는 함수를 사용하여 객체를 생성하기 때문에, 이렇게 클래스를 사용하는 것과 유사한 느낌으로 객체를 생성할 수 있다.</p><p>그렇다면 <code>evan</code> 객체는 무엇으로부터 복제된 것일까? 간단하게 생각하면 <code>User</code> 함수라고 생각해볼수 있겠지만, 사실은 <code>User</code> 함수를 복제한 것이 아니라 <code>User 함수의 프로토타입 객체</code>를 복제한 것이다.</p><center><br>  <img src="/2019/10/23/js-prototype/surprise.jpeg" width="400"><br>  <small>이렇게 갑자기 프로토타입이 나온다고…?</small><br>  <br><br></center><p>뜬금없어서 바로 이해가 안될 수도 있겠지만, 단순하게 생각해보면 쉽다. 만약 객체를 생성하면서 함수를 복제했다면 생성된 객체는 <code>object</code> 타입이 아니라 <code>function</code> 타입이어야 하지 않겠는가?</p><p>하지만 <code>evan</code> 객체는 <code>object</code> 타입을 가지고 있다. 즉, 이 함수 자체가 아니라 다른 객체 타입의 무언가를 복제했다는 것이고, 그 원본 객체가 <code>User 함수의 프로토타입 객체</code>인 것이다.</p><p>필자는 <code>User</code> 함수의 프로토타입을 명시적으로 선언하지 않았지만, 자바스크립트는 함수가 생성될 때 자동으로 그 함수의 <code>프로토타입 객체(Prototype Object)</code>도 함께 생성하고 해당 함수의 <code>prototype</code> 프로퍼티에 연결해둔다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params"></span>) </span>{}</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(User.prototype);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> User.prototype);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="hljs-attr">constructor</span>: f User(), <span class="hljs-attr">__proto__</span>: <span class="hljs-built_in">Object</span> }</span><br><span class="line">object</span><br></pre></td></tr></tbody></table></figure><p>분명히 필자는 함수만 선언했는데, <code>User.prototype</code> 프로퍼티에 뭔가 이것저것 가지고 있는 객체 녀석이 1+1으로 붙어나왔다. 함수를 생성하면 무조건 그 함수의 프로토타입 객체도 함께 생성된다는 것이 키포인트다.</p><p>그리고 이 프로토타입 객체는 함수를 사용해서 새로운 객체를 생성할 때 원본 객체 역할을 해줄 객체를 의미한다.</p><p>즉, <code>new User()</code>라는 문법을 사용하여 새로운 객체를 만들게 되면 <code>User</code> 함수 자체가 아니라 <code>User</code> 함수가 생성될 때 함께 생성된 <code>User 함수의 프로토타입 객체</code>를 복제해서 새로운 객체를 만든다는 것이다.</p><center><br>  <img src="/2019/10/23/js-prototype/prototype.png" width="500"><br>  <small>evan 객체야, 내가 아니라 내 프로토타입 객체를 복제하렴</small><br>  <br><br></center><p>이때 <code>User</code> 함수가 생성되며 함께 생성된 User 함수의 프로토타입 객체를 <code>프로토타입 프로퍼티(Prototype Property)</code>라고 한다.</p><p>그럼 이 프로토타입 객체가 가지고 있는 프로퍼티인 <code>constructor</code>와 <code>__proto__</code>는 뭘 의미하는 걸까?</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>함수가 생성되며 함께 생성된 프로토타입 객체는 모두 <code>constructor</code>라는 프로퍼티를 가지고 있다. 그리고 이 프로퍼티에는 이 프로토타입 객체가 생성될 때 선언했던 함수가 들어있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(User.prototype);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="hljs-keyword">constructor</span>: f User(),</span><br><span class="line">  __proto__: Object</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>함수를 선언하면 함수와 함께 해당 함수의 프로토타입 객체도 함께 생성되며 이 둘을 연결하게 된다. 이때 함수는 프로토타입 객체의 <code>constructor</code> 프로퍼티로 연결되고, 프로토타입 객체는 함수의 <code>prototype</code> 프로퍼티로 연결되는 것이다.</p><center><br>  <img src="/2019/10/23/js-prototype/prototype_connection.png" width="500"><br>  <small>함수와 프로토타입 객체는 서로 연결되어있다</small><br>  <br><br></center><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(User.prototype.constructor === User);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">true</span></span><br></pre></td></tr></tbody></table></figure><p>이 생성자 프로퍼티는 이 함수를 통해 생성된 객체 입장에서 보았을 때 <code>나를 만들 때 어떤 함수가 호출되었냐?</code>를 의미한다. 만약 이 연결이 없다면 새로 생성된 객체는 자신을 만들 때 어떤 생성자 함수가 호출되었는지 알 수가 없다.</p><p>새롭게 생성된 객체는 자신을 생성할 때 어떤 원본 객체를 복사했는지에 대한 링크는 가지고 있지만 어떤 생성자가 호출되었는지에 대한 링크는 가지고 있지 않기 때문이다.</p><p>하지만 원본 객체의 <code>constuctor</code> 프로퍼티에 생성자 함수가 연결되어있기 때문에 새롭게 만들어진 객체는 자신의 원본 객체에 접근해서 이 프로퍼티를 참조함으로써 자신이 만들어질때 어떤 생성자 함수가 호출되었는지를 알 수 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.__proto__.constructor === User);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">true</span></span><br></pre></td></tr></tbody></table></figure><p>이때 생성된 객체가 자신의 원본 객체에 접근할 수 있는 프로퍼티가 바로 <code>__proto__</code> 프로퍼티이다.</p><h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h4><p>방금 생성자를 설명하면서 함수를 통해 새롭게 생성된 객체는 원본 객체와의 연결을 가지고 있다고 했다. 이때 이 연결을 <code>프로토타입 링크(Prototype Link)</code>라고 한다.</p><p><code>Object.prototype</code>을 제외한 자바스크립트 내의 모든 객체는 원본 객체를 기반으로 복사되어 생성되었기 때문에, 자신의 원본 객체로 연결되어있는 프로토타입 링크 또한 모든 객체가 가지고 있다. 이때 이 링크가 담기는 프로퍼티가 <code>__proto__</code> 프로퍼티이다.</p><p><code>Object.prototype.__proto__</code>가 존재하지 않는 이유는 밑에서 후술하도록 하겠다. 우선은 객체들이 자신의 원본 객체로 통하는 프로토타입 링크를 가지고 있다는 사실에만 집중하자.</p><blockquote><p>이 포스팅에서는 이해를 돕기위해 <code>__proto__</code> 프로퍼티를 그대로 사용하고 있다.<br>그러나 해당 프로퍼티는 ECMAScript 2015에서는 표준이었지만 현재는 표준이 아니므로 <code>Object.getPrototypeOf()</code>를 사용하는 것을 추천한다.</p></blockquote><p>즉 <code>User</code> 함수를 사용하여 생성한 객체는 <code>User.prototype</code> 객체를 복사하여 생성된 객체이기 때문에, 이 객체들은 원본인 <code>User.prototype</code> 객체를 자신의 <code>__proto__</code> 프로퍼티에 연결해두는 것이다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params"></span>) </span>{}</span><br><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.__proto__ === User.prototype);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">true</span></span><br></pre></td></tr></tbody></table></figure><p>그렇다면 이 프로토타입 링크를 사용해서 계속 해서 원본 객체를 추적하다보면, 결국은 자바스크립트 내의 모든 객체들이 최종적으로 어떤 원본 객체를 복사해서 생성된 것인지 알 수 있지 않을까?</p><h2 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h2><p>자바스크립트 내의 사용되는 모든 객체들은 전부 이런 프로토타입 기반 방식으로 정의되고 생성된다. 즉, <code>String</code>, <code>Boolean</code>, <code>Array</code>와 같이 우리가 일반적으로 사용하고 있는 빌트인 객체들도 모두 같은 방식을 사용해서 만들었다는 것이다.</p><p>그렇다면 이 객체들은 어떤 프로토타입 객체를 복사해서 만들어진 것일까?</p><p>String, Boolean, Array든 뭐가 됐든 자바스크립트 내에 존재하는 모든 것들은 바로 <code>Object</code> 함수의 프로토타입인 <code>Object.prototype</code>을 시작으로 해서 복제된다.</p><p>위에서 <code>__proto__</code>를 설명하면서 <code>Object.prototype</code> 객체는 프로토타입 링크, 즉 원본 객체로 통하는 링크가 없다고 이야기했었는데, 그 이유는 바로 <code>Object.prototype</code>이 모든 객체들의 조상님이기 때문이다.</p><p>이게 정말인지 확인해보고 싶다면, 아무 객체나 골라잡아서 그 객체의 <code>__proto__</code> 프로퍼티를 통해 쭉쭉 올라가보면 된다.</p><p>일단 만만한 <code>String</code>을 사용해서 조상을 추적해보려고 하는데, <code>String</code> 객체를 생성하는 함수부터 출발할 것인지, <code>String</code> 함수를 통해 생성된 객체부터 출발할 것인지에 따라 조상까지 올라가는 길이 달라진다.</p><p>String <code>함수</code>와 String <code>객체</code>는 당연히 원본이 되는 객체도 다르기 때문이다. 필자는 그 중 String 객체를 생성할 수 있는 String 생성자 함수를 선택했다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> first = <span class="hljs-built_in">String</span>.__proto__;</span><br><span class="line"><span class="hljs-keyword">const</span> second = first.__proto__;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'첫번째 조상 -> '</span>, first.constructor.name);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'두번째 조상 -> '</span>, second.constructor.name);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">첫 번째 조상 -> Function</span><br><span class="line">두 번째 조상 -> Object</span><br></pre></td></tr></tbody></table></figure><p>자바스크립트의 모든 함수는 자신의 원본으로 <code>Function.prototype</code> 객체를 원본으로 가진다. 그리고 Function.prototype은 결국 객체이기 때문에, 당연히 원본으로 <code>Object.prototype</code> 객체를 원본으로 가진다.</p><p>그럼 여기서 한번 더 올라가면 어떻게 될까?</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> third = second.__proto__;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(third.constructor.name);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property 'constructor' of null at <anonymous>:1:28</span><br></pre></td></tr></tbody></table></figure><p>앗, <code>TypeError</code>가 발생했다. 에러메세지를 보아하니 <code>Object.prototype</code> 객체의 원본 객체인 <code>Object.prototype.__proto__</code>는 <code>null</code>인 모양이다.</p><p>즉, <code>Object</code>의 위로는 더 이상 조상이 없는 것이다. 지금 살펴본 이 관계를 간단한 다이어그램으로 나타내어보면 다음과 같다.</p><center><br>  <img src="/2019/10/23/js-prototype/prototype-chain.png"><br>  <br><br></center><p>뭔가 복잡해보이지만 별 것 없다. String <code>함수</code>의 원본 객체는 <code>Function.prototype</code>이다. 그리고 <code>const a = 'evan'</code>과 같이 선언된 String 객체는 자신을 생성한 String 함수의 <code>String.prototype</code>을 원본으로 가질 것이고, <code>String.prototype</code>은 객체이기 때문에 당연히 <code>Object.prototype</code>을 원본으로 가지는 것이다.</p><p>이렇게 프로토타입으로 이루어진 객체들의 관계를 <code>프로토타입 체인(Prototype Chain)</code>이라고 한다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 필자가 프로토타입에 대한 포스팅을 쓰려고 했던 이유는 얼마 전 면접에서 자바스크립트의 프로토타입을 사용하여 <code>Private Static 메소드</code>를 구현하라는 문제를 받았다가 결국 못 풀었기 때문이다.</p><p>자바스크립트의 클로저와 프로토타입을 활용하여 풀어야하는 문제였는데, 필자는 기본기가 부족한 나머지 풀어내지 못했다.</p><p>그래서 원래는 프로토타입을 사용한 다양한 상속 기법들과 클로저를 사용한 멤버의 은닉 등도 함께 소개해보려고 했지만, 늘 그렇듯 분량 조절 실패로 인해 다른 포스팅에서 별도로 다뤄야할 것 같다.</p><center><br>  <img src="/2019/10/23/js-prototype/no_think.jpeg" width="300"><br>  <small>사실 애초에 분량 조절 따위를 생각하고 쓰지 않는다</small><br>  <br><br></center><p>필자처럼 기존의 클래스 기반 객체 생성방식에 익숙한 개발자들에게 자바스크립트의 프로토타입은 꽤나 복잡하게 느껴진다. 디자인 패턴으로써의 프로토타입은 단순히 객체를 복제해서 새로운 객체를 생성한다는 정도의 개념에 그치지만 자바스크립트의 프로토타입 체인은 그것보다 훨씬 더 복잡하게 연결되어있기 때문이다.</p><p>하지만 프로토타입 체인이나 프로토타입을 사용한 각종 상속 기법은 어렵게 느껴질 수 있어도, 프로토타입의 뼈대 자체는 그렇게 어렵지 않다고 생각한다.</p><blockquote><ol><li>객체는 함수를 사용해서 만들어지고, 객체는 함수의 프로토타입 객체를 복제하여 생성된다.</li><li>모든 객체는 자신이 어떤 원본 객체를 복제하여 생성된 것인지에 대한 정보를 가지고 있다.</li></ol></blockquote><p>물론 원본 객체에 대한 정보를 런타임에 동적으로 변경할 수 있는 등 변태같은 짓들이 가능하기도 하고, 이를 사용한 다양한 기법들도 있기는 하지만 기본은 결국 저 두 가지라고 할 수 있을 것 같다. 다음 포스팅에서는 본격적으로 프로토타입을 사용한 상속 기법과 객체의 프로퍼티를 탐색하는 방법인 프로토타입 룩업 등에 대해서 설명하도록 하겠다.</p><p>이상으로 자바스크립트의 프로토타입 훑어보기 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/10/23/js-prototype/#disqus_thread</comments>
    </item>
    
    <item>
      <title>최소 값과 최대 값을 빠르게 찾을 수 있게 도와주는 힙(Heap)</title>
      <link>https://evan-moon.github.io/2019/10/12/introduction-data-structure-heap/</link>
      <guid>https://evan-moon.github.io/2019/10/12/introduction-data-structure-heap/</guid>
      <pubDate>Sat, 12 Oct 2019 09:51:14 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;이번 포스팅에서는 대표적인 자료 구조 중 하나인 &lt;code&gt;힙(Heap)&lt;/code&gt;에 대한 설명과 구현을 한번 해보려고 한다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>이번 포스팅에서는 대표적인 자료 구조 중 하나인 <code>힙(Heap)</code>에 대한 설명과 구현을 한번 해보려고 한다.</p><a id="more"></a><p>이전의 포스팅에서 몇 번 언급한 적이 있지만 필자는 지금 백수다. 이제 프라하에서 한 달간의 힐링도 끝났으니 슬슬 면접을 보러 다녀야 하는데, 모두들 알다시피 면접에서는 기초 알고리즘이나 자료 구조에 대한 질문이 들어올 확률이 굉장히 높다. 하지만 필자는 최근 1년 정도 기초 공부를 게을리 했기 때문에 다시 공부를 해야하는 상황이다.</p><p>그래서 일단은 자료 구조부터 다시 살펴볼 생각인데, 그 중 제일 기억이 잘 나지 않는 <code>힙(Heap)</code>부터 한번 부셔볼까 한다.</p><h2 id="힙-Heap-이란"><a href="#힙-Heap-이란" class="headerlink" title="힙(Heap)이란?"></a>힙(Heap)이란?</h2><p>힙은 기본적으로 <code>완전 이진 트리(Complete Binary Tree)</code>를 기본으로 한 자료 구조이며, 부모 노드와 자식 노드 간의 대소관계가 성립하는 자료 구조이다. 그렇기 때문에 힙의 루트 노드는 힙 내의 데이터들 중 <code>가장 큰 값</code>이거나 <code>가장 작은 값</code>이라고 할 수 있다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/heap.png" width="500"><br>  <small>루트에 최대 값이 오게 되는 Max Heap의 모습</small><br>  <small>생긴 건 완전 이진 트리랑 똑같이 생겼다</small><br>  <br><br></center><p>즉, 힙 내의 가장 큰 값이나 가장 작은 값에 접근하고 싶을 때 비교 연산없이 한번에 접근할 수 있다는 의미이며, 이 접근 연산의 시간 복잡도는 당연히 $O(1)$이다. 이런 힙의 성격 때문에 힙은 여러 개의 데이터 중에서 가장 크거나 작은 값을 빠르게 찾아야 하는 영역에서 유용하게 사용된다.</p><p>사실 단순히 어떤 데이터 뭉치 안에서 최대 값이나 최소 값에 $O(1)$의 시간 복잡도로 접근하고 싶다면 그냥 <code>링크드 리스트(Linked List)</code>나 <code>배열(Array)</code>을 정렬해서 사용해도 무방하긴 하다. 한번 정렬만 해놓으면 그 다음부터는 그냥 헤드에서 값을 쏙쏙 뽑아다 쓰면 되기 때문이다.</p><p>그러나 이렇게 정렬되어 있는 데이터 뭉치에 새로운 데이터를 <code>추가</code>할 때는 전체 데이터 뭉치를 싹 다 뒤져서 다시 최대, 최소 값이 무엇인지 찾아내고 재정렬하는 과정을 거쳐야한다.</p><p>배열과 링크드 리스트과 같은 선형 자료 구조는 이 과정에 $O(n)$의 시간 복잡도가 소요되는 반면, 부모가 자식보다 크거나 작게 정렬된 이진 트리의 경우는 새로운 추가된 노드의 부모 노드들과만 비교해도 정렬 상태를 유지할 수 있기 때문에 $O(\log n)$의 시간 복잡도만 소요된다.</p><p>즉, 정렬하고 싶은 데이터가 많을 수록 더 유리하다는 소리다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/compares.png" width="500"><br>  <small>전체 데이터를 비교할 필요없이 이 부분만 비교하면 다시 재정렬할 수 있다</small><br>  <br><br></center><p>힙은 완전 이진 트리를 기초로 하기 때문에 구현하는 방법 또한 완전 이진 트리와 흡사하다. 그렇기 때문에 힙을 구현해보기에 앞서 완전 이진 트리의 특징을 먼저 이야기 해보려고 한다.</p><h2 id="완전-이진-트리-Complete-Binary-Tree"><a href="#완전-이진-트리-Complete-Binary-Tree" class="headerlink" title="완전 이진 트리(Complete Binary Tree)"></a>완전 이진 트리(Complete Binary Tree)</h2><p>먼저, 힙의 기본이 되는 완전 이진 트리의 특징을 한번 살펴보자. <code>이진 트리(Binary Tree)</code>란 어떤 하나의 노드가 자식 노드를 최대 2개까지만 가질 수 있는 트리를 말한다.</p><p>그 말인 즉슨, 한 레벨에 최대로 들어설 수 있는 노드의 개수가 정해져있다는 뜻이고, 노드들에게 고유한 인덱스를 부여할 수 있다는 것을 의미한다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/not_allow_new_node.png" width="500"><br>  <small>부모 노드는 반드시 2개 이하의 자식 노드를 가져야 한다.</small><br>  <br><br></center><p><code>완전 이진 트리(Complete Binary Tree)</code>는 이진 트리의 노드를 생성할 때 트리의 왼쪽부터 차곡차곡 채워 나가는 트리를 의미한다. 이때 완전 이진 트리의 한 레벨이 꽉 차기 전에는 다음 레벨에 노드를 생성할 수 없다. 즉, 마지막 레벨을 제외한 모든 레벨에는 노드가 꽉 차 있어야 한다는 뜻이다.</p><p>트리는 보통 <code>링크드 리스트(Linked List)</code>나 <code>배열(Array)</code>과 같은 선형 자료 구조를 사용하여 구현하는데, 이때 링크드 리스트와 배열의 특징에 따라 장단점이 갈리기 때문에 선택이 필요하다.<small>(링크드 리스트와 배열의 차이에 대한 내용은 이 포스팅의 주제가 아니므로 따로 설명하지는 않겠다.)</small></p><p>일반적으로 트리는 링크드 리스트를 사용하여 구현하지만 완전 이진 트리의 경우에는 배열로 구현하는 것이 더 효율적이다.</p><h3 id="배열이-더-효율적인-이유"><a href="#배열이-더-효율적인-이유" class="headerlink" title="배열이 더 효율적인 이유"></a>배열이 더 효율적인 이유</h3><p>사실 트리를 구현할 때 <code>원소에 한방에 접근이 가능하다</code>는 배열의 최대 장점을 뒤로 미뤄두고서라도 링크드 리스트를 사용하는 이유는, 배열을 사용하여 트리를 구현하면 메모리 고정 할당 방식이라는 배열의 특성 상 불편한 점이 너무 많기 때문이다.</p><p>그러나 완전 이진 트리에서는 이 불편한 점들이 사라지기 때문에 배열의 장점을 오롯이 가져갈 수 있다.</p><h4 id="원하는-노드로의-접근이-쉽다"><a href="#원하는-노드로의-접근이-쉽다" class="headerlink" title="원하는 노드로의 접근이 쉽다"></a>원하는 노드로의 접근이 쉽다</h4><p>이건 배열의 최대 장점인 <code>인덱스만 알면 해당 원소에 바로 접근이 가능</code>하다는 장점을 그대로 살린 것이다. 이진 트리는 각 레벨에 들어설 수 있는 노드의 최대 개수가 정해져 있기 때문에 간단한 수식만으로 특정 노드의 인덱스를 알아내어 $O(1)$의 시간 복잡도로 노드에 접근할 수 있다.</p><p>먼저, 특정 노드를 기반으로 부모나 자식 노드에 접근하고 싶다면 다음과 같이 인덱스를 계산해볼 수 있다.</p><blockquote><p>루트 노드가 0번 인덱스를 가지고, 현재 노드가 $i$번 인덱스를 가지고 있을 때</p><p>[부모 노드] $(i-1) / 2$<br>[왼쪽 자식 노드] $2i+1$<br>[오른쪽 자식 노드] $2i+2$</p></blockquote><p>위와 같이 특정 노드의 인덱스를 기반으로 부모와 자식들의 인덱스를 알아내는 방법도 있지만, 배열로 만든 완전 이진 트리의 진짜 장점은 간단한 수식을 통해서 원하는 레벨, 원하는 순번의 노드로 바로 접근할 수도 있다는 것이다.</p><p>완전 이진 트리의 성질을 이용하면 특정 레벨까지의 최대 노드 개수인 $c$를 간단히 계산할 수 있기 때문에 가능한 일이다.</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>c</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}c = 2^{level} - 1\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.879554em;"></span><span class="strut bottom" style="height:1.259108em;vertical-align:-0.379554em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:0.01955399999999996em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit">c</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.413em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span><p><br></p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAllNodeCountByLevel</span> (<span class="hljs-params">level = <span class="hljs-number">1</span></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>**level - <span class="hljs-number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(getAllNodeCountByLevel(<span class="hljs-number">3</span>));</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">7</span> <span class="hljs-comment">// 3 레벨로 구성된 완전 이진 트리 내 노드의 최대 개수</span></span><br></pre></td></tr></tbody></table></figure><p>이 식을 사용하면 $n$번째 레벨의 $m$번째 노드의 인덱스도 간단하게 알아낼 수 있다.</p><p>예를 들어, 완전 이진 트리의 <code>n 레벨에 있는 m번째 노드</code>의 인덱스인 $i$를 구하고 싶다면, 내가 접근하고 싶은 레벨의 바로 위 레벨인 $n - 1$ 레벨까지의 모든 노드의 개수 $c$을 구하고, 거기에 해당 레벨 내에서 내가 $m$번째 노드에 접근하고 싶은지만 더해주면 된다.</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>i</mi><mo>=</mo><mi>c</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}i = c + m - 1\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.010000000000000009em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathit">c</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span><p><br></p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeIndex</span> (<span class="hljs-params">level = <span class="hljs-number">1</span>, count = <span class="hljs-number">1</span></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> getAllNodeCountByLevel(level - <span class="hljs-number">1</span>) + count - <span class="hljs-number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(getNodeIndex(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>));</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">5</span> <span class="hljs-comment">// 3 레벨의 3 번째로 위치한 노드의 인덱스</span></span><br></pre></td></tr></tbody></table></figure><p>마지막에 1을 빼주는 이유는 우리가 구하고 싶은 것이 노드의 순번이 아닌 인덱스이기 때문이다. 배열의 인덱스는 <code>0</code>부터 시작한다는 사실을 잊지 말자.</p><p>이처럼 배열로 구현한 완전 이진 트리는 간단한 계산만으로 원하는 노드에 접근하기가 용이하지만, 링크드 리스트로 구현하게되면 원하는 노드에 바로 접근할 수 없고, 트리를 순회하여 접근해야한다.</p><h4 id="배열의-원소를-뒤로-밀어줘야-할-일이-없다"><a href="#배열의-원소를-뒤로-밀어줘야-할-일이-없다" class="headerlink" title="배열의 원소를 뒤로 밀어줘야 할 일이 없다"></a>배열의 원소를 뒤로 밀어줘야 할 일이 없다</h4><p>배열은 메모리에 연속적인 공간을 할당하여 사용하기 때문에, 배열 중간에 원소를 끼워넣으려면 새로운 메모리 공간을 확보하기 위해 원소를 한 칸씩 뒤로 밀어줘야하는 슬픈 상황이 발생하지만, 링크드 리스트는 그냥 <code>prev</code> 값과 <code>next</code> 값만 변경함으로써 중간에 새로운 원소를 끼워넣기가 편하다.</p><p>그러나 이진 트리의 경우, 자식 노드를 최대 2개까지만 가질 수 있다는 제약이 있기 때문에 높이가 $h$인 트리는 최대 노드 개수가 $2^{h} -1$개로 정해져있다. 즉, 이 크기 만큼만 배열을 메모리에 할당하고 나면 중간에 노드를 새로 삽입하기 위해 배열의 원소를 뒤로 밀어야하는 경우가 발생하지 않는다는 것이다.</p><h4 id="트리가-기울어지지-않는다"><a href="#트리가-기울어지지-않는다" class="headerlink" title="트리가 기울어지지 않는다"></a>트리가 기울어지지 않는다</h4><p>일반적으로 배열로 구현한 트리가 기울어지게 되면 메모리 공간에 심한 낭비가 생기게 되는데, 그 이유는 그림으로 보면 이해하기가 한결 편하다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/balanced.jpg" width="500"><br></center><p>위 그림은 이상적으로 균형이 잡힌 <code>밸런스드 이진 트리(Balanced Binary Tree)</code>의 모습이다. 만약 이 트리를 배열로 구현한다면 메모리에는 이렇게 값들이 담길 것이다.</p><hr><table><thead><tr><th>Location</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Value</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td></tr></tbody></table><hr><p>배열 중간에 빈 공간이 없이 차곡차곡 메모리에 담겼다. 노드의 인덱스는 트리의 왼쪽부터 순차적으로 부여되기 때문에 자식 노드를 왼쪽부터 생성한다면 메모리에 빈 공간을 만들지 않을 수 있다.</p><p>물론 자식 노드를 생성할 때 왼쪽을 건너 뛰고 오른쪽부터 생성하면 빈 공간이 생기긴 하지만, 더 큰 문제는 트리가 한 쪽으로 크게 기울어지게 되게 되는 편향 트리가 되는 경우이다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/unbalanced.jpg" width="500"><br></center><hr><table><thead><tr><th>Location</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>Value</td><td>A</td><td>B</td><td>C</td><td>D</td><td>-</td><td>-</td><td>-</td><td>H</td></tr></tbody></table><hr><p>위 그림처럼 한 쪽으로 크게 기운 편향 트리는 중간 인덱스를 건너뛰고 다음 레벨에 노드를 생성한 경우이기 때문에 메모리에 빈 공간이 생길 수 밖에 없다. 그렇기 때문에 메모리 공간이 낭비된다고 하는 것이다. 물론 오른쪽으로 기울었다면 건너뛰어야 하는 인덱스도 더 크기 때문에 메모리 공간의 낭비가 더 심해진다.</p><p>그러나 <code>완전 이진 트리</code>는 노드를 왼쪽부터 차곡차곡 채워나가고, 한 레벨의 노드가 다 채워지기 전까지는 다음 레벨에 노드를 채울 수 없다는 제약들이 걸려있기 때문에 애초에 트리가 기울어질 일 자체가 없으니 메모리에 빈 공간이 생길 일도 없다.</p><p>이런 이유들로 인해 완전 이진 트리는 원소에 바로 접근이 가능한 배열의 장점을 살려서 구현하는 경우가 많고, 완전 이진 트리를 기반으로 하는 <code>힙</code> 또한 마찬가지 이유로 인해 주로 배열로 구현하게된다.</p><h2 id="완전-이진-트리와-힙의-차이"><a href="#완전-이진-트리와-힙의-차이" class="headerlink" title="완전 이진 트리와 힙의 차이"></a>완전 이진 트리와 힙의 차이</h2><p><code>힙(Heap)</code>은 완전 이진 트리를 기초로 하기 때문에 기본적인 노드의 삽입 및 삭제 알고리즘은 일반적인 완전 이진 트리와 동일하다. 노드의 삽입은 반드시 배열의 끝에만 가능하며, 노드를 삭제하고 나면 빈 공간이 남지 않도록 남은 노드들을 다시 당겨서 빈 공간을 채워줘야한다.</p><p>다만 힙은 부모와 자식 노드 간의 대소관계가 성립되어야 한다는 조건이 있기 때문에, 삽입 및 삭제 후 <code>노드를 다시 정렬해주는 기능</code>이 추가로 필요하다.</p><p>또한 힙은 사실 트리 내의 최대 값이나 최소 값을 쉽게 찾고자 하는 자료 구조이기 때문에, 트리 중간에 위치한 노드에 바로 접근할 일도 거의 없다. 항상 <code>Array[0]</code>에 위치한 루트 노드를 뽑아다 쓰면 되기 때문이다. 루트 노드를 뽑아온다는 것은 곧 루트 노드의 삭제를 의미하기 때문에 마찬가지로 힙을 다시 정렬해줘야한다.</p><p>힙은 <code>최대 힙(Max Heap)</code>과 <code>최소 힙(Min Heap)</code>으로 나누어지는데, 최대 힙은 항상 부모의 값이 자식보다 커야하고, 최소 힙은 반대로 부모의 값이 자식보다 작아야 한다. 즉, 최대 힙의 루트는 힙 내에서 <code>가장 큰 값</code>, 최소 힙의 루트는 힙 내에서 <code>가장 작은 값</code>을 의미한다는 것이다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/min-max-heap.png" width="500"><br>  <br><br></center><p>즉, 힙을 구현한다는 것은 완전 이진 트리를 구현하고, 최대 힙과 최소 힙에 맞는 정렬 기능을 추가하면 된다는 것이다.</p><h2 id="힙을-구현해보자"><a href="#힙을-구현해보자" class="headerlink" title="힙을 구현해보자"></a>힙을 구현해보자</h2><p>일단 최대 힙과 최소 힙의 차이는 사실 정렬할 때 조건 밖에 없으니, 필자는 <code>최대 힙</code>만 구현해보려고 한다. 위에서 이야기 했듯이 완전 이진 트리의 경우는 링크드 리스트를 이용하는 것보다 배열을 이용하는 것이 더 효율적이기 때문에 배열을 이용하여 구현할 것이다.</p><p>일단 작고 귀여운 <code>MaxHeap</code> 클래스를 하나 만들어주자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxHeap</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">constructor</span> () {</span><br><span class="line">    <span class="hljs-keyword">this</span>.nodes = [];</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>만약 링크드 리스트로 구현하고자 한다면 <code>Node</code> 클래스를 별도로 선언해서 사용하겠지만 필자가 사용할 자료 구조는 배열이기 때문에 단촐하기 그지 없다. 그럼 이제 힙에 값을 삽입하는 메소드부터 한번 만들어보도록 하자.</p><h3 id="새로운-값의-삽입-버블-업"><a href="#새로운-값의-삽입-버블-업" class="headerlink" title="새로운 값의 삽입. 버블 업!"></a>새로운 값의 삽입. 버블 업!</h3><p>힙에 새로운 값을 삽입할 때는 완전 이진 트리의 규칙대로 무조건 트리의 왼쪽부터 채워나간다. 그 말인 즉슨, 그냥 <code>push</code> 메소드를 사용하여 배열의 꼬리로 값을 하나씩 쑤셔넣어주면 된다는 것이다. 잘 이해가 되지 않는다면 위의 <code>완전 이진 트리</code> 설명 부분을 다시 읽어보도록 하자.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert (value) {</span><br><span class="line">  <span class="hljs-keyword">this</span>.nodes.push(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>최대 힙은 항상 부모가 자식보다 큰 값을 가져야한다는 제약이 있으므로, 만약 우리가 힙에 삽입한 노드가 부모 노드보다 큰 값을 가지고 있다면 두 노드의 위치를 바꿔줘야한다.</p><p>그리고 이 작업을 <code>현재 삽입한 노드가 루트까지 올라가거나</code>, <code>부모보다 작은 값을 가지게 되거나</code>, 두 조건 중 하나를 만족할 때까지 반복한다.</p><p>이때 새로 추가한 값이 부모 노드와 스왑되면서 점점 트리의 위로 올라가는 모양새가 거품이 뽀글뽀글 올라오는 모양새랑 비슷하다고 해서 <code>버블 업(Bubble Up)</code>이라고 부른다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/bubbleup.png" width="500"><br>  <small>부모와 자리를 바꾸면서 트리의 위쪽으로 점점 올라간다</small><br>  <br><br></center><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">insert (value) {</span><br><span class="line">  <span class="hljs-keyword">this</span>.nodes.push(value);</span><br><span class="line">  <span class="hljs-keyword">this</span>.bubbleUp();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bubbleUp (index = <span class="hljs-keyword">this</span>.nodes.length - <span class="hljs-number">1</span>) {</span><br><span class="line">  <span class="hljs-keyword">if</span> (index < <span class="hljs-number">1</span>) {</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> currentNode = <span class="hljs-keyword">this</span>.nodes[index];</span><br><span class="line">  <span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">Math</span>.floor((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);</span><br><span class="line">  <span class="hljs-keyword">const</span> parentNode = <span class="hljs-keyword">this</span>.nodes[parentIndex];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (parentNode >= currentNode) {</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">this</span>.nodes[index] = parentNode;</span><br><span class="line">  <span class="hljs-keyword">this</span>.nodes[parentIndex] = currentNode;</span><br><span class="line">  index = parentIndex;</span><br><span class="line">  <span class="hljs-keyword">this</span>.bubbleUp(index);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>bubbleUp</code> 메소드는 인자로 받은 인덱스의 노드의 값과 부모 노드의 값을 비교하여, 해당 노드가 부모 노드의 값보다 큰 값을 가지고 있다면 두 노드의 위치를 스왑하는 역할을 한다. 트리의 특성 상 이 작업은 분할 정복이 가능한 부분이므로 재귀 호출로 구현하였다.</p><p>여기까지 작성하고 간단히 테스트를 해보면 힙 내의 가장 큰 값이 배열의 헤드, 즉 트리의 루트에 위치하게 된다는 것을 알 수 있다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> heap = <span class="hljs-keyword">new</span> MaxHeap();</span><br><span class="line">heap.insert(<span class="hljs-number">1</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">3</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">23</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">2</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">10</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">32</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(heap.nodes);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="hljs-number">32</span>, <span class="hljs-number">10</span>, <span class="hljs-number">23</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span> ]</span><br></pre></td></tr></tbody></table></figure><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/max-heap.gif" width="500"><br>  <small>부모보다 큰 값이 추가되면 부모와 자리를 바꾼다</small><br>  <br><br></center><h3 id="루트에서-값을-빼오자-트릭클-다운"><a href="#루트에서-값을-빼오자-트릭클-다운" class="headerlink" title="루트에서 값을 빼오자. 트릭클 다운!"></a>루트에서 값을 빼오자. 트릭클 다운!</h3><p>값의 삽입과 버블 업을 구현해보았으면 이번에는 루트에서 값을 빼오는 메소드를 만들어보자. 즉, 삭제 연산이다. 이 경우 루트 노드를 뽑아버리면 루트 노드의 자리가 비게 되니 힙을 재정렬해서 다시 루트 노드를 채워줘야한다.</p><p>이때 기존 루트 노드의 자식 노드들을 루트 노드로 올리는 것이 아니라 트리의 가장 마지막에 위치한 노드를 가져와서 루트 노드로 삽입하게 되는데, 이는 수정될 힙에서 빈 공간이 생기지 않게 함으로써 연산량을 줄이기 위해서이다.</p><p>바로 루트의 바로 밑에 있는 자식들을 끌어올려서 루트로 사용해버리면 자연스럽게 그 노드가 있던 곳은 공백이 생기게 되고, 그럼 또 다음 레벨에서 어떤 노드를 끌여올려야 할지 비교 연산이 필요하게 되기 때문이다.</p><p>그리고 힙은 반드시 완전 이진 트리의 형태를 유지해야하기 때문에 이 과정에서 트리가 한 쪽으로 기울게 되버리면 또 트리의 균형을 맞춰줘야하는 번거로움도 생길 수 있다.</p><p>그래서 가장 마지막에 위치한 노드를 새로운 루트 노드로 사용하고 자식들과 값을 비교해나가면서 자리를 바꿔나가는데, 이때 새로운 루트 노드가 트리의 아래 쪽으로 점점 이동하는 모양새가 물방울이 떨어지는 모양새랑 비슷하다고 해서 <code>트릭클 다운(Trickle Down)</code>이라고 부른다.<small>(컴퓨터 용어 주제에 왠지 갬성적이다…)</small></p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">extract () {</span><br><span class="line">  <span class="hljs-keyword">const</span> max = <span class="hljs-keyword">this</span>.nodes[<span class="hljs-number">0</span>];</span><br><span class="line">  <span class="hljs-keyword">this</span>.nodes[<span class="hljs-number">0</span>] = <span class="hljs-keyword">this</span>.nodes.pop();</span><br><span class="line">  <span class="hljs-keyword">this</span>.trickleDown();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> max;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">trickleDown (index = <span class="hljs-number">0</span>) {</span><br><span class="line">  <span class="hljs-keyword">const</span> leftChildIndex = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> rightChildIndex = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> length = <span class="hljs-keyword">this</span>.nodes.length;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">let</span> largest = index;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (leftChildIndex <= length && <span class="hljs-keyword">this</span>.nodes[leftChildIndex] > <span class="hljs-keyword">this</span>.nodes[largest]) {</span><br><span class="line">    largest = leftChildIndex;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">if</span> (rightChildIndex <= length && <span class="hljs-keyword">this</span>.nodes[rightChildIndex] > <span class="hljs-keyword">this</span>.nodes[largest]) {</span><br><span class="line">    largest = rightChildIndex;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (largest !== index) {</span><br><span class="line">    [<span class="hljs-keyword">this</span>.nodes[largest], <span class="hljs-keyword">this</span>.nodes[index]] = [<span class="hljs-keyword">this</span>.nodes[index], <span class="hljs-keyword">this</span>.nodes[largest]];</span><br><span class="line">    <span class="hljs-keyword">this</span>.trickleDown(largest);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>트릭클 다운 또한 버블 업과 마찬가지로 재귀 호출을 통한 분할 정복으로 해결할 수 있다.</p><p><code>trickleDown</code> 메소드는 부모 노드와 왼쪽 자식 노드, 오른쪽 자식 노드의 값을 비교한 후 자식 노드가 부모 노드보다 큰 값을 가지고 있다면 부모 노드와 해당 자식 노드의 위치를 변경한다.</p><p>쉽게 말하면 세 개의 노드 중 가장 큰 값을 가지고 있는 놈이 부모 자리를 먹는 것인데, 만약 이 힘싸움에서 밀린 것이 부모 노드라면 자신의 자식이 있던 곳으로 좌천되는 것이라고 보면 된다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/Arthas_King.jpg" width="400"><br>  <small>썩씌딩하는 꼬라지가 왠지 이 놈을 닮았다</small><br>  <br><br></center><p>만약 이 과정에서 부모 노드와 자식 노드의 위치가 변경되었다면 변경된 부모 노드의 인덱스를 다시 <code>tickleDown</code> 메소드의 인자로 넘겨서 이 과정을 계속 반복한다.</p><p>여기까지 작성했으면 버블 업과 마찬가지로 간단한 테스트를 한번 해보자. 힙에 들어가는 값은 이전에 버블 업에서 사용했던 값과 동일한 값들을 사용했다.</p><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> heap = <span class="hljs-keyword">new</span> MaxHeap();</span><br><span class="line">heap.insert(<span class="hljs-number">1</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">3</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">23</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">2</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">10</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">32</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> length = heap.nodes.length;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < length; i++) {</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'MAX_VALUE = '</span>, heap.extract());</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'HEAP = '</span>, heap.nodes);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAX_VALUE = <span class="hljs-number">32</span></span><br><span class="line">HEAP = [ <span class="hljs-number">23</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]</span><br><span class="line"></span><br><span class="line">MAX_VALUE = <span class="hljs-number">23</span></span><br><span class="line">HEAP = [ <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ]</span><br><span class="line"></span><br><span class="line">MAX_VALUE = <span class="hljs-number">10</span></span><br><span class="line">HEAP = [ <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ]</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/min-heap.gif" width="500"><br>  <small>트리의 맨 끝에서 노드를 빼와서 루트 노드로 사용한다는 것에 주의하자</small><br>  <br><br></center><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>힙 자체는 단순히 데이터들이 느슨하게 정렬되어있는 완전 이진 트리이지만, 루트에는 항상 힙 내부에 있는 데이터들의 최대 값과 최소 값이 위치한다는 특징 때문에 다양하게 응용하여 사용할 수 있다.</p><p>그 중 대표적인 것은 선형 자료 구조를 정렬할 때 사용하는 방법인데, 이 정렬 알고리즘을 <code>힙 정렬(Heap Sort)</code>라고 한다. 현재 V8의 <code>Array.prototype.sort</code> 메소드는 <code>퀵 정렬(Quick Sort)</code>을 사용하고 있지만, 초반에는 힙을 사용하는 정렬 알고리즘인 힙 정렬을 잠깐 사용하기도 했었다.</p><p>어쨌든 그 동안 잊고 있었던 기초적인 자료 구조를 한번 다시 보니 왠지 기분이 좋다.</p><p>힙은 굉장히 다양한 곳에서 사용되고 있는 자료 구조이니 만큼, 알고 있어서 나쁠 게 없기도 하고 면접 때도 꽤 자주 물어봤던 것 같다. 이제 필자는 회사의 비즈니스 로직과 전혀 관련 없는 백수 개발랭이 신분이 되었으니, 그 동안 소홀했던 기초 이론 부분을 이 기회에 조금 더 자세히 공부해봐야겠다.</p><p>이상으로 최소 값과 최대 값을 빠르게 찾을 수 있게 도와주는 힙(Heap) 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/10/12/introduction-data-structure-heap/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTTP/3는 왜 UDP를 선택한 것일까?</title>
      <link>https://evan-moon.github.io/2019/10/08/what-is-http3/</link>
      <guid>https://evan-moon.github.io/2019/10/08/what-is-http3/</guid>
      <pubDate>Mon, 07 Oct 2019 16:57:49 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;code&gt;HTTP/3&lt;/code&gt;는 &lt;code&gt;HTTP(Hypertext Transfer Protocol)&lt;/code&gt;의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 &lt;code&gt;QUIC&lt;/code&gt;을 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p><code>HTTP/3</code>는 <code>HTTP(Hypertext Transfer Protocol)</code>의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 <code>QUIC</code>을 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.</p><a id="more"></a><p>필자는 최근에 다른 분들이 공유해주시는 포스팅을 보고 나서 HTTP/3가 나왔다는 것을 처음 알게 되었다. 그 포스팅은 <a href="https://blog.cloudflare.com/http3-the-past-present-and-future/" target="_blank" rel="noopener">HTTP/3: the past, the present, and the future</a>라는 포스팅이었는데, 솔직히 처음 딱 제목만 보고나서 이런 생각을 했었다.</p><blockquote><p>아니, HTTP/2가 공개된지 4년 정도 밖에 안 지났는데 무슨 HTTP/3가 벌써 나와? 그냥 설계하고 있다는 거 아니야?</p></blockquote><p>그런데 포스팅을 읽어 보니 이미 Google Chrome은 HTTP/3를 지원하는 카나리 빌드도 배포되어 있어서 실제로 사용까지 해볼 수 있는 단계에 도달했다는 사실을 알게 되어 놀랐다. HTTP/1에서 HTTP/2로 가는 데만 해도 대략 15년 정도의 시간이 걸렸는데, 고작 4년 만에 바로 사용해볼 수 있는 정도의 완성도인 다음 메이저 버전이 배포되었다는 것이다.</p><p>게다가 아직 전 세계의 HTTP/2 점유율을 보면 40% 정도 밖에 안된다. 그 정도로 HTTP/2가 나온지도 얼마 되지 않았다는 것이다.</p><center><br>  <img src="/2019/10/08/what-is-http3/ce-http2.png" width="500"><br>  <small>W3Techs.com에서 조사한 2019년 8월 HTTP/2 사용률</small><br>  <br><br></center><p>프로그래밍 언어나 프레임워크같은 친구들은 배포하는 쪽에서 업데이트를 쫙 해버리고 유저들이 업데이트를 하면 그만이지만, 프로토콜은 일종의 규약이기 때문에 소프트웨어 제조사 간 합을 맞추는 기간이 필요하므로 이렇게 단기간 안에 급격한 변화가 자주 발생하지 않을 것이라고 생각했다.</p><p>아무리 요즘 기술의 변화가 빠르다지만, HTTP는 나름 웹의 근간이 되는 프로토콜인데 꼴랑 4년 만에 이런 급격한 변화가 일어났다는 게 놀라울 따름이다.<small>(몇 달 전에 HTTP/2를 처음 도입해본 웹 개발자는 웁니다)</small></p><p>그리고 또 한가지 놀랐던 점은 HTTP/3는 <code>TCP</code>가 아닌 <code>UDP</code>를 사용한다는 것이었다. 뭐 딱히 웹 프로토콜이 무조건 TCP만 사용해야 한다는 법이 있는 건 아니긴 하지만, 학교에서 배울 때도 그렇고 실무에서도 실제로 사용할 때도 그렇고 <code>HTTP는 TCP 위에서 정의된 프로토콜</code>이라는 사실이 너무 당연하게 인식되어 있었기 때문에 UDP를 사용한다는 점이 신기하기도 했고 “왜 멀쩡히 잘 돌아가는 TCP를 냅두고 UDP를 사용하는거지?”라는 의문도 들었다.</p><p>사실 HTTP/3는 정식으로 배포된 프로토콜이라기보다 아직 테스트를 거치고 있는 단계라고 보는 게 맞다. 하지만 위에서 이야기 했듯이 Google Chrome은 이미 HTTP/3를 지원하는 카나리 빌드를 배포한 상태이고, Mozila Firefox도 조만간 Nightly 버전에서 HTTP/3를 지원할 예정이며, cURL에서도 HTTP/3를 실험적 기능으로 제공하고 있는 만큼 가까운 미래 안에 HTTP/3가 메인 프로토콜이 될 가능성이 높은 것도 사실이다.</p><p>만약 Google Chrome에서 HTTP/3 프로토콜을 사용해보고 싶다면 터미널에서 <code>--enable-quic</code>과 <code>--quic-version=h3-23</code> 인자를 사용하여 실행하면 된다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ open -a Google\ Chrome --args --<span class="hljs-built_in">enable</span>-quic --quic-version=h3-23</span><br></pre></td></tr></tbody></table></figure><center><br>  <img src="/2019/10/08/what-is-http3/http3-demo.png" width="500"><br>  <small><code>http/2+quic/46</code>이라고 되어있는 녀석들이 HTTP/3 프로토콜을 사용한 연결이다</small><br>  <br><br></center><p>필자는 웹 개발자이기 때문에 HTTP가 메이저 업데이트 된다는 사실을 그냥 넘기기는 힘들었고, UDP를 사용한다는 것이 뭘 의미하는지도 궁금하기도 해서 결국 HTTP/3에 대한 조사를 하게 되었다. 그래서 이번 포스팅에서는 필자가 여기저기 쑤셔보면서 알아본 HTTP/3에 대한 내용을 정리해볼까 한다.</p><h2 id="HTTP-3에-대한-간단한-소개"><a href="#HTTP-3에-대한-간단한-소개" class="headerlink" title="HTTP/3에 대한 간단한 소개"></a>HTTP/3에 대한 간단한 소개</h2><p>사실 <code>HTTP/3</code>는 처음에는 <code>HTTP-over-QUIC</code>이라는 이름을 가지고 있었는데, <code>IETF(Internet Engineering Task Force)</code> 내 HTTP 작업 그룹과 QUIC 작업 그룹의 의장인 마크 노팅엄이 이 프로토콜의 이름을 HTTP/3로 변경할 것을 제안했고, 2018년 11월에 이 제안이 통과되어 HTTP-over-QUIC이라는 이름에서 HTTP/3으로 변경되게 되었다.</p><p>즉, HTTP/3는 <code>QUIC</code>이라는 프로토콜 위에서 돌아가는 HTTP인 것이다. QUIC은 <code>Quick UDP Internet Connection</code>의 약자로, 말 그대로 UDP를 사용하여 인터넷 연결을 하는 프로토콜이다.<small>(참고로 발음은 그냥 <code>퀵</code>이라고 한다)</small></p><p>HTTP/3는 QUIC을 사용하고, QUIC은 UDP를 사용하기 때문에 결과적으로 <code>HTTP/3는 UDP를 사용한다</code> 라고 이야기 할 수 있는 것이다.</p><p>그렇다면 QUIC이 도대체 뭐길래 기존의 TCP보다 더 빠른 전송 속도를 가질 수 있다는 것일까? 그 이유를 알려면 먼저 TCP가 왜 느리다고 하는지, UDP를 사용함으로써 어떤 이득을 얻을 수 있는지 부터 알아야 한다.</p><h2 id="TCP가-왜-느리다고-하는-걸까"><a href="#TCP가-왜-느리다고-하는-걸까" class="headerlink" title="TCP가 왜 느리다고 하는 걸까?"></a>TCP가 왜 느리다고 하는 걸까?</h2><p>필자는 학교에서 네트워크 강의를 들을 때 <code>TCP</code>와 <code>UDP</code>의 차이에 대한 내용을 처음 배웠었는데, 교수님이 이건 반드시 시험에 나온다길래 이런 표를 보면서 열심히 외웠던 기억이 난다.</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>연결 방식</td><td>연결형 서비스</td><td>비연결형 서비스</td></tr><tr><td>패킷 교환</td><td>가상 회선 방식</td><td>데이터그램 방식</td></tr><tr><td>전송 순서 보장</td><td>보장함</td><td>보장하지 않음</td></tr><tr><td>신뢰성</td><td>높음</td><td>낮음</td></tr><tr><td>전송 속도</td><td>느림</td><td>빠름</td></tr></tbody></table><p>위 표를 보면 대략 TCP는 <code>신뢰성이 높고 느리다</code>, UDP는 <code>신뢰성이 낮고 빠르다</code> 정도로 정리가 되는데, 여기서 말하는 신뢰성이란 전송되는 데이터 패킷들의 순서, 패킷 유실 여부 등을 검사하여 송신 측이 보낸 모든 데이터가 수신 측에 온전하게 전달이 될 수 있느냐를 말하는 것이다.</p><p>TCP는 클라이언트와 서버가 서로 신뢰성있는 통신을 할 수 있도록 몇 가지 방법을 사용하게되는데, 이 방법들 또한 결국은 클라이언트와 서버 간의 통신이기 때문에 레이턴시가 발생할 수 밖에 없다. 게다가 이 과정은 TCP라는 프로토콜이 생길 때부터 정의된 <code>표준</code>이므로 무시할 수도 없다.</p><p>그렇다면 레이턴시를 줄이기 위해서는 TCP에서 정의한 기능 외에 다른 부분들을 건드려야 한다는 것인데, 여러모로 제한 사항이 많다. 아무리 회선의 대역폭을 늘린다고 해도 기술이 발전하면서 전송해야하는 데이터의 크기도 점점 커지기 때문에 결국 언젠가는 또 느려질 것이고, 회선의 전송 속도 자체를 높힌다고 해도 결국은 빛의 속도 보다 빠르게 전송할 수 없기 때문에 한계가 있다.</p><p>HTTP/3이 UDP 기반인 QUIC 프로토콜을 사용하는 이유가 바로 이런 제약 조건을 뛰어넘기 위해 프로토콜 자체를 손보는 방법을 택한 것이다. 하지만 TCP는 워낙 오래된 프로토콜이기도 하고 커널까지 내려가는 로우 레벨에서 정의되어 있기 때문에 이걸 뜯어고치는 것도 만만치 않은 대작업이라 UDP를 선택한 것이다.</p><p>그럼 한번 TCP가 신뢰성 있는 통신을 위해 사용하는 방법들이 왜 느리다고 하는지 알아보자.</p><h3 id="3-Way-Handshake"><a href="#3-Way-Handshake" class="headerlink" title="3 Way Handshake"></a>3 Way Handshake</h3><p>TCP는 굉장히 친절한 프로토콜이다. 통신을 시작할 때와 종료할 때 서로 준비가 되어있는지를 반드시 먼저 물어보고 패킷을 전송할 순서를 정하고 나서야 본격적인 통신을 시작하기 때문이다.</p><p>이때 통신을 시작할 때 거치는 과정을 <code>3 Way Handshake</code>, 통신을 마칠 때 거치는 과정을 <code>4 Way Handshake</code>라고 한다. 이 포스팅의 목적은 이 과정을 자세히 다루는 것이 아니므로, TCP를 사용하여 통신을 시작할 때 거치는 과정인 3 Way Handshake가 어떤 원리로 작동하는지만 설명하겠다.</p><center><br>  <img src="/2019/10/08/what-is-http3/3way-handshake.png" width="500"><br>  <small>통신을 시작할 때 3 Way Handshake를 하는 과정</small><br>  <br><br></center><p>위 그림을 보면 클라이언트가 처음 서버와 통신을 하기 위해 TCP 연결을 생성할 때 <code>SYN</code>와 <code>ACK</code>이라는 패킷을 주고 받고 있다. 이 패킷 내부에 들어있는 값들을 사용하여 클라이언트와 서버가 서로 보낸 패킷의 순서와 패킷을 제대로 받았는 지를 확인할 수 있는 것이다.</p><p>그리고 이 과정에는 총 3번의 통신이 필요하다. OSX나 Linux를 사용하고 있는 분이라면 터미널에서 <code>tcpdump</code> 유틸리티를 사용하여 이 과정을 직접 눈으로 확인해볼 수 있다.</p><p>단, <code>tcpdump</code>를 아무 옵션 없이 사용하면 디바이스의 모든 패킷을 감시하고 출력하기 때문에 원하는 정보를 찾기 힘들다. 그래서 필자는 루프백에서 동작하고 있는 블로그 서버와의 통신만 캡쳐해보았다.</p><figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tcpdump host localhost -i lo0</span><br><span class="line">IP localhost.53920 > localhost.terabase: Flags [S], seq 1260460927, win 65535</span><br><span class="line">IP localhost.terabase > localhost.53920: Flags [S.], seq 3009967847, ack 1260460928, win 65535</span><br><span class="line">IP localhost.53920 > localhost.terabase: Flags [.], ack 3009967848, win 6379</span><br></pre></td></tr></tbody></table></figure><blockquote><p>보낸 놈 > 받은 놈: Flags [플래그 종류], 헤더의 값들</p></blockquote><p>원래는 이것보다 더 많은 정보가 나오지만, 여기에 전부 기재하기에는 양이 너무 많으니 설명에 필요한 정보만 추려보았다. 이 로그에서 중요한 키워드는 <code>Flag</code>, <code>seq</code>, <code>ack</code> 정도이다. 한번 하나하나 뜯어보도록 하자.</p><p>먼저 <code>localhost.53920</code>은 클라이언트, <code>localhost.terabase</code>는 서버를 의미한다. 각 라인의 첫번째 필드는 <code>보낸 놈 > 받은 놈</code>을 의미하고 있으니, 첫 패킷은 클라이언트가 서버에게, 두 번째 패킷은 서버가 클라이언트에게 보낸 것이라고 할 수 있다. 그리고 각 라인에는 <code>Flag</code>라는 것이 붙어있는데, 플래그는 이 패킷이 어떤 타입의 패킷인지를 알려주는 역할을 한다.</p><table><thead><tr><th>Flag</th><th>이름</th><th>의미</th></tr></thead><tbody><tr><td>S</td><td>SYN</td><td>연결을 생성할 때 클라이언트가 서버에 시퀀스 번호를 보내는 패킷</td></tr><tr><td>S.</td><td>SYN-ACK</td><td>시퀀스 번호를 받은 서버가 ACK 값을 생성하여 클라이언트에게 응답하는 패킷</td></tr><tr><td>.</td><td>ACK</td><td>ACK 값을 사용하여 응답하는 패킷</td></tr></tbody></table><p>이 통신 과정을 거치고 나면 클라이언트와 서버는 신뢰성 있는 TCP 연결을 생성할 수 있고, 이때 총 3회의 통신을 하기 때문에 3 Way Handshake라고 하는 것이다.</p><p>그렇다면 이 과정에서 어떤 일이 벌어지길래 신뢰성 있는 연결을 생성할 수 있다는 것일까? 조금 더 자세히 들여다보면 클라이언트와 서버는 3 Way Handshake를 할 때 대략 이런 과정을 거치고 있다.</p><blockquote><p>1번 라인: 클라이언트가 서버로 시퀀스 번호를 <code>seq</code> 필드에 담아 보냄<br>2번 라인: 서버는 클라이언트가 보내준 시퀀스 번호를 1 증가시켜서 <code>ack</code> 필드에 담아 보냄<br>3번 라인: 클라이언트는 다시 서버로부터 받은 시퀀스 번호를 1 증가시켜서 자신의 <code>ack</code> 필드에 담아 보냄</p></blockquote><p>새로운 TCP 연결을 생성하고자 할 때 클라이언트가 서버에게 랜덤한 시퀀스 번호를 전송함으로써 3 Way Handshake가 시작된다. 이때 생성된 시퀀스 번호는 이후 송신 측이 전송한 패킷을 수신 측이 재조립할때 패킷의 조립 순서를 알려주는 역할을 한다.</p><p>이때 클라이언트와 서버는 상대방이 보내준 <code>seq(시퀀스 번호)</code>를 1 증가 시킨 후 자신의 <code>ack(승인 번호)</code> 필드에 담아서 보내는데, “지금 이 패킷이 니가 전에 보낸 시퀀스 번호의 다음으로 이어지는 패킷이야”라고 말하고 있는 것이다.</p><p>이 3회의 통신이 바로 3 Way Handshake이다. 이 과정을 통해 클라이언트와 서버는 데이터를 주고 받을 준비가 되었다는 것을 서로에게 알려주고 이후 데이터 전송에 필요한 시퀀스 번호를 알 수 있게 된다. 연결을 끊을 때도 마찬가지로 이와 비슷한 과정인 4 Way Handshake를 거치고 나서야 세션을 종료할 수 있으며, 이때는 총 4회의 통신을 통해 연결을 종료한다.</p><p>즉, TCP를 사용하는 이상 본격적인 통신을 시작하기 전에 무조건 저 번거로운 통신 과정을 거쳐야한다는 것이다.</p><p>HTTP/1은 하나의 TCP 연결에 하나의 요청만 처리하고 연결을 끊어버렸기 때문에 매 요청마다 이 번거로운 핸드쉐이크를 거쳐야 했다. 그래서 HTTP/2에서는 핸드쉐이크를 최소화하기 위해서 단일 TCP 연결을 유지하면서 여러 개의 요청을 처리할 수 있도록 변경된 것이다.</p><p>결국 HTTP/1에서 HTTP/2로 넘어갈 때도 핸드쉐이크 과정 자체는 건드리지 않았고 단지 핸드쉐이크가 발생하는 횟수를 최소화함으로써 레이턴시를 줄인 것이다. 이는 TCP를 사용하는 이상 핸드쉐이크가 반드시 필요한 과정이기 때문에 건드리지 못한 것이다. </p><p>그러나 HTTP/3는 UDP를 사용함으로써 이 핸드쉐이크 과정 자체를 날려버리고 다른 방법으로 연결의 신뢰성을 확보함으로써 레이턴시를 줄이는 방법을 택했다.</p><h3 id="HOLB-Head-of-line-Blocking"><a href="#HOLB-Head-of-line-Blocking" class="headerlink" title="HOLB(Head of line Blocking)"></a>HOLB(Head of line Blocking)</h3><p>그 외에도 TCP를 사용하는 기존의 HTTP에는 한 가지 문제가 더 있는데, 바로 <code>HOLB(Head of Line Blocking)</code>이라고 하는 문제이다. 사실 HTTP 레벨에서의 HOLB와 TCP 레벨에서의 HOLB는 다른 의미이기는 하나 결국 어떤 요청에 병목이 생겨서 전체적인 레이턴시가 늘어난다는 맥락으로 본다면 동일하다고 할 수 있다.</p><p>TCP를 사용한 통신에서 패킷은 무조건 정확한 순서대로 처리되어야 한다. 수신 측은 송신 측과 주고받은 시퀀스 번호를 참고하여 패킷을 재조립해야하기 때문이다.</p><p>그래서 통신 중간에 패킷이 손실되면 완전한 데이터로 다시 조립할 수 없기 때문에 절대로 그냥 넘어가지 않는다. 무조건 송신 측은 수신 측이 패킷을 제대로 다 받았다는 것을 확인한 후, 만약 수신 측이 제대로 패킷을 받지 못했으면 해당 패킷을 다시 보내야 한다.</p><p>또한 패킷이 처리되는 순서 또한 정해져있으므로 이전에 받은 패킷을 파싱하기 전까지는 다음 패킷을 처리할 수도 없다. 이렇게 패킷이 중간에 유실되거나 수신 측의 패킷 파싱 속도가 느리다면 통신에 병목이 발생하게 되는 현상을 <code>HOLB</code>라고 부르는 것이다. 이건 TCP 자체의 문제이므로 HTTP/1 뿐만 아니라 HTTP/2도 가지고 있는 문제이다.</p><p>이런 문제들을 해결하기 위해 HTTP/3는 UDP를 기반으로 만들어진 프로토콜인 QUIC 위에서 작동하는 것을 선택한 것이다. 그럼 이제 QUIC가 정확히 어떤 프로토콜인지, UDP를 사용한다는 것이 TCP에 비해서 어떤 장점이 있다는 것인지를 알아보자.</p><h2 id="HTTP-3가-UDP를-사용하는-이유"><a href="#HTTP-3가-UDP를-사용하는-이유" class="headerlink" title="HTTP/3가 UDP를 사용하는 이유"></a>HTTP/3가 UDP를 사용하는 이유</h2><p>HTTP/3는 <code>QUIC</code>을 기반으로 돌아가는 프로토콜이기 때문에 우리가 HTTP/3를 이해하려면 QUIC에 초점을 맞춰야 한다. QUIC은 TCP가 가지고 있는 이런 문제들을 해결하고 레이턴시의 한계를 뛰어넘고자 구글이 개발한 UDP 기반의 프로토콜이다.</p><p>QUIC은 처음부터 TCP의 핸드쉐이크 과정을 최적화하는 것에 초점을 맞추어 설계되었고, UDP를 사용함으로써 이를 실현해낼 수 있었다.</p><center><br>  <img src="/2019/10/08/what-is-http3/quic.png" width="350"><br>  <br><br></center><p>UDP는 User Datagram Protocol이라는 이름에서도 알 수 있듯이 데이터그램 방식을 사용하는 프로토콜이기 때문에 애초에 각각의 패킷 간의 순서가 존재하지 않는 독립적인 패킷을 사용한다. 또한 데이터그램 방식은 패킷의 목적지만 정해져있다면 중간 경로는 어딜 타든 신경쓰지 않기 때문에 종단 간의 연결 설정 또한 하지 않는다. 즉, 핸드쉐이크 과정이 필요없다는 것이다.</p><p>결론적으로 UDP는 TCP가 신뢰성을 확보하기 위해 거치던 많은 과정을 거치지 않기 때문에 속도가 더 빠를 수 밖에 없다는 것인데, 그렇다면 UDP를 사용하게되면 기존의 TCP가 가지던 신뢰성과 패킷의 무결함도 함께 사라지는 걸까?</p><p>아니 그렇지 않다. UDP를 사용하더라도 기존의 TCP가 가지고 있던 기능을 전부 구현할 수 있다. UDP의 진짜 장점은 바로 <code>커스터마이징이 용이하다</code>는 것이기 때문이다.</p><h3 id="UDP는-하얀-도화지-같은-프로토콜이다"><a href="#UDP는-하얀-도화지-같은-프로토콜이다" class="headerlink" title="UDP는 하얀 도화지 같은 프로토콜이다"></a>UDP는 하얀 도화지 같은 프로토콜이다</h3><p>필자는 학교에서 UDP와 TCP의 가장 큰 차이점으로 <code>UDP는 TCP보다 신뢰성이 없는 대신 빠르다</code>라고 배웠었는데, 사실 이 말은 반은 맞고 반은 틀리다.</p><p>왜냐면 애초에 UDP는 데이터 전송을 제외한 그 어떤 기능도 정의되어 있지 않은 프로토콜이기 때문에 프로토콜 자체적으로 신뢰성을 보장하지 않는 것은 맞지만, 다르게 말하자면 데이터 전송 기능을 제외한 아무 기능이 없는 백지 상태의 프로토콜이라고도 할 수 있기 때문이다. TCP가 신뢰성있는 연결과 혼잡 제어 등을 위해 얼마나 많은 기능을 가지고 있는 지는 TCP의 헤더를 보면 대충 각이 나온다.</p><center><br>  <img src="/2019/10/08/what-is-http3/tcp-header.png"><br>  <small>이미 정보들이 뚱뚱하게 들어찬 TCP의 헤더</small><br>  <br><br></center><p>TCP의 경우 워낙 오래 전에 설계되기도 했고, 이런 저런 기능이 워낙 많이 포함된 프로토콜이다보니 이미 헤더가 거의 풀방이다. TCP에 기본적으로 정의되어 있는 기능 외에 다른 추가 기능을 구현하고 싶다면 가장 하단에 있는 <code>옵션(Options)</code> 필드를 사용해야 하는데, 옵션 필드도 무한정 배당 해줄 수는 없으니 최대 크기를 <code>320 bits</code>로 정해놓았다.</p><p>그러나 TCP의 단점을 보완하기 위해 나중에 정의된 <code>MSS(Maximum Segment Size)</code>, <code>WSCALE(Window Scale factor)</code>, <code>SACK(Selective ACK)</code> 등 많은 옵션들이 이미 옵션 필드를 차지하고 있기 때문에 실질적으로 사용자가 커스텀 기능을 구현할 수 있는 자리는 거의 남지도 않았다.</p><p>반면 UDP는 데이터 전송 자체에만 초점을 맞추고 설계되었기 때문에 헤더에 진짜 아무 것도 없다.</p><center><br>  <img src="/2019/10/08/what-is-http3/udp-header.png"><br>  <small>TCP와 비교해보면 확실히 휑한 UDP의 헤더</small><br>  <br><br></center><p>UDP의 헤더에는 출발지와 도착지, 패킷의 길이, 체크섬 밖에 없다. 이때 체크섬은 패킷의 무결성을 확인하기 위해 사용되는데, TCP의 체크섬과는 다르게 UDP의 체크섬은 사용해도 되고 안해도 되는 옵션이다.</p><p>즉, UDP 프로토콜 자체는 TCP보다 신뢰성이 낮기도 하고 흐름 제어도 안되지만, 이후 개발자가 어플리케이션에서 구현을 어떻게 하냐에 따라서 TCP와 비슷한 수준의 기능을 가질 수도 있다는 것이다.</p><p>물론 TCP가 신뢰성을 확보하기위해 이런 저런 기능을 제공해주는 것이 개발자 입장에서는 편하고 좋지만, 한가지 슬픈 점은 이 기능들이 프로토콜 자체에 정의된 <code>필수 과정</code>이라서 개발자가 맘대로 커스터마이징 할 수 없다는 것이다. 결국 여기서 발생하는 레이턴시들을 어떻게 더 줄여볼 시도조차 하기 힘들다.</p><center><br>  <img src="/2019/10/08/what-is-http3/tcp-tls.png" width="400"><br>  <small>TCP에 TLS까지 사용한다면 통신을 시작하기도 전에 이렇게 많은 과정을 거쳐야 한다</small><br>  <br><br></center><p>결국 레이턴시를 줄이려면 프로토콜 외적인 것들을 건드려야 하는데, 위에서 이야기 했듯이 일반적인 개발자가 통신 과정에서 건드릴 수 있는 영역은 한계가 있기 때문에 이 또한 어려운 것이 사실이다.<small>(통신 업계의 큰 손 형님들이 인프라를 깔아주시는 걸 기다리자)</small></p><p>아직 TCP와 UDP의 차이가 잘 와닿지 않는다면 <code>좋은 기능이 다 들어있는 무거운 라이브러리</code>와 <code>필요한 기능만 들어있는 가벼운 라이브러리</code>로 비교해보면 조금 더 이해가 빠를 것 같다.</p><p>예를 들어 JavaScript 진영에서 많이 사용하는 <code>lodash</code>와 같은 라이브러리는 기능은 무궁무진하고 사용자에게 큰 편리함을 주지만, 보통 lodash의 모든 메소드를 다 사용하는 사람은 많지 않을 것이다. 결국 편하긴 하지만 내가 사용하지 않는 기능까지 전부 내 JS 번들에 포함시켜야 한다는 부담이 있다.</p><p>반면 단순한 하나의 기능을 제공하는 라이브러리는 lodash보다 기능은 많지 않아도 내가 원하는 부분만 쏙쏙 골라서 사용할 수 있다는 장점이 있다. 하지만 해당 라이브러리에서 지원하지 않는 기능은 직접 구현해야하는 번거로움이 있을 수도 있다. 이때 lodash와 같은 만능 라이브러리가 TCP, 하나의 기능만 제공하는 작은 라이브러리가 UDP인 것이다.</p><p>이렇듯 구글이 QUIC을 만들 때 UDP를 선택한 이유에는 기존의 TCP를 수정하기가 어려운데다가, 백지 상태나 다름 없는 UDP를 사용함으로써 QUIC의 기능을 확장하기 쉽다고 생각했기 때문이라는 것도 있다.</p><h2 id="HTTP-3가-UDP를-사용함으로써-기존-프로토콜보다-나아진-점"><a href="#HTTP-3가-UDP를-사용함으로써-기존-프로토콜보다-나아진-점" class="headerlink" title="HTTP/3가 UDP를 사용함으로써 기존 프로토콜보다 나아진 점"></a>HTTP/3가 UDP를 사용함으로써 기존 프로토콜보다 나아진 점</h2><p>지금까지 HTTP/3의 뼈대로 사용되는 QUIC이 왜 TCP가 아닌 UDP를 사용했는지 간략하게 알아보았다. 그렇다면 실제로 UDP를 사용함으로써 얻는 이득에는 무엇이 있을까? 진짜로 HTTP/3는 UDP를 사용함으로써 기존의 <code>HTTP+TCP+TLS</code>를 사용했던 방법보다 더 좋아진 것 일까?</p><p>그에 대한 해답은 Chromium Projects의 <a href="https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit" target="_blank" rel="noopener">QUIC Overview</a>라는 문서에서 찾을 수 있었다. 한번 구글이 이야기하는 QUIC의 장점에 대해서 살펴보자.</p><h3 id="연결-설정-시-레이턴시-감소"><a href="#연결-설정-시-레이턴시-감소" class="headerlink" title="연결 설정 시 레이턴시 감소"></a>연결 설정 시 레이턴시 감소</h3><p>QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3 Way Handshake 과정을 거치지 않아도 된다. 클라이언트가 보낸 요청을 서버가 처리한 후 다시 클라이언트로 응답해주는 사이클을 <code>RTT(Round Trip Time)</code>이라고 하는데, TCP는 연결을 생성하기 위해 기본적으로 <code>1 RTT</code>가 필요하고, 여기에 TLS를 사용한 암호화까지 하려고 한다면 TLS의 자체 핸드쉐이크까지 더해져 총 <code>3 RTT</code>가 필요하다.</p><p>반면 QUIC은 첫 연결 설정에 <code>1 RTT</code>만 소요된다. 클라이언트가 서버에 어떤 신호를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할 수 있다는 것이다. 즉, 연결 설정에 소요되는 시간이 반 정도 밖에 안된다.</p><center><br>  <img src="/2019/10/08/what-is-http3/gcp-cloud-cdn-performance.gif" width="500"><br>  <br><br></center><p>어떻게 이게 가능한 걸까? 그 이유는 생각보다 간단하다. 첫번째 핸드쉐이크를 거칠 때, 연결 설정에 필요한 정보와 함께 데이터도 보내버리는 것이다. <code>TCP+TLS</code>는 데이터를 보내기 전에 신뢰성있는 연결과 암호화에 필요한 모든 정보를 교환하고 유효성을 검사한 뒤에 데이터를 교환하지만, QUIC은 묻지도 따지지도 않고 그냥 바로 데이터부터 꽂아버리고 시작한다.</p><p>이 과정에 대해서는 2015년 IEEE Symposium에서 발표된 <code>How Secure and Quick is QUIC?</code>이라는 세션에서 자세히 들어볼 수 있다.</p><center><br>  <div class="video-container"><iframe src="//www.youtube.com/embed/vXgbPZ-1-us?start=206" frameborder="0" allowfullscreen></iframe></div><br>  <small>한 손 주머니에 꽂고 발표하는 모습에서 스웩이 넘친다</small><br>  <br><br></center><p>결국 이 영상에서 말하고자 하는 것은 TCP+TLS는 서로 자신의 세션 키를 주고 받아 암호화된 연결을 성립하는 과정을 거치고 나서야 세션 키와 함께 데이터를 교환할 수 있지만, QUIC은 서로의 세션 키를 교환하기도 전에 데이터를 교환할 수 있기 때문에 연결 설정이 더 빠르다는 것이다.</p><p>단, 클라이언트가 서버로 첫 요청을 보낼 때는 서버의 세션 키를 모르는 상태이기 때문에 목적지인 서버의 Connection ID를 사용하여 생성한 특별한 키인 <code>초기화 키(Initial Key)</code>를 사용하여 통신을 암호화 한다. 이 과정에 대한 자세한 설명은 QUIC 작업 그룹의 <a href="https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2" target="_blank" rel="noopener">Using TLS to Secure QUIC</a> 문서에서 확인 해볼 수 있다.</p><p>그리고 한번 연결에 성공했다면 서버는 그 설정을 캐싱해놓고 있다가, 다음 연결 때는 캐싱해놓은 설정을 사용하여 바로 연결을 성립시키기 때문에 <code>0 RTT</code>만으로 바로 통신을 시작할 수도 있다. 이런 점들 때문에 QUIC은 기존의 TCP+TLS 방식에 비해 레이턴시를 더 줄일 수 있었던 것이다.</p><p>참고로 이 세션이 발표될 당시에는 <code>TLS 1.3</code>이 나오기 전이라 따로 언급이 되지 않았지만, 지금은 <code>TCP Fast Open</code>과 <code>TLS 1.3</code>을 사용하여 QUIC와 비슷한 과정을 통해 연결을 설정함으로써 TCP를 사용하더라도 동일한 이점을 가져갈 수도 있긴하다.</p><p>그러나 TCP SYN 패킷은 한 패킷당 약 <code>1460 Byte</code>만 전송할 수 있도록 제한하지만 QUIC은 데이터 전체를 첫 번째 라운드 트립에 포함해서 전송할 수 있기 때문에 주고 받아야할 데이터가 큰 경우에는 여전히 QUIC가 유리하다고 할 수 있다.</p><h3 id="패킷-손실-감지에-걸리는-시간-단축"><a href="#패킷-손실-감지에-걸리는-시간-단축" class="headerlink" title="패킷 손실 감지에 걸리는 시간 단축"></a>패킷 손실 감지에 걸리는 시간 단축</h3><p>QUIC도 TCP와 마찬가지로 전송하는 패킷에 대한 흐름 제어를 해야한다. 왜냐면 QUIC든 TCP든 결국 본질적으로는 <code>ARQ</code> 방식을 사용하는 프로토콜이기 때문이다. 통신과정에서 발생한 에러를 어떻게 처리할 것인지를 이야기하는 것인데, ARQ 방식은 에러가 발생하면 재전송을 통해 에러를 복구하는 방식을 말하는 것이다.</p><p>TCP는 여러 ARQ 방식 중에서 <code>Stop and Wait ARQ</code> 방식을 사용하고 있다. 이 방식은 송신 측이 패킷을 보낸 후 타이머를 사용하여 시간을 재고, 일정 시간이 경과해도 수신 측이 적절한 답변을 주지 않는다면 패킷이 손실된 것으로 판단하고 해당 패킷을 다시 보내는 방식이다.</p><p>우선 2017년 구글에서 발표한 <a href="https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1" target="_blank" rel="noopener">QUIC Loss Detection and Congestion Control</a>에 따르면, QUIC은 기본적으로 TCP와 유사한 방법으로 패킷 손실을 탐지하나, 몇 가지 개선 사항을 추가한 것으로 보인다.</p><p>TCP에서 패킷 손실 감지에 대한 대표적인 문제는 송신 측이 패킷을 수신측으로 보내고 난 후 얼마나 기다려줄 것인가, 즉 타임 아웃을 언제 낼 것인가를 동적으로 계산해야한다는 것이다. 이때 이 시간을 <code>RTO(Retransmission Time Out)</code>라고 하는데, 이때 필요한 데이터가 바로 <code>RTT(Round Trip Time)</code>들의 샘플들이다.</p><p>한번 패킷을 보낸 후 잘 받았다는 응답을 받을 때 걸렸던 시간들을 측정해서 동적으로 타임 아웃을 정하는 것이다. 즉, RTT 샘플을 측정하기 위해서는 반드시 송신 측으로 부터 ACK를 받아야하는데, 정상적인 상황에서는 딱히 문제가 없으나 타임 아웃이 발생해서 패킷 손실이 발생하게 되면 RTT 계산이 애매해진다.</p><blockquote><p>패킷 전송 -> 타임 아웃 -> 패킷 재전송 -> ACK 받음!<br><small>(근데 이거 첫 번째로 보낸 패킷의 ACK야? 두 번째로 보낸 패킷의 ACK야?)</small></p></blockquote><p>이때 이 ACK가 어느 패킷에 대한 응답인지 알기 위해서는 타임스탬프를 패킷에 찍어주는 등 별도의 방법을 또 사용해야하고, 또 이를 위한 패킷 검사도 따로 해줘야 한다. 이를 <code>재전송 모호성(Retransmission Ambiguity)</code>이라고 한다.</p><p>이 문제를 해결하기 위해 QUIC는 헤더에 별도의 패킷 번호 공간을 부여했다. 이 패킷 번호는 패킷의 전송 순서 자체만을 나타내며, 재전송시 동일한 번호가 전송되는 시퀀스 번호와는 다르게 매 전송마다 모노토닉하게 패킷 번호가 증가하기 때문에, 패킷의 전송 순서를 명확하게 파악할 수 있다.</p><p>TCP의 경우 타임스탬프를 사용할 수 있는 상황이라면 타임스탬프를 통해 패킷의 전송 순서를 파악할 수 있지만, 만약 사용할 수 없는 경우 시퀀스 번호에 기반하여 암묵적으로 전송 순서를 추론할 수 밖에 없지만, QUIC는 이런 불필요한 과정을 패킷마다 고유한 패킷 번호를 통해 타파함으로써 패킷 손실 감지에 걸리는 시간을 단축할 수 있었다.</p><p>이 외에도 QUIC는 대략 5가지 정도의 기법을 사용하여 이 패킷 손실 감지에 걸리는 시간을 단축시켰는데, 자세한 내용은 <a href="https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1" target="_blank" rel="noopener">QUIC Loss Detection and Congestion Control</a>의 <code>3.1 Relevant Differences Between QUIC and TCP</code> 챕터를 한번 읽어보는 것을 추천한다.</p><h3 id="멀티플렉싱을-지원"><a href="#멀티플렉싱을-지원" class="headerlink" title="멀티플렉싱을 지원"></a>멀티플렉싱을 지원</h3><p><code>멀티플렉싱(Multiplexing)</code>은 위에서 TCP의 단점으로 언급했던 <code>HOLB(Head of Line Blocking)</code>을 방지하기 때문에 매우 중요하다. 여러 개의 스트림을 사용하면, 그 중 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 굴릴 수 있기 때문이다.</p><p>참고로 멀티플렉싱은 여러 개의 TCP 연결을 만든다는 의미가 아니라, 단일 연결 안에서 몇 가지 얌생이를 사용하여 여러 개의 데이터를 섞이지 않게 보내는 기법이다. 이때 각각의 데이터의 흐름을 <code>스트림</code>이라고 하는 것이다.</p><p>HTTP/1의 경우는 하나의 TCP 연결에 하나의 스트림만 사용하기 때문에 HOLB 문제에서 벗어날 수 없었다. 또한 한번의 전송이 끝나게 되면 연결이 끊어지기 때문에 다시 연결을 만들기 위해서는 번거로운 핸드쉐이크 과정을 또 겪어야 했다.</p><p>비록 <code>keep-alive</code> 옵션을 통해 어느 정도의 시간 동안 연결을 유지할 수는 있지만 결국 일정 시간 안에 액세스가 없다면 연결이 끊어지게 되는 것은 똑같다.</p><p>그리고 HTTP/2는 하나의 TCP 연결 안에서 여러 개의 스트림을 처리하는 멀티플렉싱 기법을 도입하여 성능을 끌어올린 케이스이다. 이 경우 한번의 TCP 연결로 여러 개의 데이터를 전송할 수 있기 때문에 핸드쉐이크 횟수도 줄어들게 되어 효율적인 데이터 전송을 할 수 있게 된다.</p><center><br>  <img src="/2019/10/08/what-is-http3/multiplexing.svg" width="500"><br>  <small>HTTP/3도 HTTP/2와 같은 멀티플렉싱을 지원한다.</small><br>  <br><br></center><p>QUIC 또한 HTTP/2와 동일하게 멀티플렉싱을 지원하기 때문에, 이런 이점을 그대로 가져가고 있다. 혹여나 하나의 스트림에서 문제가 발생한다고 해도 다른 스트림은 지킬 수 있게 되어 이런 문제에서 자유로울 수 있다.</p><h3 id="클라이언트의-IP가-바뀌어도-연결이-유지됨"><a href="#클라이언트의-IP가-바뀌어도-연결이-유지됨" class="headerlink" title="클라이언트의 IP가 바뀌어도 연결이 유지됨"></a>클라이언트의 IP가 바뀌어도 연결이 유지됨</h3><p>TCP의 경우 소스의 IP 주소와 포트, 연결 대상의 IP 주소와 포트로 연결을 식별하기 때문에 클라이언트의 IP가 바뀌는 상황이 발생하면 연결이 끊어져 버린다. 연결이 끊어졌으니 다시 연결을 생성하기 위해 결국 눈물나는 3 Way Handshake 과정을 다시 거쳐야한다는 것이고, 이 과정에서 다시 레이턴시가 발생한다.</p><p>게다가 요즘에는 모바일로 인터넷을 사용하는 경우가 많기 때문에 Wi-fi에서 셀룰러로 전환되거나 그 반대의 경우, 혹은 다른 Wi-fi로 연결되는 경우와 같이 클라이언트의 IP가 변경되는 일이 굉장히 잦아서 이 문제가 더 눈에 띈다.</p><p>반면 QUIC은 Connection ID를 사용하여 서버와 연결을 생성한다. Connection ID는 랜덤한 값일 뿐, 클라이언트의 IP와는 전혀 무관한 데이터이기 때문에 클라이언트의 IP가 변경되더라도 기존의 연결을 계속 유지할 수 있다. 이는 새로 연결을 생성할 때 거쳐야하는 핸드쉐이크 과정을 생략할 수 있다는 의미이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 HTTP/3와 QUIC을 제대로 설명하기 위해서는 네트워크에 대한 기본 개념들이 필수적으로 동반되야하기 때문에 이 짧은 포스팅 만으로 세부적인 설명을 하기 힘든 부분이 있었다. 최대한 자세하게 작성해보려고 했지만 생각보다 글이 너무 길어지게 되어서 분량 조절을 조금 하려고 한다.</p><p>이번에 HTTP/3를 공부해보고 여러가지 자료를 찾아보면서 느낀 점은 “뭐가 이렇게 많이 바뀌었어?” 였던 것 같다. 일단 TCP부터 갖다 버렸으니 뭐가 많이 바뀔만 하긴 했지만, HTTP/2를 사용해본지도 몇 달 밖에 되지 않은 필자의 입장에서는 조금 당황스럽기는 했다.<small>(HTTP를 만든다면서 TCP를 갖다 버린 건 아직도 신기하다)</small></p><p>사실 개발자들이 HTTP/2를 사용하든 HTTP/3를 사용하든 한국에서 인터넷을 사용하고 있는 사용자는 별로 큰 차이를 못 느낄 것이다. 한국은 워낙 땅덩이도 작고 통신 인프라도 좋다보니 핸드쉐이크 레이턴시고 나발이고 그냥 인프라로 대충 커버칠 수 있지만, 그래도 상대적으로 통신 인프라가 빈약한 나라의 경우에는 꽤 큰 차이가 느껴질 수도 있을 것 같다.</p><p>필자가 이 포스팅에서는 HTTP/3와 UDP의 장점만을 이야기했지만, 사실 많은 사람들이 TCP를 버리고 UDP로 갈아타는 것에 대해서 걱정하고 있다. 당연히 완벽한 기술이란 없으니 문제도 있을 것이다.</p><p>그러나 기존의 HTTP와 TCP가 가지고 있는 한계를 돌파하기 위한 시도로는 굉장히 좋은 것 같다. 마치 엔비디아의 RTX 시리즈 같은 느낌이랄까.</p><p>이상으로 HTTP/3는 왜 UDP를 선택한 것일까? 포스팅을 마친다.</p><h2 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h2><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46403.pdf" target="_blank" rel="noopener">The QUIC Transport Protocol: Design and Internet-Scale Deployment</a></li><li><a href="https://medium.com/codavel-blog/quic-vs-tcp-tls-and-why-quic-is-not-the-next-big-thing-d4ef59143efd" target="_blank" rel="noopener">QUIC vs TCP+TLS - and why QUIC is not the next big thing</a></li><li><a href="https://blog.cloudflare.com/http3-the-past-present-and-future/" target="_blank" rel="noopener">HTTP/3: the past, the present, and the future</a></li><li><a href="https://www.saturnsoft.net/network/2019/03/21/quic-http3-1/" target="_blank" rel="noopener">QUIC과 HTTP/3 - 1.UDP기반 전송 프로토콜의 대두</a></li><li><a href="https://www.chromium.org/quic" target="_blank" rel="noopener">QUIC, a multiplexed stream transport over UDP</a></li><li><a href="https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2" target="_blank" rel="noopener">Using TLS to Secure QUIC</a></li><li><a href="https://blog.cloudflare.com/the-road-to-quic/" target="_blank" rel="noopener">The Road to QUIC</a></li></ul></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/10/08/what-is-http3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>블로그 개설을 망설이고 있는 사람들에게</title>
      <link>https://evan-moon.github.io/2019/09/28/how-do-i-write-postings/</link>
      <guid>https://evan-moon.github.io/2019/09/28/how-do-i-write-postings/</guid>
      <pubDate>Fri, 27 Sep 2019 23:43:03 GMT</pubDate>
      <description>
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;과거에는 블로그를 운영하는 개발자들이 오히려 손에 꼽을 정도였지만, 최근 많은 개발자들이 블로그를 운영하며 다양한 주제에 대한 자신의 생각이나 특정 기술에 대한 분석을 포스팅으로 기재하고 공유하고 있다. 하지만 필자는 개인적으로 블로그를 운영하는 것이 생각보다 진입 장벽이 높다고 생각하는데, 그건 블로그 세팅과 같은 기술적인 이유 때문이 아니다.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
      
      </description>
      
      <content:encoded><![CDATA[<html><head></head><body><p>과거에는 블로그를 운영하는 개발자들이 오히려 손에 꼽을 정도였지만, 최근 많은 개발자들이 블로그를 운영하며 다양한 주제에 대한 자신의 생각이나 특정 기술에 대한 분석을 포스팅으로 기재하고 공유하고 있다. 하지만 필자는 개인적으로 블로그를 운영하는 것이 생각보다 진입 장벽이 높다고 생각하는데, 그건 블로그 세팅과 같은 기술적인 이유 때문이 아니다.</p><a id="more"></a><p>블로그 세팅은 velog나 티스토리같은 블로그 전문 서비스를 사용할 수도 있고 깃허브 호스팅과 <code>jekyll</code>이나 <code>hexo</code>같은 정적 사이트 생성기를 사용하여 세팅할 수도 있는데, 사실 뭘 사용하든간에 그런 건 개발자들에게 크게 어려운 문제가 아니다. 회사나 학교에서 맨날 복잡한 문제로 삽질하면서 밥 벌어 먹고 사는 사람들한테 정적 사이트 생성기를 세팅할 때 발생하는 문제를 해결하는 것 정도는 꽤 쉬운 편이라고 생각한다.</p><p>진짜 문제는 블로그를 세팅한 다음부터 발생한다. 이런저런 삽질 끝에 블로그 세팅을 끝내고 나면 이제 글만 쓰면 되는데, 음… 막상 하얗게 비어있는 에디터를 보고 있으면 머리 속도 함께 햐얘지는 기분이 들기 시작하기 때문이다.</p><center><br>  <img src="/2019/09/28/how-do-i-write-postings/blank_page.png" width="500"><br>  <small>뭘 어떻게 쓰기 시작해야 하지…?</small><br>  <br><br></center><p>글쓰기도 프로그래밍과 마찬가지로 꾸준한 연습과 연구가 필요한 영역이다. 필자 같은 경우는 평균적으로 <code>8000~10000</code> 단어 정도의 포스팅을 작성하는데, 이렇게 하나의 주제를 가지고 긴 호흡으로 글을 작성하게 되면 조금만 딴 생각을 해도 금새 주제가 흐트러지기 쉽상이기 때문에 꽤 많은 집중을 요한다.</p><p>사실 필자 같은 경우만 해도 평소에 글쓰기를 그렇게 많이 해볼 기회가 많지 않았다. 물론 최근에 <a href="http://www.yes24.com/Product/Goods/76639545" target="_blank" rel="noopener">커피 한 잔 마시며 끝내는 VueJS</a>라는 책을 집필하면서 글을 토할 정도로 쓰기는 했지만, 이건 조금 특이한 케이스이기 때문에 제외하고 생각해본다면 아마 대학교 때 과제로 레포트를 썼던 것이 자신의 생각을 길게 적어본 마지막 경험인 것 같다.</p><p>필자가 주변 사람들한테 블로그를 써보라고 권했을 때 많은 분들이 <code>뭘 써야할 지 모르겠다</code>라고 이야기하고는 했는데, 사실 일상 속에서 자기 생각을 글로 표현해볼 기회 자체가 많지 않기 때문에 글을 쓴다는 것에 많은 분들이 어려움을 느끼는 부분이 있는 것 같다.</p><p>그래서 이번 포스팅에서는 블로그 개설을 망설이고 있는 분들이 고민하고 있는 몇 가지 주제에 대해서 이야기를 한번 해보려고 한다.</p><h2 id="어떤-주제로-글을-써야할까"><a href="#어떤-주제로-글을-써야할까" class="headerlink" title="어떤 주제로 글을 써야할까?"></a>어떤 주제로 글을 써야할까?</h2><p>일단 첫번째로 이야기하고 싶은 것은 바로 <code>포스팅의 주제</code>이다. 많은 분들이 첫 포스팅을 작성할 때 어떤 주제를 선정해야하는지 고민하시는데, 사실 주제는 뭐가 됐든 크게 의미없다.</p><p>주제에 대해서 이야기한다고 하면서 주제는 큰 의미가 없다고 하니 이게 무슨 소리인가 싶겠지만, 진짜로 별 의미 없다. 그냥 아무거나 써도 된다는 것이다.</p><p>필자 주변에 있는 분들의 이야기를 들어보면 첫 포스팅의 주제를 정할 때 고민하는 것이 대부분 비슷했다. 내가 알고 있는 지식은 남들도 다 알고 있을 것이라고 하시는 분도 있었고, 내가 알고 있는 지식이 너무 쉽고 간단한 것이라서 섣불리 공유하기가 조금 꺼려진다고 하시는 분도 있었다.</p><p>그런데 이유가 뭐가 됐든 사실 별로 상관이 없는 것이, 일단 블로그 포스팅은 책과 같이 출판하고 나면 수정하기 힘든 컨텐츠가 아니다. 마음에 안들면 나중에 지워버릴 수도 있고, 내용을 수정하는 것도 자유롭다. 그렇기 때문에 나중에 다시 포스팅을 읽어 보았을 때 주제가 이상하다고 느껴지거나 문체가 오글거려서 도저히 못 봐주겠으면 그냥 미련없이 <code>rm</code> 명령어를 때려버리면 그만이다.</p><p>그래서 필자는 <code>어떤 주제를 고르는 것이 좋다</code> 같은 이야기는 하지 않을 것이다. 대신 주제 자체가 왜 그리 중요하지 않은지, 그리고 필자가 실수했던 경험을 토대로 어떤 주제를 피해야하는지에 대한 이야기를 조금 해보려고 한다.</p><h3 id="내가-알고-있는-지식은-생각보다-값지다"><a href="#내가-알고-있는-지식은-생각보다-값지다" class="headerlink" title="내가 알고 있는 지식은 생각보다 값지다"></a>내가 알고 있는 지식은 생각보다 값지다</h3><p>일단 필자가 <code>주제는 별로 중요하지 않다</code>라고 하는 이유 중 하나는 여러분이 블로그 포스팅을 통해 무엇을 적든 간에 분명 누군가에게는 도움이 될 것이기 때문이다.</p><p>의외로 많은 분들이 <code>내가 알고 있는 것은 남들도 알고 있을 것이다</code>라는 마음 때문에 자신이 알고 있는 것을 공개적으로 공유하기를 꺼려한다. 물론 이건 겸손한 마음에서 우러나오는 생각이지만 그래도 여러분이 알고 있는 지식을 공유하는 행위 자체가 생각보다 값지다는 사실을 알아야 한다.</p><p>여러분이 선정한 주제가 이미 해당 분야에서 널리 알려진 지식일지라도 그 지식에 대해서 아직 모르는 사람도 분명 존재한다. 필자는 개인적으로 그 사람이 단 1명일지라도 내 포스팅을 읽고 그 사람에게 도움이 되었다면 잘 쓴거라고 생각한다.</p><p>이렇게 자신의 지식이나 생각을 아무 대가 없이 타인과 공유하는 것에 대해 익숙한 문화가 개발자들의 장점이 아닐까?</p><center><br>  <img src="/2019/09/28/how-do-i-write-postings/open_source.jpeg" width="500"><br>  <small>우리가 좋아하는 오픈소스도 결국은 지식과 기술을 공유하는 것이다</small><br>  <br><br></center><p>사실 지금은 필자가 이렇게 말하고는 있지만, 필자도 본격적으로 블로그에 포스팅을 작성하기 시작했을 때 제일 고민했던 게 이런 문제였다.</p><p>예를 들어 필자가 작성했던 <a href="/2019/06/18/javascript-let-const/" title="JavaScript의 let과 const, 그리고 TDZ">JavaScript의 let과 const, 그리고 TDZ</a> 포스팅 같은 경우도 쓰기 전에 고민을 많이 했었다. 필자가 해당 포스팅을 작성할 당시인 2019년 6월은 이미 JavaScript ES6 버전이 배포된지 지나도 한참 지난 후였기 때문에 이제 와서 이 주제에 대해서 작성하기에는 너무 늦은 게 아닌가라는 생각을 했었다.</p><p>그러나 막상 포스팅을 작성하고나니 생각보다 많은 분들에게서 도움이 되었다는 메세지를 받을 수 있었다. 필자는 이 지식이 별로 중요한 지식이 아니라고 생각했지만 누군가에게는 도움이 되었다는 것이다.</p><p>비록 필자가 해당 포스팅을 작성한 시점은 JavaScript ES6가 배포된 지 3년이 지난 후였지만 그때도 JS를 처음 접하는 사람들은 있을 수밖에 없고, 그 분들에게는 필자의 포스팅이 큰 도움이 된 것이다.</p><p>사람마다 알고 있는 지식과 모르고 있는 지식은 전부 다를 수 밖에 없다. 내가 <code>A</code>나 <code>B</code>를 알고 있다고 해서 다른 사람들도 모두 <code>A</code>나 <code>B</code>를 알고 있는 것이 아니라는 소리다. 개발자들은 모두 각자가 걸어온 길에 따라 각기 다른 기술에 대한 전문성을 보유한 사람들이기 때문에 이런 지식의 공유가 더 가치있는 것이다.</p><p>그러니까 이미 내가 알고 있는 지식을 저평가 하지말고 일단 그 지식에 대한 주제로 포스팅을 한번 작성해보자. 포스팅을 작성하기 위해서는 기존에 알고 있는 지식이라고 할 지라도 다시 정리하는 과정이 필요하기 때문에 스스로도 지식의 깊이를 다질 수 있는 좋은 기회가 된다.</p><h3 id="처음부터-너무-어려운-주제는-피하자"><a href="#처음부터-너무-어려운-주제는-피하자" class="headerlink" title="처음부터 너무 어려운 주제는 피하자"></a>처음부터 너무 어려운 주제는 피하자</h3><p>이건 필자가 처음 블로그를 작성할 때 실수했던 것이다. 사실 필자가 본격적으로 블로그에 포스팅을 기재하기 시작한 것은 2019년 6월, 즉 약 3개월 전이지만 처음 포스팅을 작성하기 시작한 것은 2017년 쯤이다. 그 당시에는 포스팅을 상당히 뜸하게 올렸는데, 그 이유는 바로 <code>주제 선정에 대해 눈이 너무 높아서</code> 였다.</p><p>당시 필자가 생각하기에는 이미 많은 개발자들이 블로그를 운영하고 있기 때문에 너무 일반적인 주제로 포스팅을 작성하면 별로 눈에 띄지도 않을 것이고 PR에도 별로 도움이 안될 것이라고 생각했었다.</p><p>그래서 필자는 포스팅 주제를 선택할 때 남들이 많이 선택하지 않은 주제나 최신 기술, 난이도가 어느 정도 있다고 생각하는 것들 위주로 선택했는데, 지금 생각해보면 이거 그냥 <code>허세</code>다. 포스팅만 어려운 주제로 쓴다고 해서 내가 진짜로 가치있는 사람이 되는 것이 아니기 때문이다.</p><center><br>  <img src="/2019/09/28/how-do-i-write-postings/bluffing.jpg" width="500"><br>  <small>뭔가 있어보이는 포스팅을 쓰고 싶었다</small><br>  <br><br></center><p>문제는 남들이 어렵다고 생각할 정도인 주제는 당연히 필자한테도 어렵다는 것이다. 알다시피 기술 포스팅을 작성하기 위해서는 그 주제에 대해서 단순한 이해 정도가 아니라 남들에게 쉽게 설명할 수 있을 정도의 이해도가 필요하기 때문에 일반적으로 투자하는 공부 시간보다 더 많은 시간을 투자해서 공부하게된다.</p><p>어떻게 보면 포스팅을 작성하기 위해 어려운 주제에 대한 공부를 강제로 하게되니 좋다고 생각할 수도 있지만, 이렇게 되면 포스팅을 하나 작성하는데 투자해야하는 시간이 거의 몇 주 단위가 될 수도 있다.</p><p>필자는 스스로도 많은 공부가 필요한 주제들로만 포스팅을 작성하려고 했기 때문에 하나의 포스팅을 작성하기 위해서 많은 연구가 필요했다. 그 결과 포스팅을 하나 작성하는데 걸리는 시간이 점점 늘어나기 시작하면서 포스팅 작성에 대한 의욕 또한 점차 떨어지게 되어, 결국 꾸준한 포스팅 업로드를 하지 못하게 되었다.</p><p>블로그를 운영하면서 중요한 것은 주제의 난이도가 아니라 양질의 포스팅을 꾸준히 생산하는 습관을 들이는 것이다. 물론 컴포트존을 벗어나고자 하는 목적으로 가끔씩 본인의 수준보다 약간 더 어려운 수준의 주제를 선정하고 공부를 하는 것은 좋지만, 필자처럼 모든 포스팅을 그런 식으로 작성하려고 하면 꾸준히 포스팅을 작성하는 것이 점점 힘에 부칠 수 밖에 없다.</p><p>여러분이 이미 알고 있는 분야의 지식은 상대적으로 모르는 분야의 지식에 비해 쉬운 것이라고 느껴질 지 모르지만, 분명 그 지식도 다른 사람들에게는 도움이 될 수 있는 가치있는 지식이다. 그 지식이 비록 단순한 변수 선언에 대한 내용일지라도 그 변수 선언에 대한 지식이 없는 누군가에게는 큰 도움이 될 것이다.</p><p>그러니 필자처럼 <code>이건 너무 단순한 내용인데?</code>라는 생각으로 어려운 주제의 포스팅을 고집하다가 제 풀에 지쳐 나가떨어지는 것보다는, 우선 내가 이미 알고있는 분야에 대해서 정리하는 포스팅을 작성해보는 것이 좋다고 생각한다.</p><h2 id="기술-서적이-아닌-책도-많이-읽어보자"><a href="#기술-서적이-아닌-책도-많이-읽어보자" class="headerlink" title="기술 서적이 아닌 책도 많이 읽어보자"></a>기술 서적이 아닌 책도 많이 읽어보자</h2><p>블로그 포스팅을 작성할 때 물론 주제도 중요하지만 일단 포스팅이라는 행위 자체가 기본적으로 <code>글을 쓰는 것</code>이라는 사실을 잊어서는 안된다. 아무리 주제가 좋더라도 그 주제를 몰입력있게 풀어나갈 수 있는 능력이 없다면 사람들은 읽지 않는다.</p><p><code>TIL(Today I Learned)</code>처럼 본인의 기록용으로 짧은 포스팅을 남기는 경우에는 딱히 글쓰기 스킬의 중요성이 부각되지는 않지만 자신의 생각을 표현하거나 특정 기술에 대해서 깊히 파헤치는 등 어느 정도 컨텐츠성을 가지고 있는 포스팅의 경우는 저자의 글쓰기 스킬이 많이 중요해진다.</p><p>글쓰기 스킬의 향상이라는 주제에서 제일 많이 언급되는 내용 중 하나는 아마 <code>독서의 중요성</code>일 것이다. 사실 개발자들은 평소에 책을 많이 읽는 편이기는 하다. 그러나 대부분 기술과 관련된 서적 위주의 독서를 하기 때문에 문어체 특유의 어휘력을 기르기에는 별로 도움이 안되는 것이 사실이다.</p><p>애초에 이런 책들은 특정 기술의 사용법 같은 명확한 사실 전달에 초점을 맞추기 때문에 문체의 유려함은 중요한 포인트가 아니다. 필자도 VueJS 관련 서적을 집필할 때 딱히 문체는 신경쓰지 않았던 것 같다. 기술 서적을 집필해 보신 분들은 공감하시겠지만, 이런 책을 집필할 때는 문체보다 첨부된 코드의 오류를 검수하거나 확실한 정보를 전달하고 있는지 검증하는데만 해도 정신이 없다.</p><p>반면 에세이나 소설 같은 장르는 자신의 생각이나 상상 속의 이야기를 긴 호흡으로 풀어나가야 하는 장르이다보니 다양한 접속사의 활용이나, 간결하고 논리적인 문장의 구조, 명확한 주제의 제시 등 독자가 이야기의 흐름을 놓치지 않도록 하는 여러가지 방법들이 많이 사용될 수 밖에 없다.</p><p>이러한 방법들을 체득하기위해 따로 공부를 할 수도 있겠지만, 우리는 전공자도 아니고 프로 작가가 될 것도 아니므로 독서를 통해 자연스럽게 체득하는 방법을 추천하는 것이다. 요리도 많이 먹어본 사람이 잘하는 것처럼 글쓰기도 많이 읽어본 사람이 잘하기 마련이다.</p><p>필자가 그런 방법들을 이 포스팅에서 모두 소개하기에는 지식도 짧고, 포스팅 분량도 길어질 것이므로 그 중에서 가장 기초라고 생각하는 <code>문어체</code>에 대한 이야기를 조금 해보려한다.</p><h3 id="문어체에-익숙해져야-한다"><a href="#문어체에-익숙해져야-한다" class="headerlink" title="문어체에 익숙해져야 한다"></a>문어체에 익숙해져야 한다</h3><p>우리가 평소 말할 때 사용하는 <code>구어체</code>와 글을 쓸 때 사용하는 <code>문어체</code>는 각기 다른 특성을 가지고 있다. 구어체의 경우에는 화자의 생각을 실시간으로 표현하는 방식이기 때문에 어순이 변경되거나 필요한 표현이 생략되는 등 문법에 크게 구애 받지 않는다.</p><blockquote><p>야, 저번에 했던 그 게임 또 할까? 그 뭐였더라? 오버워치…가 아니고 배틀그라운드였다!</p></blockquote><p>참고로 구어체의 이런 특성은 한국어에만 국한되는 것은 아니고, 영어 같은 다른 언어들 또한 동일하다.</p><p>구어체는 애초에 완벽한 문장을 만드는 것이 목적이 아니라 <code>커뮤니케이션</code> 자체에 초점을 맞춘 용법이기 때문에 한국어든 영어든 간에 문법은 딱히 중요하지 않다. 우리가 평소에 말할 때 딱히 문장의 구조를 생각하고 말하지 않는 것처럼 말이다.</p><p>또한 위의 예시를 보면 알 수 있듯이 실시간으로 자신의 생각을 표현하는 구어체에서는 앞에서 말한 내용을 수정하는 경우 또한 자주 발생한다. 그렇기 때문에 글을  구어체로 작성하게 되면 문장이 명료하게 완성되지 않고 문체가 산만해질 수 있으며 독자가 글을 읽어나가는 흐름이 끊기게 된다.</p><p>물론 글의 장르에 따라 이런 구어체를 글쓰기에 활용하는 경우도 있지만, 그건 대화를 하는 상황을 묘사하는 등 현실감을 불어넣기 위한 일종의 스킬이라 블로그 포스팅같은 컨텐츠에서는 많이 쓰이지 않는 방법이다.</p><p>이런 이유로 블로그 포스팅과 같이 정보성을 띄고 있는 글은 하나의 문장을 깔끔하게 완성하는 문어체로 글을 작성하는 것이 좋다. 긴 글의 흐름을 끊기지 않게 이어나가기 위해서는 깔끔하고 논리적인 문장의 구사와 다양한 접속사의 활용과 같은 스킬들을 사용해야 하는데, 구어체에는 이런 요소들이 문어체에 비해 상대적으로 약하거나 없기 때문이다.</p><p>하지만 문제는 문어체가 우리가 일상 속에서 잘 사용하지 않는 용법이기 때문에 익숙하지 않다는 것이다. 문어체에 익숙해지는 여러가지 방법이 있겠지만 그 중 필자가 추천했던 것은 기술 서적이 아닌 책, 그 중에서도 저자의 생각을 표현하는 주제를 가진 책을 많이 읽어보는 것이었다. 예를 들면 <code>에세이</code> 같은 것들 말이다.</p><p>단, 필자가 말하는 에세이는 짤막한 감성 글귀들이 송송 박혀있는 그런 책을 말하는 게 아니다. 필자가 말하는 에세이는 서론에서는 주제를 제시하고 본론에서는 그 주제에 대한 실증적인 방법을 제시하며 결론에서는 그에 따른 자신의 의견을 제시하는, 명확하게 구조화 되어있는 에세이를 말하는 것이다.<small>(외국 학교나 기업에 들어갈 때 요구되는 그 에세이다)</small></p><center><br>  <img src="/2019/09/28/how-do-i-write-postings/book.jpeg" width="500"><br>  <small>빌 게이츠나 버락 오바마가 추천하는 책으로도 유명한 팩트풀니스</small><br>  <small>장르 분류는 인문학으로 되어있지만 이런 주제도 크게 보면 에세이라고 할 수 있다</small><br>  <br><br></center><p>개발자들은 주로 튜토리얼, 기술 분석, Dev Log와 같은 주제의 포스팅을 많이 작성한다. 이런 기술적인 포스팅에 왠 저자의 생각이냐고 반문할 수도 있겠지만, 결국은 포스팅의 주제가 <code>남들에게 공유하고 싶은 무언가</code>라면 그 포스팅에는 기본적으로 그 주제에 대한 저자의 의견, 정리 또는 생각이 어느 정도 묻어있을 수 밖에 없다.</p><p>또한 개발자들이 작성하는 포스팅들은 논리적이고 실증적인 방법으로 주제를 풀어나가는 경우가 많기 때문에 저런 에세이를 추천하는 것이다. 이렇게 자신이 작성할 블로그 포스팅과 유사한 스타일의 글을 많이 읽다보면 점점 문어체에서 사용하는 문법과 단어들, 주제를 풀어나가는 구성 등에 대해서 익숙해지기 때문에 자신의 글쓰기에도 많은 도움이 된다.</p><p>정 뭐부터 읽어봐야할지 모르겠다면 필자가 위에 올려놓은 <code>팩트풀니스</code>부터 한번 읽어보자. 사람마다 취향이 다르니 재미있을 것이라고는 할 수 없겠지만, 자신의 생각을 논리로 풀어나간다는 것이 어떤 전개로 이루어지는지는 알 수 있을 것이다.</p><h2 id="피드백을-두려워-하지-말자"><a href="#피드백을-두려워-하지-말자" class="headerlink" title="피드백을 두려워 하지 말자"></a>피드백을 두려워 하지 말자</h2><p>아무래도 블로그라는 것이 불특정 다수에게 노출되는 컨텐츠다 보니 다른 사람들이 주는 피드백에 대한 두려움이 있을 수 있다. 간단하게 말하자면 욕먹는 것에 대한 두려움이랄까. 잘못된 내용을 전파했다가 피드백을 받는 경우도 있고, 자신의 생각을 기재했다가 나와 생각이 다른 사람들이 그 생각에 대한 피드백을 주는 경우도 있다.</p><p>일단 피드백을 받는 것을 두려워 해서는 안된다는 이야기를 먼저 하고 싶다. 피드백은 단순히 내 생각에 반대하는 의견, 나를 까는 의견이 아니라 나를 제 3자의 눈으로 바라본 냉정한 평가이기 때문이다.</p><p>필자도 물론 포스팅을 배포하고 공유하다보면 피드백을 받게 되는데, 뭐 가끔씩 공격적으로 이야기하시는 분들도 있긴 하지만 결국 뭐가 됐든 그 분들은 필자의 포스팅을 읽어보고 거기에 대한 자신의 생각을 표현했을 뿐이니 딱히 기분 나쁘거나 한 것은 없다.</p><p>그리고 그런 피드백은 대부분 필자의 포스팅에 뭔가 오류가 있었다거나, 필자의 생각과 다른 부분을 말씀해주시는 것이니 <code>음, 그렇군</code>하고 그냥 받아들이면 그만이다. 특히 잘못된 정보에 대한 피드백을 주시는 경우는 오히려 가만히 앉아서 오류를 파악하고 고칠 수 있으니 개이득아닌가.</p><center><br>  <img src="/2019/09/28/how-do-i-write-postings/feedback.png" width="500"><br>  <small>최근 동기/비동기 포스팅에 대해 OKKY의 하마님께서 주신 피드백</small><br>  <small>지금까지 필자가 받은 피드백 중 가장 상세한 피드백을 주셔서 굉장히 감사했다<br>  <br><br></small></center><p>하지만 사람 마음이라는 것이 뭔가 지적받는 것에 대해서 한없이 무뎌질 수는 없는 법이다. 당연히 두렵기도 하고 부끄럽기도 하고 때로는 기분 나쁘기도 할 수 있다.</p><p>솔직히 말하자면 필자도 포스팅을 공유할 때마다 마음 한켠으로는 <code>비난 받고 싶지 않다</code>라는 마음이 든다. 개인적으로 정답이 명확한 기술 관련 포스팅을 작성할 때보다 지금 이 주제와 같이 필자의 생각을 표현하는 포스팅을 공유할 때가 더 그렇다.</p><p>기술 포스팅같은 경우는 주로 필자가 잘못된 정보를 기재했을 경우에 피드백이 들어오기 때문에 잘못된 정보를 기재했음을 인정하고 고치면 되지만, 이렇게 자신의 생각을 표현하는 주제처럼 주관성을 가지고 있는 포스팅의 경우에는 필자와 다른 생각을 가지신 분들이 가끔 공격적인 피드백을 주시는 경우도 있기 때문이다.</p><p>하지만 필자가 읽어 보았을 때 <code>좀 심한데...?</code>라는 생각이 들 정도로 거친 피드백을 주신 분은 지금까지 단 한 분밖에 없었고, 이 정도로 공격적인 피드백은 그냥 무시하면 그만이다. 개인적으로 그 피드백에 담긴 생각과는 별개로 타인에게 전달하는 말의 가치를 잘 모르는 사람과는 별로 생각을 나누고 싶지 않다.<small>(비판과 비난은 다르다는 것을 명심하자)</small></p><p>아마도 이렇게 밑도 끝도 없이 비난하는 케이스가 사람들이 두려워 하는 <code>욕먹기 싫다</code>의 원인일 것 같은데, 생각보다 세상에 그렇게 이상한 사람들이 많지는 않다. 대부분은 여러분의 포스팅을 읽고 뭔가 아쉬운 마음에, 더 발전했으면 하는 좋은 마음으로 피드백을 주시는 분들이다.</p><p>오히려 그런 피드백들을 통해 다양한 사람들의 다양한 생각을 들어볼 수도 있을 뿐더러 피드백을 토대로 자신이 성장할 수 있는 좋은 기회이기도 하니까 너무 피드백을 두려워하지 않았으면 한다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>필자가 글쓰기에 대한 포스팅을 작성한 이유는 많은 개발자들이 자신의 생각을 공유하는 생태계가 더욱 활성화되었으면 하는 마음에서 비롯되었다. 자신의 생각이나 지식을 공유하는 것이 얼마나 가치있는 행위인지는 매일 구글이나 스택오버플로우를 사용하면서 느끼고 있을 것이다.</p><p>그리고 이런 공유 행위는 오픈소스 활동이나 블로그 포스팅, 발표 등 다양한 방법으로 이루어지고 있지만, 그 중에서도 글쓰기는 자신의 생각을 남들에게 보여줄 수 있는 가장 기초적인 수단 중 하나이다. 글쓰기를 잘하기 위해서는 기본적으로 올바른 문장 구성을 위한 어휘력과 논리력이 뒷받침되어야 하므로 글쓰기를 통해 커뮤니케이션에 대한 기본적인 소양을 기를 수 있다고 볼 수도 있다.</p><p>이렇게 불특정 다수에게 자신의 생각을 공유하는 행위가 두려울 수도 있지만, 필자가 위에서 이야기했듯이 피드백을 두려워하지 않았으면 한다. 그런 피드백을 통해 나 자신도 조금씩 성장할 수 있는 것이고, 다른 사람의 생각을 다양하게 들어볼 수도 있는 좋은 기회이기 때문에 딱히 두려워할 이유가 없다.</p><p>거듭 이야기하지만 <code>욕 먹는다</code>라고 표현할 수 있을 정도로 모욕적인 맹비난을 쏟아붓는 사람은 생각보다 많지 않고, 만약에라도 그런 비난을 받는다면 그냥 해당 메세지를 삭제하고 없었던 일로 생각하면 된다. 원래 이상한 사람과 술 취한 사람과는 아예 안 엮이는 게 스트레스 덜 받는 방법이다.</p><p>피드백을 주시는 대부분의 사람들은 포스팅을 읽고 뭔가 아쉬운 마음에서, 좋은 마음으로 주시는 것이기 때문에 자신의 생각을 공유하는 것을 주저하지 않았으면 한다.</p><p>그리고 블로그에 당장 뭐부터 써야할 지 모르겠다면, 일단 내가 알고있는 것이 무엇인지부터 한번 차근차근 정리해보자. 장담하건데 본인이 생각하는 것보다 많은 주제들이 나올 것이다. 그리고 위에서는 이야기하지 않았지만 진짜 아무리 생각해도 도저히 쓸 주제가 없다면 재밌게 읽었던 외국 포스팅을 번역해보는 것도 좋은 방법이다.<small>(생각보다 이런 포스팅은 인기도 많다)</small></p><p>이상으로 블로그 개설을 망설이고 있는 사람들에게 포스팅을 마친다.</p></body></html>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/09/28/how-do-i-write-postings/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
