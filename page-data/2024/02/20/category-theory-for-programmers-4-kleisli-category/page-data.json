{"componentChunkName":"component---src-templates-post-page-template-index-tsx","path":"/2024/02/20/category-theory-for-programmers-4-kleisli-category/","result":{"data":{"markdownRemark":{"id":"610888fd-70a9-5b54-a6f0-bbcaf8d1d8c9","tableOfContents":"<ul>\n<li><a href=\"#41-writer-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\">4.1 Writer 카테고리</a></li>\n<li><a href=\"#42-%ED%95%98%EC%8A%A4%EC%BC%88%EC%9D%98-writer\">4.2 하스켈의 Writer</a></li>\n<li><a href=\"#43-%ED%81%AC%EB%9D%BC%EC%9D%B4%EC%8A%AC%EB%A6%AC-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACkleisli-categories\">4.3 크라이슬리 카테고리(Kleisli Categories)</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"우리는 지금까지 타입과 순수 함수들을 카테고리로 모델링하는 방법을 살펴봤다. 앞서 필자는 카테고리 이론에서 사이드 이펙트나 순수하지 않은 함수를 모델링하는 방법이 있다고 이야기했었는데, 어떠한 실행과정을 추적하거나 로깅하는 함수를 예시로 들어 이 방법에 대해 한번 살펴보도록 하자. 우리가 명령형 언어를 사용하여 무언가를 구현할 때는 일반적으로 전역 상태를 선언하고 변경해가며 구현하게 된다. 이 함수는 자신의 외부 세계에 선언되어있는 를 변경한다는 사이드이펙트를 가지고 있기 때문에 순수함수가 아니다. 모던 프로그래밍의 세계에서는 가…","html":"<p>우리는 지금까지 타입과 순수 함수들을 카테고리로 모델링하는 방법을 살펴봤다. 앞서 필자는 카테고리 이론에서 사이드 이펙트나 순수하지 않은 함수를 모델링하는 방법이 있다고 이야기했었는데, 어떠한 실행과정을 추적하거나 로깅하는 함수를 예시로 들어 이 방법에 대해 한번 살펴보도록 하자.</p>\n<p>우리가 명령형 언어를 사용하여 무언가를 구현할 때는 일반적으로 전역 상태를 선언하고 변경해가며 구현하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">string logger<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     logger <span class=\"token operator\">+=</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span>b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 자신의 외부 세계에 선언되어있는 <code class=\"language-text\">logger</code>를 변경한다는 사이드이펙트를 가지고 있기 때문에 순수함수가 아니다.</p>\n<p>모던 프로그래밍의 세계에서는 가급적이면 변경 가능한 전역 상태를 사용하지 않기 위해 노력하는데, 다른 것은 둘째치고 동시성의 복잡성때문에라도 이러한 행위는 최대한 피해야 한다. 아마 독자 여러분도 이런 코드를 라이브러리에 넣고 싶지는 않을 것이라 생각한다.</p>\n<p>다행히도 이 함수는 순수함수로 변경될 수 있는 가능성이 있다. 그저 함수에게 <code class=\"language-text\">logger</code>를 명시적으로 전달하기만 하면 된다. 즉, 함수에 하나의 문자열 인수를 추가함으로써 함수의 출력과 로그가 포함된 문자열을 짝지어볼 수 있는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">,</span> string logger<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>b<span class=\"token punctuation\">,</span> logger <span class=\"token operator\">+</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이제 이 함수는 사이드 이펙트를 발생시키지 않기 때문에 순수하다. 동일한 인수가 주어졌을 때 항상 동일한 값의 쌍을 출력하며, 이러한 특성으로 인해 필요한 경우에는 메모이제이션 할 수도 있다. 그러나 메모이제이션을 할 경우 이전 값을 토대로 다음 값을 생성한다는 누산적인 로그의 특성으로 인해, 결국은 이 함수가 호출되기까지의 모든 이력을 메모이제이션해야 할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"It was the best of times. \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 또는</span>\n<span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"It was the worst of times. \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p><strong>💡 역주</strong></p>\n<p>여기서 작가는 누산적인 연산을 한다는 로그의 특성으로 인해 메모이제이션을 하나마나라는 이야기를 하고 있다. negate 함수는 “이전 로그”를 받아 “Not so! “라는 문자열을 이어붙히는 방식으로 새로운 로그 문자열을 생성하여 반환하는데, 이는 결국 negate 함수가 반환하는 로그 문자열이 negate 함수가 호출되기 이전의 로그 상태의 영향을 받는다는 의미이다.</p>\n<p>아무리 negate 함수가 참조 투명성을 보장하는 순수함수라도, 결국 함수의 호출 맥락이라는 것은 상황에 따라 달라질 수 있기 때문에 negate 함수가 반환하는 로그 문자열 또한 매번 달라질 가능성이 크다. 그로 인해 이를 메모이제이션하는 것은 큰 의미가 없어지는 것이다.</p>\n</blockquote>\n<p>이러한 설계는 라이브러리 함수로써 좋은 설계라고 볼 수도 없다. 함수 호출자는 이 함수가 반환하는 로그 문자열을 무시할 수 있으니 출력 형태에 대해서는 큰 문제가 없겠지만, 입력에 대해서는 다르다. 로그가 필요없는 상황에도 매번 호출자가 특정한 로그 문자열을 함수에게 직접 전달해줘야 하기 때문이다.</p>\n<p>그렇다면 관심사를 분리하는 방법을 통해 이 함수를 조금 더 편하게 호출할 수 있는 방법은 없을까? 결국 위 예시에서 negate 함수의 주 목적은 인수로 받은 하나의 Boolean 값을 다른 Boolean 값으로 변환하는 것이며, 로깅은 그저 보조적인 역할만 수행한다. 물론 이 로그에 기록되는 메세지가 함수의 목적에 특화되어 있기는 하지만, 결국 어떠한 메세지를 하나의 로그로 통합하는 작업 자체는 negate 함수의 주 목적과는 별개의 관심사이다. 즉, 우리는 로깅에 대한 관심사를 분리해야 한다.</p>\n<p>그렇다면 이런 방법으로 타협을 볼 수 있을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>b<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>결국 이 아이디어는 함수가 호출될 때마다 로그를 계속 쌓는다는 컨셉에서 출발한다. 이제 이 아이디어를 어떻게 구현할 수 있을지 알아보기 위해 약간 더 현실적인 예제를 보도록하자.</p>\n<p>여기 어떤 문자열을 받아 소문자를 대문자로 변경하는 함수가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">string <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    string result<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>toupper<span class=\"token punctuation\">;</span> <span class=\"token comment\">// toupper is overloaded</span>\n    <span class=\"token function\">transform</span><span class=\"token punctuation\">(</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">back_inserter</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 두번째 함수는 인수로 받은 문자열을 공백을 기준으로 나누어 벡터를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">toWords</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">words</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">toWords</code> 함수의 실제 동작은 <code class=\"language-text\">words</code> 함수에서 수행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">words</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> result<span class=\"token punctuation\">{</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">=</span> <span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">!=</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isspace</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+=</span> <span class=\"token operator\">*</span>i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>우리는 <code class=\"language-text\">toUpper</code> 함수와 <code class=\"language-text\">toWords</code> 함수를 수정하여 문자열 메세지를 이 함수들의 반환값과 함께 묶어 표현하고 싶다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 300px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/01933c7eafd8f72afd7f176b92dbd607/f93b5/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 106.87500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAVABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAMFAQIE/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAbblngSyC41CQH//xAAbEAACAgMBAAAAAAAAAAAAAAABAgMRABASIv/aAAgBAQABBQKVqwSt0DYkj9MrYBQYWOBr/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAHBAAAgEFAQAAAAAAAAAAAAAAAREAAhASIWEy/9oACAEBAAY/Ava5A2LCqlDe3AMwYooOW//EAB4QAAICAgIDAAAAAAAAAAAAAAERACExQRBhcYGx/9oACAEBAAE/IVXg03CwWsFK4JwIPiKNuwIZaidfYIYagXH6iaV04//aAAwDAQACAAMAAAAQtA88/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHhABAQACAgIDAAAAAAAAAAAAAREAMSFBYXEQgaH/2gAIAQEAAT8QhUlUC8usmlWJB+3XnBhjVVL3iSBF0F6d/nnOM1+Lt9nzkRIJqYjQDusGIVogL7+P/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/01933c7eafd8f72afd7f176b92dbd607/f93b5/1.jpg\" srcset=\"/static/01933c7eafd8f72afd7f176b92dbd607/0913d/1.jpg 160w,\n/static/01933c7eafd8f72afd7f176b92dbd607/f93b5/1.jpg 300w\" sizes=\"(max-width: 300px) 100vw, 300px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>우리는 이제 이 함수들의 반환값을 아름답게 꾸며볼 것이다. 가장 먼저 임의의 타입 A인 값이 첫 번째 요소이고 문자열이 두 번째 요소인 쌍을 캡슐화하는 템플릿 <code class=\"language-text\">Writer</code>를 정의함으로써 이 문제를 일반화하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">using</span> Writer <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>A<span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이제 <code class=\"language-text\">Writer</code>를 사용하여 각 함수들을 꾸며줄 차례이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    string result<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>toupper<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">transform</span><span class=\"token punctuation\">(</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">back_inserter</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token string\">\"toUpper \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nWriter<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">toWords</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token function\">words</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"toWords \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 이 두 함수를 조합하여 문자열을 대문자로 변환하고 공백을 기준으로 나눠주는 함수를 꾸며보자. 바로 이 과정에서 이 작업에 대한 로그를 생성할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">auto</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">auto</span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">toWords</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 처음의 목표를 달성했다. 각각의 로그를 합치는 것은 이제 더 이상 개별 함수들의 관심사가 아니다. 각 함수들은 자체적으로 자신과 관련된 메세지를 생성할 뿐이고, 이 개별 함수들의 외부에서 이러한 메세지들을 합쳐 더 큰 로그를 만들어낸다.</p>\n<p>이제 이러한 스타일로 작성된 거대한 프로그램을 한번 상상해보자. 아마 이러한 패턴을 계속해서 반복하게되면 오류가 발생하기 쉬운 악몽과도 같은 코드가 될 것이다. 하지만 우리는 프로그래머이기 때문에 이런 반복적인 코드를 추상화를 사용하여 우아하게 해결하는 일에 이미 익숙하다. 그러나 이것은 우리가 지금까지 알던 추상화와는 약간 다르다. 바로 함수의 합성이라는 개념 자체를 추상화해야하기 때문이다.</p>\n<p>결국 합성이라는 개념은 카테고리 이론의 본질이니, 코드를 더 작성하기 전에 일단 카테고리 이론의 관점에서 이 문제를 한번 분석해보자.</p>\n<h2>4.1 Writer 카테고리</h2>\n<p>함수들의 반환 타입을 꾸며 추가 기능을 끼워넣을 수 있다는 아이디어는 우리에게 큰 가치를 가져다준다. 이제 이에 대한 더 많은 예제를 한번 보도록 하자. 대상을 타입으로 가지고 사상은 우리가 꾸며주었던 함수로 가지는 일반적인 카테고리에서부터 시작해보는 것이 좋겠다.</p>\n<p>예를 들어 <code class=\"language-text\">int</code> 타입에서 <code class=\"language-text\">bool</code> 타입으로 향하는 <code class=\"language-text\">isEven</code> 함수를 꾸며본다고 생각해보자. 가장 먼저 카테고리의 사상을 우리가 앞서 꾸며보았던 함수로 다시 표현해볼 것이다. 여기서 중요한 점은 이 함수가 비록 <code class=\"language-text\">pair&lt;bool, string></code> 타입을 반환한다고 해도 카테고리 내에서는 여전히 <code class=\"language-text\">int</code> 대상과 <code class=\"language-text\">bool</code> 대상 사이의 화살표로 간주된다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">isEven</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"isEven \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>카테고리 법칙에 의하면 우리는 이 사상을 다른 사상과 합성하여 대상 <code class=\"language-text\">bool</code>에서 다른 대상으로 향하는 사상을 만들 수 있어야 한다. 여기서는 앞서 정의했던 <code class=\"language-text\">negate</code> 함수와 합성하는 상황을 한번 보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>b<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>물론 <code class=\"language-text\">isEven</code> 함수와 <code class=\"language-text\">negate</code> 함수는 서로의 입력과 출력 타입이 일치하지 않기 때문에 이 두 개의 사상을 일반적인 함수와 같은 방식으로 합성할 수는 없다. 이 두 사상의 합성은 아래와 같이 표현해줘야 할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">isOdd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">isEven</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tpair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 카테고리에서 두 개의 사상을 합성하는 과정은 다음과 같다.</p>\n<hr>\n<ol>\n<li>첫 번째 사상에 해당하는 함수를 실행시킨다. 위 예시에서는 <code class=\"language-text\">isEven(n)</code>에 해당한다.</li>\n<li>첫 번째 함수가 반환한 값의 쌍에서 첫 번째 요소를 추출하고, 이 요소를 두 번째 사상에 해당하는 함수에 전달한다. 위 예시에서는 <code class=\"language-text\">negate(p1.first)</code>에 해당한다.</li>\n<li>첫 번째 사상과 두 번째 사상이 반환한 로그 문자열, 즉 각 함수가 반환한 쌍에서 두 번째 요소를 추출하여 직접 연결해준다.</li>\n<li>위 과정을 통해 얻어낸 값과 연결한 로그 문자열을 사용하여 새로운 쌍을 만들어 반환한다. 위 예시에서는 <code class=\"language-text\">make_pair(p2.first, p1.second + p2.second)</code>에 해당한다.</li>\n</ol>\n<hr>\n<p>만약 이 과정을 C++의 고차함수로 추상화하려면 이 카테고리가 가진 세 개의 대상을 타입 변수로 표현한 템플릿을 사용해야한다. 그리고 결과값과 로그 문자열 쌍을 반환하는 두 개의 함수를 가져와 합성하고, 마지막으로 새로운 쌍을 만드는 함수를 반환하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token operator\">></span>\n\nfunction<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">Writer</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>C<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>function<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">Writer</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> m1<span class=\"token punctuation\">,</span>\n                               function<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">Writer</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>C<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> m2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>m1<span class=\"token punctuation\">,</span> m2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>A x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">m1</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">m2</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기까지 왔으면 이제 거의 끝났다. 이제 이 템플릿을 사용하여 원래 우리가 합성하려고 했던 <code class=\"language-text\">toUpper</code> 함수와 <code class=\"language-text\">toWords</code> 함수의 합성을 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> string<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span></span></span><span class=\"token punctuation\">(</span>toUpper<span class=\"token punctuation\">,</span> toWords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>하지만 아직도 <code class=\"language-text\">compose</code> 템플릿에 타입을 전달하는 과정이 번거로워 보인다. 이는 C++14 호환 컴파일러에서 지원하는 반환 타입 추론 기능을 지원하는 람다 함수를 사용함으로써 해결해볼 수 있다. (아래 코드의 작성자는 Eric Niebler이다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> <span class=\"token keyword\">const</span> compose <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> m1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">auto</span> m2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>m1<span class=\"token punctuation\">,</span> m2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">m1</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">m2</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 타입 추론을 지원하도록 정의된 <code class=\"language-text\">compose</code> 함수를 사용하여 함수를 더 간단하게 합성해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>toUpper<span class=\"token punctuation\">,</span> toWords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>아직 끝난 것이 아니다. 우리는 지금까지 카테고리 내 사상의 합성만 정의한 것이고 아직 항등 사상에 대한 것은 정의하지 않았다. 이 항등 사상은 일반적인 항등 함수와는 약간 다르다. 이들은 타입 A로부터 다시 타입 A로 돌아가는 사상이기 때문에 아래와 같은 타입 선언을 가질 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token function\">identity</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 항등 사상은 합성에 대한 항등원처럼 작동해야한다. 우리가 정의해놓은 로직의 합성 과정에 의하면 이 항등 사상은 자신이 인수로 받은 값을 변경하지도 않고, 로그에는 빈 문자열만 기록하는 방식으로 정의해야 할 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span> Writer<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token function\">identity</span><span class=\"token punctuation\">(</span>A x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 정의한 카테고리는 카테고리가 지켜야하는 모든 조건들을 만족하고 있다. 특히 이 카테고리의 합성은 명확하게 결합법칙을 만족하고 있다. 각 함수들이 반환하는 값의 쌍 중 첫 번째 요소만 보면 일반적인 함수의 합성으로 바라볼 수 있으며, 이 연산은 결합법칙을 만족한다. 또한 두 번째 요소인 로그 문자열에 대한 연산은 그저 문자열의 연결일 뿐이니 이 또한 결합법칙을 만족한다.</p>\n<p>여기서 영리한 독자라면 우리가 이 구조를 문자열 모노이드 뿐 아니라 어떤 모노이드에던 일반화해서 적용할 수 있다는 사실을 알아차렸을 것이다. <code class=\"language-text\">compose</code> 함수에서 <code class=\"language-text\">+</code> 연산자 대신 <code class=\"language-text\">mappend</code>를, 그리고 <code class=\"language-text\">identity</code> 함수에서는 <code class=\"language-text\">\"\"</code>라는 값 대신에 <code class=\"language-text\">mempty</code>를 사용하기만 하면 된다.</p>\n<p>반드시 문자열을 다룰 때에만 한해서 로깅을 한다는 법은 없다. 좋은 라이브러리 작성자는 라이브러리가 동작하는 데 필요한 최소한의 제약 조건을 식별할 수 있어야 한다. 우리가 만든 로깅 라이브러리의 유일한 요구 사항은 그저 로그라는 개념이 모노이드적인 특성을 가져야 한다는 것이다.</p>\n<h2>4.2 하스켈의 Writer</h2>\n<p>앞서 구현했던 것들을 Haskell에서는 조금 더 간결하게 작성할 수 있고 컴파일러로부터 더 많은 도움을 받을 수 있기도 하다.</p>\n<p>일단 <code class=\"language-text\">Writer</code> 타입을 정의하는 것부터 시작해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서는 단순히 타입 별칭(Type Alias)을 정의하고 있으며, 이것은 C++의 <code class=\"language-text\">typedef</code> 또는 <code class=\"language-text\">using</code>과 동일한 기능이다. <code class=\"language-text\">Writer</code> 타입은 타입 변수 <code class=\"language-text\">a</code>를 받아 <code class=\"language-text\">a</code> 타입과 <code class=\"language-text\">String</code> 타입의 쌍을 반환한다. 이 문법은 쌍을 의미하는 괄호 안에 두 개의 요소가 존재하고, 이 요소들이 쉼표로 부분되는 최소한의 형태로만 이루어져있다.</p>\n<p>이 카테고리에서의 사상은 임의의 타입에서 다른 타입을 매개변수로 가지는 <code class=\"language-text\">Writer</code> 타입으로 나아가는 함수라고 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 “fish”라고도 불리는 재미있는 중위 연산자(Infix Operator)를 사용하여 합성을 정의할 차례이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">>=></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 연산자는 두 개의 인수를 받아 합성하는 함수이며, 이 인수들은 합성의 대상이 되는 함수들이고 최종적으로는 합성된 함수를 반환한다. 첫 번째 인수는 <code class=\"language-text\">(a -> Writer b)</code> 타입, 두 번째 인수는 <code class=\"language-text\">(b -> Writer c)</code> 타입이며, 최종 반환 결과는 <code class=\"language-text\">(a -> Writer c)</code> 타입을 가진다.</p>\n<p>아래 예시는 <code class=\"language-text\">m1</code> 이라는 인수와 <code class=\"language-text\">m2</code>라는 인수를 받았을 때 이 중위 연산자가 어떻게 작동하는지를 보여준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m1</span> <span class=\"token operator\">>=></span> <span class=\"token hvariable\">m2</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m1</span> <span class=\"token hvariable\">x</span>\n        <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m2</span> <span class=\"token hvariable\">y</span>\n    <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>연산의 결과는 <code class=\"language-text\">x</code>라는 하나의 인수를 받는 람다 함수이다. 람다 함수는 역슬래시(<code class=\"language-text\">\\</code>)로 표현할 수 있다. 기억하기 어렵다면 다리를 하나 잃은 그리스 문자 λ(Lambda)라고 생각하자.</p>\n<p><code class=\"language-text\">let</code> 표현을 사용하면 함수 내의 지역변수를 선언할 수 있다. 여기서 <code class=\"language-text\">m1</code> 함수의 호출 결과는 <code class=\"language-text\">(y, s1)</code> 변수에 담기고, 이 변수에서 가져온 <code class=\"language-text\">y</code> 인자를 사용하여 호출된 <code class=\"language-text\">m2</code> 함수의 호출 결과는 <code class=\"language-text\">(z, s2)</code> 변수에 담긴다.</p>\n<p>이처럼 Haskell에서는 C++에서 <code class=\"language-text\">p1.first</code> 같이 접근자를 사용했던 것과는 다르게, <code class=\"language-text\">(y, s1) = m1 x</code> 처럼 패턴 매칭하여 쌍을 분해하는 방법을 주로 사용한다. 이 외에도 두 언어의 기능 간에는 이렇게 직관적으로 대응해볼 수 있는 관계가 꽤 존재한다.</p>\n<p>위 함수의 <code class=\"language-text\">let</code> 표현식에서 선언된 변수들은 함수 동작의 구현을 의미하는 <code class=\"language-text\">in</code>절에서 접근할 수 있다. 즉 <code class=\"language-text\">in</code>절 내부에서 접근한 변수들은 <code class=\"language-text\">let</code> 표현식 내부에서 선언된 값들이며, 최종적으로 첫 번째 요소는 <code class=\"language-text\">z</code> 이고, 두 번째 요소는 두 문자열의 연결인 <code class=\"language-text\">s1 ++ s2</code>로 구성된 쌍을 만들어내고 이쓴 것이다.</p>\n<p>이런 합성 외에도 우리의 카테고리 내부에 존재해야하는 항등 사상도 정의를 해야하겠지만 이건 조금 이따 보도록 하겠다. 일단 항등사상은 <code class=\"language-text\">return</code> 이라고 네이밍하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">return</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">return</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>자 이제 원래 합성하려고 했던 대상인 <code class=\"language-text\">upCase</code> 와 <code class=\"language-text\">toWords</code> 함수의 Haskell 버전을 추가하면 거의 다 완성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">upCase</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">upCase</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">map</span> <span class=\"token builtin\">toUpper</span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"upCase \"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token hvariable\">toWords</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">toWords</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">words</span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"toWords \"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">map</code> 함수는 C++의 <code class=\"language-text\">transform</code>에 해당한다. 이 함수는 문자열 <code class=\"language-text\">s</code> 에 <code class=\"language-text\">toUpper</code> 함수를 적용한다. 그리고 <code class=\"language-text\">words</code> 함수는 표준 Prelude 라이브러리에 이미 정의되어있다.</p>\n<p>최종적으로 이 두 함수의 합성은 앞서 정의했던 fish 연산자를 사용하여 간단하게 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">process</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">process</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">upCase</span> <span class=\"token operator\">>=></span> <span class=\"token hvariable\">toWords</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h2>4.3 크라이슬리 카테고리(Kleisli Categories)</h2>\n<p>사실 이러한 카테고리는 필자가 직접 고안해낸 것이 아니다. 이는 모나드라는 개념에서 기반한 크라이슬리 카테고리(Kleisli Category)의 한 예시이다. 아직 우리가 모나드에 대해 자세히 논의하기에는 조금 이르긴 하지만, 모나드가 어떤 역할을 하는지에 대해서 간략하게 살펴봤다고 생각하면 된다.</p>\n<p>크라이슬리 카테고리는 프로그래밍 언어의 타입들을 대상으로 가진다. 그리고 타입 A에서 타입 B로 나아가는 사상은 타입 A에서 특정 “장식(Embellishment)”를 적용하여 B로 나아가는 함수라고 볼 수 있다.</p>\n<p>모든 크라이슬리 카테고리는 이러한 사상들을 고유한 방법으로 합성하는 방법을 정의하고, 이러한 합성에 대한 항등 사상 또한 정의할 수 있다. (추후 이 애매한 “장식”이라는 용어가 카테고리의 엔도펑터(Endofunctor)라는 개념을 의미한다는 사실을 설명하겠다.)</p>\n<p>이 챕터에서 함수들의 실행 과정을 추적하고 로깅하기 위해 만들었던 Writer 모나드는 순수함수들의 연산 결과에 이펙트를 포함하기 위한 일반적인 매커니즘의 예시이기도 하다.</p>\n<p>우리는 이전 챕터에서 프로그래밍 언어에서 bottom을 제외한 일반 타입들과 함수들을 집합으로 구성된 카테고리로 모델링하는 방법에 대해서 알아봤다. 그리고 이번에는 이 모델을 기반으로 함수들의 합성이라는 행위가 단지 한 함수의 출력을 다른 함수의 입력으로 전달하는 것뿐 아니라 조금 더 다양한 기능을 포함할 수 있는 카테고리로 발전시켜보았다.</p>\n<p>이제 우리는 함수의 합성을 가지고 놀 때 조금 더 자유로운 아이디어를 표현해볼 수 있게 되었다. 바로 우리가 앞서 알아본 개념들이 지금까지 명령형 언어들이 사이드이펙트를 사용하여 구현해왔던 프로그램에도 표시적 의미론(Denotational Semantics)을 적용할 수 있는 자유를 선물해준 것이다.</p>\n<h2>원문 보기</h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240220-category-theory-for-programmers-4-kleisli-category","path":"/2024/02/20/category-theory-for-programmers-4-kleisli-category/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 4. 크라이슬리 카테고리","date":"2024-02-20","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}},"allMarkdownRemark":{"edges":[]}},"pageContext":{"slug":"20240220-category-theory-for-programmers-4-kleisli-category","previous":{"fields":{"slug":"20240213-category-theory-for-programmers-3-categories-great-and-small","path":"/2024/02/13/category-theory-for-programmers-3-categories-great-and-small/","lang":"ko","postGroup":"20240213-category-theory-for-programmers-3-categories-great-and-small"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 3. 다양한 카테고리들"}},"next":{"fields":{"slug":"20240227-category-theory-for-programmers-5-products-and-coproducts","path":"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts/","lang":"ko","postGroup":"20240227-category-theory-for-programmers-5-products-and-coproducts"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 5. 곱과 합"}},"lang":"ko","postGroup":"20240220-category-theory-for-programmers-4-kleisli-category"}},"staticQueryHashes":["3129619726","3523904809","376081736","650499039"],"slicesMap":{}}