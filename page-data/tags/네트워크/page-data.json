{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/네트워크/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"efd49bfc-a57c-57dd-91b8-2117aebe2b31","tableOfContents":"<ul>\n<li>\n<p><a href=\"#cors%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EB%82%B4%EC%9A%A9\">CORS에 대한 기본적인 내용</a></p>\n<ul>\n<li><a href=\"#%EC%B6%9C%EC%B2%98origin%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">출처(Origin)가 무엇인가요?</a></li>\n<li><a href=\"#sopsame-origin-policy\">SOP(Same-Origin Policy)</a></li>\n<li><a href=\"#%EA%B0%99%EC%9D%80-%EC%B6%9C%EC%B2%98%EC%99%80-%EB%8B%A4%EB%A5%B8-%EC%B6%9C%EC%B2%98%EC%9D%98-%EA%B5%AC%EB%B6%84\">같은 출처와 다른 출처의 구분</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#cors%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94\">CORS는 어떻게 동작하나요?</a></p>\n<ul>\n<li><a href=\"#preflight-request\">Preflight Request</a></li>\n<li><a href=\"#simple-request\">Simple Request</a></li>\n<li><a href=\"#credentialed-request\">Credentialed Request</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#cors%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B0%A9%EB%B2%95\">CORS를 해결할 수 있는 방법</a></p>\n<ul>\n<li><a href=\"#access-control-allow-origin-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0\">Access-Control-Allow-Origin 세팅하기</a></li>\n<li><a href=\"#webpack-dev-server%EB%A1%9C-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%B1%ED%95%98%EA%B8%B0\">Webpack Dev Server로 리버스 프록싱하기</a></li>\n<li><a href=\"#%EC%9A%94%EC%B2%AD%EC%9D%84-img-%ED%83%9C%EA%B7%B8%EC%97%90-%EB%84%A3%EC%9C%BC%EB%A9%B4-%EC%96%B4%EB%96%A8%EA%B9%8C\">요청을 img 태그에 넣으면 어떨까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 웹 개발자라면 한번쯤은 얻어맞아 봤을 법한 “CORS(Cross-Origin Resource Sharing)” 정책에 대한 이야기를 해보려고 한다. 사실 웹 개발을 하다보면 CORS 정책 위반으로 인해 에러가 발생하는 상황은 굉장히 흔해서 누구나 한 번 정도는 겪게 된다고 해도 과언이 아니다.","html":"<p>이번 포스팅에서는 웹 개발자라면 한번쯤은 얻어맞아 봤을 법한 “CORS(Cross-Origin Resource Sharing)” 정책에 대한 이야기를 해보려고 한다. 사실 웹 개발을 하다보면 CORS 정책 위반으로 인해 에러가 발생하는 상황은 굉장히 흔해서 누구나 한 번 정도는 겪게 된다고 해도 과언이 아니다.</p>\n<!-- more -->\n<p>필자는 대학생 때 친구들과 토이 프로젝트를 만들던 과정에 이 이슈를 처음 겪었었다. 당시 필자는 로컬 환경에서 클라이언트 어플리케이션을 만들고 있었고, 친구가 미리 만들어서 배포해놓은 개발 환경 API 서버와 통신을 시도했었다.</p>\n<p>API 서버와 통신을 진행해서 데이터를 받아오면 되는 단순한 작업이었기 때문에 아무 생각없이 통신을 진행했는데, 갑자기 콘솔이 빨개지더니 당황스러운 메세지를 뱉어냈다.</p>\n<blockquote>\n<p>🚨 Access to fetch at ’<a href=\"https://api.lubycon.com/me\" target=\"_blank\" rel=\"nofollow\">https://api.lubycon.com/me</a>’ from origin ‘http://localhost:3000’ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled.</p>\n</blockquote>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAABAD/xAAWAQEBAQAAAAAAAAAAAAAAAAACAAH/2gAMAwEAAhADEAAAAQoJBIk23//EABsQAAICAwEAAAAAAAAAAAAAAAECABEDEjEz/9oACAEBAAEFAkaiVXSpj6PQAT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAEBAQAAAAAAAAAAAAAAAAABECD/2gAIAQEABj8CcE//xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhMRBBcbH/2gAIAQEAAT8hSv8AJSUAnYb4bfI2i8XEGSf/2gAMAwEAAgADAAAAEOwP/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAh/9oACAEDAQE/EByf/8QAFhEBAQEAAAAAAAAAAAAAAAAAEQAB/9oACAECAQE/EDWb/8QAGhABAQEBAQEBAAAAAAAAAAAAAREAIWFRcf/aAAgBAQABPxB6coHKy1h6dHhua+ZKr7xKkCF5lSK383//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"what\" title=\"\" src=\"/static/34d40d58a5f3a94ac3dce372aa54cd71/c08c5/what.jpg\" srcset=\"/static/34d40d58a5f3a94ac3dce372aa54cd71/0913d/what.jpg 160w,\n/static/34d40d58a5f3a94ac3dce372aa54cd71/cb69c/what.jpg 320w,\n/static/34d40d58a5f3a94ac3dce372aa54cd71/c08c5/what.jpg 640w,\n/static/34d40d58a5f3a94ac3dce372aa54cd71/80e3c/what.jpg 720w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>CO...뭐요...? Access 어쩌고를 헤더에 넣으라고...?</small>\n</center>\n<p>지금 보면 나름 친절하게 해결 방법을 잘 알려주고 있는 에러 메세지이지만, 웹 어플리케이션 개발 경험이 전무하던 당시 필자는 이 메세지를 보고도 뭘 어떻게 해야하는지 한참 헤맸던 기억이 난다.</p>\n<h2 id=\"cors에-대한-기본적인-내용\" style=\"position:relative;\">CORS에 대한 기본적인 내용<a href=\"#cors%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EB%82%B4%EC%9A%A9\" aria-label=\"cors에 대한 기본적인 내용 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇듯 우리가 겪는 CORS 관련 이슈는 모두 CORS 정책을 위반했기 때문에 발생하는 것이다. 개발하는 입장에서는 저 정책 때문에 신경써야 하는 것들이 늘어나니 귀찮을 수도 있지만, 사실 CORS라는 방어막이 존재하기 때문에 우리가 이 곳 저 곳에서 가져오는 리소스가 안전하다는 최소한의 보장을 받을 수 있는 것이다.</p>\n<p>CORS는 “Cross-Origin Resource Sharing”의 줄임말로, 한국어로 직역하면 교차 출처 리소스 공유라고 해석할 수 있다. 여기서 “교차 출처”라고 하는 것은 “다른 출처”를 의미하는 것인데, 아무래도 “Cross”라는 영단어가 가지는 뉘앙스가 한국어와 조금은 다르다보니 CORS를 그대로 직역한 교차 출처 리소스 공유라는 말만 보고는 어떤 의미인지 감을 잡기가 조금은 어려운 것 같다.</p>\n<p>그래서 필자는 조금 더 쉬운 이해를 위해 교차 출처라는 말 대신 “다른 출처”라는 단어를 사용해서 이 포스팅을 풀어나갈까 한다.</p>\n<p>일단 다른 출처간의 리소스 공유에 대해서 알아보기에 앞서 간단하게 이 “출처(Origin)“라는 것이 정확히 뭘 의미하는지부터 한번 짚고 넘어가도록 하자.</p>\n<h3 id=\"출처origin가-무엇인가요\" style=\"position:relative;\">출처(Origin)가 무엇인가요?<a href=\"#%EC%B6%9C%EC%B2%98origin%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\" aria-label=\"출처origin가 무엇인가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>서버의 위치를 의미하는 <code class=\"language-text\">https://google.com</code>과 같은 URL들은 마치 하나의 문자열 같아 보여도, 사실은 여러 개의 구성 요소로 이루어져있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 18.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDElEQVR42h2MX0+CcAAA+f6PPbae6qG1XGuKytLE0JW62nKaGvkPDIQE4YdoU9CLtd12u5eTzu47XFSGeJsDJCdadQM590qzOmUfgxMbKN0cxbcbpmKIOzBoXSt08xqd2xpiPMbvFdHVK8LhI1LP8Jk4EftsRsba22HO1qzcmGMKv8cYOzRZ+FM2qWAf7fCNJYHhElgrku2GJLLYOmMSYSP1TcHsZ4tpBlhGgGOJzAJ7EWKZ4b8d8Z1N5wT2D2KxIlr6rOcOke0RZB27LgdvwilNkM4rIy61GaXyEK2sUyuOqCs6VXnAk/KF+tCnNpBR9QJdrYFeavOptBnIz/TzDT4KLyyaKv77Hek24A//mh4jJrvfIAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"uri structure\" title=\"\" src=\"/static/e25190005d12938c253cc72ca06777b1/6af66/uri-structure.png\" srcset=\"/static/e25190005d12938c253cc72ca06777b1/69538/uri-structure.png 160w,\n/static/e25190005d12938c253cc72ca06777b1/72799/uri-structure.png 320w,\n/static/e25190005d12938c253cc72ca06777b1/6af66/uri-structure.png 640w,\n/static/e25190005d12938c253cc72ca06777b1/d9199/uri-structure.png 960w,\n/static/e25190005d12938c253cc72ca06777b1/21b4d/uri-structure.png 1280w,\n/static/e25190005d12938c253cc72ca06777b1/5bd27/uri-structure.png 1432w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <br>\n</center>\n<p>이때 출처는 Protocol과 Host, 그리고 위 그림에는 나와있지 않지만 <code class=\"language-text\">:80</code>, <code class=\"language-text\">:443</code>과 같은 포트 번호까지 모두 합친 것을 의미한다. 즉, 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 것들을 합쳐놓은 것이다.</p>\n<p>또한 출처 내의 포트 번호는 생략이 가능한데, 이는 각 웹에서 사용하는 HTTP, HTTPS 프로토콜의 기본 포트 번호가 정해져있기 때문이다. HTTP가 정의된 <a href=\"https://tools.ietf.org/html/rfc2616#section-3.2.2\" target=\"_blank\" rel=\"nofollow\">RFC 2616</a> 문서를 보면 다음과 같이 기본 포트 번호가 함께 정의되어있는 것을 볼 수 있다.</p>\n<blockquote>\n<p>3.3.2 http URL</p>\n<p>…<br />\n<strong>If the port is empty or not given, port 80 is assumed.</strong> The semantics are that the identified resource is located at the server listening for TCP connections on that port of that host, and the Request-URI for the resource is abs_path (section 5.1.2).<br />\n…</p>\n</blockquote>\n<p>그러나 만약 <code class=\"language-text\">https://google.com:443</code>과 같이 출처에 포트 번호가 명시적으로 포함되어 있다면 이 포트 번호까지 모두 일치해야 같은 출처라고 인정된다. 하지만 이 케이스에 대한 명확한 정의가 표준으로 정해진 것은 아니기 때문에, 더 정확히 이야기하자면 어떤 경우에는 같은 출처, 또 어떤 경우에는 다른 출처로 판단될 수도 있다. <small>(진리의 케바케)</small></p>\n<p>우리는 브라우저의 개발자 도구의 콘솔에서 <code class=\"language-text\">Location</code> 객체가 가지고 있는 <code class=\"language-text\">origin</code> 프로퍼티에 접근함으로써 손 쉽게 어플리케이션이 실행되고 있는 출처를 알아낼 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">.</span>origin<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">\"https://evan-moon.github.io\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h3 id=\"sopsame-origin-policy\" style=\"position:relative;\">SOP(Same-Origin Policy)<a href=\"#sopsame-origin-policy\" aria-label=\"sopsame origin policy permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>웹 생태계에는 다른 출처로의 리소스 요청을 제한하는 것과 관련된 두 가지 정책이 존재한다. 한 가지는 이 포스팅의 주제인 CORS, 그리고 또 한 가지는 “SOP(Same-Origin Policy)“이다.</p>\n<p>SOP는 지난 2011년, <a href=\"https://tools.ietf.org/html/rfc6454#page-5\" target=\"_blank\" rel=\"nofollow\">RFC 6454</a>에서 처음 등장한 보안 정책으로 말 그대로 “같은 출처에서만 리소스를 공유할 수 있다”라는 규칙을 가진 정책이다.</p>\n<p>그러나 웹이라는 오픈스페이스 환경에서 다른 출처에 있는 리소스를 가져와서 사용하는 일은 굉장히 흔한 일이라 무작정 막을 수도 없는 노릇이니 몇 가지 예외 조항을 두고 이 조항에 해당하는 리소스 요청은 출처가 다르더라도 허용하기로 했는데, 그 중 하나가 “CORS 정책을 지킨 리소스 요청”이다. <small>(참고로 CORS라는 이름이 처음 등장한 것은 2009년이라, SOP의 등장보다 빠르다)</small></p>\n<blockquote>\n<p>Access to network resources varies depending on whether the resources are in the same origin as the content attempting to access them.</p>\n<p>Generally, reading information from another origin is forbidden.\nHowever, an origin is permitted to use some kinds of resources retrieved from other origins. For example, an origin is permitted to execute script, render images, and apply style sheets from any origin.  Likewise, an origin can display content from another origin, such as an HTML document in an HTML frame. <strong>Network resources can also opt into letting other origins read their information, for example, using Cross-Origin Resource Sharing.</strong></p>\n<p><a href=\"https://tools.ietf.org/html/rfc6454#section-3.4.2\" target=\"_blank\" rel=\"nofollow\">RFC 6454 - 3.4.2 Network Access</a></p>\n</blockquote>\n<p>우리가 다른 출처로 리소스를 요청한다면 SOP 정책을 위반한 것이 되고, 거기다가 SOP의 예외 조항인 CORS 정책까지 지키지 않는다면 아예 다른 출처의 리소스를 사용할 수 없게 되는 것이다.</p>\n<p>즉, 이렇게 다른 출처의 리소스를 사용하는 것을 제한하는 행위는 하나의 정책만으로 결정된 사항이 아니라는 의미가 되며, SOP에서 정의된 예외 조항과 CORS를 사용할 수 있는 케이스들이 맞물리지 않을 경우에는 아예 리소스 요청을 할 수 없는 케이스도 존재할 수 있다.</p>\n<p>근데 왜 이렇게 귀찮은 정책을 만들어서 개발자들을 괴롭히는 것일까? 어차피 개발자는 정해진 서버하고만 통신을 하도록 어플리케이션을 작성할 텐데 말이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 436px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 61.24999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkklEQVR42n2SSY8BURSF679b2FlYCRsrFoYQiTKEhZipUkgtSMxCRIUgZl73R3UjnVTfxctL3jn3nHvuk/r9vqZp9Xq92WxOp9PZbGYYxna7FUJ8/VsApG6322g0yuUytOVyyZ0WnJ1OB8TxeLzf75bkYrEYi8UqlQpq7Xa7Wq3SDi+ZTGa9XtNuv99bkvP5fCKRqNVq0CDrup7NZoPBoKIo3AG9lMVvvcmlUkl7Fnzmx0IkErHZbF6vN5lMmiBL5V6vh6Df7+dyOp0YweVy2e12h8PhdDpvt5sJxTxZEMRgMHiTd7sdUXs8nsViAYIIotEoLRgHMqDD4TCZTDBFihhUVZVor9crT5L+rEKhsNlsAPEQCoUYO51OswJTczQajcdjXhEfDodc2MKD3Gq1fD4f2a5WK0wCRWE+n8O0WtLbNjnhUJZlNkRXJue3oExar6/Ceblc6PUZ+E/axItt5VmYT6VSbrc7Ho8TOKsGhyMSOZ/Pn+E/yKw0l8vRArdoYjscDpsDBwIBjJg4EvqzMyHEN7KqfRhZKKGAAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"trust\" title=\"\" src=\"/static/b7814fc71828e37d43c7516e4d1314ab/8574c/trust.png\" srcset=\"/static/b7814fc71828e37d43c7516e4d1314ab/69538/trust.png 160w,\n/static/b7814fc71828e37d43c7516e4d1314ab/72799/trust.png 320w,\n/static/b7814fc71828e37d43c7516e4d1314ab/8574c/trust.png 436w\" sizes=\"(max-width: 436px) 100vw, 436px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>그냥 개발자를 믿어주시면 안될까요 선생님들...?</small>\n</center>\n<p>하지만 잘 생각해보면 이렇게 출처가 다른 두 개의 어플리케이션이 마음대로 소통할 수 있는 환경은 꽤 위험한 환경이다.</p>\n<p>애초에 클라이언트 어플리케이션, 특히나 웹에서 돌아가는 클라이언트 어플리케이션은 사용자의 공격에 너무나도 취약한 친구라는 사실을 잊지말자. 당장 브라우저의 개발자 도구만 열어도 DOM이 어떻게 작성되어있는지, 어떤 서버와 통신하는지, 리소스의 출처는 어디인지와 같은 각종 정보들을 아무런 제재없이 열람할 수 있지 않은가?</p>\n<p>최근에는 자바스크립트 소스 코드를 난독화해서 읽기 어렵다고 하지만, 난독화는 어디까지나 난독화일 뿐이지 암호화가 아니다. 그리고 아무리 난독화되어있다고 해도 사람이 바로 이해할 수 없는 정도도 아닌데다가, 소스 코드를 직접 볼 수 있다는 것 자체가 보안적으로 상당히 취약한 부분이다. 심지어 아직까지도 소스 코드의 난독화가 안되어 개발자 도구만 열면 <code class=\"language-text\">&lt;script></code> 태그 안에 날 것 그대로의 소스 코드가 떡하니 노출되는 사이트들도 많다.</p>\n<p>이런 상황 속에서 다른 출처의 어플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않는다면, 악의를 가진 사용자가 소스 코드를 쓱 구경한 후 <a href=\"https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8A%B8_%EA%B0%84_%EC%9A%94%EC%B2%AD_%EC%9C%84%EC%A1%B0\" target=\"_blank\" rel=\"nofollow\">CSRF(Cross-Site Request Forgery)</a>나 <a href=\"https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8A%B8_%EA%B0%84_%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8C%85\" target=\"_blank\" rel=\"nofollow\">XSS(Cross-Site Scripting)</a>와 같은 방법을 사용하여 여러분의 어플리케이션에서 코드가 실행된 것처럼 꾸며서 사용자의 정보를 탈취하기가 너무나도 쉬워진다. <small>(그리고 개발자가 신경써야 할 일은 더 많아진다…)</small></p>\n<center>\n  <div style=\"max-width: 400px\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFOklEQVR42h2U6VOb1xXG34+1IXZKIA7E7ELbqw3QBpLQDgKtaEP7hgRCGIyDTcDO4mbB43ZiY8fJOElrT1s3JomXJDNO63xIZzxtPfmrfr2TD2feO/c955nnPOc5Vxo9bWGoZ5rB3mmG+qwo+21o+q2Yxr045EWW7DnqS5ts5Q9oxM5Rim6xGDnPbOoAg7OFWk4xPOShX2D0ntAhjffMMt7vQTnkY3xgFtWgA+OwkxllgIAxzlpii92dI/zeIhF3jlaqQ75wBU/2ALu3hVEfRx4LMNAzRV+XEUkeWmJidF6EF9WwC51gZlGHcJoSRJwFGpU/4LDlOKps86/PH9As7lCrXSGauYTLWWHKlMYgx1Eqwpwd8CBZ5AImXQq9NoJBu4jZEBcABfxzdSKBFirdMiGDl0/XLvHggxuU0xvk8rsko+fwuOrYXU2mZhvorWWUchLJ59rA5aoy68jjcORwO3MEgk3CS21i4Q3OvDlLyuzluwuH/HLzz1y9eEg82iSb2CYitA2E2rhEvt1dwSY6kgqhfZKBLZLBDqng+m+RXdiknr7MWv59oVEWs8LMwwtXebL/CdvVPfILbdaFhuXINvnQJunf6tokxFdq2S5TmBRCT7UpWTvkJlusBi5ybuMu5dw1MtH3UEyEsSkdhF1RMkK3Ded56rYOdfMaeWOV/GSToqXDimUTqW65TEq3yrK+SkxfIGbI0SxcI527js8v2oruEgjsoJcTDA45WDQVWDGUBIEqUTlLwlAhZqoRMTVIWDaQyuaLJOV1otoKcXmFqDFHu3mLRvMzMplDPO4WoUUxhPQ+s84aobDIXzogPFljQeQ7FAn8+hIBUx2vro4UVlSJqJuk9GuExjO4JzM0WncoVsREazfw+7ZwOhqEhZmdzjru+R1cCx08tnV86jQBfZGpsWXc2jJh0xpSaXqPrHGLqKpJQJHDPJUjnfmAWOx9YtF3mBcA7jnxz9fG42kzaSkj68IEvdvMjERERw3hgm28qnVCmm2kqnmPiKpFTFknZVhHFl6ac68LZptYbBVRHMUgNsZsEe05myjGfRgE4Jyrw4JGSKBep+Z4hw3/TXK260hxVYOliToZfZuq7QJabUIUFxgWW9PXo+GNPh29vTJnzhh4rc+ASXayFDrPnHcLj7pBcKzKvKJBxb5HybaP5B1KE1bXWLW/RVCuoJlcEYySwipR3nxdj10bZPTsDD2vTjAx5kWtCmG25jHbK8xM5HENruAbLeIeEZM3X0ByD6ep23eIjBUxjyToF8y0wsyjijiviRfoZNc4r3SP0d09yunTKvr7pxk4a0ejXMA+ssLMwAp+AeYbreEbqSE1gpeI21q4lVlmNEl0kyki2XeJJHfFKtVw+1fx+8s4PEUmp+dRquwYJ0KURV1IaL48vSVavUjJeYXUzFtIuxuf8vjrn7l8/g73vvqJu1/+zMF79/j46Dt+/P4l9/7xgmfPXvLo6a88++evPPnhvzy6/ws/fPOS29ee8s2959x695jn3/+Pm/t3kTqrh9z46AF/vf2Iq29/xZPjf3P04Rf86aP7HH3ymNs3n/Lj8X+48fFDrh8e8+3fXnD/L895evyCv996LHIfcOePD7l9/Vv20gdI1okEVmUSvzGDeTiMTiu0cS4zbYmgNUaxzdWYdWWR9SEhRwybY4UpcR82lng7+yE55zZLpjIBYex5TRHp7EkbQ112Bk5YGRTngVfsnOq1cqJbSdcpJd2n1fS9MS0sY6T71DgnRbx+Souyy0NQUyLr6DDyOyfy7/2oX/Xwf+8f/ytffeuZAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"hacker\" title=\"\" src=\"/static/8d7b67f798121b900eda125cf4e20698/6af66/hacker.png\" srcset=\"/static/8d7b67f798121b900eda125cf4e20698/69538/hacker.png 160w,\n/static/8d7b67f798121b900eda125cf4e20698/72799/hacker.png 320w,\n/static/8d7b67f798121b900eda125cf4e20698/6af66/hacker.png 640w,\n/static/8d7b67f798121b900eda125cf4e20698/c5bb3/hacker.png 680w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  </div>\n  <small>5252...이 사이트에 내 스크립트를 심으면 재미있어지겠는걸?\n  <br>\n  <br>\n</small></center>\n<p>자, 지금까지 계속 같은 출처, 다른 출처에 대한 이야기를 중심으로 포스팅을 풀어나가고 있는데, 그렇다면 정확히 어떤 경우에 출처가 같다고 판단하고, 어떤 경우에 출처가 다르다고 판단하는 것일까?</p>\n<h3 id=\"같은-출처와-다른-출처의-구분\" style=\"position:relative;\">같은 출처와 다른 출처의 구분<a href=\"#%EA%B0%99%EC%9D%80-%EC%B6%9C%EC%B2%98%EC%99%80-%EB%8B%A4%EB%A5%B8-%EC%B6%9C%EC%B2%98%EC%9D%98-%EA%B5%AC%EB%B6%84\" aria-label=\"같은 출처와 다른 출처의 구분 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>사실 두 개의 출처가 서로 같다고 판단하는 로직 자체는 굉장히 간단한데, 두 URL의 구성 요소 중 Scheme, Host, Port, 이 3가지만 동일하면 된다.</p>\n<p><code class=\"language-text\">https://evan-moon.github.io:80</code>라는 출처를 예로 들면 <code class=\"language-text\">https://</code> 이라는 스킴에 <code class=\"language-text\">evan-moon.github.io</code> 호스트를 가지고 <code class=\"language-text\">:80</code>번 포트를 사용하고 있다는 것만 같다면 나머지는 전부 다르더라도 같은 출처로 인정이 된다는 것이다.</p>\n<p>필자의 블로그 출처인 <code class=\"language-text\">https://evan-moon.github.io</code>와 같은 출처로 인정되는 예시는 대략 이런 느낌이다.</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>같은 출처</th>\n<th>이유</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><a href=\"https://evan-moon.github.io\" target=\"_blank\" rel=\"nofollow\">https://evan-moon.github.io</a></strong>/about</td>\n<td>O</td>\n<td>스킴, 호스트, 포트가 동일</td>\n</tr>\n<tr>\n<td><strong><a href=\"https://evan-moon.github.io\" target=\"_blank\" rel=\"nofollow\">https://evan-moon.github.io</a></strong>/about?q=안뇽</td>\n<td>O</td>\n<td>스킴, 호스트, 포트가 동일</td>\n</tr>\n<tr>\n<td><strong>https://</strong> user:password@<strong>evan-moon.github.io</strong></td>\n<td>O</td>\n<td>스킴, 호스트, 포트가 동일</td>\n</tr>\n<tr>\n<td><strong><a href=\"http://evan-moon.github.io\" target=\"_blank\" rel=\"nofollow\">http://evan-moon.github.io</a></strong></td>\n<td>X</td>\n<td>스킴이 다름</td>\n</tr>\n<tr>\n<td><strong><a href=\"https://api.github.io\" target=\"_blank\" rel=\"nofollow\">https://api.github.io</a></strong></td>\n<td>X</td>\n<td>호스트가 다름</td>\n</tr>\n<tr>\n<td><strong><a href=\"https://evan-moon.naver.com\" target=\"_blank\" rel=\"nofollow\">https://evan-moon.naver.com</a></strong></td>\n<td>X</td>\n<td>호스트가 다름</td>\n</tr>\n<tr>\n<td><strong><a href=\"https://evan-moon.github.com\" target=\"_blank\" rel=\"nofollow\">https://evan-moon.github.com</a></strong></td>\n<td>X</td>\n<td>호스트가 다름</td>\n</tr>\n<tr>\n<td><strong><a href=\"https://evan-moon.github.io:8000\" target=\"_blank\" rel=\"nofollow\">https://evan-moon.github.io:8000</a></strong></td>\n<td>?</td>\n<td>브라우저의 구현에 따라 다름</td>\n</tr>\n</tbody>\n</table>\n<p>맨 마지막에 있는 케이스의 경우, 만약 출처에 <code class=\"language-text\">https://evan-moon.github.io:80</code>처럼 포트 번호가 명시되어 있다면 명백하게 다른 출처로 인정되는 부분이지만, 예시로 든 출처의 경우 포트 번호가 포함되지 않았기 때문에 판단하기가 애매하다. RFC 6454의 <a href=\"https://tools.ietf.org/html/rfc6454#section-5\" target=\"_blank\" rel=\"nofollow\">Comparing Origins</a> 섹션에는 “만약 출처가 스킴/호스트/포트의 삼중 체계라면…” 이라는 전제가 붙어있기 때문에 어떻게 해석하냐에 따라 구현이 달라질 수 있기 때문이다.</p>\n<p>그래서 이런 경우에는 각 브라우저들의 독자적인 출처 비교 로직을 따라가게 된다.</p>\n<center>\n  <div style=\"max-width: 400px\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 106.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAVABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwT/xAAYAQACAwAAAAAAAAAAAAAAAAABAgADBP/aAAwDAQACEAMQAAABis00VbKEbqzBAB//xAAcEAACAgIDAAAAAAAAAAAAAAABAgADEjETISP/2gAIAQEAAQUCzsmdhis0K97Ka4/RQUZa5//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/ASH/xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQIBAT8BWNa//8QAGxAAAQUBAQAAAAAAAAAAAAAAAAECESIxMnH/2gAIAQEABj8CW7jtx0oueSVaYSS1TT//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhQVFhwf/aAAgBAQABPyFdZULuXQ0dldvA9gdFwBIRa0sQL12USnHK+ym26rJMTe/J/9oADAMBAAIAAwAAABDgyD3/xAAYEQEBAQEBAAAAAAAAAAAAAAABABEhMf/aAAgBAwEBPxDV3seQAgL/xAAYEQADAQEAAAAAAAAAAAAAAAAAARExUf/aAAgBAgEBPxCLgi4U3BtT/8QAHBABAQEAAwADAAAAAAAAAAAAAREAIUFRYYHx/9oACAEBAAE/EBMhgH65SElvN02lhzfRnCKbYVl06i8UTESR6V4YBZtplevlouawqR+89wVav73/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ie is trash\" title=\"\" src=\"/static/a21288d9ab75a6714b1f5a752d171ce4/c08c5/ie_is_trash.jpg\" srcset=\"/static/a21288d9ab75a6714b1f5a752d171ce4/0913d/ie_is_trash.jpg 160w,\n/static/a21288d9ab75a6714b1f5a752d171ce4/cb69c/ie_is_trash.jpg 320w,\n/static/a21288d9ab75a6714b1f5a752d171ce4/c08c5/ie_is_trash.jpg 640w,\n/static/a21288d9ab75a6714b1f5a752d171ce4/6a068/ie_is_trash.jpg 960w,\n/static/a21288d9ab75a6714b1f5a752d171ce4/fb914/ie_is_trash.jpg 998w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  </div>\n  <small>\n    출처 비교 시 포트 번호를 완전 무시하는 브라우저는 Internet Explorer 밖에 없다.<br>그러니 이제 그만 관짝으로 보내주도록 하자<br>\n    <a href=\"https://www.memedroid.com/memes/detail/2429165/internet-explorer-is-crap\" target=\"_blank\">[출처] memdroid</a>\n  </small>\n  <br>\n  <br>\n</center>\n<p>여기서 중요한 사실 한 가지는 이렇게 출처를 비교하는 로직이 서버에 구현된 스펙이 아니라 브라우저에 구현되어 있는 스펙이라는 것이다.</p>\n<p>만약 우리가 CORS 정책을 위반하는 리소스 요청을 하더라도 해당 서버가 같은 출처에서 보낸 요청만 받겠다는 로직을 가지고 있는 경우가 아니라면 서버는 정상적으로 응답을 하고, 이후 브라우저가 이 응답을 분석해서 CORS 정책 위반이라고 판단되면 그 응답을 사용하지 않고 그냥 버리는 순서인 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 36.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABfElEQVR42lWSS0/CQBSF+b1ujAaBCiSAsDea4IKF8gtcmBCjwQcrg4muNJEYIlCoIH2ldMp0Oj3eKeDjNqd3krn97pneSUVRBMZ8cM7Bl8uVaL2krPZUxPF/qXAcC2N9iPF4QllHv98nDkOKcwVhkFIiomqpRGtBsHDpQfI5PHsE3x1T1ilPCGejc3MBLbuNXG4f1eoBCoUCBoMBUkII6rpuO52ttHYlQoZYeBAEXrhf8NwZAmbDF3O02y1k93aQ0zRUKhUUi0Xo5DQBqq/V0+1eY/TUIpwgp/QOTMTcIJc2QjaDYHMw38DL7Bmtq3PktQzy+QJqtRrK5fIvcOPwPfqEFX0kDcL7O/DTM4jXN8iNZQr1O1R0bi+xt7uFdDqDUqkEjZwOh8MVUEkVxmQrpvogCGBSt2mvB2c6RahOgTiRlKtBPXYfcHx0iHr9BM1mE41GA4ZhIKU2XddN5LgOTc+GZVlY0MTkGvMz2j8R0C0wTSupdRwHvu8nJ/0GiJD+Yn5vu6MAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"cors\" title=\"\" src=\"/static/d4d623ba331c1d7851e7000c11cd3809/6af66/cors.png\" srcset=\"/static/d4d623ba331c1d7851e7000c11cd3809/69538/cors.png 160w,\n/static/d4d623ba331c1d7851e7000c11cd3809/72799/cors.png 320w,\n/static/d4d623ba331c1d7851e7000c11cd3809/6af66/cors.png 640w,\n/static/d4d623ba331c1d7851e7000c11cd3809/d9199/cors.png 960w,\n/static/d4d623ba331c1d7851e7000c11cd3809/21b4d/cors.png 1280w,\n/static/d4d623ba331c1d7851e7000c11cd3809/f4fb1/cors.png 1766w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>서버는 CORS를 위반하더라도 정상적으로 응답을 해주고, 응답의 파기 여부는 브라우저가 결정한다</small>\n</center>\n<p>즉, CORS는 브라우저의 구현 스펙에 포함되는 정책이기 때문에, 브라우저를 통하지 않고 서버 간 통신을 할 때는 이 정책이 적용되지 않는다. 또한 CORS 정책을 위반하는 리소스 요청 때문에 에러가 발생했다고 해도 서버 쪽 로그에는 정상적으로 응답을 했다는 로그만 남기 때문에, CORS가 돌아가는 방식을 정확히 모르면 에러 트레이싱에 난항을 겪을 수도 있다.</p>\n<h2 id=\"cors는-어떻게-동작하나요\" style=\"position:relative;\">CORS는 어떻게 동작하나요?<a href=\"#cors%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"cors는 어떻게 동작하나요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그럼 본격적으로 어떤 방법을 통해 서로 다른 출처를 가진 리소스를 안전하게 사용할 수 있는지 알아보도록 하자.</p>\n<p>기본적으로 웹 클라이언트 어플리케이션이 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청을 보내게 되는데, 이때 브라우저는 요청 헤더에 <code class=\"language-text\">Origin</code>이라는 필드에 요청을 보내는 출처를 함께 담아보낸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token header\"><span class=\"token header-name keyword\">Origin</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">https://evan-moon.github.io</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더의 <code class=\"language-text\">Access-Control-Allow-Origin</code>이라는 값에 “이 리소스를 접근하는 것이 허용된 출처”를 내려주고, 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 <code class=\"language-text\">Origin</code>과 서버가 보내준 응답의 <code class=\"language-text\">Access-Control-Allow-Origin</code>을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정한다.</p>\n<p>기본적인 흐름은 이렇게 간단하지만, 사실 CORS가 동작하는 방식은 한 가지가 아니라 세 가지의 시나리오에 따라 변경되기 때문에 여러분의 요청이 어떤 시나리오에 해당되는지 잘 파악한다면 CORS 정책 위반으로 인한 에러를 고치는 것이 한결 쉬울 것이다.</p>\n<h3 id=\"preflight-request\" style=\"position:relative;\">Preflight Request<a href=\"#preflight-request\" aria-label=\"preflight request permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>프리플라이트(Preflight) 방식은 일반적으로 우리가 웹 어플리케이션을 개발할 때 가장 마주치는 시나리오이다. 이 시나리오에 해당하는 상황일 때 브라우저는 요청을 한번에 보내지 않고 예비 요청과 본 요청으로 나누어서 서버로 전송한다.</p>\n<p>이때 브라우저가 본 요청을 보내기 전에 보내는 예비 요청을 Preflight라고 부르는 것이며, 이 예비 요청에는 HTTP 메소드 중 <code class=\"language-text\">OPTIONS</code> 메소드가 사용된다. 예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 이 요청을 보내는 것이 안전한지 확인하는 것이다.</p>\n<p>이 과정을 간단한 플로우 차트로 나타내보면 대략 이런 느낌이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 64.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAClElEQVR42mNgYGDQBGJDIBZmgABGKAYBQVYGBgMuBgZJEKeegYHpP1QORP9HUsvJwCANpNRBbBYIHyzBdOnSJT0g1oAayATE3EgW4ANAuxnYQAxmIOYDYnaQ4MaNGyN37NjhAzZERYXdhYFB6ikDA9f/GzdE/q1dK7OnsFB6e1WV5ImyMpnN6enS/48ckfp/9KjYFAYGnmKI5WADOZCtgnqH5b+WFlsbMCj0gAof3Lu36ea1ay/279595+jhw/fOnDx579CBA3euX7364tXz5xtBPing4pLEMPD///+MjywsOIEGqgGxai4PjyhI/OrVq84fvnyp/fbjR9mtu3crHj99Wv7t16+yV2/e1F+5ccMGFDy9fHxCWF2I5EqmdCEhUGAz3rl2LfLB7dvPH929e/fEkSMPTgLx/du37zy6d+/N7y9f3EBqFikpieE0EGgkOCKiVcz4nuu5cm8y9uGqF1LhywWGNTC2WSBYnmOimQffc9di7lVKxvxpxsZceAyEAPHAbjEG7wpBhtB6HoaYRdxbDp2IPHL2Ytne4+cq9py4GMLAEMomFL2Yj8E4UJLbtRjVhaDwq6//zwQ2qe2/MHvzf0V5+3wBZAsunz2u+ebxY4tbF89YXDx1Sh052cgkz8Ydhgz1/7l4J/8XFrKIk+bn1xdgAHobjIEad+4+kHXg8NE0kDJR+1Aecb0Ybn45G0GZ0F6wgSyCgoL8IMaxY8d0b926FXLjxo1QIFYEiUk5xwprZe3nUZl4i92i9xgniN26bI9467JL4sb1T7nk6/dz2M//z6EUOpNf1D6LB2wgLy8vONvt3LnTeM+ePTG7du2KnT9/KSi3MAoJCfGRk1PY8SgEBkc9EyLm/zNiskHAGGwgAL767TM7F884AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"cors preflight\" title=\"\" src=\"/static/c86699252752391939dc68f8f9a860bf/6af66/cors-preflight.png\" srcset=\"/static/c86699252752391939dc68f8f9a860bf/69538/cors-preflight.png 160w,\n/static/c86699252752391939dc68f8f9a860bf/72799/cors-preflight.png 320w,\n/static/c86699252752391939dc68f8f9a860bf/6af66/cors-preflight.png 640w,\n/static/c86699252752391939dc68f8f9a860bf/d9199/cors-preflight.png 960w,\n/static/c86699252752391939dc68f8f9a860bf/21b4d/cors-preflight.png 1280w,\n/static/c86699252752391939dc68f8f9a860bf/2b36a/cors-preflight.png 2268w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>브라우저는 본 요청을 보내기 전 예비 요청을 먼저 보내고, 요청의 유효성을 검사한다</small>\n</center>\n<p>우리가 자바스크립트의 <code class=\"language-text\">fetch</code> API를 사용하여 브라우저에게 리소스를 받아오라는 명령을 내리면 브라우저는 서버에게 예비 요청을 먼저 보내고, 서버는 이 예비 요청에 대한 응답으로 현재 자신이 어떤 것들을 허용하고, 어떤 것들을 금지하고 있는지에 대한 정보를 응답 헤더에 담아서 브라우저에게 다시 보내주게 된다.</p>\n<p>이후 브라우저는 자신이 보낸 예비 요청과 서버가 응답에 담아준 허용 정책을 비교한 후, 이 요청을 보내는 것이 안전하다고 판단되면 같은 엔드포인트로 다시 본 요청을 보내게 된다. 이후 서버가 이 본 요청에 대한 응답을 하면 브라우저는 최종적으로 이 응답 데이터를 자바스크립트에게 넘겨준다.</p>\n<p>이 플로우는 브라우저의 개발자 도구 콘솔에서도 간단하게 재현해볼 수 있는데, 필자의 블로그 환경에서 필자의 티스토리 블로그의 RSS 파일 리소스에 요청을 보내면 브라우저가 본 요청을 보내기 전에 <code class=\"language-text\">OPTIONS</code> 메소드를 사용하여 예비 요청을 보내는 것을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> headers <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Headers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">'Content-Type'</span><span class=\"token operator\">:</span> <span class=\"token string\">'text/xml'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://evanmoon.tistory.com/rss'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> headers <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">OPTIONS https://evanmoon.tistory.com/rss\n\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">*/*</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept-Encoding</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">gzip, deflate, br</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept-Language</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">en-US,en;q=0.9,ko;q=0.8,ja;q=0.7,la;q=0.6</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Access-Control-Request-Headers</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">content-type</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Access-Control-Request-Method</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">GET</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Connection</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">keep-alive</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">evanmoon.tistory.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Origin</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">https://evan-moon.github.io</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Referer</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">https://evan-moon.github.io/2020/05/21/about-cors/</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Sec-Fetch-Dest</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">empty</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Sec-Fetch-Mode</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">cors</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Sec-Fetch-Site</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">cross-site</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>실제로 브라우저가 보낸 요청을 보면, 단순히 <code class=\"language-text\">Origin</code>에 대한 정보 뿐만 아니라 자신이 예비 요청 이후에 보낼 본 요청에 대한 다른 정보들도 함께 포함되어 있는 것을 볼 수 있다.</p>\n<p>이 예비 요청에서 브라우저는 <code class=\"language-text\">Access-Control-Request-Headers</code>를 사용하여 자신이 본 요청에서 <code class=\"language-text\">Content-Type</code> 헤더를 사용할 것을 알려주거나, <code class=\"language-text\">Access-Control-Request-Method</code>를 사용하여 이후 <code class=\"language-text\">GET</code> 메소드를 사용할 것을 서버에게 미리 알려주고 있는 것이다.</p>\n<p>이렇게 티스토리 서버에 예비 요청을 보내면, 이제 티스토리 서버가 이 예비 요청에 대한 응답을 보내준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">OPTIONS https://evanmoon.tistory.com/rss 200 OK\n\n<span class=\"token header\"><span class=\"token header-name keyword\">Access-Control-Allow-Origin</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">https://evanmoon.tistory.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Encoding</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">gzip</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Length</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">699</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/xml; charset=utf-8</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Date</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Sun, 24 May 2020 11:52:33 GMT</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">P3P</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">CP='ALL DSP COR MON LAW OUR LEG DEL'</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Server</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Apache</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Vary</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Accept-Encoding</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">X-UA-Compatible</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">IE=Edge</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서 우리가 눈여겨 봐야할 것은 서버가 보내준 응답 헤더에 포함된 <code class=\"language-text\">Access-Control-Allow-Origin: https://evanmoon.tistory.com</code>라는 값이다.</p>\n<p>티스토리 서버는 이 리소스에 접근이 가능한 출처는 오직 <code class=\"language-text\">https://evanmoon.tistory.com</code> 뿐이라고 브라우저에게 이야기해준 것이고, 필자가 이 요청을 보낸 출처는 <code class=\"language-text\">https://evan-moon.github.io</code>이므로 서버가 허용해준 출처와는 다른 출처이다.</p>\n<p>결국 브라우저는 이 요청이 CORS 정책을 위반했다고 판단하고 다음과 같은 에러를 뱉게 되는 것이다.</p>\n<blockquote>\n<p>🚨 Access to fetch at ’<a href=\"https://evanmoon.tistory.com/rss\" target=\"_blank\" rel=\"nofollow\">https://evanmoon.tistory.com/rss</a>’ from origin ‘https://evan-moon.github.io’ has been blocked by CORS policy: Response to preflight request doesn’t pass access control check: The ‘Access-Control-Allow-Origin’ header has a value ‘http://evanmoon.tistory.com’ that is not equal to the supplied origin. Have the server send the header with a valid value, or, if an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled.</p>\n</blockquote>\n<p>이때 예비 요청에 대한 응답에서 에러가 발생하지 않고 정상적으로 <code class=\"language-text\">200</code>이 떨어졌는데, 콘솔 창에는 빨갛게 에러가 표시되기 때문에 많은 분들이 헷갈려하시는데, CORS 정책 위반으로 인한 에러는 예비 요청의 성공 여부와 별 상관이 없다. 브라우저가 CORS 정책 위반 여부를 판단하는 시점은 예비 요청에 대한 응답을 받은 이후이기 때문이다.</p>\n<p>물론 예비 요청 자체가 실패해도 똑같이 CORS 정책 위반으로 처리될 수도 있지만, 중요한 것은 예비 요청의 성공/실패 여부가 아니라 “응답 헤더에 유효한 <code class=\"language-text\">Access-Control-Allow-Origin</code> 값이 존재하는가”이다. 만약 예비 요청이 실패해서 <code class=\"language-text\">200</code>이 아닌 상태 코드가 내려오더라도 헤더에 저 값이 제대로 들어가있다면 CORS 정책 위반이 아니라는 의미이다.</p>\n<p>대부분의 경우 이렇게 예비 요청, 본 요청을 나누어 보내는 프리플라이트 방식을 사용하기는 하지만, 모든 상황에서 이렇게 두 번씩 요청을 보내는 것은 아니다. 조금 까다로운 조건이기는 하지만 어떤 경우에는 예비 요청없이 본 요청만으로 CORS 정책 위반 여부를 검사하기도 한다.</p>\n<h3 id=\"simple-request\" style=\"position:relative;\">Simple Request<a href=\"#simple-request\" aria-label=\"simple request permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 시나리오에 대한 정식 명칭은 없지만 MDN의 CORS 문서에서는 이 시나리오를 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/CORS#%EC%A0%91%EA%B7%BC_%EC%A0%9C%EC%96%B4_%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4_%EC%98%88%EC%A0%9C\" target=\"_blank\" rel=\"nofollow\">Simple Request</a>라고 부르고 있으니, 필자도 그냥 “단순 요청(Simple Request)“이라고 부르도록 하겠다.</p>\n<p>단순 요청은 예비 요청을 보내지 않고 바로 서버에게 본 요청부터 때려박은 후, 서버가 이에 대한 응답의 헤더에 <code class=\"language-text\">Access-Control-Allow-Origin</code>과 같은 값을 보내주면 그때 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다. 즉, 프리플라이트와 단순 요청 시나리오는 전반적인 로직 자체는 같되, 예비 요청의 존재 유무만 다르다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 48.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABx0lEQVR42mNgYGDQB2I5BkzADMSaQKwDxKwMhIECEGuDGFyhoaEgzQzLli0TP3HihJaxsTHIAEYgZgPJQ9T/Z4RgGEDn27MACQ4Qi8/CwoITxFi9erXz/v37a+3t7XmgrhIEYh4G4gAzzEBOnErs61kkfepFjNPOcJnVb+NLnn1MaM6G61LLzj6UWn/5rWz9pqci9ln7eYzrz3DJRbULimqBHYIw8P///4yrVq1ihnqXQav+Cg+vRoCwjAzEB4vXrpU5ePhY5YmzZ8v2HTrStGv/fhOQuEVoISevlIawiHuVJHYX1v/nYqj5ry5Y/xQUWdwgi4DYE4hjf/78Fnv6xIm4169fxgL5MUAcBsS8IG0asZOFcRnIxLDqP7N8/noBBmF1KfusLJ6r127uvXvv/usr127cP3jk6MMLFy89uHP33tN7Dx7ePn75Jig1cOjFTBODGwjyKtAmLigGB65x2kxWpdCZ/KGr/rPJ28/nYLBYxckQv59DZeI/dnkgLRO6ihNEg+RBwSPsV8rLwM3NLQ6KofXr1xscO3asF5hsJhw5ciQTGmPciGRDWiwz1tfXs0ycOJEdhIFsNmjEwNMWnnTIiEiHKuwAnnGz5V1xAocAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"simple request\" title=\"\" src=\"/static/d8ed6519e305c807c687032ff61240f8/6af66/simple-request.png\" srcset=\"/static/d8ed6519e305c807c687032ff61240f8/69538/simple-request.png 160w,\n/static/d8ed6519e305c807c687032ff61240f8/72799/simple-request.png 320w,\n/static/d8ed6519e305c807c687032ff61240f8/6af66/simple-request.png 640w,\n/static/d8ed6519e305c807c687032ff61240f8/d9199/simple-request.png 960w,\n/static/d8ed6519e305c807c687032ff61240f8/21b4d/simple-request.png 1280w,\n/static/d8ed6519e305c807c687032ff61240f8/2b36a/simple-request.png 2268w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>단순 요청은 예비 요청없이 바로 본 요청으로 퉁치는 시나리오이다</small>\n</center>\n<p>하지만 아무 때나 단순 요청을 사용할 수 있는 것은 아니고, 특정 조건을 만족하는 경우에만 예비 요청을 생략할 수 있다. 게다가 이 조건이 조금 까다롭기 때문에 일반적인 방법으로 웹 어플리케이션 아키텍처를 설계하게 되면 거의 충족시키기 어려운 조건들이라 필자도 이런 경우를 거의 경험하지는 못 했다.</p>\n<hr>\n<ol>\n<li>요청의 메소드는 <code class=\"language-text\">GET</code>, <code class=\"language-text\">HEAD</code>, <code class=\"language-text\">POST</code> 중 하나여야 한다.</li>\n<li><code class=\"language-text\">Accept</code>, <code class=\"language-text\">Accept-Language</code>, <code class=\"language-text\">Content-Language</code>, <code class=\"language-text\">Content-Type</code>, <code class=\"language-text\">DPR</code>, <code class=\"language-text\">Downlink</code>, <code class=\"language-text\">Save-Data</code>, <code class=\"language-text\">Viewport-Width</code>, <code class=\"language-text\">Width</code>를 제외한 헤더를 사용하면 안된다.</li>\n<li>만약 <code class=\"language-text\">Content-Type</code>를 사용하는 경우에는 <code class=\"language-text\">application/x-www-form-urlencoded</code>, <code class=\"language-text\">multipart/form-data</code>, <code class=\"language-text\">text/plain</code>만 허용된다.</li>\n</ol>\n<hr>\n<p>사실 1번 조건의 경우는 그냥 <code class=\"language-text\">PUT</code>이나 <code class=\"language-text\">DELETE</code> 같은 메소드를 사용하지 않으면 되는 것 뿐이니 그렇게 보기 드문 상황은 아니지만, 2번이나 3번 조건 같은 경우는 조금 까다롭다.</p>\n<p>애초에 저 조건에 명시된 헤더들은 진짜 기본적인 헤더들이기 때문에, 복잡한 상용 웹 어플리케이션에서 이 헤더들 외에 추가적인 헤더를 사용하지 않는 경우는 드물다. 당장 사용자 인증에 사용되는 <code class=\"language-text\">Authorization</code> 헤더 조차 저 조건에는 포함되지 않는다.</p>\n<p>게다가 대부분의 HTTP API는 <code class=\"language-text\">text/xml</code>이나 <code class=\"language-text\">application/json</code> 컨텐츠 타입을 가지도록 설계되기 때문에 사실 상 이 조건들을 모두 만족시키는 상황을 만들기는 그렇게 쉽지 않은 것이 현실이다.</p>\n<h3 id=\"credentialed-request\" style=\"position:relative;\">Credentialed Request<a href=\"#credentialed-request\" aria-label=\"credentialed request permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>3번째 시나리오는 인증된 요청을 사용하는 방법이다. 이 시나리오는 CORS의 기본적인 방식이라기 보다는 다른 출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용하는 방법이다.</p>\n<p>기본적으로 브라우저가 제공하는 비동기 리소스 요청 API인 <code class=\"language-text\">XMLHttpRequest</code> 객체나 <code class=\"language-text\">fetch</code> API는 별도의 옵션 없이 브라우저의 쿠키 정보나 인증과 관련된 헤더를 함부로 요청에 담지 않는다. 이때 요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션이 바로 <code class=\"language-text\">credentials</code> 옵션이다.</p>\n<p>이 옵션에는 총 3가지의 값을 사용할 수 있으며, 각 값들이 가지는 의미는 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th>옵션 값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>same-origin (기본값)</td>\n<td>같은 출처 간 요청에만 인증 정보를 담을 수 있다</td>\n</tr>\n<tr>\n<td>include</td>\n<td>모든 요청에 인증 정보를 담을 수 있다</td>\n</tr>\n<tr>\n<td>omit</td>\n<td>모든 요청에 인증 정보를 담지 않는다</td>\n</tr>\n</tbody>\n</table>\n<p>만약 여러분이 <code class=\"language-text\">same-origin</code>이나 <code class=\"language-text\">include</code>와 같은 옵션을 사용하여 리소스 요청에 인증 정보가 포함된다면, 이제 브라우저는 다른 출처의 리소스를 요청할 때 단순히 <code class=\"language-text\">Access-Control-Allow-Origin</code>만 확인하는 것이 아니라 좀 더 빡빡한 검사 조건을 추가하게 된다.</p>\n<p>백문이불여일견이니 필자가 지금 이 포스팅을 작성하고 있는 로컬 환경과 필자의 블로그를 호스팅하고 있는 Github 서버와의 통신을 통해, 어떤 제약이 추가되었는지 직접 살펴보는 것이 좋을 것 같다.</p>\n<p>필자의 블로그는 <code class=\"language-text\">Access-Control-Allow-Origin</code> 값으로 모든 출처를 허용한다는 의미인 <code class=\"language-text\">*</code>가 설정되어있기 때문에, 다른 출처에서 필자의 블로그로 리소스를 요청할 때 CORS 정책 위반으로 인한 제약을 받지 않는다.</p>\n<p>그래서 <code class=\"language-text\">http://localhost:8000</code>과 같은 로컬의 개발 환경에서도 <code class=\"language-text\">fetch</code> API를 사용하여 마음대로 리소스를 요청하고, 또 받아올 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://evan-moon.github.io/feed.xml'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">Request\nGET https://evan-moon.github.io/feed.xml\n\n<span class=\"token header\"><span class=\"token header-name keyword\">Origin</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">http://localhost:8000</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Referer</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">http://localhost:8000/2020/05/21/about-cors/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">Response\nGET https://evan-moon.github.io/feed.xml 200 OK\n\n<span class=\"token header\"><span class=\"token header-name keyword\">Access-Control-Allow-Origin</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">*</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Encoding</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">gzip</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Length</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">1132748</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/xml</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Server</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">GitHub.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Status</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">200</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한 구글 크롬 브라우저의 <code class=\"language-text\">credentials</code> 기본 값은 같은 출처 내에서만 인증 정보를 사용하겠다는 <code class=\"language-text\">same-origin</code>이기 때문에, 필자의 로컬 환경에서 <code class=\"language-text\">https://evan-moon.github.io</code>로 보내는 리소스 요청에는 당연히 브라우저의 쿠키와 같은 인증 정보가 포함되어 있지 않다.</p>\n<p>그렇기 때문에 브라우저는 단순히 <code class=\"language-text\">Access-Control-Allow-Origin: *</code>이라는 값만 보고 “이 요청은 안전하구만”이라는 결론을 내리는 것이다. 그러나 필자가 <code class=\"language-text\">credentials</code> 옵션을 모든 요청에 인증 정보를 포함하겠다는 의미를 가진 <code class=\"language-text\">include</code>로 변경하고 같은 요청을 보내면 이번에는 상황이 조금 달라진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://evan-moon.github.io/feed.xml'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">credentials</span><span class=\"token operator\">:</span> <span class=\"token string\">'include'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// Credentials 옵션 변경!</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>직접 브라우저 콘솔에서 실행해보면 알겠지만, 이번에는 <code class=\"language-text\">credentials: include</code> 옵션을 사용하여 동일 출처 여부와 상관없이 무조건 요청에 인증 정보가 포함되도록 설정했으므로, 이번 요청에는 브라우저의 쿠키 정보가 함께 담겨있는 것을 확인해볼 수 있다.</p>\n<p>필자의 블로그를 호스팅하고 있는 Github 서버는 이번에도 동일한 응답을 보내주었지만, 브라우저의 반응은 다르다.</p>\n<blockquote>\n<p>🚨 Access to fetch at ’<a href=\"https://evan-moon.github.io/feed.xml\" target=\"_blank\" rel=\"nofollow\">https://evan-moon.github.io/feed.xml</a>’ from origin ’<a href=\"http://localhost:8000\" target=\"_blank\" rel=\"nofollow\">http://localhost:8000</a>’ has been blocked by CORS policy: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ’*’ when the request’s credentials mode is ‘include’.</p>\n</blockquote>\n<p>브라우저는 인증 모드가 <code class=\"language-text\">include</code>일 경우, 모든 요청을 허용한다는 의미의 <code class=\"language-text\">*</code>를 <code class=\"language-text\">Access-Control-Allow-Origin</code> 헤더에 사용하면 안된다고 이야기하고 있다.</p>\n<p>이처럼 요청에 인증 정보가 담겨있는 상태에서 다른 출처의 리소스를 요청하게 되면 브라우저는 CORS 정책 위반 여부를 검사하는 룰에 다음 두 가지를 추가하게 된다.</p>\n<hr>\n<ol>\n<li><code class=\"language-text\">Access-Control-Allow-Origin</code>에는 <code class=\"language-text\">*</code>를 사용할 수 없으며, 명시적인 URL이어야한다.</li>\n<li>응답 헤더에는 반드시 <code class=\"language-text\">Access-Control-Allow-Credentials: true</code>가 존재해야한다.</li>\n</ol>\n<hr>\n<p>인증까지 얶혀있는 이 시나리오는 다른 시나리오에 비해서 다소 복잡하게 느껴질 수는 있지만, 이렇게 CORS 정책에 대한 다양한 시나리오를 알아두면 실제 상황에서 CORS 정책 위반으로 인한 문제가 발생했을 경우 삽질해야하는 시간을 크게 단축시킬 수 있으니 숙지해놓는 것을 추천한다. <small>(하라는 거 다 했는데 왜 안돼? 같은 상황을 조금은 예방할 수 있다)</small></p>\n<h2 id=\"cors를-해결할-수-있는-방법\" style=\"position:relative;\">CORS를 해결할 수 있는 방법<a href=\"#cors%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"cors를 해결할 수 있는 방법 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 CORS가 무엇인지, 어떤 상황에서 CORS 정책이 적용되고 위반되는 것인지 알아봤다면 이번 섹션에서는 실질적으로 CORS 정책 위반으로 인한 문제가 발생했을 경우에 해결할 수 있는 방법을 알아보도록 하자.</p>\n<h3 id=\"access-control-allow-origin-세팅하기\" style=\"position:relative;\">Access-Control-Allow-Origin 세팅하기<a href=\"#access-control-allow-origin-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0\" aria-label=\"access control allow origin 세팅하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>CORS 정책 위반으로 인한 문제를 해결하는 가장 대표적인 방법은, 그냥 정석대로 서버에서 <code class=\"language-text\">Access-Control-Allow-Origin</code> 헤더에 알맞은 값을 세팅해주는 것이다.</p>\n<p>이때 와일드카드인 <code class=\"language-text\">*</code>을 사용하여 이 헤더를 세팅하게 되면 모든 출처에서 오는 요청을 받아먹겠다는 의미이므로 당장은 편할 수 있겠지만, 바꿔서 생각하면 정체도 모르는 이상한 출처에서 오는 요청까지 모두 받아먹겠다는 오픈 마인드와 다를 것 없으므로 보안적으로 심각한 이슈가 발생할 수도 있다.</p>\n<p>그러니 가급적이면 귀찮더라도 <code class=\"language-text\">Access-Control-Allow-Origin: https://evan.github.io</code>와 같이 출처를 명시해주도록 하자.</p>\n<p>이 헤더는 Nginx나 Apache와 같은 서버 엔진의 설정에서 추가할 수도 있지만, 아무래도 복잡한 세팅을 하기는 불편하기 때문에 소스 코드 내에서 응답 미들웨어 등을 사용하여 세팅하는 것을 추천한다. Spring, Express, Django와 같이 이름있는 백엔드 프레임워크의 경우에는 모두 CORS 관련 설정을 위한 세팅이나 미들웨어 라이브러리를 제공하고 있으니 세팅 자체가 어렵지는 않을 것이다.</p>\n<h3 id=\"webpack-dev-server로-리버스-프록싱하기\" style=\"position:relative;\">Webpack Dev Server로 리버스 프록싱하기<a href=\"#webpack-dev-server%EB%A1%9C-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%B1%ED%95%98%EA%B8%B0\" aria-label=\"webpack dev server로 리버스 프록싱하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>사실 CORS를 가장 많이 마주치는 환경은 바로 로컬에서 프론트엔드 어플리케이션을 개발하는 경우라고 해도 과언이 아니다. 백엔드에는 이미 <code class=\"language-text\">Access-Control-Allow-Origin</code> 헤더가 세팅되어있겠지만, 이 중요한 헤더에다가 <code class=\"language-text\">http://localhost:3000</code> 같은 범용적인 출처를 넣어주는 경우는 드물기 때문이다.</p>\n<p>프론트엔드 개발자는 대부분 웹팩과 webpack-dev-server를 사용하여 자신의 머신에 개발 환경을 구축하게 되는데, 이 라이브러리가 제공하는 프록시 기능을 사용하면 아주 편하게 CORS 정책을 우회할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">devServer</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">proxy</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string-property property\">'/api'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token literal-property property\">target</span><span class=\"token operator\">:</span> <span class=\"token string\">'https://api.evan.com'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">changeOrigin</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">pathRewrite</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token string-property property\">'^/api'</span><span class=\"token operator\">:</span> <span class=\"token string\">''</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 설정을 해놓으면 로컬 환경에서 <code class=\"language-text\">/api</code>로 시작하는 URL로 보내는 요청에 대해 브라우저는 <code class=\"language-text\">localhost:8000/api</code>로 요청을 보낸 것으로 알고 있지만, 사실 뒤에서 웹팩이 <code class=\"language-text\">https://api.evan.com</code>으로 요청을 프록싱해주기 때문에 마치 CORS 정책을 지킨 것처럼 브라우저를 속이면서도 우리는 원하는 서버와 자유롭게 통신을 할 수 있다. 즉, 프록싱을 통해 CORS 정책을 우회할 수 있는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 518px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 76.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACKUlEQVR42pWUZ4siQRCG/fmifvCDkTUnMKGimLOucY2YUBEzBlAXQRBh63gLZrnd9Y67gZ7prq556q2qnhFVq1XK5/NkNpt5vLy8kMvlIpPJRGq1moxGI/n9fvL5fKTVaslqtZJGo2G7xWIhvV7PtkKhQKVSiUS4tVotcrvdDMSm3W7nuU6nI4VCQUqlkiQSCYnFYrYhkPBUqVQcvF6v0+vrK4nK5TIvGo0Gj2azyQPzbrdLTqeTZDIZSaVScjgcHFzYx7PdbrPtC/Dt7Y1qtRobMTDHC9lsllM9nU50PB45C6SGPcH39/EF+H0T0QHEAPB8PlMkEmGgEPS/gahvv99nCHzQwFwux2k+U/lHoLBOJBLU6XQoFApROp1mVcFgkLxe72eQfwJCSbFYpOVySfP5nEajEc1mM/J4PHxM0HmDwfAj7b8C39/fab/f03a7JZvNxmcTTYFCvIPaflf5A4gnnKbTKV0uF64TUo7H47z3eDy4rvBFo4TgT4HCUclkMrRarWi327FKNGWz2ZBwQfFwOOQ9nNOnKWNRqVQYjC6iw/f7nQGo3/V6/QSu12tKJpO0WCy4zoAIShmIG0CIBhg6Ox6PWRUUAwb47Xajj48PVocgh8OB7UIJ4MtALABC4cPhMAPRSXz4sAk/gUAgwD8JuVzOc3zvgPR6Pa5xNBpljmgymVAqleI/CDo3GAy4kzi8UI45gkAJ6oyXY7EYA+CLpqH7OAXw/wVI5OBE3AhEbgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"trap\" title=\"\" src=\"/static/e4e41838e8e9f4ac284b2b2a6214052f/6b9fd/trap.png\" srcset=\"/static/e4e41838e8e9f4ac284b2b2a6214052f/69538/trap.png 160w,\n/static/e4e41838e8e9f4ac284b2b2a6214052f/72799/trap.png 320w,\n/static/e4e41838e8e9f4ac284b2b2a6214052f/6b9fd/trap.png 518w\" sizes=\"(max-width: 518px) 100vw, 518px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>웹팩의 함정 카드 리버스 프록싱(이)가 발동했다!</small>\n</center>\n<p>혹시 <a href=\"https://github.com/webpack/webpack-dev-middleware\" target=\"_blank\" rel=\"nofollow\">webpack-dev-middleware</a>와 Node 서버의 조합으로 개발 환경을 직접 구축했더라도 <a href=\"https://github.com/chimurai/http-proxy-middleware\" target=\"_blank\" rel=\"nofollow\">http-proxy-middleware</a> 라이브러리를 사용하면 손쉽게 프록시 설정을 할 수 있으니 걱정하지말자. <small>(webpack-dev-server도 내부적으로는 어차피 http-proxy-middleware를 사용한다)</small></p>\n<p>다만 이 방법은 실제 프로덕션 환경에서도 클라이언트 어플리케이션의 소스를 서빙하는 출처와 API 서버의 출처가 같은 경우에 사용하는 것이 좋다. 물론 로컬 개발 환경에서야 웹팩이 요청을 프록싱해주니 아무 이상이 없겠지만, 어플리케이션을 빌드하고 서버에 올리고 나면 더 이상 webpack-dev-server가 구동하는 환경이 아니기 때문에 프록싱이고 나발이고 이상한 곳으로 API 요청을 보내기 때문이다.</p>\n<p>예를 들어 API 서버의 출처는 <code class=\"language-text\">https://api.evan.com</code>이고 클라이언트 어플리케이션을 서빙하는 서버의 출처는 <code class=\"language-text\">https://www.evan.com</code>이라면, 다음과 같은 상황이 발생한다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/me'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">로컬환경에서는...\nGET https://api.evan.com/me 200 OK\n\n실제 서버에는 프록싱 로직이 없음...\nGET https://www.evan.com/api/me 404 Not Found</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>물론 비즈니스 로직 내에서 <code class=\"language-text\">process.env.NODE_ENV</code>와 같은 빌드 환경 변수를 사용하여 분기 로직을 작성하는 방법도 있지만, 개인적으로 비즈니스 로직에 이런 개발 환경 전용 소스가 포함되는 것은 별로 좋지 않다고 생각해서 피하는 편이다.</p>\n<h3 id=\"요청을-img-태그에-넣으면-어떨까\" style=\"position:relative;\">요청을 img 태그에 넣으면 어떨까?<a href=\"#%EC%9A%94%EC%B2%AD%EC%9D%84-img-%ED%83%9C%EA%B7%B8%EC%97%90-%EB%84%A3%EC%9C%BC%EB%A9%B4-%EC%96%B4%EB%96%A8%EA%B9%8C\" aria-label=\"요청을 img 태그에 넣으면 어떨까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자는 앞서 SOP(Same-Origin Policy) 정책에는 다른 출처의 리소스에 접근할 수 있는 몇 가지 예외조항이 존재하고, 그 중 하나가 CORS 정책을 지킨 요청이라고 이야기했었다. 그리고 CORS 정책을 지킨 요청을 제외한 SOP의 예외 조항은 실행 가능한 스크립트, 렌더될 이미지, 스타일 시트 정도가 있다.</p>\n<p>그렇다면 다른 예외 조항이 적용된 요청을 보내면 CORS를 우회할 수 있지 않을까…? 이렇게 말이다!</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-html line-numbers\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://evanmoon.tistory.com/rss<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://evanmoon.tistory.com/rss<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>물론 이런 식으로 접근하면 CORS를 위반하지 않고 요청 자체는 성공한다. 그리고 브라우저의 개발자 도구의 네트워크 탭에서 이 요청들의 헤더를 자세히 살펴보면 <code class=\"language-text\">Sec-Fetch-Mode: no-cors</code>라는 값이 포함되어 있는 것을 볼 수 있다.</p>\n<p><code class=\"language-text\">Sec-Fetch-Mode</code> 헤더는 요청 모드를 설정하는 필드인데, 브라우저는 이 필드의 값이 <code class=\"language-text\">no-cors</code>인 경우에는 다른 출처라고 해도 CORS 정책 위반 여부를 검사하지 않는다. 하지만 한 가지 슬픈 점은 브라우저가 이 헤더에 값이 포함된 요청의 응답을 자바스크립트에게 알려주지 않는다는 것이다. 즉, 우리는 코드 레벨에서 절대 이 응답에 담긴 내용에 접근할 수가 없다.</p>\n<p>필자도 이게 진짜 방법이 없는건지 궁금해서 이것저것 시도해보았는데 결과적으로 전부 실패했다. 그러니 어찌어찌 CORS를 우회하려는 시도는 그냥 깔끔하게 포기하고 똑똑한 아저씨들이 시키는 대로 CORS 정책을 지키도록 하자.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>아무래도 CORS 정책 위반으로 인해 생기는 문제를 해결할 때 가장 번거로운 점은 문제를 겪는 사람과 문제를 해결해야하는 사람이 다르다는 것이다.</p>\n<p>앞서 이야기했듯 CORS 정책은 브라우저의 구현 스펙이기 때문에 정책 위반으로 인해 문제를 겪는 사람은 대부분 프론트엔드 개발자이지만, 정작 문제를 해결하기 위해서는 백엔드 개발자가 서버 어플리케이션의 응답 헤더에 올바른 <code class=\"language-text\">Acccess-Control-Allow-Origin</code>이 내려올 수 있도록 세팅해줘야 하기 때문이다.</p>\n<p>물론 필자가 이야기했던 <code class=\"language-text\">webpack-dev-server</code>의 프록싱 옵션을 사용하여 자체적으로 해결하는 방법도 있지만, 이 방법은 로컬 개발 환경에서만 통하는 방법인데다가, 근본적인 문제 해결 방법이 아니기 때문에 결국 운영 환경에서 CORS 정책 위반 문제를 해결하기 위해서는 백엔드 개발자의 도움이 필요할 수 밖에 없다.</p>\n<p>사실 CORS 정책 위반을 해결하는 방법 자체가 그렇게 어렵고 복잡한 편은 아니라서 프론트엔드 개발자나 백엔드 개발자 중 한 명이라도 이러한 정책에 대해서 잘 알고 있는 경우라면 생각보다 빠르고 수월하게 문제를 해결할 수 있다.</p>\n<p>그러나 필자가 대학생 때 처음 CORS 정책 위반을 경험했던 것처럼 프론트엔드와 백엔드 둘 다 이런 문제에 대한 경험이 없는 경우에는 좀처럼 감을 잡기가 힘든, 참 묘한 문제인 것 같다.</p>\n<p>이상으로 CORS는 왜 이렇게 우리를 힘들게 하는걸까? 포스팅을 마친다.</p>","fields":{"slug":"20200521-about-cors","path":"/2020/05/21/about-cors/","lang":"ko"},"frontmatter":{"title":"CORS는 왜 이렇게 우리를 힘들게 하는걸까?","subTitle":"웹 보안과 개발자의 충돌, CORS를 이해해보자","date":"May 21, 2020","categories":["프로그래밍","네트워크","웹"],"tags":["CORS","Cross-Origin Resource Sharing","교차 출처 리소스 공유","네트워크","Web","보안 정책","Access-Control-Allow-Origin"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/e21f60bac8f04efc2928f1d0504fd95f/d803c/thumbnail.png","srcSet":"/static/e21f60bac8f04efc2928f1d0504fd95f/d803c/thumbnail.png 320w,\n/static/e21f60bac8f04efc2928f1d0504fd95f/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/e21f60bac8f04efc2928f1d0504fd95f/fc5c5/thumbnail.webp 320w,\n/static/e21f60bac8f04efc2928f1d0504fd95f/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/e21f60bac8f04efc2928f1d0504fd95f/01fb2/thumbnail.png","srcSet":"/static/e21f60bac8f04efc2928f1d0504fd95f/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/e21f60bac8f04efc2928f1d0504fd95f/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"26553317-3b91-575a-a94a-167cb8e11d35","tableOfContents":"<ul>\n<li>\n<p><a href=\"#http3%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%86%8C%EA%B0%9C\">HTTP/3에 대한 간단한 소개</a></p>\n</li>\n<li>\n<p><a href=\"#tcp%EA%B0%80-%EC%99%9C-%EB%8A%90%EB%A6%AC%EB%8B%A4%EA%B3%A0-%ED%95%98%EB%8A%94-%EA%B1%B8%EA%B9%8C\">TCP가 왜 느리다고 하는 걸까?</a></p>\n<ul>\n<li><a href=\"#3-way-handshake\">3 Way Handshake</a></li>\n<li><a href=\"#holbhead-of-line-blocking\">HOLB(Head of line Blocking)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#http3%EA%B0%80-udp%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">HTTP/3가 UDP를 사용하는 이유</a></p>\n<ul>\n<li><a href=\"#udp%EB%8A%94-%ED%95%98%EC%96%80-%EB%8F%84%ED%99%94%EC%A7%80-%EA%B0%99%EC%9D%80-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%B4%EB%8B%A4\">UDP는 하얀 도화지 같은 프로토콜이다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#http3%EA%B0%80-udp%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8-%EA%B8%B0%EC%A1%B4-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EB%B3%B4%EB%8B%A4-%EB%82%98%EC%95%84%EC%A7%84-%EC%A0%90\">HTTP/3가 UDP를 사용함으로써 기존 프로토콜보다 나아진 점</a></p>\n<ul>\n<li><a href=\"#%EC%97%B0%EA%B2%B0-%EC%84%A4%EC%A0%95-%EC%8B%9C-%EB%A0%88%EC%9D%B4%ED%84%B4%EC%8B%9C-%EA%B0%90%EC%86%8C\">연결 설정 시 레이턴시 감소</a></li>\n<li><a href=\"#%ED%8C%A8%ED%82%B7-%EC%86%90%EC%8B%A4-%EA%B0%90%EC%A7%80%EC%97%90-%EA%B1%B8%EB%A6%AC%EB%8A%94-%EC%8B%9C%EA%B0%84-%EB%8B%A8%EC%B6%95\">패킷 손실 감지에 걸리는 시간 단축</a></li>\n<li><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1%EC%9D%84-%EC%A7%80%EC%9B%90\">멀티플렉싱을 지원</a></li>\n<li><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%9D%98-ip%EA%B0%80-%EB%B0%94%EB%80%8C%EC%96%B4%EB%8F%84-%EC%97%B0%EA%B2%B0%EC%9D%B4-%EC%9C%A0%EC%A7%80%EB%90%A8\">클라이언트의 IP가 바뀌어도 연결이 유지됨</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0-%EB%A7%81%ED%81%AC\">참고 링크</a></p>\n</li>\n</ul>","excerpt":"HTTP/3는 HTTP(Hypertext Transfer Protocol)의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 QUIC을 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다. 필자는 최근에 다른 분들이 공유해주시는 포스팅을 보고 나서 HTTP/3가 나왔다는 것을 처음 알게 되었다. 그 포스팅은 HTTP/3: the past, the present, and the future라는 포스팅이었는데, 솔직히 처음 딱 제목만 보고나서 이런 생각을 했었다.","html":"<p>HTTP/3는 HTTP(Hypertext Transfer Protocol)의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 QUIC을 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.</p>\n<p>필자는 최근에 다른 분들이 공유해주시는 포스팅을 보고 나서 HTTP/3가 나왔다는 것을 처음 알게 되었다. 그 포스팅은 <a href=\"https://blog.cloudflare.com/http3-the-past-present-and-future/\" target=\"_blank\" rel=\"nofollow\">HTTP/3: the past, the present, and the future</a>라는 포스팅이었는데, 솔직히 처음 딱 제목만 보고나서 이런 생각을 했었다.</p>\n<!-- more -->\n<blockquote>\n<p>아니, HTTP/2가 공개된지 4년 정도 밖에 안 지났는데 무슨 HTTP/3가 벌써 나와? 그냥 설계하고 있다는 거 아니야?</p>\n</blockquote>\n<p>그런데 포스팅을 읽어 보니 이미 Google Chrome은 HTTP/3를 지원하는 카나리 빌드도 배포되어 있어서 실제로 사용까지 해볼 수 있는 단계에 도달했다는 사실을 알게 되어 놀랐다. HTTP/1에서 HTTP/2로 가는 데만 해도 대략 15년 정도의 시간이 걸렸는데, 고작 4년 만에 바로 사용해볼 수 있는 정도의 완성도인 다음 메이저 버전이 배포되었다는 것이다.</p>\n<p>게다가 아직 전 세계의 HTTP/2 점유율을 보면 40% 정도 밖에 안된다. 그 정도로 HTTP/2가 나온지도 얼마 되지 않았다는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABKklEQVR42pWS2W6DMBBF+f8vzAPYHryUBLyw2NikD70JqJGatErR0WgYrrnjsatt287nZO2ntdc3ce46DGVZSjVNM2OjUkXK/BKlnil1HYchVuM4CTEZs2ldjHmBlIXogLHSNIVzLEazsQph5DxApHVu20z0gLFc14gr5ysiaNtVylUpJNH7m/N8OoWmge5QfEN0SLU+QL6/ChGdi9U8L2h73wzMn3neM4pEaXeeOB/3X8LnHaA8nLGYsXAf7P8XL0vkfHp1Hr/yaBt7xrT3tt8EAyO6O6eEwY445D+sftwZiOHsXKq893X9IYQlsm3rhBiI3B0rZUCCT1L6HaVQgcByPvS9h3OKMeacQ/BCcK0VkUBUSgohLpczcmN0132g3nWm7/t8e9aU0hd/j8r0CkmYvgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ce http2\" title=\"\" src=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png\" srcset=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/69538/ce-http2.png 160w,\n/static/8a0a69c0fbc05eba2198cd4f552845d4/72799/ce-http2.png 320w,\n/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png 600w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>W3Techs.com에서 조사한 2019년 8월 HTTP/2 사용률</small>\n</center>\n<p>프로그래밍 언어나 프레임워크같은 친구들은 배포하는 쪽에서 업데이트를 쫙 해버리고 유저들이 업데이트를 하면 그만이지만, 프로토콜은 일종의 규약이기 때문에 소프트웨어 제조사 간 합을 맞추는 기간이 필요하므로 이렇게 단기간 안에 급격한 변화가 자주 발생하지 않을 것이라고 생각했다.</p>\n<p>아무리 요즘 기술의 변화가 빠르다지만, HTTP는 나름 웹의 근간이 되는 프로토콜인데 꼴랑 4년 만에 이런 급격한 변화가 일어났다는 게 놀라울 따름이다. <small>(몇 달 전에 HTTP/2를 처음 도입해본 웹 개발자는 웁니다)</small></p>\n<p>그리고 또 한가지 놀랐던 점은 HTTP/3는 TCP가 아닌 UDP를 사용한다는 것이었다. 뭐 딱히 웹 프로토콜이 무조건 TCP만 사용해야 한다는 법이 있는 건 아니긴 하지만, 학교에서 배울 때도 그렇고 실무에서도 실제로 사용할 때도 그렇고 HTTP는 TCP 위에서 정의된 프로토콜이라는 사실이 너무 당연하게 인식되어 있었기 때문에 UDP를 사용한다는 점이 신기하기도 했고 “왜 멀쩡히 잘 돌아가는 TCP를 냅두고 UDP를 사용하는거지?”라는 의문도 들었다.</p>\n<p>사실 HTTP/3는 정식으로 배포된 프로토콜이라기보다 아직 테스트를 거치고 있는 단계라고 보는 게 맞다. 하지만 위에서 이야기 했듯이 Google Chrome은 이미 HTTP/3를 지원하는 카나리 빌드를 배포한 상태이고, Mozila Firefox도 조만간 Nightly 버전에서 HTTP/3를 지원할 예정이며, cURL에서도 HTTP/3를 실험적 기능으로 제공하고 있는 만큼 가까운 미래 안에 HTTP/3가 메인 프로토콜이 될 가능성이 높은 것도 사실이다.</p>\n<p>만약 Google Chrome에서 HTTP/3 프로토콜을 사용해보고 싶다면 터미널에서 <code class=\"language-text\">--enable-quic</code>과 <code class=\"language-text\">--quic-version=h3-23</code> 인자를 사용하여 실행하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">open</span> <span class=\"token parameter variable\">-a</span> Google<span class=\"token punctuation\">\\</span> Chrome <span class=\"token parameter variable\">--args</span> --enable-quic --quic-version<span class=\"token operator\">=</span>h3-23</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/1d6e0c652510ca8a97827fff1fad7575/5a6dd/http3-demo.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60.62500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACTElEQVR42lWRSXPTQBCF/QcgS0EVBwriRIvtaLVkS9Y20mixExNClkMqcQrHCVVw4sbff/S0i5AcXnVP98yn162elBK1rDB2bXiO9azAsxH6ziupWlNLnH1ZIokmnC+Xp8jSGXzXwjTw0Gtuf8NabPA5u4Em7qCVK+jVPd6Fl3jrfsWOd44d95zyc7yxz6i3woFYYZd6ZvMdo24DjWqmvMf7yRV6d7/+IOxuYJfXcOU1jotv+OgI7Bsz7GgRdrUYe5Tvmwl29RjD9Ayf/BZ7lFviAra4hFVcwKmu8MEq0fv5Y4OTroHIE8iygMgSBGQ/Ivtx6CEi+fYQI6PPytOYeyovixRS5BS3bz17gN7m8RGyaZHmAhmplA1yUUFUNeft/BRJlkM3DOi6jiTNEYRTOuvIihJFKSkK5GWFY8sm4GaDum7pYkbAAgXBFFhBgzBEOJnC98cM0zSN76m6rmtIs//3CwJaloXeIzmcL04IULKqmsanr6oLChaEEziuC88bwzBMBoZUM8hxzg4rioLfWDY5fHh4QNvNnyHxLEUQhPB8nx2ocSbTiOoJQ1R/HITsWPUKMrGNNPIxOVyv12jajoGy6Rg2Go34wdHREUuNqpMUMKV9KuemaTKEjRBU7dx2nC2wJtAsyXjctltgfrKE47gMeKntDnNeg/qgWpH4N3Iltzt8enqiP7lgoLqsonIxjWIMBoNXYof049QKTNNgSEnOlFNlRpngHfKBFt/vH+Dw8JBin0dVLl5KOZzQuK7rcT6NY96tihHF4XCEv+fijBWB+5EDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"http3 demo\" title=\"\" src=\"/static/1d6e0c652510ca8a97827fff1fad7575/6af66/http3-demo.png\" srcset=\"/static/1d6e0c652510ca8a97827fff1fad7575/69538/http3-demo.png 160w,\n/static/1d6e0c652510ca8a97827fff1fad7575/72799/http3-demo.png 320w,\n/static/1d6e0c652510ca8a97827fff1fad7575/6af66/http3-demo.png 640w,\n/static/1d6e0c652510ca8a97827fff1fad7575/5a6dd/http3-demo.png 802w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>http/2+quic/46이라고 되어있는 녀석들이 HTTP/3 프로토콜을 사용한 연결이다</small>\n</center>\n<p>필자는 웹 개발자이기 때문에 HTTP가 메이저 업데이트 된다는 사실을 그냥 넘기기는 힘들었고, UDP를 사용한다는 것이 뭘 의미하는지도 궁금하기도 해서 결국 HTTP/3에 대한 조사를 하게 되었다. 그래서 이번 포스팅에서는 필자가 여기저기 쑤셔보면서 알아본 HTTP/3에 대한 내용을 정리해볼까 한다.</p>\n<h2 id=\"http3에-대한-간단한-소개\" style=\"position:relative;\">HTTP/3에 대한 간단한 소개<a href=\"#http3%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%86%8C%EA%B0%9C\" aria-label=\"http3에 대한 간단한 소개 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 HTTP/3는 처음에는 “HTTP-over-QUIC”이라는 이름을 가지고 있었는데, IETF(Internet Engineering Task Force) 내 HTTP 작업 그룹과 QUIC 작업 그룹의 의장인 마크 노팅엄이 이 프로토콜의 이름을 HTTP/3로 변경할 것을 제안했고, 2018년 11월에 이 제안이 통과되어 HTTP-over-QUIC이라는 이름에서 HTTP/3으로 변경되게 되었다.</p>\n<p>즉, HTTP/3는 QUIC이라는 프로토콜 위에서 돌아가는 HTTP인 것이다. QUIC은 “Quick UDP Internet Connection”의 약자로, 말 그대로 UDP를 사용하여 인터넷 연결을 하는 프로토콜이다. <small>(참고로 발음은 그냥 “퀵”이라고 한다)</small></p>\n<p>HTTP/3는 QUIC을 사용하고, QUIC은 UDP를 사용하기 때문에 결과적으로 HTTP/3는 UDP를 사용한다고 이야기 할 수 있는 것이다.</p>\n<p>그렇다면 QUIC이 도대체 뭐길래 기존의 TCP보다 더 빠른 전송 속도를 가질 수 있다는 것일까? 그 이유를 알려면 먼저 TCP가 왜 느리다고 하는지, UDP를 사용함으로써 어떤 이득을 얻을 수 있는지 부터 알아야 한다.</p>\n<h2 id=\"tcp가-왜-느리다고-하는-걸까\" style=\"position:relative;\">TCP가 왜 느리다고 하는 걸까?<a href=\"#tcp%EA%B0%80-%EC%99%9C-%EB%8A%90%EB%A6%AC%EB%8B%A4%EA%B3%A0-%ED%95%98%EB%8A%94-%EA%B1%B8%EA%B9%8C\" aria-label=\"tcp가 왜 느리다고 하는 걸까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 학교에서 네트워크 강의를 들을 때 TCP와 UDP의 차이에 대한 내용을 처음 배웠었는데, 교수님이 이건 반드시 시험에 나온다길래 이런 표를 보면서 열심히 외웠던 기억이 난다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>연결 방식</td>\n<td>연결형 서비스</td>\n<td>비연결형 서비스</td>\n</tr>\n<tr>\n<td>패킷 교환</td>\n<td>가상 회선 방식</td>\n<td>데이터그램 방식</td>\n</tr>\n<tr>\n<td>전송 순서 보장</td>\n<td>보장함</td>\n<td>보장하지 않음</td>\n</tr>\n<tr>\n<td>신뢰성</td>\n<td>높음</td>\n<td>낮음</td>\n</tr>\n<tr>\n<td>전송 속도</td>\n<td>느림</td>\n<td>빠름</td>\n</tr>\n</tbody>\n</table>\n<p>위 표를 보면 대략 “TCP는 신뢰성이 높고 느리다”, “UDP는 신뢰성이 낮고 빠르다” 정도로 정리가 되는데, 여기서 말하는 신뢰성이란 전송되는 데이터 패킷들의 순서, 패킷 유실 여부 등을 검사하여 송신 측이 보낸 모든 데이터가 수신 측에 온전하게 전달이 될 수 있느냐를 말하는 것이다.</p>\n<p>TCP는 클라이언트와 서버가 서로 신뢰성있는 통신을 할 수 있도록 몇 가지 방법을 사용하게되는데, 이 방법들 또한 결국은 클라이언트와 서버 간의 통신이기 때문에 레이턴시가 발생할 수 밖에 없다. 게다가 이 과정은 TCP라는 프로토콜이 생길 때부터 정의된 표준이므로 무시할 수도 없다.</p>\n<p>그렇다면 레이턴시를 줄이기 위해서는 TCP에서 정의한 기능 외에 다른 부분들을 건드려야 한다는 것인데, 여러모로 제한 사항이 많다. 아무리 회선의 대역폭을 늘린다고 해도 기술이 발전하면서 전송해야하는 데이터의 크기도 점점 커지기 때문에 결국 언젠가는 또 느려질 것이고, 회선의 전송 속도 자체를 높힌다고 해도 결국은 빛의 속도 보다 빠르게 전송할 수 없기 때문에 한계가 있다.</p>\n<p>HTTP/3이 UDP 기반인 QUIC 프로토콜을 사용하는 이유가 바로 이런 제약 조건을 뛰어넘기 위해 프로토콜 자체를 손보는 방법을 택한 것이다. 하지만 TCP는 워낙 오래된 프로토콜이기도 하고 커널까지 내려가는 로우 레벨에서 정의되어 있기 때문에 이걸 뜯어고치는 것도 만만치 않은 대작업이라 UDP를 선택한 것이다.</p>\n<p>그럼 한번 TCP가 신뢰성 있는 통신을 위해 사용하는 방법들이 왜 느리다고 하는지 알아보자.</p>\n<h3 id=\"3-way-handshake\" style=\"position:relative;\">3 Way Handshake<a href=\"#3-way-handshake\" aria-label=\"3 way handshake permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>TCP는 굉장히 친절한 프로토콜이다. 통신을 시작할 때와 종료할 때 서로 준비가 되어있는지를 반드시 먼저 물어보고 패킷을 전송할 순서를 정하고 나서야 본격적인 통신을 시작하기 때문이다.</p>\n<p>이때 통신을 시작할 때 거치는 과정을 3 Way Handshake, 통신을 마칠 때 거치는 과정을 4 Way Handshake라고 한다. 이 포스팅의 목적은 이 과정을 자세히 다루는 것이 아니므로, TCP를 사용하여 통신을 시작할 때 거치는 과정인 3 Way Handshake가 어떤 원리로 작동하는지만 설명하겠다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.74999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA9gAAAPYAF6eEWNAAACX0lEQVR42k1S227aQBD1//9EH/LQqhSpJNCE2IAvwXfWxvLd611fARHRgBSJW7A7wEvnYTS7O2fm7JlhTqdz27bb7Ycyldfr9fl8Ph6OTdO0/9nlcjkcDvCUpqltWbvdDhLgyCiKMpnwgiAihBzHCYIA/HK5BExzMwjKspzP557n2bataxrPC7wgTmWZEUW+8/MHxw0JwUmSYJwAvijKe8M7OM/zoijquoaiGGOOe+12O5I0YTx3riqS50Fpa2bOLAuZpllV9b0zwCEAtsPhkGVfx+NxHMfI1gWB8/w5A5TCMABKPM8PBgOWZf88PyfJtfNqtd5sPiAghMg3myGUxFhjPfaXYk19JooSWdaCIPZ93zCN668MI4qK/b5FqAj81R2sqSo8aRpkhqHrz3QjDkOGZdHDw/CpP03iCKGZaRqSJOVZBpjPz/3m7+fHtuUnCc9PBFBVkqIoTlLsuE61qJk0jZGlJ0kI5YG8YRij0SjPr+C5EUQOaY+thzA34uAevmZb9nOH6357El5Epi7r0I/LvAIlQBhCKQTEq067dk3279m+OYPaWYpxlmWQQAn1HM9UjSgIGNVRBmJ/oo+kN1EUhF7vd78/sJTqcmqrugbNrmpj/PjYAy0ty8rynGTE9d2yKpmRMey9dYbqE6UpMAflXc+lWXk8tba9CIJ3AGNMQSdCKDSnlBa0DNxgUS2YZb1c1Svwt03Iq6oCbuAB8/XVnE7NdttOp1TTVF3XLdvGBI8MtjvuyPM3BrZihkzQ2brZdVS6fgffFqy5jYrK8hTmZJowI7037na57y/C4z+QeJZeh7viqwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3way handshake\" title=\"\" src=\"/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png\" srcset=\"/static/dd7f29fecd14fe5feebc6cf562123c48/69538/3way-handshake.png 160w,\n/static/dd7f29fecd14fe5feebc6cf562123c48/72799/3way-handshake.png 320w,\n/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png 550w\" sizes=\"(max-width: 550px) 100vw, 550px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>통신을 시작할 때 3 Way Handshake를 하는 과정</small>\n</center>\n<p>위 그림을 보면 클라이언트가 처음 서버와 통신을 하기 위해 TCP 연결을 생성할 때 <code class=\"language-text\">SYN</code>와 <code class=\"language-text\">ACK</code>라는 패킷을 주고 받고 있다. 이 패킷 내부에 들어있는 값들을 사용하여 클라이언트와 서버가 서로 보낸 패킷의 순서와 패킷을 제대로 받았는 지를 확인할 수 있는 것이다.</p>\n<p>그리고 이 과정에는 총 3번의 통신이 필요하다. OSX나 Linux를 사용하고 있는 분이라면 터미널에서 <code class=\"language-text\">tcpdump</code> 유틸리티를 사용하여 이 과정을 직접 눈으로 확인해볼 수 있다.</p>\n<p>단, <code class=\"language-text\">tcpdump</code>를 아무 옵션 없이 사용하면 디바이스의 모든 패킷을 감시하고 출력하기 때문에 원하는 정보를 찾기 힘들다. 그래서 필자는 루프백에서 동작하고 있는 블로그 서버와의 통신만 캡쳐해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> tcpdump <span class=\"token function\">host</span> localhost <span class=\"token parameter variable\">-i</span> lo0\nIP localhost.53920 <span class=\"token operator\">></span> localhost.terabase: Flags <span class=\"token punctuation\">[</span>S<span class=\"token punctuation\">]</span>, <span class=\"token function\">seq</span> <span class=\"token number\">1260460927</span>, win <span class=\"token number\">65535</span>\nIP localhost.terabase <span class=\"token operator\">></span> localhost.53920: Flags <span class=\"token punctuation\">[</span>S.<span class=\"token punctuation\">]</span>, <span class=\"token function\">seq</span> <span class=\"token number\">3009967847</span>, ack <span class=\"token number\">1260460928</span>, win <span class=\"token number\">65535</span>\nIP localhost.53920 <span class=\"token operator\">></span> localhost.terabase: Flags <span class=\"token punctuation\">[</span>.<span class=\"token punctuation\">]</span>, ack <span class=\"token number\">3009967848</span>, win <span class=\"token number\">6379</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>보낸 놈 > 받은 놈: Flags [플래그 종류], 헤더의 값들</p>\n</blockquote>\n<p>원래는 이것보다 더 많은 정보가 나오지만, 여기에 전부 기재하기에는 양이 너무 많으니 설명에 필요한 정보만 추려보았다. 이 로그에서 중요한 키워드는 <code class=\"language-text\">Flag</code>, <code class=\"language-text\">seq</code>, <code class=\"language-text\">ack</code> 정도이다. 한번 하나하나 뜯어보도록 하자.</p>\n<p>먼저 <code class=\"language-text\">localhost.53920</code>은 클라이언트, <code class=\"language-text\">localhost.terabase</code>는 서버를 의미한다. 각 라인의 첫번째 필드는 <code class=\"language-text\">보낸 놈 > 받은 놈</code>을 의미하고 있으니, 첫 패킷은 클라이언트가 서버에게, 두 번째 패킷은 서버가 클라이언트에게 보낸 것이라고 할 수 있다. 그리고 각 라인에는 <code class=\"language-text\">Flag</code>라는 것이 붙어있는데, 플래그는 이 패킷이 어떤 타입의 패킷인지를 알려주는 역할을 한다.</p>\n<table>\n<thead>\n<tr>\n<th>Flag</th>\n<th>이름</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S</td>\n<td>SYN</td>\n<td>연결을 생성할 때 클라이언트가 서버에 시퀀스 번호를 보내는 패킷</td>\n</tr>\n<tr>\n<td>S.</td>\n<td>SYN-ACK</td>\n<td>시퀀스 번호를 받은 서버가 ACK 값을 생성하여 클라이언트에게 응답하는 패킷</td>\n</tr>\n<tr>\n<td>.</td>\n<td>ACK</td>\n<td>ACK 값을 사용하여 응답하는 패킷</td>\n</tr>\n</tbody>\n</table>\n<p>이 통신 과정을 거치고 나면 클라이언트와 서버는 신뢰성 있는 TCP 연결을 생성할 수 있고, 이때 총 3회의 통신을 하기 때문에 3 Way Handshake라고 하는 것이다.</p>\n<p>그렇다면 이 과정에서 어떤 일이 벌어지길래 신뢰성 있는 연결을 생성할 수 있다는 것일까? 조금 더 자세히 들여다보면 클라이언트와 서버는 3 Way Handshake를 할 때 대략 이런 과정을 거치고 있다.</p>\n<blockquote>\n<p>1번 라인: 클라이언트가 서버로 시퀀스 번호를 <code class=\"language-text\">seq</code> 필드에 담아 보냄<br />\n2번 라인: 서버는 클라이언트가 보내준 시퀀스 번호를 1 증가시켜서 <code class=\"language-text\">ack</code> 필드에 담아 보냄<br />\n3번 라인: 클라이언트는 다시 서버로부터 받은 시퀀스 번호를 1 증가시켜서 자신의 <code class=\"language-text\">ack</code> 필드에 담아 보냄<br /></p>\n</blockquote>\n<p>새로운 TCP 연결을 생성하고자 할 때 클라이언트가 서버에게 랜덤한 시퀀스 번호를 전송함으로써 3 Way Handshake가 시작된다. 이때 생성된 시퀀스 번호는 이후 송신 측이 전송한 패킷을 수신 측이 재조립할때 패킷의 조립 순서를 알려주는 역할을 한다.</p>\n<p>이때 클라이언트와 서버는 상대방이 보내준 <code class=\"language-text\">seq(시퀀스 번호)</code>를 1 증가 시킨 후 자신의 <code class=\"language-text\">ack(승인 번호)</code> 필드에 담아서 보내는데, “지금 이 패킷이 니가 전에 보낸 시퀀스 번호의 다음으로 이어지는 패킷이야”라고 말하고 있는 것이다.</p>\n<p>이 3회의 통신이 바로 3 Way Handshake이다. 이 과정을 통해 클라이언트와 서버는 데이터를 주고 받을 준비가 되었다는 것을 서로에게 알려주고 이후 데이터 전송에 필요한 시퀀스 번호를 알 수 있게 된다. 연결을 끊을 때도 마찬가지로 이와 비슷한 과정인 4 Way Handshake를 거치고 나서야 세션을 종료할 수 있으며, 이때는 총 4회의 통신을 통해 연결을 종료한다.</p>\n<p>즉, TCP를 사용하는 이상 본격적인 통신을 시작하기 전에 무조건 저 번거로운 통신 과정을 거쳐야한다는 것이다.</p>\n<p>HTTP/1은 하나의 TCP 연결에 하나의 요청만 처리하고 연결을 끊어버렸기 때문에 매 요청마다 이 번거로운 핸드쉐이크를 거쳐야 했다. 그래서 HTTP/2에서는 핸드쉐이크를 최소화하기 위해서 단일 TCP 연결을 유지하면서 여러 개의 요청을 처리할 수 있도록 변경된 것이다.</p>\n<p>결국 HTTP/1에서 HTTP/2로 넘어갈 때도 핸드쉐이크 과정 자체는 건드리지 않았고 단지 핸드쉐이크가 발생하는 횟수를 최소화함으로써 레이턴시를 줄인 것이다. 이는 TCP를 사용하는 이상 핸드쉐이크가 반드시 필요한 과정이기 때문에 건드리지 못한 것이다.</p>\n<p>그러나 HTTP/3는 UDP를 사용함으로써 이 핸드쉐이크 과정 자체를 날려버리고 다른 방법으로 연결의 신뢰성을 확보함으로써 레이턴시를 줄이는 방법을 택했다.</p>\n<h3 id=\"holbhead-of-line-blocking\" style=\"position:relative;\">HOLB(Head of line Blocking)<a href=\"#holbhead-of-line-blocking\" aria-label=\"holbhead of line blocking permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그 외에도 TCP를 사용하는 기존의 HTTP에는 한 가지 문제가 더 있는데, 바로 HOLB(Head of Line Blocking)라고 하는 문제이다. 사실 HTTP 레벨에서의 HOLB와 TCP 레벨에서의 HOLB는 다른 의미이기는 하나 결국 어떤 요청에 병목이 생겨서 전체적인 레이턴시가 늘어난다는 맥락으로 본다면 동일하다고 할 수 있다.</p>\n<p>TCP를 사용한 통신에서 패킷은 무조건 정확한 순서대로 처리되어야 한다. 수신 측은 송신 측과 주고받은 시퀀스 번호를 참고하여 패킷을 재조립해야하기 때문이다.</p>\n<p>그래서 통신 중간에 패킷이 손실되면 완전한 데이터로 다시 조립할 수 없기 때문에 절대로 그냥 넘어가지 않는다. 무조건 송신 측은 수신 측이 패킷을 제대로 다 받았다는 것을 확인한 후, 만약 수신 측이 제대로 패킷을 받지 못했으면 해당 패킷을 다시 보내야 한다.</p>\n<p>또한 패킷이 처리되는 순서 또한 정해져있으므로 이전에 받은 패킷을 파싱하기 전까지는 다음 패킷을 처리할 수도 없다. 이렇게 패킷이 중간에 유실되거나 수신 측의 패킷 파싱 속도가 느리다면 통신에 병목이 발생하게 되는 현상을 “HOLB”라고 부르는 것이다. 이건 TCP 자체의 문제이므로 HTTP/1 뿐만 아니라 HTTP/2도 가지고 있는 문제이다.</p>\n<p>이런 문제들을 해결하기 위해 HTTP/3는 UDP를 기반으로 만들어진 프로토콜인 QUIC 위에서 작동하는 것을 선택한 것이다. 그럼 이제 QUIC가 정확히 어떤 프로토콜인지, UDP를 사용한다는 것이 TCP에 비해서 어떤 장점이 있다는 것인지를 알아보자.</p>\n<h2 id=\"http3가-udp를-사용하는-이유\" style=\"position:relative;\">HTTP/3가 UDP를 사용하는 이유<a href=\"#http3%EA%B0%80-udp%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"http3가 udp를 사용하는 이유 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>HTTP/3는 QUIC을 기반으로 돌아가는 프로토콜이기 때문에 우리가 HTTP/3를 이해하려면 QUIC에 초점을 맞춰야 한다. QUIC은 TCP가 가지고 있는 이런 문제들을 해결하고 레이턴시의 한계를 뛰어넘고자 구글이 개발한 UDP 기반의 프로토콜이다.</p>\n<p>QUIC은 처음부터 TCP의 핸드쉐이크 과정을 최적화하는 것에 초점을 맞추어 설계되었고, UDP를 사용함으로써 이를 실현해낼 수 있었다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/e8950/quic.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC3klEQVR42o1U/UuTURT2H4gI+iGTgqB+S5McFqlJZDaz0LK0NHSpSYkmlbNiH1okiC00h6SULjQykrWK/MyVpqFoUzIlNXP4rdkHfmzpdren+95t2mxbXTjcc+8553mfe597XjcAC86MEOJy/YfNUTNTq3eDk2E2m9k8O69DQ1sX5nR6u/1VucTqNrs5A1oyGFHV1IYD0Slw38lHcEwq6lo6/spzCWhL0v1axCNVDbb5H8WWM2Lwyt9ia4IEG31CEHvxBj4OaO3yHQISk4nNlbWNOJYsQux1OQIq3oHXoIVPqRretYPg0dmDL8Am/wg8a2hZrnMMSCyAIlkx1vidgG/TGHaUqBEnkiFbdhfh6TnwftCIXXTf/aAA4tvF1jriGlCadx/r/I5jj6oLPGUnAkUFEOYWoVjxGOICBUIVdVgbEIVMmucS0GQ98vuefuyLuYANu8OwXVIEn5p+eKk+4EihElLKPrdQAQkF0/QMWOvM/xZlnj6RgjIlPPdHwSM4Dl6Z97CeHtPrsACvWjv/X2X2RZpoYzsyNYNLN+XwDDoJYbYco5Nfl0/DMXMKaDQa6bszMDMaLTFuNlkUxMTMj+VXwOXY2Blo3aKlzjnD1VdgY8sxMjnoEocMa5vbkZyVTy0P1bQ7uPHpyzCKKl4wv6SyCh3dfcyXlz/F1Mx35iuUNUgQ3YL0jmIFUE+7IiA6FWWqOjx8Xg/fiHMs8rpVg9CzV5gfmZbFYtwIPJ0G7dgkej9rWZ2qvhnqVs0K4NyCHv6nUjAyMY3x6W8IElxmkTf0h8BPyGB3GU47p+Klmu3z44VMHE1vP0ISM8ARon1vd2STJL+U0CA5lHSVbN4bSdq7+8jP2XkSK8wmYedFJCJVSgaHx4mRvuL4azmEMiQLOj1JFOWS4Ph0kiSWLVlFb2R3aLaagXZLS2cPhkYnV0Qxc7Nz4bg4FcyO4RDVcQirjJKxW1O1Xa0HqXEsnvwGZ3Pl7+F/khcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"quic\" title=\"\" src=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/6af66/quic.png\" srcset=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/69538/quic.png 160w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/72799/quic.png 320w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/6af66/quic.png 640w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/d9199/quic.png 960w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/21b4d/quic.png 1280w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/e8950/quic.png 2000w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>UDP는 User Datagram Protocol이라는 이름에서도 알 수 있듯이 데이터그램 방식을 사용하는 프로토콜이기 때문에 애초에 각각의 패킷 간의 순서가 존재하지 않는 독립적인 패킷을 사용한다. 또한 데이터그램 방식은 패킷의 목적지만 정해져있다면 중간 경로는 어딜 타든 신경쓰지 않기 때문에 종단 간의 연결 설정 또한 하지 않는다. 즉, 핸드쉐이크 과정이 필요없다는 것이다.</p>\n<p>결론적으로 UDP는 TCP가 신뢰성을 확보하기 위해 거치던 많은 과정을 거치지 않기 때문에 속도가 더 빠를 수 밖에 없다는 것인데, 그렇다면 UDP를 사용하게되면 기존의 TCP가 가지던 신뢰성과 패킷의 무결함도 함께 사라지는 걸까?</p>\n<p>아니 그렇지 않다. UDP를 사용하더라도 기존의 TCP가 가지고 있던 기능을 전부 구현할 수 있다. UDP의 진짜 장점은 바로 커스터마이징이 용이하다는 것이기 때문이다.</p>\n<h3 id=\"udp는-하얀-도화지-같은-프로토콜이다\" style=\"position:relative;\">UDP는 하얀 도화지 같은 프로토콜이다<a href=\"#udp%EB%8A%94-%ED%95%98%EC%96%80-%EB%8F%84%ED%99%94%EC%A7%80-%EA%B0%99%EC%9D%80-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%B4%EB%8B%A4\" aria-label=\"udp는 하얀 도화지 같은 프로토콜이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자는 학교에서 UDP와 TCP의 가장 큰 차이점으로 “UDP는 TCP보다 신뢰성이 없는 대신 빠르다”라고 배웠었는데, 사실 이 말은 반은 맞고 반은 틀리다.</p>\n<p>왜냐면 애초에 UDP는 데이터 전송을 제외한 그 어떤 기능도 정의되어 있지 않은 프로토콜이기 때문에 프로토콜 자체적으로 신뢰성을 보장하지 않는 것은 맞지만, 다르게 말하자면 데이터 전송 기능을 제외한 아무 기능이 없는 백지 상태의 프로토콜이라고도 할 수 있기 때문이다. TCP가 신뢰성있는 연결과 혼잡 제어 등을 위해 얼마나 많은 기능을 가지고 있는 지는 TCP의 헤더를 보면 대충 각이 나온다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ac69210c44cd473bcb737665d590b124/c7bb6/tcp-header.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 33.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABWUlEQVR42j2P147CMBRE8/9/x4IQkEKq4zi9YofA7NjS7sOR43jKvV6YSMh2xbJs6PoR47Rg5vc0rxjGGbKq8fADVKpx/5q2d5o/rKbtBvTDhO2l4V0fCcK0gpAKWSGRCYkozvBMcqR5ibQoIVWLsmrce5wWjuvNx+0RIMkEYmr9KEHbD/ByoVz7/j6gzU4M20ZOucLsb9cqK4W8ENTVWLeXo6N5GCfnsTpNzL7DS3PJ9hrLurmQhUyzXWfGwDWSNEMYPSFK6mQFVTeuxIZuRGuDF9mIYbib0K7UsLHuejwZkNEsaVRtB9W06DiJOQ4c3y/eZKXZvlv9y05ntyOGeGFcoMwKHFxTM0A3HaoogopjTJxoYvggSow8F65uTxGEKMOIuif6vIC2wSw23MwTNSdIUnx9H0cQ4BOG2Pk9ns+O6XJx9KfT/338OaPjXd/v+LLcej7WrxR+AYjFDnQh+N9MAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tcp header\" title=\"\" src=\"/static/ac69210c44cd473bcb737665d590b124/6af66/tcp-header.png\" srcset=\"/static/ac69210c44cd473bcb737665d590b124/69538/tcp-header.png 160w,\n/static/ac69210c44cd473bcb737665d590b124/72799/tcp-header.png 320w,\n/static/ac69210c44cd473bcb737665d590b124/6af66/tcp-header.png 640w,\n/static/ac69210c44cd473bcb737665d590b124/d9199/tcp-header.png 960w,\n/static/ac69210c44cd473bcb737665d590b124/21b4d/tcp-header.png 1280w,\n/static/ac69210c44cd473bcb737665d590b124/c7bb6/tcp-header.png 1986w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이미 정보들이 뚱뚱하게 들어찬 TCP의 헤더</small>\n</center>\n<p>TCP의 경우 워낙 오래 전에 설계되기도 했고, 이런 저런 기능이 워낙 많이 포함된 프로토콜이다보니 이미 헤더가 거의 풀방이다. TCP에 기본적으로 정의되어 있는 기능 외에 다른 추가 기능을 구현하고 싶다면 가장 하단에 있는 <code class=\"language-text\">옵션(Options)</code> 필드를 사용해야 하는데, 옵션 필드도 무한정 배당 해줄 수는 없으니 최대 크기를 <code class=\"language-text\">320 bits</code>로 정해놓았다.</p>\n<p>그러나 TCP의 단점을 보완하기 위해 나중에 정의된 <code class=\"language-text\">MSS(Maximum Segment Size)</code>, <code class=\"language-text\">WSCALE(Window Scale factor)</code>, <code class=\"language-text\">SACK(Selective ACK)</code> 등 많은 옵션들이 이미 옵션 필드를 차지하고 있기 때문에 실질적으로 사용자가 커스텀 기능을 구현할 수 있는 자리는 거의 남지도 않았다.</p>\n<p>반면 UDP는 데이터 전송 자체에만 초점을 맞추고 설계되었기 때문에 헤더에 진짜 아무 것도 없다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/73dae/udp-header.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 13.750000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAq0lEQVR42j2O226DMBAF+f/P60vTkNoO2GAuBoxNopJEky1S+zDSzh7tpVCVx0+ZdLszxcSSNtbtfhDzjXlN6KpGXesjiykTpoW4Zqm3gzmuTHNkkfnio3Qo7QjW4U1Nf7U0yqBOZ5pvg9cVvfQ7wTUdVqidp7Ytn6eS8qKxbU8l/kvRjYEwjOxy5WeJPOSjLN5q8+9/2T6OPIVXCOz9QPt1Zjbm8KfseQwDb9HI4QyOb6OzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"udp header\" title=\"\" src=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/6af66/udp-header.png\" srcset=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/69538/udp-header.png 160w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/72799/udp-header.png 320w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/6af66/udp-header.png 640w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/d9199/udp-header.png 960w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/21b4d/udp-header.png 1280w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/73dae/udp-header.png 2122w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>TCP와 비교해보면 확실히 휑한 UDP의 헤더</small>\n</center>\n<p>UDP의 헤더에는 출발지와 도착지, 패킷의 길이, 체크섬 밖에 없다. 이때 체크섬은 패킷의 무결성을 확인하기 위해 사용되는데, TCP의 체크섬과는 다르게 UDP의 체크섬은 사용해도 되고 안해도 되는 옵션이다.</p>\n<p>즉, UDP 프로토콜 자체는 TCP보다 신뢰성이 낮기도 하고 흐름 제어도 안되지만, 이후 개발자가 어플리케이션에서 구현을 어떻게 하냐에 따라서 TCP와 비슷한 수준의 기능을 가질 수도 있다는 것이다.</p>\n<p>물론 TCP가 신뢰성을 확보하기위해 이런 저런 기능을 제공해주는 것이 개발자 입장에서는 편하고 좋지만, 한가지 슬픈 점은 이 기능들이 프로토콜 자체에 정의된 필수 과정이라서 개발자가 맘대로 커스터마이징 할 수 없다는 것이다. 결국 여기서 발생하는 레이턴시들을 어떻게 더 줄여볼 시도조차 하기 힘들다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e0bf6f0a79b033925a91b04e4653d7af/e2310/tcp-tls.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 102.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAADtklEQVR42s2TbUxTVxjHsWwuRMbclmWGKZoN3USigsFJ1A9kWZZJsixmbPHLFr84i2lLaUtf0uaEVpcimkDGQjYVBTK23ESBZnTicLp0AtG2lL5cyu1tb+9tb6G0lHaoHVR6dm4DRnRu9sOSneRJ7n2ec375n/P8n5yc/3IJBIICoVC4VSqVviWRSDbX1dW9WV9fvwnlihoaGjbKZLJCPp+/icuLRKL1y7XX0dE1q0AYBnO5UCi+elUuB1sAABuXgeUItEOr1W7V6XSb1Wr1dg4gFovfUCj4LwOgL5LJQCGEMBfFc6uhN0C+sllZqmxVvsb9Awh5T7sJBA9rPK1Wv0MJwDurNty5M9kyMkzYzL/jt1wW0jwViQ5csAY+PKb/9iUPjpcHg8GjDMMcpWm6hts/KLlcCnJq1vqmUx8RzPwEPX3PNhVJVj0Edl2yD7WfGoEXVFdT174zw5nYQqSfjB/JqEkmtyDYCYIgakmSPIYxWF5Pbc+7bvsUFp39M3U/uZRegjAdu5uC1vEZUQbonIgPOYgktDHzKR99D17rsET7iOgn3cbRAjYQEPn9/hORSIQfDoWlOIl/0S3o3nf7FiO1k3+kTWb2wc1RJm3xJhZ/tYU/yABn5lP6u6kl08JS2hhL3L9uHqaw86OB6isDv2xDykQul+szpPJjpPBIcDpY2av6abegWPDCb65Eo2ViDjqJWMpiC9X//YNDmLGA6opzby1oy08kIm+zLNuAVMpCodCXXK1H3ldmbDUWcN9zc3D3/AIs5c4hd/BWIJm2c2E2w+e5nOZHR8U57OorLEsfQCA+RVHHUVOOOwlnyQ+NvQe7JF3rHhPC+0eFwnOWnSMWx3afz/cNUncKx3Hd+Ph4u5/xSzvVxrK2Wiz/ETG5T52WFaCmw1oRjieLY+Hwrng8vndxcbECXf2g1z9Z/XO36dOaErD2mcZv5R1Of2+vnJ6Jtnk9nkuoGc1ut/uM3W4/zYYCHe7bDHhi3P5NoeKMaU9np6Fo0uU6xCmbnZ3dj6xTheobWoT9O8/L+l7MCqhqGiqn6UghgjUiy+i9Xq+OcBOtoXDg8681hspmyeC6rIBy7c0yg8FUhOPOk6jDOnRlDUGQzYEQdbhJZihvAzfyswJqNIN7jEaigKI8VUhdNTL3IYfNcdiOW99vaex976x4OC8roFp+fZfTSpSQpAfzeDw9KNopyt8ZYOm6JtXQsytEyAwQKAa2XbyIbRgbG1u/bHreit+Aor/4rBjLy/k/rDXZnvgLm+tNcqo265oAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tcp tls\" title=\"\" src=\"/static/e0bf6f0a79b033925a91b04e4653d7af/6af66/tcp-tls.png\" srcset=\"/static/e0bf6f0a79b033925a91b04e4653d7af/69538/tcp-tls.png 160w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/72799/tcp-tls.png 320w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/6af66/tcp-tls.png 640w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/d9199/tcp-tls.png 960w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/e2310/tcp-tls.png 968w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>TCP에 TLS까지 사용한다면 통신을 시작하기도 전에 이렇게 많은 과정을 거쳐야 한다</small>\n</center>\n<p>결국 레이턴시를 줄이려면 프로토콜 외적인 것들을 건드려야 하는데, 위에서 이야기 했듯이 일반적인 개발자가 통신 과정에서 건드릴 수 있는 영역은 한계가 있기 때문에 이 또한 어려운 것이 사실이다.<small>(통신 업계의 큰 손 형님들이 인프라를 깔아주시는 걸 기다리자)</small></p>\n<p>아직 TCP와 UDP의 차이가 잘 와닿지 않는다면 “좋은 기능이 다 들어있는 무거운 라이브러리”와 “필요한 기능만 들어있는 가벼운 라이브러리”로 비교해보면 조금 더 이해가 빠를 것 같다.</p>\n<p>예를 들어 JavaScript 진영에서 많이 사용하는 <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"nofollow\">lodash</a>와 같은 라이브러리는 기능은 무궁무진하고 사용자에게 큰 편리함을 주지만, 보통 lodash의 모든 메소드를 다 사용하는 사람은 많지 않을 것이다. 결국 편하긴 하지만 내가 사용하지 않는 기능까지 전부 내 JS 번들에 포함시켜야 한다는 부담이 있다.</p>\n<p>반면 단순한 하나의 기능을 제공하는 라이브러리는 lodash보다 기능은 많지 않아도 내가 원하는 부분만 쏙쏙 골라서 사용할 수 있다는 장점이 있다. 하지만 해당 라이브러리에서 지원하지 않는 기능은 직접 구현해야하는 번거로움이 있을 수도 있다. 이때 lodash와 같은 만능 라이브러리가 TCP, 하나의 기능만 제공하는 작은 라이브러리가 UDP인 것이다.</p>\n<p>이렇듯 구글이 QUIC을 만들 때 UDP를 선택한 이유에는 기존의 TCP를 수정하기가 어려운데다가, 백지 상태나 다름 없는 UDP를 사용함으로써 QUIC의 기능을 확장하기 쉽다고 생각했기 때문이라는 것도 있다.</p>\n<h2 id=\"http3가-udp를-사용함으로써-기존-프로토콜보다-나아진-점\" style=\"position:relative;\">HTTP/3가 UDP를 사용함으로써 기존 프로토콜보다 나아진 점<a href=\"#http3%EA%B0%80-udp%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8-%EA%B8%B0%EC%A1%B4-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EB%B3%B4%EB%8B%A4-%EB%82%98%EC%95%84%EC%A7%84-%EC%A0%90\" aria-label=\"http3가 udp를 사용함으로써 기존 프로토콜보다 나아진 점 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 HTTP/3의 뼈대로 사용되는 QUIC이 왜 TCP가 아닌 UDP를 사용했는지 간략하게 알아보았다. 그렇다면 실제로 UDP를 사용함으로써 얻는 이득에는 무엇이 있을까? 진짜로 HTTP/3는 UDP를 사용함으로써 기존의 HTTP + TCP + TLS를 사용했던 방법보다 더 좋아진 것 일까?</p>\n<p>그에 대한 해답은 Chromium Projects의 <a href=\"https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit\" target=\"_blank\" rel=\"nofollow\">QUIC Overview</a>라는 문서에서 찾을 수 있었다. 한번 구글이 이야기하는 QUIC의 장점에 대해서 살펴보자.</p>\n<h3 id=\"연결-설정-시-레이턴시-감소\" style=\"position:relative;\">연결 설정 시 레이턴시 감소<a href=\"#%EC%97%B0%EA%B2%B0-%EC%84%A4%EC%A0%95-%EC%8B%9C-%EB%A0%88%EC%9D%B4%ED%84%B4%EC%8B%9C-%EA%B0%90%EC%86%8C\" aria-label=\"연결 설정 시 레이턴시 감소 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3 Way Handshake 과정을 거치지 않아도 된다. 클라이언트가 보낸 요청을 서버가 처리한 후 다시 클라이언트로 응답해주는 사이클을 “RTT(Round Trip Time)“라고 하는데, TCP는 연결을 생성하기 위해 기본적으로 1 RTT가 필요하고, 여기에 TLS를 사용한 암호화까지 하려고 한다면 TLS의 자체 핸드쉐이크까지 더해져 총 3 RTT가 필요하다.</p>\n<p>반면 QUIC은 첫 연결 설정에 1 RTT만 소요된다. 클라이언트가 서버에 어떤 신호를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할 수 있다는 것이다. 즉, 연결 설정에 소요되는 시간이 반 정도 밖에 안된다.</p>\n<center>\n  <img src=\"/95f5c7e411d0b7f96d182abe284be551/gcp-cloud-cdn-performance.gif\" width=\"100%\">\n  <br>\n</center>\n<p>어떻게 이게 가능한 걸까? 그 이유는 생각보다 간단하다. 첫번째 핸드쉐이크를 거칠 때, 연결 설정에 필요한 정보와 함께 데이터도 보내버리는 것이다. TCP + TLS는 데이터를 보내기 전에 신뢰성있는 연결과 암호화에 필요한 모든 정보를 교환하고 유효성을 검사한 뒤에 데이터를 교환하지만, QUIC은 묻지도 따지지도 않고 그냥 바로 데이터부터 꽂아버리고 시작한다.</p>\n<p>이 과정에 대해서는 2015년 IEEE Symposium에서 발표된 ”<a href=\"https://youtu.be/vXgbPZ-1-us\" target=\"_blank\" rel=\"nofollow\">How Secure and Quick is QUIC?</a>“이라는 세션에서 자세히 들어볼 수 있다.</p>\n<p><div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.49999999999999%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <div class=\"embedVideo-container\"> <iframe title=\"\" src=\"https://www.youtube.com/embed/vXgbPZ-1-us?rel=0\" class=\"embedVideo-iframe\" style=\"border:0; position: absolute; top: 0; left: 0; width: 100%; height: 100%; \" loading=\"eager\" allowfullscreen=\"\" sandbox=\"allow-same-origin allow-scripts allow-popups\"></iframe> </div> </div></p>\n<center>\n  <small>3분 33초 부터 보도록 하자.<br />한 손 주머니에 꽂고 발표하는 모습에서 스웩이 넘친다</small>\n  <br />\n  <br />\n</center>\n<p>결국 이 영상에서 말하고자 하는 것은 TCP + TLS는 서로 자신의 세션 키를 주고 받아 암호화된 연결을 성립하는 과정을 거치고 나서야 세션 키와 함께 데이터를 교환할 수 있지만, QUIC은 서로의 세션 키를 교환하기도 전에 데이터를 교환할 수 있기 때문에 연결 설정이 더 빠르다는 것이다.</p>\n<p>단, 클라이언트가 서버로 첫 요청을 보낼 때는 서버의 세션 키를 모르는 상태이기 때문에 목적지인 서버의 Connection ID를 사용하여 생성한 특별한 키인 초기화 키(Initial Key)를 사용하여 통신을 암호화 한다. 이 과정에 대한 자세한 설명은 QUIC 작업 그룹의 <a href=\"https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2\" target=\"_blank\" rel=\"nofollow\">Using TLS to Secure QUIC</a> 문서에서 확인 해볼 수 있다.</p>\n<p>그리고 한번 연결에 성공했다면 서버는 그 설정을 캐싱해놓고 있다가, 다음 연결 때는 캐싱해놓은 설정을 사용하여 바로 연결을 성립시키기 때문에 0 RTT만으로 바로 통신을 시작할 수도 있다. 이런 점들 때문에 QUIC은 기존의 TCP+TLS 방식에 비해 레이턴시를 더 줄일 수 있었던 것이다.</p>\n<p>참고로 이 세션이 발표될 당시에는 TLS 1.3이 나오기 전이라 따로 언급이 되지 않았지만, 지금은 TCP Fast Open과 TLS 1.3을 사용하여 QUIC와 비슷한 과정을 통해 연결을 설정함으로써 TCP를 사용하더라도 동일한 이점을 가져갈 수도 있긴하다.</p>\n<p>그러나 TCP SYN 패킷은 한 패킷당 약 <code class=\"language-text\">1460 Byte</code>만 전송할 수 있도록 제한하지만 QUIC은 데이터 전체를 첫 번째 라운드 트립에 포함해서 전송할 수 있기 때문에 주고 받아야할 데이터가 큰 경우에는 여전히 QUIC가 유리하다고 할 수 있다.</p>\n<h3 id=\"패킷-손실-감지에-걸리는-시간-단축\" style=\"position:relative;\">패킷 손실 감지에 걸리는 시간 단축<a href=\"#%ED%8C%A8%ED%82%B7-%EC%86%90%EC%8B%A4-%EA%B0%90%EC%A7%80%EC%97%90-%EA%B1%B8%EB%A6%AC%EB%8A%94-%EC%8B%9C%EA%B0%84-%EB%8B%A8%EC%B6%95\" aria-label=\"패킷 손실 감지에 걸리는 시간 단축 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>QUIC도 TCP와 마찬가지로 전송하는 패킷에 대한 흐름 제어를 해야한다. 왜냐면 QUIC든 TCP든 결국 본질적으로는 ARQ 방식을 사용하는 프로토콜이기 때문이다. 통신과정에서 발생한 에러를 어떻게 처리할 것인지를 이야기하는 것인데, ARQ 방식은 에러가 발생하면 재전송을 통해 에러를 복구하는 방식을 말하는 것이다.</p>\n<p>TCP는 여러 ARQ 방식 중에서 “Stop and Wait ARQ” 방식을 사용하고 있다. 이 방식은 송신 측이 패킷을 보낸 후 타이머를 사용하여 시간을 재고, 일정 시간이 경과해도 수신 측이 적절한 답변을 주지 않는다면 패킷이 손실된 것으로 판단하고 해당 패킷을 다시 보내는 방식이다.</p>\n<p>우선 2017년 구글에서 발표한 <a href=\"https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1\" target=\"_blank\" rel=\"nofollow\">QUIC Loss Detection and Congestion Control</a>에 따르면, QUIC은 기본적으로 TCP와 유사한 방법으로 패킷 손실을 탐지하나, 몇 가지 개선 사항을 추가한 것으로 보인다.</p>\n<p>TCP에서 패킷 손실 감지에 대한 대표적인 문제는 송신 측이 패킷을 수신측으로 보내고 난 후 얼마나 기다려줄 것인가, 즉 타임 아웃을 언제 낼 것인가를 동적으로 계산해야한다는 것이다. 이때 이 시간을 RTO(Retransmission Time Out)라고 하는데, 이때 필요한 데이터가 바로 RTT(Round Trip Time)들의 샘플들이다.</p>\n<p>한번 패킷을 보낸 후 잘 받았다는 응답을 받을 때 걸렸던 시간들을 측정해서 동적으로 타임 아웃을 정하는 것이다. 즉, RTT 샘플을 측정하기 위해서는 반드시 송신 측으로 부터 ACK를 받아야하는데, 정상적인 상황에서는 딱히 문제가 없으나 타임 아웃이 발생해서 패킷 손실이 발생하게 되면 RTT 계산이 애매해진다.</p>\n<blockquote>\n<p>패킷 전송 -> 타임 아웃 -> 패킷 재전송 -> ACK 받음!<br />\n<small>(근데 이거 첫 번째로 보낸 패킷의 ACK야? 두 번째로 보낸 패킷의 ACK야?)</small></p>\n</blockquote>\n<p>이때 이 ACK가 어느 패킷에 대한 응답인지 알기 위해서는 타임스탬프를 패킷에 찍어주는 등 별도의 방법을 또 사용해야하고, 또 이를 위한 패킷 검사도 따로 해줘야 한다. 이를 재전송 모호성(Retransmission Ambiguity)이라고 한다.</p>\n<p>이 문제를 해결하기 위해 QUIC는 헤더에 별도의 패킷 번호 공간을 부여했다. 이 패킷 번호는 패킷의 전송 순서 자체만을 나타내며, 재전송시 동일한 번호가 전송되는 시퀀스 번호와는 다르게 매 전송마다 모노토닉하게 패킷 번호가 증가하기 때문에, 패킷의 전송 순서를 명확하게 파악할 수 있다.</p>\n<p>TCP의 경우 타임스탬프를 사용할 수 있는 상황이라면 타임스탬프를 통해 패킷의 전송 순서를 파악할 수 있지만, 만약 사용할 수 없는 경우 시퀀스 번호에 기반하여 암묵적으로 전송 순서를 추론할 수 밖에 없지만, QUIC는 이런 불필요한 과정을 패킷마다 고유한 패킷 번호를 통해 타파함으로써 패킷 손실 감지에 걸리는 시간을 단축할 수 있었다.</p>\n<p>이 외에도 QUIC는 대략 5가지 정도의 기법을 사용하여 이 패킷 손실 감지에 걸리는 시간을 단축시켰는데, 자세한 내용은 <a href=\"https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1\" target=\"_blank\" rel=\"nofollow\">QUIC Loss Detection and Congestion Control</a>의 “3.1 Relevant Differences Between QUIC and TCP” 챕터를 한번 읽어보는 것을 추천한다.</p>\n<h3 id=\"멀티플렉싱을-지원\" style=\"position:relative;\">멀티플렉싱을 지원<a href=\"#%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1%EC%9D%84-%EC%A7%80%EC%9B%90\" aria-label=\"멀티플렉싱을 지원 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>멀티플렉싱(Multiplexing)은 위에서 TCP의 단점으로 언급했던 HOLB를 방지하기 때문에 매우 중요하다. 여러 개의 스트림을 사용하면, 그 중 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 굴릴 수 있기 때문이다.</p>\n<p>참고로 멀티플렉싱은 여러 개의 TCP 연결을 만든다는 의미가 아니라, 단일 연결 안에서 몇 가지 얌생이를 사용하여 여러 개의 데이터를 섞이지 않게 보내는 기법이다. 이때 각각의 데이터의 흐름을 스트림(Stream)이라고 하는 것이다.</p>\n<p>HTTP/1의 경우는 하나의 TCP 연결에 하나의 스트림만 사용하기 때문에 HOLB 문제에서 벗어날 수 없었다. 또한 한번의 전송이 끝나게 되면 연결이 끊어지기 때문에 다시 연결을 만들기 위해서는 번거로운 핸드쉐이크 과정을 또 겪어야 했다.</p>\n<p>비록 <code class=\"language-text\">keep-alive</code> 옵션을 통해 어느 정도의 시간 동안 연결을 유지할 수는 있지만 결국 일정 시간 안에 액세스가 없다면 연결이 끊어지게 되는 것은 똑같다.</p>\n<p>그리고 HTTP/2는 하나의 TCP 연결 안에서 여러 개의 스트림을 처리하는 멀티플렉싱 기법을 도입하여 성능을 끌어올린 케이스이다. 이 경우 한번의 TCP 연결로 여러 개의 데이터를 전송할 수 있기 때문에 핸드쉐이크 횟수도 줄어들게 되어 효율적인 데이터 전송을 할 수 있게 된다.</p>\n<center>\n  <img src=\"/40cb0bc1d62eba25c2e351d213d1700d/multiplexing.svg\">\n  <br>\n  <small>HTTP/3도 HTTP/2와 같은 멀티플렉싱을 지원한다.</small>\n  <br>\n  <br>\n</center>\n<p>QUIC 또한 HTTP/2와 동일하게 멀티플렉싱을 지원하기 때문에, 이런 이점을 그대로 가져가고 있다. 혹여나 하나의 스트림에서 문제가 발생한다고 해도 다른 스트림은 지킬 수 있게 되어 이런 문제에서 자유로울 수 있다.</p>\n<h3 id=\"클라이언트의-ip가-바뀌어도-연결이-유지됨\" style=\"position:relative;\">클라이언트의 IP가 바뀌어도 연결이 유지됨<a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%9D%98-ip%EA%B0%80-%EB%B0%94%EB%80%8C%EC%96%B4%EB%8F%84-%EC%97%B0%EA%B2%B0%EC%9D%B4-%EC%9C%A0%EC%A7%80%EB%90%A8\" aria-label=\"클라이언트의 ip가 바뀌어도 연결이 유지됨 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>TCP의 경우 소스의 IP 주소와 포트, 연결 대상의 IP 주소와 포트로 연결을 식별하기 때문에 클라이언트의 IP가 바뀌는 상황이 발생하면 연결이 끊어져 버린다. 연결이 끊어졌으니 다시 연결을 생성하기 위해 결국 눈물나는 3 Way Handshake 과정을 다시 거쳐야한다는 것이고, 이 과정에서 다시 레이턴시가 발생한다.</p>\n<p>게다가 요즘에는 모바일로 인터넷을 사용하는 경우가 많기 때문에 Wi-fi에서 셀룰러로 전환되거나 그 반대의 경우, 혹은 다른 Wi-fi로 연결되는 경우와 같이 클라이언트의 IP가 변경되는 일이 굉장히 잦아서 이 문제가 더 눈에 띈다.</p>\n<p>반면 QUIC은 Connection ID를 사용하여 서버와 연결을 생성한다. Connection ID는 랜덤한 값일 뿐, 클라이언트의 IP와는 전혀 무관한 데이터이기 때문에 클라이언트의 IP가 변경되더라도 기존의 연결을 계속 유지할 수 있다. 이는 새로 연결을 생성할 때 거쳐야하는 핸드쉐이크 과정을 생략할 수 있다는 의미이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 HTTP/3와 QUIC을 제대로 설명하기 위해서는 네트워크에 대한 기본 개념들이 필수적으로 동반되야하기 때문에 이 짧은 포스팅 만으로 세부적인 설명을 하기 힘든 부분이 있었다. 최대한 자세하게 작성해보려고 했지만 생각보다 글이 너무 길어지게 되어서 분량 조절을 조금 하려고 한다.</p>\n<p>이번에 HTTP/3를 공부해보고 여러가지 자료를 찾아보면서 느낀 점은 “뭐가 이렇게 많이 바뀌었어?” 였던 것 같다. 일단 TCP부터 갖다 버렸으니 뭐가 많이 바뀔만 하긴 했지만, HTTP/2를 사용해본지도 몇 달 밖에 되지 않은 필자의 입장에서는 조금 당황스럽기는 했다. <small>(HTTP를 만든다면서 TCP를 갖다 버린 건 아직도 신기하다)</small></p>\n<p>사실 개발자들이 HTTP/2를 사용하든 HTTP/3를 사용하든 한국에서 인터넷을 사용하고 있는 사용자는 별로 큰 차이를 못 느낄 것이다. 한국은 워낙 땅덩이도 작고 통신 인프라도 좋다보니 핸드쉐이크 레이턴시고 나발이고 그냥 인프라로 대충 커버칠 수 있지만, 그래도 상대적으로 통신 인프라가 빈약한 나라의 경우에는 꽤 큰 차이가 느껴질 수도 있을 것 같다.</p>\n<p>필자가 이 포스팅에서는 HTTP/3와 UDP의 장점만을 이야기했지만, 사실 많은 사람들이 TCP를 버리고 UDP로 갈아타는 것에 대해서 걱정하고 있다. 당연히 완벽한 기술이란 없으니 문제도 있을 것이다.</p>\n<p>그러나 기존의 HTTP와 TCP가 가지고 있는 한계를 돌파하기 위한 시도로는 굉장히 좋은 것 같다. 마치 엔비디아의 RTX 시리즈 같은 느낌이랄까.</p>\n<p>이상으로 HTTP/3는 왜 UDP를 선택한 것일까? 포스팅을 마친다.</p>\n<h2 id=\"참고-링크\" style=\"position:relative;\">참고 링크<a href=\"#%EC%B0%B8%EA%B3%A0-%EB%A7%81%ED%81%AC\" aria-label=\"참고 링크 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46403.pdf\" target=\"_blank\" rel=\"nofollow\">The QUIC Transport Protocol: Design and Internet-Scale Deployment</a></li>\n<li><a href=\"https://medium.com/codavel-blog/quic-vs-tcp-tls-and-why-quic-is-not-the-next-big-thing-d4ef59143efd\" target=\"_blank\" rel=\"nofollow\">QUIC vs TCP+TLS - and why QUIC is not the next big thing</a></li>\n<li><a href=\"https://blog.cloudflare.com/http3-the-past-present-and-future/\" target=\"_blank\" rel=\"nofollow\">HTTP/3: the past, the present, and the future</a></li>\n<li><a href=\"https://www.saturnsoft.net/network/2019/03/21/quic-http3-1/\" target=\"_blank\" rel=\"nofollow\">QUIC과 HTTP/3 - 1.UDP기반 전송 프로토콜의 대두</a></li>\n<li><a href=\"https://www.chromium.org/quic\" target=\"_blank\" rel=\"nofollow\">QUIC, a multiplexed stream transport over UDP</a></li>\n<li><a href=\"https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2\" target=\"_blank\" rel=\"nofollow\">Using TLS to Secure QUIC</a></li>\n<li><a href=\"https://blog.cloudflare.com/the-road-to-quic/\" target=\"_blank\" rel=\"nofollow\">The Road to QUIC</a></li>\n</ul>","fields":{"slug":"20191008-what-is-http3","path":"/2019/10/08/what-is-http3/","lang":"ko"},"frontmatter":{"title":"HTTP/3는 왜 UDP를 선택한 것일까?","subTitle":"웹의 표준이 바뀐다. HTTP/3, 빠른 속도를 위해 UDP를 선택하다","date":"Oct 08, 2019","categories":["프로그래밍","네트워크"],"tags":["HTTP3","TCP","UDP","네트워크"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/3a812/thumbnail.jpg","srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/3a812/thumbnail.jpg 320w,\n/static/70cbe98ca5682a8f70aa5afe9a5533ed/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/fc5c5/thumbnail.webp 320w,\n/static/70cbe98ca5682a8f70aa5afe9a5533ed/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/2d839/thumbnail.jpg","srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"aa9608ff-e701-507d-a416-1bfb2995dfc7","tableOfContents":"<ul>\n<li>\n<p><a href=\"#ip-internet-protocol\">IP, Internet Protocol</a></p>\n<ul>\n<li><a href=\"#ipv4%EC%9D%98-%EA%B5%AC%EC%A1%B0\">IPv4의 구조</a></li>\n<li><a href=\"#ipv4%EC%9D%98-%ED%81%B4%EB%9E%98%EC%8A%A4\">IPv4의 클래스</a></li>\n<li><a href=\"#%ED%8A%B9%EC%88%98%ED%95%9C-%EB%AA%A9%EC%A0%81%EC%9D%98-ipv4-%EC%A3%BC%EC%86%8C\">특수한 목적의 IPv4 주소</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9A%B0%EB%A6%AC-%EC%A7%91%EC%97%90%EC%84%9C-%EA%B5%AC%EA%B8%80%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B2%BD%EB%A1%9C%EB%A5%BC-%EB%B3%B4%EC%9E%90\">우리 집에서 구글까지의 경로를 보자</a></p>\n<ul>\n<li><a href=\"#traceroute-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">traceroute 사용하기</a></li>\n<li><a href=\"#%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%9E%88-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\">좀 더 자세히 알아보자!</a></li>\n</ul>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 우리 집에서 구글까지 어떤 과정을 통해 통신을 하는지에 대해서 간략하게 얘기해보려고 한다. 필자가 대학에서 배운 것 중 재밌다고 생각했던 것이 몇 개 있는데, 그 중 대표적인 것이 바로 인터넷에 연결되어 있는 모든 컴퓨터는 실제로 케이블을 통해 연결되어있다는 사실이었다. 혹자는 당연하다고 생각할 수 있는 이 사실이 그땐 굉장히 신기했던 것 같다. 매일매일 인터넷을 사용하고 있지만 너무 생활 속에 자연스레 녹아있는 요소이다 보니 그 원리에 대해서는 그다지 신경쓰지 않았기 때문이다.","html":"<p>이번 포스팅에서는 우리 집에서 구글까지 어떤 과정을 통해 통신을 하는지에 대해서 간략하게 얘기해보려고 한다. 필자가 대학에서 배운 것 중 재밌다고 생각했던 것이 몇 개 있는데, 그 중 대표적인 것이 바로 인터넷에 연결되어 있는 모든 컴퓨터는 실제로 케이블을 통해 연결되어있다는 사실이었다.</p>\n<p>혹자는 당연하다고 생각할 수 있는 이 사실이 그땐 굉장히 신기했던 것 같다. 매일매일 인터넷을 사용하고 있지만 너무 생활 속에 자연스레 녹아있는 요소이다 보니 그 원리에 대해서는 그다지 신경쓰지 않았기 때문이다.</p>\n<!-- more -->\n<p>그러다가 학교에서 네트워크에 대해 점점 자세히 배우면서 “내가 당연하게 사용하고 있는 이 혜택들이 사실은 굉장히 체계적이고 복잡한 시스템이구나”라는 사실을 알게 되었다.</p>\n<p>그래서 이번 포스팅에서는 필자의 집에서 구글 서버에 접속하는 과정을 통해 그 시스템에 대해서 간단하게 풀어보려고 한다. 물론 IP 주소를 기반으로 대략적인 추정을 하는 것이기 때문에 정확한 정보는 아니겠지만 대략적으로 이런 과정을 통해 해외에 있는 서버에 접속할 수 있다는 사실을 중심으로 풀어갈 것이다.</p>\n<h2 id=\"ip-internet-protocol\" style=\"position:relative;\">IP, Internet Protocol<a href=\"#ip-internet-protocol\" aria-label=\"ip internet protocol permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>먼저 우리 집에서 구글까지의 경로를 알기 위해서 인터넷하면 빠질 수 없는 IP에 대해서 간단하게 알아보자. IP 주소라는 단어는 컴퓨터 관련 전공을 하신 분이 아니더라도 굉장히 익숙한 단어이다.</p>\n<p>일반적인 환경에서 우리가 인터넷에 접속할 때 이 IP 주소가 우리 집 주소의 역할을 한다고 생각하면 된다. 마찬가지로 우리 집에서 구글까지 가는 길목에 있는 지점들도 모두 IP 주소를 가지고 있고, 우리는 그 IP 주소를 기반으로 이 지점이 어디인지 대략적으로 추측해볼 수 있다.</p>\n<p>IP에 관해서 굉장히 기본적인 내용을 설명할 예정이므로 이미 다 아시는 분은 그냥 건너뛰셔도 무방하다.</p>\n<h3 id=\"ipv4의-구조\" style=\"position:relative;\">IPv4의 구조<a href=\"#ipv4%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\"ipv4의 구조 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>일반적으로 우리가 접할 수 있는 <code class=\"language-text\">192.168.0.1</code>과 같은 형태는 IPv4이다. IPv4는 8비트로 구성된 4개의 필드로 구성되고 이 하나하나의 필드를 옥탯(Octet)이라고 부른다. <small>(참고로 Oct으로 시작하는 용어는 8을 뜻하는 게 많다)</small>.</p>\n<p>예를 들어 <code class=\"language-text\">192.168.0.1</code>은 이진법으로 전환하면 다음과 같이 나타낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">10진법: 192.168.0.1\n2진법: 11000000.10101000.00000000.00000001</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>한 옥탯에 8비트밖에 가지지 못하기 때문에 옥탯은 <code class=\"language-text\">00000000-11111111</code>, 즉 십진법으로는 <code class=\"language-text\">0-255</code>의 수를 가지게 되는 것이다. 그렇기 때문에 IPv4로 생성할 수 있는 주소의 개수는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>=</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>294</mn><mo separator=\"true\">,</mo><mn>967</mn><mo separator=\"true\">,</mo><mn>296</mn></mrow><annotation encoding=\"application/x-tex\">2^{32} = 4,294,967,296</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">32</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">294</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">967</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">296</span></span></span></span></span>로 약 43억개이다. 43억개라니… 꽤 큰 숫자 같아 보인다. 처음에 이 주소 체계를 만들 때만 해도 이런 생각을 했던 것 같다.</p>\n<blockquote>\n<p><em>에이 43억개나 있는데 어느 정도는 버티겠지?</em></p>\n</blockquote>\n<center>\n<br />\n.<br />\n.<br />\n.<br />\n<br />\n</center>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/de8631a2bb9ad577fae2ba57e8801a22/41099/unexpected-result.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAABAD/xAAUAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAExEHKPUj//xAAaEAACAgMAAAAAAAAAAAAAAAAAAQIDEiEz/9oACAEBAAEFAqkXdB6lbJ5n/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8BZ//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ASf/xAAWEAEBAQAAAAAAAAAAAAAAAAAQESH/2gAIAQEABj8Cjj//xAAaEAEAAgMBAAAAAAAAAAAAAAABABEQIaFh/9oACAEBAAE/IRF6j2fDCWtUsN8x/9oADAMBAAIAAwAAABBcD//EABYRAAMAAAAAAAAAAAAAAAAAAAEQIf/aAAgBAwEBPxA4v//EABURAQEAAAAAAAAAAAAAAAAAABAx/9oACAECAQE/ELP/xAAdEAEBAAEEAwAAAAAAAAAAAAABEQAQITFBUXGh/9oACAEBAAE/EKbSNjkylivZv19zluOSJXj3iajcCx40/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"unexpected result\" title=\"\" src=\"/static/de8631a2bb9ad577fae2ba57e8801a22/41099/unexpected-result.jpg\" srcset=\"/static/de8631a2bb9ad577fae2ba57e8801a22/0913d/unexpected-result.jpg 160w,\n/static/de8631a2bb9ad577fae2ba57e8801a22/cb69c/unexpected-result.jpg 320w,\n/static/de8631a2bb9ad577fae2ba57e8801a22/41099/unexpected-result.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>생각보다 전세계의 인터넷 사용자가 빠르게 늘면서 결국 2011년 2월 4일부로 모든 주소가 소진되어 현재는 IPv4의 할당이 중지되었다. 다행히 그 동안 손놓고 있지는 않았고, 전세계의 똑똑한 분들이 이미 대책을 다 세워두었으니 너무 걱정하진 말자.</p>\n<h3 id=\"ipv4의-클래스\" style=\"position:relative;\">IPv4의 클래스<a href=\"#ipv4%EC%9D%98-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"ipv4의 클래스 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이렇게 IP 주소는 무제한으로 막 퍼줄 수 있는 자원이 아니라 유한한 자원이다 보니, 특정 대역마다 사용처를 나누어서 관리하게 된다. 이때 나누어진 대역을 클래스라고 부르며 A-E의 총 5개의 클래스로 나누어서 관리한다.</p>\n<p>각 클래스는 이진법으로 표현한 IPv4인 <code class=\"language-text\">00000000.00000000.00000000.00000000</code> 중 첫번째 필드에 있는 8비트에 제한을 만들어서 표기하기 때문에 첫번째 필드의 숫자만 보면 해당 IPv4 주소가 어느 클래스에 속해있는 지 알 수 있다.</p>\n<p>이 제한은 바로 첫번째 필드의 최상위 비트를 강제하는 방식이다. 예를 들어 A 클래스는 무조건 비트가 <code class=\"language-text\">0</code>으로 시작해야하기 때문에 <code class=\"language-text\">00000000(0)</code>에서 <code class=\"language-text\">01111111(127)</code>사이의 첫번째 필드를 사용할 수 있고 C 클래스는 무조건 비트가 <code class=\"language-text\">110</code>로 시작해야하기 때문에 <code class=\"language-text\">11000000(192)</code>부터 <code class=\"language-text\">11011111(223)</code>까지의 첫번째 필드를 사용할 수 있는 식이다.</p>\n<table>\n<thead>\n<tr>\n<th>클래스</th>\n<th>첫번째필드</th>\n<th>주소범위</th>\n<th>용도</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>0xxxxxxx</td>\n<td>0.0.0.0 ~ 127.255.255.255</td>\n<td>대규모 네트워크</td>\n</tr>\n<tr>\n<td>B</td>\n<td>10xxxxxx</td>\n<td>128.0.0.0 ~ 191.255.255.255</td>\n<td>중규모 네트워크</td>\n</tr>\n<tr>\n<td>C</td>\n<td>110xxxxx</td>\n<td>192.0.0.0 ~ 223.255.255.255</td>\n<td>소규모 네트워크</td>\n</tr>\n<tr>\n<td>D</td>\n<td>1110xxxx</td>\n<td>224.0.0.0 ~ 239.255.255.255</td>\n<td>멀티캐스트</td>\n</tr>\n<tr>\n<td>E</td>\n<td>1111xxxx</td>\n<td>240.0.0.0 ~ 255.255.255.255</td>\n<td>연구/개발 또는 미래 대비로 예약</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"특수한-목적의-ipv4-주소\" style=\"position:relative;\">특수한 목적의 IPv4 주소<a href=\"#%ED%8A%B9%EC%88%98%ED%95%9C-%EB%AA%A9%EC%A0%81%EC%9D%98-ipv4-%EC%A3%BC%EC%86%8C\" aria-label=\"특수한 목적의 ipv4 주소 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이렇게 클래스를 나누고 그 클래스 내부에서도 특수한 용도를 위해 미리 예약해놓은 IPv4 주소들이 있다. 이 예약 주소들은 <a href=\"https://tools.ietf.org/html/rfc5735\" target=\"_blank\" rel=\"nofollow\">RFC 5735</a>에 의해 정의되어 있으며 목적에 벗어난 용도로 할당 받는 것이 불가능하다. 이 포스팅에서는 간략하게 대표적인 몇가지만 설명하고 넘어가겠다.</p>\n<table>\n<thead>\n<tr>\n<th>클래스</th>\n<th>주소</th>\n<th>용도</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>0.0.0.0 ~ 0.255.255.255</td>\n<td>할당되지 않은 메타 주소</td>\n</tr>\n<tr>\n<td>A</td>\n<td>10.0.0.0 ~ 10.255.255.255</td>\n<td>대규모 사설 네트워크</td>\n</tr>\n<tr>\n<td>A</td>\n<td>100.64.0.0 ~ 100.127.255.255</td>\n<td>Carrier-grade NAT용 주소</td>\n</tr>\n<tr>\n<td>A</td>\n<td>127.0.0.0 ~ 127.255.255.255</td>\n<td>자기 자신. 일명 루프백(Lookback)</td>\n</tr>\n<tr>\n<td>C</td>\n<td>192.168.0.0 ~ 192.168.255.255</td>\n<td>소규모 사설 네트워크. 공유기를 쓰면 많이 보인다.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"우리-집에서-구글까지의-경로를-보자\" style=\"position:relative;\">우리 집에서 구글까지의 경로를 보자<a href=\"#%EC%9A%B0%EB%A6%AC-%EC%A7%91%EC%97%90%EC%84%9C-%EA%B5%AC%EA%B8%80%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B2%BD%EB%A1%9C%EB%A5%BC-%EB%B3%B4%EC%9E%90\" aria-label=\"우리 집에서 구글까지의 경로를 보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 드디어 이 포스팅의 메인 내용을 시작할 수 있게 되었다.</p>\n<p>집에서 맥북을 열고 웹 브라우저에 <code class=\"language-text\">google.com</code>을 입력하면 웹 브라우저는 전 세계 어딘가에 있는 구글 서버에 페이지를 보내달라는 요청을 보낼 것이다. 하지만 필자의 맥북과 구글 서버까지는 직접 연결되어 있지 않다.</p>\n<p>그렇기 때문에 필자가 보낸 요청은 구글 서버까지 가기 위해 여기저기를 들러가면서 험난한 여정을 겪는다. 그렇다면 이제 필자가 집에서 보낸 요청이 구글 서버까지 도달하기 전에 어디를 들리는 지 한번 알아보자.</p>\n<h3 id=\"traceroute-사용하기\" style=\"position:relative;\">traceroute 사용하기<a href=\"#traceroute-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"traceroute 사용하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자는 Unix 기반의 MacOS를 사용하고 있기 때문에 MacOS 기준으로 설명하겠다. <code class=\"language-text\">traceroute</code> 유틸리티를 사용하면 내가 보낸 패킷이 어떤 경로를 통해 구글 서버까지 도달하는 지 알아볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">traceroute</span> <span class=\"token parameter variable\">-q</span> <span class=\"token number\">1</span> google.com\n<span class=\"token function\">traceroute</span> to google.com <span class=\"token punctuation\">(</span><span class=\"token number\">172.217</span>.25.196<span class=\"token punctuation\">)</span>, <span class=\"token number\">64</span> hops max, <span class=\"token number\">52</span> byte packets\n <span class=\"token number\">1</span>  <span class=\"token number\">192.168</span>.25.1 <span class=\"token punctuation\">(</span><span class=\"token number\">192.168</span>.25.1<span class=\"token punctuation\">)</span>  <span class=\"token number\">3.077</span> ms\n <span class=\"token number\">2</span>  <span class=\"token number\">211.0</span>.0.0 <span class=\"token punctuation\">(</span><span class=\"token number\">211.0</span>.0.0<span class=\"token punctuation\">)</span>  <span class=\"token number\">5.928</span> ms\n <span class=\"token number\">3</span>  <span class=\"token number\">100.71</span>.51.17 <span class=\"token punctuation\">(</span><span class=\"token number\">100.71</span>.51.17<span class=\"token punctuation\">)</span>  <span class=\"token number\">4.693</span> ms\n <span class=\"token number\">4</span>  <span class=\"token number\">10.44</span>.255.240 <span class=\"token punctuation\">(</span><span class=\"token number\">10.44</span>.255.240<span class=\"token punctuation\">)</span>  <span class=\"token number\">4.328</span> ms\n <span class=\"token number\">5</span>  <span class=\"token number\">10.222</span>.18.10 <span class=\"token punctuation\">(</span><span class=\"token number\">10.222</span>.18.10<span class=\"token punctuation\">)</span>  <span class=\"token number\">7.319</span> ms\n <span class=\"token number\">6</span>  <span class=\"token number\">10.222</span>.16.201 <span class=\"token punctuation\">(</span><span class=\"token number\">10.222</span>.16.201<span class=\"token punctuation\">)</span>  <span class=\"token number\">4.883</span> ms\n <span class=\"token number\">7</span>  <span class=\"token number\">10.222</span>.16.41 <span class=\"token punctuation\">(</span><span class=\"token number\">10.222</span>.16.41<span class=\"token punctuation\">)</span>  <span class=\"token number\">3.853</span> ms\n <span class=\"token number\">8</span>  <span class=\"token number\">72.14</span>.204.124 <span class=\"token punctuation\">(</span><span class=\"token number\">72.14</span>.204.124<span class=\"token punctuation\">)</span>  <span class=\"token number\">34.784</span> ms\n <span class=\"token number\">9</span>  <span class=\"token number\">108.170</span>.242.193 <span class=\"token punctuation\">(</span><span class=\"token number\">108.170</span>.242.193<span class=\"token punctuation\">)</span>  <span class=\"token number\">37.751</span> ms\n<span class=\"token number\">10</span>  <span class=\"token number\">108.170</span>.233.79 <span class=\"token punctuation\">(</span><span class=\"token number\">108.170</span>.233.79<span class=\"token punctuation\">)</span>  <span class=\"token number\">36.643</span> ms\n<span class=\"token number\">11</span>  nrt13s50-in-f4.1e100.net <span class=\"token punctuation\">(</span><span class=\"token number\">172.217</span>.25.68<span class=\"token punctuation\">)</span>  <span class=\"token number\">35.416</span> ms</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두번째 홉은 필자의 디테일한 위치가 노출될 수 있는 공인 IP를 출력하므로 보안상 마스킹했다. 사실 필자가 사용하고 있는 ISP(Internet Service Provider)인 SK 브로드밴드는 관리 지역 내 IP 주소 임대기간이 1시간이기도 하고 필자는 인구밀도가 높은 곳에 거주하고 있으므로 저 IP 주소가 노출된다고 해도 위치를 알기는 쉽지 않지만 그래도 불안하기 때문에 가린다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 420px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6d8c691361160ceec51f9bdd1c9b19f0/65f94/meme.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 83.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAMEAQIF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHj2K8ubVZWbTBGD//EABwQAAEFAAMAAAAAAAAAAAAAAAIAAQMQERIiMf/aAAgBAQABBQIe0k4MNZiMuSdqPxf/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAcEAABAwUAAAAAAAAAAAAAAAABABARAiBhcYH/2gAIAQEABj8CGShE9abKNN//xAAdEAEAAgICAwAAAAAAAAAAAAABABEhMRBhQVHw/9oACAEBAAE/IamoDQQdcQdb35xC3XrEofcJ8vbDU//aAAwDAQACAAMAAAAQHP8Agv/EABYRAQEBAAAAAAAAAAAAAAAAAAERIP/aAAgBAwEBPxAkcf/EABcRAAMBAAAAAAAAAAAAAAAAAAEgITH/2gAIAQIBAT8Q0xP/xAAeEAEAAQMFAQAAAAAAAAAAAAABEQAhQRAxUXGh8P/aAAgBAQABPxALIqgsdFTohYWA+aOgUIJbZpMtYnYh+zScBuJWHRXk6F//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"meme\" title=\"\" src=\"/static/6d8c691361160ceec51f9bdd1c9b19f0/65f94/meme.jpg\" srcset=\"/static/6d8c691361160ceec51f9bdd1c9b19f0/0913d/meme.jpg 160w,\n/static/6d8c691361160ceec51f9bdd1c9b19f0/cb69c/meme.jpg 320w,\n/static/6d8c691361160ceec51f9bdd1c9b19f0/65f94/meme.jpg 420w\" sizes=\"(max-width: 420px) 100vw, 420px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>누가 우리 집 알아내면 어떡해...</small>\n</center>\n<p><code class=\"language-text\">traceroute</code>의 결과로 출력되는 하나의 row를 홉(Hop)이라고 부르는데, 필자의 집에서부터 구글의 서버까지 필자의 패킷이 거쳐간 경로를 의미하는 것이다. 홉의 IP 주소 오른쪽에 출력된 시간은 홉이 응답한 시간을 의미한다. 재밌는 것은 8번 홉부터 갑자기 응답 시간이 한자리 수에서 두자리 수로 확 뛴다는 것인데, 여기서부터는 패킷이 국내를 벗어나 해외로 빠져나간 것이다.</p>\n<p>그렇다면 이 IP 주소들은 어디를 의미하는 걸까?</p>\n<h3 id=\"좀-더-자세히-알아보자\" style=\"position:relative;\">좀 더 자세히 알아보자!<a href=\"#%EC%A2%80-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%9E%88-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\" aria-label=\"좀 더 자세히 알아보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이제 이 IP 주소들이 각각 어디를 의미하는지, 어떤 회사가 소유하고 있는 어떤 디바이스인지 좀 더 자세히 알아보고 싶다. 간단하게 알아보는 방법은 <code class=\"language-text\">whois</code> 유틸리티를 사용하는 방법이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ whois <span class=\"token number\">172.217</span>.25.68\nNetRange:       <span class=\"token number\">172.217</span>.0.0 - <span class=\"token number\">172.217</span>.255.255\nCIDR:           <span class=\"token number\">172.217</span>.0.0/16\nNetName:        GOOGLE\nNetHandle:      NET-172-217-0-0-1\nParent:         NET172 <span class=\"token punctuation\">(</span>NET-172-0-0-0-0<span class=\"token punctuation\">)</span>\nNetType:        Direct Allocation</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>MacOS의 <code class=\"language-text\">whois</code> 유틸리티는 5개의 <code class=\"language-text\">whois</code> 서비스에 요청을 보내 받아온 결과를 출력해주는 방식이다. 참고로 대한민국의 <code class=\"language-text\">whois</code> 서비스는 KISA(한국인터넷진흥원)의 <a href=\"https://xn--c79as89aj0e29b77z.xn--3e0b707e/kor/main.jsp\" target=\"_blank\" rel=\"nofollow\">후이즈검색</a>에서 제공하고 있다.</p>\n<table>\n<thead>\n<tr>\n<th>whois 도메인</th>\n<th>담당 구역</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>whois.arin.net</td>\n<td>아메리카</td>\n</tr>\n<tr>\n<td>whois.nic.mil</td>\n<td>미국(현재 작동안함)</td>\n</tr>\n<tr>\n<td>whois.ripe.net</td>\n<td>유럽</td>\n</tr>\n<tr>\n<td>whois.apnic.net</td>\n<td>아시아 태평양</td>\n</tr>\n<tr>\n<td>whois.jprs.jp</td>\n<td>일본</td>\n</tr>\n</tbody>\n</table>\n<p>그러나 <code class=\"language-text\">whois</code> 서비스는 기본적으로 도메인이 등록된 IP 주소의 소유주에 대한 정보를 보여주는 서비스라서 도메인이 등록되지 않은 게이트웨이나 라우터에 대한 정보는 나오지 않는다. 그래서 필자는 <a href=\"https://www.ip2location.com/demo\" target=\"_blank\" rel=\"nofollow\">IP2Location</a>이라는 사이트를 이용하여 한번 찾아볼 것이다. <small><strike>(근데 이것도 잘 나올 것 같지는 않다)</strike></small></p>\n<p>먼저 첫 번째 홉인 <code class=\"language-text\">192.168.25.*</code>은 필자 집의 공유기에서 할당해준 사설 IP이고 두 번째 홉은 ISP가 필자에게 부여해준 공인 IP이나, 보안 상 마스킹 했으므로 세 번째 홉인 <code class=\"language-text\">100.71.51.17</code>부터 한번 살펴보겠다.</p>\n<h4 id=\"100715117\" style=\"position:relative;\">100.71.51.17<a href=\"#100715117\" aria-label=\"100715117 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<img src=\"https://images.ip2location.com/18399031.png\">\n<p>앗 역시 생각보다 정보가 별로 안나왔다. 대신 해당 IP 주소가 Carrier Grade NAT에 사용된다는 정보를 출력했다. 위에서 설명한 대로 A 클래스의 <code class=\"language-text\">100.64.0.0 - 100.127.255.255</code> 대역이 Carrier Grade NAT에 사용된다는 것은 이미 표준으로 정의된 것이기 때문에 사실 뻔한 결과를 출력한 것이다. 그럼 Carrier Grade NAT이 뭐길래 중간에 필자의 패킷이 들렀다 가는걸까?</p>\n<p>우선 NAT은 Network Address Translation의 약자로 대개 사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP를 사용하여 인터넷에 접속하기 위한 기술이다.</p>\n<p>필자는 SK 브로드밴드의 IPTV나 Wi-Fi 등 여러 개의 서비스를 사용 중이다. 그렇다고 IP 주소를 가입한 서비스마다 나눠주기에는 주소가 매우 부족한 상황이기 때문에 SK 브로드밴드는 필자에게 단 하나의 공인 IP 주소를 할당해주고 NAT 기능이 있는 공유기를 집에 설치해, 필자의 집에 사설 네트워크(Private Network)를 구축해준 것이다.</p>\n<p>Carrier Grade NAT(CGN)은 NAT의 스케일 큰 버전이라고 생각하면 된다. 필자의 집에 설치된 공유기는 필자의 집 내부에 사설망을 구성하는 데에 그치지만 CGN은 백본망에 구성되는 NAT이다. 쉽게 말하면 거대 공유기랄까…?</p>\n<p>필자가 알기로는 원래 스마트폰의 LTE같이 모바일 망에 직접 연결되는 무선 인터넷 디바이스를 NAT로 관리하기 위해 백본망에서 CGN을 운영한다고 알고 있었는데, 왜 집에 있는 공유기를 사용 중인 필자의 패킷이 CGN을 타는지는 잘 모르겠다. SK 브로드밴드가 IPv4가 많은 편은 아니긴 한데… 너무 모자라서 유선 인터넷에도 CGN을 달았나…? <small>(혹시 아시는 분은 좀 알려주세요…궁금해요…)</small></p>\n<h4 id=\"1044255240--102221641\" style=\"position:relative;\">10.44.255.240 ~ 10.222.16.41<a href=\"#1044255240--102221641\" aria-label=\"1044255240  102221641 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>여기서부터는 A클래스 사설망에 할당되는 IP이므로, 추측하건데 SK 브로드밴드의 백본망 내부인 것 같다. ISP들은 자신들의 망 구조를 자세히 알려주지 않기 때문에 정확히 어디에 위치한 노드인지는 알 수 없지만 SK 브로드밴드의 망 구조 상 대략 이쯤 되는 것 같다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/40e14dfe7f089d802c42a2c0fcca55dc/82158/skb-network.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 97.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAA7zAAAO8wEcU5k6AAAC4UlEQVR42o1U2VLbMBT1T7b9hvITnfaxfEOf+sBMH2CmdPrQklAYIA2BAA5LiB07i5PYsS1blhdJ1lI5CWmZ0uXOtcf23HN1dO6RNcaY7wcQJiiJOOfy9xBCXT9z9VqFFgLQ0dv+xMrjAc6CZfkat34WT3SVmut6EIaCFZxRRpCg+UO1WCYjmSwKSZnEWFI86RuXZy3f9yvweDTs9y1C6BLCiyjPEsYq/iWnQTRAs36ZRuNRo4CeJOS+3TLPmmmWCSE0lMQ3ndMkiSSJBEWszFA845xhUtiT66l7J7MsRtHXky0XjBX5JIHpzDFMs6RUM00zgYoDXyixFKhattvT68efQGzzOHKC7jTolpSAyI8A2P+48+zF893dXc2zmpPhLaalwJDnkeCl5ET1gvOmcbNt2b3Mcw7Pt+/63+dgWGtshX4wvb/d3tkJgkBLAzPyTSlKxVmQhONY8lzyAheOM+0MBl0KgsncHrqXOYYzd9Y3jMvDb283Ny8u2lrnWnecYcWWKXyqZFoozQQnC9GoTBHK01rjveMZBDOKcau+93Jj4+DgQLu9aiDPkFJVF2osqwlyrPBVx7KUaUIZHU1vUAowydVABARZXk1UQ9C3jOssRZyxlWB8SWERrJQIqsYgmWcF8oDD1ZckXugqtL5lX1x1ur1727bYAi9o9ggcBVk8B54dzYcq4XzEQ285Fa2nt6am3jqqda+vOF9MS+BHdsQFQ5AkgCaAwFDd1ZeVPSfW1ah7enZUv9XblRsrk8yXDhPiSUf/4u3poNM7369/3mk3TyqlCMigu6KwwAuxtvlDrk9V4I2RP7Z7N4O+Ueax2jFOQ8u8j+LYdd1/rIzAIOwdH2+/M/UmKwuc50r52t6XN69f1eq18XicpumftqDpescP4/ZFq9v+oErUOUm9oedYp82GYfTyvHj6D7EEO47jujPfdVDoCFpItrLH/4S2EqYkPA1Z4qnkGCmKf1lwDf4BBWRoCVFWkuUAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"skb network\" title=\"\" src=\"/static/40e14dfe7f089d802c42a2c0fcca55dc/6af66/skb-network.png\" srcset=\"/static/40e14dfe7f089d802c42a2c0fcca55dc/69538/skb-network.png 160w,\n/static/40e14dfe7f089d802c42a2c0fcca55dc/72799/skb-network.png 320w,\n/static/40e14dfe7f089d802c42a2c0fcca55dc/6af66/skb-network.png 640w,\n/static/40e14dfe7f089d802c42a2c0fcca55dc/82158/skb-network.png 696w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>여기서 부터 다른 국내 ISP와 연결되거나 해외망으로 연결된다</small>\n</center>\n<h4 id=\"7214204124--10817023379\" style=\"position:relative;\">72.14.204.124 ~ 108.170.233.79<a href=\"#7214204124--10817023379\" aria-label=\"7214204124  10817023379 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<img src=\"https://images.ip2location.com/60603511.png\">\n<p>드디어 구글이 소유하고 있는 디바이스가 나타났다! 근데 위치가 네덜란드 암스테르담이다. 구글은 미국 캘리포니아에 있는 회사인데 왜 뜬금없이 암스테르담이 출현했는지 모르겠다. 뭔가 이상하기 때문에 유럽을 담당하는 <code class=\"language-text\">whois</code> 서비스인 <code class=\"language-text\">whois.ripe.net</code>에 물어봐야겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">whois <span class=\"token parameter variable\">-h</span> whois.ripe.net <span class=\"token number\">72.14</span>.204.124\n\ninetnum:        <span class=\"token number\">69.194</span>.128.0 - <span class=\"token number\">76.255</span>.255.255\nnetname:        NON-RIPE-NCC-MANAGED-ADDRESS-BLOCK\ndescr:          IPv4 address block not managed by the RIPE NCC</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>역시 여기서 관리하고 있는 주소가 아니라고 한다. 그렇다면 아메리카를 담당하는 <code class=\"language-text\">whois.arin.net</code>에 물어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">whois <span class=\"token parameter variable\">-h</span> whois.arin.net <span class=\"token number\">72.14</span>.204.124\n\nNetRange:       <span class=\"token number\">72.14</span>.192.0 - <span class=\"token number\">72.14</span>.255.255\nCIDR:           <span class=\"token number\">72.14</span>.192.0/18\nNetName:        GOOGLE\nNetHandle:      NET-72-14-192-0-1\nParent:         NET72 <span class=\"token punctuation\">(</span>NET-72-0-0-0-0<span class=\"token punctuation\">)</span>\nNetType:        Direct Allocation\nOriginAS:\nOrganization:   Google LLC <span class=\"token punctuation\">(</span>GOGL<span class=\"token punctuation\">)</span>\nRegDate:        <span class=\"token number\">2004</span>-11-10\nUpdated:        <span class=\"token number\">2012</span>-02-24\nRef:            https://rdap.arin.net/registry/ip/72.14.192.0</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>오 이번에는 제대로 된 정보가 나왔다. <code class=\"language-text\">72.14.204.124</code> 주소를 가진 디바이스는 구글이 소유하고 있는 무언가인듯하다. IP2Location은 이제 필자에게 신뢰를 잃었기 때문에 가차없이 버리기로 하고 <a href=\"https://db-ip.com\" target=\"_blank\" rel=\"nofollow\">DB IP</a>라는 새로운 솔루션을 사용하겠다.</p>\n<p>DB IP를 사용하여 검색해보니 위치가 <code class=\"language-text\">Ashburn, Loudoun, Virginia, United States</code>로 잡히고 Connection Type은 <code class=\"language-text\">Hosting</code>으로 되어있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6aa63397ba4132502a4856ab76647df1/a6d66/db-ip-result.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 78.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACbUlEQVR42p1UiW7bMAz1/3/RPmEYVgzoiqJJ3DSJj/iWLcm35TeSbgK0w4BiAmjrIJ/J9yh7tu2Q5QXqpsG0LJhmtvlu4zRhcQ4t+aVZDvbn9XZOvtPmN1PsQmtvGEcBa7ueHBfwel4c1tXBkXGwW1c0VYUiDqGyK+osRl0msCpHkV/RkOWHHarrBZ7WGkmSYCQgDsz0hLIDzABoMrdCRtso6DyWoCI8IvD3CN5ekQc0Px3hv/xCHO/g9X0vYDwcRavGoOtHLAQ0O0Dw6NHVBVQZUaYJmiTA8fWAlx8PODz+RhQH+Lk/4PvxzIAD8jyHUgoL8aCp/Jk4+TyMLhClPqLIp7ID6PSM2H/Cw2GPMDrDP+7x7SWEt1KZjnlyzNsqZTN32/563+87jdZUMGUGU6VEQYGkyPCc5NhfU/hhiMcghVdWNVJSOUkzaNOK0uM0i7GK/GYFOWsWj8F5dBOgiKk6pcrojHf5TDI0jYUlMN4c2gHzuAiIKhWdGQEYhhGXS4Asy2StDcW0PVaq4vYRrs7jya56RWQS2XwuD7i2W9BTsUNi8y0jEo+5rustS2MZ0H7geb0BRjZF2SvZDEwMNTT3ednXMudO0NpQI0+ytgTIgv4FaK1Boxo09OWyKqVE3WjibpR28auTZL9SDx3f3nA6n4VPY4x0Rtu20h13QKU75EpTCYacLHGjxbnrOnnbrhVnziwl4RhAMqS3UrUItdDNugPOROr8Tuy/7AYYhJGII6JQ+UVRygfYbn4evjj4J8BXlG+WiCQVWPl5rM59FOUrg0WJouguBItSlFuG7n8A+dZw2bfSlvdm/6zyH6Vx13b7DHTLAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"db ip result\" title=\"\" src=\"/static/6aa63397ba4132502a4856ab76647df1/6af66/db-ip-result.png\" srcset=\"/static/6aa63397ba4132502a4856ab76647df1/69538/db-ip-result.png 160w,\n/static/6aa63397ba4132502a4856ab76647df1/72799/db-ip-result.png 320w,\n/static/6aa63397ba4132502a4856ab76647df1/6af66/db-ip-result.png 640w,\n/static/6aa63397ba4132502a4856ab76647df1/d9199/db-ip-result.png 960w,\n/static/6aa63397ba4132502a4856ab76647df1/21b4d/db-ip-result.png 1280w,\n/static/6aa63397ba4132502a4856ab76647df1/a6d66/db-ip-result.png 2070w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>그 이후 9번 홉인 <code class=\"language-text\">108.170.242.193</code>과 10번 홉인 <code class=\"language-text\">108.170.233.79</code> 또한 버지니아 주에 위치한 호스팅 서버인 것으로 표시되었다. 여기에 도대체 뭐가 있길래 다 여기에 옹기종기 모여있는걸까…?</p>\n<p>조금 구글링을 해보니 구글이 Ashburn에서 일할 사람을 찾고 있는 공고를 발견했다. 또한 같은 버지니아 주의 옆 동네인 Sterling과 Reston으로도 채용공고가 많이 올라와있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/fa825b93f209cad6a735204a4c4504b1/6d2da/google-hiring.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABy0lEQVR42pVTa4/aMBDM//9bfOJaaGlVroU8DkggJI4d8g6JPd11G3ToDl270mhtxxmPd9aOAWC6DmhqtJSLoiCU6NoaGCuYK0GPMMb8Exzig3ie4dviJxKZY/3jO758XUGle6D2oQsf0D2mMHgcN8K4PuJZCjQkNCutZkjKSW4wauLtDCKh0Q0G/UD7pbZ73lVY1zUu6oKWcpZlUOWAS20oa2SFRl5rmms7z2ld0lrd9CznXZVOR3UTmYBSCkKkyKuBYFA0TGpuYyZTNOZDOpZJ0fe9xfV6BfOM4whHa22lTjUwd3P9Som5Yboek7Rta3PTNBiGAU6appjNZlitVlgul3h6+mTxebGAHwSYz+fw/QBaxBjb5o8p5rE1TlVV2Gw2cF0PnfLQn5do0l8Iwwj7/R673Q7n8/mhq28I2RTXdXE4HMBqw/CAKAwhpbQ/cElel+WjcLiop9PJqhBCWNKMyKZxkiT225QZURTheDwijmNrJh94p3C73cLzPAvfcy1eXgK7HlAdeX29XlsSPpzVMzETshF3Ctly7j8pFfKcWkdViEWF/FIip9O5xuxgWZa2RT68MsudbO+oBSp6LYqecc+v4m9v/U/8BqA969jZ9pErAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"google hiring\" title=\"\" src=\"/static/fa825b93f209cad6a735204a4c4504b1/6af66/google-hiring.png\" srcset=\"/static/fa825b93f209cad6a735204a4c4504b1/69538/google-hiring.png 160w,\n/static/fa825b93f209cad6a735204a4c4504b1/72799/google-hiring.png 320w,\n/static/fa825b93f209cad6a735204a4c4504b1/6af66/google-hiring.png 640w,\n/static/fa825b93f209cad6a735204a4c4504b1/6d2da/google-hiring.png 936w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>날 뽑아줘요...엉엉</small>\n</center>\n<p>공고를 쭉 스캔해보니 주로 Network Engineer, Administrative Business Partner, Data Center, Google Cloud와 같은 키워드가 많이 보이는 걸로 봐서는 아무래도 여기에 구글 데이터센터가 있나보다. 좀 더 정보를 찾아보니 <a href=\"https://wtop.com/business-finance/2019/02/google-to-double-its-virginia-workforce/\" target=\"_blank\" rel=\"nofollow\">구글이 버지니아에서 일하는 인원을 두배 늘린다는 기사</a>도 올해 2월에 작성되었었다.</p>\n<p>여기에 구글 데이터센터가 있는 것은 아무래도 확실한 것 같다.</p>\n<h4 id=\"1722172568googlecom\" style=\"position:relative;\">172.217.25.68(google.com)<a href=\"#1722172568googlecom\" aria-label=\"1722172568googlecom permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/0d61b84bb06d96dea7054db728e40209/6f175/final.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 59.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACRElEQVR42l1TaW/TQBD1//8bCIpA8IVSKqRyiCI1JE3cxCaU1Hadqz7i+r7Wx2NmkxTESOPdbHbfvDdvV0nzHJ6/Q5QkaNoWoqEUDWpK0dDYCLRdh4T2bR0PYZKiEi2qWqCsa0rxlBWdUfKiwPbBQZKm6PoOWVGhanpwdH2Pltb4l+nu8F638EEzcaEZWBg6luYMFz8tnP5a4d3cxldzC6UoS7ieR6yEBImJQZxkSJIYNTE4xnjt47lq4ouqQtd/QLu5wmQywtvJLU5mFv1n4Ox2BSXLMnBKRl2PXVJTCgRZg7DoiOUecGZa+DZRcTe/xtYYYjq6wqfvI7yZmXitWXh5Y+L895ok5wVy6k9D/eqoV49hhLKqpcyWPn2/RzSMBaaDS6jE6uNYw9m1jlfjBV4Q0AnlM2J4ygxZahRFiONYAhbUUx6PcSCIpetgbi8xWTn4fO/j0nAwXO8wolZwDmwX+taHUhOgTHKJXWVG7Cpnd5jzyAp8P5B7OchoMrAhGS3+Vu+hhFFMLrsyM2LH1+FYpCgrkl9JUDbowXFITSzP8j428F8VHAp/2JSS3JZz6icfZtm7IKBDiVznAildreagglsVhiH+Dwl47Wu4i225MPSmsJKVnA9cFXa6OTCqYC+XMK17WbAlqZ7nyyLHWyIBpSlZTC8hhSAZUR4jLTL0xDCvSwRFiFwUEsBxXKQHmfyaguBRmsmsnwAZPaSrwr0J2W0aE9ok6MmBzLbjDTapI+eO66Kinu4BBV2xUAIeHwW34g91epBEkzIrowAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"final\" title=\"\" src=\"/static/0d61b84bb06d96dea7054db728e40209/6af66/final.png\" srcset=\"/static/0d61b84bb06d96dea7054db728e40209/69538/final.png 160w,\n/static/0d61b84bb06d96dea7054db728e40209/72799/final.png 320w,\n/static/0d61b84bb06d96dea7054db728e40209/6af66/final.png 640w,\n/static/0d61b84bb06d96dea7054db728e40209/d9199/final.png 960w,\n/static/0d61b84bb06d96dea7054db728e40209/21b4d/final.png 1280w,\n/static/0d61b84bb06d96dea7054db728e40209/6f175/final.png 2036w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>자 드디어 마지막 <code class=\"language-text\">google.com</code> 도메인의 종착점인 <code class=\"language-text\">172.217.25.68</code> 주소를 가진 서버이다. 이 주소도 역시 DB IP를 통해 검색해본 결과 일본에 있는 서버라고 한다.</p>\n<p>사실 한국에 있는 필자가 미국에 있는 서버에서 계속 정보를 받는 것보다 가까운 일본에 있는 서버에서 정보를 받는 게 훨씬 빠르기 때문에 이건 당연하긴 하다. 필자의 패킷은 태평양을 건너 미국에 갔다가 다시 일본으로 건너가는 기묘한 루트를 그리고 있었다는 것이다…</p>\n<p>자세하게 파고 들어가면 왜 이런 루트를 그리는지 알 수 있겠지만 너무 포스팅이 길어질 것 같아 여기까지만 파보겠다. <small>(다음에 좀 더 자세히 파보는 걸로…)</small>\n늘 아무 생각없이 접속하던 구글도 자세히 들여다보면 이렇게 다양한 경로를 통해 나에게 전달된다. 새삼 신기한 사실이다.</p>\n<p>이상으로 우리 집에서 구글까지 가는 길 포스팅을 마친다.</p>","fields":{"slug":"20190622-my-home-to-google","path":"/2019/06/22/my-home-to-google/","lang":"ko"},"frontmatter":{"title":"우리 집에서 구글까지 가는 길","subTitle":"매일 사용하는 인터넷, 그 속을 들여다보자","date":"Jun 22, 2019","categories":["프로그래밍","네트워크"],"tags":["네트워크","Network","IP","TCP","IP 클래스","traceroute","인터넷","네트워크 기초","기술면접"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/b9d22b130aacc561550df26f133f469d/d803c/network-structure.png","srcSet":"/static/b9d22b130aacc561550df26f133f469d/d803c/network-structure.png 320w,\n/static/b9d22b130aacc561550df26f133f469d/2a1fd/network-structure.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/b9d22b130aacc561550df26f133f469d/fc5c5/network-structure.webp 320w,\n/static/b9d22b130aacc561550df26f133f469d/e9225/network-structure.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/b9d22b130aacc561550df26f133f469d/01fb2/network-structure.png","srcSet":"/static/b9d22b130aacc561550df26f133f469d/01fb2/network-structure.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/b9d22b130aacc561550df26f133f469d/b384d/network-structure.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"10f3f894-af40-5c3f-af3f-e6d6e621d61f","tableOfContents":"<ul>\n<li>\n<p><a href=\"#http2%EB%9E%80\">HTTP/2란?</a></p>\n</li>\n<li>\n<p><a href=\"#aws-cloud-front%EC%97%90%EC%84%9C-http2-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">AWS Cloud Front에서 HTTP/2 사용하기</a></p>\n<ul>\n<li><a href=\"#cloudfront-distributions-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0\">CloudFront Distributions 변경하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#elastic-beanstalk%EC%97%90%EC%84%9C-http2-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">Elastic Beanstalk에서 HTTP/2 사용하기</a></p>\n<ul>\n<li><a href=\"#application-load-balancer%EB%9E%80\">Application Load Balancer란?</a></li>\n<li><a href=\"#%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\">설정하기</a></li>\n<li><a href=\"#%EC%84%9C%EB%B2%84%EC%97%90-%EB%B3%84%EB%8F%84-%EC%84%A4%EC%A0%95%EC%9D%84-%EC%95%88%ED%96%88%EB%8A%94%EB%8D%B0\">서버에 별도 설정을 안했는데?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#http2-%EC%9E%98-%EC%A0%81%EC%9A%A9-%EB%90%90%EB%8B%88\">HTTP/2, 잘 적용 됐니?</a></p>\n</li>\n<li>\n<p><a href=\"#waterfall%EB%A1%9C-%EB%B9%84%EA%B5%90%ED%95%B4%EB%B3%B4%EC%9E%90\">Waterfall로 비교해보자</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 AWS(Amazon Web Service) 환경에서 HTTP/2 프로토콜을 적용하는 방법에 대해서 설명하려고 한다. AWS의 CloudFront와 Application Load Balancer는 자체적으로 HTTP/2 프로토콜을 사용할 수 있는 기능들을 제공해주고 있기 때문에 별도의 작업 없이 간단하게 HTTP/2 프로토콜을 적용할 수 있다.","html":"<p>이번 포스팅에서는 AWS(Amazon Web Service) 환경에서 HTTP/2 프로토콜을 적용하는 방법에 대해서 설명하려고 한다. AWS의 CloudFront와 Application Load Balancer는 자체적으로 HTTP/2 프로토콜을 사용할 수 있는 기능들을 제공해주고 있기 때문에 별도의 작업 없이 간단하게 HTTP/2 프로토콜을 적용할 수 있다.</p>\n<!-- more -->\n<h2 id=\"http2란\" style=\"position:relative;\">HTTP/2란?<a href=\"#http2%EB%9E%80\" aria-label=\"http2란 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>HTTP/1은 이미 세상에 나온지 30년이 다 되어가는 프로토콜로, 웹 어플리케이션을 위한 프로토콜이라기 보다는 문서를 위한 프로토콜로 설계되었기 때문에 모던 웹 어플리케이션과 같이 무거운 페이로드, 빈번한 통신 등의 환경에서는 여러 가지 비효율적인 점이 많다.</p>\n<p>그래서 HTTP/2는 현대적인 통신을 지원하기 위해 다음과 같은 목표를 가지고 고안되었다.</p>\n<hr>\n<ul>\n<li>전체 요청, 응답 다중화를 통한 지연 시간 단축</li>\n<li>비대한 HTTP 헤더 필드의 효율적인 압축을 통해 프로토콜 오버헤드를 최소화</li>\n<li>요청 우선 순위 지정</li>\n<li>서버 푸시 지원</li>\n</ul>\n<hr>\n<p>HTTP/2는 기존 HTTP/1 프로토콜을 사용하고 있는 어플리케이션을 수정하지 않고도 모든 핵심 개념(메소드, 상태 코드, URI 및 헤더 필드)을 공유하도록 설계되었다. 대신 HTTP/2는 클라이언트와 서버 간 데이터 프레임과 전송 방식을 수정하는 방식으로 통신 효율을 높였다.</p>\n<p>또한 클라이언트와 서버 간 통신에서 가장 효과가 큰 것은 응답 다중화가 정식으로 지원된다는 것이다. 이 말은 하나의 연결만 으로 여러 리소스를 주고 받을 수 있다는 뜻이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cd17700751cbce62e857b08574923f45/9c177/multiplexing.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 97.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAADeUlEQVR42p2U/U9TVxjH+08tWChCaaGlvbcUmagzCiuzbqAD0Y3o3BCVQSl9oS1liCUWYWTJiJuEqJsvGUucUfe+yUtfLy1QzP6Hz869JUxQt+kPT07Oued87vPyfR6d5E9hG0xxcCTLiak87ZM5jsQUmi8p1A+lqRlIiv0KrssKFm8S9X5rPMfJz/O0ifW9Kys0RjLUCobkS6KT/Eks4tGp6VUCNzfovV6g+1qBs1+usT+aodojgOMrtKhAca8umMY7t0HPtXUG5gr0zxZwjSnajzeBGeyDCey+lLAksjCnbwlZeKKa6tU7OzxUI6rdtOK71NZ7na3/d6ShvIAuYxrMYTr3C66uGSy+rPbwRcDtkB1AvamO2t4fcUQK9Ez9xsy9JT6bXeBEfImmkcSrA8vsTegrrZTu6eBgyzGGZrO4x0SuAqq92EPp34BquMYjAQzy25i771PRr2D2pLH50trjbcCBhIAltJzLfhVeLIS6/gMURZHDG1oeLT4FaXCRhuACDv+yBt0GFN/rImvIoTymgRzVXgWrOKv2ZgQ0rdVBV/5mO3axcYqLJ68q3LoR5+G9i/RO3uHAcBarNyGACi2xPDXnH1DXPoH71GW6J+9ycfoB7f5beCfmMQl5ycEVdCVlRgxSE+VHRznWeYaZ71KcnlzkQCRBfTClaU8Vumt8HfvHN7GYjDirSuhyV3H2+F66OtzEwn1UuTzYL/wgZOP5k/I9x9m1u5rKji8wehR2f5re0pgastYpY1ks/hx7vY9o6LnBvgvfEpmeJxodRWo+jfP9MHpDZTGHUmgNyfMHpsBT9nl/ZmTqNlZ/dgv4bFHsAQV7cFVYDnuogKP/J0pth3nDYKaq9ZKQjdSM3btIffQpnVcW+Xp+gUxigdbYMoeiCZHDHbJRq+pLaKtaBBWsNof13PeaYzq9UaK0poGyw324WzuYuJ2hbTzF/rBoweAzIb9U2OqZiHIoV6yyuql46yP0JifGD+eoFDm0+IWEvOnnQ35ppyS3TGfr+xV5+C9NqLWhDeTBJ3QOf0NjaFmcpZ8P+b9ab1eFBWvPfRzhNT6JP+b6ncdcjUX5IP6EQyPJVwcanO8KyZgpkY/S2NSG5ysxXMdWcQR2yOb/AuXQuij3qNBiG+bzj4QOM2JYFuej5H+N8aVVSZRbDhdE6yibTV+cKK8D/BtyUDBzrCWA+QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"multiplexing\" title=\"\" src=\"/static/cd17700751cbce62e857b08574923f45/6af66/multiplexing.png\" srcset=\"/static/cd17700751cbce62e857b08574923f45/69538/multiplexing.png 160w,\n/static/cd17700751cbce62e857b08574923f45/72799/multiplexing.png 320w,\n/static/cd17700751cbce62e857b08574923f45/6af66/multiplexing.png 640w,\n/static/cd17700751cbce62e857b08574923f45/9c177/multiplexing.png 880w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>[출처] csstrick.com<small>\n</small></small></center>\n<p>HTTP/1에서는 프로토콜 차원의 응답 다중화가 지원되지않았고 응답의 병렬 처리는 브라우저가 책임을 가졌다. 그렇기 때문에 브라우저의 정책에 따라 요청의 병렬처리가 가능한 개수가 달랐다.</p>\n<hr>\n<ul>\n<li>Internet Explorer: 출처 별 10개~11개</li>\n<li>Chrome: 출처 별 6개</li>\n<li>Firefox: 출처 별 6개</li>\n<li>Opera: 출처 별 6개</li>\n</ul>\n<hr>\n<p>그렇기 때문에 프론트엔드 개발자들은 어플리케이션 초기화 시 최대한 리소스 요청을 줄이기 위해 모든 JavaScript와 CSS 파일을 하나의 번들로 묶어 <code class=\"language-text\">index.js</code>나 <code class=\"language-text\">style.css</code>와 같은 파일로 만들고 Minify나 Uglify 등의 기법을 사용하여 용량을 최대한 줄이기도 하고, 여러 개의 이미지를 요청하지 않기 위해 하나의 커다란 이미지를 다운로드받아 마스킹해서 사용하는 스프라이트 방식과 같은 방식을 사용했다.</p>\n<p>하지만 HTTP/2는 출처 별로 최대 128개의 병렬 요청을 처리할 수 있으므로, 이제 우리는 하나의 큰 파일이 아닌 작은 여러 개의 파일로 나눠서 동시에 요청하고 받아올 수 있는 등의 HTTP/1.1에서는 하지 못했던 성능 개선의 여지를 만들 수 있게되었다.</p>\n<h2 id=\"aws-cloud-front에서-http2-사용하기\" style=\"position:relative;\">AWS Cloud Front에서 HTTP/2 사용하기<a href=\"#aws-cloud-front%EC%97%90%EC%84%9C-http2-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"aws cloud front에서 http2 사용하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>AWS는 2016년 9월부터 Cloud Front에서 HTTP/2를 지원해주기 시작했다. 간단한 세팅 만으로 HTTP/1.1에서 HTTP/2로 변경할 수 있다. 또한 HTTP/2를 지원하지않는 하위 버전의 브라우저에서 요청을 받는다면 HTTP/1.1으로 프로토콜을 변경하여 응답하는 기능 또한 가지고 있다.</p>\n<p><a href=\"https://aws.amazon.com/blogs/aws/new-http2-support-for-cloudfront/\" target=\"_blank\" rel=\"nofollow\">AWS CloudFront HTTP/2 세팅 메뉴얼</a>에서 HTTP/2를 세팅할 수 있는 방법을 자세히 설명해주고 있기 때문에 프로토콜을 변경하는 과정은 전혀 어려움이 없었다.</p>\n<h3 id=\"cloudfront-distributions-변경하기\" style=\"position:relative;\">CloudFront Distributions 변경하기<a href=\"#cloudfront-distributions-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0\" aria-label=\"cloudfront distributions 변경하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>먼저 Cloud Front 대시보드로 이동하면 현재 등록되어있는 배포판들의 목록이 보인다. 이 중 HTTP/2 프로토콜을 적용하고 싶은 배포판을 선택한 후 상단의 <code class=\"language-text\">Distribution Settings</code>을 선택한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 634px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e1216e67d70cafeea2556e898cbfef79/374ac/cloudfront1.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 16.249999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAs0lEQVR42k2OXQqCQBSF3XD02Eu7aAf1Ei2hVVSazBSVaGlC4Pivo/g1CUUHDufjXjgc6xk+kOKIc9jjXS+cTgLbObDb7zjaDrZxEAR8NAzDL//5qw9b/qvE9RPkXXEOFW6gSPKKNDWZJCilSFVK27b0fU/TNHRdN7qu69+tKAq07rAWW5/pymW2Fsw3gslSIB4ZoX8za894noeUkjCKxtI4jseiqip5GtZaE5mfFIIsy3kDCJDel9x/7mwAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"cloudfront1\" title=\"\" src=\"/static/e1216e67d70cafeea2556e898cbfef79/374ac/cloudfront1.png\" srcset=\"/static/e1216e67d70cafeea2556e898cbfef79/69538/cloudfront1.png 160w,\n/static/e1216e67d70cafeea2556e898cbfef79/72799/cloudfront1.png 320w,\n/static/e1216e67d70cafeea2556e898cbfef79/374ac/cloudfront1.png 634w\" sizes=\"(max-width: 634px) 100vw, 634px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p><code class=\"language-text\">Distribution Settings</code>을 클릭해서 배포판 설정 화면으로 들어가면 현재 배포판에 대한 여러 가지 정보가 있는 화면이 나온다. 이 정보들 중 이 배포판이 지원하고 있는 프로토콜에 대한 정보도 함께 담겨있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9590e8009282b8ca9e49b979a697dc38/636c2/cloudfront2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 59.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABY0lEQVR42oWS63KDIBCFff9Xa2baRsd410RRVMQUvIKXrpq0SSZNvx87wOxhzy4oJWsDRL7qluRZli7wipfnsiiKpmnyPId1SSnGSVVXOMGEFHVdF5T2fa8UhFQVn+cZNkKItm0Z513XNXUN66qqhmGYxgki5Eg5jOM4TRNkQlS2zXxFSpli7PvB8Xg0DcOyrCzL6Ap4gUgIAUdbsjLfwxkHjaaqjPHt0mEYhxV5Beo9irfU8BR+frxrmhbHcUlL0AgphRQ/glvuKkMGdOs6zsEwCMkRijHG4cpm9bbBXzEMgC+wKIpQFBmmyRiDEc4vuYi7roVJgABeS93vVU0LgsAyTdu2YWae5yGE4BWfV14GI2VBizhJ3nY7sI3TNCfwyGc4hEvHlT97HoTAgR+6jqvrnn4IHZcmSQ+yXvxj+6Lve4wi2zR1dY9OYRxG8Eu6tn1w+1y84fme47pdvwCf7MXYvgFuGrA4CzbmowAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"cloudfront2\" title=\"\" src=\"/static/9590e8009282b8ca9e49b979a697dc38/6af66/cloudfront2.png\" srcset=\"/static/9590e8009282b8ca9e49b979a697dc38/69538/cloudfront2.png 160w,\n/static/9590e8009282b8ca9e49b979a697dc38/72799/cloudfront2.png 320w,\n/static/9590e8009282b8ca9e49b979a697dc38/6af66/cloudfront2.png 640w,\n/static/9590e8009282b8ca9e49b979a697dc38/636c2/cloudfront2.png 911w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이제 상단의 <code class=\"language-text\">Edit</code> 버튼을 눌러 배포판의 설정을 변경하도록 하자. 밑으로 쭉 내리다보면 <code class=\"language-text\">Supported HTTP Versions</code>라는 항목이 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 598px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5246325f1e672822f3bab327f1bf4566/0c69d/cloudfront3.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 12.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAgElEQVR42m1O0QrCMAzc//+iY0qXKjZZHybrbGl7pkVhqAchueMuyYA3Ss4opeCIWmuvz9y7er59RwzjeALRjJkI1lqcpwnO3RFCwMUYGNWZGXS9QdhBRMDC2ML2c7wvjDEipdSvZv2y8dabxhqWZcFjXeG9h1e+788WV3/9++EL7pvpWv+Z2GQAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Supported HTTP Versions\" title=\"\" src=\"/static/5246325f1e672822f3bab327f1bf4566/0c69d/cloudfront3.png\" srcset=\"/static/5246325f1e672822f3bab327f1bf4566/69538/cloudfront3.png 160w,\n/static/5246325f1e672822f3bab327f1bf4566/72799/cloudfront3.png 320w,\n/static/5246325f1e672822f3bab327f1bf4566/0c69d/cloudfront3.png 598w\" sizes=\"(max-width: 598px) 100vw, 598px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이제 첫 번째 항목인 <code class=\"language-text\">HTTP/2, HTTP/1.1, HTTP/1.0</code>을 선택하면 된다.</p>\n<h2 id=\"elastic-beanstalk에서-http2-사용하기\" style=\"position:relative;\">Elastic Beanstalk에서 HTTP/2 사용하기<a href=\"#elastic-beanstalk%EC%97%90%EC%84%9C-http2-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"elastic beanstalk에서 http2 사용하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Elastic Beanstalk은 Web 서버나 Worker와 같이 친숙한 웹 어플리케이션이나 서비스를 간편하게 배포하거나 컨트롤할 수 있는 서비스이다. Elastic Beanstalk에서 환경을 생성할 때 사용할 언어나 서버 엔진등을 설정해놓으면 해당 설정을 사용하여 다른 환경으로 복사할 수도 있고 Auto Scaling이나 Load Balancing과 같은 귀찮은 설정이 필요한 작업들도 간단한 몇개의 설정만 건드려주면 알아서 다 해주기 때문에 꿀이 따로 없다.</p>\n<p>또한 프로젝트의 루트에 <code class=\"language-text\">.ebextensions</code> 디렉토리를 생성하고 내부에 쉘 스크립트 파일을 넣어놓으면 파일 정렬 순서에 따라서 배포할 때마다 해당 스크립트들을 실행시킬 수도 있어서 굉장히 유연하다.<small><del>(node-sass가 말썽부려서 rebuild 해야할 때 아주 유용하다)</del></small></p>\n<p>환경을 생성할 때 Classic Load Balancer와 Application Load Balancer 중 하나의 로드 밸런서를 선택할 수 있는데 Classic Load Balancer는 기존의 ELB를 의미한다. Elastic Beanstalk에서 HTTP/2를 사용하고 싶다면 Application Load Balancer를 선택하도록 하자. 물론 ELB를 고르고 직접 세팅하는 방법도 있지만 필자는 굳이 어려운 길을 선택하지 않았다.</p>\n<h3 id=\"application-load-balancer란\" style=\"position:relative;\">Application Load Balancer란?<a href=\"#application-load-balancer%EB%9E%80\" aria-label=\"application load balancer란 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>AWS는 지난 2016년에 L7(Application) 계층에서 작동하는 <a href=\"https://aws.amazon.com/ko/blogs/korea/new-aws-application-load-balancer/\" target=\"_blank\" rel=\"nofollow\">Application Load Balancer(ALB)</a>를 공개하였다.</p>\n<p>기존에 사용되던 로드밸런서인 Elastic Load Balancer(ELB)는 L4(Network) 계층에서 동작하기 때문에 HTTP나 HTTPS와 같은 Application Layer에서 사용되는 프로토콜을 인지하지도 못하고 이에 따라서 유연하게 처리하지도 못했지만 ALB는 Application 계층에서 작동하기 때문에 직접 HTTP 헤더를 까보고 이에 따른 유연한 부하 분산이 가능한 것이 장점이다.</p>\n<p>예를 들면 동일한 호스트로 요청을 보내더라도 <code class=\"language-text\">/a</code> 경로로 요청을 보내면 a 서버로 보내고 <code class=\"language-text\">/b</code> 경로로 요청을 보내면 b 서버로 보내는 등의 유연한 라우팅이 가능하게 된다는 것이다.</p>\n<p>하지만 무엇보다 좋은 점은 위에서 설명했듯이 <code class=\"language-text\">HTTP/2</code> 프로토콜과 <code class=\"language-text\">WebSocket</code>을 자체적으로 지원한다는 것이다. 만약 기존에 ELB, 즉 Classic Load Balancer를 사용하고 있던 환경에서 HTTP/2 프로토콜을 사용하고 싶다면 직접 세팅하거나 ALB로 마이그레이션 해야한다.</p>\n<p>하지만 로드 밸런서를 마이그레이션해도 기존 ELB에 연결되어있던 인스턴스들과 자동으로 연결해주지는 않기 때문에 Elastic Beanstalk을 사용하고 있다면 그냥 환경을 다시 만드는 게 정신건강에 이롭다.<small><del>(처음에 쉽게 가보려다가 안되서 실망한 1인)</del></small></p>\n<h3 id=\"설정하기\" style=\"position:relative;\">설정하기<a href=\"#%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"설정하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>먼저 Elastic Beanstalk 환경에 접속하여 새로운 환경을 생성하자.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2c4c368507f2816bfd6aea8f30a79582/ad12c/eb1.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 80.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACdUlEQVR42p1UyVLbQBDVP5HAjQSuWciv5pLKJbkEMCaEhNiSLVu2FmvxItuSF8laX7rHyAUGLumqV7Oo5/Xrnh5JR6dnODr9hMOTM7x++xEHx+/x6s0HMa/AewfH74TfPg5Ptj58nteS0mpBlhW02ir6ugFVVXFdr6N2cU7jFeq1Gv78vkWn3YbaJt9GA4oso0mjTKPW60E3THQ1TfBIWrcrSHq6DrunYVL/AeP6ElrtAr2rS/SvahjLDfhKE9bN9Xavdk77hO9fMVBkON4QpmGg0+lAKssSAgCyMEDq2GArww4QtICwLeZFsEU5a6BIV1v/yQjFdIycVkWeCR4pjmNsNhskWY546iNu/kLkakj1BhL9L1JDRmYqyKwWcltFaVMAz0Lpj5CoTcSTCVIiT7ICm7SAZJDUCnpfx9DWcNf5DJtKYGk9GJSGQ7W16dtyOkUexShJBJIIi3mArruAPl7DnEToeqttyjuj6TpZ4M76BtfzYNk2DMuCOxzCdh04rgt/Otu5Z3mOXcnuIWHP1psQt/0vsJlMqO7DcRzoep/WOlarFdI0Eb75PeFDe0xI36LNCpr3E77vYzQawSOlPOcATOySyvF4vFWYZft6HtwygSMyiqLAfD5HGIYCPN9Xwus0TQVpdY7xLCE7WVS76rJY1ZQuZLlcPiJm34cBnqTMyhhMqNMtm6YpiHnU6CXwXpIkO/8gCETAwWAgSsKQnkuD+3I2m4lU+dCEeo0VMqIoEkoZvOa6MhEH5vmTW67Sf2nNNqQ2Eh1Aivm5teh/wBkoCr1ljviSVUT7hJVxJlwOJueRA0nr9Rr/Y1waJuDWqlqMCf8BnQCWST/aBEoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Elastic Beanstalk 환경 생성\" title=\"\" src=\"/static/2c4c368507f2816bfd6aea8f30a79582/6af66/eb1.png\" srcset=\"/static/2c4c368507f2816bfd6aea8f30a79582/69538/eb1.png 160w,\n/static/2c4c368507f2816bfd6aea8f30a79582/72799/eb1.png 320w,\n/static/2c4c368507f2816bfd6aea8f30a79582/6af66/eb1.png 640w,\n/static/2c4c368507f2816bfd6aea8f30a79582/ad12c/eb1.png 856w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이후 <code class=\"language-text\">Web server environment</code>를 선택하면 환경 이름이나 사용할 언어등 간단한 세팅을 할 수 있는 화면으로 이동한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 518px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ce0af85cf4b6cc034de1f43536f7c668/6b9fd/eb2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 89.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACJElEQVR42p1Uaa+bQAx8//9PtVK/tVLvg1cSBXISwrEXEM6pbUJe2qRN1EijZWF37PHYeXLOYrfbwRiNumngnIOzFlobFIWjVdFa4NHf07GqkCQHWOvQti3SNMF+v0cURbSOSNNUAjFxWZYvz0VJ9yy6rnsh/DOCLWpkykGZArl2yGlVtpR3mS6gbUXfaK9H0puEwzCcX6SqRLjaIlhuEIRr+LMFtlFCxG4McEKUGFxcu5Xh+PXZX+DV6zd4++4DPn35hvcfP+Prdw/ezxm8Z1/WH54Pf768XcPLTd8PsK5EsJhLDYe+Fzlt29DaUka9gFNrmu5ehqcaEuEyDBEEgSBJMzHKkhFj0DFIVbePSVbaYjabwfdJnudJpkpppFkmbjNaIjzeJxwp+eDhEEtrGGOg8hyaCLldJnT/IgyCEJv1RjIpy4qkVdKHaZIgo6yyPJMMu64XuZPkvxJOh3opOKQ2q9VyNOXUUj2BSS7xkGR2uTo2WK9XIpcD8fQw/ouwrmsibGm2t+RuenZVsjxJncCBp2BN056H46ptNE1EGAaYz+fIyRDnCqklZ8x1ZDImdzTHcXxAnqXYx7E4f5PQ2EL6j9smoH40xpLrdFGp37IUyfcmhbPmgzG5zEM/GcZyhivJrZjFzTZcUF/V0NCkRPsDDmmO8lijrGoJUtOoXaKqu3P3DueEhhuSqVZZlssfrCKZPBnjXsuezVL0PO0ZXGsGN/0vveJ2udRNtk4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Elastic Beanstalk Platform 설정\" title=\"\" src=\"/static/ce0af85cf4b6cc034de1f43536f7c668/6b9fd/eb2.png\" srcset=\"/static/ce0af85cf4b6cc034de1f43536f7c668/69538/eb2.png 160w,\n/static/ce0af85cf4b6cc034de1f43536f7c668/72799/eb2.png 320w,\n/static/ce0af85cf4b6cc034de1f43536f7c668/6b9fd/eb2.png 518w\" sizes=\"(max-width: 518px) 100vw, 518px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>Elastic Beanstalk에서는 다양한 언어를 제공해주고 있으니 입맛대로 골라담아보자. 이렇게 기본적인 세팅을 하고서 하단의 <code class=\"language-text\">Configure more options</code>를 클릭하면 좀 더 디테일한 설정을 할 수 있는 화면으로 이동할 수 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c58be6012821f6a5d25c879335789b05/302a4/eb3.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 30.624999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAyklEQVR42q2QzWrCUBSEfcTiVoqvpBRKUFz4DgUXre6Emmhs1IRKSDGEQDUgUfAnN73386ZZCbUrBz7mrIY5U+HOqtw9UEpJgdIUUrlAHQ+QnUrOBUd9n+GkXWR/Bimlrhtm4ocozdlFMcnSxTPf+bRG+NMxvj3GNUesZxaN7pDqs8ejMadmLKi3XB6aDgNvex0ockmcCvbfG9JgyZcOCiYmoTP9xbctkoXNy+sHT28hncEKo7+irb3RC5hH+xsbFtWV5MZfJf9seAGDucj3Hwwz8wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Configure more option\" title=\"\" src=\"/static/c58be6012821f6a5d25c879335789b05/6af66/eb3.png\" srcset=\"/static/c58be6012821f6a5d25c879335789b05/69538/eb3.png 160w,\n/static/c58be6012821f6a5d25c879335789b05/72799/eb3.png 320w,\n/static/c58be6012821f6a5d25c879335789b05/6af66/eb3.png 640w,\n/static/c58be6012821f6a5d25c879335789b05/d9199/eb3.png 960w,\n/static/c58be6012821f6a5d25c879335789b05/302a4/eb3.png 1080w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>만약 손이 미끄러져서 <code class=\"language-text\">Create environment</code>를 클릭하면 환경이 생성되는 동안 10분 정도는 그냥 날리게 되므로 눈 크게 뜨고 클릭하도록 하자.</p>\n<p>제대로 클릭했다면 디테일 설정화면으로 이동하게 되는데 상단의 <code class=\"language-text\">Configuration presets</code>를 확인해보면 아마 기본 값으로 <code class=\"language-text\">Low cost</code>가 선택되어 있을 것이다. 이 옵션에서는 로드 밸런서를 사용할 수 없으므로 우리는 <code class=\"language-text\">Custom configuration</code>을 선택해야한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b3ef6724a1eb0a47401fbd6ffdac9c27/27b8e/eb4.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 46.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABO0lEQVR42o1Ry3KCQBDk//8rFzl40VJEQAXR+AJU3o+O3amlTA6pbFUzOzs9vUOv1fc9fN/HarXCfD7HbDZDEATwPA+O44xg7rqu6rZtKx4OByyXS0WzrGEYcDweJbrb7TCdTiW82WwQhqFECO4nk4mEKWLOeBn7R0F+rtcrLpeLkKap4vl8xul0QpIk2pPDfZZlAs8YTZ1cTirB+/2O5/OJPM8VSTRnxO1200WPx2MEc8M3XPZJkD6+k4miKEYibem6DlVVoSxL1UwkzDDkSbBpGnmzWCz0OAT9pD/b7VZi2UucnsVxLH/p+X6/V04/oygSz8K/1oCqLBC+mugXm3kRJ1P1NdmPRzGHv9H3g8TcT+DDKRCHPjw/GKfiX63Xa1lhNKy/5/peeQ0keY+ubVDXNdq2Hf1k/j7hF1cmq2XFWr3rAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Configuration presets\" title=\"\" src=\"/static/b3ef6724a1eb0a47401fbd6ffdac9c27/6af66/eb4.png\" srcset=\"/static/b3ef6724a1eb0a47401fbd6ffdac9c27/69538/eb4.png 160w,\n/static/b3ef6724a1eb0a47401fbd6ffdac9c27/72799/eb4.png 320w,\n/static/b3ef6724a1eb0a47401fbd6ffdac9c27/6af66/eb4.png 640w,\n/static/b3ef6724a1eb0a47401fbd6ffdac9c27/27b8e/eb4.png 836w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p><code class=\"language-text\">Custom configuration</code> 옵션을 선택하면 하단의 Load balancer 카드에 <code class=\"language-text\">Modify</code> 버튼이 활성화 되었을 것이다. 해당 버튼을 클릭하면 이제 드디어 로드 밸런서를 선택할 수 있는 화면이 나타난다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/1a3b213065692e5e6e9300b99e424245/d2782/eb5.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABrElEQVR42o1Ue0/CMBzs9/9c/mmMxoARwQljbOzhXt37cfaqxQrE0OTyW9txvbv+hgjDENvtFp7nYb/fw3Vd+L6PcRwxz/MJ18a1PZE3PeKyUWiRyBZhXiNtBsgBqBSydkZSjfqAruvQ9z3attXzc+JpmiD8VOJh+Ybntw88vb7j8WWDjRfCCRI4foxtLBFWilxK7YQO6IbOiqJAWZYnlayCipbvLnZhBu+zxEEdsE9KuHGu1yLZKZUT5ulXhalUyWorFaV6uVAo+1nblMOMopv1nMjVXl6rPH+IbNJzy5qQuaRpijzPEccxsiz7Y4FE0zTi1iEYsM4kipAkiSZnNiRmPua2byYcBnWjKnBWo8rkY8gmy+55u1y0DduAtom6rnVLXOu3mxXS2uFwQKQss6FZm6a5AA8j7Pn5O3QpmBd7iiAZL+Z4PCIIAl3NM/d5IOd85hp/S2JGJqtauxTMibbJboNrdhwmU7PPXEnMz5UOX18WSkz0rdBxHH26Ubnb7bBarfQa63q9PimzodfoQOHufgHPDyB4EpXYwRt1//0x2GNUX9G9I5FVPb4A9Co8/w8ketwAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"로드 밸런서 선택화면\" title=\"\" src=\"/static/1a3b213065692e5e6e9300b99e424245/6af66/eb5.png\" srcset=\"/static/1a3b213065692e5e6e9300b99e424245/69538/eb5.png 160w,\n/static/1a3b213065692e5e6e9300b99e424245/72799/eb5.png 320w,\n/static/1a3b213065692e5e6e9300b99e424245/6af66/eb5.png 640w,\n/static/1a3b213065692e5e6e9300b99e424245/d9199/eb5.png 960w,\n/static/1a3b213065692e5e6e9300b99e424245/21b4d/eb5.png 1280w,\n/static/1a3b213065692e5e6e9300b99e424245/d2782/eb5.png 1864w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>3개 다 맛있어보이지만 한번에 하나만 먹을 수 있으므로 욕심 부리지말고 Application Load Balancer를 선택하자. 그리고 밑으로 스크롤을 조금만 내려보면 로드 밸런서 설정 메뉴들이 보인다.</p>\n<p>우리는 이 중 <code class=\"language-text\">Listener</code>를 생성해주어야한다. ALB의 리스너는 구성한 프로토콜이나 포트를 사용한 요청을 확인하는 프로세스라고 보면 된다. 기본 설정에는 HTTP 프로토콜을 사용하여 80포트로 들어오는 요청에 대한 리스너만 있기 때문에 우리는 HTTPS 프로토콜을 사용하여 443포트로 들어오는 요청에 대한 리스너를 만들어주면 된다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2447dd384b41d2fe99a736d917073cae/3a1b1/eb6.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.74999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABqklEQVR42p1Sy07CUBDlV12TmJC4UNC9gARYiFIgwY1LkMcvuFJCXLlQEzUQEyhBWqCE9vZ4Z2RK8REfNzmZmfs4c2bmRqLRKLLZLFKpFNLpNJLJZGAzmQxyuRwjn89/CzovFAqIx+OINBoN0JrNZlgsFpjP53Ach2PP8/CbpZRi2+12EWk2mxzQY9d1Yds2k5FPkP2vYvGXyyVzdDodTdhqBYSkjBROp1P2JfOfFDZCComI1I3HY4xGI1iWxTHty5lA4nBiJrxY9ZAORLpawfsA5fucWEBEgoCwVqtxmf1+H71eD44ejD94gXq8g//8sMbTPTzb0qSb5fqrJAFha9XDV10mwaYS6mdQhztQuQOo7L5GAupoF87tDZbvLD9Pmb6MaZrcG1c/oIcb0HsL3RJSRARiCTTpgLDdbnMg4yc70UrNwYAxMocwh0P2J5MJD4JaFB6QZdlwddlX1521QiKjbNQP+eDyyQV0JzwUGcyGwlboH/5nTXU/xjMX510HxfolIrFYDNVqFcViEYZhoFQqsRVfUC6XUalUPuHUKOP4xMDWXh5b2wm8ARletbTJSXtIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"로드 밸런서 리스너 생성화면\" title=\"\" src=\"/static/2447dd384b41d2fe99a736d917073cae/6af66/eb6.png\" srcset=\"/static/2447dd384b41d2fe99a736d917073cae/69538/eb6.png 160w,\n/static/2447dd384b41d2fe99a736d917073cae/72799/eb6.png 320w,\n/static/2447dd384b41d2fe99a736d917073cae/6af66/eb6.png 640w,\n/static/2447dd384b41d2fe99a736d917073cae/d9199/eb6.png 960w,\n/static/2447dd384b41d2fe99a736d917073cae/21b4d/eb6.png 1280w,\n/static/2447dd384b41d2fe99a736d917073cae/3a1b1/eb6.png 1686w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>리스너를 생성했다면 하단의 <code class=\"language-text\">Save</code> 버튼을 눌러 로드 밸런서 설정을 저장하고 나머지 설정도 입맛대로 설정한 후 <code class=\"language-text\">Create environment</code>를 클릭하면 드디어 환경이 올라가기 시작한다. 참고로 좀 오래 걸린다.</p>\n<h3 id=\"서버에-별도-설정을-안했는데\" style=\"position:relative;\">서버에 별도 설정을 안했는데?<a href=\"#%EC%84%9C%EB%B2%84%EC%97%90-%EB%B3%84%EB%8F%84-%EC%84%A4%EC%A0%95%EC%9D%84-%EC%95%88%ED%96%88%EB%8A%94%EB%8D%B0\" aria-label=\"서버에 별도 설정을 안했는데 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>따로 안해도 된다. ALB에 HTTPS 리스너를 가지고 있다면 이 리스너가 알아서 해준다. 만약 브라우저가 HTTP/2를 지원하는 브라우저라면 리스너도 HTTP/2로 응답할 것이고 만약 HTTP/1.1만 지원하는 브라우저<small><del>인터넷익스플로러</del></small>라면 리스너도 HTTP/1.1 프로토콜로 응답할 것이다.</p>\n<p>그리고 HTTPS 리스너가 HTTP/2 요청을 받더라도 로드 밸런서에 연결된 인스턴스들과는 각각의 HTTP/1.1 프로토콜로 통신하기 때문에 서버에서는 그냥 평소대로 HTTP/1.1에 대한 처리만 하면 된다.</p>\n<p>자세한 내용은 <a href=\"https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html#http-connections\" target=\"_blank\" rel=\"nofollow\">Elastic Load Balancing 사용 설명서의 HTTP Connections</a>을 읽어보도록 하자.</p>\n<h2 id=\"http2-잘-적용-됐니\" style=\"position:relative;\">HTTP/2, 잘 적용 됐니?<a href=\"#http2-%EC%9E%98-%EC%A0%81%EC%9A%A9-%EB%90%90%EB%8B%88\" aria-label=\"http2 잘 적용 됐니 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>환경을 생성했다면 이제 끝이다. 가장 간단하게 테스트해볼 수 있는 방법은 역시 <code class=\"language-text\">curl</code>을 사용하는 것이다. 여러분이 생성한 환경에 요청을 해봐도 되고 아니면 그냥 아무데나 찔러보자. 생각보다 많은 서비스들이 HTTP/2를 사용하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">curl</span> <span class=\"token parameter variable\">--http2</span> <span class=\"token parameter variable\">-I</span> https://www.naver.com/\n\nHTTP/2 <span class=\"token number\">200</span>\nserver: NWS\ndate: Thu, <span class=\"token number\">13</span> Jun <span class=\"token number\">2019</span> <span class=\"token number\">14</span>:59:09 GMT\ncontent-type: text/html<span class=\"token punctuation\">;</span> <span class=\"token assign-left variable\">charset</span><span class=\"token operator\">=</span>UTF-8\ncache-control: no-cache, no-store, must-revalidate\npragma: no-cache</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>크롬 브라우저를 사용한다면 <a href=\"https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin?utm_source=chrome-ntp-icon\" target=\"_blank\" rel=\"nofollow\">HTTP/2 and SPDY indicator 크롬익스텐션</a>을 설치하는 방법도 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 98px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ea713cc7adcbac869f0ddc1c27f52939/a4837/http2-plugin.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 96.93877551020407%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB2klEQVR42q2TsW7bMBCGOfUVOmTs1FcoMsSGPbW2swbJ2AxFMgdeMmVwAqSFDXSIA8Qo4MKWbImSKEs2EmTOY/25o3I2rSpDAQ8fRIrkf/8dj6rZbGKXqEajgV2idu5w54K1Wg1V1Ot1izuuonxOdTodlGm32/+FnPnWakHFcQwmiiJorddszyOEoSZCSxAEa+yciGn/U5ZDLRYLZFmGPM8hYyFNUxiT0v+E1mMkiSESy9pIHCFPF/jre/hxfQXFTpj5fI7BYIDxeGzn4kbrANNpSGuGHPmYzWZ274zwfB8RZTCl7+fTY3z4ug/Fh1hgOByi1+uh3++/CWkS0FguA1xcPOLg4IXcBltpTz0PS3J3OfiJvZNDnP2+LRwaYzAajdDtdq1LTqVIzWC1SnB3t8LNzRONjS0Bl4LXgyBETmX6403w8aiFT6dHUO5FTCYTG3nzr3ATx5pEikwkmHmrJbOiy/j1cI8v59+hfH9TFxaRlORwGam52wkhBc7I+XO+3FyKiLmiLm6ruC3D+zlQIayhuH6pMbaOjKThjrfaxDFQ7lceKznsUvSfwXtNX4UEUlUpbr0C+nJ9be9RrQWey75/BN0oblrvUeVQzCh3o4hJquUSMPw83XmZV3Oj5CsAxn8kAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"HTTP/2 and SPDY indicator\" title=\"\" src=\"/static/ea713cc7adcbac869f0ddc1c27f52939/a4837/http2-plugin.png\" srcset=\"/static/ea713cc7adcbac869f0ddc1c27f52939/a4837/http2-plugin.png 98w\" sizes=\"(max-width: 98px) 100vw, 98px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이런 귀여운 아이콘이 HTTP/2나 SPDY 프로토콜 사용 여부를 알려줄 것이다. 근데 SPDY는 아직까지 구글 말고는 쓰는 곳을 본 적이 없는듯…?</p>\n<p>또는 크롬 브라우저의 개발자 도구 <code class=\"language-text\">Network</code> 탭에서 테이블 헤드에 마우스 우클릭을 하면 <code class=\"language-text\">Protocol</code> 컬럼을 활성화 시킬 수도 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 362px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b4034d3ba3d49737892b8eeb0dc3101d/10600/network.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFQ0lEQVR42nWV2U8bVxTG5/+oEohtzGKMWQwYYkiIjfeNkiZNorYPbV/aNFUWKgFJCgYHbLPEhtiAN8A7pmmz0EppCk1e+md9/c4EpEhVHz7dc2fm/uY759w7o3zi/wrnnFfRZJtEk9mK1r5RaHotMHQYoW/RQavToaW1FbqWFugYi1r+JxYp50a9aBq8DE33AJrbjWhvM0Fn7IRB3wq9Vgut9r+LRFre+xio0WhUKYZOIzrb22Fs06OjowOmdgOMpi6YDB3qg61018b7rW1t6lxieU6v16uws7Grqws9PT1QjD3d6GRg7O2FUUaqgzcHhoYQmZ7B9J0fMfX9bUz9cAfzs7OIL0WxEo0jPBfGo0ePMTc3jwdTU3B6fQhevQbFRbqHcsqoa4GXo+PCBdwc7Mffu2nsRx6jEPkZh5tr+OdFDe9/reCEOmb8J3X8uoFGrQB7dzeGJWWBuakAJXAbUwhqmuExDeDGVAnfzdfx9WwJ9+NH+PbJ7/hi/jW+XHiNW9SN8CvcXPwDn87WMWLswYhOC0WcuVgbHyWxnUAPgeNdFljvvsWNxXf4Jv4etyInsP50AvPdY/TfO0Yf1XvvL/TdfwfT7ZewGHpxUYAegrwids3NMUC5m5txzdyHk9wW8nOPsT71AJuPZvG2vIs31T0cVffxorKLXzj/rV5Ens85TCZYJeVJuhJNUD6681MB3rje3483mSzyCwvYnp9HPhZFY3sb5a0tlDIZ1Pb3UdrbQ7VcRmpnB+Ns5iXZhy46c1J2QvyUQ+KmJgT6+nCUTiNLWCYcRm55GRscVzlPRKMqsKwCS0jzRZe4MyxspuKQmlHuU3eiK4TeMptRj8eQjyxii1vjaHcXR8UiXpRKOOSoAilxmD51OCIOx6VuBATpLiQuOffT4efcl9XVVWQXF/F0Zga5WAyvCHhONagaoQKsnKYsNRwVh58JkPXzU0EZZdvwxjXW8GU2i52lJaw+fIgka/mcKYq7A6pKlT5yOMaUh9lMxUJI/6kGKDOPWj+BNgIbLH6CDjdZv9XwApbn5rDHxQeVCiolOhQw4zQbZb9ohbXPDEVDR9pTqTGB55l6/8AA0mtriBKSSSbRkMV0WGMNa3RV4ViSa9UqUs+eweXzw+0PQWnjoRe1n4mHXz5VFgJT62tYZ0fX6bBBSJ2qlcpqmlK7UrFEhwSmUnC63Bh3uAikK1ErIaJ2xno6tDDlcqGARCyOKOuX4aLnBwc4rNVQk5TPgNUPQLvDiSs2B0/K6T6cJERiOTET58/hOk+KpLexsoqVJ0uIRZ4gwa4n19exV9hFjaAzh+mdDMbZ5RE5KV5vAD5fAH5/EC6XBx6Pj/MgQqEJ1JleiYtFe/kCdnN55LM5AgvYZz2L7HKRdUyyxk46tNvFIUG2cdrlxO5007pLnfuDIRwwvbX4CmLL/AYy9Q0ufEqHEXY+kUigwtSz3FrLrLGHTZH1itvrh9PtxeUxG0cf5AUuugxNTKJeqyPxNIFoNIYYgblcDvV6HWU6L+4XVXcZbq0oG+fyeFUjyqDFgkHLEAYGLRgavgjL0DDM7LB93IEagVmmKAsbjUNVB2yMXK/RvTSkyDqLWwE6WDJFYAaDASZTN4xG/ktYXIOhE1brCLa3dxBeWERyYxP7dJRKpbHDL9AWrwskmdxAPB7HzPQ0s/PAQSluNkRSPpOLaXu5QW10OHbFzjgIKYuk08kf2uilMQzzVFzgMZOflvyktFqNmp30QRGbKoh1czKW0eH8MApYrgVZT4GK5CXWkVH1TyeHQA5FC8FjNjt8gRD+BcIaJTG18gx0AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"네트워크 탭의 Protocol 컬럼 활성화\" title=\"\" src=\"/static/b4034d3ba3d49737892b8eeb0dc3101d/10600/network.png\" srcset=\"/static/b4034d3ba3d49737892b8eeb0dc3101d/69538/network.png 160w,\n/static/b4034d3ba3d49737892b8eeb0dc3101d/72799/network.png 320w,\n/static/b4034d3ba3d49737892b8eeb0dc3101d/10600/network.png 362w\" sizes=\"(max-width: 362px) 100vw, 362px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>그러면 네트워크 탭에서 HTTP/2 프로토콜로 통신하여 받아온 리소스는 <code class=\"language-text\">h2</code>라고 표시가 된다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 165px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/64a2efd14eb3ccf3c692e6d32ed99f81/04c57/http2-check.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 27.500000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDElEQVR42oWRa0vDMBiF808a2ia9pde13brZ2d2cojKGIvgLREFhgozJmOi++K+PSWAw3NAPDyFv3pyc84Z4ngff9zUOd8A5/xfXdfXKGIdpmggCofeO44CMJlMs159YvL2j7jeghiEbGWzbPkDVKaWoeid4Xa7x+LzAw9MLbu7uoXS6vRokTTP0mwEGwzFEGOoXj4ntsCwLgRDoVF1Mpue4ms0RRTHyopApA5AwjNDKC2RZS1oPtG0V6S+EFEzSVAtTaoBL54zZ8i4Hubi8xmb7jdXmC6PxGZh0oeapZvsbVVfn9WmD1ccWs/mtnt3uD1QPSZIEZdlGu1MhlJGVg2Ni+6gkeVEijpOD/h++CLzRmVvtPAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"네트워크 탭의 Protocol 컬럼 모습\" title=\"\" src=\"/static/64a2efd14eb3ccf3c692e6d32ed99f81/04c57/http2-check.png\" srcset=\"/static/64a2efd14eb3ccf3c692e6d32ed99f81/69538/http2-check.png 160w,\n/static/64a2efd14eb3ccf3c692e6d32ed99f81/04c57/http2-check.png 165w\" sizes=\"(max-width: 165px) 100vw, 165px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"waterfall로-비교해보자\" style=\"position:relative;\">Waterfall로 비교해보자<a href=\"#waterfall%EB%A1%9C-%EB%B9%84%EA%B5%90%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"waterfall로 비교해보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>왼쪽이 <code class=\"language-text\">HTTP/1.1</code>, 오른쪽이 <code class=\"language-text\">HTTP/2</code>이다. HTTP/2 쪽의 붉은 라인은 이미지 요청 에러인데, 스테이징 환경에서 리소스 출처 문제로 인해 발생하는 403에러이기 때문에 무시해도된다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/10f6fcafbe60f0c9d6f5291aabf79d51/9cab2/result.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 183.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAlCAYAAABCr8kFAAAACXBIWXMAABYlAAAWJQFJUiTwAAAGhklEQVR42oWWy3Pb1hXG/ad305lsmukuXbgzTTtdtEnaNI2sie1YsSXVlmSRlPgm8SIJEiAA4o0LgHp8/e4FJUtyZrLAXIo8+t3z+M45eGaaJnTdgGla6Pf7eP3za5ycnMAwDH6vQ9M0zGYzLBYL9Z1lzZTdwcEBzs7OIP9ffm8YujqfxUmCpb3AxvcQBhGcpQPP9RCHMaJNhE0QI8syJEkK254/svPXPu0i/h0i3CS0SfBMiAqTaQ9RtEJdXaGqKlRl85SiRBLXuL6+5ucKI62LKHawraVdqWzLskSRC6RJjdvbGwksMZn0CXT4Y4U8z2lQKFhRFLy1aoD8bTztIwwdgmr1mxBCPVlWIE0r3NxcN0BNHyFOPZTSUBTKWN38CFhiqtEu9pRnCsjvBO2zLFd29x5q0yGiYIk8SpDFMfJCGkpvBQENUP6tTQkMA8KvUcQZnxwiKwmsCNx+Aup6D4F2jsQaIt/YvDmiFxEhGxpmBN4QUmCqn8IdvUZsHiGxT5G758iTIYET2vkEQgIz6OYBQ36H7fYMZc2n/IC6PuF5zNxoBEIBR1obYWygLleMYglROUzRisAFgRGBtxIomJsuwsRiZUOG6TM/MqwNT1/Jpakyi2dMMOjMEPmyGDVEUavzs5DH4xbsWRdF5hHCWwuXwLX6LG+WIcuLNWuCk3cdjM4t/i52lf6sKEIBZ0YPebqmh656hJCfHRalATYeDjG+HCP0EyWvh7K5B5YiZ7J/gb16wxBaNDhXT1W16MUpDQ0Cb++Bc7ZjXW9pW/w6sCgEjNkY2miEwI2Y5Iy3ZyoUecZxeZ9DYzFFr9PHpDNnUQijHgU7JqPMkrT+BNStMSyKO3Q3Sth34chTAdkBQl6s9dA97eDwxQUWfRN1tIHwfcpnjTTImipLoMZQ/MDGyloryK8CKXJtconeWQf/e3mJtW6j3gQQnofccZH6KW5x21R5qg+RFB60jonxxxkcM1CJl1W8C1kUTcjddhfvf7qEbXkMVajQc/Eg5KaXh4jzNTw7gDW0kaXZYw93QN0aodfq4ni/g/5HjUMkV0+WZE96mSFHKbVXV1joMxYnYCWrByFTh6ykcXaI3uEHvH/dZdjsmtM26l4X+XkbqblkwNj1sslezJgPcaV61xo7yNn0opQdUH/ykGrotnsqh6cHXcQcqlVF2aQPhS2rbHaQFjql4dMzD+6cE9xboqrXHLBx4yGLYow66NGrY+bw/C09s1eoXF6+WCL1kk9F0YxLJPmMQuaEYf/maQTfcehx0PSyAjLkQQv9k5YCdo/6qG0b1XKJwpojpYYbYCGBYwJ9ArbNLOTg3PDGPBNNyBJIsPXyB/R/eoOjN0N0/3uE8pt/od57ger7/yBvD3Cjclg0VU6yNaS3TZdwR3CAxmGiRrsCcvha//gag+/3cPR2guG3r1D/4UuUX/0J5Zd/RPbmeAfcVTnhpGmmNEXNSZKEKbcegVlTFLmINCWbHnV4gdbhAJa2gmyMR70sPVTCzh8ARVO5YB0pwd5VWTMZ6vkl3rPK7191ML0wOUPFEx0q4OAeWBT5/ZLa+NH9krqTjRT2h1eXLEwLk66Fels9kY0KeURhy4Ha5PAubGfBFtwItR7vdXjexRE75d3eR+iDOaVVMs/55yHHT4Alx5Lvhnxy3NCwAXIFXHQxauvQR3OVY7lSH0/soilKnD0BlvJtIOOrSEEPb9T4kivA0saw9TXzG6scy3Cznbx+E5hEKQK/2HnIjpoNORP7sC6H8FZrrPmk3Dl5HhMofiNkCYwJ9PLGQ64KbXGMqDjBYn6G5fwt1st32IQfkdcXbF0H5DXAiTb4DHg3vnwCpbBLjjT9aB/Fhx+RHbxE++AYHfa1ubcP77tvkAxGu2kjk80qx4mrxNsAM7WE5Om7fHPgaC+5/fS950i//T3E119gfPgKo8FbhPvPUf3td0hPf2k6pVkBo10vy5cl7ltKqZQLiFpMooJAhsypo7/4J7J//wX5X59j/MM+uhdjBC9+RP33PyM7azXA7faaiV8gXg9RbPiKwd2S+XMUoYuE54Y7o6kyi6exo0IPGyfArKdhtfAQOCH/N0IalU1R5BJPU95uDrBwDNiujpkzhb3m6/Cyj4W3YLJvVQqmZlvNze01h3HtIFgZcI0ZXNPgDvKbHMq2utpeMUTu2bpQTynPLQuzLVBfNa1X8611udTgLnv02uS81HjKdWHAcyhyP6C8bvF/+fnTvqnZQYkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"result\" title=\"\" src=\"/static/10f6fcafbe60f0c9d6f5291aabf79d51/6af66/result.png\" srcset=\"/static/10f6fcafbe60f0c9d6f5291aabf79d51/69538/result.png 160w,\n/static/10f6fcafbe60f0c9d6f5291aabf79d51/72799/result.png 320w,\n/static/10f6fcafbe60f0c9d6f5291aabf79d51/6af66/result.png 640w,\n/static/10f6fcafbe60f0c9d6f5291aabf79d51/9cab2/result.png 864w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>HTTP/2 쪽의 Waterfall은 상당히 많은 수의 요청이 동시에 처리되고 있는 것을 확인할 수 있다. HTTP/2의 이런 특징을 이용하면 기존에 하나로 번들링하고 있던 JavaScript 파일을 여러 개로 Chunking하여 파일 용량을 줄이거나, 기존에 스프라이트로 사용하던 이미지도 개별 요청을 통해 동시에 받아옴으로써 로딩 속도를 조금 더 단축시킬 수도 있다.</p>\n<p>이상으로 AWS와 함께 간단하게 HTTP/2 적용하기 포스팅을 마친다.</p>","fields":{"slug":"20190613-http2-with-aws","path":"/2019/06/13/http2-with-aws/","lang":"ko"},"frontmatter":{"title":"AWS와 함께 간단하게 HTTP/2 적용하기","subTitle":"HTTP/2의 장점과 AWS에서 쉽게 활성화하는 법","date":"Jun 13, 2019","categories":["프로그래밍","네트워크"],"tags":["Amazon Web Service","AWS","HTTP","HTTP/2","HTTP2","Network","네트워크","ALB","Application Load Balancer","ELB","Elastic Load Balancer","Cloud Front","튜토리얼"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/be9e83d603d0e671bc285680c3aa165f/d803c/aws.png","srcSet":"/static/be9e83d603d0e671bc285680c3aa165f/d803c/aws.png 320w,\n/static/be9e83d603d0e671bc285680c3aa165f/2a1fd/aws.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/be9e83d603d0e671bc285680c3aa165f/fc5c5/aws.webp 320w,\n/static/be9e83d603d0e671bc285680c3aa165f/e9225/aws.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/be9e83d603d0e671bc285680c3aa165f/01fb2/aws.png","srcSet":"/static/be9e83d603d0e671bc285680c3aa165f/01fb2/aws.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/be9e83d603d0e671bc285680c3aa165f/b384d/aws.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"네트워크","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}