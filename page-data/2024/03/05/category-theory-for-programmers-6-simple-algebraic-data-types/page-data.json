{"componentChunkName":"component---src-templates-post-page-template-index-tsx","path":"/2024/03/05/category-theory-for-programmers-6-simple-algebraic-data-types/","result":{"data":{"markdownRemark":{"id":"47605aa1-3714-56bb-adc5-4cb4803954da","tableOfContents":"<ul>\n<li><a href=\"#61-%EA%B3%B1-%ED%83%80%EC%9E%85product-types\">6.1 곱 타입(Product Types)</a></li>\n<li><a href=\"#62-%EB%A0%88%EC%BD%94%EB%93%9Crecords\">6.2 레코드(Records)</a></li>\n<li><a href=\"#63-%ED%95%A9-%ED%83%80%EC%9E%85sum-types\">6.3 합 타입(Sum Types)</a></li>\n<li><a href=\"#64-%ED%83%80%EC%9E%85%EC%9D%98-%EB%8C%80%EC%88%98%ED%95%99\">6.4 타입의 대수학</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"앞서 우리는 곱과 합이라는 두 가지 기본적인 방법을 통해 타입을 결합하는 것을 보았다. 사실 우리가 일상적인 프로그래밍에서 자주 접하는 데이터 구조는 이 두 가지 메커니즘만으로도 충분히 표현할 수 있다.","html":"<p>앞서 우리는 곱과 합이라는 두 가지 기본적인 방법을 통해 타입을 결합하는 것을 보았다. 사실 우리가 일상적인 프로그래밍에서 자주 접하는 데이터 구조는 이 두 가지 메커니즘만으로도 충분히 표현할 수 있다.</p>\n<!-- more -->\n<p>이처럼 데이터 구조의 많은 속성들을 합성할 수 있다는 사실은 굉장히 중요한 포인트이다. 예를 들어 동등성을 사용하여 기본적인 타입의 값들을 비교하는 방법과 이러한 비교 행위를 곱과 합 타입으로 일반화하는 방법을 알고 있다면, 우리는 자연스럽게 합성 타입에 대한 동등 연산자라는 개념을 유도할 수 있다. Haskell에서는 이렇게 합성된 타입의 하위 집합에 대해 동등성, 비교, 문자열로의 변환과 같은 연산들을 유도할 수 있다.</p>\n<p>그럼 프로그래밍에서 곱 및 합 타입이 나타나는 방식에 대해서 자세히 살펴보도록 하자.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 409px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/fcf5139ae1c84cc62f66e0f43c59f1ba/e9a96/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.12499999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB0lsLLOMUf//EABoQAAMBAAMAAAAAAAAAAAAAAAECAwAREjH/2gAIAQEAAQUCejKwsRlPKvLuXiG3m//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABoQAAICAwAAAAAAAAAAAAAAAAABEBEhMVH/2gAIAQEABj8C3ZmmJss5H//EABoQAQEBAAMBAAAAAAAAAAAAAAERACExUaH/2gAIAQEAAT8hgQCyB8wZdekzQFfMVTOMmJ1OJ7gBAgb/2gAMAwEAAgADAAAAENgP/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EKF//8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EIV//8QAHhABAQACAQUBAAAAAAAAAAAAAREAITFBUWGBkfD/2gAIAQEAAT8QcsEhUefb9rIZxuzvshgYALvT7myGQQ63nGIptMi1fOqYZMCAEDP/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/fcf5139ae1c84cc62f66e0f43c59f1ba/e9a96/1.jpg\" srcset=\"/static/fcf5139ae1c84cc62f66e0f43c59f1ba/0913d/1.jpg 160w,\n/static/fcf5139ae1c84cc62f66e0f43c59f1ba/cb69c/1.jpg 320w,\n/static/fcf5139ae1c84cc62f66e0f43c59f1ba/e9a96/1.jpg 409w\" sizes=\"(max-width: 409px) 100vw, 409px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"61-곱-타입product-types\" style=\"position:relative;\">6.1 곱 타입(Product Types)<a href=\"#61-%EA%B3%B1-%ED%83%80%EC%9E%85product-types\" aria-label=\"61 곱 타입product types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>프로그래밍 언어에서 두 타입의 곱의 대표적인 구현은 바로 쌍(Pair)이다. Haskell에서는 쌍이 원시 타입 생성자이며, C++에서는 표준 라이브러리에서 정의된 템플릿이다.</p>\n<p>엄밀히 말해 쌍은 교환 법칙을 따르지 않는다. 어떠한 쌍 <code class=\"language-text\">(Int, Bool)</code>은 <code class=\"language-text\">(Bool, Int)</code>으로 대체될 수 없다는 것이다. 하지만 이 두 타입은 동형성(Isomorphism)을 지니고 있다. 이 동형성은 Swap 함수에 의해 제공되며, Swap 함수는 아래와 같이 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">swap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">swap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 두 쌍은 동일한 데이터를 저장하지만 단순히 다른 형식을 사용하고 있는 것이라고 생각할 수 있다. 이는 마치 빅 엔디안(Big Endian) vs 리틀 엔디안(Little Endian)의 관계와도 비슷하다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>엔디안(Endian)은 컴퓨터 메모리에 데이터를 저장하는 방식을 의미한다. 빅 엔디안(Big Endian)은 가장 상위 바이트(Most Significant Byte, MSB)를 가장 낮은 주소에 저장하고, 반대로 리틀 엔디안은 MSB를 가장 높은 주소에 저장한다. 즉, 같은 데이터를 다루더라도 저장하는 방식만 다르다는 것이다.</p>\n<p>이는 <code class=\"language-text\">(Int, Bool)</code>과 <code class=\"language-text\">(Bool, Int)</code> 쌍처럼 같은 타입들의 곱이지만 각 구성 요소의 위치만 다른 상황과도 유사하기에 작가는 이러한 예시를 든 것이다.</p>\n</blockquote>\n<p>만약 임의의 개수인 타입들을 곱으로 결합하려면 그저 쌍을 중첩시키는 것만으로도 표현할 수 있지만 더 쉬운 방법도 있다. 이렇게 중첩된 쌍은 튜플과 동일한데, 이는 쌍을 중첩하는 다양한 방법들이 동형(Isomorphic)이기 때문이다. 세가지 타입 <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code>, <code class=\"language-text\">c</code>를 순서대로 곱으로 결합하려면 아래와 같은 두 가지 방법을 사용해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 또는</span>\n<span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 타입들은 분명히 다른 타입이다. <code class=\"language-text\">((a, b), c)</code> 타입을 받을 수 있는 함수에 <code class=\"language-text\">(a, (b, c))</code> 타입을 전달할 수 없다는 것을 생각해보면 된다. 하지만 이 타입들이 가진 각각의 요소들은 분명 일대일 대응 관계에 놓여있다.</p>\n<p>여기 이 두 타입을 서로 매핑해주는 함수가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">alpha</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그리고 이 함수에는 역함수 또한 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha_inv</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">alpha_inv</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, 이 매핑 함수는 동형사상(Isomorphism)이며, 이 과정에서 이 타입들이 결국 동일한 데이터를 여러 방법으로 패키징하고 있을 뿐이라는 사실을 알 수 있다.</p>\n<p>이렇게 생성된 곱 타입을 타입에 대한 이항 연산이라고 생각해볼 수도 있다. 이 관점에서 바라보면 위에서 알아본 동형사상은 모노이드(Monoid)에서 본 결합 법칙과 매우 유사한 형태를 띄고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그러나 모노이드의 경우 이 두 가지 방법이 완전히 동일하다고 말할 수 있겠지만, 곱 타입의 경우 완전히 동일하다는 의미가 아닌 동형사상에 따라 동일하다고 말할 수 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>만약 <code class=\"language-text\">(a * b) * c</code>와 <code class=\"language-text\">a * (b * c)</code>를 모노이드인 곱 연산의 관점에서 바라본다면, 이 연산은 교환법칙을 만족하기 때문에 완벽히 동일(Equal)하다고 이야기할 수 있다.</p>\n<p>하지만 곱 타입의 경우 각 튜플 안에 있는 요소들이 서로 정보의 손실 없이 매핑될 수 있는 일대일 대응함수가 존재하는 동형(Isomorphic)일 뿐이다.</p>\n<p>즉, 두 곱 타입이 동형사상을 통해 서로 매핑이 가능하므로 “동형성에 의해 같다”고 말할 수는 있겠지만 엄밀한 의미에서 동일하지는 않다는 것이다.</p>\n</blockquote>\n<p>만약 우리가 동형사상을 수용할 수 있고 엄격한 동일성을 요구하지 않는다면, 유닛 타입인 <code class=\"language-text\">()</code>이 곱셈의 항등원인 1과 같이  작동한다는 것을 보일 수도 있다. 실제로 임의의 타입 <code class=\"language-text\">a</code>인 값과 Unit을 쌍으로 묶는 것은 어떠한 정보도 추가하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>결국 이 타입은 <code class=\"language-text\">a</code>와 동형(Isomorphic)이다. 아래와 같이 동형사상을 정의할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">rho</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">rho</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token hvariable\">rho_inv</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">rho_inv</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이러한 분석을 통해 집합의 카테고리가 모노이드 카테고리(Monoidal Category)라는 것을 형식적으로 설명할 수 있다. 결국 집합의 카테고리는 각 대상을 데카르트 곱(Cartesian Product)의 형태로 곱할 수 있는 카테고리라는 것이다. 이에 대한 자세한 정의는 추후 다시 논의해보도록 하자.</p>\n<p>Haskell에서는 곱 타입을 더 일반적인 방식으로 정의할 수 있는 방법을 제공하고 있다. 나중에 다시 보겠지만 이런 방법은 특히 곱 타입이 합 타입과 합쳐질 때 빛을 발하게 된다. 이 방법은 여러 개의 인자를 받는 생성자로 표현되는데, 쌍의 경우는 아래와 같이 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Pair</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">P</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">Pair a b</code>는 매개변수화된 두 개의 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>, 그리고 데이터 생성자인 <code class=\"language-text\">P</code>를 의미한다. 우리는 <code class=\"language-text\">Pair</code> 타입 생성자에 두 개의 타입을 전달함으로써 간단하게 쌍이라는 타입을 생성할 수 있다. 그리고 <code class=\"language-text\">P</code>에는 정의해둔 타입에 맞는 두 값을 전달하여 쌍 타입의 값을 생성할 수 있다.</p>\n<p>한번 <code class=\"language-text\">String</code>과 <code class=\"language-text\">Bool</code>의 쌍으로 값을 정의해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">stmt</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Pair</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">stmt</span> <span class=\"token operator\">=</span> <span class=\"token constant\">P</span> <span class=\"token string\">\"This statements is\"</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>첫 번째 줄은 타입 선언부이다. 여기서 <code class=\"language-text\">Pair</code> 타입 생성자를 사용하며, 일반화했었던 <code class=\"language-text\">Pair</code> 정의의 매개변수인 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 대신에 <code class=\"language-text\">String</code>과 <code class=\"language-text\">Bool</code>을 직접 넘겨준다. 두 번째 줄은 데이터 생성자 <code class=\"language-text\">P</code>를 사용하여 구체적인 문자열과 부울값을 전달하여 실제 값을 정의하고 있다. 타입 생성자는 타입을 생성할 때 사용되고, 데이터 생성자는 해당 타입을 가진 값을 생성할 때 사용되는 것이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>완전히 동일하지는 않지만, 위 Haskell 코드를 TypeScript로 표현해보자면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 데이터 생성자</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">P</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 타입 생성자</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Pair<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> ReturnType<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> <span class=\"token constant\">P</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> \n\n<span class=\"token keyword\">const</span> stmt<span class=\"token operator\">:</span> Pair<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token constant\">P</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This statements is\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</blockquote>\n<p>Haskell에서는 타입 생성자와 데이터 생성자의 네임스페이스가 분리되어있기 때문에 아래와 같이 동일한 이름도 종종 사용되고는 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Pair</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Pair</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>더 깊게 들여다보면 <code class=\"language-text\">Pair</code>를 이항 연산자인 <code class=\"language-text\">(,)</code>으로 대체하고 있는 것 또한 결국은 빌트인 쌍(Pair) 타입의 선언을 변형한 것이라고 볼 수 있다. 실제로 <code class=\"language-text\">(,)</code>을 전위 연산자로 표현하여 타입 생성자처럼 사용할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">stmt</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"This statement is\"</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이와 유사하게 <code class=\"language-text\">(,,)</code>을 사용하면 트리플(원소가 3개인 튜플)을 생성할 수 있으며, 같은 방법으로 계속 해서 튜플을 확장해나갈 수도 있다. 또한 일반적인 쌍이나 튜플 대신 원하는 곱 타입을 정의할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Stmt</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Stmt</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Bool</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 타입은 단순히 <code class=\"language-text\">String</code>과 <code class=\"language-text\">Bool</code>의 곱이지만 이 타입은 자체적인 이름과 생성자를 가지고 있다. 이러한 선언 방법의 장점은 동일한 내용을 가지지만 의미와 기능이 다른 타입을 다양하게 정의할 수 있다는 것이다. 또한 이렇게 선언된 각 타입들은 서로 대체될 수 없다.</p>\n<p>이처럼 튜플과 다중 인자 생성자를 사용하는 생성자는 각 구성 요소가 무엇을 나타내고 있는지 추적하기 어렵기 떄문에 종종 혼란스러운 표현이 되기 쉽고 오류가 발생하기도 쉽다. 그래서 때로는 각 구성 요소에 이름을 지정해주는 것이 나을 수도 있다. 이처럼 이름이 지정된 필드를 가진 곱 타입을 Haskell에서는 <code class=\"language-text\">record</code>라고 하며, C에서는 <code class=\"language-text\">struct</code>라고 한다.</p>\n<h2 id=\"62-레코드records\" style=\"position:relative;\">6.2 레코드(Records)<a href=\"#62-%EB%A0%88%EC%BD%94%EB%93%9Crecords\" aria-label=\"62 레코드records permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>본격적인 설명에 앞서 간단한 예시를 먼저 살펴보도록 하자. 우리는 화학 원소들을 설명하기 위해 원소의 이름과 원소 기호로 이루어진 두 개의 문자열과 원자 번호를 표현하는 하나의 정수가 결합된 데이터 구조를 만드려고 한다. 먼저 <code class=\"language-text\">(String, String, Int)</code>와 같이 튜플을 사용하여 각 구성 요소를 표현해볼 수 있다. 그 다음 원소 기호가 원소 이름의 접두사가 맞는지 확인하는 함수로 패턴 매칭하여 구성 요소들을 추출할 것이다. 아래는 <code class=\"language-text\">He</code>가 <code class=\"language-text\">Helium</code>의 접두사인지 확인하는 함수이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">name</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">isPrefixOf</span> <span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">name</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러나 이 코드는 에러가 발생할 가능성이 있고 유지 보수하기도 쉽지 않은 코드이다. 이런 경우에는 레코드를 정의하는 것이 훨씬 더 낫다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Element</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">name</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span>\n                       <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span>\n                       <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">atomicNumber</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위 표현과 튜플을 사용한 표현은 동형(Isomorphic)이다.이는 서로 역함수의 관계를 가지는 두 개의 변환 함수를 통해 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">tupleToElem</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Element</span>\n<span class=\"token hvariable\">tupleToElem</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Element</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">name</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">n</span>\n                                <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">s</span>\n                                <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">atomicNumber</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token hvariable\">elemToTuple</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">elemToTuple</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">name</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">atomicNumber</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서 레코드 필드의 이름은 필드에 액세스하기 위한 함수로도 작동한다는 사실에 주목하도록 하자. 예를 들어 <code class=\"language-text\">atomicNumber e</code>라는 표현은 <code class=\"language-text\">e</code>에서 <code class=\"language-text\">atomicNumber</code>필드를 검색한다. 이처럼 <code class=\"language-text\">e</code>라는 레코드의 필드에 액세스하는 <code class=\"language-text\">atomicNumber</code> 함수의 타입은 다음과 같이 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">atomicNumber</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Element</code>의 레코드 문법을 사용하면 이제 <code class=\"language-text\">startWithSymbol</code> 함수도 더 읽기 쉬운 형태로 다시 표현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">isPrefixOf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">name</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>심지어 Haskell이 제공하는 트릭을 사용하여 함수인 <code class=\"language-text\">isPrefixOf</code>를 중위 연산자로 표현하여 거의 하나의 자연어 문장처럼 읽히도록 만들어 볼 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">`isPrefixOf`</span> <span class=\"token hvariable\">name</span> <span class=\"token hvariable\">e</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2 id=\"63-합-타입sum-types\" style=\"position:relative;\">6.3 합 타입(Sum Types)<a href=\"#63-%ED%95%A9-%ED%83%80%EC%9E%85sum-types\" aria-label=\"63 합 타입sum types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>집합의 카테고리의 곱 연산에서 곱 타입을 유도할 수 있듯이, 합 연산에서 합 타입을 유도해볼 수도 있다. Haskell에서 합 타입을 표현하는 전형적인 방법은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Right</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>쌍과 마찬가지로 <code class=\"language-text\">Either</code>도 두 연산 대상이 동형성(Isomorphic)인 경우에 한해 교환 법칙을 만족하고 중첩도 가능하다. 또한 두 대상이 동형이라는 전제 하에 중첩 순서 또한 중요하지 않다. 그런 이유로 다음과 같이 세 개의 구성 요소를 가진 합 타입을 정의해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">OneOfThree</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Sinistral</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Medial</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Dextral</span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 집합의 카테고리가 합을 기준으로 대칭적인 모노이드 카테고리라는 것이 밝혀졌다. 여기서 이항 연산의 역할은 서로소 합에 의해 수행되며 단위 원소의 역할은 초기 대상에 의해 수행된다.</p>\n<p>타입 관점에서 바라보면 <code class=\"language-text\">Either</code>는 모노이드 연산자, 그리고 Uninhabited(아무런 값도 가질 수 없는) 타입인 <code class=\"language-text\">Void</code>는 이 연산에 대한 항등원으로 볼 수 있다. <code class=\"language-text\">Either</code>를 덧셈으로, <code class=\"language-text\">Void</code>를 0이라고 생각해보자. 실제로 <code class=\"language-text\">Void</code>를 합 타입에 추가하더라도 해당 타입의 내용은 변하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token constant\">Void</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 정의는 <code class=\"language-text\">a</code>와 동형(Isomorphic)이다. 그 이유는 <code class=\"language-text\">Void</code>는 아무런 값도 가질 수 없는 타입이기 때문에 이 합 타입에서 <code class=\"language-text\">Right</code> 생성자 부분을 채워넣을 방법이 없기 때문이다. <code class=\"language-text\">Either a Void</code> 타입을 가질 수 있는 유일한 값은 <code class=\"language-text\">Left</code> 생성자를 사용하여 생성되기 때문에 결과적으로는 그저 타입 <code class=\"language-text\">a</code>의 값을 캡슐화하는 역할만 하게 될 것이다. 따라서 형식적으로 <code class=\"language-text\">a + 0 = a</code>와 같은 관점이 성립한다.</p>\n<p>이처럼 Haskell에서는 합 타입이라는 개념이 일상적으로 사용되지만, C++의 합 타입이라고 할 수 있는 <code class=\"language-text\">union</code>이나 <code class=\"language-text\">variants</code>은 Haskell처럼 일상적으로 사용되지는 않는다.</p>\n<p>이에는 여러 이유가 있다. 일단 C++에서 간단한 합 타입은 굳이 <code class=\"language-text\">union</code>을 사용하지 않더라도 <code class=\"language-text\">enum</code> 키워드를 사용하여 선언하는 열거형(Enumerations)으로 표현할 수 있다.</p>\n<p>Haskell에서 합 타입을 표현하는 방법을 다시 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Color</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Red</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Green</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Blue</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 합 타입을 C++에서 다시 표현해보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">enum</span> <span class=\"token punctuation\">{</span> Red<span class=\"token punctuation\">,</span> Green<span class=\"token punctuation\">,</span> Blue <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>마찬가지로 Haskell에서는 간단한 합 타입 중 하나인 <code class=\"language-text\">Bool</code>을 아래와 같이 합 타입임을 명시하여 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Bool</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span> <span class=\"token operator\">|</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>하지만 C++에서 이러한 합 타입은 그저 원시 자료형인 <code class=\"language-text\">bool</code>일 뿐이다.</p>\n<p>C++에서 값의 존재나 부재를 인코딩하는 간단한 합 타입은 여러가지 트릭과 빈 문자열, 음수, Null 포인터와 같이 “불가능한” 값들을 사용하여 다양하게 구현되고 있다. 이렇게 선택적으로 값이 존재할 수 있는 경우 Haskell에서는 <code class=\"language-text\">Maybe</code> 타입을 사용하여 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Maybe</code> 타입은 두 타입의 합 타입으로 구성되어있다. Maybe 타입을 구성하는 두 생성자를 각각의 개별적인 타입으로 분리하면 아래와 같이 보일 것이다. 먼저 첫 번째 생성자를 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">NothingType</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 타입은 값이 단 하나뿐인 열거형(Enumeration)이며, <code class=\"language-text\">Nothing</code>이라는 하나의 값만 가지고 있다. 다시 말해 이 타입은 싱글톤, 즉 단일 원소 집합이며 이는 유닛 타입인 <code class=\"language-text\">()</code>와 동등하다.</p>\n<p>이제 두 번째 생성자도 한번 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">JustType</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사실 위 타입은 그저 타입 <code class=\"language-text\">a</code>를 캡슐화한 것에 불과하다. 결과적으로 우리는 <code class=\"language-text\">Maybe</code> 타입을 다음과 같이 표현할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>C++에서 이보다 더 복잡한 합 타입을 표현하고 싶을 때는 포인터를 사용하여 일종의 모방을 한다. 포인터는 <code class=\"language-text\">null</code>이거나 특정 타입인 값을 가리킬 수 있다. 예를 들어 Haskell의 <code class=\"language-text\">List</code> 타입은 재귀적인 합 타입으로 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Cons</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>C++에서 이 표현을 모방하려면 Null 포인터 트릭을 사용하여 빈 리스트를 구현하는 방법으로 시도해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">List</span> <span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> _head<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">List</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_head</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// Nil</span>\n    <span class=\"token function\">List</span><span class=\"token punctuation\">(</span>A a<span class=\"token punctuation\">,</span> List<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> l<span class=\"token punctuation\">)</span>       <span class=\"token comment\">// Cons</span>\n      <span class=\"token operator\">:</span> <span class=\"token function\">_head</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token generic-function\"><span class=\"token function\">Node</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 개의 Haskell 생성자인 <code class=\"language-text\">Nil</code>과 <code class=\"language-text\">Cons</code>는 오버로딩된 두 개의 <code class=\"language-text\">List</code> 생성자로 번역된다. <code class=\"language-text\">List</code> 클래스는 합 타입의 두 구성 요소를 구별하는데 별도의 태그가 필요하지는 않지만, 리스트의 헤드를 의미하는 <code class=\"language-text\">_head</code>를 <code class=\"language-text\">nullptr</code>로 초기화함으로써 <code class=\"language-text\">Nil</code> 생성자를 표현하고 있다.</p>\n<p>Haskell과 C++ 타입 간의 주요한 차이는 Haskell의 데이터 구조가 불변(Immutable)하다는 점에서 발생한다. 특정한 생성자를 사용하여 객체를 생성하면 해당 객체는 자신을 생성할 때 어떤 생성자가 사용되었는지, 그리고 어떤 인수가 전달되었는지 영원히 기억하고 있다. 따라서 <code class=\"language-text\">Just \"energy\"</code>로 생성된 <code class=\"language-text\">Maybe</code> 객체는 절대 <code class=\"language-text\">Nothing</code>으로 변하지 않는다는 것이다. 마찬가지로 빈 리스트는 영원히 빈 상태로 유지되며, 세 개의 원소를 가진 리스트는 영원히 동일한 세 개의 원소를 가진다.</p>\n<p>이러한 불변성은 구성 자체를 뒤집을 수 있도록 만들어주기도 한다. 주어진 객체를 항상 해당 구성에 사용된 부분으로 분해할 수 있다는 뜻이다. 이러한 분해에는 패턴 매칭이 사용되며 주어진 생성자를 패턴으로 다시 사용한다. 생성자에 인자가 주어진 경우 해당 인자는 변수로 대체된다.</p>\n<p><code class=\"language-text\">List</code> 데이터 타입은 두 개의 생성자를 가지고 있기 때문에 <code class=\"language-text\">List</code>를 해체할 때는 해당 생성자들에 각각 대응하는 두 가지 패턴을 사용해야 한다. 하나는 빈 <code class=\"language-text\">Nil</code> 리스트와 매칭될 것이고 다른 하나는 <code class=\"language-text\">Cons</code>로 생성된 리스트와 매칭될 것이다. 아래는 <code class=\"language-text\">List</code>에 대한 간단한 함수의 정의들이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">maybeTail</span> <span class=\"token operator\">::</span> <span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">maybeTail</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token hvariable\">maybeTail</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Cons</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">t</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">maybeTail</code>의 정의의 첫 번째 부분은 <code class=\"language-text\">Nil</code> 생성자를 패턴으로 사용하여 <code class=\"language-text\">Nothing</code>을 반환하고 있다. 두 번째 부분은 <code class=\"language-text\">Cons</code> 생성자를 패턴으로 사용하고 있는데, 생성자에게 주어진 첫 번째 인자는 필요없기 때문에 와일드 카드인 <code class=\"language-text\">_</code>로 대체하고 있다. 생성자에게 주어진 두 번째 인자는 변수 <code class=\"language-text\">t</code>에 바인딩되며 최종 반환 값은 <code class=\"language-text\">Just t</code>이다. 이제 <code class=\"language-text\">List</code>가 어떻게 생성되었느냐에 따라 두 정의 중 하나와 패턴 매칭이 될 것이다. 만약 <code class=\"language-text\">Cons</code>를 사용하여 생성되었다면 생성자에 전달된 두 인자 중 두 번째인자가 검색될 것이고 이후 <code class=\"language-text\">Just t</code>의 형태로 반환될 것이다.</p>\n<p>C++에서 이보다 더 복잡한 합 타입은 다형적인 클래스 계층을 사용하여 구현한다. 공통 조상을 가진 클래스 패밀리는 숨겨진 태그로 이해될 수 있으며, Haskell에서 생성자에 대한 패턴 매칭을 통해 수행되는 작업은 C++의 vtable 포인터를 기반으로 가상 함수 호출을 디스패치함으로써 수행된다.</p>\n<p>사실 C++에서는 합 타입을 온전하게 구현하기 어려운 여러가지 제약 때문에 <code class=\"language-text\">union</code>이 많이 사용되지는 않는다. 심지어 <code class=\"language-text\">string::std</code>이 복사 생성자(Copy Constructor)를 가지고 있기 때문에 <code class=\"language-text\">std::string</code>를 <code class=\"language-text\">union</code>에 넣을 수 조차 없다.</p>\n<h2 id=\"64-타입의-대수학\" style=\"position:relative;\">6.4 타입의 대수학<a href=\"#64-%ED%83%80%EC%9E%85%EC%9D%98-%EB%8C%80%EC%88%98%ED%95%99\" aria-label=\"64 타입의 대수학 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>곱 타입과 합 타입 모두 각각 데이터 구조를 정의할 때 유용하게 사용할 수 있지만, 실질적인 강점은 이 둘을 결합할 때 나타난다. 여기서 다시 한번 우리는 합성의 힘을 느끼게된다.</p>\n<p>먼저 우리가 지금까지 발견한 내용을 요약해보도록 하자. 타입 시스템의 기초에는 교환 법칙을 만족하는 두 가지 모노이달(Monoidal) 구조가 있다. 바로 <code class=\"language-text\">Void</code>를 항등원으로 가지는 합 타입과 유닛 타입인 <code class=\"language-text\">()</code>을 항등원으로 가지는 곱 타입이다. 우리는 이 개념들을 덧셈과 곱셉에 비유해서 생각해보려고 한다. 이 비유에서 <code class=\"language-text\">Void</code>는 덧셈의 항등원인 0, 그리고 <code class=\"language-text\">()</code>는 곱셈의 항등원인 1에 해당할 것이다.</p>\n<p>이 비유를 한번 어디까지 확장해서 적용할 수 있는지 보도록 하자. 우리는 이미 어떤 수에 0을 곱하게 되면 0이라는 결과를 얻는다는 사실을 알고 있다. 그렇다면 곱 타입인 쌍의 한 요소가 <code class=\"language-text\">Void</code>라면 이 타입은 Void와 동형일까? 예를 들면 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Void</code>를 구성요소로 가진 쌍을 만드는 것이 가능하냐는 것이다.</p>\n<p>쌍이라는 타입을 가진 값을 생성하기 위해서는 쌍의 구성 요소가 될 두 개의 값이 필요하다. 문제는 정수는 쉽게 만들 수 있지만 문제는 <code class=\"language-text\">Void</code> 타입의 값이 존재하지 않는다는 것이다. 따라서 모든 타입 <code class=\"language-text\">a</code>에 대해 타입 <code class=\"language-text\">(a, Void)</code>는 값을 가질 수 없는 타입(Uninhabited Type)이며, 결과적으로 <code class=\"language-text\">Void</code>와 동등하다. 다시 말해 <code class=\"language-text\">a*0 = 0</code>인 것이다.</p>\n<p>덧셈과 곱셈을 연결하는 또 다른 속성은 분배 법칙이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>곱셈과 덧셈의 분배 법칙이라는 속성은 일반적으로 곱 타입과 합 타입에도 적용될 수 있다. 위 식의 좌변은 아래와 같은 타입에 해당한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 우변은 아래와 같은 타입에 해당한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>좌변과 우변에 해당하는 타입들은 아래와 같은 방법을 통해 상호 변환될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">prodToSum</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">prodToSum</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">case</span> <span class=\"token hvariable\">e</span> <span class=\"token keyword\">of</span>\n      <span class=\"token constant\">Left</span>  <span class=\"token hvariable\">y</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Left</span>  <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>\n      <span class=\"token constant\">Right</span> <span class=\"token hvariable\">z</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한 위 함수의 역함수도 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">sumToProd</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">sumToProd</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">case</span> <span class=\"token hvariable\">e</span> <span class=\"token keyword\">of</span>\n      <span class=\"token constant\">Left</span>  <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Left</span>  <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>\n      <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Right</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">case of</code> 문은 함수 내에서 패턴 매칭에 사용된다. 주어진 변수가 화살표 왼쪽의 패턴과 일치한다면 화살표 오른쪽의 표현식이 실행되는 것이다. 예를 들어 <code class=\"language-text\">prodToSum</code> 함수를 호출해보는 상황을 한번 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">prod1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Float</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">prod1</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Left</span> <span class=\"token string\">\"Hi!\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">case e</code> 구문의 <code class=\"language-text\">e</code>는 <code class=\"language-text\">Left \"Hi!\"</code>에 해당한다. 이는 <code class=\"language-text\">Left y</code>라는 패턴과 일치하기 때문에 <code class=\"language-text\">y</code>는 <code class=\"language-text\">“Hi!”</code>라는 값으로 대체된다. 이 경우 <code class=\"language-text\">x</code>는 <code class=\"language-text\">2</code>에 매칭될 것이기 때문에 <code class=\"language-text\">case</code> 문을 사용한 전체 함수의 결과는 <code class=\"language-text\">Left(2, \"Hi!\")</code>가 되는 것이다.</p>\n<p>여기서 굳이 이 두 함수가 서로의 역함수임을 증명할 생각은 없지만, 가만 생각해보면 이 두 함수는 서로의 역함수여야하는 것이 당연하다. 왜냐하면 이 두 함수는 그저 자신이 받은 두 데이터 구조의 내용을 간단하게 재포장하는 것에 불과하기 때문이다. 즉, 데이터는 동일하지만 표현 방식이 다른 것 뿐이다.</p>\n<p>수학자들은 이처럼 얽혀있는 두 개의 모노이드에 대해 반환(Semiring)이라는 이름을 붙혔다. 이것은 이 경우 타입 간의 뺄셈에 대해서는 정의할 수 없기 때문에 완전한 “환(Ring)”이라고 말할 수는 없는 것이다.</p>\n<p>반환(Semiring)은 환(Ring)에서 음의 요소(<strong>N</strong>egative) n이 빠진 것이므로, 말장난처럼 “Rig”라고 부르기도 한다.</p>\n<p>하지만 음의 요소가 빠진 반환만으로도 자연수의 관한 명제를 타입에 관한 명제로 번역하여 많은 이점을 얻을 수 있다. 여기 몇 가지 흥미로운 항목들을 담은 번역 표가 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Numbers</th>\n<th>Types</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">0</code></td>\n<td><code class=\"language-text\">Void</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">1</code></td>\n<td><code class=\"language-text\">()</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">a+b</code></td>\n<td>`Either a b = Left a</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">a*b</code></td>\n<td><code class=\"language-text\">(a, b)</code> or <code class=\"language-text\">Pair a b = Pair a b</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">2=1+1</code></td>\n<td>`data Bool = True</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">1+a</code></td>\n<td>`data Maybe = Nothing</td>\n</tr>\n</tbody>\n</table>\n<p>리스트 타입은 특히 더 흥미로운데, 이 타입은 방정식의 해로 정의되기 때문이다. 우리가 정의하려는 타입은 일종의 방정식이며 아래와 같이 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Cons</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 방정식의 <code class=\"language-text\">List a</code>를 <code class=\"language-text\">x</code>로 치환해서 이 식을 일반화하면 아래와 같은 방정식을 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>하지만 타입의 세계에는 뺄셈이나 나눗셈이 없으니 우리는 이 문제를 전통적인 대수적 방법론으로는 해결할 수 없다. 하지만 이 식에 표현되어있는 녀석들을 치환하는 것 정도는 할 수 있다. 우변에 있는 <code class=\"language-text\">x</code>를 <code class=\"language-text\">(1 + a * x)</code>로 계속 해서 치환하고 분배 법칙을 사용해보자. 그러면 이제 이러한 식으로 이어질 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span>\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span>\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">...</span>\n\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">...</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>결국 이 식은 무한한 곱(튜플)의 합으로 끝나게 되는데, 이것은 리스트가 빈 경우 <code class=\"language-text\">1</code>, 단일 값인 경우 <code class=\"language-text\">a</code>, 쌍인 경우는 <code class=\"language-text\">a*a</code>, 트리플인 경우 <code class=\"language-text\">a*a*a</code>처럼 무한히 나아갈 것이라고 해석할 수 있다. 이게 결국 리스트의 정의 그 자체이다.</p>\n<p>이외에도 리스트에 대한 더 많은 내용들이 있지만, 다른 내용들에 대해서는 추후 펑터(Functor)와 고정점(Fixed Point)에 대해서 배운 후에 리스트와 같은 기타 재귀적인 데이터 구조에 대해서 다시 다룰 때 이야기를 해볼 것이다.</p>\n<p>결국 이처럼 기호로 표현되는 변수를 사용하여 어떠한 방정식을 해결하는 것이 바로 대수(Algebra)이며, 대수학으로 표현할 수 있는 타입에 이름을 붙힌 것이 대수적 데이터 타입(Algebraic Data Type)이다.</p>\n<p>마지막으로 타입의 대수에 대한 아주 중요한 해석 중 하나를 이야기하려고 한다. 두 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 곱 타입에는 <code class=\"language-text\">a</code> 타입의 값과 <code class=\"language-text\">b</code> 타입의 값이 모두 포함되어야 하지만, 두 타입의 합 타입에는 <code class=\"language-text\">a</code> 타입이나 <code class=\"language-text\">b</code> 타입의 값이 둘 중 하나라도 포함되어 있으면 충분하다. 이는 논리식인 AND와 OR도 반환(Semiring)을 형성한다는 것을 의미하며, 결국 논리식 또한 타입 이론으로 매핑될 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Logic</th>\n<th>Types</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">Void</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">()</code></td>\n</tr>\n<tr>\n<td>`a</td>\n<td>b`</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">a &amp;&amp; b</code></td>\n<td><code class=\"language-text\">(a, b)</code></td>\n</tr>\n</tbody>\n</table>\n<p>논리식과 타입 이론 간의 유사성은 이외에도 더 깊게 이어질 수 있으며, 커리-하워드 동형성(Curry-Howard Isomorphism)의 기초라고 할 수 있다. 이 내용에 대해서는 추후 함수 타입에 대해 이야기할 때 다시 살펴보도록 하겠다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240305-category-theory-for-programmers-6-simple-algebraic-data-types","path":"/2024/03/05/category-theory-for-programmers-6-simple-algebraic-data-types/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 6. 단순한 대수적 타입","subTitle":null,"date":"Mar 05, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}},"allMarkdownRemark":{"edges":[]}},"pageContext":{"slug":"20240305-category-theory-for-programmers-6-simple-algebraic-data-types","previous":{"fields":{"slug":"20240227-category-theory-for-programmers-5-products-and-coproducts","path":"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts/","lang":"ko","postGroup":"20240227-category-theory-for-programmers-5-products-and-coproducts"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 5. 곱과 합"}},"next":{"fields":{"slug":"20240315-category-theory-for-programmers-7-functors","path":"/2024/03/15/category-theory-for-programmers-7-functors/","lang":"ko","postGroup":"20240315-category-theory-for-programmers-7-functors"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 7. 펑터"}},"lang":"ko","postGroup":"20240305-category-theory-for-programmers-6-simple-algebraic-data-types"}},"staticQueryHashes":["3129619726","3523904809","376081736","650499039"],"slicesMap":{}}