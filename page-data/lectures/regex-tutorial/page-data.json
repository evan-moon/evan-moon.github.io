{"componentChunkName":"component---src-templates-lecture-page-template-tsx","path":"/lectures/regex-tutorial/","result":{"data":{"markdownRemark":{"id":"3cba8ba7-097e-598d-969c-732ce2a7b3b1","excerpt":"💡 이 강의는 인프런에 있는 “가제” 강의의 참고자료입니다 정규식은 “정규 표현식”의 줄임말로, 임의의 문자열 내에서 원하는 패턴의 문자열을 검색하거나 치환할 때 사용하는 형식 언어입니다. 영어로는 Regular Expression이라고 하기 때문에…","html":"<blockquote>\n<p>💡 이 강의는 인프런에 있는 “가제” 강의의 참고자료입니다</p>\n</blockquote>\n<p>정규식은 “정규 표현식”의 줄임말로, 임의의 문자열 내에서 원하는 패턴의 문자열을 검색하거나 치환할 때 사용하는 형식 언어입니다. 영어로는 Regular Expression이라고 하기 때문에 여러 프로그래밍 언어들에서는 보통 정규식을 <code class=\"language-text\">regex</code> 또는 <code class=\"language-text\">regexp</code> 라는 줄임말로 호칭합니다.</p>\n<p>그래서 정규식은 보통 사용자가 입력한 문자열이 이메일 주소가 맞는지와 같이 사용자 입력을 검증하거나, 불특정한 문자열 속에서 내가 원하는 문자열을 찾아내는 상황에서 굉장히 많이 쓰이고 있습니다.</p>\n<p>이처럼 정규식은 실무에서 접하는 빈도는 높은 반면, 제대로 정규식을 알고 사용하는 사람들은 많지 않은데요. 왜냐하면 정규식의 문법 자체가 사람이 읽기 상당히 어렵기도 하고, 대부분 이메일, 웹 링크와 같이 보편적인 정보들을 검증하는 데에 쓰이기 때문에 인터넷에서 해당 정보를 검증할 수 있는 정규식을 복사/붙여넣기 하는 것만으로도 문제를 해결할 수는 있기 때문입니다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/06d8206a5c2d81fb57eadd887a65c938/29d31/regex.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 84.375%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQDAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABkn5SRrx52hGQr//EABwQAAIDAAMBAAAAAAAAAAAAAAACAQMRExQxMv/aAAgBAQABBQLYc2NtaGs53kR1Oyiike2/f//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EAB4QAAIBAwUAAAAAAAAAAAAAAAABEQIDMRIgQmGS/9oACAEBAAY/AlqwT2NrBx8lLgh2adn/xAAdEAACAgMAAwAAAAAAAAAAAAABEQAhMVGBEHGx/9oACAEBAAE/IbYwruNK3EejowoQMcBGyiWSxyC7BG1MR78Hwn//2gAMAwEAAgADAAAAEJMoQP/EABYRAAMAAAAAAAAAAAAAAAAAAAEgIf/aAAgBAwEBPxARP//EABYRAQEBAAAAAAAAAAAAAAAAAAEQMf/aAAgBAgEBPxBI7P/EACAQAQACAgEEAwAAAAAAAAAAAAEAESExQRBRYaFxkbH/2gAIAQEAAT8QMiPTmh353KnsFnVrwTiBTIfUaDWlYf4QT4BSUOFpWpYJGrFn1PadHd8J/9k=&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"regex\" title=\"regex\" src=\"/static/06d8206a5c2d81fb57eadd887a65c938/c08c5/regex.jpg\" srcset=\"/static/06d8206a5c2d81fb57eadd887a65c938/0913d/regex.jpg 160w,\n/static/06d8206a5c2d81fb57eadd887a65c938/cb69c/regex.jpg 320w,\n/static/06d8206a5c2d81fb57eadd887a65c938/c08c5/regex.jpg 640w,\n/static/06d8206a5c2d81fb57eadd887a65c938/29d31/regex.jpg 700w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  <small>&#xBB54;&#xAC00; &#xACF5;&#xD3EC;&#xC758; &#xB300;&#xC0C1;&#xC774; &#xB418;&#xC5B4;&#xBC84;&#xB9B0; &#xC815;&#xADDC;&#xC2DD;...</small>\n</center>\n<p>하지만 이렇게 때로는 이렇게 간단한 정보들의 패턴을 찾아내는 것이 아니라 조금 더 복잡한 패턴을 찾아내야 하는 경우도 있습니다. 만약 여러분이 사용자가 입력한 비밀번호가 우리 회사의 정책에 맞는 비밀번호인지 검증하려면 어떻게 해야할까요?</p>\n<p>물론 비밀번호 정책도 “무조건 영어 소문자나 대문자, 그리고 숫자가 한 개 이상 포함되어야 한다”, “무조건 8자리 이상의 비밀번호를 만들어야 한다”와 같이 어느 정도 보편화된 규칙은 있습니다. 하지만 디테일한 비밀번호 정책은 회사가 어느 정도의 보안 레벨을 가져가고 싶냐에 따라 다를 수 있기 때문에 인터넷에서 복사/붙여넣기 하는 것만으로는 문제를 해결하기가 어려울 수도 있습니다.</p>\n<blockquote>\n<ul>\n<li>반드시 소문자, 대문자, 숫자, 특수 문자가 하나씩 포함되어야한다.</li>\n<li>같은 문자가 3번 이상 반복되면 안된다.</li>\n<li>8글자 이상이어야 한다.</li>\n</ul>\n</blockquote>\n<p>는 아래와 같은 정규식으로 표현됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"regex\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-regex line-numbers\"><code class=\"language-regex\"><span class=\"token group\">(?=</span><span class=\"token charclass\">.</span><span class=\"token quantifier\">*</span><span class=\"token charclass\">\\d</span><span class=\"token group\">)</span><span class=\"token group\">(?=</span><span class=\"token charclass\">.</span><span class=\"token quantifier\">*</span><span class=\"token charset\"><span class=\"token charset-punctuation\">[</span><span class=\"token range\">a<span class=\"token range-punctuation\">-</span>z</span><span class=\"token charset-punctuation\">]</span></span><span class=\"token group\">)</span><span class=\"token group\">(?=</span><span class=\"token charclass\">.</span><span class=\"token quantifier\">*</span><span class=\"token charset\"><span class=\"token charset-punctuation\">[</span><span class=\"token range\">A<span class=\"token range-punctuation\">-</span>Z</span><span class=\"token charset-punctuation\">]</span></span><span class=\"token group\">)</span><span class=\"token group\">(?=</span><span class=\"token charclass\">.</span><span class=\"token quantifier\">*</span><span class=\"token charset\"><span class=\"token charset-punctuation\">[</span><span class=\"token charclass\">\\W</span><span class=\"token charset-punctuation\">]</span></span><span class=\"token group\">)</span><span class=\"token group\">(?!</span><span class=\"token charclass\">.</span><span class=\"token quantifier\">*</span><span class=\"token group\">(</span><span class=\"token charclass\">.</span><span class=\"token group\">)</span><span class=\"token backreference\">\\1</span><span class=\"token quantifier\">{2}</span><span class=\"token group\">)</span><span class=\"token charclass\">.</span><span class=\"token quantifier\">{8,}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이렇게 보편적인 정보가 아니라 상황에 따라 달라지는 문자열의 패턴을 정규식으로 잡아내야 하는 경우는 생각보다 드물지 않습니다.</p>\n<p>게다가 정규식은 단순히 문자열을 검증하는 것 뿐만 아니라, String 객체의 <code class=\"language-text\">replace</code> 메소드와 조합하여 정규식을 통해 문자열 내에서 검색된 패턴을 내가 원하는 패턴으로 자유롭게 치환할 수도 있으며, 어떤 부분은 치환하고 어떤 부분은 남겨놓을 지 선택할 수도 있는 고급진 기능 또한 제공합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'이 사과의 가격은 $1,000입니다'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token language-regex\"><span class=\"token anchor\">^</span><span class=\"token group\">(</span><span class=\"token charclass\">.</span><span class=\"token quantifier\">*</span><span class=\"token group\">)</span><span class=\"token special-escape escape\">\\$</span><span class=\"token group\">(</span><span class=\"token charset\"><span class=\"token charset-punctuation\">[</span><span class=\"token charclass\">\\d</span>,<span class=\"token charset-punctuation\">]</span></span><span class=\"token quantifier\">+</span><span class=\"token group\">)</span><span class=\"token group\">(</span><span class=\"token charclass\">.</span><span class=\"token quantifier\">*</span><span class=\"token group\">)</span></span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'$1$2원 $3'</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">이 사과의 가격은 1,000원 입니다</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>물론 이런 정규식의 기능들을 프로그래밍 언어로 동일하게 구현할 수는 있습니다. 하지만 방금 예시로 들었던 간단한 문제들을 만약 프로그래밍 언어로 해결하려면 굉장히 많은 조건문들이 필요할 뿐더러, 때로는 불필요하게 문자열을 여러 번 순회해야하는 경우도 있습니다.</p>\n<p>게다가 정규식 한 줄로 처리할 수 있는 문제임에도 불구하고 거대한 코드를 작성해야하는 경우도 발생하기 때문에 생산성에서 큰 손해를 볼 수도 있습니다.</p>\n<p>정규식이 가지는 이런 장점들에도 불구하고 정규식은 우리가 일상 속에서 사용하는 자연어와는 거리가 멀기 때문에, 프로그래밍 언어와 다르게 정규식을 잘 아는 사람이라고 해도 한 눈에 정규식이 작동하는 방식을 파악하기는 쉽지 않습니다.</p>\n<p>하지만 그렇다고 지레 겁먹을 필요는 없습니다. 정규식도 결국은 어떠한 패턴을 표현하기 위한 방법이기 때문에 다른 프로그래밍 언어들과 마찬가지로 일정한 규칙을 가지고 있습니다.</p>\n<p>그럼 지금부터 저 복잡한 기호들이 어떤 의미를 가지고 있는 것인지 하나씩 살펴보고 나의 생산성을 2배, 3배로 키울 수 있는 엔지니어가 되어봅시다.</p>","tableOfContents":"","fields":{"slug":"lecture.regex-tutorial","lecture":"regex-tutorial","category":"lecture"},"frontmatter":{"title":"정규식 강의 소개"}}},"pageContext":{"slug":"lecture.regex-tutorial","previous":{"fields":{"slug":"lecture.regex-tutorial.section1.2","path":"/lectures/regex-tutorial/section1/2/"}},"next":null}}}