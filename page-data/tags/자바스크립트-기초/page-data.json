{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/자바스크립트-기초/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"a9680e03-58e1-5f68-82fa-94e0e953b3fa","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C%EB%8A%94-%EC%9B%90%EB%B3%B8-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%ED%86%B5%ED%95%B4-%EA%B3%B5%EC%9C%A0%EB%90%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\">프로퍼티와 메소드는 원본 객체를 통해 공유될 수 있다</a></p>\n<ul>\n<li><a href=\"#%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98-%EB%82%B4%EC%97%90%EC%84%9C-this%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\">생성자 함수 내에서 this를 사용하는 방법</a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4%EC%97%90-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\">프로토타입 객체에 정의하는 방법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A3%A9%EC%97%85\">프로토타입 룩업</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%83%81%EC%86%8D\">프로토타입을 사용한 상속</a></p>\n<ul>\n<li><a href=\"#objectcreate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90\">Object.create를 사용하자</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 이전 포스팅에 이어, 프로토타입을 사용한 다양한 상속 패턴에 대한 이야기를 해볼까 한다. 사실 자바스크립트에는 상속이나 캡슐화와 같은 개념이 명시적으로 존재하지는 않기 때문에 자바나 C++ 같은 클래스 기반 언어를 사용하던 개발자들은 자바스크립트에 클래스가 없다는 사실에 혼란스러워한다.","html":"<p>이번 포스팅에서는 <a href=\"/2019/10/23/js-prototype/\">이전 포스팅</a>에 이어, 프로토타입을 사용한 다양한 상속 패턴에 대한 이야기를 해볼까 한다.</p>\n<p>사실 자바스크립트에는 상속이나 캡슐화와 같은 개념이 명시적으로 존재하지는 않기 때문에 자바나 C++ 같은 클래스 기반 언어를 사용하던 개발자들은 자바스크립트에 클래스가 없다는 사실에 혼란스러워한다.</p>\n<!-- more -->\n<p>즉, 자바스크립트에서의 상속이나 캡슐화 등은 OOP(객체지향프로그래밍)에 익숙한 개발자들이 자바스크립트에서도 이런 개념들을 가져다 사용하기 위해 프토토타입을 사용하여 이를 유사하게 구현한 일종의 디자인 패턴이라고 할 수 있다.</p>\n<p>자바스크립트에서의 상속은 프로토타입 체인을 사용하여 구현하고, 캡슐화는 클로저를 사용해서 구현하게 되는데, 이번 포스팅에서는 이 중 프로토타입을 사용한 상속 패턴에 집중해서 설명해볼까 한다.</p>\n<h2 id=\"프로퍼티와-메소드는-원본-객체를-통해-공유될-수-있다\" style=\"position:relative;\">프로퍼티와 메소드는 원본 객체를 통해 공유될 수 있다<a href=\"#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EB%A9%94%EC%86%8C%EB%93%9C%EB%8A%94-%EC%9B%90%EB%B3%B8-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%ED%86%B5%ED%95%B4-%EA%B3%B5%EC%9C%A0%EB%90%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\" aria-label=\"프로퍼티와 메소드는 원본 객체를 통해 공유될 수 있다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>객체의 상속을 알아보기 전에 객체를 생성할 때 프로퍼티와 메소드를 부여하는 방법에 대해서 알아보도록 하자. <a href=\"/2019/10/23/js-prototype/\">이전 포스팅</a>에서 필자는 자바스크립트는 클래스가 아닌 함수를 사용하여 객체를 생성한다고 이야기 했었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">User</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 <code class=\"language-text\">User</code> 함수를 생성자로 호출하면서 생성된 <code class=\"language-text\">evan</code> 객체는 <code class=\"language-text\">User.prototype</code> 객체를 원본 객체로 하여 복제된 객체이다.</p>\n<p>이때 두 가지 방법을 사용하여 새롭게 생성되는 객체들에게 프로퍼티나 메소드를 부여할 수 있는데, 첫 번째는 생성자 함수 내에서 <code class=\"language-text\">this</code>를 사용하여 선언하는 방법, 두 번째는 새롭게 생성되는 객체들이 복사할 원본 객체인 프로토타입 객체에 선언하는 방법이다.</p>\n<p>먼저, <code class=\"language-text\">this</code>를 사용하여 프로퍼티나 메소드를 정의하는 방법에 대해서 살펴보자.</p>\n<h3 id=\"생성자-함수-내에서-this를-사용하는-방법\" style=\"position:relative;\">생성자 함수 내에서 this를 사용하는 방법<a href=\"#%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98-%EB%82%B4%EC%97%90%EC%84%9C-this%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"생성자 함수 내에서 this를 사용하는 방법 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>자바스크립트도 생성자 역할을 하는 함수 내에서 <code class=\"language-text\">this</code>를 사용하여 다른 언어와 비슷한 느낌으로 객체들에게 프로퍼티나 메소드를 부여할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">User</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function-variable function\">say</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello, World!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span><span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Hello, World!</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>참고로 생성자 함수 내에서 <code class=\"language-text\">strict</code> 모드를 사용한 이유는, 해당 생성자 함수가 실수로 <code class=\"language-text\">new</code> 예약어 없이 호출되어 <code class=\"language-text\">this</code>가 전역 객체로 평가되는 불상사를 방어하기 위해서이다. <small>(이 내용은 프로토타입과는 관련이 없기 때문에 자세히 다루지는 않겠다)</small></p>\n<p>이 방법은 일반적인 생성자의 사용 방법과 비슷해서 직관적으로 이해가 되는 편이다. 이때 생성자 함수 안의 <code class=\"language-text\">this</code>는 새롭게 생성된 객체를 의미하기 때문에, 함수 내에서 <code class=\"language-text\">this</code>를 통해 정의한 프로퍼티나 메소드는 이 생성자 함수를 사용하여 객체가 생성될 때마다 새롭게 정의된다.</p>\n<p>무슨 말인지 조금 더 쉽게 알아보기 위해 생성자 함수를 통해 두 개의 새로운 객체를 생성하고, 이 객체들의 메소드를 비교해도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> john <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>say <span class=\"token operator\">===</span> john<span class=\"token punctuation\">.</span>say<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>생성자 함수가 호출될 때 <code class=\"language-text\">this</code>는 각각 <code class=\"language-text\">evan</code> 객체와 <code class=\"language-text\">john</code> 객체를 의미했을 것이고, <code class=\"language-text\">say</code> 메소드 또한 이 객체들에게 직접 할당되었을 것이다. 자바스크립트의 완전항등연산자(<code class=\"language-text\">===</code>)는 다른 메모리에 적재된 객체는 다르다고 평가하므로 이 두 객체의 메소드들은 각자 다른 메모리에 담긴, 전혀 다른 함수라고 할 수 있다.</p>\n<p>이때 <code class=\"language-text\">evan</code> 객체나 <code class=\"language-text\">john</code> 객체를 출력해보면, 객체 내부에 <code class=\"language-text\">say</code> 메소드가 정의되어 있는 모습 또한 확인해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">User <span class=\"token punctuation\">{</span><span class=\"token function-variable function\">say</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>필자가 이와 같은 당연한 이야기를 강조하는 이유는 바로 밑에서 후술할 프로토타입 객체에 정의하는 방법과의 차이점을 분명히 하기 위해서이다. 프로토타입 객체를 사용해서 프로퍼티나 메소드를 정의하게되면 지금과는 전혀 다른 결과가 나온다.</p>\n<h3 id=\"프로토타입-객체에-정의하는-방법\" style=\"position:relative;\">프로토타입 객체에 정의하는 방법<a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4%EC%97%90-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"프로토타입 객체에 정의하는 방법 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이번에는 <code class=\"language-text\">User</code> 생성자 함수의 프로토타입 객체인 <code class=\"language-text\">User.prototype</code>을 사용하여 메소드를 한번 정의해보도록 하자. <code class=\"language-text\">this</code>를 통해서 정의하는 방법과 어떤 차이가 있을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">User</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">say</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello, World!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span><span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Hello, World!</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>일단 <code class=\"language-text\">this</code>를 사용하여 정의했던 메소드와 동일한 느낌으로 작동하고 있다. 그래서 동일한 동작이라고 생각할 수도 있지만, 사실 두 방법들 사이에는 중요한 차이가 존재한다.</p>\n<p>바로 생성자 함수를 통해 생성된 모든 객체들이 해당 메소드를 “공유하고 있냐, 없냐”의 차이이다. 이전과 마찬가지로 두 개의 객체를 생성하고, 두 객체의 메소드를 비교해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> john <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>say <span class=\"token operator\">===</span> john<span class=\"token punctuation\">.</span>say<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>음? 이번에는 아까와는 다르게 두 객체의 메소드가 같다고 한다. 방금 전과는 다르게 이번에는 <code class=\"language-text\">evan.say</code>와 <code class=\"language-text\">john.say</code>가 객체에 따로따로 정의된 메소드가 아닌, 원본 객체의 메소드를 공유하고 있는 상황이기 때문이다.</p>\n<p>생성된 <code class=\"language-text\">evan</code> 객체를 한번 콘솔에 출력해보면, 원본 객체의 프로퍼티나 메소드를 공유하고 있다는 말이 무엇인지 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">User <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">evan</code> 객체를 출력해보니, 이 객체는 아무 메소드나 프로퍼티도 가지고 있지 않고 텅 비어있는 친구다.</p>\n<p>즉, 생성자 함수 내에서 <code class=\"language-text\">this</code>를 사용하지 않고, 원본 객체에 메소드나 프로퍼티를 정의하게 되면 객체들에게는 해당 프로퍼티가 없고, 원본 객체의 프로퍼티나 메소드를 참조한다는 것이다.</p>\n<p>이 특징을 제대로 인지하지 못하면 이런 상황도 발생할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>john<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Evan\nEvan</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그렇기 때문에 각 객체마다 고유한 프로퍼티를 부여하고 싶다면 원본 객체에 정의하는 것이 아니라, 생성자 함수 내에서 <code class=\"language-text\">this</code>를 사용하여 정의해야한다. 다시 말하지만 <strong>원본 객체에 정의한 프로퍼티나 메소드는 생성된 객체들끼리 공유된다</strong>.</p>\n<p>한 가지 이상한 점은, 분명히 <code class=\"language-text\">evan</code> 객체에는 아무런 프로퍼티나 메소드도 없었는데, 필자는 분명히 <code class=\"language-text\">evan.say</code>를 통해 해당 메소드에 접근할 수 있었다는 것이다. 어떻게 이런 일이 가능한 것일까?</p>\n<h2 id=\"프로토타입-룩업\" style=\"position:relative;\">프로토타입 룩업<a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A3%A9%EC%97%85\" aria-label=\"프로토타입 룩업 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그 질문에 대한 해답은 바로 자바스크립트가 객체 내에서 프로퍼티를 찾는 방법 중 하나인 프로토타입 룩업(Prototype Lookup)에서 알아볼 수 있다. 방금 전 자바스크립트가 <code class=\"language-text\">evan</code> 객체에서 <code class=\"language-text\">say</code> 메소드를 찾아냈던 과정은 다음과 같다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/3caa593b82cbd86bf7af67e4dff11475/a2498/prototype_lookup.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 48.75000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAD2EAAA9hAHVrK90AAABiUlEQVR42pVSu2oCURDdGC0sbVKE4B9YWfkLWiSF+YCkskt62TqQ3xERF0VECxE1yKKID1B84BOX9YFys07mLG5YjJJkYJh7Z86cO/fcK0knRkTXiK1W63G1WlG5XDbS6fShWCwauq4T8nbcr2YBJ5NJeDqdglBUq9XPfD4v5vM5If9fQgdiPB6PYML1em1w7sCOSIlEImLH/YXwioMjFosF2+12NpfLJTkqfN3kYrHIMmEI9SPuLIEzk8mYXiqVXEegm9114Uzk3cABb/WCB346GeJdoVB47nQ6IUsnW83Jj3LPD/TE61t77dvG47Fcr9flRqMhj0ajKPu7oiivtVrtwTrRRujiBwqnUqmXwWDwxr1R9MLB02w2ZYCINSImMEXfbDYfXq/XA50uXNmBOnDAq6pq8NRYEmtMEhfEcDgU2+12jySLXwkEAjd+v/+shsijrmlaZbfbEU+6ZxPcKmazmZD4itTr9Wi5XJoT8l49TvhDH2vv8/k83W5Xxb/kXvPD82DU7/fpC7lobzt/8ly5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prototype lookup\" title=\"\" src=\"/static/3caa593b82cbd86bf7af67e4dff11475/6af66/prototype_lookup.png\" srcset=\"/static/3caa593b82cbd86bf7af67e4dff11475/69538/prototype_lookup.png 160w,\n/static/3caa593b82cbd86bf7af67e4dff11475/72799/prototype_lookup.png 320w,\n/static/3caa593b82cbd86bf7af67e4dff11475/6af66/prototype_lookup.png 640w,\n/static/3caa593b82cbd86bf7af67e4dff11475/d9199/prototype_lookup.png 960w,\n/static/3caa593b82cbd86bf7af67e4dff11475/21b4d/prototype_lookup.png 1280w,\n/static/3caa593b82cbd86bf7af67e4dff11475/a2498/prototype_lookup.png 1764w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<blockquote>\n<ol>\n<li><code class=\"language-text\">evan.say</code>로 접근 시도</li>\n<li>어, <code class=\"language-text\">say</code> 프로퍼티가 없네? <code class=\"language-text\">__proto__</code>를 통해 원본 객체로 올라가보자!</li>\n<li><code class=\"language-text\">User.prototype</code>객체야, 너는 <code class=\"language-text\">say</code> 프로퍼티 가지고 있니?</li>\n<li>있네? Profit!</li>\n</ol>\n</blockquote>\n<p>이런 식으로 우리가 어떤 객체의 프로퍼티에 접근을 시도했을 때, 자바스크립트는 먼저 그 객체가 해당 프로퍼티를 가지고 있는지를 확인하고, 해당 프로퍼티가 없다면 그 객체의 원본 객체로 거슬러 올라가서 다시 확인하게 된다.</p>\n<p>이 집요한 확인 과정은 모든 객체의 조상인 <code class=\"language-text\">Object.prototype</code>에 다다를 때까지 계속되고, 만약 여기에도 존재하지 않는 프로퍼티라면 그때서야 <code class=\"language-text\">undefined</code>를 반환하게 된다.</p>\n<p>이 말인 즉슨, 모든 객체는 자신의 프로토타입 체인 내에 있는 모든 원본 객체들의 프로퍼티나 메소드에 접근할 수 있다는 뜻이다.</p>\n<p>쉽게 말해, 방금 생성한 <code class=\"language-text\">evan</code> 객체는 아무 프로퍼티나 메소드도 가지고 있지 않지만, 자신의 원본 객체인 <code class=\"language-text\">User.prorotype</code>에 정의된 <code class=\"language-text\">say</code> 메소드도 사용할 수 있고, <code class=\"language-text\">Object.prototype</code>에 있는 <code class=\"language-text\">toString</code>이나 <code class=\"language-text\">hasOwnProperty</code>와 같은 메소드도 사용할 수 있다는 것이다.</p>\n<center>\n  <div style=\"width: 200px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7b54dda3a84203718b2412b4631d61b5/31493/prototype_lookup2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 220.00000000000003%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAsCAYAAABloJjNAAAACXBIWXMAAD2EAAA9hAHVrK90AAAGZUlEQVR42q1XW0xUVxQdrNZiqhapoQVKrJ22SGqTxsQ2fjWm6ZdJv0x/TKyNf36ppdGERBIzxqTph4kzVKdm5OEEjU9QER+8BhWfKIiACCKIKDigyEXg3svuWif3TGcQpJie5GSfOffeffbeZ611zrhc/7a41atXx8Mm5OXl7X/y5Im0tbWNoFu6t7S0WPfv37du376txg8ePFDznOvu7rZKSkqsKH+u9xcuXOiG/aGgoKBU0Gw02rGxMRoJh8NSXV0t58+fF8uyRDfnNamrq5Noh/Pi4+OTOdi7d+9PFy9e/PPSpUvbYT26h0Ihz+nTpz3nzp3zXL58OWb+xo0bHmTmccHxTPS4tLS0hAULFqRyvG3btpmu/6HNQ/9I1xOO33mbzgjLsQFlN2/erEIa1b29vZWYK0L/mJ5hZzlZTNnLy8tnuvr6+towaD1x4kR7UVFROxx3YK4GiyQ5DuOmlSfqNYN2z54989evX5/K8aFDhzIbGhpq79y5U3H37t0QIBK6d+9eCIuF+BtQCTU3N0fm6+vr1dzx48dD0b7npqSkKIc1NTU5DlwsQgYvy/Xr1wU4E2QiFRUVUllZqWDS09MTgc9rsElNTU3h4Nq1a16+gNWtjo4OaW1tFYBXEJEA1ILngggFGcjTp09lcHBQOUSkMQ7nADZLYN8DePcTuLm5uVZ2drbs3LlTCgsLBaUQlEaNvV6vAK8SCARky5YtaiEuElPP5cuXEzouANfPFfv7+y1SELQSbJQw2sePH8vz58/l2bNnKt3Ozk559OiRmKYpV69ejXWoth3typUrKuVXr15ZpNXo6CjHimK0TJFzdEI7MjKiUsamTewQlPMyAlgLVJNTp07J0aNHhePi4mJBBlJVVSXHjh1Tz06ePDlhDaMd+rg60rH4AXeY9amtrZWuri4B+AVIULvOkkB1JtzlmAhfvnzJKKzS0lK5deuW0B45ckRFg81S9sKFCzI8PBxRo/EO41asWDEX9gN8nMu6ANwW6Kg+ZJSECSNkLXVn01I23uFc6OFnsD8CCqWMEGnakCeBPElTU5McPnw4kh6d6chi9JCkprf09PTEZcuWpTlM8QEyfGEYhTeRukmLeprt7e0mvjHhRFl2RKgssGjGMCWKej6uCOxR2hX2WPwXL14omIxv4yP8FfX6Bd43oNC/4ffPqF0JHhajZv7Gxsb9SDcAUQhgPoANCgBvMR1qrZ6DSQE6VJAAmFn4MYfsPYZhpDryNWNa8gWofHX27NklAO13Pp9vJRx+AY6uzMrK+mbTpk3pW7duzWCHzGXk5ORk7Nq1S409Hk+GfrZ582Zl161blzFhDcvKyv5gvcDZAZx0BhYxwFcD6RkogYGaGpA0A/VVz8AqA3g0ICoGhXWW3uWlS5d+yTGg4nfqrbhMyLAkyCZCN8KJ2CQuJ9PD2YmJiek86JF+Hl/Ay6MQVBuObOy8Dac2eGzjuQ3w2wC8DaG14ZjbbGPD7DeqDRxa1D5SjWyhWpOCtGfOnFF6uG/fPjXHRk2c0CFW9Wn50mygWJCOLAGppqVMSxh/syyTigOdYGMsKsvAwIByRiHgx7rTGTvn2ahGMeKwatWqObBJ0LwDpB4WsPx+vzqkou84UzFFAXfx4sXz3W43xeH7/Pz8EooD2ggcmyi6iYKbEAkT0UQ4PCWXk5OTP9FcZn3wosXzgsXGCahgwvTH8zkmQrzwIcYJiOBTpPc1xrOBtd/BzSI4yAdPg8BhEA6DOEaD/I35IOoV6ZwD4IPgcpAp9+FHH7a+H4DtwxnMXOvQ3+4q8vDhw79RGz9ok4t+AM79oFjB7t27v127du2izMzMzzdu3OjG2esGh907duxQY935TD9fs2aNe8KbA8RiO+AyDI72oocxDoOzYSweRgZhcDkMHqt5/WxoaCgMIQ4ruGiHSUlJizjAOfKXU2x1WPBI5VWYxySEQ3VuEM9h4nCyQ+pdh8uJoFWe43CU92xstg19tFEanjGKwzhi1TwbnL6Zy/qyxNuXhgbphuuaHDx4UN1tcLZEwD7ZpT0iZZrLuHJYiExxFjWKHJ10rq8kfO6QYHIuA9heJyqlh/yAgkteR99pNJf/092GJx0+sng35L2G1w78bVD3QS0GU/1Pea2GlC9Gxih0vZg6052WQ0Tk5XmM6Pj3K3J7paXyMGr+1p2nJjnP+84/JJLSlavYgYkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prototype lookup2\" title=\"\" src=\"/static/7b54dda3a84203718b2412b4631d61b5/6af66/prototype_lookup2.png\" srcset=\"/static/7b54dda3a84203718b2412b4631d61b5/69538/prototype_lookup2.png 160w,\n/static/7b54dda3a84203718b2412b4631d61b5/72799/prototype_lookup2.png 320w,\n/static/7b54dda3a84203718b2412b4631d61b5/6af66/prototype_lookup2.png 640w,\n/static/7b54dda3a84203718b2412b4631d61b5/31493/prototype_lookup2.png 664w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>evan 객체는 프토토타입 체인 내에 있는 모든 원본 객체의 프로퍼티를 공유받는다</small>\n  <br>\n  <br>\n</center>\n<p>이 프로토타입 룩업 과정은 객체의 프로퍼티나 메소드에 접근하는 그 순간마다 수행되기 때문에, 클래스가 정의될 때 모든 상속관계가 함께 평가되는 클래스 기반 언어의 상속과는 조금 다른 느낌이다.</p>\n<p>그러나 추상적으로 생각해보면 원본 객체(부모)의 속성을 물려받고 있다는 점에서 착안하여, 프로토타입 룩업을 토대로 상속을 구현할 수 있다.</p>\n<h2 id=\"프로토타입을-사용한-상속\" style=\"position:relative;\">프로토타입을 사용한 상속<a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%83%81%EC%86%8D\" aria-label=\"프로토타입을 사용한 상속 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자바스크립트에서 프로토타입을 사용하여 상속을 구현하는 방법은 크게 <code class=\"language-text\">Object.create</code> 메소드를 사용하는 방법과 이 메소드를 사용하지않는 <small>(더러운)</small> 방법, 두 가지로 나누어질 수 있다.</p>\n<p>사실 <code class=\"language-text\">Object.create</code>만 사용해도 프로토타입을 사용한 상속은 충분히 구현이 가능하다. 하지만 굳이 두 가지를 나눠서 이야기한 이유는, <code class=\"language-text\">Object.create</code> 메소드가 Internet Explorer 9부터 지원이 되기 때문이다.</p>\n<p>하지만 필자의 행복을 위해 쓰는 포스팅에서 IE 8 이하 환경에 대한 자세한 이야기는 별로 하고 싶지 않으므로 <code class=\"language-text\">Object.create</code>를 사용하지 않는 방법에 대한 코드를 간단하게 <a href=\"https://gist.github.com/evan-moon/a7e5a51e20d22016ea443a03480765b7\" target=\"_blank\" rel=\"nofollow\">필자의 Github Gist 링크</a>로 첨부하겠다.</p>\n<h3 id=\"objectcreate를-사용하자\" style=\"position:relative;\">Object.create를 사용하자<a href=\"#objectcreate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90\" aria-label=\"objectcreate를 사용하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Object.create</code> 메소드는 첫 번째 인자로 생성할 객체의 원본 객체가 될 객체, 두 번째 인자로 새로 생성할 객체에 추가할 프로퍼티를 객체 타입으로 받는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>proto<span class=\"token operator\">:</span> Object<span class=\"token punctuation\">,</span> properties<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 두 번째 인자는 선택사항이며, 단순하게 <code class=\"language-text\">{ test: 1 }</code>처럼 넘기는 것이 아니라, <code class=\"language-text\">Object.defineProperties</code> 메소드를 사용할 때 처럼 데이터 서술자와 접근 서술자를 지정해줘야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">foo</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">configurable</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">enumerable</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">value</span><span class=\"token operator\">:</span> <span class=\"token string\">'I am Foo!'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>자세한 프로퍼티들의 의미는 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\" target=\"_blank\" rel=\"nofollow\">MDN Web Docs: Object.defineProperties</a>에서 확인해보도록 하자.</p>\n<p>이 메소드에서 중요한 포인트는 객체의 프로토타입 객체를 지정할 수 있다는 것이며, 이 말인 즉슨 객체의 프로토타입 체인을 내 맘대로 만져줄 수 있다는 것이다. 심지어 동적으로 변경도 가능하다. <small>(사실 이게 JS의 변태적인 면…)</small></p>\n<p>그럼 이제 <code class=\"language-text\">Object.create</code> 메소드와 프로토타입을 사용하여 상속을 한번 구현해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">SuperClass</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">SuperClass</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">say</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">I am </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>우선 부모 클래스 역할을 할 <code class=\"language-text\">SuperClass</code> 생성자 함수를 생성하고, 이 함수의 프로토타입 객체에 <code class=\"language-text\">say</code> 메소드를 정의했다. 그럼 이제 자식 클래스 역할을 할 생성자 함수를 구현하고, 이 두 개의 함수의 상속 관계도 함께 정의해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">SubClass</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">SuperClass</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">SubClass</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SuperClass</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">SubClass</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">=</span> SubClass<span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">SubClass</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">run</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> is running</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>뭘 이것저것 많이 만진 것 같지만, 막상 하나하나 뜯어보면 별 거 없다.</p>\n<h4 id=\"superclasscallthis\" style=\"position:relative;\">SuperClass.call(this)<a href=\"#superclasscallthis\" aria-label=\"superclasscallthis permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">Function.prototype.call</code> 메소드는 호출된 함수의 실행 컨텍스트를 첫 번째 인자로 받은 녀석으로 변경한다. 즉, <code class=\"language-text\">this</code>의 타겟을 변경하는 것이다.</p>\n<p>즉, <code class=\"language-text\">SuperClass.call(this, name)</code>의 의미는 부모 생성자 함수의 생성자를 호출하되, 실행 컨텍스트를 자식 생성자 함수로 변경하라는 의미이다. 자바로 치면 <code class=\"language-text\">super</code> 메소드를 호출하는 것과 비슷한 느낌이랄까.</p>\n<p>필자는 이때 <code class=\"language-text\">call</code> 메소드를 사용했지만, 뭐가 됐든 부모 생성자 함수의 실행 컨텍스트만 변경해주면 장땡이기 때문에 <code class=\"language-text\">apply</code>나 <code class=\"language-text\">bind</code> 메소드를 사용해도 상관없다.</p>\n<h4 id=\"subclassprototype-변경\" style=\"position:relative;\">SubClass.prototype 변경<a href=\"#subclassprototype-%EB%B3%80%EA%B2%BD\" aria-label=\"subclassprototype 변경 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>그 후 <code class=\"language-text\">Object.create</code> 메소드를 사용하여 <code class=\"language-text\">SuperClass.prototype</code> 객체를 원본 객체로 하는 새로운 객체를 생성하고, 이 객체를 <code class=\"language-text\">SubClass</code>의 프로토타입 객체로 할당해준다. 자식 생성자 함수의 프로토타입 객체와 부모 생성자 함수의 프로토타입 객체 간의 프로토타입 체인, 쉽게 말해 부모 자식 관계를 만들어 주는 것이다.</p>\n<h4 id=\"subclassprorotypeconstructor-변경\" style=\"position:relative;\">SubClass.prorotype.constructor 변경<a href=\"#subclassprorotypeconstructor-%EB%B3%80%EA%B2%BD\" aria-label=\"subclassprorotypeconstructor 변경 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>우리는 부모 생성자 함수의 프로토타입 객체를 토씨 하나 안바꾸고 그대로 복제했기 때문에, 새롭게 생성한 자식 생성자 함수의 프로토타입 객체의  <code class=\"language-text\">constructor</code> 프로퍼티는 여전히 부모 생성자 함수인 <code class=\"language-text\">SuperClass</code>를 참조하고 있다.</p>\n<p>하지만 자식 생성자 함수인 <code class=\"language-text\">SubClass</code>를 통해 생성된 객체가 <code class=\"language-text\">SuperClass</code>를 사용하여 생성된 것처럼 처리되면 안되므로, 다시 <code class=\"language-text\">constructor</code> 프로퍼티를 <code class=\"language-text\">SubClass</code>로 변경해줘야한다.</p>\n<p>이런 과정들을 거치면 다음과 같은 관계가 성립된다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8ad5010e348e3ea93ea8ee00b6a3a94b/a3c4c/extends.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 46.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAD2EAAA9hAHVrK90AAAB/klEQVR42qVSOYtaURR2BrKQFCkCmSappphJkTbFFCEIQggYcILKaBIdAhbpUoRMZ+ef0NZWHTQyATfEQm0EN8R9eS+uuO++d2++e3EmPyAHDufB+d453z3fpxiPx1SSJJrJZGggEGBVpojhcPjHZDKd+ny+r8gfGo3m+Wg0ut5utzSdTkvhcJjG43FaKBRkQgirSgULURRJs9kkvV6PzGYzslwuJTZwvV63bDbb00ql8qpUKp0BegDc9XQ6pYPBYAsiBN8ElePdbvdHPnCxWFC2geU+OMPNZiMqlcojl8t14fF4vgP6pFwu/8Yw2u12JfovOD4Wi73nAxuNhh5b9O12Wy8IAqu6Tqdzge8PWq32vsViuWe1Wh8ybLVafVMsFj+Bse4Wj9T1+31DMBg89vv9DxT/EyB2sK+PIpHIt0QicaWo1+tG3NGIzTxrtZoBT/rcarXOGbv9D4esovcWvUvGKJvNGnFTI+5uwBlMDofjRKVSPeY3ZAHqNBqNsspvAnFEDDwNhUIWKHplNptfzOdzD+vhyVIymaSpVIqCDMeD3TtOG7cgYEMmkwmBskRiHkLAHgKs8sxut790Op2vAT3Esl9MFCi/Q5+sVqs7V9yJAr9RbGaqcqV3ux3fCLCgVquPvF7vF/jwJ1M5l8vd5PN5iudKsizTfXL8rQ//Atnk4klMaXG1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"extends\" title=\"\" src=\"/static/8ad5010e348e3ea93ea8ee00b6a3a94b/6af66/extends.png\" srcset=\"/static/8ad5010e348e3ea93ea8ee00b6a3a94b/69538/extends.png 160w,\n/static/8ad5010e348e3ea93ea8ee00b6a3a94b/72799/extends.png 320w,\n/static/8ad5010e348e3ea93ea8ee00b6a3a94b/6af66/extends.png 640w,\n/static/8ad5010e348e3ea93ea8ee00b6a3a94b/d9199/extends.png 960w,\n/static/8ad5010e348e3ea93ea8ee00b6a3a94b/21b4d/extends.png 1280w,\n/static/8ad5010e348e3ea93ea8ee00b6a3a94b/a3c4c/extends.png 2196w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이제 한번 <code class=\"language-text\">SubClass</code> 생성자 함수를 사용하여 객체를 생성해보고, 제대로 부모 생성자 함수의 속성들을 물려받았는지 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SubClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Evan'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">SubClass <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 에반 객체</span>\nSubClass <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">constructor</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>Function<span class=\"token operator\">:</span> SubClass<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">run</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>Function<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 에반 객체의 원본 객체</span>\nSuperClass <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">say</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>Function<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 에반 객체의 원본 객체의 원본 객체</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">evan</code> 객체는 <code class=\"language-text\">SubClass</code>의 프로토타입 객체를 복제해서 정상적으로 생성되었고, <code class=\"language-text\">evan</code> 객체의 원본 객체와 원본 객체의 원본 객체도 잘 체이닝되어있다.</p>\n<p>즉, <code class=\"language-text\">evan</code> -> <code class=\"language-text\">SubClass.prototype</code> -> <code class=\"language-text\">SuperClass.prototype</code>으로 이어지는 프로토타입 체인이 완성된 것이다. 이때 <code class=\"language-text\">evan</code> 객체의 <code class=\"language-text\">run</code>이나 <code class=\"language-text\">say</code> 메소드를 호출하면, 위에서 언급한 프로토타입 룩업을 통해 원본 객체의 메소드를 호출할 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"/2019/10/23/js-prototype/\">이전 포스팅</a>에 이어 이번에는 자바스크립트에서 프로토타입을 활용한 상속 패턴에 대한 내용을 한번 다뤄보았다.</p>\n<p>솔직히 말해서, 필자가 실무에서 이러한 패턴을 사용해서 상속을 구현해본 경험은 거의 없다. 필자가 개발자로 일을 시작하고 얼마 되지 않아 ES6가 나오기도 했었고, 필자는 당시 자바가 더 익숙했기 때문에 새로 추가된 <code class=\"language-text\">class</code> 키워드에 흠뻑 빠져있었다.</p>\n<p>하지만 일을 시작하고 몇 년이 지나면서 레거시 코드에서 이 상속 패턴을 꽤 마주치기도 했고, 면접에서 이런 패턴에 대해서 물어보는 경우도 있었기 때문에 확실히 공부할 필요는 있는 것 같다.</p>\n<p>아무리 요즘 ES5를 거의 사용하지 않는다고 하지만, 사실 이런 상속 패턴이 자바스크립트를 사용한 프로그램 아키텍처의 근간이기도 하니 말이다.</p>\n<p>이상으로 프로토타입을 사용하여 상속하기 포스팅을 마친다.</p>","fields":{"slug":"20191027-inheritance-with-prototype","path":"/2019/10/27/inheritance-with-prototype/","lang":"ko"},"frontmatter":{"title":"[JS 프로토타입] 프로토타입을 사용하여 상속하기","subTitle":"자바스크립트에서 상속이 실제로 작동하는 방식, 프로토타입 체인","date":"Oct 27, 2019","categories":["프로그래밍","자바스크립트"],"tags":["프로토타입","자바스크립트","JavaScript","Prototype","자바스크립트 기초","프론트엔드 기초","자바스크립트 상속","자바스크립트 클래스"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/ffc88c93a54f1c5d1783f61478e57588/d803c/thumbnail.png","srcSet":"/static/ffc88c93a54f1c5d1783f61478e57588/d803c/thumbnail.png 320w,\n/static/ffc88c93a54f1c5d1783f61478e57588/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/ffc88c93a54f1c5d1783f61478e57588/fc5c5/thumbnail.webp 320w,\n/static/ffc88c93a54f1c5d1783f61478e57588/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/ffc88c93a54f1c5d1783f61478e57588/01fb2/thumbnail.png","srcSet":"/static/ffc88c93a54f1c5d1783f61478e57588/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/ffc88c93a54f1c5d1783f61478e57588/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"cbf11ad3-1e69-5178-91bb-d088b7b4453b","tableOfContents":"<ul>\n<li>\n<p><a href=\"#es6%EB%B6%80%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94%EB%8D%B0%EB%8F%84-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EA%B5%B3%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\">ES6부터 클래스를 지원하는데도 프로토타입을 굳이 알아야 하나요?</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%80-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%8B%A4\">프로토타입은 디자인 패턴이다</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85\">자바스크립트의 프로토타입</a></p>\n<ul>\n<li><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EA%B0%80-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\">자바스크립트가 객체를 생성하는 방법</a></li>\n<li><a href=\"#%EB%8F%84%EB%8C%80%EC%B2%B4-%EB%AD%98-%EB%B3%B5%EC%A0%9C%ED%95%B4%EC%84%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EA%B1%B8%EA%B9%8C\">도대체 뭘 복제해서 객체를 만드는 걸까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\">프로토타입 체인</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 자바스크립트(JavaScript)하면 빠질 수 없는 프로토타입(Prototype)에 대해서 한번 이야기해보려고 한다. 프로토타입은 자바스크립트를 ES5 시절부터 사용해오던 분들에게는 매우 익숙하지만 ES6부터 시작하신 분들은 대부분 클래스를 사용하기 때문에 익숙한 개념은 아닐 것이라고 생각한다.","html":"<p>이번 포스팅에서는 자바스크립트(JavaScript)하면 빠질 수 없는 프로토타입(Prototype)에 대해서 한번 이야기해보려고 한다.</p>\n<p>프로토타입은 자바스크립트를 ES5 시절부터 사용해오던 분들에게는 매우 익숙하지만 ES6부터 시작하신 분들은 대부분 클래스를 사용하기 때문에 익숙한 개념은 아닐 것이라고 생각한다.</p>\n<!-- more -->\n<p>필자가 처음 프론트엔드 개발을 시작했을때는 자바스크립트의 ES5 버전에서 막 ES6로 넘어가고 있던 시절이었는데, 기존에는 자바(Java)를 주로 사용하고 있던 필자가 프론트엔드 개발로 넘어오면서 제일 애먹었던 부분이 바로 이 프로토타입이었다. <small>(물론 애먹는 건 현재진행형이다)</small></p>\n<p>물론 지금은 자바스크립트의 위상이 많이 올라가면서 프로토타입 패턴에 대한 관심도 많아지기 시작했지만, 그래도 당시나 지금이나 여전히 주류는 C 계열 언어나 Java에서 사용하는 클래스를 기반으로한 객체 생성 방식이다.</p>\n<p>그래서 자바스크립트를 처음 접하는 개발자에게 프로토타입 기반 프로그래밍은 상대적으로 낯선 방식일 수 밖에 없고, 이로 인해 기존 개발자들이 자바스크립트로 진입하는데 어려움이 있었다. 그런 이유로 ES6에서는 <code class=\"language-text\">class</code> 예약어가 등장한 것이다.</p>\n<p>사실 필자도 아직 클래스 기반의 객체 생성 방식이 익숙하기 때문에 프로토타입에 대한 공부가 더 필요하다.</p>\n<p>그래서 이번 포스팅에서는 프로토타입 패턴이 무엇인지, 자바스크립트 내에서 프로토타입이 어떤 방식으로 사용되고 있는지에 집중해서 한번 이야기해보려고 한다.</p>\n<h2 id=\"es6부터-클래스를-지원하는데도-프로토타입을-굳이-알아야-하나요\" style=\"position:relative;\">ES6부터 클래스를 지원하는데도 프로토타입을 굳이 알아야 하나요?<a href=\"#es6%EB%B6%80%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94%EB%8D%B0%EB%8F%84-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EA%B5%B3%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"es6부터 클래스를 지원하는데도 프로토타입을 굳이 알아야 하나요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자바스크립트는 ES6부터 <code class=\"language-text\">class</code> 키워드를 사용하여 클래스를 지원하고 있다. 정확히 말하면 프로토타입으로 클래스를 흉내내서 구현한 것이라고 말하는 것이 맞다.</p>\n<p>그런 이유로 많은 개발자들이 자바스크립트의 클래스를 단순한 문법 설탕(Syntactic Sugar)이라고 이야기하지만, 사실 개인적으로 자바스크립트의 클래스는 ES5 시절 프로토타입을 사용하여 객체를 생성했던 방법보다 더 엄격한 제약을 가지고 있기 때문에 단순한 문법 설탕이라기보다는 상위 요소(Superset)라고 하는게 맞지 않나 싶다.</p>\n<p>그러면 그냥 클래스를 쓰면 되는데 왜 프로토타입을 알아야 하는 것일까?</p>\n<p>그 이유는 ES6에서 <code class=\"language-text\">class</code> 키워드를 통해 클래스를 지원하고 있기는 하지만, 이건 자바스크립트가 클래스 기반 언어가 되었다는 의미는 아니기 때문이다. 결국 자바스크립트 안에서의 클래스는 클래스의 탈을 쓴 프로토타입이다.</p>\n<p>그리고 예전에 작성된 레거시 프론트엔드 코드의 경우에는 ES5로 작성된 것도 많기 때문에 아직까지 프론트엔드 개발자들은 ES5를 만져야하는 경우가 왕왕 있는 것이 현실이다. 물론 ES5를 ES6 이상의 버전으로 마이그레이션하려고 해도 기존의 프로토타입 기반의 객체 생성이나 상속이 구현된 코드를 이해할 수 없다면 마이그레이션 또한 불가능하다.</p>\n<h2 id=\"프로토타입은-디자인-패턴이다\" style=\"position:relative;\">프로토타입은 디자인 패턴이다<a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%80-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%8B%A4\" aria-label=\"프로토타입은 디자인 패턴이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>프로토타입이라고 하면 일반적으로 자바스크립트를 떠올리지만, 사실 프로토타입은 자바스크립트에서만 사용되는 것은 아니고, 그냥 일종의 디자인 패턴 중 하나이다. 자바스크립트 뿐만 아니라 ActionScript, Lua, Perl 등 프로토타입 기반 프로그래밍을 지원하는 다른 언어도 많다.</p>\n<p>그래서 자바스크립트의 프로토타입을 자세히 알아보기 전에 디자인 패턴으로써의 프로토타입을 먼저 알아볼까 한다.</p>\n<p>프로토타입 패턴은 객체를 효율적으로 생성하는 방법을 다루는 패턴 중 하나인데, 주로 객체를 생성하는 비용이 클 때 이를 회피하기 위해 사용된다.</p>\n<p>객체를 생성할 때의 비용이 크다는 말은, 말 그대로 객체를 생성할 때마다 뭔가 일을 많이 해야한다는 뜻이다.</p>\n<p>예를 들어 RPG 게임의 캐릭터를 하나 구현해본다고 생각해보자. 이 캐릭터는 여러가지 장비를 장착할 수 있는 기능을 가지고 있는데, 처음 캐릭터가 생성될 때 딸랑 맨 몸으로 시작하면 유저들이 싫어할 것 같으니 기본적인 장비 몇 가지를 장착한 상태로 생성될 수 있도록 만들어주려고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// Player.java</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Weapon</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Armor</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">BasicSward</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Weapon</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">BasicArmor</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Armor</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Player</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Weapon</span> weapon<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Armor</span> armor<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Player</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>weapon <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BasicSward</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 초심자의 목도</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>armor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BasicArmor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 초보자용 갑주</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>간단하게 만들어보면 대충 이런 느낌이다. <code class=\"language-text\">Player</code> 객체는 자신이 생성될 때 <code class=\"language-text\">BasicSward</code> 객체와 <code class=\"language-text\">BasicArmor</code> 객체까지 함께 생성해야한다.</p>\n<p>이런 경우 그냥 <code class=\"language-text\">Player</code> 객체만 생성하는 상황보다는 객체의 생성 비용이 높다고 할 수 있다. 게다가 캐릭터 생성 시 처음 부여하는 아이템의 종류가 많아질수록 <code class=\"language-text\">Player</code>의 객체의 생성 비용 또한 계속 높아질 것이다.</p>\n<p>음… 근데 곰곰히 생각해보니 캐릭터가 처음 생성되며 가지고 있는 아이템이 항상 같다는 전제 조건이 있다면 생성 비용이 높은 <code class=\"language-text\">Player</code>객체를 딱 한번만 생성하고 그 다음부터는 생성된 객체를 복사해서 사용해도 될 것 같다는 생각이 든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// 이건 너무 객체 생성 비용이 높으니까...</span>\n<span class=\"token class-name\">Player</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Player</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Player</span> john <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Player</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Player</span> wilson <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Player</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 이런 방법으로 접근해보는 것은 어떨까?</span>\n<span class=\"token class-name\">Player</span> player <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Player</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Player</span> evan <span class=\"token operator\">=</span> player<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Player</span> john <span class=\"token operator\">=</span> player<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Player</span> wilson <span class=\"token operator\">=</span> player<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이런 관점으로 접근하는 것이 바로 프로토타입 패턴이라고 할 수 있다. 프로토타입, 즉 원본 객체가 존재하고 그 객체를 복제해서 새로운 객체를 생성하는 방법인 것이다.</p>\n<p>실제로 자바에서 프로토타입 패턴을 사용할때, 복제 대상이 되는 클래스는 보통 <code class=\"language-text\">Cloneable</code> 인터페이스를 사용하여 구현한다. Cloneable 인터페이스에는 <code class=\"language-text\">clone</code> 메소드가 정의되어 있기 때문에, 이 인터페이스를 사용하는 클래스는 반드시 <code class=\"language-text\">clone</code> 메소드를 오버라이딩해서 구현해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Player</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Cloneable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//...</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Player</span> clone <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">CloneNotSupportedException</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Player</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">clone</code> 메소드를 구현하고나면 이제 <code class=\"language-text\">Player</code> 객체는 복사 가능한 객체가 된다. 즉, 다른 객체들의 원본 객체가 될 수 있는 기능을 가지게 되었다는 것이다.</p>\n<p>이제부터는 <code class=\"language-text\">Player</code> 객체를 추가로 생성하고 싶을 때는 기존에 생성되어 있던 객체를 그대로 복사하면 되기 때문에 높은 객체 생성 비용이 드는 것을 피할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">Player</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Player</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Player</span> evanClone <span class=\"token operator\">=</span> evan<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또한 <code class=\"language-text\">Player</code> 객체는 복사되어 새로운 메모리 공간을 할당받지만, 깊은 복사를 하지 않는 이상 <code class=\"language-text\">Player</code>객체가 가지고 있는 <code class=\"language-text\">BasicSward</code> 객체와 <code class=\"language-text\">BasicArmor</code> 객체는 새롭게 생성되지 않고 기존에 이 객체들이 할당된 메모리 공간을 참조하기만 한다.</p>\n<p>즉, 잘만 쓴다면 메모리 공간을 아낄 수도 있다는 것이다. 자바스크립트에서 원시 자료형은 Call by value, 그 외 자료형은 Call by reference를 사용하는 것과 동일한 원리이다.</p>\n<p>여기까지 듣고 나서 예상하신 분들도 있겠지만, 그 말인 즉슨 잠깐 정신줄 놓고 코딩하다보면 이런 슬픈 상황도 발생할 수 있다는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">Player</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Player</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Player</span> evanClone <span class=\"token operator\">=</span> evan<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    evanClone<span class=\"token punctuation\">.</span>weapon<span class=\"token punctuation\">.</span>attackPoint <span class=\"token operator\">=</span> <span class=\"token number\">40</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"에반 무기 공격력 -> \"</span> <span class=\"token operator\">+</span> evan<span class=\"token punctuation\">.</span>weapon<span class=\"token punctuation\">.</span>attackPoint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"에반 복사본 무기 공격력 -> \"</span> <span class=\"token operator\">+</span> evanClone<span class=\"token punctuation\">.</span>weapon<span class=\"token punctuation\">.</span>attackPoint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>err<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">에반 무기 공격력 -> 40\n에반 복사본 무기 공격력 -> 40</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 582px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cd3f0d7227b1bc002df8850727239515/14007/overtime_work.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 69.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHSsUgYAP/EABkQAAIDAQAAAAAAAAAAAAAAAAECABAREv/aAAgBAQABBQJtCg0zTrFn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAgIDAAAAAAAAAAAAAAAAABABESFBYf/aAAgBAQAGPwLFHVcLZ//EABwQAAICAgMAAAAAAAAAAAAAAAEhABExUWFxkf/aAAgBAQABPyHMexUwArSVxCAWMJw1jtwgGn6n/9oADAMBAAIAAwAAABAwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAQEBAQABBQAAAAAAAAAAAAERIQBBMVFxoeH/2gAIAQEAAT8QswKlv8uFyIWNGGx9usMy6R5Gi7WvH68u4sIfRrPrrBBnjHf/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"overtime work\" title=\"\" src=\"/static/cd3f0d7227b1bc002df8850727239515/14007/overtime_work.jpg\" srcset=\"/static/cd3f0d7227b1bc002df8850727239515/0913d/overtime_work.jpg 160w,\n/static/cd3f0d7227b1bc002df8850727239515/cb69c/overtime_work.jpg 320w,\n/static/cd3f0d7227b1bc002df8850727239515/14007/overtime_work.jpg 582w\" sizes=\"(max-width: 582px) 100vw, 582px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>디버깅 지옥이 펼쳐진다...</small>\n</center>\n<p>정리해보자면 프로토타입 패턴이란, 객체를 생성할 때 원본이 되는 객체를 복사해서 생성하는 패턴이라고 할 수 있다.</p>\n<p>물론 자바스크립트의 프로토타입은 단순히 몇 개의 객체가 복제 관계를 가지는 것이 아니라, 자바스크립트 내의 모든 객체 전체가 복제 관계로 얽혀있기 때문에 이것보다는 약간 더 복잡하긴 하지만, 근본적인 원리 자체는 프로토타입 패턴을 따라간다.</p>\n<p>그럼 이제 자바스크립트가 객체를 생성할 때 프로토타입 패턴을 어떤 식으로 사용하고 있는 지 한번 알아보도록 하자.</p>\n<h2 id=\"자바스크립트의-프로토타입\" style=\"position:relative;\">자바스크립트의 프로토타입<a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85\" aria-label=\"자바스크립트의 프로토타입 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 설명했듯이 프로토타입 패턴은 객체를 생성할 때 사용하는 패턴이다. 필자가 위에서 예시로 사용한 언어인 자바는 클래스 기반 프로그래밍을 지원하기 때문에, 특수한 패턴을 사용해야지만 프로토타입이라는 개념을 사용할 수 있다.</p>\n<p>그러나 애초에 프로토타입 기반 프로그래밍을 지원하는 자바스크립트의 경우에는 애초에 모든 객체를 생성할 때 프로토타입을 사용하기 때문에, 객체를 생성하기만 해도 위에서 필자가 설명한 프로토타입 패턴이 적용된다.</p>\n<p>그렇기 때문에 우선 자바스크립트에서 말하는 객체(Object)가 무엇인지, 그리고 그 객체가 생성된다는 것이 무엇을 의미하는 것인지 알아볼 필요가 있다.</p>\n<h3 id=\"자바스크립트가-객체를-생성하는-방법\" style=\"position:relative;\">자바스크립트가 객체를 생성하는 방법<a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EA%B0%80-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"자바스크립트가 객체를 생성하는 방법 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>컴퓨터 공학에서의 객체(Object)는 “현실의 대상을 프로그램에 반영한 것”이다. 즉, 여러 개의 프로퍼티(특징)와 메소드(행위)를 가지고 현실 세계의 무언가를 흉내내는 존재인 것이다.</p>\n<p>클래스 기반 언어에서는 클래스를 생성하고 그 클래스를 사용하여 객체를 생성해야하지만, 자바스크립트는 간단한 문법만으로 객체를 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">say</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hi, I am </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이런 방식을 우리는 “리터럴(Literal)로 객체를 선언한다”고 한다. 리터럴은 소스 코드의 고정된 값을 대표하는 일종의 단축어 같은 개념이기 때문에, 우리는 간단한 문법만으로 객체를 생성했다고 느끼지만 내부적으로는 객체를 생성하는 일련의 매커니즘이 작동하고 있다.</p>\n<p>예를 들어, 다른 언어에서는 이런 리터럴 문법을 사용하여 객체를 생성할 때 내부적으로 클래스를 사용하게된다. 파이썬 같은 경우, 딕셔너리를 리터럴로 선언하고 타입을 찍어보면 <code class=\"language-text\">dict</code> 클래스가 출력되는 것을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-python line-numbers\"><code class=\"language-python\">my_dict <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'name'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'age'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">29</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token builtin\">type</span><span class=\"token punctuation\">(</span>my_dict<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">&lt;class 'dict'></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 <code class=\"language-text\">dict({ 'name': 'Evan', 'age': 29 })</code>와 같이 클래스를 명시적으로 사용하지않고 리터럴로 딕셔너리를 생성했지만 내부적으로는 제대로 <code class=\"language-text\">dict</code> 클래스를 사용해서 객체를 생성했다는 것이다.</p>\n<p>자바 또한 리터럴 문법을 지원하는 배열(Array)을 선언한 후 출력해보면 결국 클래스를 기반으로 배열 객체를 생성한다는 것을 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"Evan\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"29\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">[Ljava.lang.String;@7852e922</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 말인 즉슨, 다른 언어와 마찬가지로 자바스크립트의 객체도 갑자기 혼자서 뿅 하고 생성되는 것이 아니라 분명히 뭔가를 사용해서 만들어내고 있다는 말이다.</p>\n<p>하지만 자바스크립트에는 클래스라는 개념 자체가 없는데 뭘 사용해서 객체를 만들어내고 있는 것일까?</p>\n<blockquote>\n<p>답은 바로 함수(Function)이다.</p>\n</blockquote>\n<p>자바스크립트에서 객체가 생성되는 원리를 조금 더 파헤쳐보기 위해서 위에서 리터럴로 선언했던 <code class=\"language-text\">evan</code> 객체를 이번에는 다른 방법으로 선언해보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>왠지 클래스 기반 언어에서 클래스를 사용하여 객체를 생성하는 것과 유사한 문법이 나타났다. 이런 방식을 생성자(Constructor)를 사용하여 객체를 생성한다고 한다.</p>\n<p>클래스 기반 언어라면 <code class=\"language-text\">Object</code>는 클래스겠지만, 자바스크립트에서는 클래스가 아닌 함수이다.</p>\n<p>즉, 자바스크립트에서의 생성자는 함수가 가지고 있다는 것이다. 저게 진짜 함수인지 알고 싶으니, 브라우저 콘솔 창을 열고 <code class=\"language-text\">Object</code>를 한번 출력해보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> Object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">ƒ <span class=\"token function\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>native code<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span>\n<span class=\"token string\">\"function\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>음, 콘솔로 찍어보니 <code class=\"language-text\">Object</code>는 확실하게 빼박캔트 함수가 맞다.</p>\n<p>필자가 처음 자바스크립트를 사용하기 시작했을 때 받아들이기 어려웠던 부분이 바로 이 부분이었다.</p>\n<p>클래스 기반 프로그래밍에 익숙했던 필자에게 <code class=\"language-text\">new</code> 키워드와 생성자는 클래스만 가질 수 있는 것이었는데 갑자기 뜬금없이 함수가 나와버리니 받아들이기 힘들었던 것 같다. <small>(머리로는 알겠는데 마음이…)</small></p>\n<p>어쨌든 이제 자바스크립트가 객체를 생성할 때 함수를 사용해서 생성한다는 것을 알게되었다. 지금까지 알아낸 내용을 정리해보자면 다음과 같다.</p>\n<blockquote>\n<ol>\n<li>프로토타입 패턴이란 객체를 생성할 때 원본 객체를 복제하여 생성하는 방법이다.</li>\n<li>자바스크립트는 객체를 생성할 때 프로토타입 패턴을 사용한다.</li>\n<li>자바스크립트는 객체를 생성할 때 함수를 사용한다.</li>\n</ol>\n</blockquote>\n<p>그렇다는 것은 자바스크립트가 함수를 사용하여 객체를 생성할 때 무언가를 참조하고 복제해서 객체를 생성한다는 말이다. 이제부터 그 “무언가”의 정체를 알아 볼 시간이다.</p>\n<h3 id=\"도대체-뭘-복제해서-객체를-만드는-걸까\" style=\"position:relative;\">도대체 뭘 복제해서 객체를 만드는 걸까?<a href=\"#%EB%8F%84%EB%8C%80%EC%B2%B4-%EB%AD%98-%EB%B3%B5%EC%A0%9C%ED%95%B4%EC%84%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-%EA%B1%B8%EA%B9%8C\" aria-label=\"도대체 뭘 복제해서 객체를 만드는 걸까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>사실 디자인 패턴으로써의 프로토타입 패턴은 생각보다 그렇게 어렵지 않다. 그저 객체를 생성할 때 원본 객체를 복제해서 생성한다는 개념이기 때문이다.</p>\n<p>마찬가지로 자바스크립트 또한 뭔가를 복제해서 새로운 객체를 생성하고 있다. 그럼 이제 자바스크립트가 도대체 뭘 복제해서 객체를 생성하고 있는 것인지 알아보기 위해 간단한 함수를 하나 선언해보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">User</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">User <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">__proto__</span><span class=\"token operator\">:</span> Object <span class=\"token punctuation\">}</span>\nobject</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>위에서 이야기했듯이 자바스크립트는 함수를 사용하여 객체를 생성하기 때문에, 이렇게 클래스를 사용하는 것과 유사한 느낌으로 객체를 생성할 수 있다.</p>\n<p>그렇다면 <code class=\"language-text\">evan</code> 객체는 무엇으로부터 복제된 것일까? 간단하게 생각하면 <code class=\"language-text\">User</code> 함수라고 생각해볼수 있겠지만, 사실은 <code class=\"language-text\">User</code> 함수를 복제한 것이 아니라 ”<code class=\"language-text\">User</code> 함수의 프로토타입 객체”를 복제한 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 497px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f720bb5dac9cb6fe226a654ae54db785/fce5f/surprise.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAUDBAb/xAAXAQADAQAAAAAAAAAAAAAAAAAAAQIE/9oADAMBAAIQAxAAAAFjUkXw3JljGf/EABwQAQEAAAcAAAAAAAAAAAAAAAECAAMREhMhMf/aAAgBAQABBQKVI5mqno3aYzfaVf/EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/AVf/xAAZEQADAAMAAAAAAAAAAAAAAAAAARECFGH/2gAIAQIBAT8ByVUNTp//xAAbEAACAQUAAAAAAAAAAAAAAAAAAVEQEUFh0f/aAAgBAQAGPwKyQliTtNEn/8QAGxABAAIDAQEAAAAAAAAAAAAAAQAhETFBUWH/2gAIAQEAAT8hVAo9hRosh1Dk3tgPbfsQWMK8HIpVfpZ//9oADAMBAAIAAwAAABDH/wD/xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxCD/8QAGhEBAAEFAAAAAAAAAAAAAAAAAQARIVGh4f/aAAgBAgEBPxCr5xbd17P/xAAcEAEAAgMBAQEAAAAAAAAAAAABESEAMUFhgZH/2gAIAQEAAT8QnyZjiXvhjJENEh5v8yCLNaFZfPMRXWpBfwytwJBUtfcWGOrEZ//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"surprise\" title=\"\" src=\"/static/f720bb5dac9cb6fe226a654ae54db785/fce5f/surprise.jpg\" srcset=\"/static/f720bb5dac9cb6fe226a654ae54db785/0913d/surprise.jpg 160w,\n/static/f720bb5dac9cb6fe226a654ae54db785/cb69c/surprise.jpg 320w,\n/static/f720bb5dac9cb6fe226a654ae54db785/fce5f/surprise.jpg 497w\" sizes=\"(max-width: 497px) 100vw, 497px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이렇게 갑자기 프로토타입이 나온다고...?</small>\n</center>\n<p>뜬금없어서 바로 이해가 안될 수도 있겠지만, 단순하게 생각해보면 쉽다. 만약 객체를 생성하면서 함수를 복제했다면 생성된 객체도 <code class=\"language-text\">Object</code> 타입이 아니라 <code class=\"language-text\">Function</code> 타입이어야 하지 않겠는가?</p>\n<p>하지만 <code class=\"language-text\">evan</code> 객체는 <code class=\"language-text\">Object</code> 타입을 가지고 있다. 즉, 이 함수 자체가 아니라 다른 객체 타입의 무언가를 복제했다는 것이고, 그 원본 객체가 <code class=\"language-text\">User</code> 함수의 프로토타입 객체인 것이다.</p>\n<p>필자는 <code class=\"language-text\">User</code> 함수의 프로토타입을 명시적으로 선언하지 않았지만, 자바스크립트는 함수가 생성될 때 자동으로 그 함수의 프로토타입 객체(Prototype Object)도 함께 생성하고 해당 함수의 <code class=\"language-text\">prototype</code> 프로퍼티에 연결해둔다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">User</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">constructor</span><span class=\"token operator\">:</span> f <span class=\"token function\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">__proto__</span><span class=\"token operator\">:</span> Object <span class=\"token punctuation\">}</span>\nobject</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>분명히 필자는 함수만 선언했는데, <code class=\"language-text\">User.prototype</code> 프로퍼티에 뭔가 이것저것 가지고 있는 객체 녀석이 1+1으로 붙어나왔다. 함수를 생성하면 무조건 그 함수의 프로토타입 객체도 함께 생성된다는 것이 키포인트다.</p>\n<p>그리고 이 프로토타입 객체는 함수를 사용해서 새로운 객체를 생성할 때 원본 객체 역할을 해줄 객체를 의미한다.</p>\n<p>즉, <code class=\"language-text\">new User()</code>라는 문법을 사용하여 새로운 객체를 만들게 되면 <code class=\"language-text\">User</code> 함수 자체가 아니라 <code class=\"language-text\">User.prototype</code>에 할당되어있는 프로토타입 객체를 복제해서 새로운 객체를 만든다는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/038db1dd67c62b78ef0c8473d3468899/21e8f/prototype.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 47.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAD2EAAA9hAHVrK90AAABqklEQVR42qWSSWoCURCGmwwgRMgiBJNVLpBjtLucwlu4ktDdSAIhBCSriHgED+BGXCiKA+KIOKA4i5hWW7uVyl+PFsywEFLw07zqel8Nr6TFYkHz+ZzK5TLF43FKJBLU7XZJ13WTYM1m80mCZbPZdz4j1oKPYrEYRaNRgp+m0ymZpkmVSoUkxFis1WplJZNJq9VqWfjJMhgwHo9VBubz+Q8+b7dbq1gsUi6XI8QL8HA45F+EuyQxvdfr0WazoUPb7XaciBqNxisD6/X6C5JyJ2an0xEVHcSKL/ularXqR0Y/2vQPBgOh0WjkR1YN1b0VCoUHBqIdFWdKpVIzVPJpGMYCCVYAf67Xax08HaPQpWMtEAg4VVW9jUQirmAweO3xeO7cbvd9OBy+8vl8N5qmubxer0v6h51BF7+8mKGCVpR2u62USiWlVqsp/X6ffY+TyeQFI5E5Di2d/Lh6/idwP1i8nlgZfil70GLqgGt23NlRFVqw5XIpVsd+2b2MQ2AoFHLYENYp5PgTyAudTqf5Is1mM0KbQmhZrE0mk3nmOFmWL23AXk4b/s2+AN9ErkY8uSpGAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prototype\" title=\"\" src=\"/static/038db1dd67c62b78ef0c8473d3468899/6af66/prototype.png\" srcset=\"/static/038db1dd67c62b78ef0c8473d3468899/69538/prototype.png 160w,\n/static/038db1dd67c62b78ef0c8473d3468899/72799/prototype.png 320w,\n/static/038db1dd67c62b78ef0c8473d3468899/6af66/prototype.png 640w,\n/static/038db1dd67c62b78ef0c8473d3468899/d9199/prototype.png 960w,\n/static/038db1dd67c62b78ef0c8473d3468899/21b4d/prototype.png 1280w,\n/static/038db1dd67c62b78ef0c8473d3468899/21e8f/prototype.png 1684w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>evan 객체야, 내가 아니라 내 프로토타입 객체를 복제하렴</small>\n</center>\n<p>이때 <code class=\"language-text\">User</code> 함수가 생성되며 함께 생성된 User 함수의 프로토타입 객체를 프로토타입 프로퍼티(Prototype Property)라고 한다.</p>\n<p>그럼 이 프로토타입 객체가 가지고 있는 프로퍼티인 <code class=\"language-text\">constructor</code>와 <code class=\"language-text\">__proto__</code>는 뭘 의미하는 걸까?</p>\n<h4 id=\"constructor\" style=\"position:relative;\">constructor<a href=\"#constructor\" aria-label=\"constructor permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>함수가 생성되며 함께 생성된 프로토타입 객체는 모두 <code class=\"language-text\">constructor</code>라는 프로퍼티를 가지고 있다. 그리고 이 프로퍼티에는 이 프로토타입 객체가 생성될 때 선언했던 함수가 들어있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">constructor</span><span class=\"token operator\">:</span> f <span class=\"token function\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">__proto__</span><span class=\"token operator\">:</span> Object\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>함수를 선언하면 함수와 함께 해당 함수의 프로토타입 객체도 함께 생성되며 이 둘을 연결하게 된다. 이때 함수는 프로토타입 객체의 <code class=\"language-text\">constructor</code> 프로퍼티로 연결되고, 프로토타입 객체는 함수의 <code class=\"language-text\">prototype</code> 프로퍼티로 연결되는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7a8216c54a105c3b1df15c379d0cb707/2b984/prototype_connection.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 15.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAD2EAAA9hAHVrK90AAAA4UlEQVR42i2OvWqEUBCF7VMkVYogSbkvJQiyiLC9gTQWNoGYB/AFfARFsRBrG0FErAS18gf/ua5yZ+eGnGKGM5wzfFzf9wdTVVVHEARHURT3bdvoPM+jrusfoii+hGH45fv+pyAIT5IkXZZlue/7DnEcU9d1IYoiYL4sS+DGcQRCCJznCf+ibOCNKIpysSzrLcuyW5IkNyy/aprGI8Re1zUgBMXngP6v2DQNcHmeG2maGhgw1nU1hmH4mabpt23bb1mWn23b5h3HuXqedzVN811VVR6zBDvQdR1lIIyObUb4AEHCviv5bRQfAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prototype connection\" title=\"\" src=\"/static/7a8216c54a105c3b1df15c379d0cb707/6af66/prototype_connection.png\" srcset=\"/static/7a8216c54a105c3b1df15c379d0cb707/69538/prototype_connection.png 160w,\n/static/7a8216c54a105c3b1df15c379d0cb707/72799/prototype_connection.png 320w,\n/static/7a8216c54a105c3b1df15c379d0cb707/6af66/prototype_connection.png 640w,\n/static/7a8216c54a105c3b1df15c379d0cb707/d9199/prototype_connection.png 960w,\n/static/7a8216c54a105c3b1df15c379d0cb707/21b4d/prototype_connection.png 1280w,\n/static/7a8216c54a105c3b1df15c379d0cb707/2b984/prototype_connection.png 2164w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>함수와 프로토타입 객체는 서로 연결되어있다</small>\n</center>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">===</span> User<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 생성자 프로퍼티는 이 함수를 통해 생성된 객체 입장에서 보았을 때 “나를 만들 때 어떤 함수가 호출되었냐?”를 의미한다. 만약 이 연결이 없다면 새로 생성된 객체는 자신을 만들 때 어떤 생성자 함수가 호출되었는지 알 수가 없다.</p>\n<p>새롭게 생성된 객체는 자신을 생성할 때 어떤 원본 객체를 복사했는지에 대한 링크는 가지고 있지만 어떤 생성자가 호출되었는지에 대한 링크는 가지고 있지 않기 때문이다.</p>\n<p>하지만 원본 객체의 <code class=\"language-text\">constuctor</code> 프로퍼티에 생성자 함수가 연결되어있기 때문에 새롭게 만들어진 객체는 자신의 원본 객체에 접근해서 이 프로퍼티를 참조함으로써 자신이 만들어질때 어떤 생성자 함수가 호출되었는지를 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span><span class=\"token class-name\">__proto__</span><span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">===</span> User<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 생성된 객체가 자신의 원본 객체에 접근할 수 있는 프로퍼티가 바로 <code class=\"language-text\">__proto__</code> 프로퍼티이다.</p>\n<h4 id=\"__proto__\" style=\"position:relative;\">__proto__<a href=\"#__proto__\" aria-label=\"__proto__ permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>방금 생성자를 설명하면서 함수를 통해 새롭게 생성된 객체는 원본 객체와의 연결을 가지고 있다고 했다. 이때 이 연결을 프로토타입 링크(Prototype Link)라고 한다.</p>\n<p><code class=\"language-text\">Object.prototype</code>을 제외한 자바스크립트 내의 모든 객체는 원본 객체를 기반으로 복사되어 생성되었기 때문에, 자신의 원본 객체로 연결되어있는 프로토타입 링크 또한 모든 객체가 가지고 있다. 이때 이 링크가 담기는 프로퍼티가 <code class=\"language-text\">__proto__</code> 프로퍼티이다.</p>\n<p><code class=\"language-text\">Object.prototype.__proto__</code>가 존재하지 않는 이유는 밑에서 후술하도록 하겠다. 우선은 객체들이 자신의 원본 객체로 통하는 프로토타입 링크를 가지고 있다는 사실에만 집중하자.</p>\n<blockquote>\n<p>이 포스팅에서는 이해를 돕기위해 <code class=\"language-text\">__proto__</code> 프로퍼티를 그대로 사용하고 있다.\n그러나 해당 프로퍼티는 ECMAScript 2015에서는 표준이었지만 현재는 표준이 아니므로 <code class=\"language-text\">Object.getPrototypeOf()</code>를 사용하는 것을 추천한다.</p>\n</blockquote>\n<p>즉 <code class=\"language-text\">User</code> 함수를 사용하여 생성한 객체는 <code class=\"language-text\">User.prototype</code> 객체를 복사하여 생성된 객체이기 때문에, 이 객체들은 원본인 <code class=\"language-text\">User.prototype</code> 객체를 자신의 <code class=\"language-text\">__proto__</code> 프로퍼티에 연결해두는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">User</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그렇다면 이 프로토타입 링크를 사용해서 계속 해서 원본 객체를 추적하다보면, 결국은 자바스크립트 내의 모든 객체들이 최종적으로 어떤 원본 객체를 복사해서 생성된 것인지 알 수 있지 않을까?</p>\n<h2 id=\"프로토타입-체인\" style=\"position:relative;\">프로토타입 체인<a href=\"#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\" aria-label=\"프로토타입 체인 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자바스크립트 내의 사용되는 모든 객체들은 전부 이런 프로토타입 기반 방식으로 정의되고 생성된다. 즉, <code class=\"language-text\">String</code>, <code class=\"language-text\">Boolean</code>, <code class=\"language-text\">Array</code>와 같이 우리가 일반적으로 사용하고 있는 빌트인 객체들도 모두 같은 방식을 사용해서 만들었다는 것이다.</p>\n<p>그렇다면 이 객체들은 어떤 프로토타입 객체를 복사해서 만들어진 것일까?</p>\n<p><code class=\"language-text\">String</code>, <code class=\"language-text\">Boolean</code>, <code class=\"language-text\">Array</code>든 뭐가 됐든 자바스크립트 내에 존재하는 모든 것들은 바로 <code class=\"language-text\">Object</code> 함수의 프로토타입인 <code class=\"language-text\">Object.prototype</code>을 시작으로 해서 복제된다.</p>\n<p>위에서 <code class=\"language-text\">__proto__</code>를 설명하면서 <code class=\"language-text\">Object.prototype</code> 객체는 프로토타입 링크, 즉 원본 객체로 통하는 링크가 없다고 이야기했었는데, 그 이유는 바로 <code class=\"language-text\">Object.prototype</code>이 모든 객체들의 조상님이기 때문이다.</p>\n<p>이게 정말인지 확인해보고 싶다면, 아무 객체나 골라잡아서 그 객체의 <code class=\"language-text\">__proto__</code> 프로퍼티를 통해 쭉쭉 올라가보면 된다.</p>\n<p>일단 만만한 <code class=\"language-text\">String</code>을 사용해서 조상을 추적해보려고 하는데, <code class=\"language-text\">String</code> 객체를 생성하는 함수부터 출발할 것인지, <code class=\"language-text\">String</code> 객체부터 출발할 것인지에 따라 조상까지 올라가는 길이 달라진다.</p>\n<p><code class=\"language-text\">String</code> 객체를 생성하는 함수와 <code class=\"language-text\">String</code> 객체는 당연히 원본이 다르기 때문이다. 필자는 그 중 <code class=\"language-text\">String</code> 객체를 생성할 수 있는 생성자 함수를 선택했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> first <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> second <span class=\"token operator\">=</span> first<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'첫번째 조상 -> '</span><span class=\"token punctuation\">,</span> first<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'두번째 조상 -> '</span><span class=\"token punctuation\">,</span> second<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">첫 번째 조상 -> Function\n두 번째 조상 -> Object</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>자바스크립트의 모든 함수는 자신의 원본으로 <code class=\"language-text\">Function.prototype</code> 객체를 원본으로 가진다. 그리고 Function.prototype은 결국 객체이기 때문에, 당연히 원본으로 <code class=\"language-text\">Object.prototype</code> 객체를 원본으로 가진다.</p>\n<p>그럼 여기서 한번 더 올라가면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> third <span class=\"token operator\">=</span> second<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>third<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Uncaught TypeError: Cannot read property 'constructor' of null at &lt;anonymous>:1:28</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>앗, <code class=\"language-text\">TypeError</code>가 발생했다. 에러메세지를 보아하니 <code class=\"language-text\">Object.prototype</code> 객체의 원본 객체인 <code class=\"language-text\">Object.prototype.__proto__</code>는 <code class=\"language-text\">null</code>인 모양이다.</p>\n<p>즉, <code class=\"language-text\">Object</code>의 위로는 더 이상 조상이 없는 것이다. 지금 살펴본 이 관계를 간단한 다이어그램으로 나타내어보면 다음과 같다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/93b117acac7ef6b38673300c3c764241/0f96c/prototype-chain.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 51.87500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAD2EAAA9hAHVrK90AAACRUlEQVR42n1STWgTURDeJlVrFdSLkGO1gkLwkot4MEiPBvXkIQS9yNoqC40WPIR2L1I8leKpuYaeckhIAhVEEpKANuSH/Jl/8rO4+V02/z00m7zOrFsxFx/Mm3kz874338yjKIpaMJvNl0FT4XD4I4FVKpVOA4HA1O/3T9FGXy6Xe4s5LMsugVKDvlitVlcgfgfCy9T5SiaTtzwejxbtRqPxDi+Px2NpNBqhxqOEWyqV2sQck8l0BdQFq9V6LZ1OmyORyKder7eKMUhboDKZzA464XATbH29Xnd0u10bAB4C4OFwOLS1221HsVh8jJfsdruaml9Ysepfh0qn08kl5/P5RwB2UC6X99xu977L5doH354oigcA+FCpYu6yRqNZngPEF41G4w0FcOucMlRGBoOBbKOv0+nQCuAi3vH5fItgq/V6/VXsJ55R5AoNBoNcYTAYfAWNTvE8/xOSQyiSJP3o9/u/OI5/rgD+nzJQeRkKhV5D4nXooVYQBAvHcR9gwlsolUrlfbPZtMCU7ytTVsGDz6ANDDCinU4nE4vFNoDNejabXaei0ehTqOwF9gZovSF/lgR9JPAYmc1mMuVMTZCnzDDMJRhYEH2ValUCEFIoFMh0OiXwMJEp0zQtU4bAJnwBAhVKCvBfwN+t1gYQVutZ35IoCkeddot0RWEymZzOxicnMmCtViPy38GmKj18kEgkduPx+A58FRboo2yD/ZnjSlqL7Xjl23cv6/V6v3w9zjxxRAf3to86a5Ecf7fXa90GtqtnOODSpjeTadoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"prototype chain\" title=\"\" src=\"/static/93b117acac7ef6b38673300c3c764241/6af66/prototype-chain.png\" srcset=\"/static/93b117acac7ef6b38673300c3c764241/69538/prototype-chain.png 160w,\n/static/93b117acac7ef6b38673300c3c764241/72799/prototype-chain.png 320w,\n/static/93b117acac7ef6b38673300c3c764241/6af66/prototype-chain.png 640w,\n/static/93b117acac7ef6b38673300c3c764241/d9199/prototype-chain.png 960w,\n/static/93b117acac7ef6b38673300c3c764241/21b4d/prototype-chain.png 1280w,\n/static/93b117acac7ef6b38673300c3c764241/0f96c/prototype-chain.png 2248w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>뭔가 복잡해보이지만 별 것 없다. <code class=\"language-text\">String</code> 생성자 함수의 원본 객체는 <code class=\"language-text\">Function.prototype</code>이다. 그리고 <code class=\"language-text\">const a = 'evan'</code>과 같이 선언된 <code class=\"language-text\">String</code> 객체는 자신을 생성한 <code class=\"language-text\">String</code> 생성자 함수의 프로토타입인 <code class=\"language-text\">String.prototype</code>을 원본으로 가질 것이고, <code class=\"language-text\">String.prototype</code>은 객체이기 때문에 당연히 <code class=\"language-text\">Object.prototype</code>을 원본으로 가지는 것이다.</p>\n<p>이렇게 프로토타입으로 이루어진 객체들의 관계를 프로토타입 체인(Prototype Chain)이라고 한다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 필자가 프로토타입에 대한 포스팅을 쓰려고 했던 이유는 얼마 전 면접에서 자바스크립트의 프로토타입을 사용하여 Private Static 메소드를 구현하라는 문제를 받았다가 결국 못 풀었기 때문이다.</p>\n<p>자바스크립트의 클로저와 프로토타입을 활용하여 풀어야하는 문제였는데, 필자는 기본기가 부족한 나머지 풀어내지 못했다.</p>\n<p>그래서 원래는 프로토타입을 사용한 다양한 상속 기법들과 클로저를 사용한 멤버의 은닉 등도 함께 소개해보려고 했지만, 늘 그렇듯 분량 조절 실패로 인해 다른 포스팅에서 별도로 다뤄야할 것 같다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8d8688b810398dcf20c57de5e7c319b4/066f9/no_think.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 116.25000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7phJsAgUH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEAAQUCH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABUQAQEAAAAAAAAAAAAAAAAAACAh/9oACAEBAAY/AhT/AP/EABoQAQACAwEAAAAAAAAAAAAAAAEAERAxQYH/2gAIAQEAAT8hZ3CXuFnrDyJcNT//2gAMAwEAAgADAAAAEL/3w//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EABwQAQEAAgMBAQAAAAAAAAAAAAERACEQMVFBcf/aAAgBAQABPxByHuCEGn6XrgkAEfcaMRdFll1s42f1kmu8KQ5//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"no think\" title=\"\" src=\"/static/8d8688b810398dcf20c57de5e7c319b4/066f9/no_think.jpg\" srcset=\"/static/8d8688b810398dcf20c57de5e7c319b4/0913d/no_think.jpg 160w,\n/static/8d8688b810398dcf20c57de5e7c319b4/cb69c/no_think.jpg 320w,\n/static/8d8688b810398dcf20c57de5e7c319b4/066f9/no_think.jpg 400w\" sizes=\"(max-width: 400px) 100vw, 400px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>사실 애초에 분량 조절 따위를 생각하고 쓰지 않는다</small>\n</center>\n<p>필자처럼 기존의 클래스 기반 객체 생성방식에 익숙한 개발자들에게 자바스크립트의 프로토타입은 꽤나 복잡하게 느껴진다. 디자인 패턴으로써의 프로토타입은 단순히 객체를 복제해서 새로운 객체를 생성한다는 정도의 개념에 그치지만 자바스크립트의 프로토타입 체인은 그것보다 훨씬 더 복잡하게 연결되어있기 때문이다.</p>\n<p>하지만 프로토타입 체인이나 프로토타입을 사용한 각종 상속 기법은 어렵게 느껴질 수 있어도, 프로토타입의 뼈대 자체는 그렇게 어렵지 않다고 생각한다.</p>\n<blockquote>\n<ol>\n<li>객체는 함수를 사용해서 만들어지고, 객체는 함수의 프로토타입 객체를 복제하여 생성된다.</li>\n<li>모든 객체는 자신이 어떤 원본 객체를 복제하여 생성된 것인지에 대한 정보를 가지고 있다.</li>\n</ol>\n</blockquote>\n<p>물론 원본 객체에 대한 정보를 런타임에 동적으로 변경할 수 있는 등 변태같은 짓들이 가능하기도 하고, 이를 사용한 다양한 기법들도 있기는 하지만 기본은 결국 저 두 가지라고 할 수 있을 것 같다. 다음 포스팅에서는 본격적으로 프로토타입을 사용한 상속 기법과 객체의 프로퍼티를 탐색하는 방법인 프로토타입 룩업 등에 대해서 설명하도록 하겠다.</p>\n<p>이상으로 자바스크립트의 프로토타입 훑어보기 포스팅을 마친다.</p>","fields":{"slug":"20191023-js-prototype","path":"/2019/10/23/js-prototype/","lang":"ko"},"frontmatter":{"title":"[JS 프로토타입] 클래스보다 깊은 세계, 자바스크립트 프로토타입 완전 정복","subTitle":"클래스 문법 뒤에 숨겨진 자바스크립트의 진짜 객체 생성 원리","date":"Oct 23, 2019","categories":["프로그래밍","자바스크립트"],"tags":["프로토타입","자바스크립트","JavaScript","Prototype","자바스크립트 기초","프론트엔드 기초"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/c4c3f4bd82adfc1f6422180eedbd4fb0/d803c/thumbnail.png","srcSet":"/static/c4c3f4bd82adfc1f6422180eedbd4fb0/d803c/thumbnail.png 320w,\n/static/c4c3f4bd82adfc1f6422180eedbd4fb0/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/c4c3f4bd82adfc1f6422180eedbd4fb0/fc5c5/thumbnail.webp 320w,\n/static/c4c3f4bd82adfc1f6422180eedbd4fb0/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/c4c3f4bd82adfc1f6422180eedbd4fb0/01fb2/thumbnail.png","srcSet":"/static/c4c3f4bd82adfc1f6422180eedbd4fb0/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/c4c3f4bd82adfc1f6422180eedbd4fb0/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"45bf3acc-2f61-5e79-8f26-ad6b03a3bd29","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%99%9C-%EC%9D%B4-%ED%8F%AC%EC%8A%A4%ED%8C%85%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%98%EA%B2%8C-%EB%90%98%EC%97%88%EB%82%98\">왜 이 포스팅을 작성하게 되었나?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EC%9E%98%EB%AA%BB%EB%90%9C-%EA%B0%9C%EB%85%90%EB%93%A4\">대표적인 잘못된 개념들</a></p>\n<ul>\n<li><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EB%8A%94-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84-%EB%82%B4%EB%B6%80%EC%97%90-%EC%9E%88%EB%8B%A4\">이벤트 루프는 자바스크립트 엔진 내부에 있다</a></li>\n<li><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EB%8A%94-%ED%95%98%EB%82%98%EC%9D%98-%EC%8A%A4%ED%83%9D-%EB%98%90%EB%8A%94-%ED%95%98%EB%82%98%EC%9D%98-%ED%81%90%EB%A1%9C%EB%A7%8C-%EC%9E%91%EB%8F%99%ED%95%9C%EB%8B%A4\">이벤트 루프는 하나의 스택 또는 하나의 큐로만 작동한다</a></li>\n<li><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EB%8A%94-%EC%97%AC%EB%9F%AC-%EA%B0%9C%EC%9D%98-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EB%90%9C%EB%8B%A4\">이벤트 루프는 여러 개의 스레드에서 실행된다</a></li>\n<li><a href=\"#settimeout%EC%9D%80-%EC%9D%BC%EB%B6%80-%EB%B9%84%EB%8F%99%EA%B8%B0-os-api%EC%99%80-%EA%B4%80%EB%A0%A8%EC%9E%88%EB%8B%A4\">setTimeout은 일부 비동기 OS API와 관련있다.</a></li>\n<li><a href=\"#setimmediate%EC%9D%98-%EC%BD%9C%EB%B0%B1%EC%9D%80-%EC%9E%91%EC%97%85-%ED%81%90%EC%9D%98-%EA%B0%80%EC%9E%A5-%EC%B2%AB%EB%B2%88%EC%A7%B8%EC%97%90-%EC%9C%84%EC%B9%98%ED%95%9C%EB%8B%A4\">setImmediate의 콜백은 작업 큐의 가장 첫번째에 위치한다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EC%9D%98-%EA%B5%AC%EC%A1%B0\">이벤트 루프의 구조</a></p>\n<ul>\n<li><a href=\"#timer-phase\">Timer phase</a></li>\n<li><a href=\"#pending-io-callback-phase\">Pending i/o callback phase</a></li>\n<li><a href=\"#idle-prepare-phase\">Idle, Prepare phase</a></li>\n<li><a href=\"#poll-phase\">Poll phase</a></li>\n<li><a href=\"#check-phase\">Check phase</a></li>\n<li><a href=\"#close-callbacks\">Close callbacks</a></li>\n<li><a href=\"#nexttickqueue%EC%99%80-microtaskqueue\">nextTickQueue와 microTaskQueue</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EC%9D%98-%EC%9E%91%EC%97%85-%ED%9D%90%EB%A6%84\">이벤트 루프의 작업 흐름</a></p>\n<ul>\n<li><a href=\"#timer-phase-1\">Timer phase</a></li>\n<li><a href=\"#pending-io-phase\">Pending i/o phase</a></li>\n<li><a href=\"#poll-phase-1\">Poll phase</a></li>\n<li><a href=\"#check-phase-1\">Check phase</a></li>\n<li><a href=\"#close-callback\">Close callback</a></li>\n<li><a href=\"#nexttickqueue--microtaskqueue\">nextTickQueue &#x26; microTaskQueue</a></li>\n<li><a href=\"#thread-pool\">Thread-pool</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#workflow-with-examples\">Workflow with examples</a></p>\n<ul>\n<li><a href=\"#snippet-1--%EA%B8%B0%EC%B4%88-%EC%9D%B4%ED%95%B4\">Snippet 1 – 기초 이해</a></li>\n<li><a href=\"#snippet-2--%ED%83%80%EC%9D%B4%EB%A8%B8%EB%93%A4%EC%9D%84-%EB%8D%94-%EC%9E%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\">Snippet 2 – 타이머들을 더 잘 이해하기</a></li>\n<li><a href=\"#snippet-3--nexttick%EA%B3%BC-%ED%83%80%EC%9D%B4%EB%A8%B8-%EC%8B%A4%ED%96%89%EC%97%90-%EB%8C%80%ED%95%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\">Snippet 3 – nextTick()과 타이머 실행에 대해 이해하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%AA%87-%EA%B0%80%EC%A7%80-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%A7%88%EB%AC%B8%EB%93%A4\">몇 가지 일반적인 질문들</a></p>\n<ul>\n<li><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%A0%95%ED%99%95%ED%9E%88-%EC%96%B4%EB%94%94%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94%EA%B1%B4%EA%B0%80%EC%9A%94\">그럼 자바스크립트는 정확히 어디에서 실행되는건가요?</a></li>\n<li><a href=\"#%EC%99%9C-%EC%9A%B0%EB%A6%AC%EB%8A%94-settimeoutfn-0%EA%B0%80-%EC%9E%88%EB%8A%94%EB%8D%B0%EB%8F%84-setimmediate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\">왜 우리는 setTimeout(fn, 0)가 있는데도 setImmediate를 사용해야 하나요?</a></li>\n<li><a href=\"#%EC%99%9C-setimmediate%EB%8A%94-immediate%EC%A6%89%EC%8B%9C%EB%9D%BC%EA%B3%A0-%EB%B6%80%EB%A5%B4%EB%8A%94-%EA%B1%B4%EA%B0%80%EC%9A%94\">왜 setImmediate는 Immediate(즉시)라고 부르는 건가요?</a></li>\n<li><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-block-%EB%90%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EA%B1%B4%EA%B0%80%EC%9A%94\">자바스크립트는 Block 될 수 있는 건가요?</a></li>\n<li><a href=\"#%EB%A7%8C%EC%95%BD-exit-callback-phase%EC%97%90%EC%84%9C-settimeout%EC%9D%84-%ED%98%B8%EC%B6%9C%ED%95%98%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%90%98%EB%82%98%EC%9A%94\">만약 Exit callback phase에서 setTimeout을 호출하면 어떻게 되나요?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A7%A7%EC%9D%80-%EC%A0%95%EB%A6%AC%EB%93%A4\">짧은 정리들</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"1년 전, 필자는 setImmediate & process.nextTick의 차이점에 대해 설명하면서 Node.js의 이벤트 루프 구조에 대해 살짝 언급한 적이 있었다. 놀랍게도 독자 분들은 원래 설명하려고 했던 부분보다 이벤트 루프 부분에 대해서 더 많이 관심을 주었고, 필자는 그 부분에 대해서 많은 질문을 받았었다. 그래서 이번에는 Node.js의 이벤트 루프를 구성하는 로우 레벨의 동작을 자세하게 설명해보려고 한다.","html":"<p>1년 전, 필자는 <a href=\"http://voidcanvas.com/setimmediate-vs-nexttick-vs-settimeout/\" target=\"_blank\" rel=\"nofollow\">setImmediate &#x26; process.nextTick</a>의 차이점에 대해 설명하면서 Node.js의 이벤트 루프 구조에 대해 살짝 언급한 적이 있었다. 놀랍게도 독자 분들은 원래 설명하려고 했던 부분보다 이벤트 루프 부분에 대해서 더 많이 관심을 주었고, 필자는 그 부분에 대해서 많은 질문을 받았었다. 그래서 이번에는 Node.js의 이벤트 루프를 구성하는 로우 레벨의 동작을 자세하게 설명해보려고 한다.</p>\n<!-- more -->\n<blockquote>\n<p>이 포스팅은 2018년 2월 19일에 Paul Shan이 작성한 <a href=\"http://voidcanvas.com/nodejs-event-loop/\" target=\"_blank\" rel=\"nofollow\">Node.js event loop workflow &#x26; lifecycle in low level</a>를 번역한 글입니다. 의역이 있을 수 있습니다.</p>\n</blockquote>\n<h2 id=\"왜-이-포스팅을-작성하게-되었나\" style=\"position:relative;\">왜 이 포스팅을 작성하게 되었나?<a href=\"#%EC%99%9C-%EC%9D%B4-%ED%8F%AC%EC%8A%A4%ED%8C%85%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%98%EA%B2%8C-%EB%90%98%EC%97%88%EB%82%98\" aria-label=\"왜 이 포스팅을 작성하게 되었나 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>만약에 여러분이 구글에서 <code class=\"language-text\">node.js event loop</code>를 검색하면 나오는 대부분의 아티클들은 자세한 내용을 설명해주지 않는다. <small>(그들은 매우 거시적으로만 이 과정을 묘사하려고 한다.)</small></p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/a076c3e84ee1aecf176f5e15c621a291/c2d13/node-js-wrong-event-loop_wdvpem.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 62.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAACr0lEQVR42mWQS0wTQRiA9+jJgxegUGhLt7vdPrbbF+3S3ZZuty0tBTXgwWjiAyNG40WOJoTE4MEYjQmXmpBCvHgxECO+wiOGo3IxejAxGpQSSF+77Xa7bLH+XaMXv+zO/DPz/zPfDFKt1mRZLpfLtar466h5pNFstgOYF8TqodpUFOXwH6rakOXizx+7+TwCpbV6vSyUdwvibkkSpWqlVq3LdUiTJEkQBLnRUFUVhrKGJNVhsnCwXxEEZOL1sxubrybXX0yur15YW72y+fLc2+c7otBqteB0BQ5SFPhApPUfyMe9/a/Fwue9nWJTzT59kjw7NjF1/uat61NXL33Y3oaMeqUiVyoQLC8vZ7PZ3OLSYi43Pz+/sbGBFEWlIDYqtRIsP3p432A6EY54PAEr5uhdW3ujtlrVxmG+XJMa6mgmo+/qsKH9dn1Hz/Fj09PTCFysUAL/tufCwuMQ4zs1nj55OhUfZre23inN1kFJfP/p25fv+aWl3J3ZmXt35x7Mzc7N3F5ZWUFibTj4eZ7nOC4ChLWGDUejXDzOc1oGz8dSqdRIJpNIJpPDqczYWDqdRrr+0tnZCa1Oo1vjz6Suq6tXr+/r6zMYDH9a6Lp1OshGzGYzrkFYrS6AJCm322634zhGEITFYjEajRRF+f1+F0Vp6yQMId9kMiFWHAdJLjqUSCRAjGFZNjQY56L+IM0wDEm64CSbzQbbwV52LYAyowaCW1CWYaKRcJT28+xgmA5yboL3kcMDrthQxO32gCrpcnm8PtxqxTAMXFDUDOVOpxPBcJymB+F5RsJ0MhqJhYIjA2Qs6B0N+RiGheKenu4z4+PXLl+M0EE64HV7KRCByzocDgRFUVCBiHTYvR5PMBCIeEmGcvicBEU6MQwHPYsZBUHcAq9jxnALQeCm/rb5b5x2aX5rJxm3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"node js wrong event loop wdvpem\" title=\"\" src=\"/static/a076c3e84ee1aecf176f5e15c621a291/6af66/node-js-wrong-event-loop_wdvpem.png\" srcset=\"/static/a076c3e84ee1aecf176f5e15c621a291/69538/node-js-wrong-event-loop_wdvpem.png 160w,\n/static/a076c3e84ee1aecf176f5e15c621a291/72799/node-js-wrong-event-loop_wdvpem.png 320w,\n/static/a076c3e84ee1aecf176f5e15c621a291/6af66/node-js-wrong-event-loop_wdvpem.png 640w,\n/static/a076c3e84ee1aecf176f5e15c621a291/d9199/node-js-wrong-event-loop_wdvpem.png 960w,\n/static/a076c3e84ee1aecf176f5e15c621a291/21b4d/node-js-wrong-event-loop_wdvpem.png 1280w,\n/static/a076c3e84ee1aecf176f5e15c621a291/c2d13/node-js-wrong-event-loop_wdvpem.png 2560w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>위 그림은 구글에서 <code class=\"language-text\">nodejs event loop</code>를 검색했을 때 나오는 이미지들을 캡쳐한 것이다. 그리고 대다수의 이미지 결과들은 잘못 되었거나 실제 이벤트 루프가 어떻게 작동하는지에 대해서 거시적으로만 설명하고 있다. 이런 방식의 설명들 때문에 개발자들은 종종 이벤트 루프에 대한 잘못된 이해를 하게 된다. 아래 설명할 몇가지 개념은 개발자들이 잘못 알고 있는 몇가지 개념들이다.</p>\n<h2 id=\"대표적인-잘못된-개념들\" style=\"position:relative;\">대표적인 잘못된 개념들<a href=\"#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EC%9E%98%EB%AA%BB%EB%90%9C-%EA%B0%9C%EB%85%90%EB%93%A4\" aria-label=\"대표적인 잘못된 개념들 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"이벤트-루프는-자바스크립트-엔진-내부에-있다\" style=\"position:relative;\">이벤트 루프는 자바스크립트 엔진 내부에 있다<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EB%8A%94-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84-%EB%82%B4%EB%B6%80%EC%97%90-%EC%9E%88%EB%8B%A4\" aria-label=\"이벤트 루프는 자바스크립트 엔진 내부에 있다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>대표적인 잘못된 개념들 중 하나는 바로 이벤트 루프가 자바스크립트 엔진<small>(V8, Spider Monkey 등)</small>의 일부라는 것이다. 하지만 이벤트 루프는 단지 자바스크립트 코드를 실행하기위해 자바스크립트 엔진을 이용하기만 할 뿐이다. <small>(역주: 실제로 V8 엔진에는 이벤트 루프를 관리하는 코드가 없다. Node.js나 브라우저가 이벤트 루프를 담당하는 것)</small></p>\n<h3 id=\"이벤트-루프는-하나의-스택-또는-하나의-큐로만-작동한다\" style=\"position:relative;\">이벤트 루프는 하나의 스택 또는 하나의 큐로만 작동한다<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EB%8A%94-%ED%95%98%EB%82%98%EC%9D%98-%EC%8A%A4%ED%83%9D-%EB%98%90%EB%8A%94-%ED%95%98%EB%82%98%EC%9D%98-%ED%81%90%EB%A1%9C%EB%A7%8C-%EC%9E%91%EB%8F%99%ED%95%9C%EB%8B%A4\" aria-label=\"이벤트 루프는 하나의 스택 또는 하나의 큐로만 작동한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>먼저, 이벤트 루프에 작업을 담아놓는 스택 같은 것은 존재하지 않는다. 그리고 이벤트 루프가 작동하는 과정은 여러 개의 큐<small>(자료구조에서의 그 큐 맞다.)</small>를 사용하는 복잡한 과정이다. 그러나 대부분의 개발자들은 자바스크립트의 모든 콜백이 단 하나의 큐만 사용하여 수행된다고 알고 있는데, 이것은 완전히 잘못된 생각이다.</p>\n<h3 id=\"이벤트-루프는-여러-개의-스레드에서-실행된다\" style=\"position:relative;\">이벤트 루프는 여러 개의 스레드에서 실행된다<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EB%8A%94-%EC%97%AC%EB%9F%AC-%EA%B0%9C%EC%9D%98-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EB%90%9C%EB%8B%A4\" aria-label=\"이벤트 루프는 여러 개의 스레드에서 실행된다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Node.js 이벤트 루프의 잘못된 다이어그램들 때문에 우리는 한 개의 스레드가 자바스크립트의 실행을 담당하고 다른 한 개는 이벤트 루프를 담당하는, 총 두 개의 스레드가 있다고 생각하게 되었다. <small>(필자도 자바스크립트 뉴비 시절에 그렇게 생각했다.)</small></p>\n<p>그러나 실제로는 단일 스레드로 이 모든 것을 처리한다.</p>\n<h3 id=\"settimeout은-일부-비동기-os-api와-관련있다\" style=\"position:relative;\">setTimeout은 일부 비동기 OS API와 관련있다.<a href=\"#settimeout%EC%9D%80-%EC%9D%BC%EB%B6%80-%EB%B9%84%EB%8F%99%EA%B8%B0-os-api%EC%99%80-%EA%B4%80%EB%A0%A8%EC%9E%88%EB%8B%A4\" aria-label=\"settimeout은 일부 비동기 os api와 관련있다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>또 다른 큰 오해는 <code class=\"language-text\">setTimeout</code>의 딜레이가 끝났을 때 콜백이 외부의 요인으로 인해<small>(OS나 커널 같은)</small> 의해 어떤 작업 큐에 들어가게 된다고 생각하는 것이다. 하지만 이벤트 루프에 이런 외부의 요인 같은 건 없다. 우리는 밑에서 이 메커니즘에 대해서 좀 더 자세히 알아볼 것이다.</p>\n<h3 id=\"setimmediate의-콜백은-작업-큐의-가장-첫번째에-위치한다\" style=\"position:relative;\">setImmediate의 콜백은 작업 큐의 가장 첫번째에 위치한다<a href=\"#setimmediate%EC%9D%98-%EC%BD%9C%EB%B0%B1%EC%9D%80-%EC%9E%91%EC%97%85-%ED%81%90%EC%9D%98-%EA%B0%80%EC%9E%A5-%EC%B2%AB%EB%B2%88%EC%A7%B8%EC%97%90-%EC%9C%84%EC%B9%98%ED%95%9C%EB%8B%A4\" aria-label=\"setimmediate의 콜백은 작업 큐의 가장 첫번째에 위치한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>보통 일반적인 이벤트 루프에 대한 설명들은 하나의 큐만 가지고 설명을 진행하기 때문에, 몇몇 개발자들은 <code class=\"language-text\">setImmediate()</code>가 콜백을 작업 큐의 가장 앞쪽에 배치하는 API라고 생각하게 된다. 하지만 이것은 완전히 틀린 생각이며, 모든 작업 큐들은 FIFO(First In First Out)로만 작동한다. <small>(역주: 큐에 들어있는 작업의 포지션을 절대 변경하지 않는다는 것이다. 무조건 큐에 먼저 들어간 작업이 먼저 실행된다.)</small></p>\n<h2 id=\"이벤트-루프의-구조\" style=\"position:relative;\">이벤트 루프의 구조<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\"이벤트 루프의 구조 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>일단 이벤트 루프의 구조를 이해하기 위해서는 이벤트 루프의 흐름에 대해서 알고 있어야 한다. 이미 한번 언급했듯이, 거시적인 하나의 큐만 보는 것은 이벤트 루프를 이해하는 데 별로 도움이 되지 않는다. 아래 그림이 이벤트 루프를 제대로 설명한 그림이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/dfece5e35b7d9e50b6eac8adb1a348b8/949b7/nodejs-event-loop-phase.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 90.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAABeklEQVR42p2Ua8uCQBCF+/8/zA+BBmVYlBSBVHbX7lkTz7wMqNmbtbDsbfbMmTmz25Ca7Xa7yeVyqTy73+86jkYjadQFBOx4POr88Xj8DmjGp9NJ9vv9C9jXgDDbbrfS6XRkNpvp+iuGGNuF6/Uqm81G1uu1AiVJonMDMNuPDBEgTVMFyLKscIYTGFs+KxnihYscYAiL8/msa2ORZ84++YQ9DgwwDMM/QPMaBIG0221ptVoyn88VtJwvHCPQeDwWz/Ok1+tJt9uV4XCodwsMydNisVAgwqbvdjuJokj7arXSMwMlmuVyqWzZGwwGrznk0EIAENbNZlMcxxHXdTWSfCPP/4qCGHnAOI6V3WQy0RGHHwHZgLKFyMi6rHA+j9YREA0KopA7cnI4HDQsmGDMuqyy7eO03++rgL7vKwbpeVs25Ro0tRmtTq28jCFKv316GBI+zKv2cZyvy1pPj4aqFDB9Op0Wnp7Zf/05wAow0lD1J/70H9b54gB8AlFufC5VPBD4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"nodejs event loop phase\" title=\"\" src=\"/static/dfece5e35b7d9e50b6eac8adb1a348b8/6af66/nodejs-event-loop-phase.png\" srcset=\"/static/dfece5e35b7d9e50b6eac8adb1a348b8/69538/nodejs-event-loop-phase.png 160w,\n/static/dfece5e35b7d9e50b6eac8adb1a348b8/72799/nodejs-event-loop-phase.png 320w,\n/static/dfece5e35b7d9e50b6eac8adb1a348b8/6af66/nodejs-event-loop-phase.png 640w,\n/static/dfece5e35b7d9e50b6eac8adb1a348b8/d9199/nodejs-event-loop-phase.png 960w,\n/static/dfece5e35b7d9e50b6eac8adb1a348b8/21b4d/nodejs-event-loop-phase.png 1280w,\n/static/dfece5e35b7d9e50b6eac8adb1a348b8/949b7/nodejs-event-loop-phase.png 1583w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이 그림에 표기된 각각의 박스는 특정 작업을 수행하기 위한 페이즈들을 의미한다. 각 페이즈는 각자 하나의 큐를 가지고 있으며, 자바스크립트의 실행은 이 페이즈들 중 <code class=\"language-text\">Idle, prepare</code> 페이즈를 제외한 어느 단계에서나 할 수 있다. <small>(이해를 돕기 위해 큐라고 설명했지만 사실 실제 자료구조는 큐가 아닐 수도 있다.)</small></p>\n<p>그리고 이 그림에서 <code class=\"language-text\">nextTickQueue</code>와 <code class=\"language-text\">microTaskQueue</code>를 볼 수 있는데, 이 큐들은 이벤트 루프의 일부가 아니며, 이 큐들에 들어있는 작업 또한 어떤 페이즈에서든 실행될 수 있다. 또한 이 큐들에 들어있는 작업은 가장 높은 실행 우선 순위를 가지고 있다.</p>\n<p>이제 우리는 이벤트 루프가 각자 다른 여러 개의 페이즈들과 큐들의 조합으로 이루어져 있다는 것을 알게 되었다. 이제 각각의 페이즈가 어떤 작업을 수행하는 지 알아보자.</p>\n<h3 id=\"timer-phase\" style=\"position:relative;\">Timer phase<a href=\"#timer-phase\" aria-label=\"timer phase permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Timer phase</code>는 이벤트 루프의 시작을 알리는 페이즈이다. 이 페이즈가 가지고 있는 큐에는 <code class=\"language-text\">setTimeout</code>이나 <code class=\"language-text\">setInterval</code> 같은 타이머들의 콜백을 저장하게 된다. 이 페이즈에서 바로 타이머들의 콜백이 큐에 들어가는 것은 아니지만 타이머들을 <code class=\"language-text\">min-heap</code>으로 유지하고 있다가 실행할 때가 된 타이머들의 콜백을 큐에 넣고 실행하는 것이다.</p>\n<blockquote>\n<p><strong>역주</strong>: 힙(Heap)은 완전 이진트리의 일종으로 어느 정도의 느슨한 정렬을 사용하여 값들의 집합에서 최대 값이나 최소 값을 찾아내는 작업에 특화되어 있다. min-heap은 상위 레벨의 노드가 하위 레벨의 노드들보다 작거나 같은 구조이므로 타이머가 실행되어야하는 순서대로 저장하기에 알맞는 자료 구조라고 할 수 있다.</p>\n<p>그리고 큐에 콜백을 넣는다는 것은, 이 콜백들을 실행하겠다는 것을 의미하므로 타이머가 생성되지마자 큐에 콜백을 넣는 것이 아니라 별도의 힙에 타이머를 저장하고나서 매 Timer phase 때 어떤 타이머가 실행할 때가 되었는지를 검사한 후, 실행되어야 하는 콜백만 큐에 넣는다는 것이다. 이 과정에 대한 자세한 내용은 밑에서 다시 설명하겠다.</p>\n</blockquote>\n<h3 id=\"pending-io-callback-phase\" style=\"position:relative;\">Pending i/o callback phase<a href=\"#pending-io-callback-phase\" aria-label=\"pending io callback phase permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 페이즈에서는 이벤트 루프의 <code class=\"language-text\">pending_queue</code>에 들어있는 콜백들을 실행한다. 이 큐에 들어와있는 콜백들은 현재 돌고 있는 루프 이전에 한 작업에서 이미 큐에 들어와있던 콜백들이다. 예를 들어 여러분이 TCP 핸들러 콜백 함수에서 파일에 뭔가를 썼다면 TCP 통신이 끝나고 파일 쓰기도 끝나고 나서 파일 쓰기의 콜백이 이 큐에 들어오는 것이다.<small>(파일 쓰기는 보통 비동기로 이루어진다.)</small> 또한 에러 핸들러 콜백도 <code class=\"language-text\">pending_queue</code>로 들어오게 된다.</p>\n<h3 id=\"idle-prepare-phase\" style=\"position:relative;\">Idle, Prepare phase<a href=\"#idle-prepare-phase\" aria-label=\"idle prepare phase permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이름은 <code class=\"language-text\">Idle phase</code>이지만 이 페이즈는 매 Tick마다 실행된다. <code class=\"language-text\">Prepare phase</code> 또한 매 폴링(Polling)때마다 실행된다. 어쨌든 이 두개의 페이즈는 이벤트 루프와 직접적인 관련이 있다기보다는 Node.js의 내부적인 관리를 위한 것이기 때문에 이 포스팅에서는 설명하지 않는다.</p>\n<h3 id=\"poll-phase\" style=\"position:relative;\">Poll phase<a href=\"#poll-phase\" aria-label=\"poll phase permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자가 생각하기에 전체 이벤트 루프 중 가장 중요한 페이즈는 바로 이 <code class=\"language-text\">Poll phase</code>라고 생각한다. 이 페이즈에서는 새로운 수신 커넥션<small>(새로운 소켓 설정 등)</small>과 데이터<small>(파일 읽기 등)</small>를 허용한다. 우리는 여기서 일어나는 일을 크게 두 가지로 나눠볼 수 있다.</p>\n<hr>\n<ul>\n<li>만약 <code class=\"language-text\">watch_queue</code><small>(Poll phase가 가지고 있는 큐)</small>가 비어있지 않다면, 큐가 비거나 시스템 최대 실행 한도에 다다를 때까지 동기적으로 모든 콜백을 실행한다.</li>\n<li>일단 <code class=\"language-text\">watch_queue</code>가 비어있다면, Node.js는 곧바로 다음 페이즈로 넘어가는 것이 아니라 약간 대기시간을 가지게 된다. Node.js가 기다리는 시간은 여러 가지 요인에 따라 계산되는데, 이 부분은 밑에서 따로 설명하도록 하겠다.</li>\n</ul>\n<hr>\n<h3 id=\"check-phase\" style=\"position:relative;\">Check phase<a href=\"#check-phase\" aria-label=\"check phase permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Poll phase</code>의 다음 페이즈는 바로 <code class=\"language-text\">setImmediate</code>의 콜백만을 위한 페이즈인 <code class=\"language-text\">Check phase</code>이다. 이렇게 얘기하면 보통 하시는 질문은, “왜 setImmediate의 콜백만을 위한 큐인가요?”이다. 음, 그건 밑에서 필자가 워크 플로우 섹션에서 다시 얘기할 <code class=\"language-text\">Poll phase</code>에서 수행하는 행동들 때문이기도 하다. 일단 지금은 <code class=\"language-text\">Check phase</code>가 <code class=\"language-text\">setImmediate</code>의 콜백 전용 단계라는 사실만 기억하고 있자.</p>\n<h3 id=\"close-callbacks\" style=\"position:relative;\">Close callbacks<a href=\"#close-callbacks\" aria-label=\"close callbacks permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">socket.on('close', () => {})</code>과 같은 <code class=\"language-text\">close</code> 이벤트 타입의 핸들러들은 여기서 처리된다.</p>\n<h3 id=\"nexttickqueue와-microtaskqueue\" style=\"position:relative;\">nextTickQueue와 microTaskQueue<a href=\"#nexttickqueue%EC%99%80-microtaskqueue\" aria-label=\"nexttickqueue와 microtaskqueue permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">nextTickQueue</code>는 <code class=\"language-text\">process.nextTick()</code> API의 콜백들을 가지고 있으며, <code class=\"language-text\">microTaskQueue</code>는 Resolve된 프로미스의 콜백을 가지고 있다.</p>\n<p>이 두개의 큐는 기술적으로 이벤트 루프의 일부가 아니다. 즉, <code class=\"language-text\">libUV</code> 라이브러리에 포함된 것이 아니라 <code class=\"language-text\">Node.js</code>에 포함된 기술이라는 것이다. 이 친구들이 가지고 있는 작업들은 현재 실행되고 있는 작업이 끝나자마자 호출되어야한다.</p>\n<blockquote>\n<p><strong>역주</strong>: <a href=\"https://github.com/libuv/libuv\" target=\"_blank\" rel=\"nofollow\">libUV</a>는 Node.js에서 사용하는 비동기 I/O 라이브러리이다. 이 라이브러리는 C로 작성되었고 윈도우나 리눅스 커널을 추상화해서 Wrapping하고 있는 구조이다. 즉, 커널에서 어떤 비동기 작업들을 지원해주는 지 알고 있기 때문에 커널을 사용하여 처리할 수 있는 비동기 작업을 발견하면 바로 커널로 작업을 넘겨버린다.</p>\n<p>이후 이 작업들이 종료되어 OS 커널로부터 시스템 콜을 받으면 이벤트 루프에 콜백을 등록하는 것이다. 만약 OS 커널이 지원하지 않는 작업일 경우 별도의 스레드에 작업을 던져서 처리한다. 이 스레드에 관한 내용은 원작자가 밑에서 추가적으로 설명하고있다.</p>\n</blockquote>\n<h2 id=\"이벤트-루프의-작업-흐름\" style=\"position:relative;\">이벤트 루프의 작업 흐름<a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EC%9D%98-%EC%9E%91%EC%97%85-%ED%9D%90%EB%A6%84\" aria-label=\"이벤트 루프의 작업 흐름 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리가 <code class=\"language-text\">node my-script.js</code>를 콘솔에서 실행시켰을 때, Node.js는 이벤트 루프를 생성한 다음 <strong>이벤트 루프 바깥</strong>에서 메인 모듈인 <code class=\"language-text\">my-script.js</code>를 실행한다. 한번 메인 모듈이 실행되고나면 Node.js는 이벤트 루프가 활성 상태인지, 즉 이벤트 루프 안에서 해야할 작업이 있는지를 확인한다. 만약 이벤트 루프를 돌릴 필요가 없다면 Node.js는 <code class=\"language-text\">process.on('exit, () => {})</code>를 실행하고 이벤트 루프를 종료하려고 할 것이다.</p>\n<p>그러나 만약 이벤트 루프를 돌려야할 상황이라면 Node.js는 이벤트 루프의 첫 번째 페이즈인 <code class=\"language-text\">Timer phase</code>를 실행한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f9c11eeefdd25b07850636e84007db11/a4f52/nodejs-event-loop-workflow.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 78.75000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABeUlEQVR42o2U666CMBCE+/7vp6ISwR+KUUTEG15wT75NxjQeb00ase3Mzs5uGywat9vNzuezf9/vdzudTr6mva7r7NsI+rhcLrZarSzLMmuaxrbbrY1GIyvL0tq2teVyaev12vcU5CMh0aUAdYAAo1h7rB+PRw/+lhDg9Xp9gPQN0Ww2cxKlDBGKd7vde0KA8/nckiSxwWBgVVXZ4XCwzWbzABIEtayTOhMblBlBNYMAHGCqGPv93gGQolRAncdjArCOeoSQQYjlCoCauq79gII8dwNrBKVQZMk51sMrH9iAcDKZPJRCIJXyE6uGw6F3Rpqmrjq8M5e0i6LwqpLidDq1Xq9n4/HYgfIMYlKXn+FTk3JQoDzPvWgoiu0gUL/f9yL+8zDuSXkk0+Nq6r/aKz73kpAUSZdWYj7fDnkIOWrpTWXyklAFwEcAKIgrrQuAJYvFwj1VkGA/DLyKr6Ean0BqIVnwE6GaXa3EL9X/+Dh8G/EDET8kz4R/bwLkMJcqSxIAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"nodejs event loop workflow\" title=\"\" src=\"/static/f9c11eeefdd25b07850636e84007db11/6af66/nodejs-event-loop-workflow.png\" srcset=\"/static/f9c11eeefdd25b07850636e84007db11/69538/nodejs-event-loop-workflow.png 160w,\n/static/f9c11eeefdd25b07850636e84007db11/72799/nodejs-event-loop-workflow.png 320w,\n/static/f9c11eeefdd25b07850636e84007db11/6af66/nodejs-event-loop-workflow.png 640w,\n/static/f9c11eeefdd25b07850636e84007db11/d9199/nodejs-event-loop-workflow.png 960w,\n/static/f9c11eeefdd25b07850636e84007db11/21b4d/nodejs-event-loop-workflow.png 1280w,\n/static/f9c11eeefdd25b07850636e84007db11/a4f52/nodejs-event-loop-workflow.png 2024w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h3 id=\"timer-phase-1\" style=\"position:relative;\">Timer phase<a href=\"#timer-phase-1\" aria-label=\"timer phase 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이벤트 루프가 <code class=\"language-text\">Timer phase</code>에 들어가게 되면 실행할 타이머 콜백 큐에 뭐가 있는 지 확인부터 시작한다. 그냥 확인이라고 하면 간단해보이지만 사실 이벤트 루프는 적절한 콜백들을 찾기 위해 몇 가지 단계를 수행하게된다.\n위에서 설명했듯이 타이머 스크립트는 오름차순으로 힙에 저장된다. 그래서 제일 먼저 저장된 타이머들을 하나씩 까서 <code class=\"language-text\">now - registeredTime === delta</code> 같은 조건을 통해 타이머의 콜백을 실행할 시간이 되었는 지 검사하게 된다.<small>(역주: <code class=\"language-text\">delta</code>는 <code class=\"language-text\">setTimeout(() => {}, 10)</code>에서의 <code class=\"language-text\">10</code>)</small></p>\n<p>만약 조건에 해당된다면 이 타이머의 콜백을 실행하고 다음 타이머를 확인한다. 만약 조건에 해당하지 않는 타이머를 만난다면, 탐색을 바로 종료하고 다음 페이즈로 이동한다. 타이머는 힙 내부에 오름차순으로 정렬되어있기 때문에 그 이후로는 탐색을 해도 의미가 없기 때문이다.</p>\n<p>자, 예를 들어 딜레이 값이 <code class=\"language-text\">100</code>, <code class=\"language-text\">200</code>, <code class=\"language-text\">300</code>, <code class=\"language-text\">400</code>인 4개의 타이머(A, B, C, D)를 어떤 특정 시간 <code class=\"language-text\">t</code>에 힙에 등록했다고 가정해보자.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/87819ce16bd25b0803be9a4ebab03834/3534c/Screen-Shot-2018-02-18-at-12.50.48-PM.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 19.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAiUlEQVR42m2OSw7DIAxEc/87ElgA4ZeEwAEcPUtUldrFyPLzeDRb712u61Ld9y3P88g/xlyM+xjjh6HtPE+x1qpqrcKec5Z931Ww1tqHOefUA08piTFGGeEaiDnGKMdxSClFxXMIQRlP7Ex2vPysnYl3tdRAAEbC5pzaAIZ5MRrBvPfaBrZCvwNfylArWSyIdCMAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Screen Shot 2018 02 18 at 12 50 48 PM\" title=\"\" src=\"/static/87819ce16bd25b0803be9a4ebab03834/6af66/Screen-Shot-2018-02-18-at-12.50.48-PM.png\" srcset=\"/static/87819ce16bd25b0803be9a4ebab03834/69538/Screen-Shot-2018-02-18-at-12.50.48-PM.png 160w,\n/static/87819ce16bd25b0803be9a4ebab03834/72799/Screen-Shot-2018-02-18-at-12.50.48-PM.png 320w,\n/static/87819ce16bd25b0803be9a4ebab03834/6af66/Screen-Shot-2018-02-18-at-12.50.48-PM.png 640w,\n/static/87819ce16bd25b0803be9a4ebab03834/3534c/Screen-Shot-2018-02-18-at-12.50.48-PM.png 808w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이제 이벤트 루프가 <code class=\"language-text\">t+250</code>에 Timer phase에 진입했다고 생각해보자.</p>\n<p>가장 먼저 타이머 A를 찾아낸 후 만료 기간이 <code class=\"language-text\">t+100</code>이라는 것을 알게 될 것이다. 그러나 지금은 이미 <code class=\"language-text\">t+250</code>이기 때문에 타이머 A의 콜백은 실행될 것이다. 그리고 타이머 B를 찾아내어 만료 기간이 <code class=\"language-text\">t+200</code>임을 체크하게되고, 타이머 B의 콜백 역시 실행된다.</p>\n<p>이제 타이머 C를 체크하게 되는데 이 타이머의 딜레이는 <code class=\"language-text\">t+300</code>이기 때문에 바로 페이즈가 종료된다. 이벤트 루프는 타이머 D는 체크하지 않는데, 위에서 설명했듯이 타이머들은 만료 기간 순으로 오름차순 정렬되어있기 때문에 타이머 C의 뒤쪽에는 어차피 타이머 C보다 만료 기간이 긴 타이머들만 있기 때문이다.</p>\n<p>참고로 페이즈는 시스템의 실행 한도에도 영향을 받고 있으므로, 실행 되어야하는 타이머가 아직 남아 있다고 하더라도 시스템 실행 한도에 도달한다면 바로 다음 페이즈로 넘어가게된다.</p>\n<h3 id=\"pending-io-phase\" style=\"position:relative;\">Pending i/o phase<a href=\"#pending-io-phase\" aria-label=\"pending io phase permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>타임 페이즈가 종료된 후 이벤트 루프는 Pending i/o 페이즈에 진입하고, 가장 먼저 이전 작업들의 콜백이 실행 대기 중인지, 즉 <code class=\"language-text\">pending_queue</code>에 들어와 있는지를 체크하게 된다. 만약 실행 대기 중이라면 <code class=\"language-text\">pending_queue</code>가 비거나 시스템의 실행 한도 초과에 도달할 때까지 대기하고 있던 콜백들을 실행한다. 이 과정이 종료되면 이벤트 루프는 <code class=\"language-text\">Idle Handler Phase</code>로 이동하게 된 후 내부 처리를 위한 <code class=\"language-text\">Prepare phase</code>를 거쳐 최종적으로 가장 중요한 단계인 <code class=\"language-text\">Poll Phase</code>에 도달하게 된다.</p>\n<h3 id=\"poll-phase-1\" style=\"position:relative;\">Poll phase<a href=\"#poll-phase-1\" aria-label=\"poll phase 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이름에서 알 수 있듯이 이 페이즈는 폴링하는 단계이다. 이벤트 루프가 <code class=\"language-text\">Poll phase</code>에 들어왔을 때 <code class=\"language-text\">watcher_queue</code> 내부에 파일 읽기의 응답 콜백, HTTP 응답 콜백 같이 수행해야 할 작업들이 있다면 이 작업들을 실행하게 된다. 이 과정 또한 <code class=\"language-text\">watcher_queue</code>가 비거나 시스템의 실행 한도 초과에 다다를 때까지 계속 된다.</p>\n<p>만약 더 이상 콜백들을 실행할 수 없는 상태가 된다면 만약 <code class=\"language-text\">check_queue</code>, <code class=\"language-text\">pending_queue</code>, <code class=\"language-text\">closing_callbacks_queue</code>에 해야할 작업이 있는지를 검사하고, 만약 해야할 작업이 있다면 바로 <code class=\"language-text\">Poll phase</code>가 종료되고 다음 페이즈로 넘어가게 된다. 하지만 특별히 해야할 작업이 더 이상 없는 경우 <code class=\"language-text\">Poll phase</code>는 다음 페이즈로 넘어가지 않고 계속 대기하게 된다.</p>\n<p>이때도 마냥 무한 대기를 하는 것은 아니고, 타이머 힙에서 첫번째 타이머를 꺼내본 다음에 만약 해당 타이머가 실행 가능한 상태라면 그 타이머의 딜레이 시간만큼만 대기 시간을 결정한다.</p>\n<blockquote>\n<p><strong>역주</strong>: 결국 Poll phase에서 더 이상 수행할 작업이 없는 경우 다음 페이즈로 넘어가는 조건은 다음과 같다.</p>\n<ol>\n<li><code class=\"language-text\">Check phase</code>에 실행할 콜백이 있냐? 바로 다음 페이즈로 고고</li>\n<li><code class=\"language-text\">Check phase</code>에도 실행할 콜백이 없어? 그럼 타이머는 있어? 있다면 그 타이머를 실행 할 수 있는 시간이 될 때까지만 대기하고 바로 Timer phase로 고고</li>\n<li>없어? 그럼 일 생길 때까지 대기…</li>\n</ol>\n<p>2번 조건에서 타이머가 있다고 바로 Timer phase로 넘어가지 않고 대기하는 이유는, 대기하지않고 바로 Timer phase로 넘어갈 경우 어차피 첫번째 타이머를 실행할 수 있는 시간이 안되었기 때문에 Timer phase에서도 아무것도 수행하지 않고 Timer phase가 끝나버리기 때문이다. 그렇게 되면 굳이 이벤트 루프를 한번 더 돌아야지 해당 타이머를 실행할 수 있게되므로 그냥 Poll phase에서 대기하는 게 더 이득인 것이다.</p>\n</blockquote>\n<h3 id=\"check-phase-1\" style=\"position:relative;\">Check phase<a href=\"#check-phase-1\" aria-label=\"check phase 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Poll phase</code>가 지나면 이벤트 루프는 바로 <code class=\"language-text\">setImmediate()</code> API의 콜백과 관련이 있는 <code class=\"language-text\">Check phase</code>에 들어서게 된다. 이 페이즈에서는 다른 페이즈와 마찬가지로 큐가 비거나 시스템 실행 한도 초과에 도달할 때까지 계속 해서 <code class=\"language-text\">setImmediate</code>의 콜백들을 실행한다.</p>\n<h3 id=\"close-callback\" style=\"position:relative;\">Close callback<a href=\"#close-callback\" aria-label=\"close callback permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Check Phase</code>가 종료된 후에, 이벤트 루프의 다음 목적지는 <code class=\"language-text\">close</code>나 <code class=\"language-text\">destory</code> 콜백 타입들을 관리하는 <code class=\"language-text\">Close callback</code>이다.</p>\n<p>이벤트 루프가 <code class=\"language-text\">Close callback</code>들과 함께 종료되고나면 이벤트 루프는 다음에 돌아야할 루프가 있는지 다시 체크 하게 된다. 만약 아니라면 그대로 이벤트 루프는 종료된다. 하지만 만약 더 수행해야할 작업들이 남아 있다면 이벤트 루프는 다음 순회를 돌기 시작하고 다시 <code class=\"language-text\">Timer Phase</code>부터 시작하게 된다.</p>\n<p>아까 위에서 설명했던 <code class=\"language-text\">Timer Phase</code>에서의 예시를 다시 가져오자면, 이제 다음 루프의 <code class=\"language-text\">Timer Phase</code>에서는 타이머 C의 만료 시간이 경과했는지부터 확인을 시작할 것이다.</p>\n<h3 id=\"nexttickqueue--microtaskqueue\" style=\"position:relative;\">nextTickQueue &#x26; microTaskQueue<a href=\"#nexttickqueue--microtaskqueue\" aria-label=\"nexttickqueue  microtaskqueue permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>근데 이벤트 루프의 일부가 아닌 이 두 큐에 들어있는 콜백들은 언제 실행되는 걸까? 이 두 큐의 콜백들은 어떤 페이즈에서 다음 페이즈로 넘어가기 전에 자신이 가지고 있는 콜백들을 최대한 빨리 실행해야하는 역할을 맡고 있다.<small>(역주: 페이즈에서 다른 페이즈로 넘어가는 과정을 Tick이라고 부른다.)</small></p>\n<p>다른 페이즈들과는 다르게 이 두 큐는 시스템 실행 한도 초과에 영향을 받지 않기 때문에 Node.js는 이 큐가 완전히 비워질 때까지 콜백들을 실행한다. 그리고 <code class=\"language-text\">nextTickQueue</code>는 <code class=\"language-text\">microTaskQueue</code>보다는 높은 우선 순위를 가지고 있다.</p>\n<h3 id=\"thread-pool\" style=\"position:relative;\">Thread-pool<a href=\"#thread-pool\" aria-label=\"thread pool permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자가 자바스크립트 개발자에게 가장 많이 들은 단어는 바로 스레드풀(ThreadPoll)이다. 그리고 이와 관련된 가장 큰 오해는 바로 Node.js가 모든 비동기 명령을 관리하는 별도의 스레드풀을 가지고 있다는 것이다. 그러나 이 스레드풀은 Node.js가 아니라 Node.js가 비동기 작업을 처리하기 위해 사용하는 라이브러리인 <code class=\"language-text\">libUV</code>에 포함된 기능이라는 것이다.</p>\n<p>필자가 이벤트 루프의 다이어그램에 스레드풀을 별도로 표시하지 않은 이유는 스레드풀 자체가 이벤트 루프 매커니즘의 일부가 아니기 때문이다. <code class=\"language-text\">libUV</code>는 OS커널의 비동기 API만을 사용하여 이벤트 드리븐을 유도할 수 있을 만큼 충분히 훌륭하다. 그러나 파일 읽기, DNS Lookup 등 OS 커널이 비동기 API를 지원하지않는 작업들의 경우에는 별도의 스레드풀을 사용하게 되는데, 이때 기본 값으로 4개의 스레드를 사용하도록 설정되어있다. <code class=\"language-text\">uv_threadpool</code> 환경 변수를 사용하면 최대 128개까지 스레드 개수를 늘릴 수도 있다.</p>\n<h2 id=\"workflow-with-examples\" style=\"position:relative;\">Workflow with examples<a href=\"#workflow-with-examples\" aria-label=\"workflow with examples permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이제 이 동기식 무한 루프가 자바스크립트를 비동기식으로 작동하게 하기 위해 얼마나 큰 역할을 하고 있는 지 이해했기 바란다. 이 구조는 한번에 단 한개의 작업만 실행하고 있지만 그 어떤 것도 블로킹하지 않는다. 어쨌든 백문이불여일견이니, 코드 스니펫으로 이 구조를 다시 이해해보는 시간을 가져보도록 하자.</p>\n<h3 id=\"snippet-1--기초-이해\" style=\"position:relative;\">Snippet 1 – 기초 이해<a href=\"#snippet-1--%EA%B8%B0%EC%B4%88-%EC%9D%B4%ED%95%B4\" aria-label=\"snippet 1  기초 이해 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setImmediate'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 결과를 예측할 수 있겠는가? 아마도 여러분은 <code class=\"language-text\">setTimeout</code>이 먼저 출력된다고 생각하겠지만, 사실 장담할 수 없다.</p>\n<p>왜냐? 메인 모듈이 실행되고나서 이벤트 루프가 <code class=\"language-text\">Timer phase</code>에 진입할 때 여러분의 타이머를 찾을 수도 있고 못 찾을 수도 있기 때문이다. 왜냐면 타이머는 시스템의 시간과 사용자가 제공한 시간을 사용하여 등록되기 때문이다. <code class=\"language-text\">setTimeout</code>이 호출된 순간, 타이머는 메모리에 이 타이머를 저장하게되는데, 그 순간 컴퓨터의 성능이나 Node.js가 아닌 외부 작업 때문에 약간의 딜레이가 발생할 수 있기 때문이다.</p>\n<p>또 다른 포인트는 Node.js가 <code class=\"language-text\">Timer phase</code>에 진입하기 전에 변수 <code class=\"language-text\">now</code>를 선언하고 그 변수 <code class=\"language-text\">now</code>를 현재 시간으로 간주한다는 점이다. 그러므로 정확한 계산이라고 하기에는 약간의 노이즈가 껴있다는 것이고, 이게 바로 <code class=\"language-text\">setTimeout</code>이 반드시 먼저 실행될 것이라고 확신할 수 없는 불확실성의 이유가 된다.</p>\n<p>그러나 만약 여러분이 이 코드를 I/O 사이클의 내부로 옮긴다면, 반드시 <code class=\"language-text\">setTimeout</code>보다 <code class=\"language-text\">setImmediate</code>가 먼저 실행되는 것을 보장할 수 있게된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">'my-file-path.txt'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setImmediate'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p><strong>역주</strong>: 위 스니펫은 다음과 같은 순서로 실행된다.</p>\n<ol>\n<li><code class=\"language-text\">fs.readFile</code>을 만나면 이벤트 루프는 libUV에게 해당 작업을 던짐.</li>\n<li>파일 읽기는 OS 커널에서 비동기 API를 제공하지 않기 때문에 libUV는 별도의 스레드에 해당 작업을 던짐</li>\n<li>작업이 완료되면 이벤트 루프는 <code class=\"language-text\">Pending i/o callback phase</code>의 <code class=\"language-text\">pending_queue</code>에 작업의 콜백을 등록</li>\n<li>이벤트 루프가 <code class=\"language-text\">Pending i/o callback phase</code>를 지날 때 해당 콜백을 실행</li>\n<li><code class=\"language-text\">setTimeout</code>이 <code class=\"language-text\">Timer phase</code>의 큐에 등록됨. 해당 콜백은 다음 <code class=\"language-text\">Timer phase</code> 때 실행될 것이다.</li>\n<li><code class=\"language-text\">setImmediate</code>의 콜백이 <code class=\"language-text\">Check phase</code>의 <code class=\"language-text\">check_queue</code>에 등록됨.</li>\n<li><code class=\"language-text\">Poll phase</code>에서는 딱히 할 일이 없지만, <code class=\"language-text\">Check phase</code>의 큐에 작업이 있으므로 바로 <code class=\"language-text\">Check phase</code>로 이동</li>\n<li>setImmediate 콘솔 출력. <code class=\"language-text\">Timer phase</code>에는 타이머가 등록되어 있으므로 다시 이벤트 루프가 시작된다.</li>\n<li><code class=\"language-text\">Timer phase</code>에서 타이머를 검사, 딜레이가 0이므로 <code class=\"language-text\">setTimeout</code>의 콜백을 바로 실행한다.</li>\n<li>setTimeout 콘솔 출력</li>\n</ol>\n<p>즉, 이런 과정을 거치기 때문에 <code class=\"language-text\">setImmediate</code>의 콜백이 반드시 <code class=\"language-text\">setTimeout</code>보다 먼저 실행되는 것을 보장할 수 있는 것이다.</p>\n</blockquote>\n<h3 id=\"snippet-2--타이머들을-더-잘-이해하기\" style=\"position:relative;\">Snippet 2 – 타이머들을 더 잘 이해하기<a href=\"#snippet-2--%ED%83%80%EC%9D%B4%EB%A8%B8%EB%93%A4%EC%9D%84-%EB%8D%94-%EC%9E%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\"snippet 2  타이머들을 더 잘 이해하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> start <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> end <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Execution time: \"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>end <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위의 예시는 굉장히 간단하다. 함수 <code class=\"language-text\">foo</code>는 <code class=\"language-text\">setImmediate()</code>에 의해서 1000번 재귀호출되고 있다. 이 코드를 필자의 맥북 프로에서 Node.js 8.9.1을 사용하여 실행하면 함수가 종료되기까지 <code class=\"language-text\">6-8ms</code>정도가 걸린다. 이제 위의 스니펫을 <code class=\"language-text\">setImmediate(foo)</code>에서 <code class=\"language-text\">setTimeout(foo, 0)</code>으로 변경해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> start <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> end <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Execution time: \"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>end <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 필자의 컴퓨터에서 이 코드가 실행되는데 걸리는 시간은 대략 <code class=\"language-text\">1400+ ms</code>정도이다.</p>\n<p>왜 이렇게 되는걸까? 이 두 경우 모두 폴링에 걸리는 시간은 <code class=\"language-text\">0</code>이기 때문에 동일하게 작동해야한다. 근데 왜 이렇게 실행 시간이 많이 차이가 나게 된 걸까?</p>\n<p>그 이유는 바로 시간을 비교하고 편차를 알아내는 작업이 CPU를 집중적으로 사용하는 작업이기 때문에 시간이 더 오래 걸리기 때문이다. 그리고 타이머 스크립트를 등록하는 것 자체도 시간을 소모한다. 위에서 설명했듯이 Timer phase에서는 타이머를 실행할 시간이 되었는지, 콜백을 실행해야 하는지를 검사하기 위해 몇가지 작업을 거쳐야 하는데 이 과정을 매 이터레이션마다 하고 있으니 느려질 수 밖에 없다. 그러나 <code class=\"language-text\">setImmediate</code>의 경우 이런 과정이 필요없기 때문에 <code class=\"language-text\">setTimeout</code>보다 실행 속도가 빠른 것이다.</p>\n<h3 id=\"snippet-3--nexttick과-타이머-실행에-대해-이해하기\" style=\"position:relative;\">Snippet 3 – nextTick()과 타이머 실행에 대해 이해하기<a href=\"#snippet-3--nexttick%EA%B3%BC-%ED%83%80%EC%9D%B4%EB%A8%B8-%EC%8B%A4%ED%96%89%EC%97%90-%EB%8C%80%ED%95%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\" aria-label=\"snippet 3  nexttick과 타이머 실행에 대해 이해하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">></span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"setTimeout\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>   \n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 코드의 로그는 어떻게 출력될까? 첫번째 출력은 <code class=\"language-text\">foo</code>들이 될 것이고 기 후 <code class=\"language-text\">setTimeout</code>들이 출력된다. 제일 처음 코드를 실행하면 2ms 후에 첫 번째 <code class=\"language-text\">foo</code>가 출력되고 다음 <code class=\"language-text\">nextTickQueue</code>에 다시 <code class=\"language-text\">foo()</code>를 넣게된다.</p>\n<p>그리고 <code class=\"language-text\">nextTickQueue</code>에 들어간 콜백들은 한 페이즈에서 다음 페이즈로 넘어갈 때마다 무조건 콜백들을 동기적으로 실행해야한다. 그렇기 때문에 재귀호출로 <code class=\"language-text\">nextTickQueue</code>에 들어간 모든 콜백들을 실행하고 나서야 Timer Phase에서 <code class=\"language-text\">setTimeout</code> 콜백을 처리할 수 있게 되는 것이다.</p>\n<p>코드를 약간 수정하고 다시 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">></span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"setTimeout\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Other setTimeout\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>필자는 기존의 <code class=\"language-text\">setTimeout</code>과 같은 딜레이 시간을 가진 <code class=\"language-text\">setTimeout</code>을 추가했고, 이 타이머의 콜백은 단지 <code class=\"language-text\">Other setTimeout</code>을 출력하기만 한다. 뭐, 확실하다고 말할 수는 없지만 한 개의 <code class=\"language-text\">foo</code>가 먼저 출력된 후 <code class=\"language-text\">Other setTimeout</code>이 출력될 찬스가 존재하긴 한다. 타이머들이 들어있는 힙 내부에 동일한 딜레이를 가진 타이머들은 어떻게든 그룹화되어있고, <code class=\"language-text\">nextTickQueue</code>의 체크는 진행 중인 콜백 그룹의 실행이 끝난 후에야 진행되기 때문이다.</p>\n<blockquote>\n<p><strong>역주</strong>: 첫 번째 setTimeout의 콜백과 두 번쨰 setTimeout의 콜백이 실행될 시간이 동일하기 때문에 Timer phase에서 두 타이머의 콜백이 모두 큐에 들어갔고, 일단 큐에 들어갔으면 시스템 실행 한도에 걸리지 않는 이상 무조건 해당 페이즈가 끝나기 전에 실행된다.</p>\n<p>이런 경우, <code class=\"language-text\">foo()</code> 내부의 <code class=\"language-text\">process.nextTick</code>의 콜백은 Timer phase에서 다음 페이즈로 넘어갈 때 실행될 것이기 때문에 <code class=\"language-text\">foo</code>가 먼저 한 개 출력되고 <code class=\"language-text\">Other setTimeout</code>이 출력되는 것이다.</p>\n</blockquote>\n<h2 id=\"몇-가지-일반적인-질문들\" style=\"position:relative;\">몇 가지 일반적인 질문들<a href=\"#%EB%AA%87-%EA%B0%80%EC%A7%80-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%A7%88%EB%AC%B8%EB%93%A4\" aria-label=\"몇 가지 일반적인 질문들 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"그럼-자바스크립트는-정확히-어디에서-실행되는건가요\" style=\"position:relative;\">그럼 자바스크립트는 정확히 어디에서 실행되는건가요?<a href=\"#%EA%B7%B8%EB%9F%BC-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%A0%95%ED%99%95%ED%9E%88-%EC%96%B4%EB%94%94%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94%EA%B1%B4%EA%B0%80%EC%9A%94\" aria-label=\"그럼 자바스크립트는 정확히 어디에서 실행되는건가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 포스트를 처음 읽을 때는 자바스크립트가 정확히 어디서 실행되는지 헷갈릴 수 있다.</p>\n<p>앞서 말했듯이 이벤트 루프 자체에서 V8 또는 다른 엔진을 사용하여 자바스크립트를 실행하는 것이고 이때, 단 하나의 스레드를 사용하여 자바스크립트가 실행되는 것이다. 실행 자체는 동기적이고, 현재 실행시킨 자바스크립트의 실행이 완료되지 않는다면 이벤트 루프 또한 진행되지 않는다.</p>\n<h3 id=\"왜-우리는-settimeoutfn-0가-있는데도-setimmediate를-사용해야-하나요\" style=\"position:relative;\">왜 우리는 setTimeout(fn, 0)가 있는데도 setImmediate를 사용해야 하나요?<a href=\"#%EC%99%9C-%EC%9A%B0%EB%A6%AC%EB%8A%94-settimeoutfn-0%EA%B0%80-%EC%9E%88%EB%8A%94%EB%8D%B0%EB%8F%84-setimmediate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"왜 우리는 settimeoutfn 0가 있는데도 setimmediate를 사용해야 하나요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>일단, <code class=\"language-text\">setTimeout(fn, 0)</code>은 실질적으로 0이 아니다. 이건 사실 1이다. 여러분이 타이머의 딜레이를 <code class=\"language-text\">1ms</code>보다 작거나 <code class=\"language-text\">2147483647ms</code>보다 크게 설정하면 딜레이는 자동으로 <code class=\"language-text\">1</code>로 세팅된다. 그렇기 때문에 <code class=\"language-text\">setTimeout</code>의 딜레이를 <code class=\"language-text\">0</code>으로 설정하려고 한다면 이 딜레이는 자동으로 <code class=\"language-text\">1</code>이 되는 것이다.</p>\n<p>이미 설명했던 대로 <code class=\"language-text\">setImmediate</code>을 사용하면 타이머를 사용할 때처럼 딜레이의 시간이 지났지 뭐니 하는 추가적인 체크 로직이 필요없어진다. 그래서 <code class=\"language-text\">setImmediate</code>은 빠른 것이다. 또한 <code class=\"language-text\">setImmediate</code>의 체크 작업은 Poll phase 직후에 수행되기 때문에 HTTP 요청 콜백과 같은 곳에서 사용된 <code class=\"language-text\">setImmediate</code>의 콜백 함수는 바로 실행된다고 할 수 있다.</p>\n<h3 id=\"왜-setimmediate는-immediate즉시라고-부르는-건가요\" style=\"position:relative;\">왜 setImmediate는 Immediate(즉시)라고 부르는 건가요?<a href=\"#%EC%99%9C-setimmediate%EB%8A%94-immediate%EC%A6%89%EC%8B%9C%EB%9D%BC%EA%B3%A0-%EB%B6%80%EB%A5%B4%EB%8A%94-%EA%B1%B4%EA%B0%80%EC%9A%94\" aria-label=\"왜 setimmediate는 immediate즉시라고 부르는 건가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">setImmediate</code>와 <code class=\"language-text\">process.nextTick</code> 모두 이름이 잘못 되었다고 생각한다. 사실 <code class=\"language-text\">setImmediate</code>은 한번의 Tick 또는 루프가 돌 때마다 관리되고, <code class=\"language-text\">nextTick</code>은 한 페이즈에서 다음 페이즈로 넘어가는 매 Tick마다 최대한 빨리 호출되도록 작동하고 있다. 그래서 기능적으로는 <code class=\"language-text\">setImmediate</code>이 <code class=\"language-text\">nextTick</code>이라는 이름이 더 잘 어울리고 <code class=\"language-text\">nextTick</code>이 진짜로 즉시(Immediately) 호출되는 친구다. 😛</p>\n<h3 id=\"자바스크립트는-block-될-수-있는-건가요\" style=\"position:relative;\">자바스크립트는 Block 될 수 있는 건가요?<a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-block-%EB%90%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EA%B1%B4%EA%B0%80%EC%9A%94\" aria-label=\"자바스크립트는 block 될 수 있는 건가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이미 위에서 설명했듯이 <code class=\"language-text\">nextTickQueue</code>는 콜백 실행에 있어서 어떤 제한도 가지고 있지 않다. 그렇기 때문에 만약 <code class=\"language-text\">process.nextTick()</code>이 재귀 호출된다면, 여러분의 프로그램은 다른 페이즈들의 큐가 어떤 콜백을 가지고 있든간에 절대 그 작업에서 빠져나오지 못할 것이다.</p>\n<h3 id=\"만약-exit-callback-phase에서-settimeout을-호출하면-어떻게-되나요\" style=\"position:relative;\">만약 Exit callback phase에서 setTimeout을 호출하면 어떻게 되나요?<a href=\"#%EB%A7%8C%EC%95%BD-exit-callback-phase%EC%97%90%EC%84%9C-settimeout%EC%9D%84-%ED%98%B8%EC%B6%9C%ED%95%98%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%90%98%EB%82%98%EC%9A%94\" aria-label=\"만약 exit callback phase에서 settimeout을 호출하면 어떻게 되나요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>뭐, 타이머 자체는 시작될 수 있겠지만 <code class=\"language-text\">setTimeout</code>의 콜백은 절대 호출되지 않을 것이다. 이미 Node.js가 Exit callbacks에 들어와 있다는 것은 이미 이벤트 루프에서 빠져나왔다는 것을 의미한다.</p>\n<h2 id=\"짧은-정리들\" style=\"position:relative;\">짧은 정리들<a href=\"#%EC%A7%A7%EC%9D%80-%EC%A0%95%EB%A6%AC%EB%93%A4\" aria-label=\"짧은 정리들 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<hr>\n<ul>\n<li>이벤트 루프는 작업 스택을 가지고 있지 않다.</li>\n<li>이벤트 루프가 별도의 스레드에서 실행되고 자바스크립트 실행은 어떤 큐에서 하나씩 꺼내와서 다른 곳에서 하는 것이 아니라 자바스크립트의 실행 자체가 이벤트 루프 안에서 수행되는 것이다.</li>\n<li><code class=\"language-text\">setImmediate</code>는 콜백을 작업 큐의 앞 쪽에 밀어넣는 것이 아니라 <code class=\"language-text\">setImmediate</code> 만을 처리하기 위한 전용 페이즈와 큐가 존재한다.</li>\n<li><code class=\"language-text\">setImmediate</code>은 실질적으로 다음 페이즈 혹은 다음 이벤트 루프의 순회에서 실행되고, <code class=\"language-text\">nextTick</code>이 오히려 실질적으로 더 빠르게 실행된다.</li>\n<li><code class=\"language-text\">nextTickQueue</code>에 담긴 작업이 재귀 호출을 수행하는 경우 Node.js의 작업 프로세스를 블록킹할 수 있다. 주의하도록 하자.</li>\n</ul>\n<hr>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 Node.js 코어 개발 팀이 아니다. 이 포스팅에 관한 필자의 모든 지식은 실험과 다른 포스팅들을 통해 얻은 것이다. 필자가 이 지식들을 얻기 위해 가장 큰 도움을 준 <a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"nofollow\">Node.js 공식 문서</a>에 감사한다.\n두 번째로 도움이 많이 된 포스트는 Saúl Ibarra Corretgé의 <a href=\"https://www.youtube.com/watch?v=sGTRmPiXD4Y\" target=\"_blank\" rel=\"nofollow\">talk on libUV</a> 포스팅이다.\n그리고 세 번째로 VoidCanvas 독자 분들 덕분에 이런 건강한 토론과 실험, 관찰을 할 수 있도록 된 것에 감사한다. 🙂</p>","fields":{"slug":"20190801-nodejs-event-loop-workflow","path":"/2019/08/01/nodejs-event-loop-workflow/","lang":"ko"},"frontmatter":{"title":"[번역] 로우 레벨로 살펴보는 Node.js 이벤트 루프","subTitle":null,"date":"Aug 01, 2019","categories":["프로그래밍","자바스크립트"],"tags":["JavaScript","자바스크립트","NodeJS","Event Loop","이벤트 루프","자바스크립트 기초"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/a66907e81a18b740cc994295cd1668d5/3a812/thumbnail.jpg","srcSet":"/static/a66907e81a18b740cc994295cd1668d5/3a812/thumbnail.jpg 320w,\n/static/a66907e81a18b740cc994295cd1668d5/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/a66907e81a18b740cc994295cd1668d5/fc5c5/thumbnail.webp 320w,\n/static/a66907e81a18b740cc994295cd1668d5/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/a66907e81a18b740cc994295cd1668d5/2d839/thumbnail.jpg","srcSet":"/static/a66907e81a18b740cc994295cd1668d5/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/a66907e81a18b740cc994295cd1668d5/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"4cac42eb-8760-52a9-a0d2-720bd7c06bf1","tableOfContents":"<ul>\n<li>\n<p><a href=\"#var-%ED%82%A4%EC%9B%8C%EB%93%9C\">var 키워드</a></p>\n<ul>\n<li><a href=\"#%EB%B3%80%EC%88%98%EC%9D%98-%EC%A4%91%EB%B3%B5-%EC%84%A0%EC%96%B8%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\">변수의 중복 선언이 가능하다.</a></li>\n<li><a href=\"#%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EB%8B%B9%ED%95%9C%EB%8B%A4\">호이스팅 당한다.</a></li>\n<li><a href=\"#%ED%95%A8%EC%88%98-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84\">함수 레벨 스코프</a></li>\n<li><a href=\"#var-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%83%9D%EB%9E%B5-%EA%B0%80%EB%8A%A5\">var 키워드 생략 가능</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#let%EA%B3%BC-const-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%9D%98-%EB%93%B1%EC%9E%A5\">let과 const 키워드의 등장</a></p>\n</li>\n<li>\n<p><a href=\"#let%EA%B3%BC-const-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%9D%98-%ED%8A%B9%EC%A7%95\">let과 const 키워드의 특징</a></p>\n<ul>\n<li><a href=\"#%EB%B3%80%EC%88%98%EC%9D%98-%EC%A4%91%EB%B3%B5-%EC%84%A0%EC%96%B8%EC%9D%B4-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\">변수의 중복 선언이 불가능하다.</a></li>\n<li><a href=\"#%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EB%8B%B9%ED%95%9C%EB%8B%A4-1\">호이스팅 당한다?</a></li>\n<li><a href=\"#%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4\">블록 레벨 스코프를 사용한다</a></li>\n<li><a href=\"#let-const-%ED%82%A4%EC%9B%8C%EB%93%9C%EB%8A%94-%EC%83%9D%EB%9E%B5%EC%9D%B4-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\">let, const 키워드는 생략이 불가능하다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#const-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%9D%98-%ED%8A%B9%EC%A7%95\">const 키워드의 특징</a></p>\n<ul>\n<li><a href=\"#%EC%83%81%EC%88%98%EB%A5%BC-%EC%84%A0%EC%96%B8%ED%95%A0-%EB%95%8C-%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4\">상수를 선언할 때 사용한다</a></li>\n<li><a href=\"#%EB%B0%98%EB%93%9C%EC%8B%9C-%EC%84%A0%EC%96%B8%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%97%90-%EC%B4%88%EA%B8%B0%ED%99%94-%ED%95%B4%EC%A4%98%EC%95%BC-%ED%95%9C%EB%8B%A4\">반드시 선언과 동시에 초기화 해줘야 한다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 JavaScript ES6에서 추가되었던 과  키워드에 대해서 자세히 포스팅하려고 한다. 부끄럽지만 지금까지 필자는 과 는 호이스팅이 되지 않는다고 생각하고 있었다. 하지만 얼마 전 친구와 대화하던 중에 과 도 호이스팅 대상체이지만 TDZ라는 특수한 영역을 사용하여 참조를 방어하는 것임을 알게 되었다.","html":"<p>이번 포스팅에서는 JavaScript ES6에서 추가되었던 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code> 키워드에 대해서 자세히 포스팅하려고 한다. 부끄럽지만 지금까지 필자는 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>는 호이스팅이 되지 않는다고 생각하고 있었다. 하지만 얼마 전 친구와 대화하던 중에 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>도 호이스팅 대상체이지만 TDZ라는 특수한 영역을 사용하여 참조를 방어하는 것임을 알게 되었다.</p>\n<!-- more -->\n<hr>\n<p><strong>다른 분</strong>: 근데 <code class=\"language-text\">var</code>와 다르게 <code class=\"language-text\">let</code>이랑 <code class=\"language-text\">const</code>는 왜 참조 에러가 발생하는 건가요?</p>\n<p><strong>필자</strong>: <code class=\"language-text\">let</code>이랑 <code class=\"language-text\">const</code>는 호이스팅 안될 거에요.</p>\n<p><strong>친구</strong>: <code class=\"language-text\">let</code>이랑 <code class=\"language-text\">const</code>도 호이스팅 되는데…? TDZ에 들어가 있어서 참조 에러 나는거야</p>\n<p><strong>필자</strong>: 된다고??? TDZ는 또 뭐여?</p>\n<hr>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 450px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/32cc521a6a3381f1b8091672aa70ed2c/20e5d/no-yes.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 141.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAcABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAF9MajFAplbjnfJB//EAB0QAAIBBAMAAAAAAAAAAAAAAAECAwAEEhMhIiP/2gAIAQEAAQUCuThLBKWETkLq9EORL4ncgPSVhHwiKUVjHdB2Nf/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EACEQAAEDBAEFAAAAAAAAAAAAAAEAAhESITFBAxAiMlGB/9oACAEBAAY/AjS4icwi52kbb0uR7offxRr7T6UY+KCU5ojoCWzpGnVllf/EABwQAQADAAMBAQAAAAAAAAAAAAEAESExQVFhsf/aAAgBAQABPyFSECwu4pOgof2DBfW2bhiKE1O7yDQcBsjLbPVmOaX6Q77a1KALxhtwriHl5csfXBfkE2P/2gAMAwEAAgADAAAAEJAHDP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EAB4QAQEAAgIDAQEAAAAAAAAAAAERACExYUFxgVGx/9oACAEBAAE/EAemkY15/swDPZIu09o4KaGQBLbfuFHoCKyE+HVxpMSGz+DNn3HidEPIB5mPkWmyXfnjr2TAvqLNajG678OLBQQqA43ciABEpEhLud5ZSrzJUys2egz/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"no yes\" title=\"\" src=\"/static/32cc521a6a3381f1b8091672aa70ed2c/20e5d/no-yes.jpg\" srcset=\"/static/32cc521a6a3381f1b8091672aa70ed2c/0913d/no-yes.jpg 160w,\n/static/32cc521a6a3381f1b8091672aa70ed2c/cb69c/no-yes.jpg 320w,\n/static/32cc521a6a3381f1b8091672aa70ed2c/20e5d/no-yes.jpg 450w\" sizes=\"(max-width: 450px) 100vw, 450px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>호...호이스팅이 된다고...?</small>\n</center>\n<p>이런 부끄러운 일을 겪고 이번 기회에 변수 선언 키워드들에 대해 제대로 공부도 할겸 이번 포스팅을 작성하게 되었다.</p>\n<h2 id=\"var-키워드\" style=\"position:relative;\">var 키워드<a href=\"#var-%ED%82%A4%EC%9B%8C%EB%93%9C\" aria-label=\"var 키워드 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">var</code>키워드는 JavaScript ES5까지 변수를 선언할 수 있는 키워드로 사용되었다. <code class=\"language-text\">var</code> 키워드는 다른 언어랑 조금 다른 방식으로 작동했기에 다른 언어를 사용하다가 JavaScript로 처음 입문한 개발자들의 멘탈을 털어버리는 데 혁혁한 공을 세웠다.</p>\n<p><code class=\"language-text\">var</code> 키워드의 특징은 다음과 같다.</p>\n<h3 id=\"변수의-중복-선언이-가능하다\" style=\"position:relative;\">변수의 중복 선언이 가능하다.<a href=\"#%EB%B3%80%EC%88%98%EC%9D%98-%EC%A4%91%EB%B3%B5-%EC%84%A0%EC%96%B8%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\" aria-label=\"변수의 중복 선언이 가능하다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan2'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Evan2</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 코드는 변수 선언부가 가까이 붙어있으니 한눈에 “아 name이 두번 선언되었구나”라고 한눈에 알 수 있지만 첫번째 선언부와 두번째 선언부 사이에 500줄의 코드가 있다면 이제 문제가 심각해진다. 이런 변수의 중복 선언 허용은 의도하지 않은 변수의 변경이 일어날 가능성이 충분하다.</p>\n<h3 id=\"호이스팅-당한다\" style=\"position:relative;\">호이스팅 당한다.<a href=\"#%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EB%8B%B9%ED%95%9C%EB%8B%A4\" aria-label=\"호이스팅 당한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>호이스팅은 쉽게 얘기해서 스코프 안에 있는 선언들을 모두 스코프의 최상단으로 끌어올리는 것을 의미한다. 호이스팅은 JavaScript 인터프리터가 코드를 해석할 때 변수 및 함수의 선언 처리, 실제 코드 실행의 두단계로 나눠서 처리하기 때문에 발생하는 현상인데 이게 또 굉장히 사람 헷갈리게 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undeinfed</span>\n<span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>필자도 처음 JavaScript를 시작했을 때 “아니 이게 왜 참조 에러가 안나지?”라고 생각했었다. 사실 호이스팅이 발생하면서 이 코드는 아래와 같은 방식으로 동작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> name<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 선언부를 제일 위로 끌어올린다.</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nname <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>물론 이건 JavaScript 인터프리터가 내부적으로 코드를 이런 방식으로 처리한다는 거지 실제 코드 라인이 변경되거나 하는건 아니다.</p>\n<p>어쨌든 이 호이스팅을 당하게 되면 <small><strike>(호이스팅은 왠지 “당한다”는 표현이 잘 어울린다. 나도 여러번 당했기 때문에…)</strike></small> 인터프리터 언어임에도 불구하고 개발자가 코드를 읽는 순서와 코드가 실행되는 순서가 달라지게 되는 것이기 때문에 JavaScript에 입문할 때 헷갈리게 만드는 요인 중 하나다.</p>\n<h3 id=\"함수-레벨-스코프\" style=\"position:relative;\">함수 레벨 스코프<a href=\"#%ED%95%A8%EC%88%98-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"함수 레벨 스코프 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>대부분의 프로그래밍 언어는 블록 레벨 스코프를 사용하지만 JavaScript는 역시 다르다. <code class=\"language-text\">var</code> 키워드로 선언된 변수는 함수 레벨 스코프 내에서만 인정된다. 이건 사실 JavaScript에 익숙한 개발자들이라면 큰 문제가 되지는 않지만 역시 늅늅이 시절에는 굉장히 헷갈린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> local <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>local<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught ReferenceError: local is not defined</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 10</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>함수 스코프만 인정되기 때문에 심지어 <code class=\"language-text\">for</code> 문 내부에서 선언한 변수 <code class=\"language-text\">i</code>도 외부에서 참조 가능하다.</p>\n<h3 id=\"var-키워드-생략-가능\" style=\"position:relative;\">var 키워드 생략 가능<a href=\"#var-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%83%9D%EB%9E%B5-%EA%B0%80%EB%8A%A5\" aria-label=\"var 키워드 생략 가능 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>변수를 선언할 때 <code class=\"language-text\">var</code> 키워드를 붙혀도 되고 안붙혀도 된다. 역시 자유의 상징 JavaScript 답다. 너무 자유로워서 개발자가 한시도 긴장의 끈을 놓을 수 없게 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> globalVariable <span class=\"token operator\">=</span> <span class=\"token string\">'global!'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>globalVariable <span class=\"token operator\">===</span> <span class=\"token string\">'global!'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  globlVariable <span class=\"token operator\">=</span> <span class=\"token string\">'global?'</span> <span class=\"token comment\">// 오타 냄</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>globalVariable<span class=\"token punctuation\">)</span> <span class=\"token comment\">// global!</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>globlVariable<span class=\"token punctuation\">)</span> <span class=\"token comment\">// global?</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>실수로 <code class=\"language-text\">globalVariable</code> 변수를 <code class=\"language-text\">globlVariable</code> 변수로 오타를 냈다. 순진한 개발자는 <code class=\"language-text\">globalVariable</code> 변수의 값이 <code class=\"language-text\">global?</code>로 변경되었으리라 기대를 하겠지만 아쉽게도 그 값은 오타낸 변수명인 <code class=\"language-text\">globlVariable</code>이 가져갔다.</p>\n<p>이런 경우도 간단한 코드에서는 디버깅이 쉽지만 조금만 코드가 복잡해져도 눈물이 흐르는 케이스이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/1909feea74565c3861f0bd9dfb9951c1/72747/off-work.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 67.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdzrM1Fw/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQIAERIDIv/aAAgBAQABBQLIohVbJELeuts1T//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EAB8QAAIBAgcAAAAAAAAAAAAAAAABEQIQEiExQVFhkf/aAAgBAQAGPwLQxVboyUi4gdPUe2//xAAdEAEAAgICAwAAAAAAAAAAAAABABExQSFRYXHR/9oACAEBAAE/IQ/JiOEaoA13BLwFu1jg7UfsQXAfe0CAdE//2gAMAwEAAgADAAAAEMMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHRABAQABBQEBAAAAAAAAAAAAAREAITFBYYFxkf/aAAgBAQABPxBTRdyZAkF0gNT6mAOkhN2OnLiVRPLp+sRoKpeEV+B7m82BXoz/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"off work\" title=\"\" src=\"/static/1909feea74565c3861f0bd9dfb9951c1/c08c5/off-work.jpg\" srcset=\"/static/1909feea74565c3861f0bd9dfb9951c1/0913d/off-work.jpg 160w,\n/static/1909feea74565c3861f0bd9dfb9951c1/cb69c/off-work.jpg 320w,\n/static/1909feea74565c3861f0bd9dfb9951c1/c08c5/off-work.jpg 640w,\n/static/1909feea74565c3861f0bd9dfb9951c1/72747/off-work.jpg 764w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이런 것들에게 한번 걸리면 얄짤없이 11시까지 일하고 택시타고 집에 가야한다</small>\n</center>\n<h2 id=\"let과-const-키워드의-등장\" style=\"position:relative;\">let과 const 키워드의 등장<a href=\"#let%EA%B3%BC-const-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%9D%98-%EB%93%B1%EC%9E%A5\" aria-label=\"let과 const 키워드의 등장 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">var</code> 키워드의 경우 전역 변수를 남발하기가 쉽고 또 로컬 변수라고 해도 변수의 스코프가 너무 넓기 때문에 변수의 선언부와 호출부가 너무 멀리 떨어져 있거나 값이 의도하지 않게 바뀌는 경우를 추적하기 힘들다.</p>\n<p>그래서 2015년에 발표된 JavaScript ES6에는 새로운 변수 선언 키워드로 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>가 추가되었다.</p>\n<p><code class=\"language-text\">let</code> 키워드는 <code class=\"language-text\">var</code>와 마찬가지로 변수를 선언할 때 사용하는 키워드이고 <code class=\"language-text\">const</code> 키워드는 상수를 선언할 때 사용하는 키워드이다. 즉 <code class=\"language-text\">const</code> 키워드는 리터럴 값의 재할당이 불가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> callEvan <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, Evan!'</span><span class=\"token punctuation\">;</span>\ncallEvan <span class=\"token operator\">=</span> <span class=\"token string\">'Bye, Evan!'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught TypeError: Assignment to constant variable.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그럼 이 친구들이 기존의 <code class=\"language-text\">var</code> 키워드와 다른 점은 무엇일까? 위에서 설명했던 <code class=\"language-text\">var</code> 키워드의 특징은</p>\n<hr>\n<ul>\n<li>변수의 중복 선언이 가능하다.</li>\n<li>호이스팅 당한다.</li>\n<li>블록 레벨 스코프가 아닌 함수 레벨 스코프를 사용한다</li>\n<li>var 키워드는 생략이 가능하다.</li>\n</ul>\n<hr>\n<p>이상 4개 였다. 여기에 대조되는 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code> 키워드의 특징부터 먼저 살펴보자.</p>\n<h2 id=\"let과-const-키워드의-특징\" style=\"position:relative;\">let과 const 키워드의 특징<a href=\"#let%EA%B3%BC-const-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"let과 const 키워드의 특징 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우선 위에서 설명한 <code class=\"language-text\">var</code> 키워드의 특징과 대조되는 점 부터 살펴보자.</p>\n<h3 id=\"변수의-중복-선언이-불가능하다\" style=\"position:relative;\">변수의 중복 선언이 불가능하다.<a href=\"#%EB%B3%80%EC%88%98%EC%9D%98-%EC%A4%91%EB%B3%B5-%EC%84%A0%EC%96%B8%EC%9D%B4-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\" aria-label=\"변수의 중복 선언이 불가능하다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 친구들은 <code class=\"language-text\">var</code> 키워드와는 다르게 한번 키워드를 사용해서 선언한 변수는 재선언이 불가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan2'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 아무 일도 일어나지 않았다...</span>\n\n<span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan2'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught SyntaxError: Identifier 'name' has already been declared</span>\n\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan2'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught SyntaxError: Identifier 'name' has already been declared</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이로써 나도 모르게 변수를 두번 선언해서 값이 변경되어 야근하게 되는 일을 방어할 수 있게 되었다.</p>\n<h3 id=\"호이스팅-당한다-1\" style=\"position:relative;\">호이스팅 당한다?<a href=\"#%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EB%8B%B9%ED%95%9C%EB%8B%A4-1\" aria-label=\"호이스팅 당한다 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이게 바로 필자가 이 포스팅을 작성하게 된 이유이다. 필자는 <code class=\"language-text\">let</code>이나 <code class=\"language-text\">const</code> 키워드가 호이스팅 되지 않는 줄 알았다.</p>\n<p>그러나 위에서 설명했듯이 호이스팅은 JavaScript 인터프리터가 코드를 해석하는 과정에서 발생하는 일이기 때문에 <code class=\"language-text\">let</code>이나 <code class=\"language-text\">const</code>라고 한들 피해갈 수 있을리가 없다. 그렇다면 이 문제를 어떻게 해결했을까?</p>\n<h4 id=\"변수-선언-키워드에-따라-다른-에러가-발생한다\" style=\"position:relative;\">변수 선언 키워드에 따라 다른 에러가 발생한다<a href=\"#%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%8B%A4%EB%A5%B8-%EC%97%90%EB%9F%AC%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%9C%EB%8B%A4\" aria-label=\"변수 선언 키워드에 따라 다른 에러가 발생한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n<span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>aaa<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Uncaught ReferenceError: aaa is not defined</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught ReferenceError: Cannot access 'name' before initialization</span>\n<span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫번째는 호이스팅 당한 <code class=\"language-text\">var</code> 키워드를 사용하여 선언한 변수를 호출한 모습이다. 당연히 참조 에러따윈 나지 않고 깔끔하게 <code class=\"language-text\">undefined</code>가 출력된다.</p>\n<p>두번째는 아예 선언한 적이 없는 변수를 호출하는 모습이다. <code class=\"language-text\">Uncaught ReferenceError</code>가 발생하고 메세지는 <code class=\"language-text\">aaa is not defined</code>라고 한다.</p>\n<p>세번째는 <code class=\"language-text\">let</code> 키워드를 사용하여 선언한 변수를 선언부 이전에 호출한 모습이다. 두번째와 마찬가지로 <code class=\"language-text\">Uncaught ReferenceError</code>가 발생했지만 에러 메세지는 <code class=\"language-text\">Cannot access 'name' before initialization</code>라고 나온다.</p>\n<h4 id=\"v8-엔진을-뜯어보자\" style=\"position:relative;\">V8 엔진을 뜯어보자<a href=\"#v8-%EC%97%94%EC%A7%84%EC%9D%84-%EB%9C%AF%EC%96%B4%EB%B3%B4%EC%9E%90\" aria-label=\"v8 엔진을 뜯어보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>이 두개의 에러는 전혀 다른 에러로, V8 엔진 내부에서 사용하는 <code class=\"language-text\">MESSAGE_TEMPLATE</code>에도 엄밀히 구분되어 있고 실제 호출되는 케이스도 다르다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token function\">T</span><span class=\"token punctuation\">(</span>NotDefined<span class=\"token punctuation\">,</span> <span class=\"token string\">\"% is not defined\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">T</span><span class=\"token punctuation\">(</span>AccessedUninitializedVariable<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Cannot access '%' before initialization\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><a href=\"https://github.com/v8/v8\" target=\"_blank\" rel=\"nofollow\">V8 엔진의 깃허브 레파지토리</a>을 클론받아서 살펴본 결과 내부적으로 <code class=\"language-text\">var</code> 키워드로 선언된 JS 객체와 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>로 선언된 JS 객체를 분기로 갈라놓은 코드가 굉장히 많았다. 코드를 계속 분석해보면서 <code class=\"language-text\">var</code>, <code class=\"language-text\">let</code>, <code class=\"language-text\">const</code> 중 어떤 키워드를 사용하여 값을 선언하든 호이스팅은 항상 이루어진다는 것을 알 수 있었다. V8 엔진 내부의 호이스팅 플래그인 <code class=\"language-text\">should_hoist</code> 값을 JavaScript 객체에 할당할 때 변수 선언 키워드에 대한 구분을 하지않고 무조건 <code class=\"language-text\">true</code>를 할당한다.</p>\n<p>그렇다면 <code class=\"language-text\">var</code> 키워드와 <code class=\"language-text\">let</code>, <code class=\"language-text\">const</code> 키워드의 차이는 어디서 오는 것일까? 변수를 선언할 때, 즉 V8이 변수 객체를 생성할 때는 전부 동일하게 처리하지만 변수를 위해 메모리에 공간을 확보하는 초기화 단계에서는 이 키워드들을 다르게 처리한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">static</span> InitializationFlag <span class=\"token function\">DefaultInitializationFlag</span><span class=\"token punctuation\">(</span>VariableMode mode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">DCHECK</span><span class=\"token punctuation\">(</span><span class=\"token function\">IsDeclaredVariableMode</span><span class=\"token punctuation\">(</span>mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> mode <span class=\"token operator\">==</span> VariableMode<span class=\"token double-colon punctuation\">::</span>kVar <span class=\"token operator\">?</span> kCreatedInitialized\n                                    <span class=\"token operator\">:</span> kNeedsInitialization<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그러나 이후 진행 로직을 보면 <code class=\"language-text\">DefaultInitializationFlag</code>라는 함수를 통해 V8 엔진 내부에서 사용되는 <code class=\"language-text\">VariableKind</code>라는 타입을 반환하는데, 이때 <code class=\"language-text\">var</code> 키워드를 사용하여 선언한 변수는 <code class=\"language-text\">kCreatedInitialized</code> 값을, 그 외의 키워드인 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>로 선언한 변수는 <code class=\"language-text\">kNeedsInitialization</code> 키워드를 반환하고 있다.</p>\n<blockquote>\n<p>즉 <code class=\"language-text\">let</code>, <code class=\"language-text\">const</code> 키워드로 선언한 리터럴 값은 호이스팅은 되나 특별한 이유로 인해 “초기화가 필요한 상태”로 관리되고 있다.</p>\n</blockquote>\n<p>라고 말할 수 있다.</p>\n<h4 id=\"초기화가-필요한-상태는-무엇을-의미할까\" style=\"position:relative;\">초기화가 필요한 상태는 무엇을 의미할까?<a href=\"#%EC%B4%88%EA%B8%B0%ED%99%94%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%83%81%ED%83%9C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%9D%98%EB%AF%B8%ED%95%A0%EA%B9%8C\" aria-label=\"초기화가 필요한 상태는 무엇을 의미할까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>JavaScript 인터프리터 내부에서 변수는 총 3단계에 걸쳐 생성된다.</p>\n<hr>\n<ul>\n<li><code class=\"language-text\">선언 (Declaration)</code>: 스코프와 변수 객체가 생성되고 스코프가 변수 객체를 참조한다.</li>\n<li><code class=\"language-text\">초기화(Initalization)</code>: 변수 객체가 가질 값을 위해 메모리에 공간을 할당한다. 이때 초기화되는 값은 <code class=\"language-text\">undefined</code>이다.</li>\n<li><code class=\"language-text\">할당(Assignment)</code>: 변수 객체에 값을 할당한다.</li>\n</ul>\n<hr>\n<p><code class=\"language-text\">var</code> 키워드를 사용하여 선언한 객체의 경우 선언과 초기화가 동시에 이루어진다. 선언이 되자마자 <code class=\"language-text\">undefined</code>로 값이 초기화 된다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token comment\">// v8/src/parsing/parser.cc</span>\n<span class=\"token comment\">// Var 모드로 변수 선언 시</span>\n<span class=\"token keyword\">auto</span> var <span class=\"token operator\">=</span> scope<span class=\"token operator\">-></span><span class=\"token function\">DeclareParameter</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> VariableMode<span class=\"token double-colon punctuation\">::</span>kVar<span class=\"token punctuation\">,</span> is_optional<span class=\"token punctuation\">,</span>\n                                         is_rest<span class=\"token punctuation\">,</span> <span class=\"token function\">ast_value_factory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> beg_pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nvar<span class=\"token operator\">-></span><span class=\"token function\">AllocateTo</span><span class=\"token punctuation\">(</span>VariableLocation<span class=\"token double-colon punctuation\">::</span>PARAMETER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>V8 엔진의 코드를 보면 <code class=\"language-text\">kVar</code> 모드로 변수 객체를 생성한 후 바로 <code class=\"language-text\">AllocateTo</code> 메소드를 통해 메모리에 공간을 할당하는 모습을 볼 수 있다. 그러나 <code class=\"language-text\">let</code>이나 <code class=\"language-text\">const</code> 키워드로 생성한 변수 객체는 다르다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token comment\">// v8/src/parsing/parser.cc</span>\n<span class=\"token comment\">// kLet 모드로 변수 선언 시</span>\nVariableProxy<span class=\"token operator\">*</span> proxy <span class=\"token operator\">=</span>\n      <span class=\"token function\">DeclareBoundVariable</span><span class=\"token punctuation\">(</span>variable_name<span class=\"token punctuation\">,</span> VariableMode<span class=\"token double-colon punctuation\">::</span>kLet<span class=\"token punctuation\">,</span> class_token_pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nproxy<span class=\"token operator\">-></span><span class=\"token function\">var</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token function\">set_initializer_position</span><span class=\"token punctuation\">(</span>end_pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Const 모드로 변수 선언 시</span>\nVariableProxy<span class=\"token operator\">*</span> proxy <span class=\"token operator\">=</span>\n          <span class=\"token function\">DeclareBoundVariable</span><span class=\"token punctuation\">(</span>local_name<span class=\"token punctuation\">,</span> VariableMode<span class=\"token double-colon punctuation\">::</span>kConst<span class=\"token punctuation\">,</span> pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nproxy<span class=\"token operator\">-></span><span class=\"token function\">var</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token function\">set_initializer_position</span><span class=\"token punctuation\">(</span><span class=\"token function\">position</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">kLet</code> 모드나 <code class=\"language-text\">kConst</code> 모드로 생성한 변수 객체들은 <code class=\"language-text\">AllocateTo</code> 메소드가 바로 호출되지 않았고 대신 소스 코드 상에서 해당 코드의 위치를 의미하는 <code class=\"language-text\">position</code>값만 정해주는 것을 볼 수 있다.</p>\n<p>바로 이 타이밍에 <code class=\"language-text\">let</code> 키워드나 <code class=\"language-text\">const</code> 키워드로 생성된 변수들이 <code class=\"language-text\">TDZ(Temporal Dead Zone)</code> 구간에 들어가는 것이다. 즉, <code class=\"language-text\">TDZ</code> 구간에 있는 변수 객체는 “선언은 되어있지만 아직 초기화가 되지않아 변수에 담길 값을 위한 공간이 메모리에 할당되지 않은 상태”라고 할 수 있는 것이다.</p>\n<p>이때 해당 변수에 접근을 시도하면 얄짤없이 <code class=\"language-text\">Cannot access '%' before initialization</code> 에러 메세지를 만나게 된다.</p>\n<h3 id=\"블록-레벨-스코프를-사용한다\" style=\"position:relative;\">블록 레벨 스코프를 사용한다<a href=\"#%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4\" aria-label=\"블록 레벨 스코프를 사용한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>함수 레벨 스코프를 사용하는 <code class=\"language-text\">var</code> 키워드와 다르게 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>는 블록 레벨 스코프를 사용한다. 블록 레벨 스코프를 사용하지 않기 때문에 블록 내부에서 선언한 변수 또한 전역 변수로 취급된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> globalVariable <span class=\"token operator\">=</span> <span class=\"token string\">'I am global'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>globalVariable <span class=\"token operator\">===</span> <span class=\"token string\">'I am global'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> globalVariable <span class=\"token operator\">=</span> <span class=\"token string\">'am I local?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>globalVariable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// am I local?</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그러나 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code> 키워드의 경우에는 블록 내부에서 선언한 변수는 지역 변수로 취급된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">let</span> globalVariable <span class=\"token operator\">=</span> <span class=\"token string\">'I am global'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>globalVariable <span class=\"token operator\">===</span> <span class=\"token string\">'I am global'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> globalVariable <span class=\"token operator\">=</span> <span class=\"token string\">'am I local?'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> localVariable <span class=\"token operator\">=</span> <span class=\"token string\">'I am local'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>globalVariable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// I am global</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>localVariable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught ReferenceError: localVariable is not defined</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 경우 블록 내부에서 선언된 <code class=\"language-text\">localVariable</code>은 지역 변수로 취급되어 전역 스코프에서는 참조가 불가능하다. 참고로 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>는 호이스팅도 블록 단위로 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Global Evan'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>name <span class=\"token operator\">===</span> <span class=\"token string\">'Global Evan'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught ReferenceError: Cannot access 'name' before initialization</span>\n  <span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Local Evan'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 경우 <code class=\"language-text\">if</code>문 내부에서도 전역 변수로 선언한 <code class=\"language-text\">name</code> 변수의 값인 <code class=\"language-text\">Global Evan</code>이 출력될 것이라고 생각할 수 있지만 <code class=\"language-text\">if</code>문의 블록 내부에서도 호이스팅이 발생하여 지역 변수인 <code class=\"language-text\">name</code>의 선언부가 블록의 최상단으로 끌어올려졌기 때문에 참조 에러가 발생한다.</p>\n<h3 id=\"let-const-키워드는-생략이-불가능하다\" style=\"position:relative;\">let, const 키워드는 생략이 불가능하다.<a href=\"#let-const-%ED%82%A4%EC%9B%8C%EB%93%9C%EB%8A%94-%EC%83%9D%EB%9E%B5%EC%9D%B4-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\" aria-label=\"let const 키워드는 생략이 불가능하다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span>\n<span class=\"token comment\">// 상기 코드는</span>\n<span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span>\n<span class=\"token comment\">// 과 같다</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>변수 선언 키워드를 사용하지 않으면 <code class=\"language-text\">var</code> 키워드를 사용한 것으로 취급되기 때문에 무조건 써줘야 한다.</p>\n<h2 id=\"const-키워드의-특징\" style=\"position:relative;\">const 키워드의 특징<a href=\"#const-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"const 키워드의 특징 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">let</code> 키워드의 경우 위에서 설명한 이유들을 제외하면 변수를 선언할 때 사용한다는 점에서 <code class=\"language-text\">var</code> 키워드와 동일한 역할을 한다고 할 수 있다. 그러면 기존의 <code class=\"language-text\">var</code> 키워드와 다른 역할을 하는 <code class=\"language-text\">const</code>에 대해서 조금 더 알아보자.</p>\n<h3 id=\"상수를-선언할-때-사용한다\" style=\"position:relative;\">상수를 선언할 때 사용한다<a href=\"#%EC%83%81%EC%88%98%EB%A5%BC-%EC%84%A0%EC%96%B8%ED%95%A0-%EB%95%8C-%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4\" aria-label=\"상수를 선언할 때 사용한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>위에서 설명했듯이 <code class=\"language-text\">const</code>는 상수를 선언할 때 사용하는 키워드이다. 상수는 어떠한 불변 값을 의미한다. 즉, 한번 <code class=\"language-text\">const</code> 키워드를 사용하여 선언한 값은 두번 다시 변경할 수 없다는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> maxCount <span class=\"token operator\">=</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span>\nmaxCount <span class=\"token operator\">=</span> <span class=\"token number\">40</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught TypeError: Assignment to constant variable.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>만약 <code class=\"language-text\">const</code> 키워드로 선언한 값을 재할당하려고 시도하면 친절한 에러메세지와 함께 불가능하다고 알려준다.</p>\n<p>하지만 여기에 중요한 점이 있다. 바로 Call by Reference 호출 방식을 사용하는 타입을 <code class=\"language-text\">const</code> 키워드로 선언 했을 때다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span>\nobj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// Uncaught TypeError: Assignment to constant variable.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 경우 당연히 <code class=\"language-text\">obj</code> 변수가 바라보는 값 자체의 참조를 변경하려고 했기 때문에 에러가 발생한다. 그러나 객체 내부의 프로퍼티들은 <code class=\"language-text\">const</code> 키워드의 영향을 받지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span>\nobj<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token comment\">// { name: 'John' }</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이건 Call by Reference 호출 방식을 사용하는 다른 타입인 <code class=\"language-text\">Array</code>도 마찬가지다. <code class=\"language-text\">const</code> 키워드를 사용하여 선언했더라도 <code class=\"language-text\">push</code>나 <code class=\"language-text\">splice</code> 등으로 배열 내부의 원소를 변경하는 행위에는 아무런 제약이 없다.</p>\n<h3 id=\"반드시-선언과-동시에-초기화-해줘야-한다\" style=\"position:relative;\">반드시 선언과 동시에 초기화 해줘야 한다<a href=\"#%EB%B0%98%EB%93%9C%EC%8B%9C-%EC%84%A0%EC%96%B8%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%97%90-%EC%B4%88%EA%B8%B0%ED%99%94-%ED%95%B4%EC%A4%98%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"반드시 선언과 동시에 초기화 해줘야 한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">let</code> 키워드의 경우 명시적으로 선언만 했더라도 인터프리터가 해당 코드 라인을 해석함과 동시에 묵시적으로는 <code class=\"language-text\">undefined</code>가 할당되며 초기화된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">let</span> hi<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>hi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러나 <code class=\"language-text\">const</code> 키워드를 사용하는 경우 반드시 선언과 동시에 값을 할당해줘야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> hi<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught SyntaxError: Missing initializer in const declaration</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2 id=\"결론\" style=\"position:relative;\">결론<a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>반드시 JavaScript ES5로 코드를 작성해야하는 안습한 경우를 제외한다면 <code class=\"language-text\">var</code> 키워드는 이제 더이상 사용하지 않는 것을 추천한다.</p>\n<p>그렇다면 남은 것은 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>인데 <code class=\"language-text\">이 친구들을 어떻게 사용하는 것이 좋을까?</code> 라는 고민이 생긴다.</p>\n<p>사실 <code class=\"language-text\">var</code> 키워드만 쓰다보니까 생각도 안해본 사실인데, 생각보다 프로그램 내부에서 반드시 변수에 값을 재할당 해야하는 경우는 많지 않다. 필자도 별다른 생각없이 코딩하다가 어느 날 작성했던 소스코드를 봤는데 대부분 <code class=\"language-text\">const</code> 키워드를 사용하여 변수를 선언했고 <code class=\"language-text\">let</code> 키워드는 몇군데 사용하지 않은 것을 알 수 있었다.</p>\n<p>만약 <code class=\"language-text\">let</code> 키워드를 사용해야한다면 절대 전역 스코프에서는 사용하지말고 가능하면 블록 스코프를 작게 만들고 그 내부에서 사용하는 것을 추천한다.</p>\n<p>그리고 <code class=\"language-text\">const</code> 키워드의 경우 값을 재할당하려고 하면 바로 에러를 뿜뿜 해주기 때문에 개발자가 의도하지 않게 변수의 값이 재할당되는 슬픈 상황을 방지할 수 있다. 그렇기에 <code class=\"language-text\">const</code> 키워드를 잘 활용하여 안전한 코딩 라이프를 즐기고 다들 야근하지말고 칼퇴하시길 바란다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 313px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/a64125e9e9cda049bccec09014083a9e/aa65c/off-work2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 79.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIFAQT/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAGxwUFNED//xAAZEAADAQEBAAAAAAAAAAAAAAAAAhEBFCL/2gAIAQEAAQUCOVGRMiF9XT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAACAwEAAAAAAAAAAAAAAAABIQAQEVH/2gAIAQEABj8CIBcCw9g1qsr/xAAbEAEAAwADAQAAAAAAAAAAAAABABEhMUFRcf/aAAgBAQABPyF8BmQJoE0O/ZSVYAvsy26zuBduS4g4z//aAAwDAQACAAMAAAAQUw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEBAAMBAAMAAAAAAAAAAAABEQAhMVFhofH/2gAIAQEAAT8QbKCtGheYh51Snb9sSnYJ0HcEtB0rzzNuAg+Qd/mLBAvCMz//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"off work2\" title=\"\" src=\"/static/a64125e9e9cda049bccec09014083a9e/aa65c/off-work2.jpg\" srcset=\"/static/a64125e9e9cda049bccec09014083a9e/0913d/off-work2.jpg 160w,\n/static/a64125e9e9cda049bccec09014083a9e/aa65c/off-work2.jpg 313w\" sizes=\"(max-width: 313px) 100vw, 313px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>빨리 집에 가서 밥먹고 넷플릭스봐야지!</small>\n</center>\n<p>이상으로 JavaScript의 let과 const, 그리고 TDZ 포스팅을 마친다.</p>","fields":{"slug":"20190618-javascript-let-const","path":"/2019/06/18/javascript-let-const/","lang":"ko"},"frontmatter":{"title":"JavaScript의 let과 const, 그리고 TDZ","subTitle":"V8 엔진을 뜯어보며 살펴보는 JavaScript 변수의 내부 동작","date":"Jun 18, 2019","categories":["프로그래밍","자바스크립트"],"tags":["JavaScript","자바스크립트","Temporal Dead Zone","TDZ","호이스팅","Hoisting","V8","기술면접","자바스크립트 기초"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/2cc989808d5cc4f4cafd05e0c479f2cc/d803c/js.001.png","srcSet":"/static/2cc989808d5cc4f4cafd05e0c479f2cc/d803c/js.001.png 320w,\n/static/2cc989808d5cc4f4cafd05e0c479f2cc/6131a/js.001.png 734w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/2cc989808d5cc4f4cafd05e0c479f2cc/fc5c5/js.001.webp 320w,\n/static/2cc989808d5cc4f4cafd05e0c479f2cc/d6c14/js.001.webp 734w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/2cc989808d5cc4f4cafd05e0c479f2cc/17e8c/js.001.png","srcSet":"/static/2cc989808d5cc4f4cafd05e0c479f2cc/17e8c/js.001.png 734w","sizes":"100vw"},"sources":[{"srcSet":"/static/2cc989808d5cc4f4cafd05e0c479f2cc/88dbe/js.001.webp 734w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"자바스크립트 기초","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}