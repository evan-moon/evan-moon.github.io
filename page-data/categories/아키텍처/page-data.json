{"componentChunkName":"component---src-templates-category-page-template-index-tsx","path":"/categories/아키텍처/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"6b438603-56ea-52be-a0f8-2c6d935a3fa7","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A0%9C%EB%8A%94-%EC%A0%95%EB%A7%90-%EC%B6%94%EC%83%81%ED%99%94-%EB%BF%90%EC%9D%B4%EC%95%BC\">이제는 정말 추상화 뿐이야…</a></p>\n<ul>\n<li><a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9D%98-%EC%9E%90%EC%9C%A0%EB%8F%84%EB%A5%BC-%EB%B3%B4%EC%9E%A5%ED%95%98%EB%8A%94-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0\">사용자의 자유도를 보장하는 컴포넌트 만들기</a></li>\n<li><a href=\"#text-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4-%EB%B3%B4%EC%9E%90\">Text 컴포넌트를 만들어 보자</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A1%B0%EA%B8%88%EC%94%A9-%EC%B6%94%EC%83%81%ED%99%94%ED%95%98%EB%A9%B4%EC%84%9C-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0\">조금씩 추상화하면서 설계하기</a></p>\n<ul>\n<li><a href=\"#html-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%ED%9D%89%EB%82%B4%EB%82%B4%EA%B8%B0\">HTML 엘리먼트 흉내내기</a></li>\n<li><a href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0\">커스텀 프로퍼티 추가하기</a></li>\n<li><a href=\"#%EC%9B%90%ED%95%98%EB%8A%94-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EB%A1%9C-%EB%A0%8C%EB%8D%94%ED%95%A0-%EC%88%98-%EC%9E%88%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0\">원하는 엘리먼트로 렌더할 수 있게 만들기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A0%84%EC%B2%B4-%EC%BD%94%EB%93%9C%EB%A5%BC-%ED%95%9C-%EB%B2%88%EC%97%90-%EB%B3%B4%EC%9E%90\">전체 코드를 한 번에 보자</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"최근 필자가 활동하고 있는 루비콘 팀에서는 멘토링 프로젝트를 함께 진행했던 멘티 분들과 함께 lubycon-ui-kit이라는 작은 프로젝트를 시작했다. 뭐 시작한지 얼마 안 되어서 아직 아무 것도 없지만, 한글을 기반으로 제작해 국내의 디자이너나 개발자가 사용하기 용이한 UI 라이브러리를 만들자는 의의를 가지고 조금씩 작업 중이다.","html":"<p>최근 필자가 활동하고 있는 루비콘 팀에서는 멘토링 프로젝트를 함께 진행했던 멘티 분들과 함께 <a href=\"https://github.com/Lubycon/lubycon-ui-kit\" target=\"_blank\" rel=\"nofollow\">lubycon-ui-kit</a>이라는 작은 프로젝트를 시작했다. 뭐 시작한지 얼마 안 되어서 아직 아무 것도 없지만, 한글을 기반으로 제작해 국내의 디자이너나 개발자가 사용하기 용이한 UI 라이브러리를 만들자는 의의를 가지고 조금씩 작업 중이다.</p>\n<!-- more -->\n<p>이 프로젝트는 최근 많은 프로젝트들이 그러하듯 React와 TypeScript를 적당한 비율로 섞어주고, 여기에 <a href=\"https://storybook.js.org/\" target=\"_blank\" rel=\"nofollow\">Storybook</a>을 한 움큼 뿌린 뒤 <a href=\"https://rollupjs.org/guide/en/\" target=\"_blank\" rel=\"nofollow\">Rollup</a>으로 마무리해서 만들어졌다.</p>\n<p>일단 컴포넌트가 디자인되고나면 개발자들과 디자이너들이 모여서 리뷰를 하고 이후 리뷰 통과가 된다면 바로 개발을 진행해서 개발 서버에 스토리북을 배포하고 최종 리뷰를 하는 짧은 이터레이션으로 진행이 되는데, 최근 UI Kit에 들어가는 컴포넌트의 인터페이스를 타이핑하면서 삽질했던 일을 조금 남겨볼까 한다.</p>\n<h2 id=\"이제는-정말-추상화-뿐이야\" style=\"position:relative;\">이제는 정말 추상화 뿐이야…<a href=\"#%EC%9D%B4%EC%A0%9C%EB%8A%94-%EC%A0%95%EB%A7%90-%EC%B6%94%EC%83%81%ED%99%94-%EB%BF%90%EC%9D%B4%EC%95%BC\" aria-label=\"이제는 정말 추상화 뿐이야 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 개인적으로 이런 오픈 소스 라이브러리 프로젝트를 만들 때 가장 어려운 부분이 바로 설계라고 생각한다. 이 설계에는 모듈이나 컴포넌트의 인터페이스라던가 사용자에게 어떤 모듈을 노출시키고 어떤 모듈은 감출 것이냐하는 캡슐화 같은 것들이 모두 포함된다.</p>\n<p>게다가 이런 프로젝트는 프로젝트를 처음 시작할 때부터 혼자 만드는 것이 아니라 여러 명이 협업을 해야하기 때문에 설계에 대한 가치관을 팀 내에서 맞추기도 해야한다.</p>\n<p>솔직히 필자는 이 프로젝트를 들어가면서 설계에 대한 고민을 깊게 하지는 않았는데, 왜냐하면 필자는 회사에서 이미 TDS(Toss Design System)를 사용하여 서비스 개발을 하고 있기 때문에 그냥 막연하게 “이거랑 비슷한 느낌으로 만들면 되는 거 아닌가?”라고 생각했기 때문이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 52.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAv/EABYBAQEBAAAAAAAAAAAAAAAAAAIBA//aAAwDAQACEAMQAAABny6XQRjxT//EABoQAAICAwAAAAAAAAAAAAAAAAECESEDMTP/2gAIAQEAAQUCaVUy4NHLyQ0d/wD/xAAYEQACAwAAAAAAAAAAAAAAAAAAAQMSQf/aAAgBAwEBPwGZaXP/xAAXEQADAQAAAAAAAAAAAAAAAAAAAQNB/9oACAECAQE/AYvByP/EABgQAQADAQAAAAAAAAAAAAAAAAEAEHEh/9oACAEBAAY/AtnCjYlf/8QAGRABAQADAQAAAAAAAAAAAAAAAREAECFR/9oACAEBAAE/Ieoy+MFIzCoahChl1f/aAAwDAQACAAMAAAAQT8//xAAXEQEBAQEAAAAAAAAAAAAAAAABABEh/9oACAEDAQE/EAAEbOl//8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARIf/aAAgBAgEBPxB1aG8b/8QAGxAAAgMAAwAAAAAAAAAAAAAAAREAITFBkaH/2gAIAQEAAT8QFJVqyK46jf6aAA4njvZYh0AvYKgmhAzSf//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tds\" title=\"\" src=\"/static/54696de7a7e6c8a6cf270e1286b33c24/c08c5/tds.jpg\" srcset=\"/static/54696de7a7e6c8a6cf270e1286b33c24/0913d/tds.jpg 160w,\n/static/54696de7a7e6c8a6cf270e1286b33c24/cb69c/tds.jpg 320w,\n/static/54696de7a7e6c8a6cf270e1286b33c24/c08c5/tds.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>진짜 이 디자인 시스템 하나 덕분에 개발 속도가 엄청나게 빨라진다</small>\n</center>\n<p>그래서 디자이너 분들과 함께 싱크하는 첫 미팅에서 TDS를 예로 들면서 신나게 설명하고 있었는데, 이런 대답이 돌아왔다.</p>\n<blockquote>\n<p>개발자님…? 디자인 시스템이랑 UI Kit은 조금 다른 개념이에요.</p>\n</blockquote>\n<p>이게 무슨 소리인고 하니, 사실 디자인 시스템이라는 것은 조직의 브랜드와 디자인에 대한 철학이 녹아있는 개념이라고 한다. 그러니까 필자가 회사에서 사용하고 있는 TDS라는 녀석은 토스라는 조직이 표방하는 디자인에 대한 여러 철학들이 녹아있는 녀석이기 때문에 다른 조직에서 이걸 그대로 사용하기에는 조금 어려울 수도 있다는 의미이다.</p>\n<p>반면에 UI Kit이라는 개념은 최대한 이러한 철학들과 격리되어 진짜로 UI 컴포넌트들만을 제공하는 것이라고 한다.</p>\n<p>즉, <a href=\"https://getbootstrap.com/\" target=\"_blank\" rel=\"nofollow\">Bootstrap</a>같은 녀석들은 어떤 디자인에 대한 철학을 가지고 있는 것이 아니라 그저 레고처럼 조립해서 사용할 수 있는 UI 컴포넌트들의 모음이라서 UI Kit인 것이고, 구글의 <a href=\"https://material.io/design/\" target=\"_blank\" rel=\"nofollow\">Material Design</a>이나 에어비앤비의 <a href=\"https://airbnb.design/tag/dls/\" target=\"_blank\" rel=\"nofollow\">Design Language System</a>, 토스의 <a href=\"https://blog.toss.im/2019/04/18/tossteam/culture/toss-design-conference/\" target=\"_blank\" rel=\"nofollow\">TDS</a>처럼 어떤 조직에서 디자인에 대한 철학들을 만들고 그 철학을 UI Kit에 녹여내면 디자인 시스템이 되는 것이다. <small>(UI Kit은 디자인 시스템을 포괄하는 상위 개념이라고 한다)</small></p>\n<p>사실 필자는 회사에서 매일 사용하는 TDS의 인터페이스에 굉장히 익숙해져있는 상태라서 “그냥 이거랑 비슷한 느낌으로 만들면 되지 않을까?”라고 막연하게 생각만 하고 있었는데, 이 얘기를 듣고나서 앞서 이야기한 디자인 시스템들을 다시 살펴보니 해당 디자인 시스템을 만든 조직의 디자인 철학이 상당히 많이 묻어 있다는 것을 알 수 있었다.</p>\n<p>결국 UI Kit은 사용자가 다양한 조직의 디자인 가이드나 코딩 컨벤션에 맞게 커스터마이징까지도 가능해야 할 정도로 높은 자유도를 보장할 수 있어야하기 때문에 디자인 시스템을 만들 때보다 추상화에 대한 고민을 더 깊게 해야한다는 것이다.</p>\n<h3 id=\"사용자의-자유도를-보장하는-컴포넌트-만들기\" style=\"position:relative;\">사용자의 자유도를 보장하는 컴포넌트 만들기<a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9D%98-%EC%9E%90%EC%9C%A0%EB%8F%84%EB%A5%BC-%EB%B3%B4%EC%9E%A5%ED%95%98%EB%8A%94-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"사용자의 자유도를 보장하는 컴포넌트 만들기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 이야기를 듣고 나서 프론트엔드 개발자들이 제일 먼저 논의했던 내용은 “사용자에게 어디까지 자유도를 보장해줄 것인가?”였다.</p>\n<p>예를 들어 <code class=\"language-text\">Button</code> 같은 클리커블한 컴포넌트를 만든다고 생각해보자. HTML을 사용하여 이 엘리먼트가 클릭이 가능한 녀석이라는 것을 표현하기 위한 방법은 하나가 아니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-html line-numbers\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span><span class=\"token punctuation\">></span></span>난 버튼<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>button<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>나도 버튼<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>input</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span><span class=\"token punctuation\">></span></span>버튼은 아닌데 버튼처럼 써도 돼<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">role</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>button<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>사실 나도 버튼이기는 해<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>물론 마지막의 <code class=\"language-text\">role=\"button\"</code>처럼 버튼을 표현하는 경우에는 개발자가 별도로 엘리먼트에 <code class=\"language-text\">tabindex</code>를 사용하여 포커스가 가능하게 만들어주고, 포커싱된 상태에서 엔터나 스페이스를 눌렀을 때 버튼이 활성화 될 수 있도록 <code class=\"language-text\">click</code>이나 <code class=\"language-text\">keydown</code> 이벤트 핸들러도 정의해주어야 시맨틱한 버튼이라고 인정받을 수 있기 때문에 조금 이상하다고 생각이 될 수는 있지만, 중요한 건 저게 에러가 아니라는 것이다.</p>\n<p>어떤 조직의 철학에 종속되어있는 디자인 시스템이라면 그냥 ”<code class=\"language-text\">Button</code> 컴포넌트는 반드시 <code class=\"language-text\">button</code>으로만 렌더될 수 있다”는 규칙을 만들어 버린다고 해도 팀 내에 그 설계 철학에 대한 내용이 공유되어 있기만 하면 상관없을 수 있지만, UI Kit은 사용자가 기존에 HTML을 사용하던 방법을 최대한 훼손하지 않으면서 UI에 관련된 부분만을 도와주어야 하기 때문에 이런 고민이 필수적이다.</p>\n<p>결국 이런 고민을 거듭하던 끝에 최대한 HTML의 원래 사용법을 살려주자는 방향으로 의사 결정이 되었고, 어쩌다보니 필자가 이 프로젝트의 첫 번째 컴포넌트를 설계하게 되었다.</p>\n<h3 id=\"text-컴포넌트를-만들어-보자\" style=\"position:relative;\">Text 컴포넌트를 만들어 보자<a href=\"#text-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4-%EB%B3%B4%EC%9E%90\" aria-label=\"text 컴포넌트를 만들어 보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자가 개발을 맡게 된 녀석은 바로 <code class=\"language-text\">Text</code> 컴포넌트이다. UI Kit을 정의할 때 디자이너 분들이 시스템의 뼈대가 되는 타이포그래피와 컬러 팔레트를 먼저 정의해야 한다고 해서 자연스럽게 타이포그래피를 표현할 수 있는 이 컴포넌트를 가장 먼저 개발하게 된 것이다.</p>\n<p>물론 타이포그래피와 관련된 스타일 데이터 자체는 SCSS나 CSS Variable로도 제공이 되고 JS 모듈로도 제공이 되지만, 타이포그래프를 사용할 때마다 일일히 모듈을 임포트하거나 클래스를 작성하게 하는 것은 상당히 귀찮으므로 그냥 컴포넌트를 하나 제공해주는 것이 깔끔하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 대략 이런 느낌으로 말이다</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Text</span></span> <span class=\"token attr-name\">typography</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>h1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">나는 머릿말 1이야</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Text</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Text</span></span> <span class=\"token attr-name\">typography</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>content<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">나는 콘텐츠야</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Text</span></span><span class=\"token punctuation\">></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그리고 HTML 상에서 이런 문자열을 렌더하려고 할 때 <code class=\"language-text\">span</code>, <code class=\"language-text\">p</code>, <code class=\"language-text\">div</code> 등 다양한 엘리먼트를 사용할 수 있기 때문에 <code class=\"language-text\">Text</code> 컴포넌트 또한 동일하게 여러 엘리먼트로 렌더될 수 있도록 추상적인 인터페이스를 가져야한다.</p>\n<p>즉, <code class=\"language-text\">Text</code> 컴포넌트는 타이포그래피라는 관심사만을 가져야 하고 이 관심사를 제외한 나머지 모든 기능은 HTML의 <code class=\"language-text\">p</code>나 <code class=\"language-text\">span</code> 등을 사용할 때와 완전 동일하게 만들어줘야 한다는 것이다.</p>\n<h2 id=\"조금씩-추상화하면서-설계하기\" style=\"position:relative;\">조금씩 추상화하면서 설계하기<a href=\"#%EC%A1%B0%EA%B8%88%EC%94%A9-%EC%B6%94%EC%83%81%ED%99%94%ED%95%98%EB%A9%B4%EC%84%9C-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0\" aria-label=\"조금씩 추상화하면서 설계하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 이야기한 것과 같이 사용자의 자유도를 보장하기 위해 리액트 내에서 HTML 엘리먼트를 사용할 때의 동작을 훼손해서는 안 되므로, 이 컴포넌트의 프로퍼티는 기본적으로 렌더 대상이 되는 엘리먼트의 속성들을 그대로 재현해야한다.</p>\n<p>또한 사용자는 이 컴포넌트를 사용할 때 <code class=\"language-text\">span</code>이든 <code class=\"language-text\">p</code>든 <code class=\"language-text\">div</code>든 원하는 엘리먼트를 렌더할 수 있어야한다. 물론 사용자에게 <code class=\"language-text\">span</code>이나 <code class=\"language-text\">p</code>만을 사용하여 렌더하는 것을 강제할 수도 있겠지만 그런 룰을 강제하는 것 자체가 타이포그래피라는 관심사를 벗어나는 일이기 때문이다.</p>\n<p>그리고 필자는 타입스크립트를 사용하여 개발을 하고 있고, 이 라이브러리는 <code class=\"language-text\">*.d.ts</code> 파일을 사용하여 타입을 제공해야 하기 때문에 사용자가 렌더하기를 원하는 엘리먼트에 맞춰서 컴포넌트의 프로퍼티 타입도 유연하게 변경되어 IDE의 자동완성기능과 컴파일러의 정적 타입 분석을 제대로 이용할 수 있어야 한다.</p>\n<p>이 포스팅에서는 필자가 삽질했던 추상화 과정을 총 HTML 엘리먼트 흉내내기, 커스텀 프로퍼티 추가하기, 원하는 엘리먼트로 자유롭게 렌더할 수 있게 만들기의 3가지 단계로 나누어서 이야기해볼까 한다.</p>\n<h3 id=\"html-엘리먼트-흉내내기\" style=\"position:relative;\">HTML 엘리먼트 흉내내기<a href=\"#html-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%ED%9D%89%EB%82%B4%EB%82%B4%EA%B8%B0\" aria-label=\"html 엘리먼트 흉내내기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>가장 먼저 해볼 수 있는 설계는 바로 HTML 엘리먼트를 그대로 흉내내는 것이다. 사실 리액트는 원하는 엘리먼트의 속성 타입들을 편하게 사용할 수 있도록 <code class=\"language-text\">HTMLAttributes</code>라는 타입을 제공하고 있기 때문에 그냥 이렇게만 해도 HTML 엘리먼트를 똑같이 따라할 수는 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Props</span> <span class=\"token operator\">=</span> HTMLAttributes<span class=\"token operator\">&lt;</span><span class=\"token string\">'span'</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Text</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 61.24999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABpUlEQVR42qWSSVPbQBBG9UOQFwzWYm3IkseSxlpHsiIvMsRJgErlkFw4ceL/f2lLJFQqHAI5vOqunpo30z0j5axFzLZwyhvMwwbVpx84Pjxh9/UB7fdHiP0d4oyDxzkMK4KiLaDqrGe27NGXv2tSmN+B+w2u/BJ+cwsva7GKa1x5KWw3gWFzEgVEiJkRQO8gAYmnqt+hqH3eCZcsQ1F9BC+OCPkO4WqPKG7BkwOipEVI+Sq9Ia47TvWyvkXd3EOsv0BQXlA81TxWQXKojUXxGfnhG4Q40I1W0M0ImhHSrfgLZh9ntOa4KbxFgbmfw6f4KzftiFq2MljBDm7yAaVokIsNbaYWpg6GQx2DofYcX5AHGmRZxRkhD3rOZAUXlw4kTfOhh1sw0ZJwi7zYIM0a2E6I0bmJ8cT6i/NXGE9MTJU5JPVZGJTXqNd7ZHkDTfcwHM0wPgn/kdHYIKELSaHXYXwNlm6wrvaw7KBrqTv1/cKyE6Zp3c3hLaLXhVGJoNiBc9HP6X+FS14h3RxhWezNs/tT2D3KAq6fwGE5LumrTC7ez1T18BPzUXff/O3mNQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"html attrs\" title=\"\" src=\"/static/1425cce2ebe3ccbafd98dd47f519e8e6/6af66/html_attrs.png\" srcset=\"/static/1425cce2ebe3ccbafd98dd47f519e8e6/69538/html_attrs.png 160w,\n/static/1425cce2ebe3ccbafd98dd47f519e8e6/72799/html_attrs.png 320w,\n/static/1425cce2ebe3ccbafd98dd47f519e8e6/6af66/html_attrs.png 640w,\n/static/1425cce2ebe3ccbafd98dd47f519e8e6/d9199/html_attrs.png 960w,\n/static/1425cce2ebe3ccbafd98dd47f519e8e6/d56e1/html_attrs.png 1130w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>사실 이렇게만 해도 자동완성까지 이쁘게 해준다</small>\n</center>\n<p>하지만 이 타입은 사용할 수가 없다. 왜냐하면 <code class=\"language-text\">HTMLAttributes</code> 타입은 말 그대로 리액트에서 제공하는 HTML에 대한 기본적인 속성들만 가지고 있는 녀석이라 <code class=\"language-text\">ref</code>나 <code class=\"language-text\">key</code> 등을 포함하고 있지 않기 때문이다.</p>\n<p>물론 리액트에서 HTML 요소를 타이핑할 때 사용하는 <code class=\"language-text\">DetailedHTMLProps</code>라는 타입을 사용하면 프로퍼티에 <code class=\"language-text\">ref</code>를 포함시킬 수는 있지만, 그렇다고 해서 실제로 이 컴포넌트가 <code class=\"language-text\">ref</code>를 통과시키지는 않는다. 이건 말 그대로 타입만 선언되는 것이다.</p>\n<p>이 내용은 리액트의 공식 문서의 Forwarding Refs 섹션에도 잘 나와있다.</p>\n<blockquote>\n<p>refs will not get passed through. <strong>That’s because ref is not a prop.</strong> Like key, it’s handled differently by React.</p>\n<p><strong>Forwarding Refs</strong> - <em><a href=\"https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components\" target=\"_blank\" rel=\"nofollow\">reactjs.org</a></em></p>\n</blockquote>\n<p>결국 진짜 리액트에서 사용되는 HTML 요소들을 똑같이 재현하려면 상위 컴포넌트에서 <code class=\"language-text\">ref</code>를 받아서 하위 컴포넌트로 넘겨줄 수 있는 기능까지 모두 구현해야 한다는 뜻이고, 이때 사용하는 것이 바로 <code class=\"language-text\">forwardRef</code> 함수이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> Text <span class=\"token operator\">=</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>\n  props<span class=\"token operator\">:</span> ComponentPropsWithoutRef<span class=\"token operator\">&lt;</span><span class=\"token string\">'span'</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  ref<span class=\"token operator\">:</span> Ref<span class=\"token operator\">&lt;</span>HTMLSpanElement<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span> <span class=\"token attr-name\">ref</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>ref<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">forwardRef</code> 함수는 자신의 인자로 들어온 함수에게 <code class=\"language-text\">props</code>와 <code class=\"language-text\">ref</code>를 전달해주는데, 이때 전달된 레퍼런스를 의미하는 <code class=\"language-text\">ref</code>는 별도의 인자로 넘어오기 때문에 자연스럽게 <code class=\"language-text\">props</code>는 <code class=\"language-text\">ref</code>를 제외한 프로퍼티들 이라고 유추할 수 있다.</p>\n<p>다행히 리액트는 컴포넌트의 프로퍼티 중에서 <code class=\"language-text\">ref</code>만 제외한 나머지 프로퍼티들 쉽게 타이핑할 수 있도록 <code class=\"language-text\">ComponentPropsWithoutRef</code>라는 타입을 제공하고 있기 때문에 굳이 개발자가 <code class=\"language-text\">Omit</code> 유틸리티 타입을 사용하여 <code class=\"language-text\">ref</code> 키를 직접 제거하지 않아도 된다.</p>\n<h3 id=\"커스텀-프로퍼티-추가하기\" style=\"position:relative;\">커스텀 프로퍼티 추가하기<a href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0\" aria-label=\"커스텀 프로퍼티 추가하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>자, 여기까지 오면 <code class=\"language-text\">Text</code> 컴포넌트는 <code class=\"language-text\">span</code> 엘리먼트와 동일한 기능을 가진 컴포넌트가 된다. 이렇게 <code class=\"language-text\">forwardRef</code> 함수를 사용하여 상위 컴포넌트가 받은 모든 것들을 하위 컴포넌트에게 그대로 넘겨주는 패턴은 고차 컴포넌트(Higher-order Component)를 만들 때도 사용되는 일반적인 기법이다. <small><del>(사실 HOC 때문에 더 많이 쓴다)</del></small></p>\n<p>하지만 <code class=\"language-text\">Text</code> 컴포넌트는 <code class=\"language-text\">span</code> 엘리먼트의 속성 뿐 아니라 UI Kit에서 자체적으로 제공하려고 하는 타이포그래피와 관련된 커스텀 프로퍼티도 받을 수 있어야 하는데, 이대로라면 그냥 <code class=\"language-text\">span</code> 그 자체가 되어버린다. 그래서 방금 선언했던 <code class=\"language-text\">span</code> 엘리먼트의 속성 타입에 커스텀 프로퍼티에 대한 타입을 추가해주어야한다.</p>\n<p>어차피 타입스크립트는 <code class=\"language-text\">&amp;</code>(intersection) 타입을 제공하고 있으니 이걸 사용하면 간단하게 구현할 수 있을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  typography<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">&amp;</span> ComponentPropsWithoutRef<span class=\"token operator\">&lt;</span><span class=\"token string\">'span'</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> Text <span class=\"token operator\">=</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">{</span> typography<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>props<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> Props<span class=\"token punctuation\">,</span>\n  ref<span class=\"token operator\">:</span> Ref<span class=\"token operator\">&lt;</span>HTMLSpanElement<span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>인터섹션 타입은 서로 다른 두 개의 타입을 합치는 타입이기 때문에 이렇게 하면 필자가 선언한 <code class=\"language-text\">typography</code>라는 프로퍼티와 <code class=\"language-text\">span</code> 엘리먼트의 속성들을 묶어서 <code class=\"language-text\">TextProps</code>라는 타입으로 선언할 수 있다.</p>\n<p>하지만 이 방법에도 문제는 존재하는데, 바로 <code class=\"language-text\">ComponentPropsWithoutRef&lt;'span'></code> 타입에서 제공되는 프로퍼티와 커스텀 프로퍼티가 동일한 키를 가지고 있는 경우에 대해서 대응이 불가능하다는 점이다.</p>\n<p>이게 정확히 어떤 상황을 이야기하는 것인지 한번 예시를 통해 알아보도록 하자. 만약 필자가 커스텀 프로퍼티에 <code class=\"language-text\">customId</code>라는 프로퍼티를 추가하게 되면 이 프로퍼티는 필자가 선언한 타입 대로 잘 추론이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  customId<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">&amp;</span> ComponentPropsWithoutRef<span class=\"token operator\">&lt;</span><span class=\"token string\">'span'</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 18.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2klEQVR42l2OyU6EUBBF+RgnHvMkM3SjSCOIaJC2o3GtGzf+f44POvbCxcm9t+pWUooQMaqI0MwcP6xxvRuc4Igns+1XK8suiBts55jDZIftVehmgeve4bj1qkobjcR+gxs2tNM7236i7l5o2pluOFBUA/mmZ9fNPIxv5NE9WdkzTh/kUh1ryyY7UKYzW6nK9e0TZjFg7V+xvr/Qfj4Jnvey8IgvP1q+PFejlbOrkAst4VKy+EVVI5Oz6IQizBRVTxBWhu6WK5r0Qk/RjBTxn6VrJCe/3up/85Rf/RqGJ2pYMcQAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"o\" title=\"\" src=\"/static/1b2d749ba284a65bbbc99d320d58cd84/6af66/o.png\" srcset=\"/static/1b2d749ba284a65bbbc99d320d58cd84/69538/o.png 160w,\n/static/1b2d749ba284a65bbbc99d320d58cd84/72799/o.png 320w,\n/static/1b2d749ba284a65bbbc99d320d58cd84/6af66/o.png 640w,\n/static/1b2d749ba284a65bbbc99d320d58cd84/3d4b6/o.png 712w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>추론이 아주 잘 되는 만족스러운 모습</small>\n</center>\n<p>그러나 <code class=\"language-text\">id</code>와 같이 <code class=\"language-text\">ComponentPropsWithoutRef&lt;'span'></code> 타입 내부에 이미 선언되어 있는 녀석을 커스텀 프로퍼티에 추가하면 인터섹션 타입으로 엮은 두 개의 타입이 충돌하면서 필자가 선언했던 <code class=\"language-text\">id</code> 프로퍼티가 쌩뚱맞게 <code class=\"language-text\">undefined</code>로 추론되는 것을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">&amp;</span> ComponentPropsWithoutRef<span class=\"token operator\">&lt;</span><span class=\"token string\">'span'</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 44.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB6ElEQVR42lVSyXajMBD0t0wW24h9FwLMJjBmsSGxM8l7k8P8/z/UNMppDvVEC3VVV3fvmCXwqoU4aBxJNqBsFkTijCjuEHg9eLgg9EdoeoY9S3DQhTo1I/0PB8bhJmfsHHqYeC2sfEJWjOBZj0reEEQNwriFIJEsH5GXI2JBInEDnnZEspFzHDfQ956KMpwaO9s5Iec9jEDiVA2o6gmyvcHyTkQgESYNDDuF6WTQTaGItvh57xMCdT69+vj17EB3KuwMevjCQrLNoYkFurgq7OMJLB7higFFNVIrrqhJqKgmVW3TLihIfLs7X+4UX2H7kipkKRq3hwgmpOWMqltRtStKsn2Zf6Pt3zCMD1wIXf+uIM8rpusnLtMD/XDHMH0oN6bbECFZ4x71y5W4rZ94PP5gWb7w+PhWqpIENlIvrCipVQRbXDYzRN6rOzco8XLwfyxbdg5jaywTCLIromIBL1eImpLaN+rnivQ0UvIFcXqmoUhESUfDopi2Ic0HhLyD4xWw/A47zzyhShcE1YJ4/ouo+YaZ3XEMZ/jJRFW+U5/uqOU72f4iogm2VxNBo+BS3xy/gWkXJDjT2hCzTQosqRHlLUKyZtBuHlkMRhPd1mKbrKYnate2WKf/GxhN3bAyuovxRNPmQuIfEJ0zdUJD/0MAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"x\" title=\"\" src=\"/static/c9307aeb70ad34301279d568ff3762a8/6af66/x.png\" srcset=\"/static/c9307aeb70ad34301279d568ff3762a8/69538/x.png 160w,\n/static/c9307aeb70ad34301279d568ff3762a8/72799/x.png 320w,\n/static/c9307aeb70ad34301279d568ff3762a8/6af66/x.png 640w,\n/static/c9307aeb70ad34301279d568ff3762a8/6029f/x.png 906w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>혼란스러워 하는 컴파일러.jpg</small>\n</center>\n<p>이렇게 컴파일러가 혼란스러워하는 이유는 타입스크립트에서 인터섹션 타입을 통해 타입을 합친다는 것이 상속과 오버라이딩 개념이 아니기 때문이다. 컴파일러 입장에서는 저런 식으로 타입을 선언하면 커스텀 프로퍼티의 <code class=\"language-text\">id</code>와 <code class=\"language-text\">ComponentPropsWithoutRef&lt;'span'></code> 타입 내부의 <code class=\"language-text\">id</code> 중 어떤 것이 맞는 것인지 알 수가 없게 되어 버린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> id<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> id<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 둘 다 id를 가지고 있는데...?</span>\n<span class=\"token comment\">// 뭐가 맞는거임...?</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Result</span> <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">&amp;</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 이 이슈는 타입이 아니라 인터페이스로 선언하고 <code class=\"language-text\">extends</code>를 사용하여 상속해도 동일하게 발생한다. 동일한 프로퍼티를 가진 녀석을 상속해서 오버라이딩하려고 하면 “Interface ’*’ incorrectly extends…” 어쩌고 하는 컴파일 에러가 발생한다.</p>\n<p>사실 우리가 자바스크립트의 <code class=\"language-text\">Object.assign</code> 같은 메소드를 사용하여 객체를 병합할 때는 첫 번째 인자의 객체가 가진 프로퍼티와 두 번째 객체가 가진 프로퍼티가 중복된다면 암묵적으로 첫 번째 객체의 프로퍼티를 두 번째 객체의 프로퍼티로 오버라이딩해버린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">foo</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">foo</span><span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 두 번째 객체의 프로퍼티로 암묵적 오버라이딩된다</span>\n<span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">foo</span><span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>하지만 타입스크립트는 정적 타이핑 언어이고 명확한 선언을 지향하므로 이런 암묵적인 오버라이딩을 절대 허용하지 않는 것이다.</p>\n<p>그래서 이런 식으로 타입을 병합하려면 먼저 <a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys\" target=\"_blank\" rel=\"nofollow\">Omit</a> 유틸리티 타입을 사용해서 오버라이딩하려고 하는 프로퍼티를 제거한 후 병합해야지 문제가 없다. 하지만 매번 <code class=\"language-text\">Omit</code>을 사용해서 타입을 병합하는 건 상당히 귀찮은 일이므로 아예 병합용 유틸 타입을 하나 선언해서 사용하는 것이 손목 건강과 정신 건강에도 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Combine<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token operator\">&amp;</span> Omit<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Combine</code> 타입은 제네릭으로 2개의 타입을 받은 후 <code class=\"language-text\">K</code> 타입에서 <code class=\"language-text\">T</code> 타입이 가진 프로퍼티와 중복되는 녀석들을 몽땅 제거한 후 인터섹션 타입으로 병합한다. 즉, <code class=\"language-text\">T</code> 타입에 선언된 키가 <code class=\"language-text\">K</code> 타입에도 존재한다면 오버라이딩하는 것이다.</p>\n<p>이제 <code class=\"language-text\">Combine</code> 타입을 사용해서 필자가 사용하고자 하는 커스텀 프로퍼티와 <code class=\"language-text\">span</code> 엘리먼트의 속성들을 병합하여 최종적인 <code class=\"language-text\">Text</code> 컴포넌트의 프로퍼티를 선언하면 된다.</p>\n<p>만약 개발자가 직접 선언한 커스텀 프로퍼티에 <code class=\"language-text\">span</code> 엘리먼트의 속성과 중복되는 값이 있더라도 <code class=\"language-text\">Combine</code> 타입이 자동으로 오버라이딩을 해줄 것이므로, 개발자는 별 다른 고민없이 평소처럼 프로퍼티를 선언할 수 있게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps</span> <span class=\"token operator\">=</span> Combine<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">{</span> id<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> ComponentPropsWithoutRef<span class=\"token operator\">&lt;</span><span class=\"token string\">'span'</span><span class=\"token operator\">>></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h3 id=\"원하는-엘리먼트로-렌더할-수-있게-만들기\" style=\"position:relative;\">원하는 엘리먼트로 렌더할 수 있게 만들기<a href=\"#%EC%9B%90%ED%95%98%EB%8A%94-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EB%A1%9C-%EB%A0%8C%EB%8D%94%ED%95%A0-%EC%88%98-%EC%9E%88%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"원하는 엘리먼트로 렌더할 수 있게 만들기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이제 <code class=\"language-text\">Text</code> 컴포넌트는 자유롭게 커스텀 프로퍼티와 렌더 대상인 HTML 엘리먼트의 프로퍼티를 모두 포함하는 유연한 컴포넌트가 되었지만 아직 한 가지 추상화가 더 남아있다.</p>\n<p>현재까지 만든 <code class=\"language-text\">Text</code> 컴포넌트는 무조건 <code class=\"language-text\">span</code> 엘리먼트로만 렌더가 가능하다. 그러나 앞서 여러 번 이야기했듯이 HTML을 사용하면서 컨텐츠를 표현할 때 반드시 <code class=\"language-text\">span</code>만 사용하라는 법은 없기 때문에 이제 렌더 대상인 엘리먼트까지도 자유롭게 바꿀 수 있는 녀석으로 한 단계 더 추상화해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Text</span></span> <span class=\"token attr-name\">as</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>p<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span> <span class=\"token comment\">// p로 렌더되며, p 엘리먼트의 속성이 타이핑됨</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Text</span></span> <span class=\"token attr-name\">as</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>a<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>...<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">target</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>...<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span> <span class=\"token comment\">// a로 렌더되며, a 엘리먼트의 속성이 타이핑됨</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>일반적으로는 <code class=\"language-text\">as</code>라는 프로퍼티를 사용하여 렌더하고 싶은 엘리먼트의 태그 명을 넘기게 되면 해당 엘리먼트로 렌더해주는 기능을 제공하는데, 필자도 그냥 이걸 똑같이 구현하기로 했다. <small><del>(사실 그냥 부트스트랩 배꼈다)</del></small></p>\n<p>앞선 추상화들에서는 렌더 대상이 되는 엘리먼트가 반드시 <code class=\"language-text\">span</code>이라는 보장이 있었기 때문에 그저 타입을 잘 합쳐주기만 하면 문제를 해결할 수 있었지만, 이제는 렌더 대상이 뭐가 될지 모르기 때문에 제네릭 타입으로 유연하게 받아와야 한다.</p>\n<p>다시 한번 아까 선언했던 <code class=\"language-text\">Text</code> 컴포넌트의 프로퍼티를 가져와서 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps</span> <span class=\"token operator\">=</span> Combine<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">{</span> id<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> ComponentPropsWithoutRef<span class=\"token operator\">&lt;</span><span class=\"token string\">'span'</span><span class=\"token operator\">>></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>필자는 이 타입이 <code class=\"language-text\">span</code> 뿐 아니라 다양한 엘리먼트를 받을 수 있도록 만들고 싶기 때문에 <code class=\"language-text\">ComponentPropsWithoutRef&lt;'span'></code> 타입이 제네릭으로 받고 있는 <code class=\"language-text\">span</code>이라는 녀석을 <code class=\"language-text\">ComponentPropsWithoutRef&lt;T></code> 처럼 변수화해야한다.</p>\n<p>즉, <code class=\"language-text\">as</code>라는 프로퍼티로 HTML 엘리먼트의 이름을 받고 나면 이 이름과 매칭되는 엘리먼트 속성 타입을 찾아 아까 만들었던 <code class=\"language-text\">Combine</code> 타입으로 <code class=\"language-text\">Text</code> 컴포넌트의 프로퍼티에 합쳐주면 되는 것이다.</p>\n<h4 id=\"제네릭과-타입-추론-부셔보기\" style=\"position:relative;\">제네릭과 타입 추론 부셔보기<a href=\"#%EC%A0%9C%EB%84%A4%EB%A6%AD%EA%B3%BC-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0-%EB%B6%80%EC%85%94%EB%B3%B4%EA%B8%B0\" aria-label=\"제네릭과 타입 추론 부셔보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>이제 어떻게 하면 필자가 생각했던 설계대로 타이핑을 할 수 있을 지 한번 생각해보도록 하자. 우선 가장 바깥 쪽에 위치해서 사용자로부터 직접 제네릭 타입 <code class=\"language-text\">T</code>를 받는 <code class=\"language-text\">Text</code> 컴포넌트의 프로퍼티부터 직접 타이핑해보면서 생각해보는 것이 좋을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// Text 컴포넌트의 커스텀 프로퍼티 선언</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TextBaseProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  typography<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">as</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Props&lt;T>는 ComponentPropsWithoutRef&lt;T>에 이 값을 그대로 넘겨준다.</span>\n<span class=\"token comment\">// 그리고 커스텀 프로퍼티 내부의 as에도 T 타입을 바인딩해준다.</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span>\n  Combine<span class=\"token operator\">&lt;</span>TextBaseProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> ComponentPropsWithoutRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">>></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<center>\n.<br />\n.<br />\n.<br />\n</center>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 27.500000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABNUlEQVR42k1Q2U7DMBDMp0BbkjbOacfxkctJSGkljqIiUSH+/zeGTSIBD6uZ2R2Pvfb2pkeQWESpW4olLaJ8RJQNa2/GpENMyBbdk6dDGDcLHlgF3xfwA4FdUMALq0cYPqKxr5DuHWb8QN1cYPor7PkL1XSDPt2If6OePlG7K9R4hezfUHQvkMMFglCRbrtneJNyOJojdNrB6jOUGMADDhFKiEiBH2bU4Ix4WILvBXENGRuUtJlMK0hCm9XoqbxW9+AZNVSPkjcUSFW0kJyMeQVTEs8tzWq0diSfQ03flIQFdncM/ibGwybClvj2nsEzFJSnFoIOq6KhAAfXPtFr6QIKr8yw4Kzn/tCd0NYTNPnCPW2SVWAHCp+Dtwk8QeZ1HQVBq/xW+MeX2TJfcdHROiv+n2EaP2hjxDu+cW7LAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"generic error\" title=\"\" src=\"/static/3823464654cd20a44beec2c98e1f9580/6af66/generic_error.png\" srcset=\"/static/3823464654cd20a44beec2c98e1f9580/69538/generic_error.png 160w,\n/static/3823464654cd20a44beec2c98e1f9580/72799/generic_error.png 320w,\n/static/3823464654cd20a44beec2c98e1f9580/6af66/generic_error.png 640w,\n/static/3823464654cd20a44beec2c98e1f9580/d9199/generic_error.png 960w,\n/static/3823464654cd20a44beec2c98e1f9580/21b4d/generic_error.png 1280w,\n/static/3823464654cd20a44beec2c98e1f9580/081ff/generic_error.png 2182w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>틀렸다 주인놈아...!</small>\n</center>\n<p>행복회로를 돌려보면 아무 문제 없을 것 같았던 필자의 타이핑에 왜 이런 문제가 발생한 것일까? 어차피 전부 <code class=\"language-text\">T</code>라는 타입 변수를 사용하고 있고 그걸 그대로 넘겨준 것 뿐인데 말이다.</p>\n<p>왜냐하면 <code class=\"language-text\">ComponentPropsWithoutRef</code>타입이 제네릭으로 받을 수 있는 타입이 <code class=\"language-text\">ElementType</code>으로 정해져있기 때문이다. 필자가 작성한 타입은 타입 변수 <code class=\"language-text\">T</code>에 대한 어떠한 제약도 없기 때문에 <code class=\"language-text\">Props&lt;T></code>에서 받은 타입을 바로 <code class=\"language-text\">ComponentPropsWithoutRef</code>에게 넘기려고 하면 컴파일러가 에러를 뱉어내는 슬픈 상황이 발생하는 것이다.</p>\n<p>그래서 타입 변수 <code class=\"language-text\">T</code>를 <code class=\"language-text\">ComponentPropsWithoutRef</code> 타입에게 안전하게 넘겨주고 싶다면, <code class=\"language-text\">Text</code> 함수가 제네릭으로 타입 변수를 받아오는 시점부터 전부 <code class=\"language-text\">ElementType</code> 타입만 사용할 수 있도록 제한을 만들어주어야 할 필요가 있다.</p>\n<p>제네릭 타입을 사용할 때 타입 변수로 들어올 수 있는 타입을 제한하려면 그냥 ”<code class=\"language-text\">T</code>는 <code class=\"language-text\">ElementType</code>을 상속한 녀석이어야해!”라고 명시적으로 컴파일러에게 알려주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TextBaseProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType<span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  typography<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">as</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType<span class=\"token operator\">></span></span> <span class=\"token operator\">=</span>\n  Combine<span class=\"token operator\">&lt;</span>TextBaseProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> ComponentPropsWithoutRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">>></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">Text</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> TextProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이렇게 작성한 타이핑을 보면 <code class=\"language-text\">Text</code> 컴포넌트가 제네릭 타입을 받고 있기 때문에 <code class=\"language-text\">&lt;Text&lt;'span'> /></code>처럼 이상한 문법으로 컴포넌트를 호출해야한다고 생각할 수도 있지만 사실은 그렇지 않다.</p>\n<p>왜냐하면 이 제네릭 타입 <code class=\"language-text\">T</code>는 추론이 가능한 녀석이기 때문이다. 위의 예시를 보면 <code class=\"language-text\">Text</code> 컴포넌트가 받고 있는 타입 변수 <code class=\"language-text\">T</code>는 <code class=\"language-text\">TextProps&lt;T></code>를 거쳐 <code class=\"language-text\">TextBaseProps&lt;T></code>로 넘어간 후 그대로 <code class=\"language-text\">as</code>에 바인딩되고 있다.</p>\n<p>결국 이 타입 변수들은 사실 모두 같은 녀석이라는 것이 보장된다는 것이다.</p>\n<hr>\n<ol>\n<li><code class=\"language-text\">Text&lt;T></code>의 타입 변수 <code class=\"language-text\">T</code></li>\n<li><code class=\"language-text\">TextProps&lt;T></code>의 타입 변수 <code class=\"language-text\">T</code></li>\n<li><code class=\"language-text\">TextBaseProps&lt;T></code>의 타입 변수 <code class=\"language-text\">T</code></li>\n<li><code class=\"language-text\">as</code> 프로퍼티에 바인딩 된 타입 변수 <code class=\"language-text\">T</code></li>\n<li><code class=\"language-text\">ComponentPropsWithoutRef&lt;T></code>의 타입 변수 <code class=\"language-text\">T</code></li>\n</ol>\n<hr>\n<p>그 말인 즉슨 이 중 한 군데만이라도 타입 변수 <code class=\"language-text\">T</code>가 어떤 타입인지 명확하게 알 수 있다면 나머지도 자연스럽게 추론이 가능하다는 이야기이다.</p>\n<p>이렇게 타입스크립트의 타입 추론 기능을 이용하면 <code class=\"language-text\">Text</code> 컴포넌트를 사용할 때 타입 변수 <code class=\"language-text\">T</code>의 기본 값으로 <code class=\"language-text\">span</code>을 할당하거나, 혹은 <code class=\"language-text\">as</code> 프로퍼티의 값으로 <code class=\"language-text\">span</code>과 같은 값이 들어온다면 나머지 <code class=\"language-text\">T</code>들도 자동으로 동일한 타입으로 채워지도록 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">Text</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType <span class=\"token operator\">=</span> <span class=\"token string\">'span'</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> Props<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token operator\">&lt;</span>Text <span class=\"token operator\">/</span><span class=\"token operator\">></span> <span class=\"token comment\">// -> T는 알아서 span으로 추론된다</span>\n<span class=\"token operator\">&lt;</span>Text <span class=\"token keyword\">as</span><span class=\"token operator\">=</span><span class=\"token string\">\"p\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span> <span class=\"token comment\">// -> T는 p로 추론된다</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 대략적인 타입 추론의 흐름을 파악했으니 타이핑을 제대로 해보도록 하자.</p>\n<h4 id=\"as-프로퍼티-타이핑을-추상화하기\" style=\"position:relative;\">as 프로퍼티 타이핑을 추상화하기<a href=\"#as-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%83%80%EC%9D%B4%ED%95%91%EC%9D%84-%EC%B6%94%EC%83%81%ED%99%94%ED%95%98%EA%B8%B0\" aria-label=\"as 프로퍼티 타이핑을 추상화하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>사실 <code class=\"language-text\">as</code> 프로퍼티처럼 원하는 엘리먼트로 렌더할 수 있는 기능을 가지는 컴포넌트는 <code class=\"language-text\">Text</code>만 있는 것이 아니다. 아직은 개발이 끝나지 않았지만, 페이지의 레이아웃을 담당하는 <code class=\"language-text\">Grid</code> 컴포넌트처럼 추상화된 관심사를 가진 컴포넌트들은 모두 이런 프로퍼티가 필요할 것이다.</p>\n<p>하지만 지금 필자가 <code class=\"language-text\">TextBaseProps</code> 타입에 <code class=\"language-text\">as</code>라는 프로퍼티를 직접 넣은 것처럼, 이런 컴포넌트의 프로퍼티를 선언할 때마다 개발자가 이 작업을 매번 수행하고 제네릭 타입의 추론 관계를 생각해야한다면 꽤나 불편할 것이다.</p>\n<p>그래서 다른 컴포넌트를 만들 때도 쉽게 <code class=\"language-text\">as</code>라는 프로퍼티를 추가할 수 있도록 이 부분의 타이핑을 최대한 추상화해놓을 필요가 있다. 이런 느낌으로 말이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// 텍스트 컴포넌트의 프로퍼티</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TextBaseProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  typography<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// T 타입을 추론할 수 있는 as 프로퍼티를 자동으로 포함하고</span>\n<span class=\"token comment\">// T 타입으로 HTML 엘리먼트 속성까지 타이핑 해주는 OverridableProps!</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType<span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> OverridableProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TextBaseProps<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">OverridableProps</code> 타입은 특정 컴포넌트가 <code class=\"language-text\">as</code> 프로퍼티를 사용하여 HTML 엘리먼트 이름을 받고, 내부적으로 해당 엘리먼트의 속성 타입을 찾아 바인딩해주는 부분만 추상화한 것이다.</p>\n<p>이렇게 필요한 부분을 추상화해두면 필자가 아닌 다른 개발자는 <code class=\"language-text\">ComponentPropsWithoutRef</code>을 사용해야한다던가 <code class=\"language-text\">Combine</code> 타입을 사용할 때 타입 변수 <code class=\"language-text\">T</code>를 <code class=\"language-text\">ElementType</code>으로 제한해야한다던가 하는 귀찮은 부분을 생각하지 않고도 <code class=\"language-text\">as</code> 프로퍼티를 쉽고 빠르게 추가할 수 있을 것이다. <small>(…라고 행복회로를 돌려봅니다)</small></p>\n<p>이제 <code class=\"language-text\">OverridableProps</code>를 만들기 위해서 아까 만들었던 녀석들을 조금씩 고쳐보도록 하자.</p>\n<p>아까 필자가 만들었던 <code class=\"language-text\">Combine&lt;T, K></code> 유틸 타입은 제네릭으로 받을 수 있는 타입에 제한이 없지만, 우리가 합쳐야 하는 HTML 엘리먼트의 속성들을 의미하는 <code class=\"language-text\">ComponentPropsWithoutRef&lt;T></code>는 제네릭으로 받을 수 있는 타입이 <code class=\"language-text\">ElementType</code>으로 제한되어 있다.</p>\n<p>그래서 제일 먼저 이 타입들을 쉽게 일치시킬 수 있는 작업을 먼저 해주어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">CombineElementProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType<span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> Combine<span class=\"token operator\">&lt;</span>\n  <span class=\"token constant\">K</span><span class=\"token punctuation\">,</span>\n  ComponentPropsWithoutRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span>\n<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// ComponentPropsWithoutRef 타입의 존재를 감추자</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType <span class=\"token operator\">=</span> <span class=\"token string\">'span'</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span>\n  CombineElementProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TextBaseProps<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">CombineElementProps</code>는 합치려고 하는 타입 두 가지 중 하나를 HTML 엘리먼트를 의미하도록 제한하고, 이 타입을 그대로 <code class=\"language-text\">ComponentPropsWithoutRef</code>에게 넘겨주기 때문에 타입이 깨지는 에러가 발생하지 않는다.</p>\n<p>그리고 <code class=\"language-text\">K</code> 타입 변수의 기본 타입을 <code class=\"language-text\">unknown</code>으로 정의함으로써 이 유틸 타입을 사용할 때는 반드시 <code class=\"language-text\">K</code>에 해당하는 타입인 컴포넌트의 프로퍼티를 입력하도록 강제하였다.</p>\n<p>같은 이유로 <code class=\"language-text\">CombineElementProps</code>로 제네릭 타입을 넘겨야하는 <code class=\"language-text\">TextProps</code> 역시 자신이 받는 타입을 <code class=\"language-text\">ElementType</code>으로 제한해야한다. 이후 이 <code class=\"language-text\">CombineElementProps</code>를 사용하여 <code class=\"language-text\">as</code> 프로퍼티를 추가해주는 <code class=\"language-text\">OverridableProps</code> 타입을 정의하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">OverridableProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType<span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">as</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">&amp;</span> CombineElementProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 제네릭 타입 추론이 가능한 as 프로퍼티까지 추가된다. </span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType<span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> OverridableProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TextBaseProps<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 <code class=\"language-text\">OverridableProps</code> 타입을 사용하여 상속하기를 원하는 <code class=\"language-text\">ElementType</code>과 자신이 선언한 컴포넌트의 프로퍼티만 넘기면 편하게 <code class=\"language-text\">as</code> 프로퍼티를 가진 타입을 만들어낼 수 있다.</p>\n<h2 id=\"전체-코드를-한-번에-보자\" style=\"position:relative;\">전체 코드를 한 번에 보자<a href=\"#%EC%A0%84%EC%B2%B4-%EC%BD%94%EB%93%9C%EB%A5%BC-%ED%95%9C-%EB%B2%88%EC%97%90-%EB%B3%B4%EC%9E%90\" aria-label=\"전체 코드를 한 번에 보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>아무래도 코드와 설명이 오가는 포스팅에서는 전체 코드의 맥락을 파악하기가 쉽지 않으니, 맥락을 파악하기 쉽도록 전체 코드를 복붙한 내용을 올린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Combine<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token operator\">&amp;</span> Omit<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">keyof</span> <span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">CombineElementProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType<span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> Combine<span class=\"token operator\">&lt;</span>\n  <span class=\"token constant\">K</span><span class=\"token punctuation\">,</span>\n  ComponentPropsWithoutRef<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span>\n<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">OverridableProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType<span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">as</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token operator\">&amp;</span> CombineElementProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">K</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">TextBaseProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  typography<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">TextProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType<span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> OverridableProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> TextBaseProps<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">Text</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> ElementType <span class=\"token operator\">=</span> <span class=\"token string\">'span'</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">{</span> typography <span class=\"token operator\">=</span> <span class=\"token string\">'content'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">as</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>props <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> TextProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  ref<span class=\"token operator\">:</span> Ref<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token keyword\">as</span> <span class=\"token operator\">??</span> <span class=\"token string\">'span'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> Component <span class=\"token operator\">=</span> target<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>Component\n      ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>ref<span class=\"token punctuation\">}</span>\n      <span class=\"token comment\">// 대충 타이포그래피 클래스 렌더하는 로직</span>\n      <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>props<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span>Text<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">typeof</span> Text<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 처음 <code class=\"language-text\">Text</code> 컴포넌트를 개발하는 사람으로 필자가 당첨되었을때는 조금 우습게 보고 있었다. 뭐 컴포넌트 겨우 하나기도 하고 그렇게 대단한 기능이 있는 것도 아니니까 금방 할 거라고 생각했는데, 생각보다 타이핑이 빡세더라.</p>\n<p>물론 필자는 회사에서든 개인 프로젝트든 주로 타입스크립트를 사용하고 있기는 하지만, 이렇게 겹겹이 추론되어야하는 제네릭 타이핑을 직접 작성할 일은 몇 번 없었기 때문에 그냥 그때마다 구글신께 여쭤봐서 어떻게든 해결하고 잊어버리는 상황의 연속이었던 것 같다.</p>\n<p>이번에 삽질하면서 처음 알게 된 사실이지만, <code class=\"language-text\">@types/react</code>의 내용은 그렇게 읽기에 빡센 편이 아니기 때문에 심심할 때 한번 쭉 살펴보는 것도 좋은 것 같다.</p>\n<p>필자가 이번에 많이 사용했던 <code class=\"language-text\">ComponentPropsWithoutRef</code> 타입은 내부적으로 4-5단계의 타입 참조 체인을 가지고 있는데, 여기서 참조하고 있는 타입들만 쭉 흝어봐도 평소에 유용하게 사용할 수 있는 녀석들을 많이 만날 수 있어서 좋았다.</p>\n<blockquote>\n<p><code class=\"language-text\">ComponentPropsWithoutRef&lt;T></code> > <code class=\"language-text\">PropsWithoutRef&lt;T></code> > <code class=\"language-text\">ComponentProps&lt;T></code> > <code class=\"language-text\">JSX.IntrinsicElements[T]</code> > …(몇 개 더 있음)</p>\n</blockquote>\n<p>막상 파일을 까보면 3천 줄 정도라서 전부 읽기에는 좀 부담스럽다고 느낄 수 있지만, 필자처럼 타입 참조 체인을 타면서 읽다보면 생각보다 핵심적인 타입의 개수는 그렇게 많지 않다. 게다가 HTML의 엘리먼트를 키로 가지고 있는 <code class=\"language-text\">IntrinsicElements</code> 같은 녀석들이 차지하는 라인 비중이 높기도 하다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 523px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 86.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3klEQVR42p1U13LiMADM/3/jgbvc5N5N2ezKXOYejhCiGY0woNU2+eNyuWDfd2xNizoxGPMCU2FhoxhtVaPvB9R1g6quUfF5nBZ8Nz7+At5uN5TWIogidKVFZzI0BOj6HtfrFT8dDnDbNvewcvWDAEmaoiTYn9MZnu/D2gpZljuGbwFqDYIQhoB5WTrwtu1wOnsEP6FpWwzjiGmanrL+knylZG0wJkVHRgO9bOmbWLddh45znme39sMA7fsWUENsPM9HQ7AmoWyukrnvx+b7/f4LyWGEhCwt2UlyFMfOv5Df26p6H1Ab5WHBpEMm3rBOQRi6cGSJ5A5O8gsPtSrNhF3s8xIjJQ/0S78piJFBLMviaqTnl6FoTDRdbAp5VxRI4sSFJCABPAviZW0SY1jy6ugkPwv06KN9s9jr6him8rAoEZNh2x4eytu6adyUly9rI5OzPGeiGeaM95lXT1L3x4H6n2QvPFRTV/U5w4eHR20OyQrozE6ePc+lqlB0Q96ULA8DSs5QsjYR3zi5wuEB8rZ69FD9vj8pugNc/wGUbyYx7s0Tkq089Omfx4P0CpO3Yj/Oq7tF8v2/Hmp6ZJETcMlKdGQpkJTgGb8f+pGpRy750JQs+Oj2yOdt278APwHFyiI78x0EuwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"typesafe actions\" title=\"\" src=\"/static/39be8850618810d1ad5bd7e3d45ddd2d/3e286/typesafe-actions.png\" srcset=\"/static/39be8850618810d1ad5bd7e3d45ddd2d/69538/typesafe-actions.png 160w,\n/static/39be8850618810d1ad5bd7e3d45ddd2d/72799/typesafe-actions.png 320w,\n/static/39be8850618810d1ad5bd7e3d45ddd2d/3e286/typesafe-actions.png 523w\" sizes=\"(max-width: 523px) 100vw, 523px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span>\n  <small>솔직히 <a href=\"https://github.com/piotrwitek/typesafe-actions/blob/master/src/type-helpers.ts\" target=\"_blank\">typesafe-actions</a>에 비하면 리액트의 타입 가독성은 상당히 혜자라고 볼 수 있다<br>여긴 진짜 지옥 그 자체...</small>\n</center>\n<p>이상으로 타입스크립트로 추상화하는 컴포넌트 설계 전략 포스팅을 마친다.</p>","fields":{"slug":"20201128-making-your-components-extensible-with-typescript","path":"/2020/11/28/making-your-components-extensible-with-typescript/","lang":"ko"},"frontmatter":{"title":"타입스크립트로 추상화하는 컴포넌트 설계 전략","subTitle":"제네릭과 타입 추론을 활용한 유연한 React 컴포넌트 설계","date":"Nov 28, 2020","categories":["프로그래밍","아키텍처","자바스크립트"],"tags":["React","TypeScript","타입스크립트","리액트","제네릭 타입","Generic Type"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/471db2e1aa1eff1dab0d1d6d36e45405/3a812/thumbnail.jpg","srcSet":"/static/471db2e1aa1eff1dab0d1d6d36e45405/3a812/thumbnail.jpg 320w,\n/static/471db2e1aa1eff1dab0d1d6d36e45405/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/471db2e1aa1eff1dab0d1d6d36e45405/fc5c5/thumbnail.webp 320w,\n/static/471db2e1aa1eff1dab0d1d6d36e45405/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/471db2e1aa1eff1dab0d1d6d36e45405/2d839/thumbnail.jpg","srcSet":"/static/471db2e1aa1eff1dab0d1d6d36e45405/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/471db2e1aa1eff1dab0d1d6d36e45405/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"5fcbcf92-b72a-58d5-8d81-781a1ac6c721","tableOfContents":"<ul>\n<li>\n<p><a href=\"#rest%EA%B0%80-%EC%9D%98%EB%AF%B8%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">REST가 의미하는 것이 무엇인가요?</a></p>\n<ul>\n<li><a href=\"#%EC%82%AC%EC%8B%A4-%EC%A3%BC%EA%B3%A0-%EB%B0%9B%EB%8A%94-%EA%B2%83%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EA%B0%80-%EC%95%84%EB%8B%88%EB%8B%A4\">사실 주고 받는 것은 리소스가 아니다.</a></li>\n<li><a href=\"#%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%9C-%EC%83%81%ED%83%9C%EB%9D%BC%EB%8A%94-%EA%B2%83%EC%9D%98-%EC%9D%98%EB%AF%B8\">리소스를 표현한 상태라는 것의 의미</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#restful-api\">RESTful API</a></p>\n<ul>\n<li><a href=\"#uri%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%96%B4%EB%96%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%EC%9D%B8%EC%A7%80-%ED%91%9C%ED%98%84%ED%95%98%EC%9E%90\">URI를 사용하여 어떤 리소스인지 표현하자</a></li>\n<li><a href=\"#http-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%96%B4%EB%96%A4-%ED%96%89%EC%9C%84%EC%9D%B8%EC%A7%80-%ED%91%9C%ED%98%84%ED%95%98%EC%9E%90\">HTTP 메소드를 사용하여 어떤 행위인지 표현하자</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 프론트엔드 개발자와 백엔드 개발자가 만나는 지점인 API에 대한 이야기를 해보려고한다. 일반적으로 앱이나 웹 상에서 작동하는 어플리케이션을 개발할 때는 주로 HTTP나 HTTPS 프로토콜을 사용하여 API를 만들게 되는데, 이 API의 정의가 얼마나 직관적이고 명확하냐에 따라 프로젝트의 복잡도가 크게 낮아지게 될 만큼 시스템 설계에 있어서 꽤나 중요한 자리를 차지하고 있다.","html":"<p>이번 포스팅에서는 프론트엔드 개발자와 백엔드 개발자가 만나는 지점인 API에 대한 이야기를 해보려고한다.</p>\n<p>일반적으로 앱이나 웹 상에서 작동하는 어플리케이션을 개발할 때는 주로 HTTP나 HTTPS 프로토콜을 사용하여 API를 만들게 되는데, 이 API의 정의가 얼마나 직관적이고 명확하냐에 따라 프로젝트의 복잡도가 크게 낮아지게 될 만큼 시스템 설계에 있어서 꽤나 중요한 자리를 차지하고 있다.</p>\n<!-- more -->\n<p>그래서 우리는 일종의 약속을 통해 이 API가 어떤 동작을 수행하는 API인지를 명확하게 정의해야 하며, 이 API 정의 과정에서 우리가 사용할 수 있는 요소들이 바로 “HTTP 메소드”와 “URI(Uniform Resource Identifiers)“이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET https://evan.com/users/1</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>HTTP API의 엔드포인트는 위와 같이 HTTP 메소드와 URI를 사용하여 이 API가 어떠한 동작을 수행하는 API인지를 표현하게 된다.</p>\n<p>여기서 중요한 포인트는 사용자가 이 표현을 읽고난 뒤 API에게 기대하는 동작과 실제로 서버가 수행하는 동작이 명확하게 일치되어야 한다는 것이다. 우리가 서버에게 “앞으로 한 걸음 가줘!”라고 요청했는데 서버가 응답으로 “ㅇㅋ 뒤로 한 걸음 갔음!”이라고 한다면 꽤나 당황스럽지 않겠는가?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5304fec38eebf202dff1871c8dc2a88e/6aca1/doesnt_know.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAwAE/8QAFAEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABTEBjtgk//8QAGhABAQACAwAAAAAAAAAAAAAAAQIAAwQRMf/aAAgBAQABBQJvX3yLhDXDL7bkSM//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwFn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAECERASIbH/2gAIAQEABj8Cu0yOngm5jx0//8QAGxABAAMAAwEAAAAAAAAAAAAAAQARITFBUZH/2gAIAQEAAT8hDdefeJhi76pNoCekB8YjTe6Qui2f/9oADAMBAAIAAwAAABBHH//EABYRAAMAAAAAAAAAAAAAAAAAAAEQIf/aAAgBAwEBPxCiv//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/EEf/xAAcEAEBAAICAwAAAAAAAAAAAAABEQAxUWEhQYH/2gAIAQEAAT8QC7sJVOqcd571u7BOzJ5BKJT5iKh5hnGBMkIPBlypaq5//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"doesnt know\" title=\"\" src=\"/static/5304fec38eebf202dff1871c8dc2a88e/c08c5/doesnt_know.jpg\" srcset=\"/static/5304fec38eebf202dff1871c8dc2a88e/0913d/doesnt_know.jpg 160w,\n/static/5304fec38eebf202dff1871c8dc2a88e/cb69c/doesnt_know.jpg 320w,\n/static/5304fec38eebf202dff1871c8dc2a88e/c08c5/doesnt_know.jpg 640w,\n/static/5304fec38eebf202dff1871c8dc2a88e/6aca1/doesnt_know.jpg 650w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>사람끼리든 컴퓨터끼리든 표현을 제대로 안하면 못 알아먹는다</small>\n</center>\n<p>그래서 우리는 <a href=\"https://ko.wikipedia.org/wiki/REST\" target=\"_blank\" rel=\"nofollow\">REST</a>와 같은 가이드라인을 사용한다. REST는 지난 2000년, 로이 필딩(Roy Fielding) 아저씨가 자신의 박사학위 논문에서 소개한 API 아키텍처 가이드라인이며, 무려 20년이 지난 현재까지도 널리 사용되고 있다.</p>\n<p>하지만 지난 번 <a href=\"/2020/03/15/about-http-status-code/\">서버의 상태를 알려주는 HTTP 상태 코드</a> 포스팅에서 이야기했듯이, 이건 말 그대로 가이드라인이기 때문에 지키지 않는다고 해서 에러가 발생하거나 하는 게 아니지만, 그렇다고해서 이런 가이드라인을 무시하고 마음대로 개발해도 된다는 것은 아니다. REST라는 용어와 개념은 이미 업계에 널리 퍼져있기 때문에, 많은 개발자들이 HTTP API를 만났을 때 이 API가 당연히 RESTful하게 작성되었을 것이라고 생각하기 때문이다. <small>(사실 상 표준이라고 봐도 무방할 정도의 영향력이다)</small></p>\n<p>그런 이유로 이번 포스팅에서는 이 REST라는 것이 도대체 왜 나오게 된 것인지, 또 REST가 뭘 의미하길래 사람들이 매번 RESTful, RESTful 하는 것인지에 대한 이야기를 나눠보려고 한다.</p>\n<h2 id=\"rest가-의미하는-것이-무엇인가요\" style=\"position:relative;\">REST가 의미하는 것이 무엇인가요?<a href=\"#rest%EA%B0%80-%EC%9D%98%EB%AF%B8%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\" aria-label=\"rest가 의미하는 것이 무엇인가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>REST는 <strong>RE</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer의 약자이다. 이 거창해보이는 단어의 핵심은 바로 Representational State, 한국말로 간단히 직역하면 대표적인 상태 정도의 뜻을 가진 단어이며, 이를 조금 더 유연하게 번역해보자면 “표현된 상태”라고 할 수 있다. 이때 이야기하는 상태라 함은 서버가 가지고 있는 리소스의 상태를 이야기한다.</p>\n<p>즉, REST는 통신을 통해 자원의 표현된 상태를 주고받는 것에 대한 아키텍처 가이드라인이라고 할 수 있다.</p>\n<p>REST에 대한 이야기를 할 때, 많은 분들이 이 표현된 상태(Representational State)에 대한 이해를 어려워하는데, 이는 클라이언트와 서버가 API 통신을 통해 주고 받고 있는 것들이 리소스 그 자체라고 생각하기 때문이다.</p>\n<p>하지만 조금만 생각해보면 우리가 통신을 통해 리소스를 직접 주고받고 있지 않다는 사실을 알 수 있다.</p>\n<h3 id=\"사실-주고-받는-것은-리소스가-아니다\" style=\"position:relative;\">사실 주고 받는 것은 리소스가 아니다.<a href=\"#%EC%82%AC%EC%8B%A4-%EC%A3%BC%EA%B3%A0-%EB%B0%9B%EB%8A%94-%EA%B2%83%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EA%B0%80-%EC%95%84%EB%8B%88%EB%8B%A4\" aria-label=\"사실 주고 받는 것은 리소스가 아니다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>우리가 API를 통해 주고 받는 리소스는 어떤 문서일수도 있고, 이미지 또는 단순한 JSON 데이터일 수도 있다. 하지만 사실 우리는 리소스를 직접 주고 받는 것이 아니다. 한번 간단한 예시를 통해 이 말이 어떤 의미인지 살펴보도록 하자.</p>\n<p>자, 여기 클라이언트가 서버에게 특정 유저의 정보를 받아오는 API 엔드포인트를 통해 요청을 보냈다고 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET https://iamserver.com/api/users/2\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">iamserver.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>클라이언트는 이 API 엔드포인트를 사용하여 서버에게 2번 유저의 자원을 요청했고, 서버가 요청을 성공적으로 처리했다면 클라이언트는 서버로부터 대략 이런 느낌의 응답을 받을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Length</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">45</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token application-json\">\n<span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token operator\">:</span> 'Evan'<span class=\"token punctuation\">,</span>\n  org<span class=\"token operator\">:</span> 'Viva Republica'<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>자, 서버가 보내준 응답의 바디에는 2번 유저의 데이터가 담겨있다. 일반적으로 우리는 이 상황을 <code class=\"language-text\">/api/users/2</code>라는 엔드포인트를 통해서 2번 유저 데이터 리소스를 받아왔다고 표현하고는 한다. 사실 필자도 편의상 이런 표현을 자주 사용하고는 한다.</p>\n<p>그런데…정말로 지금 서버가 보내준 저 JSON 데이터가 리소스 자체일까?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5fafe421bec63ab1a86624ca4488daf0/6a068/no.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 54.37499999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAQP/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABrlbpRogn/8QAGRABAQEAAwAAAAAAAAAAAAAAAQARAgMi/9oACAEBAAEFAh99xvLMhZtb/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGxAAAgEFAAAAAAAAAAAAAAAAAAFRAhARYYH/2gAIAQEABj8CdMGJEtHb/wD/xAAaEAACAgMAAAAAAAAAAAAAAAAAARFRITFB/9oACAEBAAE/IXPg3fBM7IcaIaUC9vIsO4//2gAMAwEAAgADAAAAEPgv/8QAFREBAQAAAAAAAAAAAAAAAAAAERD/2gAIAQMBAT8QSf/EABURAQEAAAAAAAAAAAAAAAAAABEA/9oACAECAQE/EBi//8QAHBABAAMAAgMAAAAAAAAAAAAAAQARITFRYXGB/9oACAEBAAE/EKoUDjSZxogWj5EWggiF1KCX1fJya1r3ANGPU//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"no\" title=\"\" src=\"/static/5fafe421bec63ab1a86624ca4488daf0/c08c5/no.jpg\" srcset=\"/static/5fafe421bec63ab1a86624ca4488daf0/0913d/no.jpg 160w,\n/static/5fafe421bec63ab1a86624ca4488daf0/cb69c/no.jpg 320w,\n/static/5fafe421bec63ab1a86624ca4488daf0/c08c5/no.jpg 640w,\n/static/5fafe421bec63ab1a86624ca4488daf0/6a068/no.jpg 960w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>땡. 저건 2번 유저의 리소스가 아니다!</small>\n</center>\n<p>사실 서버에서 보내준 저 JSON은 리소스 원본이 아니라 데이터베이스에 저장된 2번 유저의 데이터 리소스를 표현한 것에 불과하다. 서버는 클라이언트의 요청을 받고 2번 유저의 정보를 데이터베이스에서 조회한 후 요청의 헤더에 담겨있던 <code class=\"language-text\">application/json</code>이라는 방식으로 표현하여 응답에 담아준 것이다.</p>\n<p>곰곰히 생각해보면 당연한 이야기인 것이, 서버가 접근하는 진짜 리소스 원본은 그저 데이터베이스에 담겨있는 하나의 로우이거나 파일에 작성된 데이터일 것이다. 물론 서버의 로컬 시스템에 리소스를 JSON 파일로 저장하고 있을 수도 있지만 어쨌든 포인트는 서버가 보내준 저 JSON이 원본 리소스가 아니라는 것이다.</p>\n<p>서버가 보내준 JSON은 단지 데이터베이스에 저장되어있는 원본 데이터 리소스의 현재 상태를 표현한 것이다.</p>\n<h3 id=\"리소스를-표현한-상태라는-것의-의미\" style=\"position:relative;\">리소스를 표현한 상태라는 것의 의미<a href=\"#%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%9C-%EC%83%81%ED%83%9C%EB%9D%BC%EB%8A%94-%EA%B2%83%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"리소스를 표현한 상태라는 것의 의미 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>앞서 이야기했듯이 REST가 이야기하는 Representation State라는 단어는 원본 리소스를 표현한 상태라는 것을 의미한다. 원본 리소스는 데이터베이스에 저장된 하나의 로우로써 존재하지만 클라이언트에게 이걸 그대로 넘겨줄 수는 없으니 서버가 원본 리소스를 읽어와서 적당한 상태로 표현해주는 것이다.</p>\n<p>그리고 이 적당한 상태에 대한 힌트는 HTTP 요청 헤더나 응답 헤더에 전부 나와있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET https://iamserver.com/api/users/2\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">iamserver.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위에서 예시로 들었던 상황에서 클라이언트는 서버에게 2번 유저의 리소스를 요청하며 요청 헤더의 <code class=\"language-text\">Accept</code>라는 키에 <code class=\"language-text\">application/json</code>이라는 값을 담아서 보냈다. 클라이언트가 서버에게 “2번 유저의 상태를 json으로 표현해줘”라는 요청을 보낸 것이다. 만약 클라이언트가 <code class=\"language-text\">application/json</code>이 아닌 <code class=\"language-text\">application/xml</code>을 담아보냈고, 서버가 XML 포맷의 표현을 지원하도록 작성되어있다면 2번 유저의 리소스는 XML 형태로 표현되어 내려왔을 것이다.</p>\n<p>그리고 서버는 응답 헤더에 <code class=\"language-text\">Content-Type</code>이나 <code class=\"language-text\">Content-Language</code>와 같은 키를 사용하여 이 리소스가 어떤 방식으로 표현된 상태인지 클라이언트에게 알려주고, 클라이언트 또한 이 정보를 읽은 후 각 컨텐츠 타입에 맞게 정보를 파싱한다.</p>\n<p>즉, 클라이언트는 2번 유저의 리소스를 받은 것이 아니다. JSON으로 표현된 2번 유저 리소스의 현재 상태를 받은 것이다. 이처럼 REST는 클라이언트와 서버가 리소스의 타입이나 원하는 언어 등을 사용하여 자원을 자유롭고 명확하게 표현할 수 있는 것에 집중한다.</p>\n<h2 id=\"restful-api\" style=\"position:relative;\">RESTful API<a href=\"#restful-api\" aria-label=\"restful api permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 이야기했듯이, REST는 결국 리소스를 어떻게 하면 명확하게 표현할 수 있을지에 대한 것에 집중하는 아키텍처 스타일이다. 하지만 우리가 HTTP API를 사용할 때는 단순히 리소스의 표현 상태만으로는 클라이언트가 API를 호출했을 때 서버에서 정확히 어떤 일이 발생하는지 알기가 어렵다.</p>\n<p>REST는 단지 리소스가 표현된 상태만을 이야기할 뿐, 어떠한 “행위”에 대해서는 이야기하고 있지 않기 때문이다. 하지만 클라이언트가 서버의 API를 사용할 때 원하는 것은 소스를 생성하거나 삭제하거나 수정하는 등 명백히 어떠한 행위이다.</p>\n<p>그래서 RESTful API에서는 REST 아키텍처를 통해 표현된 리소스와 더불어 어떠한 행위를 명시할 수 있는 HTTP 메소드와 URI까지 활용하게 되며, 각 요소들이 표현하고 있는 것들은 다음과 같다.</p>\n<hr>\n<ol>\n<li>리소스가 어떻게 표현되는지? - <strong>REST</strong></li>\n<li>어떤 리소스인지? - <strong>URI</strong></li>\n<li>어떤 행위인지? - <strong>HTTP 메소드</strong></li>\n</ol>\n<hr>\n<p>즉, 이 요소들을 사용하여 명확하게 정의된 API를 사용하는 클라이언트는 굳이 API에 대한 구구절절한 설명이 없이 <code class=\"language-text\">GET /users/2</code>와 같은 엔드포인트만 보고도 “음, 2번 유저의 정보를 가져오는 API겠군”이라고 추측할 수 있게 되는 것이다.</p>\n<p>이 3가지 요소 중 리소스를 표현하는 방법인 REST에 대해서는 앞서 이미 이야기했으니, 이번 섹션에서는 어떤 리소스인지를 표현하는 URI와 어떤 행위인지를 표현하는 HTTP 메소드에 대해 알아보도록 하자.</p>\n<h3 id=\"uri를-사용하여-어떤-리소스인지-표현하자\" style=\"position:relative;\">URI를 사용하여 어떤 리소스인지 표현하자<a href=\"#uri%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%96%B4%EB%96%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%EC%9D%B8%EC%A7%80-%ED%91%9C%ED%98%84%ED%95%98%EC%9E%90\" aria-label=\"uri를 사용하여 어떤 리소스인지 표현하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>RESTful API의 URI는 이 API가 어떤 리소스에 대한 API인지를 나타내는 요소이다. 예를 들어, 서비스를 사용하는 유저의 목록을 가져오는 API가 있다고 생각해보자. 이 API를 사용하는 클라이언트가 접근하고자 하는 리소스는 “유저”가 될 것이고, 이 API의 URI는 명확하게 유저를 표현하고 있어야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET /users</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>솔직히 이 정도 URI면 지나가던 중학생이 봐도 뭔가 유저와 관련이 있다는 것을 알 수 있을 정도로 명확하다. 그런데 유저라는 리소스를 왜 <code class=\"language-text\">user</code>라고 표현하지 않고 굳이 <code class=\"language-text\">users</code>라는 복수형으로 표현하고 있는 것일까?</p>\n<p>그 이유는 유저라는 리소스가 특정한 하나의 객체가 아니기 때문이다. 이건 영어로 “나는 고양이를 좋아해!”라는 문장을 이야기할 때 “I love <strong>a cat</strong>“가 아닌 “I love <strong>cats</strong>“라고 하는 것과 같은 맥락이다.</p>\n<p>나는 어떤 특정한 고양이를 좋아하는 것이 아니라 고양이라는 생물 자체를 좋아하는 것이고, 이때 고양이라는 단어는 우리 아파트 앞에서 쓰레기통 뒤지고 있는 점박이 고양이, 이름 모를 사람이 인스타그램에 이쁘다고 자랑하는 지네 집 고양이, 길 가다가 우연히 마주치는 고양이까지 모두 포함되는 다소 추상적인 리소스를 의미하는 것이기 때문이다.</p>\n<p>자, 그럼 유저들이라는 추상적인 리소스에서 한 단계 더 구체화 시켜보도록 하자. 유저라는 추상적인 리소스를 조금 더 구체화한 다음 레벨의 리소스는 “특정 유저”이다.</p>\n<h4 id=\"리소스의-계층을-표현하기\" style=\"position:relative;\">리소스의 계층을 표현하기<a href=\"#%EB%A6%AC%EC%86%8C%EC%8A%A4%EC%9D%98-%EA%B3%84%EC%B8%B5%EC%9D%84-%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0\" aria-label=\"리소스의 계층을 표현하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>일반적으로 유저들은 각각 고유한 ID를 가지고 있는 경우가 많으니, 이 ID를 사용하면 특정한 유저를 대충 이런 URI로 표현할 수 있을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET /users/2</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>굳이 설명하지 않더라도 다들 눈치채셨겠지만, 이 URI는 유저들을 의미하던 <code class=\"language-text\">/users</code>라는 URI 뒤 쪽에 각 유저들이 고유하게 가지고 있는 ID를 추가하여 특정한 유저를 식별할 수 있도록 만든 것이다.</p>\n<p>또한 이 URI가 표현하고 있는 리소스인 “2번 유저”는 “유저”라는 리소스의 하위 집합이라고 할 수 있고, RESTful API는 이러한 리소스 간의 계층 구조를 <code class=\"language-text\">/</code>를 사용하여 표현할 것을 권장하고 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b57aa2a5b2149437f1bfe0021e65f2f7/5bb8b/resource_layer.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 98.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC+klEQVR42p2U7U4TQRSGeysmXoHxF5LS7m63xSCUtNtSW6C0hbYg1sIfo0BsKSY0oR9sheWjH6DEbNEYqoJGuADvwttQxryeWSiW0kThx5OZnHnPe85MZsa0sbHRRehEvRPr6+v1Ukmtq6pK87Ur65qm6cQ7mlc3Nzdvmcrl8uf9/X3UajW2s7ODViiGg4MGjo6+4vDwC3S9bsTadcQp96hUKssmcj6uVqug8SfBWlnXNLb3psY+HbxljQ97bKdWYdQNa9fxXF6IOlQNQ15ldXWVEWjnlVrAlpbHplZASS2ik4bn7u7ugoqppu3t7ZNsNotIJMKi0ShamZiYQDw+ienpBKampikWQ7uGMz4+zkqlEuj4VH6GJ6lUCmNjY4wb0KIBn4dCIczMJKGqJeRyecRjMV74QtPU8dyVlRXQ0Z0ZptNpnszi8ThilNRkcjKOF/NJLC/OIkXj/LOEEWvVcLhhLpf7a7i4uIhgMMh8Ph+GhoYMFEWB2+2Gh0av5wyPx2PEvV7vhc7v9181zGQyIDNmtVohCCIsFgucTidcLheZKhgYGDDo7+83sNlspBMM+Hx4eJjl8/mrhqIoQiaBKApchGQygYWFOSQSCSSfPMbc86d4uZSB4naBF5ckCbIsIxAIdDIcMjq875ARCysYDw7C7+1DZNSJaMiFYKDfiI36nZiaUDD7yIde0kqSrbMhnQfjW+Bd8m3zkXfAuWfuQY9VMOLW8zXZJhkj3/I/DZsI3JSYGbRhzGGBwAs0186Nr20omrvwY3cJH9NT6O7uMjpu1VzPkLYpKlF8b7yHXn2Nu3YfbCLXSP9neHZtzq6DKFhhFh14kNSwXG5gfq2BOw+X0KppXpt2w2N+semCMofDgXZkyQKLuRvWnm70ysKlNbvdjr6+PoyMjBgX23jL5PqNd0gv5Vc4HP5NT/Ay4cjvcISgMRSKXFnnOTz34qXQ13Wo6zoKhQIrFou4CfR9nZ5/0lkT/WFm+hjr1O6NoF9aJ/bJo7a1tXX7Dyntkgi4sEC8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"resource layer\" title=\"\" src=\"/static/b57aa2a5b2149437f1bfe0021e65f2f7/6af66/resource_layer.png\" srcset=\"/static/b57aa2a5b2149437f1bfe0021e65f2f7/69538/resource_layer.png 160w,\n/static/b57aa2a5b2149437f1bfe0021e65f2f7/72799/resource_layer.png 320w,\n/static/b57aa2a5b2149437f1bfe0021e65f2f7/6af66/resource_layer.png 640w,\n/static/b57aa2a5b2149437f1bfe0021e65f2f7/5bb8b/resource_layer.png 749w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>유저 &gt; 특정 유저 &gt; 특정 유저의 프로필 사진으로 이어지는 계층 구조<small>\n</small></small></center>\n<p>이러한 리소스 간의 계층 구조는 어플리케이션에서 사용하는 리소소들의 관계를 어떻게 설정할 것이냐에 대한 문제이기 때문에 API를 설계할 때 굉장히 중요하고 예민한 요소인데다가, 대부분의 설계 패턴이 그러하듯이 이건 정답이 정해져있는 것도 아니기 때문에 고민을 깊게 할 수 밖에 없는 문제다.</p>\n<p>정답이 정해져있지 않다는 것은 프로필 사진이라는 리소스를 <code class=\"language-text\">/users/2/profile-image</code>라는 계층 구조가 아니라 <code class=\"language-text\">/profile-images/users/2</code>와 같은 계층으로 설계해도 논리 상으로는 아무런 문제가 없다는 것을 의미한다. 여기에는 단지 프로필 사진이라는 리소스가 어떤 의미를 가질 것이냐의 차이만 있을 뿐이다.</p>\n<hr>\n<center>\n<code class=\"language-text\">/users/2/profile-image</code><br />\n<small>유저들 중 2번 유저의 프로필 사진</small>\n</center>\n<br />\n<center>\n<code class=\"language-text\">/profile-images/users/2</code><br />\n<small>프로필 사진들 중 유저들의 프로필 사진 중 2번 유저의 프로필 사진</small>\n</center>\n<hr>\n<p>이처럼 같은 프로필 사진이지만 리소스의 계층을 어떻게 설계하냐에 따라 의미가 완전히 달라지게 된다. 이 케이스의 경우 유저 외에 프로필 사진을 가질 수 있는 다른 리소스가 존재하지 않는다면 <code class=\"language-text\">/users/2/profile-image</code>가 적당하지만 유저 외에도 다양한 리소스가 프로필 사진을 가져야 하는 상황이라면 <code class=\"language-text\">profile-images/users/2</code>라는 계층 구조도 고민해볼 수 있을 것이다.</p>\n<p>결국 우리가 고민해야 할 문제는 특정 유저의 프로필 사진이라는 리소스를 포함하는 상위 계층 리소스가 “유저가 더 명확하냐”, “프로필 사진이 더 명확하냐”인 것이다.</p>\n<p>물론 앞서 이야기했듯이 정답은 없으니, 항상 빠르게 변화하는 비즈니스 상황에 유연하게 대처할 수 있도록 팀원들과 협의해보고 URI를 설계하도록 하자.</p>\n<h4 id=\"uri에는-행위가-표현되면-안된다\" style=\"position:relative;\">URI에는 행위가 표현되면 안된다<a href=\"#uri%EC%97%90%EB%8A%94-%ED%96%89%EC%9C%84%EA%B0%80-%ED%91%9C%ED%98%84%EB%90%98%EB%A9%B4-%EC%95%88%EB%90%9C%EB%8B%A4\" aria-label=\"uri에는 행위가 표현되면 안된다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>RESTful API의 URI를 설계할 때 또 한 가지 중요한 것은 URI에 어떠한 행위를 의미하는 표현이 포함되어서는 안된다는 것이다. 예를 들어 유저를 삭제하는 엔드포인트가 하나 있다고 생각해보자. 이때 HTTP 메소드에 익숙하지 않다면, 대략 이런 느낌의 엔드포인트를 설계할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">POST /users/2/delete</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 엔드포인트의 URI에는 삭제 행위를 의미하는 <code class=\"language-text\">delete</code>라는 표현이 포함되어 있다. 뭐 사실 이대로도 이 API가 어떤 역할을 수행하는 API인지 인지하기에는 큰 무리가 없지만, RESTful API는 URI를 사용하여 행위를 표현하지 않을 것을 권고한다. URI가 가지는 의미는 철저히 어떤 리소스인지, 그리고 리소스의 계층 구조에 대한 것 뿐이어야한다.</p>\n<p>API가 수행하는 행위는 되도록이면 올바른 HTTP 메소드를 사용하여 표현해주는 것이 좋다. 그리고 단순히 이건 RESTful API가 이런 설계를 권고하기 때문인 것도 있지만, RESTful API의 가이드라인을 지키지 않도록 개발된 여러분의 어플리케이션이 이미 RESTful API의 가이드라인을 지키며 개발된 다른 어플리케이션들과 통신할 때 어떤 부작용이 발생할지 모르기 때문이기도 하다. <small>(당장 웹 브라우저만 해도 HTTP 메소드와 상태 코드에 상당히 종속되어 설계되어 있다)</small></p>\n<p>그리하여 올바르게 작성된 엔드포인트는 삭제를 의미하는 HTTP 메소드인 <code class=\"language-text\">DELETE</code>를 사용한 요런 엔드포인트가 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">DELETE /users/2</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>자, 지금까지 URI를 사용하여 리소스를 표현하는 방법에 대해 살펴보았으니, 이제는 API의 행위를 표현하는 방법에 대해서 알아볼 차례이다.</p>\n<h3 id=\"http-메소드를-사용하여-어떤-행위인지-표현하자\" style=\"position:relative;\">HTTP 메소드를 사용하여 어떤 행위인지 표현하자<a href=\"#http-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%96%B4%EB%96%A4-%ED%96%89%EC%9C%84%EC%9D%B8%EC%A7%80-%ED%91%9C%ED%98%84%ED%95%98%EC%9E%90\" aria-label=\"http 메소드를 사용하여 어떤 행위인지 표현하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>RESTful API는 HTTP 메소드를 사용하여 API가 수행하는 행위를 표현하도록 권고하고있다. HTTP 메소드는 나름 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\" target=\"_blank\" rel=\"nofollow\">RFC-2616</a>에서 정의된 표준이기 때문에 상황에 맞지 않는 메소드를 사용하게 되면 어플리케이션이 예상하지 못한 동작을 일으킬 수 있다는 사실을 기억하도록 하자.</p>\n<p>사실 API를 사용하여 하게되는 행위는 대부분 “CRUD(Create, Read, Update, Delete)” 이기 때문에, 몇 가지 특수한 경우를 제외하면 단 5가지의 HTTP 메소드만으로도 대부분의 API를 정의할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>리소스를 조회한다</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>리소스를 대체한다</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>리소스를 삭제한다</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>리소스를 생성한다</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>리소스의 일부를 수정한다</td>\n</tr>\n</tbody>\n</table>\n<p>이 외에도 <code class=\"language-text\">HEAD</code>, <code class=\"language-text\">OPTION</code>, <code class=\"language-text\">TRACE</code> 등의 메소드도 존재하기는 하지만, 사실 이 5가지의 메소드가 가지는 역할만 확실히 알고 있어도 HTTP 메소드를 사용하여 올바른 행위를 표현하거나 RESTful API를 설계하기에는 전혀 무리가 없다.</p>\n<p>여기서 한 가지 헷갈릴만한 것은 바로 <code class=\"language-text\">PUT</code>과 <code class=\"language-text\">PATCH</code> 메소드인데, 이 메소드들은 동일하게 “리소스를 수정한다”라는 의미로 해석되는 경우가 많기 때문에 정확히 어떤 경우에 <code class=\"language-text\">PUT</code>을 사용하고 어떤 경우에 <code class=\"language-text\">PATCH</code>를 사용해야 하는지 구분하기 어려운 경우가 많다.</p>\n<h4 id=\"put과-patch의-차이는-무엇인가요\" style=\"position:relative;\">PUT과 PATCH의 차이는 무엇인가요?<a href=\"#put%EA%B3%BC-patch%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\" aria-label=\"put과 patch의 차이는 무엇인가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>흔히들 <code class=\"language-text\">PUT</code> 메소드를 리소스를 수정한다는 개념으로 설명하고는 하지만, 실제 <code class=\"language-text\">PUT</code> 메소드가 의미하는 것은 리소스를 수정하는 것이 아니라 리소스를 요청 바디에 담긴 것으로 대체하는 것이다.</p>\n<p>한번 <code class=\"language-text\">{ id: 1, name: 'evan' }</code>이라는 유저 리소스의 이름을 <code class=\"language-text\">ethan</code>으로 수정해야하는 상황을 생각해보자. 만약 우리가 <code class=\"language-text\">PUT</code> 메소드를 사용하여 이 리소스를 수정한다면 우리는 반드시 요청 바디에 유저 리소스 전체를 표현하여 보내야한다.</p>\n<p>즉, 수정할 사항만 보내는 것이 아니라 수정하지 않을 사항까지도 모두 보내야한다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">PUT /users/1\n{ id: 1, name: 'ethan' }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/01507d03747ddad000635c4cc253c959/1d499/put_method.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACUUlEQVR42o2S30taYRjHXdvFYFCbwQKLXexy4KWMlI7TNdOjHdO06dLjOeYmDcGlSO0qkBpa7kJYN8u04Vmixxt/JPgfiJfe9ResgUQFeqGn99l7YsZYEb3w8PyA98P3+SGR3PLsdvt9hUIxKpfLn4yNjT2VSqXDYu22PxK1Wv1QJpONTky8kI6MjDw2Go3j2Ww2yR3kOO5nbp/juGyxWOTK5XKuXKlky9XqfrVa5Q4PD5O1Wm1YZADAvSugRqNJ6XS6LrZfWq32N0VRbafTiWjXW2BoJ9hsNgiHw5BK7UFq9ztkf2RQJpMBnuc7rVbr+V/g0BVQr9eX3G432BfmBbOFAoZhYHr6tWAmCcE6qxHUakKgaVqIx+PC1+0vwt7ut34ymUTpdPq82WxeAtfX14f+bVmvUqk+K5XK0OTLySBWGg0Ggz3aw4LH40Usw0IoFIJEIgGx2DZsbsZQLBYDDOzcCBy8QRHLH19bW+sa9HqwWOeQwWgAq9UKJEkCZXoDFmoG4Q7g08pK5/j4+DpQTMTNYf9AzE9OTp6trq52Z02zeAx2ZKJMWKkH5vEsnQs4XjQjkjRAJBK5Gfi/wna7PY7b63q9XvD5fMj/wQ8sy4ox+N77YWnJj8R4a2urc3R0dLeWA4HAOUEQF3jjPUJL9LHvU+a5Pjnzqm82aXpTU1MXy8sfz05PT+8G3NjY6DocDlEZcrkWQVQrqqTd74BlFpHD4YRoNNq5FTg4znq9/qhUKu0UCgUe2wHPF3P5fP7SxLhQKOJaga9UKjuNRuPaYf8B+eZOndX+TzwAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"put method\" title=\"\" src=\"/static/01507d03747ddad000635c4cc253c959/6af66/put_method.png\" srcset=\"/static/01507d03747ddad000635c4cc253c959/69538/put_method.png 160w,\n/static/01507d03747ddad000635c4cc253c959/72799/put_method.png 320w,\n/static/01507d03747ddad000635c4cc253c959/6af66/put_method.png 640w,\n/static/01507d03747ddad000635c4cc253c959/d9199/put_method.png 960w,\n/static/01507d03747ddad000635c4cc253c959/21b4d/put_method.png 1280w,\n/static/01507d03747ddad000635c4cc253c959/1d499/put_method.png 1632w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>PUT 메소드는 리소스를 수정하는 것이 아니라 대체하는 것이다</small>\n</center>\n<p>이렇게 리소스를 대체한다는 <code class=\"language-text\">PUT</code> 메소드의 특성 상, 실수로 <code class=\"language-text\">{ id: null, name: 'ethan' }</code>과 같은 리소스를 전송해버리기라도 하면 이 유저는 영영 ID를 잃어버린 비운의 유저가 되어버리는 경우도 발생할 수 있다. <small>(사실 이 정도 예외처리는 다들 기본적으로 해놓긴 한다.)</small></p>\n<p>하지만 그냥 리소스를 받아서 대체하면 된다는 동작 자체가 워낙 심플하기 때문에 리소스를 수정하는 쪽이든 받아서 처리하는 쪽이든 이것저것 신경써줘야 할 일이 별로 없어서 편하기는 하다.</p>\n<p>반면 우리가 <code class=\"language-text\">PATCH</code> 메소드를 사용하여 방금과 동일한 행위를 하려고 하면 어떨까?</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">PATCH /users/1\n{ name: 'ethan' }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f42966e7e24473577e61e2dda4f7aa09/c1b63/patch_method.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAADFUlEQVR42n1Uz0sbQRSO2GJpD9ba0kObQsEIWvBkrEKycbPJRhOTTSKJWoxRYxrEisYoVjw1MaUFEX8galRE9ORJ/IGgiCfFgwqlXkpz6K1/Qqnbzdc3i4otTQc+vrfvvflm3puZ1WiyjKKiorySkpIXZWVlxaWlpQ/I1hUXFz/X6XRPfD5fbrZ5GgA5a2trasLe3t6zk5OTytPT03Lil9vb2+adnZ3qg4MDw9bWFs+wu7trOjs701/mVFLs6aVUjuamQcK5m5ubpwuLi5ienpZnZmZ+ES7m5uYuUqmUPD8/f8HA7LlUSqGYvLS0hI2NjUO2qWuthoYGbVNTkzsajdYnEvHvklQHe21NRhAEWCwWmEwmVFVVoqKigqBXWa/Xg+OMit1ux+zs7DkJ3r6qVhMMBkP9/f0YHHz7ozPSnhmMBvGmMwiXyw2b3QqD0QCtVovCwoe4n5+Px48KUHD/HhNW6urqMDEx8flKUN0hOe+Wl5drBwYGdGNjY9/8Ph/ckjvj8Xjg9XrgdrvhdDppAdclE4glSVIaGxuxsLBw/ofgVf3EeXQ46aGhIfT09CrUAsT6Yujr64Nqx2KIUSXRKPPF0NvbqwwPD4PmZBW8Mz4+nmZ9s1qtis1mA1dthCCYwXolCBaYeQ6OWh41ogk8b1Jzpqamsu+QSk6zyVSu4vf7YRarIbklvA6Hqfx61Np4RII1CDRYIIqC4nS6WA+zCy4vL6fDNDkQCCgtLS1oa20D4+bmZpVbW1vRHAgi0BJk30okEsHKykp2QQqmu7q6EAqFlI6ODjCEw69VJh9xGCFCBy3a3t6udHd3Y3V19f8lsx6Koqh4vV6INVaYLTy8Hi/ouUG0CqiXzHA5eLXPlIfJycnsgnQoXziOo4bzPx0Oh8ybeZnjOZmui0zXRDYaDbLDZpBtVoPMmap/Uh47lE//FMxkMnnr6+tfR0dHMTIyoiQSCSRHkkgmk2B2PB5H8j2zkxR/r+ZQRezpsYt96+/3rI79/f1XR0dHHw4PD98Rx69wfHys4qaP5RA+0s/Cf/3sNBrNbw2AJbS7KLM6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"patch method\" title=\"\" src=\"/static/f42966e7e24473577e61e2dda4f7aa09/6af66/patch_method.png\" srcset=\"/static/f42966e7e24473577e61e2dda4f7aa09/69538/patch_method.png 160w,\n/static/f42966e7e24473577e61e2dda4f7aa09/72799/patch_method.png 320w,\n/static/f42966e7e24473577e61e2dda4f7aa09/6af66/patch_method.png 640w,\n/static/f42966e7e24473577e61e2dda4f7aa09/d9199/patch_method.png 960w,\n/static/f42966e7e24473577e61e2dda4f7aa09/c1b63/patch_method.png 1200w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>PATCH 메소드는 리소스의 일부분을 수정하는 것이다</small>\n</center>\n<p><code class=\"language-text\">PUT</code> 메소드와 다르게 <code class=\"language-text\">PATCH</code> 메소드는 진짜로 현재 저장되어 있는 리소스에 수정을 가하는 행위를 의미하기 때문에 굳이 수정하지 않은 사항을 요청 바디에 담아줄 필요도 없다.</p>\n<p><code class=\"language-text\">PATCH</code>메소드는 <code class=\"language-text\">PUT</code>처럼 수정하지 않을 사항까지 보낼 필요가 없고 진짜 수정하고 싶은 사항만 깔끔하게 보내면 되기 때문에, 쓸데없이 큰 요청 바디를 만들지 않을 수 있다.</p>\n<p>또한 실제로 이러한 수정 동작을 수행하는 API를 사용할 때는 SQL의 <code class=\"language-text\">UPDATE</code>와 동일한 의미를 떠올리는 경우가 많기 때문에, 리소스를 대체하는 <code class=\"language-text\">PUT</code> 메소드보다 리소스의 일부를 수정하는 <code class=\"language-text\">PATCH</code> 메소드가 수정이라는 의미를 가지기에도 더 적합하다고 할 수 있다.</p>\n<p>아직까지는 리소스를 수정하는 행위를 표현할 때 <code class=\"language-text\">PUT</code> 메소드를 주로 사용하는 경우가 많기는 하지만, <code class=\"language-text\">PUT</code> 메소드와 <code class=\"language-text\">PATCH</code> 메소드의 의미적인 차이는 분명히 존재하므로 API의 엔드포인트를 설계할 때 “리소스를 대체”, “리소스를 수정” 중 원하는 행위와 일치하는 메소드를 사용하는 것을 권장한다.</p>\n<p>그러나 <code class=\"language-text\">PUT</code> 메소드와 <code class=\"language-text\">PATCH</code> 메소드의 진짜 중요한 차이점은 이런 행위의 의미가 아니라, <code class=\"language-text\">PUT</code> 메소드는 반드시 멱등성을 보장하지만 <code class=\"language-text\">PATCH</code> 메소드는 멱등성을 보장하지 않을 수도 있다는 것이다.</p>\n<h4 id=\"메소드가-멱등성을-보장하는가\" style=\"position:relative;\">메소드가 멱등성을 보장하는가?<a href=\"#%EB%A9%94%EC%86%8C%EB%93%9C%EA%B0%80-%EB%A9%B1%EB%93%B1%EC%84%B1%EC%9D%84-%EB%B3%B4%EC%9E%A5%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"메소드가 멱등성을 보장하는가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>멱등성이란, 수학이나 전산학에서 어떤 대상에 같은 연산을 여러 번 적용해도 결과가 달라지지 않는 성질을 이야기한다. 즉, 단순히 HTTP 메소드에만 국한된 이야기는 아니고 이는 데이터베이스나 파일에 자원을 읽고 쓰는 등 컴퓨터가 수행하는 모든 연산에 해당되는 이야기이다.</p>\n<p>가장 대표적으로 멱등성이 보장되는 연산은 바로 어떠한 수에 1을 곱하는 연산이다. <code class=\"language-text\">x => x * 1</code>과 같은 함수는 어떠한 값에 1번을 적용하든, 10,000번을 적용하든 항상 <code class=\"language-text\">x</code>를 반환한다.</p>\n<p>그러나 1을 곱하는 것이 아니라 1을 더하거나 빼는 함수라면 한번 호출될 때마다 인자로 주어진 값을 계속 증가시키거나 감소시킬 것이므로 항상 같은 값을 반환하지 않는다. 이러한 성질의 연산이 바로 멱등성을 보장하지 않는 연산의 대표적인 예이다.</p>\n<p>HTTP 메소드 또한 결국 어떠한 자원을 읽고 쓰고 수정하고 지우는 CRUD에 대한 의미를 가지기 때문에, 우리는 어떤 행위가 멱등성을 보장하고 어떤 행위가 멱등성을 보장하는지 알고 있어야 어플리케이션이 예상하지 못한 방향으로 동작하는 것을 방지할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>멱등성 보장</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>O</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>O</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>O</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>X</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<p>일단 깊게 생각하지말고 위 테이블을 한번 보자. <code class=\"language-text\">GET</code> 메소드는 단지 리소스를 읽어 오는 행위를 의미하기에 아무리 여러 번 수행해도 결과가 변경되거나 하지는 않을 것이다. 마찬가지로 요청에 담긴 리소스로 기존 리소스를 그대로 대체해버리는 <code class=\"language-text\">PUT</code> 메소드 또한 여러 번 수행한다한들 요청에 담긴 리소스가 변하지 않는 이상 연산 결과가 동일할 것이다.</p>\n<p>즉, 어떤 리소스를 읽어오거나 대체하는 연산은 멱등성을 보장한다고 이야기할 수 있다. 그렇다면 멱등성이 보장되지 않는 케이스는 어떤 것이 있을까?</p>\n<p><code class=\"language-text\">POST</code> 메소드의 경우 리소스를 새롭게 생성하는 행위를 의미하기 때문에 여러 번 수행하게 되면 매번 새로운 리소스가 생성될 것이고, 그 말인 즉슨 결국 연산을 수행하는 결과가 매번 달라진다는 것을 의미한다. <code class=\"language-text\">POST</code> 메소드와 같이 멱등성을 보장하지 않는 동작은 한 번 수행될 때마다 어플리케이션의 상황을 전혀 다르게 변화시킬 수도 있다.</p>\n<p>이러한 HTTP 메소드의 멱등성에 대한 지식은 에러에 대한 정보가 별로 없는 상태에서 디버깅을 진행할 때도 활용될 수 있기 때문에 여러모로 알고 있는 편이 좋다고 생각한다. 똑같이 통신 후에 발생하는 에러라고 해도 <code class=\"language-text\">GET</code>을 여러 번 수행했을 때 발생하는 에러와 <code class=\"language-text\">POST</code>를 여러 번 수행했을 때 발생하는 에러는 전혀 다른 컨텍스트를 가지고 있을 수 있다는 것이다.</p>\n<h4 id=\"patch는-왜-멱등성이-보장되지-않는다는걸까\" style=\"position:relative;\">PATCH는 왜 멱등성이 보장되지 않는다는걸까?<a href=\"#patch%EB%8A%94-%EC%99%9C-%EB%A9%B1%EB%93%B1%EC%84%B1%EC%9D%B4-%EB%B3%B4%EC%9E%A5%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4%EB%8A%94%EA%B1%B8%EA%B9%8C\" aria-label=\"patch는 왜 멱등성이 보장되지 않는다는걸까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>위 테이블에서 <code class=\"language-text\">PATCH</code> 메소드는 <code class=\"language-text\">POST</code> 메소드와 동일하게 멱등성이 보장되지 않는 메소드로 표기되어있다. 그러나 사실 정확하게 이야기하면 <code class=\"language-text\">PATCH</code> 메소드는 구현 방법에 따라서 <code class=\"language-text\">PUT</code> 메소드처럼 멱등성이 보장될 수도 있고, 혹은 보장되지 않을 수도 있다고 할 수 있다.</p>\n<p><code class=\"language-text\">PATCH</code> 메소드는 <code class=\"language-text\">PUT</code> 메소드처럼 리소스를 대체하는 행위가 아니기 때문에 요청을 어떤 방식으로 사용하는지에 대한 제한이 딱히 없기 때문이다. RFC 스펙 상의 <code class=\"language-text\">PATCH</code> 메소드는 단지 리소스의 일부를 수정한다는 의미만을 가질 뿐이다.</p>\n<p>예를 들어, 앞서 필자가 설명했던 예시처럼 <code class=\"language-text\">PATCH</code> 메소드에 수정할 리소스의 일부분만 담아서 보내는 경우에는 당연히 멱등성이 보장된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 기존 리소스</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'evan'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">PATCH users/1\n{ age: 31 }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 새로운 리소스</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'evan'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">31</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 변경!</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 <code class=\"language-text\">PATCH</code> 요청은 명확하게 <code class=\"language-text\">age</code>라는 필드를 <code class=\"language-text\">31</code>로 수정하는 행위만을 의미하므로 아무리 여러 번 수행한다고 해도 늘 <code class=\"language-text\">age</code>는 <code class=\"language-text\">31</code>이라는 값을 가질 것이기 때문이다. 이건 굉장히 일반적인 <code class=\"language-text\">PATCH</code> 메소드의 구현 방법이고, 실제로 필자도 <code class=\"language-text\">PATCH</code> 메소드를 사용해야한다면 이렇게 구현한다.</p>\n<p>근데 왜 <code class=\"language-text\">PATCH</code> 메소드는 멱등성 보장이 안될 수도 있다는 것일까?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/aaf02eaa6cd79f5891d97861cc8e7338/6a068/hm.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAIBAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgP/2gAMAwEAAhADEAAAAXv5u6LgYmv/xAAaEAADAAMBAAAAAAAAAAAAAAABAgMAERIT/9oACAEBAAEFApTCnme/GZzeSbpWoFP/xAAWEQEBAQAAAAAAAAAAAAAAAAABABL/2gAIAQMBAT8BCyX/xAAYEQEAAwEAAAAAAAAAAAAAAAABAAISUf/aAAgBAgEBPwG6hN37P//EABwQAAICAgMAAAAAAAAAAAAAAAARAQIQIRJRcf/aAAgBAQAGPwJ3mPDdWx8IjC6Fs//EABkQAQEBAAMAAAAAAAAAAAAAAAEAETFBYf/aAAgBAQABPyG0DY4icl5Jc6dpqgr/2gAMAwEAAgADAAAAEOwv/8QAFxEBAAMAAAAAAAAAAAAAAAAAABExYf/aAAgBAwEBPxCa2D//xAAXEQADAQAAAAAAAAAAAAAAAAAAARFR/9oACAECAQE/ELhGLH//xAAbEAEBAAMAAwAAAAAAAAAAAAABEQAhMUFxwf/aAAgBAQABPxDSDeDbjuyMtSm+cMLVquhPPvApXeOWgSj3ACiW9+5//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"hm\" title=\"\" src=\"/static/aaf02eaa6cd79f5891d97861cc8e7338/c08c5/hm.jpg\" srcset=\"/static/aaf02eaa6cd79f5891d97861cc8e7338/0913d/hm.jpg 160w,\n/static/aaf02eaa6cd79f5891d97861cc8e7338/cb69c/hm.jpg 320w,\n/static/aaf02eaa6cd79f5891d97861cc8e7338/c08c5/hm.jpg 640w,\n/static/aaf02eaa6cd79f5891d97861cc8e7338/6a068/hm.jpg 960w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>어쩌면 이게 `PATCH`를 구현하는 올바른 방법이 아닐 수도 있을 것이라는 킹리적 갓심이 들기 시작했다</small>\n</center>\n<p>뭐든지 원조가 중요하니 <code class=\"language-text\">PATCH</code> 메소드를 처음으로 정의해놓은 <a href=\"https://tools.ietf.org/html/rfc5789\" target=\"_blank\" rel=\"nofollow\">RFC-5789</a> 문서를 한번 까보도록 하자. 보통 RFC 문서에는 정의된 개념에 대한 설명과 간략한 예시도 포함되어 있는 경우가 많으니, <code class=\"language-text\">PATCH</code> 메소드의 올바른 구현 방법 또한 적혀있을 것 같다.</p>\n<center>\n.<br />\n.<br />\n.<br />\n</center>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ddc05d3c7f7b2e1d49eedd8538eb835e/d43b4/patch_example.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABaElEQVR42m2S547CQAyEef/3yV8ECIQiqiih915EB1EEc/osLdzlsGQ2rJ2ZsSeR8Xisdrut6/UqnqvVqhKJhGWj0VAQBPI8T/F4XOVy2c5oNCrf97Xb7US8Xi+5iNxuNwPj8n6/63K5WON6vRY19/9wOFjf8XjUYrHQfr/X4/FQOCL8PJ9P1et11Wo1zWYzbbdbe2m5XGqz2Wi1Wmk+n5va0Whk9dPpZCLCaYAwpVIpZbNZU8bYpVJJ3W5XmUzGstlsGmmhUDDFvPN71D8KKdJYqVTU6/XU6XRsXxAAClA6ndZgMDAielCMWupMBiHTvEfmslgsKp/Pq9VqaTKZmFnOmFgs9iZlBW4dnAAPh0Odz+ePQphRxXgAwNzv95XL5YyM52QyaaaEnf03MkUWTbIfmJwZJE7jOLUw0FdTiOl0amNiCk47MMA5IeA7pYcRv4G/FRLsgN25ZUPgPhFIAHBrwDTuvwH+AC4t69xt49FhAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"patch example\" title=\"\" src=\"/static/ddc05d3c7f7b2e1d49eedd8538eb835e/6af66/patch_example.png\" srcset=\"/static/ddc05d3c7f7b2e1d49eedd8538eb835e/69538/patch_example.png 160w,\n/static/ddc05d3c7f7b2e1d49eedd8538eb835e/72799/patch_example.png 320w,\n/static/ddc05d3c7f7b2e1d49eedd8538eb835e/6af66/patch_example.png 640w,\n/static/ddc05d3c7f7b2e1d49eedd8538eb835e/d9199/patch_example.png 960w,\n/static/ddc05d3c7f7b2e1d49eedd8538eb835e/d43b4/patch_example.png 1202w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>...는 그딴 건 없었습니다</small>\n</center>\n<p>놀랍게도<small><strike>어이없게도</strike></small> <a href=\"https://tools.ietf.org/html/rfc5789\" target=\"_blank\" rel=\"nofollow\">RFC-5789</a> 문서에 있는 예시 요청의 바디에는 단지 <code class=\"language-text\">description of changes</code>라는 설명만 적혀있을 뿐, 어떤 제약 조건도 적혀있지 않다. 즉, 별다른 제약없이 개발자 마음대로 API의 인터페이스를 정의해도 된다는 의미이기 때문에 이런 느낌으로 API를 구현하는 것도 가능하다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">PATCH users/1\n{\n  $increase: 'age',\n  value: 1,\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 요청의 <code class=\"language-text\">$increase</code> 필드의 값은 증가시키고 싶은 속성을 의미하고, <code class=\"language-text\">value</code> 필드의 값은 그 속성을 얼마나 증가시킬 것인지를 나타내고 있다. 이 경우 API가 호출될 때마다 에반의 나이는 1씩 증가<smal><strike>(…😢)</strike></small>할 것이기 때문에 이 API는 멱등성을 보장하지 않는다.</p>\n<p>물론 필자도 <code class=\"language-text\">PATCH</code> 메소드를 이렇게 사용하는 경우를 실제로 보지는 못했지만, 앞서 이야기했듯이 <a href=\"https://tools.ietf.org/html/rfc5789\" target=\"_blank\" rel=\"nofollow\">RFC-5789</a>에는 <code class=\"language-text\">PATCH</code> 메소드를 어떻게 구현해야 하는지에 대한 제약이 존재하지 않으니 이런 방식으로 사용한다고 해서 표준을 어기는 것도 아니다.</p>\n<p>즉, 자세한 스펙 상 구현 방법에 대한 제약이 없으니 API를 어떻게 구현하느냐에 따라서 <code class=\"language-text\">PATCH</code> 메소드는 멱등성을 보장할 수도 있고 아닐 수도 있는 것이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 REST는 네트워크 아키텍처를 설계하는 가이드라인이기 때문에 필자가 이야기했던 리소스의 표현 상태는 REST의 일부분에 불과하다. 그러나 애초에 이 포스팅은 RESTful API를 설명하는 것이 목적이었기 때문에 더 자세한 내용을 굳이 이야기하지는 않았다. 혹시 REST에 대해 더 관심이 가시는 분들은 로이 필딩 아저씨의 논문 중 <a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm\" target=\"_blank\" rel=\"nofollow\">REST 챕터</a>을 한번 읽어보는 것을 추천한다.</p>\n<p>RESTful API는 필자가 지금까지 프론트엔드 개발자로 일을 하면서 백엔드 개발자와 가장 많은 논의를 했던 주제였다. 그렇게 논의를 했던 이유는 개발자로써 명확한 API를 정의하고 싶다는 욕심이기도 했고, 어떻게 하면 명확한 API를 정의해서 새로 조직에 합류한 개발자들이 바로 API에 익숙해지게 만들 수 있을지에 대한 욕심이기도 했다. <small>(오늘도 역시 사무실에서 이런 이야기를 나누다 왔다)</small></p>\n<p>필자는 개인적으로 가장 좋은 API는 기능이 많은 API도 아니고 공짜로 사용할 수 있는 API도 아닌, 어떠한 정보도 없는 누군가가 구구절절 다른 설명 없이 엔드포인트만 봐도 어떤 동작을 하는 API인지 바로 이해할 수 있을 정도로 명확한 API가 가장 좋은 API라고 생각한다.</p>\n<p>물론 RESTful API와 같은 아키텍쳐 가이드라인을 학습하고 준수하는 것이 다소 번거로울 수는 있지만, 이런 표준이나 가이드라인이 가지는 의미가 전 세계의 수 많은 개발자들이 소통할 수 있는 획일화된 교통 정리인 만큼 가이드라인을 준수하기 위한 개개인의 작은 노력이 모여서 거대한 웹 아키텍처를 유지할 수 있게 만드는 것은 아닐까.</p>\n<p>이상으로 프론트엔드와 백엔드가 소통하는 엔드포인트, RESTful API 포스팅을 마친다.</p>","fields":{"slug":"20200407-about-restful-api","path":"/2020/04/07/about-restful-api/","lang":"ko"},"frontmatter":{"title":"프론트엔드와 백엔드가 소통하는 엔드포인트, RESTful API","subTitle":"표현과 행위 사이, REST의 철학을 이해하다","date":"Apr 07, 2020","categories":["프로그래밍","네트워크","아키텍처"],"tags":["REST","REST API","RESTful API","HTTP 메소드","HTTP Method","HTTP Status","HTTP 상태"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eba52764a4c3657fcab1149679dc258c/d803c/thumbnail.png","srcSet":"/static/eba52764a4c3657fcab1149679dc258c/d803c/thumbnail.png 320w,\n/static/eba52764a4c3657fcab1149679dc258c/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eba52764a4c3657fcab1149679dc258c/fc5c5/thumbnail.webp 320w,\n/static/eba52764a4c3657fcab1149679dc258c/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eba52764a4c3657fcab1149679dc258c/01fb2/thumbnail.png","srcSet":"/static/eba52764a4c3657fcab1149679dc258c/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eba52764a4c3657fcab1149679dc258c/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"43a4e283-1828-56b2-9174-cc59fa365513","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EA%B5%B3%EC%9D%B4-%EC%9D%B4%EB%9F%AC%ED%95%9C-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\">굳이 이러한 가이드라인을 지켜야 하나요?</a></p>\n<ul>\n<li><a href=\"#%ED%91%9C%EC%A4%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A1%B4%EC%9E%AC-%EC%9D%B4%EC%9C%A0%EB%A5%BC-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EC%9E%90\">표준 인터페이스의 존재 이유를 생각해보자</a></li>\n<li><a href=\"#%EB%B0%B1%EC%97%94%EB%93%9C%EB%8A%94-%EC%9E%98-%EB%AA%A8%EB%A5%B4%EB%8A%94-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%9D%98-%EC%8A%AC%ED%94%88-%EC%82%AC%EC%A0%95\">백엔드는 잘 모르는 프론트엔드의 슬픈 사정</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%91%EC%97%85%EC%9D%98-%EC%88%98%ED%96%89-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C\">작업의 수행 상태를 알려주는 HTTP 상태 코드</a></p>\n<ul>\n<li><a href=\"#100%EB%B2%88%EB%8C%80\">100번대</a></li>\n<li><a href=\"#200%EB%B2%88%EB%8C%80\">200번대</a></li>\n<li><a href=\"#300%EB%B2%88%EB%8C%80\">300번대</a></li>\n<li><a href=\"#400%EB%B2%88%EB%8C%80\">400번대</a></li>\n<li><a href=\"#500%EB%B2%88%EB%8C%80\">500번대</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"최근의 모던 어플리케이션은 완전히 네트워크 위에서 돌아가는 프로그램이라고 해도 과언이 아닐 정도로 프로그램의 비즈니스 로직에서 통신이 차지하는 비중이 높다. 클라이언트 어플리케이션은 백엔드에 위치한 서버와 통신하여 현재 로그인한 사용자의 정보를 받아오거나, 새로운 게시글을 생성하기도 하고, 때로는 Web Socket을 통해 서버에서 발생한 이벤트를 구독하여 푸시 메세지나 채팅과 같은 기능을 구현하기도 한다.","html":"<p>최근의 모던 어플리케이션은 완전히 네트워크 위에서 돌아가는 프로그램이라고 해도 과언이 아닐 정도로 프로그램의 비즈니스 로직에서 통신이 차지하는 비중이 높다. 클라이언트 어플리케이션은 백엔드에 위치한 서버와 통신하여 현재 로그인한 사용자의 정보를 받아오거나, 새로운 게시글을 생성하기도 하고, 때로는 Web Socket을 통해 서버에서 발생한 이벤트를 구독하여 푸시 메세지나 채팅과 같은 기능을 구현하기도 한다.</p>\n<!-- more -->\n<p>이 과정에서 프론트엔드와 백엔드는 어떤 방식으로 통신을 할 것인지부터 시작하여 리소스의 생성과 삭제는 어떻게 정의할 것인지, 프론트엔드에서 요청한 백엔드 작업의 성공/실패 여부는 어떻게 알려줄 것인지 등 많은 규칙들을 정의해야한다.</p>\n<p>그래서 이러한 규칙들을 정의할 때 도움을 주는 몇 가지 가이드라인들이 존재하는데, 이때 등장하는 것들이 HTTP 메소드나 상태 코드같은 표준과 REST 같은 녀석들이다.</p>\n<p>이번 포스팅에서는 이 중에서  프론트엔드와 백엔드 간의 통신을 할 때 조금 더 명확한 정의를 위해 필요한 요소 중 하나인 HTTP 상태 코드를 파헤쳐보는 시간을 가져보려고 한다.</p>\n<h2 id=\"굳이-이러한-가이드라인을-지켜야-하나요\" style=\"position:relative;\">굳이 이러한 가이드라인을 지켜야 하나요?<a href=\"#%EA%B5%B3%EC%9D%B4-%EC%9D%B4%EB%9F%AC%ED%95%9C-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"굳이 이러한 가이드라인을 지켜야 하나요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 HTTP 메소드나 상태 코드, 그리고 REST 같은 것들은 말 그대로 가이드라인에 불과하다. 이것들을 지키지 않는다고 해서 프로그램이 작동하지 않는 것도 아니고 사용자가 프로그램을 사용하던 도중 런타임 에러가 발생하는 슬픈 일도 발생하지 않는다.</p>\n<p>즉, 지키지 않아도 사실 프로그램을 작성하는데는 아무런 지장이 없다는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgH/2gAMAwEAAhADEAAAAdFHeGZyL//EABwQAAEDBQAAAAAAAAAAAAAAAAACAxIBEyIjM//aAAgBAQABBQK4ZUVMbVsc5SP/xAAXEQADAQAAAAAAAAAAAAAAAAAAARIh/9oACAEDAQE/AXjJP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAQEBAQAAAAAAAAAAAAAAAAEAECL/2gAIAQEABj8ClXnCc//EABsQAAICAwEAAAAAAAAAAAAAAAABESExQVFh/9oACAEBAAE/IUje34sl0GmCI6npJS8JH//aAAwDAQACAAMAAAAQHO//xAAXEQEAAwAAAAAAAAAAAAAAAAAAETFR/9oACAEDAQE/EKGoP//EABYRAQEBAAAAAAAAAAAAAAAAAAEAEf/aAAgBAgEBPxABLb//xAAdEAEAAwACAwEAAAAAAAAAAAABABExcZEhUWGx/9oACAEBAAE/EKiWem1wSj+FUKG39MhTp3PLbaTkdjZ2W37AjTqf/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ebichu\" title=\"\" src=\"/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg\" srcset=\"/static/5ab263e405da8a4381a5fe32c5581820/0913d/ebichu.jpg 160w,\n/static/5ab263e405da8a4381a5fe32c5581820/cb69c/ebichu.jpg 320w,\n/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>그럼 굳이 안 지켜도 상관없는 것 아닌가요?</small>\n</center>\n<p>음, 이러한 규칙들을 지키지 않는 것은 자유지만 그로 인해 발생하는 사이드 이펙트들을 생각해보면 되도록이면 지켜주는 것이 좋다고 이야기하고 싶다.</p>\n<h3 id=\"표준-인터페이스의-존재-이유를-생각해보자\" style=\"position:relative;\">표준 인터페이스의 존재 이유를 생각해보자<a href=\"#%ED%91%9C%EC%A4%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A1%B4%EC%9E%AC-%EC%9D%B4%EC%9C%A0%EB%A5%BC-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"표준 인터페이스의 존재 이유를 생각해보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>산업 표준은 불특정 다수에 의해 생산되는 제품들의 호환성을 맞추고, 제품 생산자들 간의 커뮤니케이션을 원활하게 하기 위해서 제정되며, 이렇게 각자 다른 객체들을 호환하기 위해 정의하는 일련의 표준 규격을 우리는 “인터페이스(Interface)“라고 부른다.</p>\n<p>이 인터페이스라는 개념은 꽤나 광범위해서 뭐든 연결해주기만 할 수 있다면 인터페이스라고 생각하면 된다. 모니터와 컴퓨터를 연결하는 HDMI, 저장 장치에 사용되는 SATA, USB와 같은 친구들도 전부 인터페이스다. 심지어 UI(User Interface)같은 경우에는 기계와 기계가 아니라 인간과 기계를 이어준다는 개념으로까지 사용된다.</p>\n<p>그 중 개발자들에게 가장 친숙한 인터페이스는 바로 API(Application Programming Interface)이다. API는 응용 프로그램을 제작할 때 필요한 기능들을 일련의 인터페이스로 제공된 것을 의미한다.</p>\n<p>이때 API를 사용하는 쪽에서는 API의 사용법만 알면 되고 그 이면에 어떤 거대한 로직들이 숨어있는지는 일절 관심을 끊어도 되기 때문에 굉장히 편리하다는 장점이 있다. 대표적인 API의 한 종류로는 C에서 제공하는 Windows 운영체제의 API가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;Windows.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;tchar.h></span></span>\n\n<span class=\"token keyword\">int</span> APIENTRY <span class=\"token function\">_tWinMain</span><span class=\"token punctuation\">(</span>\n  HINSTANCE hInstance<span class=\"token punctuation\">,</span>\n  HINSTANCE hPrevInstance<span class=\"token punctuation\">,</span>\n  LPTSTR lpCmdLine<span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">int</span> nCmdShow\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">MessageBox</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token function\">TEXT</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, Windows!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">TEXT</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"App\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> MB_OK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>개발자는 Windows 운영체제가 어떻게 저 메세지박스를 렌더하는지 모르더라도 단지 <code class=\"language-text\">MessageBox</code>라는 API의 함수를 사용함으로써 간단하게 메세지박스를 사용할 수 있다. 그리고 이 과정은 필자가 작성하는 C 어플리케이션과 운영체제, 전혀 다른 두 프로그램 간의 통신이기도 하다.</p>\n<p>즉, API는 프로그램 간의 통신을 위한 인터페이스라고 할 수 있다. 마찬가지로 클라이언트가 서버에게 뭔가를 요청할 때도 특정 규칙으로 정의된 API를 사용하여 서버의 리소스를 사용하게 되는데, HTTP를 사용하여 통신하는 대부분의 모던 어플리케이션에서는 이 API를 엔드포인트(endpoint)라고 불리는 특정한 URL을 사용하여 정의하게되며, 서버는 일관된 방식으로 이 엔드포인트로 들어온 클라이언트 요청에 대한 응답을 보내줘야한다.</p>\n<p>이때 HTTP 상태 코드는 클라이언트가 보냈던 요청의 수행 결과를 의미하는 일종의 약속이며, API를 구성하는 중요한 요소 중 하나이다.</p>\n<h3 id=\"백엔드는-잘-모르는-프론트엔드의-슬픈-사정\" style=\"position:relative;\">백엔드는 잘 모르는 프론트엔드의 슬픈 사정<a href=\"#%EB%B0%B1%EC%97%94%EB%93%9C%EB%8A%94-%EC%9E%98-%EB%AA%A8%EB%A5%B4%EB%8A%94-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%9D%98-%EC%8A%AC%ED%94%88-%EC%82%AC%EC%A0%95\" aria-label=\"백엔드는 잘 모르는 프론트엔드의 슬픈 사정 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 섹션에서는 잘못 정의된 API를 사용하는 프론트엔드 개발자라면 한번쯤은 겪어보았음직한 일을 한번 짧게 이야기해보려고 한다. 아마 백엔드 개발자들은 프론트엔드 어플리케이션의 소스를 직접 보는 경우가 드물기 때문에 이런 상황이 있다는 사실조차 모를 수 있을 것 같다.</p>\n<p>바로 HTTP 상태 코드를 잘못 사용하고 있는 경우인데, 이런 상황에 대한 대표적인 예시는 바로 요청이 실패했을 때에도 상태 코드를 요청 성공을 의미하는 <code class=\"language-text\">200 Ok</code>로 내려주는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET /api/users/123</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK</span></span>\n{ \"success\": false }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이렇게 설계한 API의 경우, 위 예시처럼 HTTP 응답 바디에 요청의 성공/실패 여부나 실패 이유를 함께 담아서 보내주는 경우가 대다수인데, 그러면 프론트엔드 어플리케이션에서는 처리가 약간 애매해지는 상황이 발생한다.</p>\n<p>프론트엔드에서는 이런 비동기 요청을 Promise를 통해서 처리하게 되는데, 문제는 대부분의 HTTP 통신 라이브러리나 API들은 백엔드에서 보내주는 요청의 상태 코드에 따라 요청의 성공/실패 여부를 판단하고, 요청이 실패했을 경우에만 에러를 던진다는 것이다.</p>\n<p>그래서 일반적인 경우, 프론트엔드 어플리케이션에서는 대략 이런 느낌으로 통신을 담당하는 코드를 작성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUsers</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/users/123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'요청이 실패했어요!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>서버로 보냈던 요청이 실패했다면 서버는 반드시 400이나 500번대의 상태 코드를 보내줄 것이고, 그렇게 되면 <code class=\"language-text\">fetch</code> API는 에러를 발생시킨다. 그래서 <code class=\"language-text\">fetch</code>를 사용할 때는 단순히 외부에서 <code class=\"language-text\">try/catch</code> 구문을 사용하는 것만으로도 간단하게 통신에 대한 에러를 핸들링할 수 있는 것이다.</p>\n<p>하지만 위의 잘못된 예시처럼 백엔드 어플리케이션에서 요청이 실패했음에도 불구하고 상태 코드로 200번대 코드를 내려준다면 프론트엔드 어플리케이션의 코드에는 이런 슬픈 상황이 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUsers</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/users/123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> success <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'요청이 실패했어요'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>아까 전에는 없던 <code class=\"language-text\">if (!success)</code>가 생긴 것을 볼 수 있다. 즉, 불필요한 예외 처리가 한번 더 발생한 것인데, 이런 불필요한 예외처리는 코드의 가독성을 해치지만 프론트엔드 입장에서는 딱히 선택권이 없다. 그렇다고 서버가 보내주는 에러를 무시하고 핸들링을 안 할수도 없지 않은가?</p>\n<p>게다가 백엔드 어플리케이션이 미처 핸들링하지 못한 에러가 발생하거나 서버가 아예 죽어버리기라도 하면 응답의 상태 코드에는 에러 코드인 500이나 502가 내려올 것이기 때문에 <code class=\"language-text\">try/catch</code> 구문을 사용하지 않을 수도 없다.</p>\n<p>클라이언트에서 사용하는 모든 HTTP 통신 라이브러리들은 올바른 HTTP 상태 코드의 사용을 가정하고 설계되었기 때문에, 서버가 올바르지 않은 상태 코드를 사용한다면 이런 슬픈 상황이 발생할 수도 있다는 점을 이야기해두고 싶다. 그리고 사실 백엔드 어플리케이션에서 상황에 맞는 올바른 상태 코드를 내려주는 것이 그렇게 어려운 일도 아니다. <small>(다만 조금 귀찮을 뿐이다)</small></p>\n<p>클라이언트와 마찬가지로 대부분의 서버 프레임워크에서 제공하는 통신 라이브러리들도 모든 상황에 맞는 HTTP 상태 코드들을 제공하고 있으니 되도록이면 알맞은 상황에 맞는 상태 코드를 사용하는 것을 추천한다.</p>\n<p>자, 그럼 이제 본격적으로 이 수많은 HTTP 상태 코드들이 정확히 어떤 상태를 의미하는지 알아보도록하자.</p>\n<h2 id=\"작업의-수행-상태를-알려주는-http-상태-코드\" style=\"position:relative;\">작업의 수행 상태를 알려주는 HTTP 상태 코드<a href=\"#%EC%9E%91%EC%97%85%EC%9D%98-%EC%88%98%ED%96%89-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C\" aria-label=\"작업의 수행 상태를 알려주는 http 상태 코드 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>클라이언트가 서버에게 작업을 요청하면 서버는 요청받은 작업을 수행한 후 작업의 수행 결과를 응답으로 보내주는데, 이때 HTTP 상태 코드를 사용하여 작업의 성공/실패 여부와 작업이 실패했다면 어떤 이유로 실패했는지도 알려주게 된다. 위에서 보았던 잘못된 예시처럼 HTTP 응답 바디에 작업의 실패 여부를 담아서 응답해주는 경우도 있지만, 더 좋은 방법은 바로 올바른 HTTP 상태 코드를 사용하는 것이다.</p>\n<p>HTTP 상태 코드는 “200 = 성공”, “400 = 클라이언트가 요청 잘못함”, “500 = 서버가 잘못함”과 같이 각 상황에 맞는 코드가 표준으로 정해져있으며, 웹 상에서 돌아가는 기본적인 프로그램의 동작이나 프론트엔드, 백엔드 프레임워크들의 설계 또한 이 표준을 기준으로 만들어져 있기 때문에 되도록이면 이 표준을 지켜주는 것이 좋다.</p>\n<p>HTTP 프로토콜을 사용하는 대표적인 프로그램인 웹 브라우저 또한 이러한 상태 코드 표준을 엄격하게 지키는 녀석 중 하나인데, 실제로 브라우저는 서버가 어떤 상태 코드를 응답으로 내려주는지에 따라 이번에 자신이 보낸 요청의 성공/실패 여부를 구분하고, 이를 시각적으로 표현해주기도 한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/581d5098769863da7581ecc2a09a19ed/d7ab4/browser-response.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 44.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABO0lEQVR42o1S7XKDIBD0VRJj4kc1ioqCCJh+vP8bbe8uaaadJtP+2Dk4cbndJbHWIoSAGAOMsRj1hLZTUvthxEw9Y5d71dMsfaV6WQ+jRkdrrue2RTJNE9Z1FVhv6EeDqqqw3+8FacpI7zgcDnd87b/3k3me4ZzDYh0632JajNyWFwXqusHxeLwRp8iy7AfhIyQsOcaIQJK3sEH1vcgbtYZbA+0H1E0jYFIhv13wkNCQRPbQey9yeTr2zy4O02zg44bL2wfi9gpDPfaPz1Qv9UNS8ZAls4duuZpelpVIZZxOuSDPcxRkA9c8L5DRt6cT8nRu9XjvFSzJ7SWxTlJjibvdTvAsnF8ebtt29ZGmHMeRnoeDprDWEIWUAyrK8s9AhFApBU0BMNEwXAPoqNecW7Q0JYfCnnJY/0n5E8S6FKangsPMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"browser response\" title=\"\" src=\"/static/581d5098769863da7581ecc2a09a19ed/6af66/browser-response.png\" srcset=\"/static/581d5098769863da7581ecc2a09a19ed/69538/browser-response.png 160w,\n/static/581d5098769863da7581ecc2a09a19ed/72799/browser-response.png 320w,\n/static/581d5098769863da7581ecc2a09a19ed/6af66/browser-response.png 640w,\n/static/581d5098769863da7581ecc2a09a19ed/d9199/browser-response.png 960w,\n/static/581d5098769863da7581ecc2a09a19ed/d7ab4/browser-response.png 1014w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>브라우저는 200번대의 상태 코드와 400, 500번대의 상태 코드를 전혀 다르게 인식한다</small>\n</center>\n<p>이런 상황에서 서버가 상태 코드는 200인데 응답의 바디로만 에러를 표현한다고 하면, 브라우저는 요청이 성공했다고 생각하지만 실제로는 요청이 실패한, 요상한 상황이 발생하게 된다.</p>\n<p>심지어 서버가 응답의 상태 코드로 301과 같은 코드를 내려준다면, 브라우저는 자동으로 사용자를 다른 페이지로 리다이렉트(Redirect)해버리기 때문에 서버가 제대로 된 상태 코드를 응답에 담아주지 않는다면 브라우저가 예측하지 못한 동작을 일으킬 수도 있다.</p>\n<p>자, 그럼 이제 각 HTTP 상태 코드가 어떤 상태들을 의미하는 것인지 하나씩 살펴보도록 하자. HTTP 상태 코드는 100번대 부터 500번대까지로 이루어져 있으며 꽤나 다양한 상태들을 정의할 수 있지만, 이걸 다 알 필요도 없고 설명하려면 너무 길기도 하니, 필자가 단 한번이라도 사용해보았던 상태 코드들을 기준으로 설명을 진행하려고 한다.</p>\n<h3 id=\"100번대\" style=\"position:relative;\">100번대<a href=\"#100%EB%B2%88%EB%8C%80\" aria-label=\"100번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>100번대 코드는 프로토콜을 교체해도 된다거나 계속 요청을 보내도 된다거나하는 식의 정보성을 띄고 있는 상태를 의미하지만, 실제로 필자가 어플리케이션을 개발하며 이 상태 코드들을 만나본 사례는 아직 단 한번도 없기 때문에 건너뛰도록 하겠다.</p>\n<h3 id=\"200번대\" style=\"position:relative;\">200번대<a href=\"#200%EB%B2%88%EB%8C%80\" aria-label=\"200번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>200번대 코드들은 클라이언트가 요청한 작업을 서버가 성공적으로 수행했다는 상태라는 것을 알려주는 코드이다. 200번대 코드들은 브라우저의 콘솔의 네트워크 탭에서도 깔끔한 초록색으로 표시해준다.</p>\n<p>물론 “요청한 작업이 성공”이라는 응답만으로도 클라이언트가 원하는 정보를 모두 만족시킬 수 있긴 하지만, 조금 더 디테일한 상태를 정의해야하는 상황이라면 이 200번대의 상태 코드를 적극적으로 사용하여 클라이언트에게 더 자세한 정보를 알려줄 수도 있다.</p>\n<p><strong>200 OK</strong></p>\n<p>상태 코드 <code class=\"language-text\">200</code>은 단순히 작업이 성공했음을 의미한다. 대부분의 경우 클라이언트는 자신이 요청한 작업이 정확히 어떤 작업인지 알고 있기 때문에, 서버에서 “니가 보낸 요청이 성공했어”라는 정보만 알려주면 굳이 그 이상의 디테일한 정보는 알 필요가 없다. 그래서 이 상태 코드 하나만으로 모든 API 응답 성공 상태를 퉁치는 경우가 대다수이다.</p>\n<p><strong>201 Created</strong></p>\n<p>상태 코드 <code class=\"language-text\">201</code>은 말 그대로 요청이 정상적으로 수행되었고, 그로 인해 리소스가 새롭게 생성되었다는 것을 의미한다. 클라이언트가 서버에게 요청을 보내서 새로운 리소스를 생성하는 상황은 굉장히 흔한데, 그 중 필자가 경험했던 대표적인 사례는 바로 “회원가입”이다. 결국 클라이언트의 회원가입 요청으로 인해 데이터베이스에 새로운 유저의 로우가 생성되었기 때문에, 이런 경우가 <code class=\"language-text\">201</code> 상태 코드가 아주 잘 들어맞는 케이스라고 볼 수 있다.</p>\n<p><strong>204 No Content</strong></p>\n<p>상태 코드 <code class=\"language-text\">204</code>는 요청이 정상적으로 수행되었고, 이 요청과 관련되었던 컨텐츠 또한 더 이상 깔끔하게 존재하지 않음을 의미한다. 이 상태 코드는 클라이언트가 서버에게 요청을 보내서 뭔가를 삭제해야하는 응답으로 사용될 수 있고, 실제로 필자가 경험했던 사례 또한 게시글을 삭제하는 API였다.</p>\n<p>참고로 이때 이 삭제 작업이 Soft Delete냐 Hard Delete냐와는 아무런 상관이 없다. 서버에서 어떤 방식으로 리소스의 삭제를 표현하던 클라이언트가 알아야할 정보는 “이 리소스는 삭제되었고, 더 이상 사용할 수 없다” 뿐이라는 사실을 명심하자.</p>\n<h3 id=\"300번대\" style=\"position:relative;\">300번대<a href=\"#300%EB%B2%88%EB%8C%80\" aria-label=\"300번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>300번대 코드들은 리다이렉션에 관련된 상태들을 의미한다. 클라이언트가 요청한 리소스가 옮겨졌거나 리소스가 삭제되었거나해서 정상적인 방법으로는 더 이상 해당 리소스에 접근할 수 없고 다른 URL을 통해서 그 리소스에 접근해야하는 경우 서버는 “여기로 가면 니가 찾는 리소스가 있어!”라는 정보를 알려줄 수 있는데, 이때 사용되는 상태 코드들이 바로 300번대 코드들이다.</p>\n<p><strong>301 Moved Permanetly</strong></p>\n<p>상태 코드 <code class=\"language-text\">301</code>은 <code class=\"language-text\">301 Redirect</code>라는 별칭으로 불리기도 할 만큼 리다이렉션을 위한 코드 중 가장 많이 사용되는 녀석이다. 브라우저는 자신의 대한 요청의 응답으로 <code class=\"language-text\">301</code>을 받으면 HTTP 헤더에 들어있는 <code class=\"language-text\">Location</code> 필드를 찾아보고, 해당 필드가 존재할 경우 <code class=\"language-text\">Location</code> 필드에 담긴 URL로 자동으로 리다이렉션한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">301</span> <span class=\"token reason-phrase string\">Moved Permanetly</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Location</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">https://evan/moved-contents/1234</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또한 구글과 같은 검색 엔진의 봇들은 특정 페이지에 접근했는데 응답으로 <code class=\"language-text\">301</code> 상태 코드를 받을 경우 자동으로 페이지 정보를 갱신하기도 하기 때문에, SEO(Search Engine Optimization) 관점에서도 이 상태 코드를 올바르게 사용하는 것은 매우 중요하다.</p>\n<p>이런 리다이렉션 설정은 보통 서버 엔진의 설정 파일 내에서도 할 수 있고, 백엔드 어플리케이션 내에서 직접 할 수도 있다. 일반적인 경우 이 상태코드는 HTTP 프로토콜로 접속한 사용자를 HTTPS 프로토콜을 사용해야만 접근 가능한 포트로 보내버릴 때에도 많이 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-nginx line-numbers\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>         <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span>    evan.com</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">return</span>         <span class=\"token number\">301</span> https://<span class=\"token variable\">$host</span><span class=\"token variable\">$request_uri</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>         <span class=\"token number\">443</span> ssl</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span>    evan.com</span><span class=\"token punctuation\">;</span>\n    ...\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 경우 <code class=\"language-text\">80</code> 포트로 접속한 사용자를 발견한 Nginx는 HTTPS 프로토콜을 사용해야만 접근할 수 있는 <code class=\"language-text\">443</code> 포트로 리다이렉트시켜서 해당 프로토콜 사용을 강제할 수 있다.</p>\n<p><strong>304 Not Modified</strong></p>\n<p>상태 코드 <code class=\"language-text\">304</code>는 클라이언트가 요청한 리소스가 이전 요청때와 비교해보았을 때 전혀 달라진 점이 없다는 것을 의미한다. 즉, 말 그대로 Not Modified, 수정되지 않음이다.</p>\n<p>서버가 응답으로 이 상태 코드를 보내주면 클라이언트는 굳이 서버에게 리소스를 재전송받아야할 필요가 없기에 자신이 캐싱해놓았던 리소스를 사용하게되며, 이 과정에서 불필요한 통신 페이로드의 낭비를 줄일 수 있다.</p>\n<p>이 과정에서 클라이언트는 서버로부터 요청된 리소스를 받은 것이 아니라 자신의 캐싱해놓았던 리소스를 사용하는 것이므로 이 또한 캐싱된 리소스로 리다이렉션되었다고 치는 것이다. 그런 이유로 <code class=\"language-text\">304</code> 상태 코드는 암묵적인 리다이렉션으로 불리기도 한다.</p>\n<p>브라우저 역시 이 응답을 위한 자체 캐싱 기능을 가지고 있으며, 만약 <code class=\"language-text\">304</code> 상태 코드를 응답으로 받았는데 캐싱된 리소스가 없는 경우에는 빈 화면을 띄우거나 에러 화면이 노출된다. 그러니 이런 상황을 만나면 “브라우저에 Cached Resource가 없는 거 아님?”이라는 킹리적 갓심을 발휘해볼 수 있다.</p>\n<h3 id=\"400번대\" style=\"position:relative;\">400번대<a href=\"#400%EB%B2%88%EB%8C%80\" aria-label=\"400번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>400번대의 코드들은 클라이언트가 서버에게 보낸 요청이 잘못된 경우를 의미한다. 만약 이 상태 코드를 발견한다면 높은 확률로 프론트엔드 개발자가 예외 처리를 제대로 안 했거나 요청에 이상한 값이 묻은 경우가 많으니, 프론트엔드 개발자의 멱살을 잡도록 하자. <small><strike>(낮은 확률로 백엔드의 잘못인 경우도 있다…)</strike></small></p>\n<p><strong>400 Bad Request</strong></p>\n<p>상태 코드 <code class=\"language-text\">400</code>는 가장 많이 만날 수 있는 400번대 코드 중 하나이며, 밑도 끝도 없이 “클라이언트가 요청 잘못 날림”을 의미한다. 이때 뭘 어떻게 잘못 날렸는지는 보통 HTTP 응답 바디에 담아서 알려주는 경우도 있지만, 그렇지 않은 경우에는 백엔드 어플리케이션의 로그를 까봐야하는 슬픈 상황이 펼쳐질 수도 있다.</p>\n<p><strong>401 Unauthorized</strong></p>\n<p>상태 코드 <code class=\"language-text\">401</code>는 인증되지 않은 사용자가 인증이 필요한 리소스를 요청하는 경우에 “너 인증 필요함”이라고 알려주는 상태 코드이다. 보통 로그인이 필요한 API를 비로그인 사용자가 호출했을 때 많이 사용된다.</p>\n<p>클라이언트에서는 서버가 <code class=\"language-text\">401</code>을 응답으로 보내준 경우, 로그인이 필요하다는 것으로 판단하고 로그인 페이지로 사용자를 리다이렉션하기도 한다.</p>\n<p><strong>403 Forbidden</strong></p>\n<p>상태 코드 <code class=\"language-text\">403</code>는 클라이언트가 접근이 금지된 리소스를 요청했음을 의미한다. 이 상태 코드는 간혹 <code class=\"language-text\">401 Unauthorized</code>와 헷갈리고는 하는데, 상태 코드의 의미만 보면 확실히 애매모호하지만, 사실 분명한 한 가지 차이점이 있다.</p>\n<p><code class=\"language-text\">401</code>은 말 그대로 인증되지 않았다는 것을 의미하며, 인증이 되지 않았다는 것은 백엔드 어플리케이션이 현재 요청한 사용자가 누구인지 알 수가 없다는 것을 의미한다. 즉 이때 서버는 클라이언트에게 “너의 신원을 밝혀!”라고 말하고 있는 것이다.</p>\n<p>그러나 <code class=\"language-text\">403</code>의 경우, 백엔드 어플리케이션은 현재 리소스를 요청한 사용자가 누구인지 전혀 신경쓰지 않는다. 클라이언트가 현재 자신이 누구인지 밝혔던 밝히지 않았던, 인증이 되었던 안 되었던 간에, 이 리소스를 요청하는 것은 무조건 금지라고 말하고 있는 것이다.</p>\n<p>HTTPS 프로토콜로만 접근해야하는 리소스에 HTTP 프로토콜을 사용하여 접근했을 경우에 서버에서 <code class=\"language-text\">403</code> 응답을 보내주기도 한다.</p>\n<p><strong>404 Not Found</strong></p>\n<p>상태 코드 <code class=\"language-text\">404</code>는 말 그대로 요청한 리소스가 존재하지 않다는 것을 의미한다.</p>\n<p><strong>405 Method Not Allowed</strong></p>\n<p>상태 코드 <code class=\"language-text\">405</code>는 현재 리소스에 맞지않는 메소드를 사용했음을 의미한다. 백엔드 프레임워크의 경우 특정 컨트롤러에 해당 메소드를 사용하는 로직이 없다면 자동으로 <code class=\"language-text\">405</code>를 내려주기도 한다.</p>\n<p><strong>406 No Acceptable</strong></p>\n<p>상태 코드 <code class=\"language-text\">406</code>은 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation#%EC%84%9C%EB%B2%84_%EC%A3%BC%EB%8F%84_%EC%BB%A8%ED%85%90%EC%B8%A0_%ED%98%91%EC%83%81\" target=\"_blank\" rel=\"nofollow\">서버 주도 컨텐츠 협상</a>을 진행했음에도 불구하고 알맞은 컨텐츠 타입이 없다는 것을 의미한다.</p>\n<p>사실 클라이언트는 서버에게 리소스를 요청할 때, HTTP 헤더의 <code class=\"language-text\">Accept</code> 필드를 사용하여 어떤 컨텐츠 타입의 리소스를 원하는지도 함께 이야기해준다. 일반적으로 이 필드를 명시하지않을 경우 브라우저는 자동으로 <code class=\"language-text\">text/html</code>을 비롯한 몇 가지 타입들을 스스로 정의해서 헤더에 담아주고는 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET http://evan.com/\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html,application/xhtml+xml,application/xml,*/*</span></span>\n...</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이런 요청을 받은 서버는 클라이언트가 보낸 요청의 <code class=\"language-text\">Accept</code> 필드를 보고 앞에서부터 하나씩 찾아가며 요청받은 리소스와 알맞은 컨텐츠 타입이 있는지 하나씩 살펴보게 되고, 이후 알맞은 컨텐츠 타입이 있다면 HTTP 응답 헤더의 <code class=\"language-text\">Content-Type</code> 필드에 해당 컨텐츠 타입을 명시해주게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">HTTP/1.1 200 OK\nContent-Type: text/html</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 과정에서 어떤 컨텐츠 타입의 리소스를 응답으로 내려줄 것인지는 전적으로 서버가 결정하게 되므로 이 과정을 “서버 주도 컨텐츠 협상”이라고 하는 것이다. 위의 예시의 경우 클라이언트가 받기를 원했던 컨텐츠 타입 중 첫 번째 우선순위를 가진 <code class=\"language-text\">text/html</code>를 받아왔지만, 만약 서버에 <code class=\"language-text\">text/html</code> 타입의 리소스가 존재하지 않는 경우, 서버는 <code class=\"language-text\">application/xhtml+xml</code>, <code class=\"language-text\">application/xml</code> 순서로 리소스를 탐색하게 된다.</p>\n<p>만약 앞에 나열된 모든 컨텐츠 타입이 없는 경우 클라이언트가 요청했던 컨텐츠 타입 중 가장 마지막인 <code class=\"language-text\">*/*</code> 와일드 카드에 걸리기 때문에, 서버는 리소스가 어떤 컨텐츠 타입인지 상관하지 않고 그대로 응답해줄 것이다. 그러나 만약 클라이언트가 요청한 컨텐츠 타입을 모두 탐색했는데도 불구하고 알맞은 리소스가 없을 경우 서버는 <code class=\"language-text\">406</code> 상태 코드와 함께 “니가 찾는 컨텐츠 타입과 맞는 리소스가 없어”라는 응답을 주는 것이다.</p>\n<p><strong>408 Request Timeout</strong></p>\n<p>상태 코드 <code class=\"language-text\">408</code>은 클라이언트와 서버의 연결은 성사되었지만 요청의 본문이 계속 서버에 도착하지 않는 상황을 의미한다.</p>\n<p>HTTP 프로토콜을 사용하여 통신을 할 때는 반드시 클라이언트와 서버 간의 연결을 생성하고, 그 이후에 요청 본문에 해당하는 데이터를 전송하게 되는데, <code class=\"language-text\">408</code> 상태 코드는 이 과정에서 연결은 제대로 생성되었지만 서버가 아무리 기다려도 클라이언트가 보냈던 요청 본문을 받지 못하는 경우에 발생하게 된다.</p>\n<p><strong>429 Too Many Requests</strong></p>\n<p>상태 코드 <code class=\"language-text\">429</code>는 클라이언트가 서버에 너무 요청을 많이 보내는 경우에 발생한다. 너무 많이 보냈다는 것은, 너무 짧은 시간 안에 빠르게 요청을 마구 날려대서 서버가 “워워 진정해”라고 하는 경우일수도 있고, 유료 API를 사용하는 경우에는 현재 금액으로 사용할 수 있는 API 요청 횟수를 초과해서 “돈을 더 내세요”라는 의미로 사용되기도 한다.</p>\n<p>서버에서는 <code class=\"language-text\">429</code> 상태 코드와 함께 응답 헤더의 <code class=\"language-text\">Retry-After</code>라는 필드를 사용하여 “이 시간 이후에 재요청해봐”라는 의미를 전달할 수도 있다.</p>\n<h3 id=\"500번대\" style=\"position:relative;\">500번대<a href=\"#500%EB%B2%88%EB%8C%80\" aria-label=\"500번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>500번대의 코드들은 클라이언트가 아닌 서버에서 뭔가 말썽이 일어난 경우이다. 만약 이 상태 코드를 발견했다면 서버에서 뭔가 박살났다는 의미이므로 다소곳이 백엔드 개발자의 멱살을 잡아보도록 하자.</p>\n<p><strong>500 Internal Server Error</strong></p>\n<p>상태 코드 <code class=\"language-text\">500</code>은 백엔드 어플리케이션 내에서 뭔가 알 수 없는 에러가 발생했다는 의미이다. 대부분 제대로 핸들링되지 않은 에러가 발생한 경우가 많으므로, 에러의 원인을 클라이언트에게 알려주지 않는다.<small><strike>(라기 보다 알려줄 수 없는 상태인 경우가 많다)</strike></small></p>\n<p>또한 이렇게 핸들링되지 않은 에러의 원인을 클라이언트에게 고스란히 알려주는 것은 보안 사고가 발생할 가능성이 너무 크므로, <code class=\"language-text\">500</code> 상태 코드로 에러의 발생 자체만을 알려주는 경우가 대부분이다. 만약 이 상태 코드를 만난다면, 바로 서버 로그를 까보거나 <a href=\"https://sentry.io/welcome/\" target=\"_blank\" rel=\"nofollow\">Sentry</a>나 <a href=\"https://www.bugsnag.com/\" target=\"_blank\" rel=\"nofollow\">Bugsnag</a>과 같은 에러 모니터링 솔루션을 적극 활용하는 것을 추천한다.</p>\n<p><strong>502 Bad Gateway</strong></p>\n<p>상태 코드 <code class=\"language-text\">502</code>를 만날 수 있는 가장 흔한 상황은 바로 백엔드 어플리케이션이 죽은 상황이다. 근데 왜 “Server Died”와 같이 직접적인 메세지가 아니라 “Bad Gateway”와 같은 메세지를 보내주는 것일까?</p>\n<p>그 이유는 백엔드 아키텍처가 아무리 간단한 구조라고 해도 절대 어플리케이션 1개로만 구성되지 않기 때문이다. 여기서 말하는 게이트웨이는 어플리케이션 간의 추상적인 연결점을 의미하는데, 이 메세지가 의미하듯 백엔드의 아키텍처는 최소 2개 이상의 어플리케이션으로 구성된 경우가 대부분이다.</p>\n<p>일반적인 경우 클라이언트가 보낸 요청은 곧바로 백엔드 어플리케이션에 전달되는 것이 아니다. 사실 백엔드 어플리케이션에 앞단에는 아파치나 Nginx 같은 서버 엔진이나 로드밸런서 같은 친구들이 대신 요청을 받아서 백엔드 어플리케이션으로 전달해주는 경우가 대부분이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-nginx line-numbers\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span> <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span> evan.com</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://127.0.0.1:3000</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_http_version</span> 1.1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Upgrade <span class=\"token variable\">$http_upgrade</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Connection <span class=\"token string\">'upgrade'</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Host <span class=\"token variable\">$host</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_cache_bypass</span> <span class=\"token variable\">$http_upgrade</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Nginx를 사용하면 일반적으로 이런 설정을 사용하게 되는데, 이렇게 되면 Nginx는 80번 포트에서 대기하며 HTTP 프로토콜을 사용한 요청을 받아 3000번 포트에서 대기하고 있는 백엔드 어플리케이션에게 전달해주는 역할을 수행하게 된다.</p>\n<p>이런 아키텍처를 사용하는 이유는 보안과 처리 효율 때문이다. 백엔드 어플리케이션 자체가 완전무결한 친구가 아니기 때문에 모든 요청을 안심하고 백엔드 어플리케이션에게 먹여줄 수가 없는 것이다. 그렇다고 누가 사용하는 지도 모르는 클라이언트에서 안전한 요청만 보내줄 것이라는 기대 또한 어불성설이다.</p>\n<p>게다가 뭔가 연산이 필요한 요청이 아닌, 파일을 찾아서 보내주기만 하는 간단한 요청 같은 경우는 굳이 안 그래도 바쁜 백엔드 어플리케이션에게 시킬 필요가 없으므로 이런 서버 엔진이 대신 처리해주기도 한다.</p>\n<p>그래서 백엔드에서는 앞 단에 아예 프록시 서버를 두어서 문지기 역할을 시키는 것이다. 이때 이 프록시 서버와 백엔드 어플리케이션 간의 연결된 추상적인 통로를 “게이트웨이”라고 부르는 것이다. 백엔드 어플리케이션이 죽어버릴 경우 앞 단의 문지기인 프록시 서버는 백엔드 어플리케이션에게 아무런 응답을 받지 못하게 되고, 클라이언트에게 <code class=\"language-text\">502 Bad Gateway</code>라는 응답을 보내주는 것이다.</p>\n<p><strong>503 Service Unavailable</strong></p>\n<p>상태 코드 <code class=\"language-text\">503</code>은 서버가 요청을 처리할 준비가 되지 않았음을 의미한다. 간혹 <code class=\"language-text\">502 Bad Gateway</code>와 비슷한 느낌으로 사용되기는 하지만, <code class=\"language-text\">503</code>은 보다 “일시적인 상황”을 의미하는 상태 코드이며, 일반적으로 서버에 부하가 심해서 현재 요청을 핸들링 할 수 있는 여유가 없는 경우에 많이 사용된다.</p>\n<p>AWS Lambda에서는 요청을 처리할 때 컨테이너의 동시 실행 갯수를 초과할 정도의 리소스가 필요하거나 어떤 작업의 처리 시간이 Lambda에 설정된 컨테이너의 최대 수명 시간을 초과했을 경우에 발생하기도 한다.</p>\n<p>이렇듯이 <code class=\"language-text\">503</code>은 일시적인 상황을 의미하므로 <code class=\"language-text\">429 Too Many Requests</code>와 동일하게 응답 헤더의 <code class=\"language-text\">Retry-After</code> 필드를 사용하여 “이 시간 이후에 다시 요청해봐”라는 의미를 클라이언트에게 전달해줄 수 있다.</p>\n<p><strong>504 Gateway Timeout</strong></p>\n<p>상태 코드 <code class=\"language-text\">504</code>는 <code class=\"language-text\">408</code>과 마찬가지로 요청에 대한 타임아웃을 의미한다. 그러나 <code class=\"language-text\">504</code> 상태 코드는 클라이언트에서 보낸 요청 때문에 타임아웃이 발생하는 것이 아니라 백엔드 아키텍처 내부에서 서버끼리 주고받는 요청에서 발생한다.</p>\n<p>앞서 이야기했듯이 백엔드의 아키텍처는 단순히 백엔드 어플리케이션 하나로만 구성된 것이 아니기 때문에, 클라이언트의 요청이 서버에 닿은 뒤에도 백엔드 어플리케이션끼리의 통신이 발생하게 된다. 만약 프록시 서버 역할을 맡은 Nginx가 백엔드 어플리케이션에 클라이언트의 요청을 전달했는데, 백엔드 어플리케이션이 일정 시간 동안 응답을 하지 않는 경우 Nginx는 클라이언트에게 <code class=\"language-text\">504 Geteway Timeout</code>을 내려주게 되는 것이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이번 포스팅에서는 HTTP 상태 외에도 RESTful API에 대한 내용도 함께 이야기하려고 했지만, 다시 한번 분량 조절에 대실패하면서 포스팅을 나누어 작성하게 되었다.<small>(점점 빈도가 잦아진다…)</small></p>\n<p>앞서 이야기했듯이 이런 상태 코드와 같은 요소들은 딱히 안 지킨다고 해서 프로그램에서 에러가 발생하는 것도 아니기 때문에 가볍게 생각하고 넘어가기 쉽상이지만, 보다 명확한 인터페이스를 정의하게되면 프로그램의 작동을 예측하기도 쉬워지고, 프론트엔드와 백엔드 개발자 간의 커뮤니케이션에도 큰 도움이 되기 때문에 되도록이면 표준을 지켜주는 것을 권장한다.</p>\n<p>이상으로 서버의 상태를 알려주는 HTTP 상태 코드 포스팅을 마친다.</p>","fields":{"slug":"20200315-about-http-status-code","path":"/2020/03/15/about-http-status-code/","lang":"ko"},"frontmatter":{"title":"서버의 상태를 알려주는 HTTP 상태 코드","subTitle":"인터넷의 질서를 만드는 작은 숫자들","date":"Mar 15, 2020","categories":["프로그래밍","네트워크","아키텍처"],"tags":["HTTP","HTTP 상태코드","RESTful","Axios","HTTP Status"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/14576b0c5dc2ed40f94b7160f16c1e06/d803c/thumbnail.png","srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/d803c/thumbnail.png 320w,\n/static/14576b0c5dc2ed40f94b7160f16c1e06/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/fc5c5/thumbnail.webp 320w,\n/static/14576b0c5dc2ed40f94b7160f16c1e06/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/14576b0c5dc2ed40f94b7160f16c1e06/01fb2/thumbnail.png","srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"d0c49c06-6d51-50eb-8cc3-7478fa5a298b","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%AA%A8%EB%93%A0-%EA%B2%83%EC%9D%80-%ED%95%A8%EC%88%98%EC%9D%98-%ED%95%A9%EC%84%B1%EC%9C%BC%EB%A1%9C-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%84%EB%8B%A4\">모든 것은 함수의 합성으로 이루어진다</a></p>\n<ul>\n<li><a href=\"#%EC%A0%95%EC%9D%98%EC%97%AD%EA%B3%BC-%EC%B9%98%EC%97%AD%EC%9D%B4-%EC%9D%BC%EC%B9%98%ED%95%B4%EC%95%BC-%ED%95%A8%EC%88%98%EB%A5%BC-%ED%95%A9%EC%84%B1%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\">정의역과 치역이 일치해야 함수를 합성할 수 있다</a></li>\n<li><a href=\"#%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EC%97%90%EB%8F%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8%EB%8A%94-%EC%A1%B4%EC%9E%AC%ED%95%9C%EB%8B%A4\">순수 함수에도 사이드 이펙트는 존재한다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C\">그럼 사이드 이펙트를 어떻게 관리해야할까?</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%91%ED%84%B0%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\">펑터란 무엇일까?</a></p>\n<ul>\n<li><a href=\"#%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACcategory\">카테고리(Category)</a></li>\n<li><a href=\"#%ED%8E%91%ED%84%B0functor\">펑터(Functor)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%8E%91%ED%84%B0%EB%A5%BC-%EC%A7%81%EC%A0%91-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90\">펑터를 직접 만들어보자!</a></p>\n<ul>\n<li><a href=\"#just\">Just</a></li>\n<li><a href=\"#nothing\">Nothing</a></li>\n<li><a href=\"#maybe\">Maybe</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"함수형 프로그래밍에서 코드를 작성한다는 것은 프로그램에서 수행해야하는 여러가지 행위들을 함수로 표현하고, 또 그 함수들을 요리조리 잘 합성해가며 거대한 프로그램을 만들어나가는 패러다임이다. 결국 함수형 프로그래밍에서 함수를 합성하는 행위라는 것은 이 패러다임의 근간이 되는 개념이기 때문에 굉장히 큰 의미를 가질 수 밖에 없는데, 문제는 이렇게 함수를 합성하는 과정에서 크고 작은 현실적인 문제들이 빵빵 터진다는 것이다.","html":"<p>함수형 프로그래밍에서 코드를 작성한다는 것은 프로그램에서 수행해야하는 여러가지 행위들을 함수로 표현하고, 또 그 함수들을 요리조리 잘 합성해가며 거대한 프로그램을 만들어나가는 패러다임이다.</p>\n<p>결국 함수형 프로그래밍에서 함수를 합성하는 행위라는 것은 이 패러다임의 근간이 되는 개념이기 때문에 굉장히 큰 의미를 가질 수 밖에 없는데, 문제는 이렇게 함수를 합성하는 과정에서 크고 작은 현실적인 문제들이 빵빵 터진다는 것이다.</p>\n<!-- more -->\n<p>이런 문제가 빵빵 터지는 가장 큰 이유는 간단하다. 아무리 우리가 순수 함수를 사용한다고 해도 수학의 함수와 완벽하게 똑같을 수는 없기 때문이다. 애초에 프로그래밍과 수학은 비슷하지만 엄연히 다른 학문이다.</p>\n<p>그래서 전 세계의 똑똑이들은 이런 문제들을 해결하기 위해 펑터(Functor)나 모나드(Monad)와 같은 수학의 개념들을 끌고 와서 사용하기 시작했는데, 문제는 이 개념들이 직관적으로 이해하기에는 너무나도 추상적이고 난해한 녀석들이라는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ef8b4abd3bbf9916883c3115a00bab71/eb645/functor-example.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 47.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcUlEQVR42n1SPUsDQRB9+TAfl9xdssnlvBhP0YgWIRZBSRfwi4C2dqksLAQLK8vr7AIWgljY5BfYCoKtf8JSwcbOOs5cZuMi0YHH7u2+nXlvboCfmDOQwP+RFF56Fp8vHYJrrK4QZwWfl4RrIhnf0k6dAcUpPRon0bvhb0VI/UqW3gEWIiCjD4LTNwudS1eKAGVS8wXUnwCfH3jHz83i+btH+zzB1olkdUZA7RVoP9KK/r1XGrxsBtHYEm4+tvABzF8jF7Iie+92DScPtvSlQlgkbIiCKqv7BMJ1EgErDDLM70VcMAdxquUr6Z2lK1F4ExPxXQBxQVgGJ5y0xBd1GZ0wttWZNDtVOFxp1a+2Kmpb6WbD+IucPEdSljiRvVuvlAftVmN4oBC6ZRET28pOm3x3VHUuugqFQm3GT2EVVV2gMewqf7RfU/2mI3ni8A27WalS+mNs2O6qPLZkVDQ/Zc5hQshFUfHXYCcMfl5akjUZ31tXJv6WZZGyAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"functor example\" title=\"\" src=\"/static/ef8b4abd3bbf9916883c3115a00bab71/6af66/functor-example.png\" srcset=\"/static/ef8b4abd3bbf9916883c3115a00bab71/69538/functor-example.png 160w,\n/static/ef8b4abd3bbf9916883c3115a00bab71/72799/functor-example.png 320w,\n/static/ef8b4abd3bbf9916883c3115a00bab71/6af66/functor-example.png 640w,\n/static/ef8b4abd3bbf9916883c3115a00bab71/d9199/functor-example.png 960w,\n/static/ef8b4abd3bbf9916883c3115a00bab71/21b4d/functor-example.png 1280w,\n/static/ef8b4abd3bbf9916883c3115a00bab71/eb645/functor-example.png 2500w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>보기만 해도 눈물이 절로 나오는 펑터 설명 다이어그램...</small>\n</center>\n<p>필자가 펑터나 모나드에 대한 공부를 하면서 구글링을 하면서 찾아본 많은 자료들은 대략 두 가지 정도로 나누어졌는데, 바로 “겁나 어려운 수학적인 설명”과 “코드로 된 예시”였다.</p>\n<p>문제는 이 수학적인 설명과 코드로 된 예시 사이를 이어주는 자료가 별로 없었다는 것이다. 즉, 펑터나 모나드가 정확히 프로그래밍의 어떤 문제를 해결하기 위해 도입된 것인지 쉽게 풀어서 설명해놓은 자료가 별로 없었다. <small>(남들은 다 이해하는데 필자가 멍청해서 이해를 못한 것일수도 있다)</small></p>\n<p>하지만 그렇다고해서 제대로 된 이유도 모르고 펑터나 모나드를 사용하고 싶지는 않았기에 직접 조사해보고 조져보기로 했다.</p>\n<p>그래서 이번 포스팅에서는 함수형 프로그래밍에서 별 생각없이 함수를 조합하면 어떤 문제들이 발생하는지, 그리고 그 문제들을 어떤 방식으로 해결할 수 있는 지에 대한 이야기를 해보려고 한다.</p>\n<h2 id=\"모든-것은-함수의-합성으로-이루어진다\" style=\"position:relative;\">모든 것은 함수의 합성으로 이루어진다<a href=\"#%EB%AA%A8%EB%93%A0-%EA%B2%83%EC%9D%80-%ED%95%A8%EC%88%98%EC%9D%98-%ED%95%A9%EC%84%B1%EC%9C%BC%EB%A1%9C-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%84%EB%8B%A4\" aria-label=\"모든 것은 함수의 합성으로 이루어진다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>다시 한번 이야기하지만 함수형 프로그래밍은 프로그램에서 수행해야하는 어떠한 행위들을 함수로 표현하고, 또 그 함수들을 이렇게 저렇게 잘 합성하여 거대한 프로그램을 만들어나가는 패러다임이다.</p>\n<p>즉, 이러한 함수형 프로그래밍의 정의에서 가장 중요한 키워드는 역시 “함수의 합성”이라고 말할 수 있다. 함수형 프로그래밍에서 그토록 사이드 이펙트를 경계하는 이유도 결국 함수를 안전하게 합성하기 위해서는 함수의 입력과 출력을 예측할 수 있어야하기 때문이다.</p>\n<p>함수형 프로그래밍의 세계에서는 프로그램 내부에서 발생하는 모든 행위들을 함수로 표현하고 있기 때문에 변수에 값을 할당하거나 간단한 사칙연산 조차도 함수로 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 명령형 프로그래밍</span>\n<span class=\"token keyword\">const</span> foo<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nfoo <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 함수형 프로그래밍</span>\n<span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> add2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">add2</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 프로그램은 <code class=\"language-text\">number</code> 타입의 변수를 선언하고, 그 값에 2를 더하는 초 간단한 프로그램이다.</p>\n<p>명령형 프로그래밍으로 작성된 코드에서는 단순히 <code class=\"language-text\">foo = 1</code>과 같이 표현할 수 있었던 변수의 할당은 <code class=\"language-text\">1</code>을 반환하는 함수로, <code class=\"language-text\">foo + 2</code>로 표현하던 연산은 <code class=\"language-text\">add2(foo)</code>와 같은 함수로 표현되었다.</p>\n<p>우리가 이 코드에서 주목해야할 부분은 바로 가장 마지막 줄의 <code class=\"language-text\">add2(foo)</code>이다.</p>\n<p><code class=\"language-text\">add2(foo)</code>라는 것은 <code class=\"language-text\">foo</code> 변수에 할당되었던 익명 함수의 출력 값인 <code class=\"language-text\">1</code>을 <code class=\"language-text\">add2</code> 함수의 입력 값으로 사용하겠다는 의미이며, 이러한 행위가 바로 함수의 합성이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 조금 더 간단하게 표현한 모습은 이렇다</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add2</span> <span class=\"token operator\">=</span> x <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">add2</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>변수에 값을 할당하고 더하는 간단한 연산 조차도 함수로 표현해야하는 함수형 프로그래밍의 세계에서 거대한 프로그램을 견고하게 만든다는 것은 여러가지 복잡한 함수들을 어떻게 잘 합성해서 사용할 수 있는지에 따라 좌지우지될 수 있다는 뜻이다.</p>\n<p>이렇게 보면 굉장히 간단한 개념이지만, 사실 아무 함수끼리나 막 합성할 수 있는 것은 아니다. 함수의 합성에는 아주 중요한 규칙이 한 가지 정해져있는데, 바로 합성하려하는 함수들의 “정의역과 치역이 서로 일치해야한다는 것”이다.</p>\n<h3 id=\"정의역과-치역이-일치해야-함수를-합성할-수-있다\" style=\"position:relative;\">정의역과 치역이 일치해야 함수를 합성할 수 있다<a href=\"#%EC%A0%95%EC%9D%98%EC%97%AD%EA%B3%BC-%EC%B9%98%EC%97%AD%EC%9D%B4-%EC%9D%BC%EC%B9%98%ED%95%B4%EC%95%BC-%ED%95%A8%EC%88%98%EB%A5%BC-%ED%95%A9%EC%84%B1%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\" aria-label=\"정의역과 치역이 일치해야 함수를 합성할 수 있다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이전에 작성했던 <a href=\"/2019/12/29/about-pure-functions/\">수학에서 기원한 프로그래밍 패러다임, 순수 함수</a> 포스팅에서 한 차례 이야기한 적이 있지만, 함수형 프로그래밍에서는 함수의 사이드 이펙트를 최대한 없애버리기 위해 순수 함수를 사용한다.</p>\n<p>대표적인 순수 함수의 특징은 대략 이 두 가지이다.</p>\n<blockquote>\n<ol>\n<li>함수 외부의 상태를 변경하거나 참조하지 않는다!</li>\n<li>동일한 입력을 넣었으면 항상 동일한 출력을 반환해야 한다!</li>\n</ol>\n</blockquote>\n<p>이런 순수 함수를 사용하면 개발자가 함수의 행동을 예측하기 쉬워지기 때문에 디버깅이 편리하다는 장점도 있지만, 사실 애초에 저 규칙들이 지켜지지 않는다면 함수를 합성할 수 없기 때문에 모든 행위를 함수로 표현하고 조합해서 프로그래밍을 만드는 짓을 할 수 조차 없다.</p>\n<p>왜 저 규칙들을 준수해야 함수의 합성이 가능하다는 것일까? 일단 순수 함수는 수학의 함수를 프로그래밍으로 구현한 개념이니, 한번 수학의 함수가 어떤 느낌으로 작동하는 녀석인지부터 살펴보도록 하자.</p>\n<p>일단 수학의 함수는 함수의 입력으로 사용할 수 있는 값들의 집합인 정의역과, 함수의 출력으로 사용할 수 있는 값들의 집합인 치역을 가지고 있다.</p>\n<p>그리고 정의역에 있는 원소 하나와 치역에 있는 원소 하나는 무조건 “1:1”로 매핑되어야한다. 즉, 동일한 입력을 함수에 넣었으면 항상 동일한 출력을 반환해야 한다는 말이다. 만약 이 규칙이 깨져버리면 그건 더 이상 함수라고 부를 수 없는 변태같은 무언가가 되어버린다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/33c48b0d809a227af542dee05cf064b5/80cfc/functions.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABNklEQVR42m2T207DMAyG3axt0tM6YBsgJC6QuNlASLvhqXggXoEX4zGK034GD7D0K4kPvx07ERE5Kk6KR0Uhi7SKF8U9OtNfK14Vz4pRfuQBXZMPSdFDYrLi3DqyLAHfTlE6fUIXBYdKscaQCTbok2VFGnQt/gUkl6ydsedsA4YctFdcucwmPdVnny22C8UNLcj+38xrKsv7HYSBcwAtyRtg5NFVPx8yagIqSBIBRmh9DfjYviE22jUi1fkK91wp/ENYYr8jZuTKAz5nldhgrJcFfQtuv6LCLf2ztbIBtrBvMNRk3PnJIR1Bg3tmeb1F19jkLLBw78omXDvC2pEm9zZtML38aeyb4mO+VvKNdhKx1QfFtPS0dEOiqnG+8kne9Qt9zk0Xmc5+yW95UsLDtHxZdV18vwAdIhBsPqNo7AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"functions\" title=\"\" src=\"/static/33c48b0d809a227af542dee05cf064b5/6af66/functions.png\" srcset=\"/static/33c48b0d809a227af542dee05cf064b5/69538/functions.png 160w,\n/static/33c48b0d809a227af542dee05cf064b5/72799/functions.png 320w,\n/static/33c48b0d809a227af542dee05cf064b5/6af66/functions.png 640w,\n/static/33c48b0d809a227af542dee05cf064b5/d9199/functions.png 960w,\n/static/33c48b0d809a227af542dee05cf064b5/21b4d/functions.png 1280w,\n/static/33c48b0d809a227af542dee05cf064b5/80cfc/functions.png 1844w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>쉽게 말해 함수의 입력으로 사용할 수 있도록 정해져 있는 값들 중에 하나를 뽑아서 함수에 던지면, 반드시 출력으로 사용할 수 있도록 정해져 있는 값들 중에 하나가 튀어나온다는 것이다.</p>\n<p>그렇다면 이 개념을 그대로 프로그래밍으로 구현한 순수 함수에게도 정의역과 치역이라고 부를 수 있을만한 무언가가 있다는 말인데, 프로그래밍의 세계에서 살고 있는 순수 함수의 정의역과 치역은 무엇이 될 수 있을까?</p>\n<center>\n.<br />\n.<br />\n.<br />\n<br />\n</center>\n<blockquote>\n<p>바로 **타입(Type)**이다.</p>\n</blockquote>\n<p>사실 프로그래밍에서 사용하는 타입이라는 녀석도 잘 생각해보면 일종의 집합이라고 볼 수 있다. <code class=\"language-text\">number</code>라는 집합은 <code class=\"language-text\">{-1, 0, 0,1, 1, 2, NaN, Infinity...}</code>과 같이 모든 숫자 값을 원소로 가지고 있는 집합이고, <code class=\"language-text\">boolean</code>이라는 집합은 <code class=\"language-text\">{true, false}</code>를 원소로 가지는 집합, <code class=\"language-text\">string</code>이라는 집합은 프로그래밍으로 만들어 낼 수 있는 모든 문자열들을 가지고 있는 집합이라는 이야기이다.</p>\n<p>위에서 예시로 들었던 <code class=\"language-text\">add2</code> 함수를 다시 한번 가져와서 살펴보면, 이 함수는 <code class=\"language-text\">number</code> 타입을 가진 값을 받아서 다시 <code class=\"language-text\">number</code> 타입의 값을 반환하고 있다는 것을 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> add2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 <code class=\"language-text\">add2</code> 함수는 <code class=\"language-text\">number</code> 집합을 정의역과 치역으로 가지고 있다고 볼 수 있는 것이다. 여기에 더 나아가서 다른 형태의 함수들의 정의역과 치역도 모두 동일한 규칙으로 정의해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">f</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 정의역: number, 치역: string</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">g</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span> <span class=\"token operator\">=></span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 정의역: Array&lt;string>, 치역: boolean</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">h</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 정의역: string, 치역: boolean</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이제 슬슬 수학의 함수와 프로그래밍의 순수 함수 간의 공통점이 조금 더 보이기 시작한다.</p>\n<p>그럼 이제 원래 본론이었던 함수의 합성에 대해 한번 이야기해보자. 사실 수학의 세계에서 함수를 합성하는 상황은 굉장히 흔한 일이며, 심지어 함수의 합성을 나타내는 전용 기호도 준비되어있다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> 함수와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span> 함수를 합성한 합성함수 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span></span>는 이런 간단한 수식으로 나타낼 수 있다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>h</mi><mo>=</mo><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">h = g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span></div>\n<p>갑자기 수식이 나와서 머리가 아프다면 그냥 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> 함수는 밥먹기, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span> 함수는 그릇 치우기, 합성함수 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span></span>는 밥먹고 그릇 치우기 정도로 이해해도 아무 문제가 없다. 원래 함수란 그렇게 추상적인 느낌이다.</p>\n<p>이 식에서 함수의 실행 순서는 오른쪽에서 왼쪽이다. 즉, 합성된 함수인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span></span> 함수를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">h(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span></span>와 같이 사용한다는 것은 사실 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(f(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span></span>와 같이 함수를 합성해서 사용하는 것과 동일하다는 것이다.</p>\n<p>하지만 이런 식으로 함수를 겹쳐가면서 합성을 표현한다면 많은 함수를 합성하는 공식을 보았을 때 괄호만 보일 게 뻔하므로 저 동그란 연산자를 사용하여 합성된 함수들을 펼쳐서 읽을 수 있도록 해주는 것이다. <small>(콜백과 async/await의 차이를 생각해보자)</small></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 함수 합성 연산자가 없다면 대충 이런 느낌이 되어 버리지 않을까...?</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token function\">h</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token function\">g</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 함수를 합성하기 위해서는 첫 번째 함수인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>의 치역과 그 다음 함수인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>의 정의역이 동일해야 한다는 중요한 원칙이 있다.</p>\n<p>방금 위에서 순수 함수의 정의역과 치역은 타입이라고 했으니, 첫 번째 함수의 출력 값의 타입과 그 다음 함수의 입력 값의 타입이 동일해야한다고 말할 수도 있을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 합성이 가능하다!</span>\n<span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span>\n<span class=\"token function-variable function\">g</span><span class=\"token operator\">:</span>           <span class=\"token builtin\">number</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span>\n\n<span class=\"token comment\">// 이건 합성이 불가능...</span>\n<span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">string</span>\n<span class=\"token function-variable function\">g</span><span class=\"token operator\">:</span>           <span class=\"token builtin\">number</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>정의역과 치역 어쩌고하면 조금 복잡해보일지 몰라도 타입으로 바꿔보니 굉장히 당연하기 짝이 없는 이야기가 되어버렸다. 그렇다면 순수 함수를 사용하면서 이 규칙만 잘 적용해주면 아무 문제가 없을까?</p>\n<p>음, 대부분의 경우에는 가능하겠지만 슬프게도 모든 케이스를 커버할 수는 없다. 프로그래밍의 세계에는 에러라던가 불확실성과 같이 수학의 세계에는 없는 케이스들이 존재하기 때문이다.</p>\n<p>수학의 함수를 프로그래밍적으로 구현한 순수 함수라 할 지라도 프로그래밍의 세계에 존재하는 이상 이런 케이스들을 모두 피해갈 수는 없다.</p>\n<p>결국 아무리 순수 함수를 사용한다고 해도 이런 문제점들이 여전히 존재하기 때문에 전세계의 똑똑이들이 “도대체 어떻게 하면 안전하게 함수를 합성할 수 있을까?”라는 고민을 하게 된 것이고, 그 고민을 통해 도입된 것이 바로 펑터나 모나드와 같은 수학의 개념들인 것이다.</p>\n<h3 id=\"순수-함수에도-사이드-이펙트는-존재한다\" style=\"position:relative;\">순수 함수에도 사이드 이펙트는 존재한다<a href=\"#%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EC%97%90%EB%8F%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8%EB%8A%94-%EC%A1%B4%EC%9E%AC%ED%95%9C%EB%8B%A4\" aria-label=\"순수 함수에도 사이드 이펙트는 존재한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>사이드 이펙트(Side-Effect)라는 단어는 한국어로 직역하면 “부수 효과”이다.</p>\n<p>즉, 함수에게 기대하고있는 행위 외에 발생하는 모든 부수 효과들을 우리는 사이트 이펙트라고 하는 것이다. 함수가 외부 상태에 영향을 받는 것은 대표적인 사이드 이펙트 중 하나에 불과하다.</p>\n<p>사실 순수 함수를 수학의 함수와 비교해보면 “같은 값을 입력받으면 늘 같은 출력을 반환한다”라는 규칙이 보장되는 것 외에는 허술하기 짝이 없는 함수이다. 예를 들어 문자열을 입력받은 후 그 문자열의 가장 첫번째 글자를 반환하는 함수가 있다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getFirstLetter</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>일단 이 함수도 순수 함수는 맞다. 함수의 출력 값은 인자에만 영향을 받고 있고, 늘 같은 입력 값에는 같은 출력을 반환하고, 외부 상태에 전혀 영향도 받고 있지 않기 때문이다.</p>\n<p><code class=\"language-text\">getFirstLetter</code> 함수는 주어진 문자열의 첫 글자를 반환하는 순수 함수이지만, 만약 빈 문자열이 인자로 주어질 경우 <code class=\"language-text\">string</code>형이 아닌 <code class=\"language-text\">undefined</code>를 반환할 것이다.</p>\n<p>우리가 과연 이 함수를 사용할 때 “반드시 <code class=\"language-text\">string</code> 타입이 반환될꺼야”라고 장담할 수 있을까?</p>\n<p>만약 이렇게 <code class=\"language-text\">getFirstLetter</code> 함수가 반드시 <code class=\"language-text\">string</code> 타입을 반환할 것이라고 장담하고 함수를 합성했다면 아마 이런 타입 에러를 만날 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getStringLength</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">getStringLength</span><span class=\"token punctuation\">(</span><span class=\"token function\">getFirstLetter</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Uncaught TypeError<span class=\"token operator\">:</span> Cannot read property <span class=\"token string\">'length'</span> <span class=\"token keyword\">of</span> <span class=\"token keyword\">undefined</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사실 이 에러 조차 사이드 이펙트라고 할 수 있다. 어찌되었든 우리의 순수 함수에게 기대했던 효과가 아니라 부수적으로 발생하고 있는 효과이기 때문이다.</p>\n<p>이렇게 여러 개의 함수가 합성되어 있는 상황에서 단 하나의 함수라도 에러가 발생하면 합성 함수로 구성된 연산 전체가 망해버리기 때문에 우리는 이 사이드 이펙트를 반드시 관리해줘야 한다.</p>\n<p>사실 <code class=\"language-text\">getFirstLetter</code> 함수의 치역은 <code class=\"language-text\">string</code>이 아니라, <code class=\"language-text\">string</code> 집합과 <code class=\"language-text\">undefined</code> 집합이 합쳐져 있는 <code class=\"language-text\">string|undefined</code> 집합이다. 그러니 우리는 이 두 함수의 정의역과 치역을 다시 설정해주고 예외 처리를 추가함으로써 이 문제를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getFirstLetter</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token operator\">|</span><span class=\"token keyword\">undefined</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getStringLength</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token operator\">|</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>하지만 이렇게 어떤 함수가 여러 개의 집합이 합쳐진 치역을 가지기 시작하면 이 함수와 합성하기 위한 모든 함수의 정의역도 여러 개의 집합이 합쳐진 치역을 가져야하기 때문에, 결국 <code class=\"language-text\">type|undefined</code>처럼 암 걸리는 타입이 모든 함수에 적용되어야 할 것이다.</p>\n<p>게다가 이런 상황이 발생할 때마다 함수 내부에서 매번 조건 검사를 통해 값의 유무를 검사하는 것은 너무나도 귀찮은 일이고, 여기저기서 동일한 코드가 계속 발생하기 때문에 이 방법이 근본적인 해결책은 아닌 것 같다.</p>\n<p>이렇게 함수에서 어떤 타입이 반환될지 장담할 수 없다는 불확실성 또한 결국 정의역과 치역을 일치시켜야하는 함수의 합성 과정에서 명확한 타입의 사용을 저해하는 요소가 되기 때문에 반드시 믿고 걸러야하는 사이드 이펙트라고 할 수 있다.</p>\n<h2 id=\"그럼-사이드-이펙트를-어떻게-관리해야할까\" style=\"position:relative;\">그럼 사이드 이펙트를 어떻게 관리해야할까?<a href=\"#%EA%B7%B8%EB%9F%BC-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C\" aria-label=\"그럼 사이드 이펙트를 어떻게 관리해야할까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이런 상황이 발생하는 이유는 그냥 “컴퓨터는 수학이 아니니까”라고 말할 수 밖에 없다. 어쨌든 프로그램에서 돌아가는 모든 함수는 저런 문제들을 가지고 있다. 심지어 순수 함수라고 할지라도 말이다.</p>\n<p>즉, 근본적으로 이 문제는 함수들 간의 합성 과정에서 어쩔 수 없이 발생하는 사이드 이펙트를 어떻게 하면 잘 관리해가면서 합성할 수 있을지에 대한 고민이다.</p>\n<p>함수를 합성할 때 중간에 껴있는 함수에서 에러가 발생하더라도 합성된 함수의 연산을 안전하게 끝낼 수 있을 지, 불확실한 함수의 출력을 어떻게 하면 명확하게 만들어서 다음 함수로 전달할 수 있을 지 말이다.</p>\n<p>그렇다면 함수를 다른 함수로 한번 감싸서 안전하게 예외처리를 진행하거나, 혹은 중간에 이상한 값이 나오면 그대로 다음 함수를 지나치게 만들면 되지 않을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">StringFunction</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">safety</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token operator\">|</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> fn<span class=\"token operator\">:</span> StringFunction<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">?</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">safety</span><span class=\"token punctuation\">(</span><span class=\"token function\">getFirstLetter</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> getStringLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">safety</span><span class=\"token punctuation\">(</span><span class=\"token function\">getFirstLetter</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> getStringLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">1</span>\n<span class=\"token keyword\">undefined</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>하지만 이런 방식은 수많은 타입의 입출력을 가진 함수들에게 모두 적용하기에는 약간 무리가 있어보이니 제네릭 타입을 사용하여 조금 더 유연하게 만들어 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">safety</span> <span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token operator\">|</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">fn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">?</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token generic-function\"><span class=\"token function\">safety</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function\">getFirstLetter</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> getStringLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token generic-function\"><span class=\"token function\">safety</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function\">getFirstLetter</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> getStringLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">1</span>\n<span class=\"token keyword\">undefined</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>오호 조금 그럴싸해졌다. 결국 <code class=\"language-text\">safety</code> 함수는 <code class=\"language-text\">T</code>또는 <code class=\"language-text\">undefined</code>의 값을 인자로 받은 후 이 인자가 <code class=\"language-text\">undefined</code>이라면 그대로 <code class=\"language-text\">undefined</code>을 반환하고, 만약 아니라면 <code class=\"language-text\">T</code> 타입을 인자로 받아서 <code class=\"language-text\">U</code> 타입을 반환하는 함수에게 인자를 넘겨주고 그 함수의 실행 결과를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">값이 있다<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> fn<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span>\n값이 없다<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token keyword\">undefined</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>결국 우리는 <code class=\"language-text\">getFirstLetter</code> 함수의 치역과 <code class=\"language-text\">getStringLength</code> 함수의 정의역을 바로 연결해버리는 것이 아닌, <code class=\"language-text\">x ? fn(x) : x</code>라는 로직을 통해 함수의 사이드 이펙트를 한번 감싸준 다음 함수를 안전하게 합성한 것이다.</p>\n<p>그렇다면 이 개념을 조금 더 확장해서 함수가 출력한 값을 사용할 때 일종의 안전장치 역할을 하는 함수가 늘 값을 감싸고 있다면 어떨까? 이런 느낌으로 함수의 정상적인 결과와 사이드 이펙트를 감싸줄 수 있는 무언가를 만들 수 있으면 이 문제를 해결할 수 있지 않을까?</p>\n<center>\n  <div style=\"width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/4ff50b03adf61a44030b6872ee2fdcce/f793b/set.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADyElEQVR42m2UW08bRxTH3TxFbb9bHppW9KtUavvSN3ipqpZGitJcheglCQQQpFWt0AawZ/bi9QXstbnULgaMvFdj452Zf8/smsSorHR07J3Z37mfXG7qAXAr1af5jxEVZzAqLZC4uLAHGFgxRraLsbMA35jRd7Jvvr6Vu+m5OoDH7iJgLuQuzjqbyi0twbVfoNvcQLO8hMP6uoKsQQbFJkLjk2lHpmC5D1LtF2YhasClo+iyzK/+KB7Mf6We3f8GfPMJHnz/pbr37RcCPpMYlxVEFfCLc9MMTc9gkTELNEA6EYEpETJgYEJFBmTISXOM+ztI/CLd4YDHJZ0JwAVCPnctfPj8M21NRqZoeueKewJH/ilUwPTl90JwLck+x6VNBhpMqZCgUnvKP81g//IPMXQqSEo48Lrybw8oeApaHwdtAhWgNCwgiTnEPxwjRmJmetyk8EUZuCiV0d34KEcVnNEWRr4tmZcQDKnskFjeCCI0kYY/gY4cjqHBMDRZpi0GeU5QRbmPzM9zcuA8A6o49fbFFkGKfYWClgnUDxqpl9o7ecIwti1yqATh2KRtJJaFpM0ol3uUc+tRTsZmnUzh0D+RbwnAfEmwTPT/Y1+HvQNFQNU20fn9D5RfPEd95RWqyy/RWl3TOaWwHTJqOjkZGREihv3IV6vNPh7+WcDCdhlP3nC8PhqgE51RqBlQHppoE3D93jzW5n+A9evPqC+/ouJwhcsSGTa6OaKmQDfw1JtTge+eb+D+6y0sFqrY7CkcBRqYhTxuMYhSCbsry/jr8SO01teoOCYu95iiidLAE8qhRSGbaHk9uR0A641jrNQ6yLc9bPlA2z9OPcTAwHifobmyBvu3X1BdeonNxz/BWFzE2KWQk/Ik5GHpKVBB2+sInTMzUjBjgAcKukhnwUGaQ8QGRJsjLhQQswIGJBe8iGh7RxuiotRB7fcwJy7KM1BVeP6e3NYtc1XltNISg6BCwGw61Dk1tGVck5FJhrrUNrrK1IJTjV2F3Y9TKJtUuOYH73swnRTK4y71IiexJtohWEJGR04ZNjW2foQePVmBFzbFdh9KT0mRoHFQS717NykElL0MNiyScKZEl/KHXbpn3r22tmSYLYcgcpMj6sk4rGUNPT3LYTZ+qpdWXIkzvRxaurqz19bY1caR/eKczicSW1GrSBVwQRD1DhZwlb6LKExZVVB7U+srY0xv62yNhewOhelCUdXQoJ1X0fsxE/1bv9Nn6YJld26E/W97H+Rv63VE6+spbe8aLdRz8q6nf6fv6AzI377p4/8ApEvjlY5UrW0AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"set\" title=\"\" src=\"/static/4ff50b03adf61a44030b6872ee2fdcce/6af66/set.png\" srcset=\"/static/4ff50b03adf61a44030b6872ee2fdcce/69538/set.png 160w,\n/static/4ff50b03adf61a44030b6872ee2fdcce/72799/set.png 320w,\n/static/4ff50b03adf61a44030b6872ee2fdcce/6af66/set.png 640w,\n/static/4ff50b03adf61a44030b6872ee2fdcce/d9199/set.png 960w,\n/static/4ff50b03adf61a44030b6872ee2fdcce/21b4d/set.png 1280w,\n/static/4ff50b03adf61a44030b6872ee2fdcce/f793b/set.png 1404w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <br>\n</center>\n<p>만약 저 추상적인 무언가가 함수의 사이드 이펙트를 관리해주면서 다른 함수와의 합성을 진행할수만 있다면, 함수를 합성하는 과정에서 일일히 저런 예외 처리를 해주지 않아도 되고, 함수들의 입출력에 대한 타입 안정성도 가져가며 마음 놓고 합성을 쭉쭉 해나갈수 있을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 이런 느낌으로 말이다!</span>\nf<span class=\"token operator\">:</span> Something<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Something<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span>\ng<span class=\"token operator\">:</span>                      Something<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Something<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>함수는 제대로 된 치역에 해당하는 값을 반환할 수도 있고 사이드 이펙트를 일으킬 수 있는 <code class=\"language-text\">null</code>이나  <code class=\"language-text\">undefined</code> 같은 값을 반환할 수도 있지만, 뭐가 되었든 저 <code class=\"language-text\">Something</code>이라는 녀석이 알아서 예외를 핸들링할 수 있도록 만들기만 한다면 우리는 그런 자잘한 건 신경쓰지 않고 함수를 쭉쭉 합성할 수 있기 때문이다.</p>\n<p>그리고 이런 느낌이라면 <code class=\"language-text\">null</code>이나 <code class=\"language-text\">undefined</code>를 관리하는 것 외에도, 다양한 로직을 값에다가 감싸서 사용하면 되니까 나름 확장성도 좋은 개념인 것 같다. 뭐 대충 이런 느낌으로 말이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> 값이 있을 수도 있고 없을 수도 있다\n<span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> 지금은 값이 없는데 나중에 값이 생기면 값을 준다\nList<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> 같은 속성의 값을 여러 개 가지고 있을 수도 있다</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그리고 이렇게 값을 감싸고 있는 무언가를 효율적으로 사용하려면 내부에 있는 값을 자유롭게 변경할 수 있어야 하므로 <code class=\"language-text\">Maybe&lt;T> -> Maybe&lt;U></code>와 같은 동작을 수행할 수 있는 무언가도 필요할 것 같다.</p>\n<p>이런 고민 끝에 개발자들은 이런 비슷한 역할을 수행하는 수학의 한 개념을 차용하게 되는데, 그 개념이 바로 <code class=\"language-text\">펑터(Functor)</code>이다.</p>\n<h2 id=\"펑터란-무엇일까\" style=\"position:relative;\">펑터란 무엇일까?<a href=\"#%ED%8E%91%ED%84%B0%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\" aria-label=\"펑터란 무엇일까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>펑터는 보통 값을 품고 있는 어떠한 박스의 형태로 설명되고는 한다. 방금 위에서 설명한 것과 같이 함수의 정상적인 결과와 사이드 이펙트를 감싸서 처리할 수 있는 무언가를 설명하기에는 박스가 적절한 예시이기 때문이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/340a17df74756ac7c3e06a5a4eaa74fb/78597/fmap_just.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 28.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAABC0lEQVR42mVQTUvEMBDtr9ejB8+uiseCCMJ6dNnjgqigtFnWfmT7kSZtYpsE048kZld2EX0wwzAzj3lvPGutMcYe4Gqtdcd5EkdScNeBECgl9yNr9GT2+Fn29KSPRCokSDNGG1SRxeI+266zHK1W87bF6ksFGXoN1r0UbjVO4wJjb3brE1oLKbv2M4DFbPkM8ooQEiURY9Sp6IdhnDQl+B2iywcfJGveydPri3P/xju5Onv7AASTsiy5lI9B/LKteNc2lAkhD152mcn+bjnfwI1T8RSGII08WCHnUClVYYwQitNEDYP9B8fXeirzAkIYAsAo3Xl24S6Q2iklTdOQuh6n8c8Xf7/TWHPEN7KLTgVWzdmZAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"fmap just\" title=\"\" src=\"/static/340a17df74756ac7c3e06a5a4eaa74fb/6af66/fmap_just.png\" srcset=\"/static/340a17df74756ac7c3e06a5a4eaa74fb/69538/fmap_just.png 160w,\n/static/340a17df74756ac7c3e06a5a4eaa74fb/72799/fmap_just.png 320w,\n/static/340a17df74756ac7c3e06a5a4eaa74fb/6af66/fmap_just.png 640w,\n/static/340a17df74756ac7c3e06a5a4eaa74fb/78597/fmap_just.png 947w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>[출처] http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html</small>\n</center>\n<p>저 박스는 결국 안전하게 값을 사용할 수 있도록 도와주는 로직을 가지고 있거나, 혹은 여러 개의 값을 처리할 수 있는 로직을 가지고 있거나, 아직은 값이 결정되지 않았지만 나중에 값이 결정되고 나면 값을 사용할 수 있는 로직을 가지고 있는 등, 값을 사용할 때 도움을 주는 여러가지 로직을 담고 있는 마법의 박스라고 할 수 있다.</p>\n<p>이때 이 박스는 역할이 고정된 것이 아니라 <code class=\"language-text\">Maybe</code>, <code class=\"language-text\">Promise</code> 등 다양한 기능을 가질 수도 있기 때문에 <code class=\"language-text\">문맥(Context)</code>이라는 이름으로 불리기도 한다.</p>\n<p>우리가 방금 만들었던 <code class=\"language-text\">safety</code> 함수도 값을 감싸고 있는 일종의 박스라고 생각해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">safety</span> <span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token operator\">|</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">fn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">?</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<center>\n  <div style=\"width: 200px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2a4ed3a1c967bb8474d5ef04b59bb091/27b7a/box.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 110.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAADLUlEQVR42pVVW1NSURTG0uk31G91GpvqoR7qoZesqV50SisrdZTwAU1L4JwDnAscQJT7XS4HEBTPOV9rby6Bxowy87HX3mt9315r783C4aAPsHqXjTEb9zw1SIdV9Lx1GFILLamNltgkkO0/Q0sg29eAQXE9TxV+EZjra+COY2DM0NcM3O7ZCioPiFgOdIA/pxf2WiAOhlffXPjkCWFpP4DNcBr7hbYd7AJi0y6VUb4PcXFuTEucozwW0BROLo1ASaj1TF8T2M2d4dnSdzx5v4J3Lg+ek/3GeYCnH1bhjFcgtAAWyzi24UvAEB4xLQcM32MgAVzIltWRoTY6EOo2xLoJX+2SbBMBIkuGRWs9HOQNSA3yUYza6IJx0FNMrtESFhz2eTCNswAsQ7AoS5hNPy6bwT5ach9jc7OtjOYslnFsQzRxTsJdJeqgcumYJeawyQG7Id0OBuOKFhdsSRkHTZpo006GaJdPEsjoOWQjk8joWY7r6zmUjxOM2xdsiiRo0PG2JVgNyc6E80ioRSS1f0ioBWT1CgmccnvSV+SixLXoDtixZScFyZnUCkiF+khqeRIqQ9yTIewGuc3W/vkLPPMbCya0HErxOtZXtrC2vIFivHY7wfR/Su6jMCr/asnp8JSS2aWU4kkwUZbpOLJ6nuPqOostEmd4KWOC/D3ZdEv0DPy3A3FGz2ZCkDJkTuuW4ILGFMFkRUG4qEEnhIsqIuUQQgWFzyOlEMIFlY/6ICZU0JAoK6MMecnW4AxNEmRBKkFjwUQMZoOI1WIIV8KQczKO6jG+FqKNtEEs45jGFMFoSYVKWcSqEezKbrx8+wLrez+w7dmC07uNHdEFl+8nfql7iJ7qPJZxJgSHPz0mGCGnRmVEKjp8cS8+u1bxdecLljeXsPl7A4sfX8PpIWHBxTe9Ktj/6bHmMCyZZThWMoNO4kpOgZc2iFSjOIx5uNCo5HFB3hzO5RQ6vH3ZaboUlmX0GjQcVUKIFBU+Dtd1urgUccBa3wWNXZm1L9ZpT6jBKrQLLU5DV54cR5Bh91TeYOkJPaS/APcsPep5qv+YkKa0U3y8GYaxx3Rs80zrL1W5GIz1y+BDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"box\" title=\"\" src=\"/static/2a4ed3a1c967bb8474d5ef04b59bb091/6af66/box.png\" srcset=\"/static/2a4ed3a1c967bb8474d5ef04b59bb091/69538/box.png 160w,\n/static/2a4ed3a1c967bb8474d5ef04b59bb091/72799/box.png 320w,\n/static/2a4ed3a1c967bb8474d5ef04b59bb091/6af66/box.png 640w,\n/static/2a4ed3a1c967bb8474d5ef04b59bb091/27b7a/box.png 804w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>`x` 값이 있으면 `fn(x)`를 실행하고, 없으면 그대로 `x`를 반환하는 박스</small>\n  <br>\n  <br>\n</center>\n<p>즉, <code class=\"language-text\">x</code>라는 값을 바로 사용하는 것이 아니라 <code class=\"language-text\">safety</code> 함수에 <code class=\"language-text\">x</code>라는 값을 넣어서 사용하고 있으므로 <code class=\"language-text\">safety</code> 함수를 일종의 박스라고 생각하자는 것이 저 설명의 취지이다.</p>\n<p>사실 펑터의 개념적인 내용은 이게 전부라고 할 수 있고, 이후 펑터를 구현하는 방법만 익혀도 펑터를 사용함에 있어서는 아무런 지장이 없다. 그러나 이번 포스팅의 목적은 펑터가 무엇인지 조금 더 깊숙하게 조져보는 것이므로 필자는 조금 더 근본적인 펑터의 개념에 대해서 이야기해볼까한다.</p>\n<h3 id=\"카테고리category\" style=\"position:relative;\">카테고리(Category)<a href=\"#%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACcategory\" aria-label=\"카테고리category permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>펑터(Functor)는 수학의 카테고리 이론(Category Theory)에 등장하는 개념이며, 동일한 구조를 가지고 있는 카테고리들의 관계를 정의할 수 있는 구조체라고 정의된다.</p>\n<p>그렇기 때문에 펑터가 본질적으로 무엇인지, 왜 <code class=\"language-text\">Something&lt;type></code>이라는 것을 통해 함수를 안전하게 합성하기위해 펑터가 필요하다는 것인지 알기 위해서는 카테고리라는 개념에 대해 알고 있어야 한다.</p>\n<p>사실 수학에서 이야기하는 카테고리라는 개념은 우리가 일상 생활 속에서 사용하는 카테고리의 의미와 크게 다르지 않다. 뭐 비슷한 것들을 묶어놓은 그런 개념이랄까…?</p>\n<p>이렇게 마음을 가볍게 먹은 후 카테고리 이론을 위키피디아에 검색해보면 아래와 같은 검색 결과를 만날 수 있게 된다.</p>\n<blockquote>\n<p>범주 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal {C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span></span>는 다음과 같은 데이터로 구성된다.</p>\n<ul>\n<li>대상(對象, 영어: object)들의 모임 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>o</mi><mi>b</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ob(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>. 이 모임의 원소를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 “대상”이라고 한다.</li>\n<li>임의의 두 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>∈</mo><mi>o</mi><mi>b</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">a,b \\in ob(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>에 대하여, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>를 정의역으로, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 공역으로 하는 사상(寫像, 영어: morphism)들의 모임 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"></mspace><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"></mspace><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f\\colon a\\to b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>로 쓰고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>로 가는 사상’이라고 한다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 사상의 모임을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\hom(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>로 나타낸다.</li>\n<li>임의의 세 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi><mo>∈</mo><mi>o</mi><mi>b</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">a,b,c\\in ob(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>에 대하여, 이항 연산 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\hom(a,b)\\times \\hom(b,c)\\to \\hom(a,c)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span></span></span></span></span>. 이를 사상의 합성(合成, 영어: composition)이라고 한다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"></mspace><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"></mspace><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f\\colon a\\to b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mspace></mspace><mspace width=\"0.1111em\"></mspace><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"></mspace><mi>b</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">g\\colon b\\to c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></span>의 합성은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">gf</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> 등으로 나타낸다.<br /></li>\n</ul>\n<p>…</p>\n<p><strong>위키피디아</strong> <em><a href=\"https://ko.wikipedia.org/wiki/%EB%B2%94%EC%A3%BC_(%EC%88%98%ED%95%99)\" target=\"_blank\" rel=\"nofollow\">범주(수학)</a></em></p>\n</blockquote>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 420px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7d059800d070c80898d9648585a46696/65f94/what.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAIB/9oADAMBAAIQAxAAAAHSEoDQlKv/xAAbEAAABwEAAAAAAAAAAAAAAAAAAQIDEiEyEf/aAAgBAQABBQKfQ5IJXTWnMpOv/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAEDAQE/AVxsv//EABYRAAMAAAAAAAAAAAAAAAAAABARIf/aAAgBAgEBPwFQf//EABcQAAMBAAAAAAAAAAAAAAAAAAABEiD/2gAIAQEABj8CFGf/xAAZEAEBAAMBAAAAAAAAAAAAAAABABEhMUH/2gAIAQEAAT8hEsEwL10kSvYa7xDYO+ST/9oADAMBAAIAAwAAABBLD//EABYRAQEBAAAAAAAAAAAAAAAAAAARMf/aAAgBAwEBPxDAS//EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAgEBPxAJgn//xAAbEAEAAwEBAQEAAAAAAAAAAAABABEhMWFBUf/aAAgBAQABPxAiOLp5M9dWd87GZ42v2Xs2A1X2AUBRU7TBGsJ//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"what\" title=\"\" src=\"/static/7d059800d070c80898d9648585a46696/65f94/what.jpg\" srcset=\"/static/7d059800d070c80898d9648585a46696/0913d/what.jpg 160w,\n/static/7d059800d070c80898d9648585a46696/cb69c/what.jpg 320w,\n/static/7d059800d070c80898d9648585a46696/65f94/what.jpg 420w\" sizes=\"(max-width: 420px) 100vw, 420px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>읭...?</small>\n</center>\n<p>사실 카테고리 이론의 개괄적인 내용은 누구나 다 간단하게 이해할 수 있는 수준의 내용이다. 단지 추상적인 학문인 수학의 특성 상 일상적인 언어로 풀어서 설명하면 너무 길어지고 복잡해지니 간단하게 축약할 수 있는 단어와 기호들로 표현한 것 뿐이다. <small>(사실 이게 수포자가 생기는 원인 중 하나)</small></p>\n<p>일단 위에서 이야기 했듯이 수학에서 이야기하는 카테고리는 쇼핑몰 사이트에 있는 그 카테고리가 맞다. 다만 수학의 카테고리는 조금 더 추상적인 개념이기 때문에 물건으로 구성되는 카테고리일수도 있고 자연수로 구성된 카테고리일수도 있으며, 때로는 함수로 구성된 카테고리가 될 수도 있다는 차이점이 있다.</p>\n<p>위의 수학적 정의에서 카테고리는 “대상(Object)“과 “사상(Morphism)“이라는 것으로 구성된다고 이야기하고 있다.</p>\n<p>대상이라는 것은 그냥 카테고리 안에 있는 하나의 객체이다. 만약 패션 쇼핑몰의 상품 카테고리라면 대상은 셔츠, 맨투맨, 아우터, 코트가 될 것이고, 자연수로 이루어진 카테고리라면 1, 2, 3과 같은 수가 될 것이다. 여기까지는 우리가 일상적으로 사용하는 카테고리라는 단어와 비슷한 느낌이기 때문에 이해가 그리 어렵지 않다.</p>\n<p>그러나 수학에서의 카테고리는 대상 외에도 사상이라는 한 가지 데이터를 더 가지고 있다.</p>\n<p>위의 수학적 정의를 다시 보면 사상은 임의의 두 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>∈</mo><mi>o</mi><mi>b</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">a,b \\in ob(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>에 대하여, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>를 정의역으로, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 공역으로 하는 무언가라고 한다. 사실 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo>∈</mo><mi>o</mi><mi>b</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">a,b \\in ob(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>라는 말은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>라는 대상이 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>안에 있다는 것을 의미하는 것이니 그냥 넘어가도록 하고, 우리가 집중해야할 단어는 “정의역”과 “공역”이다.</p>\n<p>정의역과 공역이라는 단어를 듣고 가장 먼저 생각나는 단어가 무엇일까? 바로 “함수”이다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>를 정의역으로, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 공역으로 한다는 이야기는, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>라는 대상에 어떤 사상(함수)를 적용하면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>가 된다는 것을 이야기하고 있는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> 대상<span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">사상add1</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 대상 A에게 add1이라는 사상을 적용하면...</span>\n<span class=\"token function\">사상add1</span><span class=\"token punctuation\">(</span>대상<span class=\"token constant\">A</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">2</span> <span class=\"token comment\">// 대상 B가 된다</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>즉, 사상이라는 것은 대상과 대상 간의 관계를 나타낼 수 있는 일종의 함수라고 생각하면 된다. 그래서 수학적 표현으로는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f: a \\to b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>라고 표현할 수 있는 것이고 프로그래밍적으로는 그냥 람다 함수로 <code class=\"language-text\">(a) => b</code>이라고 표현할 수 있는 것이다. <small>(대상의 종류에 따라 사상이 함수가 아닌 경우도 있지만, 거기까진 생각하지 말자)</small></p>\n<p>여기까지 이해했다면 보다 쉬운 설명을 위해 간단한 카테고리를 하나 가져와서 가지고 놀아보도록 하겠다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d24e3d04ef5aa42d4f6de9c7fef7744b/7a18f/category.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACIklEQVR42pVTPW/TUBS1U7eQSgGqColOYciAkFCmiIWqEks3tszZspcPic1kgFIKPwCpCwMDIBVRpQLKYNQG7KQOCUogAdqCSh0Fx7Hz4aSQ2r3cW7nIFNo0Rzp6912/d+557z4zkm4rqRq0F9aqzbn8uhkvKOZiqV3LtAGkqnWNQXh9vkvDIyNnKF5Y0/h3JsBS+Wf9We6bGf+4YdJeSYdO0oAiU7DtzRUAeKs24MlyEZ5/KsGyUd/SMJeu1ydJxO/3nz4bCp3CkJ3P52dU/JbvWNbT7Bd4mMjCq1VlexVzRYAyI1bgulixb2Y2IbZUak0l1K3bcgN4SYO7og4XSBDXeogUJ1QYFTWYRjcx5K3XSvNOpgUxSbMnk1W4zPwHfa6Y3Ye76Ef6/tqNlftc9ITDYW8gEDhJc57nPXurOW531kYikaPBYPAExqwgCBzlmX0wiDzGdMe/Dl0gN0eckSoNO8LdBKkw5/DPPRGGkOPUVOR5ZMhZPHCAIIkcR44iz+39yLoqcY5LznHq6XJk1u2wG7yO+57v8CD4djfy2F0BYKej4YkJb3BsjLrsuS/L/YIAXC+iQ07T3BhwvQa2J4vRaJSON/hypXIxWYPpdAtuCN/Ne49ThRnZBF7U7SnRgCuHFqTHS2M8nX7QwMmHZsualXPwSHwPYknd3sDcV/qXDwu6NxrfVDpXkzr8kqq28uKz+mMut64uKu2yqFlGyoDsb0n0PW01RzOAAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"category\" title=\"\" src=\"/static/d24e3d04ef5aa42d4f6de9c7fef7744b/6af66/category.png\" srcset=\"/static/d24e3d04ef5aa42d4f6de9c7fef7744b/69538/category.png 160w,\n/static/d24e3d04ef5aa42d4f6de9c7fef7744b/72799/category.png 320w,\n/static/d24e3d04ef5aa42d4f6de9c7fef7744b/6af66/category.png 640w,\n/static/d24e3d04ef5aa42d4f6de9c7fef7744b/d9199/category.png 960w,\n/static/d24e3d04ef5aa42d4f6de9c7fef7744b/21b4d/category.png 1280w,\n/static/d24e3d04ef5aa42d4f6de9c7fef7744b/7a18f/category.png 1284w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <br>\n</center>\n<p>대충 이런 구조를 가진 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal {C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span></span></span></span>가 있다고 생각해보자. 이 카테고리에서 대상은 자전거, 자동차, 비행기이고 사상은 객체들 사이에 있는 <code class=\"language-text\">빠름</code>이라는 화살표이다.</p>\n<p>즉, 이 카테고리에서 자전거에 <code class=\"language-text\">빠름</code>이라는 사상을 적용하면 자동차가 되고, 자동차에 다시 <code class=\"language-text\">빠름</code>라는 사상을 적용하면 비행기가 된다는 뜻이다. 사상으로 객체들 간의 관계를 표현할 수 있다는 말은 이런 의미이다. 자전거가 빨라지면 자동차가 되고, 자동차가 빨라지면 비행기가 되는 것이니 말이다.</p>\n<p>그리고 사상을 적용한다는 것은 함수를 적용한다는 말과 같으므로 간단한 코드로 이 카테고리의 구조를 표현해볼 수도 있겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> 카테고리 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'자전거'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'자동차'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'비행기'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">빠름</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">카테고리<span class=\"token punctuation\">,</span> 대상</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> index <span class=\"token operator\">=</span> 카테고리<span class=\"token punctuation\">.</span><span class=\"token function\">findIndex</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> v <span class=\"token operator\">===</span> 대상<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> 카테고리<span class=\"token punctuation\">[</span>index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">빠름</span><span class=\"token punctuation\">(</span>카테고리<span class=\"token punctuation\">,</span> <span class=\"token string\">'자전거'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">빠름</span><span class=\"token punctuation\">(</span>카테고리<span class=\"token punctuation\">,</span> <span class=\"token string\">'자동차'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'자동차'</span>\n<span class=\"token string\">'비행기'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그리고 자전거에서 비행기로 바로 그어진 빠름 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∘</mo></mrow><annotation encoding=\"application/x-tex\">\\circ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord\">∘</span></span></span></span></span> 빠름 사상은 빠름 사상 두 개를 합성한 것을 의미하니까, 코드로는 함수 두 개를 합성한 형태인 <code class=\"language-text\">빠름(빠름(자전거)) === '비행기'</code>로 표현할 수 있다.</p>\n<p>결국 사상의 합성이라는 것을 프로그래밍으로 표현하면 그냥 함수를 합성하는 것 그 이상도 이하도 아니다. 이 간단한 걸 수학적인 정의로 이야기하면 이렇게 복잡해보이는 이야기가 되는 것이다.</p>\n<blockquote>\n<p>임의의 세 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi><mo>∈</mo><mi>o</mi><mi>b</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">a,b,c\\in ob(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">b</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>에 대하여, 이항 연산 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>c</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\hom(a,b)\\times \\hom(b,c)\\to \\hom(a,c)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">hom</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span></span></span></span></span>. 이를 사상의 합성(合成, 영어: composition)이라고 한다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"></mspace><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"></mspace><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f\\colon a\\to b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mspace></mspace><mspace width=\"0.1111em\"></mspace><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"></mspace><mi>b</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">g\\colon b\\to c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></span>의 합성은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">gf</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> 등으로 나타낸다.</p>\n</blockquote>\n<p>이 정의에서 이야기하는 임의의 세 대상은 각각 위 카테고리의 자전거, 자동차, 비행기라고 생각하면 된다. 그리고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">hom(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>라는 말에서 나오는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>o</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">hom</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span></span></span></span></span>이라는 녀석은 여러 개의 사상을 가지고 있는, 사상의 집합을 의미한다.</p>\n<p>이 정의에서 사상이 하나가 아닌 여러 개라고 이야기하는 이유는 간단하다. 위의 카테고리만 보더라도 자전거와 자동차 간의 관계가 단지 <code class=\"language-text\">빠름</code>이라는 것만 있지는 않을 것이니 말이다.</p>\n<blockquote>\n<ol>\n<li>자전거 -<strong>빠름</strong>-> 자동차</li>\n<li>자전거 -<strong>비쌈</strong>-> 자동차</li>\n<li>자전거 -<strong>크기가 큼</strong>-> 자동차</li>\n<li>자전거 -<strong>엔진이 달림</strong>-> 자동차</li>\n</ol>\n</blockquote>\n<p>뭐 이런 식으로 어떤 대상과 대상 사이에는 여러 개의 사상이 존재할 수 있기 때문에, 이 사상들의 집합을 퉁쳐서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>o</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">hom</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span></span></span></span></span>라고 표현한 것이다.</p>\n<p>뭐 이딴 것까지 하나하나 다 신경쓰고 있냐고 할 수도 있지만, 수학은 분명히 정답이 존재해야하고, 절대 예외를 허용하지 않는 논리적인 학문이기 때문에 이렇게 모든 케이스를 전부 고려한 정의를 만들어줘야한다.</p>\n<p>그리고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"></mspace><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"></mspace><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f\\colon a\\to b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> 라는 표현은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>o</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">hom</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span></span></span></span></span>에 있는 여러 개의 사상 중에서, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span> 대상과 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> 대상에 단 하나의 사상만 적용한 경우를 말한다. 저 사상들 중 무슨 사상을 적용할지는 모르겠는데, 어쨌든 적용할 때는 한번에 하나만 적용해야하기 때문이다. <small>(여러 개를 동시에 적용할거야!는 양자 컴퓨터가 아니면 불가능하다)</small></p>\n<p>그리고 마지막으로 우리가 자전거에다 빠름 사상을 두 번 적용한 것과 같이 사상을 합성한 것을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f: a\\to b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span> 사상과 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>:</mo><mi>b</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">g: b\\to c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></span> 사상이 합성된 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>, 사상의 합성이라고 표현하는 것이다.</p>\n<p>즉, 자전거라는 대상에 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>를 적용하고, 다시 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>를 적용하면 비행기라는 대상이 된다는 것을 이야기 하는 것이며, 이것도 그냥 코드로 표현하면 그냥 <code class=\"language-text\">g(f(자전거)) === '비행기'</code>라고 할 수 있겠다.</p>\n<p>이렇듯이 카테고리 이론은 굉장히 추상적인 이론이라 프로그램 안에서 벌어지는 일을 전부 저런 카테고리 모델로 표현해낼 수 있으며, 마찬가지로 우리가 함수형 프로그래밍을 하면서 어떤 값에 함수를 적용하고 합성하는 과정 또한 일종의 카테고리 모형으로 표현할 수 있는 것이다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/31c57f106ec9d6857471d2fcdbfe5da7/bf286/category-example.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 80.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC6ElEQVR42oVTyXLTQBAVVz4A+AjgxBdw5cid/+KYKi4UBRRQIZA9xIkXyfISEztRkC05lu1402ixrMQzj55xEiBUQFWv2prpfu73uqUBuKPd/lzd3SPc1f7zXHMhqj1AWHyM0Hj0F3D40HNWn9x6ryDvsvcXZEx/gcBIMDWBuCgwKwOzCpCU5DtEVMRsmBXpJE9nZXWm7lLKmZUXNbI20CMExecaTw9OcV5Bz3d4dTARRccRedsWZa8nTpgv+u6u0LeWhFV6Kya9vKiPx6LidUWhaYui64iD4USc+c058B3ivFbReGQmYDk0gxFWTxMsbZt4+WUfH+tdFHyBSd9A0s8gPdvDaWsPmeEc76qOynm1d4CN7gUc1udITPCo1CLJxox8QMoqiIMGkugI40GVftcxDQ5JMskh2RIiLiFmhypnMjrANGyompSVubIgMBzpYUrapQcE8iko4HyUQdjZAkL98txQEEwnFOi8gKi7DT7JLmqYToRVujNcjSaUIiF2+ndMS4tI7+m4gGSwT8WmTLwmVQiLRLgLThFTGkxkcvCaHKCrsc526h2vYNDcwMjZoLiGM3sdp0crcOvLSIZZRQp21eWCMCTCkbMJz/oq6zjr7CDwvrnasLWRysIzew0dIrHK79Guf0ar9gljdxMy8cInmcoWIvytw97JqsodtNZ51/qCdmOZJMdmKvUrubL95AoLG+ZEJknFJRmXxNRx2M1gHlLNjGpjGgpXA3Q17hfSX4bfhKGKabGVRNmZYHk1iJCGMh+Rx36O7Chw+TFwprtybRKZ+IfpN0GrE9MuRv19BOwI8dSG3TLAmIUw+oHEr6i1EYFOexiZMXUzV6O/BdynGOrctnb49oDzN5U2f11y+FKmxj+cBNwJhxeIdFpss6mRfxZQpy5KQnl4K0q4mNbQjsZo9NqwBh3U2hbq/Q782OFAg77val5KfkZd2BQ96rQj47+R8xAbC0xNjzojxlyXrDmmL+7pTz/gOdXQ1uU9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"category example\" title=\"\" src=\"/static/31c57f106ec9d6857471d2fcdbfe5da7/6af66/category-example.png\" srcset=\"/static/31c57f106ec9d6857471d2fcdbfe5da7/69538/category-example.png 160w,\n/static/31c57f106ec9d6857471d2fcdbfe5da7/72799/category-example.png 320w,\n/static/31c57f106ec9d6857471d2fcdbfe5da7/6af66/category-example.png 640w,\n/static/31c57f106ec9d6857471d2fcdbfe5da7/d9199/category-example.png 960w,\n/static/31c57f106ec9d6857471d2fcdbfe5da7/21b4d/category-example.png 1280w,\n/static/31c57f106ec9d6857471d2fcdbfe5da7/bf286/category-example.png 1688w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>프로그램 내에서 벌어지는 모든 일은 이렇게 카테고리로 표현할 수 있다</small>\n  <br>\n  <br>\n</center>\n<p>필자는 개인적으로 여기까지가 펑터를 조금 더 쉽게 이해하기위한 카테고리 이론의 전부라고 생각한다. 프로그램에서 발생하는 일들을 일종의 카테고리로 정의할 수 있다는 사실까지 받아들이고 나면 펑터를 이해하는 것이 간단해지기 때문이다.</p>\n<h3 id=\"펑터functor\" style=\"position:relative;\">펑터(Functor)<a href=\"#%ED%8E%91%ED%84%B0functor\" aria-label=\"펑터functor permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>자, 이제 방금 만들었던 간단한 카테고리를 이제 조금 추상적인 모델로 바꿔보도록 하자. 비행기, 자동차, 자전거와 같은 이름은 변수 <code class=\"language-text\">x, y, z</code>로 변경하고 사상 <code class=\"language-text\">빠름</code> 역시 변수인 <code class=\"language-text\">f</code>와 <code class=\"language-text\">g</code>로 변경하겠다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8580182cd5537b8b1808d4e97c3c27a4/93582/absolute-category.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 89.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACnElEQVR42o1Uy27aQBSlm1aq1G1XXfYP8g39gHxe/6GrqE0iRS0USDBgxzRN1AQ15IFxeNmeGRtjDJ7TOxPaQBKsIh3NZebccx8z1wUALxQK+b93hDd5hDUdZUjZfvUc6Ozl9vaHtzs7H18rO4e3FGPWe/D6J3DjBLxhg9da9H8FzRYmx5bkTVvba2eKa9j3vqRBWgVMrBLgIkm72WzexXzRg1oTQppeUeBfCAZVpLFN9jnS+bU+19xsyU2dBXAH0vpWQGxOukFXljxkhwHkXofL0iCVZR+yPppI1itLt70nmVOUt+f78qgvZIV4pcFc7nYCeUi8Ivm63AFpsQJEPfHEFVr+FGc8hnHbR8vj+MmmaAc+FkETUpiQ3EQyNnDhj+ksQWvENVf52H4sWXQDhHVeoL7MEJqAaNBGE3O/htAtapt6SvvmA0KLVtoPG5gHBsJBecmrS+qz4oiloPXgFFmI+hWE/bK2wc110aXw3K9DuOX7ILxJgvYGQYVpC+FdBTPP0A50w88KhhRYC7FNgrQugjoCpwjW+w63vY/ssdg/XgP+bRHT0ZHae1qyziI6RkSZ3Zx9xvj6K6JBBZyEpXhatuJ3z3cx7Bwov5weKlD6UvWPAkyHR/e9iqynPaTgiPNKXomuM15mrQRjEla23leCVHJID/7/LuWRuDpnTgkp9ReRqZ9KMqpi8HtfTQcyZqyULMwkT/AvMnp//csDXAx7uBARTsceTOcObSFw6gspoiv1lnlBTuxYp5yDTPUotCRzq7LiMlnlNG6Dmfxy6ctDRra/OnrpKaXQUReRIW5hM6hHyQ+I+AbepAd/4sCLunodh06mPw6zk4b6fG3RONWoVx5lM6TJGG1CxhojMIPsNQwhDI/KraXM2PoDpJ3XiwGEc1UAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"absolute category\" title=\"\" src=\"/static/8580182cd5537b8b1808d4e97c3c27a4/6af66/absolute-category.png\" srcset=\"/static/8580182cd5537b8b1808d4e97c3c27a4/69538/absolute-category.png 160w,\n/static/8580182cd5537b8b1808d4e97c3c27a4/72799/absolute-category.png 320w,\n/static/8580182cd5537b8b1808d4e97c3c27a4/6af66/absolute-category.png 640w,\n/static/8580182cd5537b8b1808d4e97c3c27a4/d9199/absolute-category.png 960w,\n/static/8580182cd5537b8b1808d4e97c3c27a4/21b4d/absolute-category.png 1280w,\n/static/8580182cd5537b8b1808d4e97c3c27a4/93582/absolute-category.png 1524w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <br>\n</center>\n<p>아까 우리가 만든 카테고리를 이렇게 추상적인 구조로 변경하고나니, 이런 구조를 가진 카테고리는 왠지 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span> 말고도 더 있을 것 같다는 생각이 든다.</p>\n<p>그도 그럴것이 저런 구조의 대상과 사상을 가지는 카테고리는 굉장히 흔하고, 솔직히 어디다가 가져다 붙혀도 왠만한 정의에는 껴맞출 수 있는 보편적인 카테고리이기 때문이다.</p>\n<p>그렇다면 대상에 사상을 적용하여 다른 대상으로 만들 수 있듯이, 카테고리에도 사상을 적용하여 다른 카테고리로 만들 수 있지 않을까?</p>\n<p>이때 등장하는 것이 바로 “펑터(Functor)“이다. 즉, 펑터는 카테고리를 다른 카테고리로 변경할 수 있는 사상(함수)인 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/091da7127032da1c6ee53eb819d6af9d/b8f37/functor-category.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 38.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9UlEQVR42jWSS2/TQBSFg5DYUMESqWVHECAhWPDT+BEIwQ9g2RWLSJUqgZAKEn0lcbDdkAbapk3TPJymjp/zsF0/4jmMnWDp6s7VfHPmnJErCD+vl+XUNur1zScIvy/nsLaBeW2tIj+gcqfscka49RhQHu19ef/047u3bxBurwPbyzOo3avc+KPM8I3QJRdRah+G1P8bTYkRTP1JztmZDvHtQSnm1R5yetoe24N84o1C1+6EZPyDu6QfDe0BnzMDCT/+VJkwGz1nDptPIdw6fL+HvmeLK+qCx1cB0Hi+dHlUDeJh2rOucWJOBWMXSK19mNRA1xjmZkKRZX2lAq5i4TWQuU0gaANcR+o1hKAtOetscrrzshAc/vn6AkxNCj616yKnv1a8hsRr5ojlmmlSkOkIzDrY7AALokqgjVtbEbKKA/y8vfVa6t1VDjZf5URNPWMPZLovIqsBQfWSj51WzmaHyLxWqxTMqSY3NcRSpOip2xSCtIobOaj6rIxMjqqSTQoeVBPF5bGjlIkST8mRdFYOo98o67ZT2ne9Hs48V/SpD56MAsT/37BfRdxNSy5si6IXsWfEgD4e5dcxx2JxWURWiXRh50xzQFQn8LuO6Y8skwx5SE9+4mbn/vKX2V2TEXeXrjULK97zzx3DvrQsfxBl7PjDP7mvCVMvxyTZAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"functor category\" title=\"\" src=\"/static/091da7127032da1c6ee53eb819d6af9d/6af66/functor-category.png\" srcset=\"/static/091da7127032da1c6ee53eb819d6af9d/69538/functor-category.png 160w,\n/static/091da7127032da1c6ee53eb819d6af9d/72799/functor-category.png 320w,\n/static/091da7127032da1c6ee53eb819d6af9d/6af66/functor-category.png 640w,\n/static/091da7127032da1c6ee53eb819d6af9d/d9199/functor-category.png 960w,\n/static/091da7127032da1c6ee53eb819d6af9d/21b4d/functor-category.png 1280w,\n/static/091da7127032da1c6ee53eb819d6af9d/b8f37/functor-category.png 3524w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>가 아무리 복잡하게 구성되어있다고 해도 우리는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>와 같이 카테고리에 펑터를 덮어 씌우기만 하면 간단하게 펑터를 사용할 수 있다. 그러면 펑터가 적용된 카테고리 내부에 있는 모든 대상과 사상들 또한 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>라는 함수로 감싸져 있는 형태로 변경된다.</p>\n<p>여기서 가장 중요한 것은 펑터로 감싸도 카테고리 자체의 구조는 절대 변하지 않는다는 점이다. 위 그림에서도 대상과 사상들에게 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>라는 함수가 적용되었을 뿐 화살표 자체의 모양은 변하지 않은 것을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> 대상x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> 대상y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">사상f</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">사상f</span><span class=\"token punctuation\">(</span>대상x<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> 대상y<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> 대상x <span class=\"token operator\">=</span> <span class=\"token function\">펑터</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> 대상y <span class=\"token operator\">=</span> <span class=\"token function\">펑터</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> 사상f <span class=\"token operator\">=</span> <span class=\"token function\">펑터</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">사상f</span><span class=\"token punctuation\">(</span>대상x<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> 대상y<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>즉, 펑터를 사용하더라도 카테고리가 가지고 있는 규칙 자체는 절대 변경되지 않는다. 쉽게 말해 안전하게 대상이나 사상을 감싸기만 할 뿐, 그 외에 아무런 사이드 이펙트를 일으키지 않는다는 것이다.</p>\n<p>아까 전에 프로그래밍에서 발생하는 모든 일도 일종의 카테고리로 표현할 수 있다고 했던 것을 기억하는가?</p>\n<p>아무리 복잡한 카테고리라고 해도, 단순히 펑터로 감싸기만 하면 기존 카테고리의 구조를 전혀 건드리지 않으면서 다른 카테고리로 변경할 수 있기 때문에 우리가 찾고있던 “값을 감싸서 안전하게 값을 사용하고 싶다”라는 니즈에 부합하는 개념인 것이다.</p>\n<h2 id=\"펑터를-직접-만들어보자\" style=\"position:relative;\">펑터를 직접 만들어보자!<a href=\"#%ED%8E%91%ED%84%B0%EB%A5%BC-%EC%A7%81%EC%A0%91-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90\" aria-label=\"펑터를 직접 만들어보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>펑터라는 것은 그렇게 거창한 개념이 아니다. 간단하게 말해서 카테고리를 다른 카테고리로 바꿔주는 행위를 할 수 있으면 펑터인 것이다.</p>\n<p>이때 펑터가 카테고리를 변경하는 행위를 “매핑(mapping)“이라고 하며, 조금 더 자세히 말해 카테고리에 함수를 적용하여 다른 카테고리로 변경하는 행위라고 할 수도 있다.</p>\n<p>이렇게 추상적인 개념을 가진 펑터이기에, 누구는 펑터를 이래서 쓴다, 누구는 펑터를 저래서 쓴다와 같이 이야기가 전부 다른 것이다. 사실 펑터 자체는 그저 매핑이라는 행위를 할 수 있는 무언가에 불과하기 때문에 펑터를 어떤 방식으로 응용하냐에 따라 그 사용 방법 또한 무궁무진하다.</p>\n<p>사실 펑터라는 개념 자체는 특정 메소드를 통해 펑터 내부의 값을 변경할 수 있도록 만들어주기만 하면 되기 때문에 프로그래밍으로 표현하는 것이 그렇게 어렵지는 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Functor<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token generic-function\"><span class=\"token function\">map</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Functor<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<ul>\n<li><code class=\"language-text\">Function&lt;T></code>: 이 펑터는 <code class=\"language-text\">T</code> 타입의 값을 가지고 있다.</li>\n<li><code class=\"language-text\">map&lt;U></code>: 이 펑터의 사상을 적용하면 <code class=\"language-text\">U</code> 타입의 값을 가진 새로운 펑터를 얻는다.</li>\n<li><code class=\"language-text\">f: (x: T) => U</code>: 이 펑터의 사상이 작동하는 방식은 <code class=\"language-text\">T</code> 타입의 값을 입력으로 받아 <code class=\"language-text\">U</code> 타입의 값을 출력하는 것이다.</li>\n</ul>\n</blockquote>\n<p><code class=\"language-text\">map</code> 메소드는 인자로 받은 <code class=\"language-text\">(x: T) => U</code> 꼴의 함수를 펑터 내부의 값에 적용하고, 변경된 값을 감싸고 있는 새로운 펑터를 반환한다.</p>\n<p>결국 <code class=\"language-text\">map</code> 메소드에 인자로 넘기는 이 함수가 실질적으로 펑터 내부의 값을 변경하는 역할을 하는 것이며, 값을 실질적으로 변경하는 역할을 하는 이 함수를 트랜스폼(Transform) 함수라고 부른다.</p>\n<p>매핑을 하고 난 뒤 변경된 값 자체가 아니라 변경된 값을 감싸고 있는 펑터가 반환되는 이유는 펑터라는 것이 본질적으로 어떤 카테고리를 다른 카테고리로 변경하는 구조체일 뿐, 카테고리를 부숴버리고 내부에 있는 대상을 꺼내는 역할을 하는 게 아니기 때문이다.</p>\n<p>그리고 펑터는 단지 새로운 카테고리를 표현하는 수단이기 때문에 기존 카테고리의 대상을 변경해서는 안된다. 그렇기 때문에 기존 펑터의 값을 업데이트하는 것이 아니라 변경된 값을 담고 있는 새로운 펑터를 생성해서 반환해야하는 것이다.</p>\n<p>이 개념이 약간 혼란스럽게 느껴진다면 <code class=\"language-text\">Array.prototype.map</code> 메소드를 생각해보자. 잘 생각해보면 배열도 어떠한 박스 안에 값을 담고 있는 일종의 펑터라고 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// Functor&lt;number></span>\n<span class=\"token keyword\">const</span> array<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 트랜스폼 함수: (x: number) => string</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">toString</span> <span class=\"token operator\">=</span> v <span class=\"token operator\">=></span> v<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 매핑!</span>\narray<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>toString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 새로운 펑터 Functor&lt;string></span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'3'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>우리는 트랜스폼 함수인 <code class=\"language-text\">toString</code> 함수를 사용하여 배열이라는 펑터 내부의 값을 변경할 수는 있지만, 배열이라는 박스 자체를 없애버리지는 않는다.</p>\n<p>일반적으로 우리가 자주 사용하는 <code class=\"language-text\">map</code>이라는 메소드가 <code class=\"language-text\">Array</code>에 물려있기 때문에 매핑이라는 행위를 이터레이션과 연결지어 생각하기 쉬운데, 매핑은 그렇게 구체적인 행위가 아니다.</p>\n<p>뭐 <code class=\"language-text\">map</code> 메소드 내부에서 이터레이션을 돌던 북을 치던 브레이크댄스를 추던 최종적으로 <code class=\"language-text\">Functor&lt;T> -> Functor&lt;U></code>라는 변환만 수행할 수 있으면 되는 것이다. 이제 펑터가 어떤 느낌으로 돌아가는 개념인지 살짝 감을 잡을 수 있을 것이다.</p>\n<p>자, 이제 펑터를 직접 구현해볼 시간이다. 펑터라는 게 워낙 추상적인 개념인 만큼 어떻게 응용하냐에 따라 무궁무진한 펑터를 만들 수 있지만, 이미 포스팅이 꽤나 길어졌기 때문에 많은 펑터를 선보이기는 힘들 것 같다. 그리고 펑터를 사용한 구현체들은 다른 분들이 작성해주신 포스팅에도 많으니 궁금하신 분들은 그 쪽을 참고해보도록 하자.</p>\n<p>이 포스팅에서는 가장 간단한 형태의 펑터인 <code class=\"language-text\">Just</code> 펑터와 <code class=\"language-text\">Nothing</code> 펑터를 만들어보고, 이 두 펑터를 조합하여 값의 유무로 인한 사이드 이펙트를 관리할 수 있는 <code class=\"language-text\">Maybe</code> 펑터만 만들어보도록 하겠다.</p>\n<h3 id=\"just\" style=\"position:relative;\">Just<a href=\"#just\" aria-label=\"just permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Just</code> 펑터는 아무런 추가적인 기능없이 값을 그냥 감싸고 있기만 하고 <code class=\"language-text\">map</code> 메소드를 통해서 그 값을 변경할 수 있는 펑터이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Just<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Functor<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token generic-function\"><span class=\"token function\">map</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span> <span class=\"token punctuation\">(</span><span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Just<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">Just</code>는 자신 내부에 값을 가지고 있는 단순한 펑터이다. 이 펑터의 <code class=\"language-text\">map</code> 메소드를 사용한다는 것은 펑터가 가지고 있는 <code class=\"language-text\">T</code> 타입의 값을 <code class=\"language-text\">U</code> 타입의 값으로 변경하고, 이 값을 다시 새로운 <code class=\"language-text\">Just</code> 펑터에 감싸서 반환하는 것을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Just</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> v <span class=\"token operator\">+</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> v<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> v<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Just <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">value</span><span class=\"token operator\">:</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h3 id=\"nothing\" style=\"position:relative;\">Nothing<a href=\"#nothing\" aria-label=\"nothing permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Nothing</code> 펑터는 이름 그대로 내부에 어떠한 값도 가지고 있지 않은 펑터를 의미한다. 그리고 펑터 내부에 값이 없으니 트랜스폼 함수를 적용할 수도 없으므로 이 펑터의 <code class=\"language-text\">map</code> 메소드는 아무 행동도 하지 않고 그대로 <code class=\"language-text\">Nothing</code> 펑터를 반환하기만 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Nothing</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Functor<span class=\"token operator\">&lt;</span><span class=\"token keyword\">null</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">map</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Nothing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Nothing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Nothing <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>굳이 이렇게 값의 유무를 표현하는 펑터가 필요한 이유는 무엇일까?</p>\n<p>한번 펑터를 사용하여 함수를 합성하기 시작하면 그 연산 과정에서 필요한 모든 값들 또한 펑터로 감싸져 있어야하기 때문이다. 만약 펑터로 감싸진 값에 그냥 함수를 적용하려고 하면 당연히 에러가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Just</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfoo <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Operator '+' cannot be applied to types 'Just&lt;number>' and 'number'.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그렇기 때문에 한번 펑터를 사용하여 함수를 합성하기 시작했다면 합성이 끝날 때까지 계속 펑터를 사용해야한다. 애초에 펑터를 사용하는 이유는 함수를 합성하는 동안 타입 안정성을 유지하고 사이드 이펙트를 관리하기 위해서인데, 이 과정에서 펑터가 아닌 녀석이 하나라도 끼어들게 되면 합성한 연산 전체의 안정성을 보장할 수 없기 때문이다. <small>(미꾸라지 한 마리가 물을 흐린다)</small></p>\n<p>이렇게 들으면 뭔가 불편하다고 느껴질 수도 있지만 아까 위에서 대표적인 펑터라고 이야기했던 <code class=\"language-text\">Array</code>를 사용하는 경우를 생각해보면 이게 그렇게 특이한 개념이 아니라는 사실을 알 수 있다.</p>\n<p>만약 <code class=\"language-text\">new Array(3)</code>이라는 배열이 있을 때 이 배열이 가지고 있는 값에 2를 더하고 싶다면 어떻게 해야할까? 단, 함수형 프로그래밍의 세계에서는 상태의 변경을 허용하지 않으므로 <code class=\"language-text\">new Array(3)[0] += 2</code>와 같은 개념으로 접근해서는 안된다는 사실을 잊지말자.</p>\n<p>즉, 불변성을 중시하는 함수형 프로그래밍의 세계에서 배열 내부의 값을 변경하고 싶다면, “변경된 값을 가지고 있는 새로운 배열”을 생성할 수 밖에 없다.</p>\n<p>그래서 우리는 불변성을 지키며 배열 내부의 값을 변경하기위해 무조건 <code class=\"language-text\">map</code>이라는 메소드를 사용해야하는 것이다. 이제 펑터의 <code class=\"language-text\">map</code> 메소드가 왜 값을 변경한 후 새로운 펑터를 생성해서 반환하는지 조금은 이해가 갈 거라고 생각한다.</p>\n<h3 id=\"maybe\" style=\"position:relative;\">Maybe<a href=\"#maybe\" aria-label=\"maybe permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>자, 여기까지 이해했다면 조금 더 복잡한 펑터를 만들어보도록 하자. <code class=\"language-text\">Maybe</code>라는 펑터의 <code class=\"language-text\">map</code> 메소드는 펑터 내부에 값이 있다면 인자로 받은 함수를 값에 적용하고, 값이 없다면 값이 없음을 의미하는 펑터인 <code class=\"language-text\">Nothing</code> 펑터를 반환하는 펑터이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Functor<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  value<span class=\"token operator\">:</span> Just<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> Nothing<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Just<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Nothing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token generic-function\"><span class=\"token function\">map</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span> <span class=\"token punctuation\">(</span><span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token operator\">|</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Just</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token generic-function\"><span class=\"token function\">map</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Nothing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getFirstLetter</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">s</span> <span class=\"token operator\">=></span> s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getStringLength</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">s</span> <span class=\"token operator\">=></span> s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Maybe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hi'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>getFirstLetter<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>getStringLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Maybe</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>getFirstLetter<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>getStringLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Just { value: 1 }</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Nothing {}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">Maybe</code> 펑터를 사용하면 우리는 중간에 <code class=\"language-text\">null</code>이나 <code class=\"language-text\">undefined</code>가 반환되어 함수의 합성이 깨져버리는 걱정 없이 안심하고 함수를 합성할 수 있다.</p>\n<p>물론 최종적으로 연산 결과가 <code class=\"language-text\">Just</code>인지 <code class=\"language-text\">Nothing</code>인지 구분하려면 <code class=\"language-text\">if</code> 문을 통해서 조건 검사를 해야하기는 하지만, 적어도 함수를 합성하는 중간중간마다 검사하지는 않는다. 즉, 함수를 합성할 때는 합성에만 집중할 수 있다는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 펑터가 없다면 함수를 함부로 합성할 수 없다</span>\n<span class=\"token keyword\">const</span> firstLetter <span class=\"token operator\">=</span> <span class=\"token function\">getFirstLetter</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>firstLetter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">getStringLength</span><span class=\"token punctuation\">(</span>firstLetter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'함수 합성 실패'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Maybe 펑터를 사용하면 마음놓고 합성이 가능하다</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Maybe</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>getFirstLetter<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>getStringLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Just</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'함수 합성 실패'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 단순히 값을 감싸고, 내부에 있는 값을 변경할 수 있다는 단순한 개념만으로 우리는 함수의 안전한 합성을 할 수 있게 되었다.</p>\n<p>이 포스팅에서는 값의 유무로 인한 사이드 이펙트를 관리할 수 있는 <code class=\"language-text\">Maybe</code> 펑터 만을 예시로 들었지만, 여러 번 이야기 했듯이 펑터는 그냥 값을 감싸고 있는 박스이기 때문에 어떤 로직을 구현하냐에 따라 천차만별로 다른 펑터를 만들어낼 수 있다.</p>\n<p>예를 들면 현재에는 아직 값이 없지만 미래에 값이 결정되는 것을 약속해주는 <code class=\"language-text\">Promise</code> 같은 개념도 일종의 펑터라고 볼 수 있고, 여러 개의 값을 순차적으로 저장할 수 있는 <code class=\"language-text\">Array</code>도 일종의 펑터라고 할 수 있다.</p>\n<p>펑터라는 것은 추상적인 개념일 뿐이지 구체적으로 특정 로직만을 수행하는 구현체가 아니라는 말이다. 말 그대로 코에 붙히면 코걸이고 귀에 붙히면 귀걸이기 때문에 단순히 뭔가로 값을 감싸고 그 값을 변환할 수 있다는 개념만으로도 마음껏 상상의 나래를 펼치며 다양한 펑터 구현체들을 만들어낼 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이 포스팅을 읽는 독자 분들 중 펑터에 대한 설명을 읽으면서 “어? 이거 모나드 아닌가?”라고 하신 분들도 있을 것이라 생각한다.</p>\n<p>정확히 말하면 반은 맞고 반은 틀리다. 모나드도 결국 함수를 안전하게 합성하기 위한 펑터의 한 종류이기 때문이다. 간단하게 말하면 모나드라는 것은 수학적으로 특별한 몇 가지 조건을 만족시키는 두 개의 펑터 사이의 사상이라고 할 수 있다.</p>\n<p>어플리케이티브 펑터나 모나드를 이 포스팅에서 따로 설명하지는 않았지만, 뭐 원리가 어쩌고 저쩌고를 떠나서 그냥 이런 개념들을 추가적으로 사용하는 이유는 그냥 딱 한 가지 밖에 없다.</p>\n<blockquote>\n<p>어 뭐여…? 펑터로도 해결이 안되네…?</p>\n</blockquote>\n<p>함수의 안전한 합성이라는 목표를 이루기 위해 펑터를 사용했지만 사실 프로그래밍을 하다보면 펑터로 해결이 안되는 케이스도 수두룩하기 때문이다. 뭐 펑터로 여러 번 감싸져 있는 값에 매핑해야한다거나 하는 케이스말이다. 이런 경우에는 펑터의 매핑만으로는 함수를 합성할 수 없다.</p>\n<p>결국 어플리케이티브 펑터나 모나드는 펑터로도 해결되지 않는 예외 상황들까지 모두 커버할 수 있도록 더 추상적이고 강력하게 만든 펑터라고 생각하면 된다.</p>\n<p>사실 이번 포스팅에서 모나드의 개념까지 설명을 해보려고 했지만, 이 포스팅에서 펑터를 설명했던 방식으로 모나드를 설명하기 위해서는 개요 수준의 카테고리 이론이 아니라 조금 더 깊숙한 설명이 필요하기 때문에 포기했다. <small>(모나드는 다음 포스팅에서 한 번 조져보겠다)</small></p>\n<p>물론 함수의 합성과 펑터와의 관계를 파악하는 것은 꽤나 추상적인 개념이기 때문에 이해하기에 조금 어렵긴 하다. 그런 이유로 어떤 개발자들은 펑터와 모나드의 사용 방법 정도만 익히고 프로그래밍하기도 하지만, 개인적으로는 이러한 개념들이 왜 사용되는 것인지, 어디서 아이디어를 얻은 것인지 알고 있다면 프로그래밍이 더 재밌어지지 않을까라는 생각이 든다.</p>\n<p>이상으로 어떻게 하면 안전하게 함수를 합성할 수 있을까? 포스팅을 마친다.</p>","fields":{"slug":"20200127-safety-function-composition","path":"/2020/01/27/safety-function-composition/","lang":"ko"},"frontmatter":{"title":"어떻게 하면 안전하게 함수를 합성할 수 있을까?","subTitle":"펑터와 모나드로 함수 합성의 실패를 다루는 법","date":"Jan 27, 2020","categories":["프로그래밍","아키텍처"],"tags":["펑터","모나드","Functor","Monad","함수형 프로그래밍","Functional Programming","합성 함수","Composition","카테고리 이론","범주론","수학"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/fe86b5bd480c2654850ae7a9ec8c4aa2/d803c/thumbnail1.png","srcSet":"/static/fe86b5bd480c2654850ae7a9ec8c4aa2/d803c/thumbnail1.png 320w,\n/static/fe86b5bd480c2654850ae7a9ec8c4aa2/2a1fd/thumbnail1.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/fe86b5bd480c2654850ae7a9ec8c4aa2/fc5c5/thumbnail1.webp 320w,\n/static/fe86b5bd480c2654850ae7a9ec8c4aa2/e9225/thumbnail1.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/fe86b5bd480c2654850ae7a9ec8c4aa2/01fb2/thumbnail1.png","srcSet":"/static/fe86b5bd480c2654850ae7a9ec8c4aa2/01fb2/thumbnail1.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/fe86b5bd480c2654850ae7a9ec8c4aa2/b384d/thumbnail1.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"3e41aa97-cbc8-576b-b589-204ba89ff96d","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EC%99%80-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%80-%EB%AC%B4%EC%8A%A8-%EA%B4%80%EA%B3%84%EC%9D%B8%EA%B0%80%EC%9A%94\">순수 함수와 불변성은 무슨 관계인가요?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\">불변성이란?</a></p>\n<ul>\n<li><a href=\"#%EC%9A%B0%EB%A6%AC%EB%8A%94-%EB%B3%80%EC%88%98%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%9C%EB%8B%A4\">우리는 변수를 통해 메모리에 접근한다</a></li>\n<li><a href=\"#%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C%EA%B3%BC-%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C\">값에 의한 호출과 참조에 의한 호출</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%ED%82%A4%EB%A9%B4-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%9D%B4-%EC%A2%8B%EC%9D%80%EA%B0%80%EC%9A%94\">불변성을 지키면 어떤 점이 좋은가요?</a></p>\n<ul>\n<li><a href=\"#%EB%AC%B4%EB%B6%84%EB%B3%84%ED%95%9C-%EC%83%81%ED%83%9C%EC%9D%98-%EB%B3%80%EA%B2%BD%EC%9D%84-%EB%A7%89%EB%8A%94%EB%8B%A4\">무분별한 상태의 변경을 막는다</a></li>\n<li><a href=\"#%EC%83%81%ED%83%9C%EC%9D%98-%EB%B3%80%EA%B2%BD%EC%9D%84-%EC%B6%94%EC%A0%81%ED%95%98%EA%B8%B0%EA%B0%80-%EC%89%BD%EB%8B%A4\">상태의 변경을 추적하기가 쉽다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%98%84%EC%8B%A4%EC%A0%81%EC%9D%B8-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%98-%EC%83%81%ED%99%A9\">현실적인 불변성의 상황</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 순수 함수에 이어 함수형 프로그래밍에서 중요하게 여기는 개념인 불변성(Immutable)에 대한 이야기를 해보려고 한다. 사실 순수 함수를 설명하다보면 불변성에 대한 이야기가 꼭 한번은 나오게 되는데, 대부분 “상태를 변경하지 않는 것”이라는 짧은 정의로 설명하거나, 혹은 불변성을 해치는 행위들을 예시로 들고 이런 행위들을 금지 행위로 규정하며 설명을 진행하게된다.","html":"<p>이번 포스팅에서는 순수 함수에 이어 함수형 프로그래밍에서 중요하게 여기는 개념인 불변성(Immutable)에 대한 이야기를 해보려고 한다.</p>\n<p>사실 순수 함수를 설명하다보면 불변성에 대한 이야기가 꼭 한번은 나오게 되는데, 대부분 “상태를 변경하지 않는 것”이라는 짧은 정의로 설명하거나, 혹은 불변성을 해치는 행위들을 예시로 들고 이런 행위들을 금지 행위로 규정하며 설명을 진행하게된다.</p>\n<!-- more -->\n<p>그러나 개인적으로 이런 설명 방식은 상태와 메모리에 대한 개념이 확실하게 정립되지 않은 사람에게 별로 와닿지 않는 방식일 수도 있다고 생각한다. 그래서 이번 포스팅에서는 정확히 “불변”이라는 것이 무엇을 의미하는지에 대한 이야기를 해보려고 한다.</p>\n<h2 id=\"순수-함수와-불변성은-무슨-관계인가요\" style=\"position:relative;\">순수 함수와 불변성은 무슨 관계인가요?<a href=\"#%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EC%99%80-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%80-%EB%AC%B4%EC%8A%A8-%EA%B4%80%EA%B3%84%EC%9D%B8%EA%B0%80%EC%9A%94\" aria-label=\"순수 함수와 불변성은 무슨 관계인가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>저번에 작성했던 <a href=\"/2019/12/29/about-pure-functions/\">수학에서 기원한 프로그래밍 패러다임, 순수 함수</a>에서 한 번 이야기 했듯이, 순수 함수는 수학의 함수를 프로그래밍의 세계로 가져온 모델이다.</p>\n<p>프로그래밍의 세계에는 무언가를 저장하고 변경하고 불러올 수 있는 상태라는 개념이 존재하지만, 수학의 세계에는 그런 개념이 없기 때문에 모든 함수는 함수 외부의 무언가에 절대 영향을 받지 않고 독립적으로 존재한다.</p>\n<p>그렇기 때문에 상태라는 개념 자체가 존재하지 않는 수학의 함수를 프로그래밍으로 구현한 모델인 순수 함수 또한 함수 외부의 상태에 영향을 받지 않아야한다는 규칙을 가질 수 밖에 없는 것이다.</p>\n<p>또한 수학의 세계에는 상태라는 개념이 없기에 당연히 상태를 변경한다는 개념도 없을 수 밖에 없고, 우리는 이를 “불변성(Immutable)“이라고 부른다.</p>\n<p>하지만 프로그래밍의 세계에서 상태를 변경하지 않는다는 것은 꽤나 신경을 많이 써줘야 하는 일이다. 그래서 우리는 “변수에 값을 재할당하지 않는다”와 같은 몇 가지 규칙들을 정해놓고 프로그래밍을 하면서 불변성을 유지한다.</p>\n<p>하지만 프로그램에서 변이(Mutation)가 발생하는 근본적인 원인을 파악하고 불변성을 스스로 지켜나간다면, 이러한 규칙들이 커버할 수 없는 변태같은 상황을 마주치더라도 대응할 수 있기 때문에 우리는 불변(Immutation)이 정확히 무엇을 의미하는 지 알아야 할 필요가 있다.</p>\n<h2 id=\"불변성이란\" style=\"position:relative;\">불변성이란?<a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\" aria-label=\"불변성이란 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>보통 불변성의 의미는 “상태를 변경하지 않는 것”이라는 간단한 정의로 설명된다.</p>\n<p>그러나 대부분 불변성에 대한 설명을 할 때, “함수 외부의 변수에 접근, 재할당해서는 안된다”, “함수의 인자를 변경하면 안 된다”와 같이 상태를 변경하는 행위를 금지하는 예시 정도만 설명하고, 상태를 변경한다는 것이 정확히 무엇을 의미하는지는 자세히 설명하지 않는다.</p>\n<p>그래서 이런 설명 방식은 상태를 변경한다는 것이 정확히 어떤 의미인지 모르는 사람에게는 잘 와닿지 않을 수 있다고 생각한다.</p>\n<p>그렇다면 불변성이 이야기하고 있는 상태의 변경이라는 것이 정확히 어떤 행위를 의미하는 것일까? 단순히 프로그램의 변수를 변경하거나 재할당 하지 않는 것을 이야기하는 것일까?</p>\n<p>사실 불변성이 이야기하는 상태의 변경이라는 것은 단순한 변수의 재할당을 이야기하는 것이 아니다. 정확히 말하면 메모리에 저장된 값을 변경하는 모든 행위를 의미하며, 여기에 변수의 재할당과 같은 행위도 포함되는 것이다.</p>\n<p>즉, 상태의 변경이라는 행위를 제대로 이해하기 위해서는 컴퓨터가 값을 어떤 방식으로 메모리에 저장하고 접근하는지에 대한 간단한 지식이 필요하다.</p>\n<h3 id=\"우리는-변수를-통해-메모리에-접근한다\" style=\"position:relative;\">우리는 변수를 통해 메모리에 접근한다<a href=\"#%EC%9A%B0%EB%A6%AC%EB%8A%94-%EB%B3%80%EC%88%98%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%9C%EB%8B%A4\" aria-label=\"우리는 변수를 통해 메모리에 접근한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>대부분의 프로그래밍 언어에서는 메모리의 특정 공간에 저장된 값에 조금 더 쉽게 접근할 수 있도록 도와주는 변수라는 기능을 제공하고 있다.</p>\n<p>변수라는 개념은 프로그래밍을 배울 때 가장 처음 배우는 것이기 때문에, 개발자라면 누구나 다 알고 있는 개념일 것이다. 한번 간단한 변수를 선언해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">let</span> a<span class=\"token punctuation\">;</span>\na <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">1</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>필자는 <code class=\"language-text\">a</code>라는 변수를 “선언”하고, 그 다음 라인에서 <code class=\"language-text\">a</code> 변수에 <code class=\"language-text\">1</code>이라는 값을 “할당”했다.</p>\n<p>일반적으로는 <code class=\"language-text\">let a = 1;</code>와 같이 선언과 동시에 할당을 진행하지만, 엄밀히 말해서 선언과 할당은 다른 행위이기에 조금 더 편한 이해를 위해 코드를 나눠서 작성했다.</p>\n<p><code class=\"language-text\">let a;</code>라는 명령을 사용하여 변수를 선언하면 자바스크립트는 메모리에 <code class=\"language-text\">a</code>라는 변수를 통해 접근할 수 있는 메모리 공간을 마련한다. 필자는 변수를 선언만 하고 값을 할당하지 않았으니 이때 <code class=\"language-text\">a</code> 변수에 접근하려 한다면, “아무것도 정의되지 않았다”라는 의미의 <code class=\"language-text\">undefined</code>를 뱉어낼 것이다.</p>\n<p>그 후 필자는 <code class=\"language-text\">a = 1</code>이라는 명령을 사용하여 마련된 메모리 공간에 <code class=\"language-text\">1</code>이라는 값을 저장했고, 그 이후부터 필자가 <code class=\"language-text\">a</code>라는 변수를 통해 해당 메모리 공간에 접근하면 저장되어 있던 <code class=\"language-text\">1</code>이라는 값을 얻어낼 수 있는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/758e65bb220cb568f802edf2c320b13f/fe720/memory-value.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAABB0lEQVR42mNgIAwYoTQXECsCsQwQcyLJ8wCxMhBLATEzg4mJia+usUGouq5WiK6BQYieoV6wsbFxpIGBgT5Mh5aWFpucnFyIlJRUkrS0dJyMjEyKioqKjJqamqKmpmayqqpSvLq6ehKQ7c9gbGLy097c+r+Prct/R3v7//Zmdn8sLa3/6+vrL6yvrxfasmWLAdBMAy8vr/8xMTH/w8PDf0VFRf3X1dVN1dHRKbawtPhvY27/y8Lc4j/Qca8ZjIyN7lmZmr92NLd5aWVh9dLCxOKZqYnpd6CB3f///2d59OiRNMg7VlZWz52dnT85OTm9BuL/QMPCQK4DeuS/saH5GwMDw69APTcBnf5M6tKki8EAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"memory value\" title=\"\" src=\"/static/758e65bb220cb568f802edf2c320b13f/6af66/memory-value.png\" srcset=\"/static/758e65bb220cb568f802edf2c320b13f/69538/memory-value.png 160w,\n/static/758e65bb220cb568f802edf2c320b13f/72799/memory-value.png 320w,\n/static/758e65bb220cb568f802edf2c320b13f/6af66/memory-value.png 640w,\n/static/758e65bb220cb568f802edf2c320b13f/d9199/memory-value.png 960w,\n/static/758e65bb220cb568f802edf2c320b13f/21b4d/memory-value.png 1280w,\n/static/758e65bb220cb568f802edf2c320b13f/fe720/memory-value.png 1448w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>즉, 변수라는 것은 메모리에 저장되어 있는 어떠한 값에 접근하는 일종의 단축어같은 개념이며, 만약 변수가 없다면 우리는 일일히 <code class=\"language-text\">0x0018fa</code>와 같은 메모리 주소를 사용하여 메모리에 값을 저장할 공간을 마련하고 값을 저장하거나 접근해야한다는 것이다.</p>\n<p>만약 필자가 <code class=\"language-text\">a = 2</code>처럼 해당 변수의 값을 다시 할당한다면, <code class=\"language-text\">0x0018fa</code>라는 주소를 가진 메모리 공간에 저장되어 있는 값을 변경하는 것이며, 상태를 변경하는 행위라고 말할 수 있는 것이다.</p>\n<p>자바스크립트는 재할당 할 수 있는 변수를 선언하는 <code class=\"language-text\">let</code> 키워드와 재할당 할 수 없는 <code class=\"language-text\">const</code> 키워드를 구분하여 제공함으로써 개발자가 실수로 메모리 공간에 저장되어있는 값을 변경하는 행위를 방어할 수 있는 기능을 제공한다.</p>\n<p>그렇다면 우리가 변수를 재할당하지만 않는다면 불변이라는 개념을 지킬 수 있는 것일까?</p>\n<center>\n  <div style=\"width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f4617a9e1f692a7df11953b0a4b86f44/d7854/nope.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQDAv/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAABs2lpGpALaQbsY1//xAAbEAEBAAIDAQAAAAAAAAAAAAABAgASAwQFEf/aAAgBAQABBQImqLTWLKPO+vWpTNqwkOMrZz//xAAYEQACAwAAAAAAAAAAAAAAAAAAARARMf/aAAgBAwEBPwHShR//xAAXEQEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/AWpr/8QAHxAAAgEDBQEAAAAAAAAAAAAAAAERAiFBEBIyYXFy/9oACAEBAAY/AppQqFup7RI/oTmHmDky1vBzi2n/xAAdEAEAAgICAwAAAAAAAAAAAAABABEhMRBBcZGh/9oACAEBAAE/IcpB03LYaGiUNZ5gCV2r5ChuKDSLb9sJVqBjAcRmA6K4/9oADAMBAAIAAwAAABBQ/wAD/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQETH/2gAIAQMBAT8QbYuaj//EABgRAQEAAwAAAAAAAAAAAAAAAAEAEBEx/9oACAECAQE/EAC1uMf/xAAgEAEBAAIBAwUAAAAAAAAAAAABEQAhMUFhsRBRcYGh/9oACAEBAAE/EGfNgAVPb7yZYA6Wrp31k+cmyLEMcBcNgdyLzcp1cdaHSnbnneJWrtHjADmNbAah3cGBXqTRf30//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"nope\" title=\"\" src=\"/static/f4617a9e1f692a7df11953b0a4b86f44/d7854/nope.jpg\" srcset=\"/static/f4617a9e1f692a7df11953b0a4b86f44/0913d/nope.jpg 160w,\n/static/f4617a9e1f692a7df11953b0a4b86f44/cb69c/nope.jpg 320w,\n/static/f4617a9e1f692a7df11953b0a4b86f44/d7854/nope.jpg 550w\" sizes=\"(max-width: 550px) 100vw, 550px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <br>\n</center>\n<p>슬프게도 그렇지 않다. 프로그램이 변수가 가리키고 있는 메모리 공간에 있는 값을 불러오고 사용하는 방법은 그렇게 단순하지 않기 때문이다.</p>\n<p>바로 여기서 그 유명한 “값에 의한 호출(Call by value)“과 “참조에 의한 호출(Call by reference)“이 등장한다.</p>\n<h3 id=\"값에-의한-호출과-참조에-의한-호출\" style=\"position:relative;\">값에 의한 호출과 참조에 의한 호출<a href=\"#%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C%EA%B3%BC-%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C\" aria-label=\"값에 의한 호출과 참조에 의한 호출 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>값에 의한 호출과 참조에 의한 호출은 특정 컨텍스트에서 다른 컨텍스트에게 변수를 넘길 때 어떤 방식으로 값을 넘겨줄 것인지에 대한 방법들이다.</p>\n<p>이렇게 컨텍스트 간 변수를 넘기는 상황은 함수 외부의 스코프에서 함수에게 인자를 넘겨주는 상황으로 많이 표현되며, 또 실제로도 그런 상황이 대부분이다.</p>\n<p>이에 대해서 조금 더 쉽게 알아보기 위해 간단한 함수를 선언해보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">foo</code> 함수는 문자열을 인자로 받아서 가장 앞의 두 글자만 잘라내어 반환하는 순수 함수이다. 즉, <code class=\"language-text\">foo</code> 함수는 자신의 인자로 받은 값을 재료로 하여 자신의 반환 값을 만들어내는 셈이다.</p>\n<p>그럼 <code class=\"language-text\">foo</code> 함수를 한번 사용해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, World!'</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">He</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">foo</code> 함수는 자신의 인자로 받은 문자열을 잘라서 반환하기 때문에, 마치 인자로 받은 <code class=\"language-text\">str</code> 변수를 직접 수정하는 것처럼 보인다.</p>\n<p>하지만 <code class=\"language-text\">foo</code> 함수의 인자로 사용했던 <code class=\"language-text\">str</code> 변수를 콘솔에 출력해보면 처음 필자가 할당했던 값인 <code class=\"language-text\">Hello, World!</code>가 그대로 저장되어 있는 것을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">He\nHello<span class=\"token punctuation\">,</span> World<span class=\"token operator\">!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이게 어떻게 된 것일까? 정답은 <code class=\"language-text\">str</code> 변수의 자료형인 String 타입의 호출 방식이 “값에 의한 호출” 방식을 사용하기 때문이다.</p>\n<p>자바스크립트에서 <code class=\"language-text\">string</code>, <code class=\"language-text\">number</code>, <code class=\"language-text\">boolean</code>과 같이 원시 타입을 사용하는 변수들은 모두 값에 의한 호출 방식을 사용한다.</p>\n<p>값에 의한 호출 방식은 함수의 인자로 어떤 변수를 넘길 때 해당 변수가 가지고 있는 값을 그대로 복사하여 함수에게 넘겨주는 방식을 의미하기 때문에, 기존에 <code class=\"language-text\">str</code> 변수가 가리키고 있는 메모리 공간에 있는 값을 함수에 인자로 넘기는 것이 아니라 그 값을 복사하여 새로운 메모리 공간에 저장하고나서 넘겨준다는 뜻이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/44d1018198529f57a7dbd342e7c5557c/6569d/call-by-value.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC1klEQVR42pVTzU8TURBfBIkm2BZLSaBCldIPut0u+0X3ox/sttra0gIlTRtLhBjLwdjIzXggkYsQ/wX0RAInQggnGw+IEBLDid4kfhAUMWo4eFBD5TmPQELQEJzkt/Pm92ZmZ968RxCnk3MAJ8ACMB/bw3YboAlwhuB53s0wDO+knJyTojin08lRoEFYURTP4wiTydSu1+tDBoMhiLXZbPZgHnzd5uYWzWKxqGazVbXZbDTBsOz3Dk747RekXYX3ln0+364oibssyyJBEEIQZwwEAp+TySRKJBK/enp6kCSJb4C/KHWw6/l+FWV7fT9j1yRE0+0bBMOxPwJeGWX8MRSXNJToSqBoNLoHFSJI2gWBl8Ph8LdcLodSqVQ5k8kgv9+/Afwln8y/vZe/igazgXJ/uhP8uU0CAlWao+NWloxcIR19LS22uN1uvw7VRWFPj1traGjgjEajWldXFwCtNTY2MphvbW1lXC67RrXZAiTpUK1WK3f88HXpdLryYF2BPy6XqxrOatjhcIyRJDkKGAeuAFtVDO2+Gwnx4yGVG+U5eoykqGFifzIEcZjEMDEx8XR2dvZZTU2NCexqAN/d3f21UCigfD5fxjoej+GWm7RO6d3IcBe6Mxgu38yG4cy9m3/dj5WVFe/y8nIoGAxWHVBGaH1RluUNSZLWYWgfwX4O/IUOgS7eSCkfervE14mIuOnx0AvEfwo+06ojdsUxEASuZGBgAF9cAlq9PT09XZqamlqcmZl5CfaLubm5BdBF4F9NTk7ewn4IoTMn/hYc9rPPz8+7YS3v7Oy0A9jV1VVtbW0tViwWI0tLS8lSqWQ96v9Pgak9dLvdjyk79ajeVP9Ep9ONwEu4D3hQW1vbfHTipxKBF5ASVJCaU1Fftg9lM1mkadoeDAC/lF7sMzQ0dBa3eWJlhwLv9j3DMtucwm3JPnlbUZRPkGjL4/F8gfumHbhVnrbCP+ts8mF/LuM/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"call by value\" title=\"\" src=\"/static/44d1018198529f57a7dbd342e7c5557c/6af66/call-by-value.png\" srcset=\"/static/44d1018198529f57a7dbd342e7c5557c/69538/call-by-value.png 160w,\n/static/44d1018198529f57a7dbd342e7c5557c/72799/call-by-value.png 320w,\n/static/44d1018198529f57a7dbd342e7c5557c/6af66/call-by-value.png 640w,\n/static/44d1018198529f57a7dbd342e7c5557c/d9199/call-by-value.png 960w,\n/static/44d1018198529f57a7dbd342e7c5557c/21b4d/call-by-value.png 1280w,\n/static/44d1018198529f57a7dbd342e7c5557c/6569d/call-by-value.png 1328w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>결국 <code class=\"language-text\">foo(str)</code>라는 코드로 함수를 호출하며 인자로 넘긴 <code class=\"language-text\">str</code>이라는 변수가 가지고 있는 값과, <code class=\"language-text\">foo</code> 함수 내부에서 <code class=\"language-text\">s</code>라는 변수를 통해 접근하는 값은 전혀 다른 메모리 공간에 저장되어 있는 새로운 값이다.</p>\n<p>그렇기 때문에 <code class=\"language-text\">foo</code> 함수가 아무리 자신의 인자로 받은 변수를 지지고 볶아도 원본 변수는 절대로 영향을 받지 않는다. 심지어 <code class=\"language-text\">foo</code> 함수 내부에서 <code class=\"language-text\">s</code> 변수를 재할당하더라도 원본 변수에 담겨져 있는 값은 변하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, World!'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  s <span class=\"token operator\">=</span> <span class=\"token string\">'재할당합니다'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Hello<span class=\"token punctuation\">,</span> World<span class=\"token operator\">!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">foo</code> 함수는 인자로 넘어온 변수에 값을 재할당했음에도 함수 외부에 있는 <code class=\"language-text\">str</code> 변수의 값은 변하지 않았다.</p>\n<p>즉, 불변성을 유지한다는 것은 단순히 “함수의 인자를 변경하지 않는다”라던가 “변수를 재할당하지 않는다”는 개념이 아닌 것이다. 포인트는 메모리에 이미 담겨있는 값을 변경하지 않는 것이다.</p>\n<p>반면 값에 의한 호출 방식을 사용하지 않는 <code class=\"language-text\">Array</code>, <code class=\"language-text\">Object</code>와 같은 객체들은 조금 상황이 다르다.</p>\n<p>이번에는 인자로 배열을 받은 후 그 배열에 <code class=\"language-text\">hi</code>라는 문자열 원소를 추가하는 간단한 함수를 선언하고, 어떤 결과가 나오는지 살펴보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">bar</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hi'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>원시 자료형이었던 <code class=\"language-text\">str</code> 변수는 값에 의한 호출 방식을 사용하지만, 객체인 <code class=\"language-text\">Array</code>는 “참조에 의한 호출” 방식을 사용한다. 그럼 함수를 사용해보고 원본 변수가 어떻게 되는지 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">bar</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">'hi'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>함수 내부에서 인자를 지지고 볶아도 원본 변수에는 전혀 영향이 없었던 <code class=\"language-text\">foo</code> 함수와 다르게, 이번에는 <code class=\"language-text\">bar</code> 함수의 인자로 넘겼던 <code class=\"language-text\">array</code> 변수의 값이 변경된 것을 확인해볼 수 있다.</p>\n<p>함수의 인자로 변수를 넘길 때 값을 복사하여 새로운 공간에 저장한 후 넘겨주는 값에 의한 호출 방식과 다르게, 참조에 의한 호출 방식은 “변수가 가리키고 있는 메모리 공간의 주소”를 넘기는 방식이다.</p>\n<p>즉, <code class=\"language-text\">array</code> 변수가 가리키고 있는 메모리 공간에 저장된 배열과 <code class=\"language-text\">bar</code> 함수가 인자로 받은 배열은 정확히 같은 메모리 공간에 저장되어 있는, “같은 배열” 이라는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8e28402edf974ba2f299767cd19f1f12/6569d/call-by-reference.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACE0lEQVR42mNgwA8YobQ0EOsCsRIQCyDJMwOxFhBrALEUWETPVE9NyUBTVdPAQFVJSUlVWVlZxcTERN3Y2FgEJM/Pzy/Ax8dnwsnJacrFxWUMYsvJyQna29uzANVqy8jImAoLC5vIysqaAPXLMViamn+1N7X+ZGVq8dnaxuaznZ3dB3Nz8/9GRkbzQAYaGhq2urq6/vf09PwAxB+B+D/QwjqQAQYGBn9NTU0/2drafgQ64Jeent4ZBk9rp/8x9r7/fWxd/wcGB/2Pjo7+A9IENGg11MA5CQkJIPG/ILmYmJj/lpaWXUCX2ZuZmf23sbH55+3t/Rco9h9owQ0GHUO9XDV9rWwtfd1sDQ2NbDU1tUygRDFQgRPIQHV1dRMFBYVyoDfLQBjorQogNtHS0hLS0dEpBuIiILtQV1e3TFNTM5yBBMAFxJxIkcWIVVVoaChzfX09k7y8PAcwwIWAQnwTJkyoWLdu3ZKZM2cuBuJ4oBgHMOClREVFef7//w8yiAlkIEgvMgaLgwwDGSwoKMgvKSnJBZKYMmVK0q5du7qWL1/euXjxYm+QPNBbbDhdhSOtiSN5iXygq607V1dNd4aKiso6JWWlxcBIma6vr78MiFNhQUKSgbaetv8doh3+BwWBk8z/qKioP8C0CEqHa0HysCAhGhiaGr41tDZ8bWFp8QaYpt4Ac8BLYNr7qa2tPR2qhCQDAXhMmtiBpCW6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"call by reference\" title=\"\" src=\"/static/8e28402edf974ba2f299767cd19f1f12/6af66/call-by-reference.png\" srcset=\"/static/8e28402edf974ba2f299767cd19f1f12/69538/call-by-reference.png 160w,\n/static/8e28402edf974ba2f299767cd19f1f12/72799/call-by-reference.png 320w,\n/static/8e28402edf974ba2f299767cd19f1f12/6af66/call-by-reference.png 640w,\n/static/8e28402edf974ba2f299767cd19f1f12/d9199/call-by-reference.png 960w,\n/static/8e28402edf974ba2f299767cd19f1f12/21b4d/call-by-reference.png 1280w,\n/static/8e28402edf974ba2f299767cd19f1f12/6569d/call-by-reference.png 1328w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>즉, <code class=\"language-text\">bar</code> 함수의 인자로 받은 배열은 참조에 의한 호출 방식을 사용하는 객체이기 때문에, 함수 내에서 이 배열을 지지고 볶아 버린다면 원본 배열 자체가 지지고 볶아지는 것이다.</p>\n<p>이 경우에는 메모리 공간에 저장되어있던 배열을 직접 변경해버리는 것이므로, 상태가 변경되었다고 말할 수 있고, 불변성이 깨져버린 것이다.</p>\n<p>똑같이 함수의 내부에서 인자를 수정하는 행위지만 인자가 값에 의한 호출 방식을 사용하는 자료형인지 참조에 의한 호출 방식을 사용하는 자료형인지에 따라 결과는 큰 차이가 나기 때문에, 불변성을 지키고 싶다면 항상 이 점을 염두에 두고 코드를 작성해야한다.</p>\n<h2 id=\"불변성을-지키면-어떤-점이-좋은가요\" style=\"position:relative;\">불변성을 지키면 어떤 점이 좋은가요?<a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%ED%82%A4%EB%A9%B4-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%9D%B4-%EC%A2%8B%EC%9D%80%EA%B0%80%EC%9A%94\" aria-label=\"불변성을 지키면 어떤 점이 좋은가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>프로그래밍을 하면서 상태의 불변성을 지키려면 자연스럽게 이것저것 신경써줘야하는 것들이 늘어날 수 밖에 없다. 그럼에도 불구하고 불변이라는 개념은 현재 많은 개발자들에게 환영받고 있는 개념이라는 것이 사실이다.</p>\n<p>도대체 상태가 변경되지 않게 함으로써 얻을 수 있는 것이 무엇이길래, 다들 이렇게 불변불변하는 것일까?</p>\n<h3 id=\"무분별한-상태의-변경을-막는다\" style=\"position:relative;\">무분별한 상태의 변경을 막는다<a href=\"#%EB%AC%B4%EB%B6%84%EB%B3%84%ED%95%9C-%EC%83%81%ED%83%9C%EC%9D%98-%EB%B3%80%EA%B2%BD%EC%9D%84-%EB%A7%89%EB%8A%94%EB%8B%A4\" aria-label=\"무분별한 상태의 변경을 막는다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>상태는 프로그램의 현재 상황을 보여주는 좋은 역할도 하지만, 여기저기서 무분별하게 이 상태를 참조하거나 변경하는 경우, 개발자조차 현재 프로그램이 어떻게 돌아가는지 파악하기 힘든 슬픈 상황이 발생할 수도 있다.</p>\n<p>그래서 개발자들은 상태를 변경하는 행위에 특정한 규칙과 제약을 정해서 무분별한 상태 변화를 최대한 피하고, 이런 변화를 추적할 수 있는 상황을 선호할 수 밖에 없다.</p>\n<p>무분별한 상태 변경 때문에 프로그램이 터지게 되는 가장 대표적인 상황은 바로 “전역 변수의 남용”이다. 자바스크립트에서 전역 변수의 사용을 아예 금지하는 컨벤션을 추천하는 것도 바로 이 이유이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">let</span> greeting <span class=\"token operator\">=</span> <span class=\"token string\">'Hi'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">setName</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  greeting <span class=\"token operator\">=</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>greeting<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">greeting</code> 변수는 전역 스코프에서 선언된 전역 변수이고, <code class=\"language-text\">setName</code> 함수 내부에서도 암묵적으로 전역 변수를 선언하고 있으며, <code class=\"language-text\">setTimeout</code>의 콜백 함수 내에서도 전역 변수인 <code class=\"language-text\">greeting</code>의 값을 재할당하고 있다.</p>\n<p>이런 상황에서는 어디서 어떤 놈이 <code class=\"language-text\">greeting</code>이라는 전역 변수의 상태를 변경했는지 추적이 거의 불가능하며, 갑자기 콘솔에 <code class=\"language-text\">Hi, Evan</code>이 아닌 <code class=\"language-text\">Get out, Evan</code>이라고 출력된다고 해도 전혀 이상할 것이 없다.</p>\n<p>개발자가 이런 상황을 만났을 때 야근을 하는 이유는, 슬프게도 이게 버그가 아니기 때문이다. 이 코드들은 콘솔에는 어떠한 에러도 출력되지 않는 지극히 정상적인 로직이다. <small>(차라리 에러라도 나는 것이 디버깅은 더 쉽다)</small></p>\n<p>불변성을 유지하며 순수 함수를 사용한다는 것은 함수 외부의 상태에 접근하여 이미 메모리에 할당되어 있는 값을 변경하지 않는다는 의미이므로, 이렇게 예측하지 못한 상태의 변경을 방어할 수 있다.</p>\n<h3 id=\"상태의-변경을-추적하기가-쉽다\" style=\"position:relative;\">상태의 변경을 추적하기가 쉽다<a href=\"#%EC%83%81%ED%83%9C%EC%9D%98-%EB%B3%80%EA%B2%BD%EC%9D%84-%EC%B6%94%EC%A0%81%ED%95%98%EA%B8%B0%EA%B0%80-%EC%89%BD%EB%8B%A4\" aria-label=\"상태의 변경을 추적하기가 쉽다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>일반적으로 자바스크립트의 객체의 프로퍼티나 배열의 원소를 변경해야하는 경우, 필연적으로 불변성이 깨질 수 밖에 없다.</p>\n<p>애초에 배열이나 객체가 처음 나왔을 때, 어딘가에 구조화된 데이터를 저장해놓고 상태를 유지하고 변경해가며 사용하고자 하는 목적을 가지고 있었기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nevan<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Not Evan'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 상태 변화!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>하지만 이렇게 기존에 메모리에 저장되어있는 값을 변경하는 행위는 불변의 법칙을 정면으로 위반하는 것이기 때문에, 불변성을 유지하고 싶은 개발자는 이런 식으로 객체의 프로퍼티나 배열의 원소를 변경할 수 없다.</p>\n<p>게다가 방금 보았던 무분별한 전역 변수의 사용과 마찬가지로 객체나 배열의 상태 변화 또한 추적할 수 없는 문제이기 때문에, 어디서 이상한 놈이 엄한 객체나 배열의 상태를 변경하여 버그가 발생하더라도 개발자가 이를 디버깅하기란 쉽지 않은 문제이다.</p>\n<p>그렇다고 객체의 프로퍼티나 배열의 원소를 변경하지 못하도록 할 수도 없는 노릇이다. 그럼 어떻게 이 문제를 해결해야할까?</p>\n<p>한번 객체의 프로퍼티를 변경하는 간단한 함수를 통해 객체의 프로퍼티를 변경할 때 발생하는 상태 변화의 재현과 해결 방법을 알아보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">convertToJohn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">person<span class=\"token punctuation\">,</span> name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  person<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> person<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">convertToJohn</code> 함수는 객체를 인자로 받아, 해당 객체의 <code class=\"language-text\">name</code> 프로퍼티에 <code class=\"language-text\">John</code>이라는 문자열을 할당하는 역할을 하는 함수이다. 즉, 이 함수는 객체의 상태를 변경하는 역할을 하고 있다.</p>\n<p>일단 결론부터 이야기하자면 이 함수는 순수 함수가 아닌데, 그 이유는 함수가 참조에 의한 호출 방식을 사용하는 객체의 프로퍼티를 직접 변경하면 함수 외부에 있는 원본 객체의 상태도 변경되기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> john <span class=\"token operator\">=</span> <span class=\"token function\">convertToJohn</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>john<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// ?</span>\n<span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">convertToJohn</code> 함수를 사용하는 사람은 함수의 이름만 보고 “오호, 이 함수는 어떤 객체를 존 객체로 바꿔주는 함수로군?”이라고 생각하겠지만, 이 함수는 개발자 몰래 자신의 인자로 받은 객체까지 변경해버리는 나쁜 함수였다.</p>\n<p>이렇게 의도하지않은 객체의 프로퍼티가 변경되는 것도 문제지만, 사실 더 큰 문제는 이런 상태의 변화를 전혀 추적할 수 없다는 것이다. 당장 위 예시의 <code class=\"language-text\">evan</code> 객체와 <code class=\"language-text\">john</code> 객체를 비교해보면 자바스크립트는 두 객체가 같은 객체라고 평가해버린다.</p>\n<p>두 객체는 메모리 공간에 접근할 수 있는 변수명만 다를 뿐, 실제로는 같은 메모리 공간에 저장되어 있는 같은 객체이기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan <span class=\"token operator\">===</span> john<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이런 상황에서 개발자는 “의도하지 않은 객체의 상태 변화”와 “상태의 변화를 추적할 수 없다”는 고약한 문제를 떠안게 된다. 그렇다면 이 문제를 어떻게 해결할 수 있을까?</p>\n<p>이 문제는 생각보다 간단하게 해결할 수 있는데, <code class=\"language-text\">name</code>을 <code class=\"language-text\">John</code>으로 가지는 객체를 그냥 새로 생성해버리면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">convertToJohn</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">person</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> newPerson <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  newPerson<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> newPerson<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> john <span class=\"token operator\">=</span> <span class=\"token function\">convertToJohn</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>john<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>변경된 <code class=\"language-text\">convertToJohn</code> 함수는 더 이상 인자로 받은 <code class=\"language-text\">person</code> 객체에 직접 접근해서 값을 수정하지 않는다. 다만 <code class=\"language-text\">Object.assgin</code> 메소드를 사용하여 <code class=\"language-text\">person</code> 객체와 동일한 구조를 가진 새로운 객체를 생성하고 <code class=\"language-text\">name</code> 프로퍼티를 <code class=\"language-text\">John</code>으로 변경한 후 반환할 뿐이다.</p>\n<p>이런 과정이 너무 불편하게 느껴진다면 ES6의 <code class=\"language-text\">spread</code> 연산자를 사용하면 더 간단한 문법으로 변경할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">convertToJohn</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">person</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>person<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 새로운 객체를 생성하게 되면 의도하지 않은 객체의 상태 변화도 방어할 수 있고 상태 변화를 추적할 수도 있게 된다. 왜냐하면 <code class=\"language-text\">convertToJohn</code> 함수가 뱉어낸 객체는 <code class=\"language-text\">evan</code> 객체와는 전혀 다른, 새로운 객체이기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan <span class=\"token operator\">===</span> john<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>객체의 상태를 변화시킬때, “상태가 변화된 객체”를 새로 생성한다면 우리는 이전 상태를 가진 객체와 다음 상태를 가진 객체를 비교하며 <code class=\"language-text\">false</code>가 나온다는 사실을 이용하며 객체의 상태가 변화되었음을 알 수 있는 것이다.</p>\n<p>이런 원리는 웹 프론트엔드의 UI 라이브러리인 React에서 상태의 변화를 감지하는 데에도 사용되고 있는데, React는 개발자가 <code class=\"language-text\">setState</code>와 같은 메소드를 사용하여 상태를 변경했을 때 <code class=\"language-text\">Object.is</code> 메소드를 사용하여 이전 상태와 다음 상태를 비교하고 두 객체가 같지 않다고 평가되면 상태가 변이되었다고 판단하고 컴포넌트를 다시 렌더한다.</p>\n<p>또한 상태 관리 라이브러리인 Redux 또한 동일한 원리로 상태의 변화를 판단하기 때문에, 리듀서(Reducer)를 작성할 때는 기존 <code class=\"language-text\">state</code> 객체의 프로퍼티를 직접 변경하지 않고 새로운 객체를 생성해서 반환해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">reducer</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token constant\">SET_NAME</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">...</span>state<span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> action<span class=\"token punctuation\">.</span>payload<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이러한 불변성의 특징들은 참조에 의한 호출을 사용하는 자료형들의 상태 변화를 쉽게 감지할 수 있도록 만들어주기 때문에 개발자가 예상하지 못하는 방향으로 버그가 발생하는 것을 어느 정도 막을 수 있다.</p>\n<p>또한 불변성은 멀티 쓰레딩을 사용할 때도 매우 유용한데, 여러 개의 쓰레드가 한 개의 상태를 정신없이 수정하고 참조하게되면 어느 순간부터는 도대체 쓰레드가 참조한 게 어떤 값인지 파악하기가 힘들기 때문이다.</p>\n<p>이건 마치 하나의 종이에 여러 명의 화가가 물감을 칠하면서 그림을 완성해가는 느낌이라고 할 수도 있을 것 같다. 그러나 불변성이 제대로 지켜진다면 각자 쓰레드마다 종이를 주고 그림을 그려서 제출하라는 상황과 비슷하다.</p>\n<p>개발자는 각 쓰레드가 그림을 제출할 때마다 상태가 변경되었음을 감지할 수도 있고, 이를 이용하여 그림의 상태가 변경되는 로그를 쌓을 수도 있다. 이후 그 그림들을 어떻게 취합하던, 필요없는 그림은 버리던 그건 그 후의 문제로 분리하면 되는 것이다.</p>\n<h2 id=\"현실적인-불변성의-상황\" style=\"position:relative;\">현실적인 불변성의 상황<a href=\"#%ED%98%84%EC%8B%A4%EC%A0%81%EC%9D%B8-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%98-%EC%83%81%ED%99%A9\" aria-label=\"현실적인 불변성의 상황 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇게 불변성을 지키면서 프로그래밍을 하면 상태 변화를 쉽게 추적할 수 있고 관리할 수 있다는 점에서 더할 나위 없이 좋지만, 그렇다고 해서 장점만 있는 것은 아니다.</p>\n<p>불변성의 가장 큰 문제는 기존의 객체지향 프로그래밍과의 접점을 만들기 어렵다는 것이다.</p>\n<p>불변성을 지향한다는 함수형 프로그래밍의 특징은 기존에 우리가 익숙하게 사용하는 객체지향 프로그래밍과는 많이 다르다.</p>\n<p>객체지향 프로그래밍은 <code class=\"language-text\">private</code>과 같은 접근 제한자로 상태를 외부에 노출시키지 않음으로써 사용자가 단순한 인터페이스를 접할 수 있도록 하지만, 함수형 프로그래밍은 아예 프로그램의 상태를 변경하지 않는 불변성을 지향하면서 프로그램의 동작을 예측하기 쉽고 단순하게 만든다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/def489f1400293515499d529e83b420a/e9140/oop_fp.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 43.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAACXklEQVR42m2RyU9TURTGL05xgUtj4k4sJAwxIS7Y+SfoQhRkJTPEKSRuTCQyJCx4xCHQFHi0ry21lilVEINBGV+hpeWVliHpI4gR6EAhAjXQ9tF+3leCQeNJvpyTc5Pf+e45hBCSREUyMjKSs9NTb1zPVFwlR5F0/PafSPRzsjPTc7KyLp3sER64PLiLtKEDKAbCSB0GUoYAhaxV4Py/JPWE92K7bTONnQoo9HMHV966D1Lkun1iPa2DD14gjaq5HUbtBtPhlhjWLTWyrkOGdUVe6z2obZhqlyEAEtO7F3BOY/E7Ome2wfG+qMbiO9TwCUWMwh7UvE9LHt3qQ3Vxf7y2fBA1ZR/xvLAfdRWD8arcXlTe7IlW3u65duyOApN11i3ROLsLzhKI6a1B6KaD4KYCUs98GJ22bTN58nImXMLYUMZY4+VNNpQyVlnSg5ZFVL+yaxIg4HQijwaSqQvR6NiBcmQ9VvNhBfUD38BOeKUu1z6oUzMp1i+G8lg3Cti5eAHrQv6RooWmH2gYWq2XQW0OnD0JNNh/Qj3pi5VwC3ja5aEuA5LpGPi4c3HnTrMjnq90Ru+pnNLdFkHKVwr7pYYVMJ9W646Ajj9AzuJfMti20DKyEWn+uia9GV6T2sa9YZMQkvfaR6p6v4cKdcso0nniFYZl3Nd6UKQXow/NQTR9Cf7tkO7QOBsSuxciMAl7MZMzhC4qo3NPei8C74RfZkIv9bl1bGO+bcw72zruFeg0QTW2Yad7EXXTm3ky6MXo6JlEBk5pLX6OHmRJw/sdVAL9pkBd2zneL2onfc9+A3kmnpn735kWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"oop fp\" title=\"\" src=\"/static/def489f1400293515499d529e83b420a/6af66/oop_fp.png\" srcset=\"/static/def489f1400293515499d529e83b420a/69538/oop_fp.png 160w,\n/static/def489f1400293515499d529e83b420a/72799/oop_fp.png 320w,\n/static/def489f1400293515499d529e83b420a/6af66/oop_fp.png 640w,\n/static/def489f1400293515499d529e83b420a/d9199/oop_fp.png 960w,\n/static/def489f1400293515499d529e83b420a/e9140/oop_fp.png 1226w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>\n    OOP는 변경 가능한 상태를 감추며 단순함을 만들어내지만,<br>\n    FP는 아예 변경 가능한 상태를 없앰으로써 단순함을 만들어낸다\n  </small>\n</center>\n<p>즉, 객체지향 프로그래밍과 함수형 프로그래밍은 상태를 바라보는 관점 자체가 다르다는 것이다. 애초에 객체지향 프로그래밍은 상태를 “잘 변경하는 것”에 초점을 맞추는 패러다임이기 때문에 불변성과는 약간 거리가 있다.</p>\n<p>또한 아직까지 우리가 사용하는 대부분의 API나 라이브러리들은 객체지향 프로그래밍을 기반으로 설계되고 있기 때문에 우리는 객체지향 프로그래밍에서 완벽하게 독립할 수 없는 상황이다.</p>\n<p>문제는 이렇게 객체지향 프로그래밍을 기반으로 설계된 것들을 불변의 법칙으로 관리하려면 꽤 많은 비용이 들 수도 있다는 것이다.</p>\n<p>쉬운 이해를 위해 웹 오디오 API를 사용하여 객체를 하나 생성하고, 이 객체의 상태를 변경해야하는 상황을 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AudioContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">node</span><span class=\"token operator\">:</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">createGain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>상태를 표현하기 위해 간단한 객체를 생성하고 그 안에 <code class=\"language-text\">GainNode</code>를 할당했다. <code class=\"language-text\">GainNode</code>는 오디오 신호의 크기를 키웠다 줄였다 할 수 있는 값인 <code class=\"language-text\">gain</code> 프로퍼티를 가지고 있고, 개발자는 이 프로퍼티의 값을 변경함으로써 간단하게 오디오 신호를 조작할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">state<span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">.</span>gain <span class=\"token operator\">=</span> <span class=\"token number\">1.2</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그러나 이렇게 객체에 직접 접근하여 프로퍼티를 변경하는 행위는 불변성을 위배한다. 이 상황에서 불변성을 만족하기 위해서는 <code class=\"language-text\">gain</code> 프로퍼티의 값을 변경할 때마다 새로운 게인 노드 객체를 생성해줘야 하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">setGain</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> newGain <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">createGain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  newGain<span class=\"token punctuation\">.</span>gain <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> newGain<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nstate <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>state<span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">node</span><span class=\"token operator\">:</span> <span class=\"token function\">setGain</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>물론 이렇게 불변성을 지켜주면 게인 노드의 상태 변화를 추적할 수 있다는 장점을 가지지만, 객체를 생성하는 비용이 클 경우에는 문제는 발생할 수 있다.</p>\n<p>웹 오디오 API가 제공하는 게인 노드 객체는 멤버 변수와 메소드를 가지고 있는 엄연한 인스턴스이며, <code class=\"language-text\">{ gain: 1 }</code>처럼 간단한 프로퍼티만을 가지고 있는 객체가 아니다.</p>\n<p>만약 인스턴스가 가지고 있는 멤버 변수와 메소드가 많거나 객체를 생성할 때 무거운 작업이 동반되어야 한다면, 프로퍼티를 변경할 때마다 객체를 생성하는 것은 퍼포먼스에 상당한 부담이 될 수도 있다.</p>\n<p>이미 생성된 객체를 복사하는 방법도 있겠지만, 저렇게 생성자를 통해 생성된 객체는 복사한 후에 프로토타입 링크도 전부 다시 연결해줘야하기 때문에, 일반 객체를 복사하는 것에 비해 그리 가벼운 작업은 아니다.<small>(실제로 몇 번 해봤는데, 퍼포먼스가 생각보다 안 나온다)</small></p>\n<p>이런 상황에서 섣불리 불변성을 유지한답시고 저런 코드를 작성하면 프로그램 전체의 퍼포먼스가 크게 저하될 수도 있기 때문에 각 상황에 맞는 현명한 판단이 필요하다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이번 포스팅에서는 불변성에 대한 설명과 더불어, 일급 시민이라는 개념을 사용한 커링과 같이 기술적인 부분에 대한 이야기도 함께 하려고 했는데, 또 분량 조절에 실패해버렸다.</p>\n<p>아무래도 요즘 관심을 많이 가지고 있는 내용이다보니 자꾸 내용이 길어지는 듯 하다.</p>\n<p>최근 불변성이라는 키워드가 프론트엔드 쪽에서 많이 주목받고 있기는 하지만 사실 불변성이 프론트엔드에서만 주목받는 키워드는 아니다. 본래 불변성이 주목받기 시작한 이유는 변경 가능한 상태를 여러 곳에서 공유하게 됨으로써 발생하는 여러가지 문제를 해결하기 위함이었기 때문이다.</p>\n<p>일반적으로 이런 문제는 멀티 쓰레딩과 같은 동시성 프로그래밍을 사용할 때 많이 발생했는데, 기존에는 상태에 접근할 수 있는 권한을 의미하는 일종의 락(Lock)을 걸어놓고 락이 풀린 상태에만 쓰레드가 상태에 접근할 수 있도록 허가하는 방식을 주로 사용했었다.</p>\n<p>그러나 이러한 상태가 한두개도 아닐 뿐더러, 실수로 락을 잘못 걸어서 상태가 꼬여버려도 개발자가 알아차리기 힘든 것은 매한가지이기 때문에, 변경 가능한 상태를 아예 없애버리는 불변의 개념이 각광받기 시작한 것이다.</p>\n<p>오히려 Erlang이나 Rust 같은 언어들은 자바스크립트보다 더 빡빡한 방법으로 불변성을 지원하고 있기 때문에, 이 키워드에 관심이 많으신 분들은 해당 언어를 한 번 체험해보는 것도 좋겠다는 생각이 든다. <small>(필자는 Rust를 한번 해볼까 생각 중이다)</small></p>\n<p>하지만 자바스크립트 또한 특유의 자유로운 언어의 성격 때문에 ES5 시절부터 무분별한 상태 관리에 많은 개발자들이 고통받았었고, 점점 더 웹 프론트엔드 어플리케이션이 고도화되고 복잡한 상태 관리를 요구하게 되면서 이런 개념을 사용하게 되었다.</p>\n<p>실제로 필자 또한 상태의 변화를 추적할 수 없는 상황에서 발생한 버그를 디버깅하느라 고생한 적이 너무나도 많았기 때문에, 이러한 불변의 개념을 처음 알았을 때 꽤나 관심있게 지켜봤던 기억이 있다.</p>\n<p>하지만 앞서 이야기했듯이 불변성을 유지하며 프로그래밍을 한다는 것이 모든 상황에서의 정답이 될 수는 없다.</p>\n<p>필자도 현재 작업 중인 토이 프로젝트인 <a href=\"https://github.com/evan-moon/simple-waveform-visualizer\" target=\"_blank\" rel=\"nofollow\">Web Audio 에디터</a>에 아무 생각없이 리덕스를 붙혔다가 위에서 이야기했던 객체 생성 비용 문제때문에 퍼포먼스가 안 나와서 고생 중이다.<small>(위에서 예로 든 상황은 필자의 경험담이었다)</small></p>\n<p>늘 이야기하는 것이지만 모든 상황에 맞아떨어지는 절대적인 기술이라는 것은 없기 때문에, 불변성이 무조건 좋다고 이야기하기보다 그저 각 상황에 맞는 현명한 의사결정을 통해 불변성을 이용하면 된다고 생각한다.</p>\n<p>이상으로 변하지 않는 상태를 유지하는 방법, 불변성 포스팅을 마친다.</p>","fields":{"slug":"20200105-what-is-immutable","path":"/2020/01/05/what-is-immutable/","lang":"ko"},"frontmatter":{"title":"변하지 않는 상태를 유지하는 방법, 불변성(Immutable)","subTitle":"변하지 않는 데이터를 쓰면 무엇이 달라지는가","date":"Jan 05, 2020","categories":["프로그래밍","아키텍처"],"tags":["함수형 프로그래밍","Functional Programming","순수 함수","불변성","Pure Functions","Immutable","Immer","Redux","Reducer"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/5015b01788f79d9bfd780840b41814f1/d803c/thumbnail.png","srcSet":"/static/5015b01788f79d9bfd780840b41814f1/d803c/thumbnail.png 320w,\n/static/5015b01788f79d9bfd780840b41814f1/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/5015b01788f79d9bfd780840b41814f1/fc5c5/thumbnail.webp 320w,\n/static/5015b01788f79d9bfd780840b41814f1/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/5015b01788f79d9bfd780840b41814f1/01fb2/thumbnail.png","srcSet":"/static/5015b01788f79d9bfd780840b41814f1/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/5015b01788f79d9bfd780840b41814f1/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"6492e3b5-e104-5bfb-8485-dae6c08b7131","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EB%8A%94-%EA%B7%B8%EB%83%A5-%EC%88%98%ED%95%99%EC%A0%81-%ED%95%A8%EC%88%98%EB%8B%A4\">순수 함수는 그냥 수학적 함수다</a></p>\n<ul>\n<li><a href=\"#%EC%88%98%ED%95%99%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98\">수학에서의 함수</a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98\">프로그래밍에서의 함수</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%88%9C%EC%88%98%ED%95%9C-%EC%88%98%ED%95%99%EC%A0%81-%ED%95%A8%EC%88%98%EB%A1%9C-%ED%9A%8C%EA%B7%80%ED%95%98%EC%9E%90\">순수한 수학적 함수로 회귀하자</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이전에 작성했던 기존의 사고 방식을 깨부수는 함수형 사고 포스팅에 이어, 이번 포스팅에서는 함수형 프로그래밍이 지향하는 관점을 실제 프로그램에 구현하기 위해 알고 있어야하는 필수적인 개념 중 하나인 “순수 함수(Pure functions)“에 대한 이야기를 해볼까 한다.","html":"<p>이전에 작성했던 <a href=\"/2019/12/15/about-functional-thinking/\">기존의 사고 방식을 깨부수는 함수형 사고</a> 포스팅에 이어, 이번 포스팅에서는 함수형 프로그래밍이 지향하는 관점을 실제 프로그램에 구현하기 위해 알고 있어야하는 필수적인 개념 중 하나인 “순수 함수(Pure functions)“에 대한 이야기를 해볼까 한다.</p>\n<!-- more -->\n<p>2017년 쯤, 함수형 프로그래밍이라는 패러다임이 떠오르면서 순수 함수라는 개념 또한 함께 주목받기 시작했고, 지금도 구글에 “순수 함수”라고 검색하면 많은 개발자 분들이 순수 함수의 특징에 대한 포스팅을 작성해놓은 것을 볼 수 있다.</p>\n<p>일반적으로 우리가 순수 함수에 대해서 공부하려고 하면 다음과 같은 두 가지 특징을 가지는 함수라고 정의하는 경우를 많이 볼 수 있다.</p>\n<blockquote>\n<ol>\n<li>동일한 인풋(인자)에는 항상 동일한 결과를 내야한다.</li>\n<li>함수 외부의 상태를 변경하거나, 외부의 상태에 영향을 받아서는 안된다.</li>\n</ol>\n</blockquote>\n<p>그러나 이렇게 공부하게 되면 “순수 함수는 이런저런 특징을 가지고 있는 함수”라고 외우게 되기 쉬운데, 사실 순수 함수는 이렇게 접근할 필요가 없는, 더 심플한 개념이다.</p>\n<p>뭐 그냥 이렇게만 외워놔도 순수 함수가 어떤 것인지 이해하고 사용하는 데는 전혀 무리가 없지만, 필자는 순수 함수의 이러한 특징이 어디서 나온 것인지, 순수 함수라는 것이 정확하게 무엇을 의미하는지에 대해 조금 더 근본적인 이야기를 해보려고 한다.</p>\n<h2 id=\"순수-함수는-그냥-수학적-함수다\" style=\"position:relative;\">순수 함수는 그냥 수학적 함수다<a href=\"#%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EB%8A%94-%EA%B7%B8%EB%83%A5-%EC%88%98%ED%95%99%EC%A0%81-%ED%95%A8%EC%88%98%EB%8B%A4\" aria-label=\"순수 함수는 그냥 수학적 함수다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리가 순수 함수라고 이름을 붙히고 순수 함수의 특징은 이러이러한 것들이 있다고 공부하기 때문에 뭔가 특별한 함수인 것 같지만, 사실 순수 함수는 그냥 수학에서 사용하는 함수를 프로그래밍의 세계에 똑같이 구현해놓은 것에 불과하다.</p>\n<p>위키 백과의 함수형 프로그래밍의 정의를 보면 이 개념에 대해 조금 더 자세하게 작성된 설명을 볼 수 있다.</p>\n<blockquote>\n<p><strong>함수형 프로그래밍</strong>(functional programming)은 자료 처리를 <strong>수학적 함수</strong>의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다. 명령형 프로그래밍에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다.</p>\n<p><strong>함수형 프로그래밍 - 위키 백과</strong> <em><a href=\"https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" target=\"_blank\" rel=\"nofollow\">원문 링크</a></em></p>\n</blockquote>\n<p>이 설명에서 가장 중요한 키워드는 바로 “수학적 함수”라는 단어이다. 우리가 이런저런 특징을 외우며 공부하는 순수 함수라는 녀석은 말 그대로 순수한 함수, 즉 수학에서 사용하는 함수를 의미하는 것이다.</p>\n<p>우리가 수학의 세계와 프로그래밍의 세계에서 동일하게 함수라는 개념을 사용하고 있기 때문에 간혹 잊어버리긴 하지만, 사실 프로그래밍에서의 함수는 수학의 그것과는 다른 점이 상당히 많다.</p>\n<p>그럼 수학적인 함수와 프로그래밍의 함수 간 차이점을 알아보기 위해, 수학적인 함수의 정의부터 다시 한번 확실하게 짚고 넘어가도록 하자.</p>\n<h3 id=\"수학에서의-함수\" style=\"position:relative;\">수학에서의 함수<a href=\"#%EC%88%98%ED%95%99%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98\" aria-label=\"수학에서의 함수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>우리가 중학생 때 배웠던 함수라는 녀석은 대략 다음과 같은 정의를 가지는 개념이다.</p>\n<blockquote>\n<p>임의의 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">x \\in X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span>에 대하여 그에 대응하는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">y \\in Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span>가 <strong>유일하게 존재하는</strong> 대응 관계</p>\n</blockquote>\n<p>수학이라는 학문 특유의 어려워 보이는 문법을 사용하긴 했지만 뜯어보면 별 거 없다. 이 정의에서 등장하는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span>는 정의역, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span>는 치역이라고 하며, 각각 정의역은 함수의 입력, 치역은 함수의 출력에 사용될 수 있는 값의 집합이라고 생각하면 된다.</p>\n<p>즉, 정의역은 함수의 인자로 사용되는 값들, 치역은 함수의 결과물로 사용되는 값들이라는 뜻이라고 봐도 무방하다.</p>\n<p>하지만 이 정의에서 가장 중요한 것은 정의역이니 치역이니 하는 개념이 아니라, 함수의 인자로 사용되는 값 하나에 대응하는 함수의 결과 값이 “유일하게 존재한다”라는 개념이다.</p>\n<p>어떤 값을 함수에 던지면 반드시 하나의 값을 반환하는 것, 이것이 본래 함수의 정의다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/33c48b0d809a227af542dee05cf064b5/80cfc/functions.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABNklEQVR42m2T207DMAyG3axt0tM6YBsgJC6QuNlASLvhqXggXoEX4zGK034GD7D0K4kPvx07ERE5Kk6KR0Uhi7SKF8U9OtNfK14Vz4pRfuQBXZMPSdFDYrLi3DqyLAHfTlE6fUIXBYdKscaQCTbok2VFGnQt/gUkl6ydsedsA4YctFdcucwmPdVnny22C8UNLcj+38xrKsv7HYSBcwAtyRtg5NFVPx8yagIqSBIBRmh9DfjYviE22jUi1fkK91wp/ENYYr8jZuTKAz5nldhgrJcFfQtuv6LCLf2ztbIBtrBvMNRk3PnJIR1Bg3tmeb1F19jkLLBw78omXDvC2pEm9zZtML38aeyb4mO+VvKNdhKx1QfFtPS0dEOiqnG+8kne9Qt9zk0Xmc5+yW95UsLDtHxZdV18vwAdIhBsPqNo7AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"functions\" title=\"\" src=\"/static/33c48b0d809a227af542dee05cf064b5/6af66/functions.png\" srcset=\"/static/33c48b0d809a227af542dee05cf064b5/69538/functions.png 160w,\n/static/33c48b0d809a227af542dee05cf064b5/72799/functions.png 320w,\n/static/33c48b0d809a227af542dee05cf064b5/6af66/functions.png 640w,\n/static/33c48b0d809a227af542dee05cf064b5/d9199/functions.png 960w,\n/static/33c48b0d809a227af542dee05cf064b5/21b4d/functions.png 1280w,\n/static/33c48b0d809a227af542dee05cf064b5/80cfc/functions.png 1844w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>오른쪽 그림처럼 정의역의 원소에 대응하는 치역의 원소가 없거나 2개 이상인 경우는<br>함수의 정의에서 벗어나게 된다</small>\n</center>\n<p>조금 더 편한 이해를 위해 인자로 받은 값에 2를 곱하는 간단한 함수를 생각해보자. 우리는 이런 함수를 정의할 때 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">f(x) = 2x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span></span></span></span></span>와 같은 식으로 나타낸다.</p>\n<p>이제 이 함수의 인자인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>를 1이라고 생각해보면 우리는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mo>×</mo><mn>1</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">f(1) = 2 \\times 1 = 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span></span>라는 결과를 얻을 수 있다. 만약 어느 날 갑자기 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">f(1) = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span>이 되어버린다면, 이 함수는 특정한 정의역의 원소에 맞대응되는 치역의 원소가 유일하지 않으므로 더 이상 함수라고 부를 수 없는 것이다.</p>\n<p>일반적으로 이야기하는 순수 함수의 특징들은 바로 이러한 수학적 함수의 성질에서 기원한다.</p>\n<h3 id=\"프로그래밍에서의-함수\" style=\"position:relative;\">프로그래밍에서의 함수<a href=\"#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98\" aria-label=\"프로그래밍에서의 함수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그러나 프로그래밍에서의 함수에는 이러한 제약이 전혀 없다. 이런 저런 예시를 들 것도 없이, 어떤 값도 반환하지 않는 <code class=\"language-text\">void</code>형 함수가 있지 않은가?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> y <span class=\"token operator\">=</span> x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">undefined</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>수학적인 함수의 정의로 비춰볼 때 이러한 <code class=\"language-text\">void</code>형 함수는 함수가 아니다. 정의역의 원소인 <code class=\"language-text\">x</code>와 맞대응하는 치역의 원소가 없기 때문이다. 그래서 프로그래밍에서의 함수라는 개념이 수학의 함수와 약간 다르다고 이야기하는 것이다.</p>\n<p>사실 프로그래밍의 함수는 수학의 함수에서 “어떤 값을 던져주면 뭔가를 계산한다”라는 개념만 들고 온 것에 불과하며, 수학적인 관점에서 바라보면 프로그래밍의 함수는 사실 함수가 아닌 경우가 더 많다.</p>\n<p>무엇보다 수학의 함수와 프로그래밍에서의 함수가 가장 큰 차이를 보이는 점은 바로 함수의 동작이 일관되지 않을 수 있다는 것이다.</p>\n<p>아까 예시로 들었던 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">f(x) = 2x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span></span></span></span></span>라는 수학의 함수는 내부 구현이 어떻게 되어있던 항상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>로 1을 받으면 2를 뱉어내는 것이 보장되어 있지만, 프로그래밍에서는 그렇지 않은 함수도 얼마든지 만들어 낼 수 있다.</p>\n<p>예를 들면 <code class=\"language-text\">Math.random</code>이라던가, <code class=\"language-text\">Date.prototype.getTime</code>과 같은 메소드들을 사용한 함수 같은 것들 말이다. 이 메소드들은 함수의 동작과 전혀 상관없는 값을 만들어내기 때문에, 함수의 연산이 이러한 값들에 종속되어 버린다면 개발자는 이 함수가 어떤 값을 뱉어낼 지 절대 예측할 수가 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sum</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token number\">5</span> <span class=\"token comment\">// ?</span>\n<span class=\"token number\">4</span> <span class=\"token comment\">// ?</span>\n<span class=\"token number\">9</span> <span class=\"token comment\">// ?</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이런 개념은 특정한 의미를 가지는 값들을 저장, 할당, 호출할 수 있는 프로그래밍의 세계에서만 존재하는 것들이며, 수학의 세계에서는 이런 개념 자체가 없다.</p>\n<p>이렇게 특정한 의미를 가지는 값들을 우리는 상태(State)라고 부른다. 상태는 프로그램의 현재 상황을 보여주는 좋은 역할도 하지만, 여기저기서 무분별하게 이 상태를 참조하거나 변경하는 경우, 개발자조차 현재 프로그램이 어떻게 돌아가는지 파악하기 힘든 슬픈 상황이 발생할 수도 있다.</p>\n<p>그래서 개발자들은 상태를 변경하는 행위에 특정한 규칙과 제약을 정해서 무분별한 상태 변화를 최대한 피하고, 이런 변화를 추적할 수 있는 상황을 선호한다.</p>\n<p>문제는 프로그래밍에서의 함수는 이런 상태들, 더 정확히 이야기하자면 함수 외부의 상태들과 뭔가 썸씽이 생기는 경우가 많다는 것이다. 여기 인자로 받은 수를 함수 외부에 선언된 변수와 더한 후 반환하는 <code class=\"language-text\">addState</code>라는 간단한 함수가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> state <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">addState</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> state <span class=\"token operator\">+</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">addState</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">4</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">addState</code> 함수는 자신 외부에 있는 <code class=\"language-text\">state</code>라는 값을 참조하여 자신이 인자로 받은 수를 더해주는 간단한 일을 한다.</p>\n<p>즉, 이 함수의 결과 값은 함수의 외부 상태인 <code class=\"language-text\">state</code> 변수에 종속되어 있다는 것이며, 이런 상황은 개발자가 함수의 동작을 예측할 수 없게 만드는 위험 요소로 작용할 수 있다.</p>\n<p>만약 다른 곳에서 <code class=\"language-text\">state</code> 변수의 값을 변경이라도 하면 상황은 더욱 꼬이기 시작할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">state <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">addState</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">11</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이전과 같은 함수에 같은 인자를 사용했지만, 결과값은 전혀 다르게 나왔다. 이 함수는 외부 상태의 변화에 따라 자신의 결과 값도 변경되기 때문에, 개발자는 이 함수의 동작을 전혀 예측할 수 없는 것이다.</p>\n<p>이렇게 함수가 함수 외부 상태에 영향을 받거나, 함수 외부 상태를 직접 변경하는 행위를 “사이드 이펙트(Side Effect)“라고 하며, 사이드 이펙트를 발생시키는 함수는 개발자가 예측하지 못한 버그를 발생시키는 위험 요소 중 하나이다.</p>\n<p>그런 이유로 자바스크립트와 같은 언어에서는 전역 변수의 선언 및 할당을 최대한 지양하는 컨벤션을 내놓기도 하며, React Hooks에서는 사이드 이펙트를 발생시키는 동작을 따로 구분하기 위해 <code class=\"language-text\">useEffect</code>라는 훅을 제공하기도 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">TestComponent</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">setItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'greeting'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Hi'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">removeItme</span><span class=\"token punctuation\">(</span><span class=\"token string\">'greeting'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">TestComponent</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>지금 이게 간단한 함수인데다가 의도적으로 연출한 상황이라 부자연스러워 보일 수도 있지만, 실제 어플리케이션에는 이거보다 훨씬 복잡하고 이상한 짓들을 하는 함수가 수두룩하다.</p>\n<p>예를 들면 API 서버와 통신한 결과물을 뱉어내는 간단한 함수 또한 순수하지 않은 함수의 일종이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getUsers</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/users'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> e<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>딱 봐도 <code class=\"language-text\">getUsers</code>는 호출할 때마다 항상 같은 값을 반환하는 함수는 아니다. 현재 데이터베이스의 상태에 따라 유저 리스트는 매번 달라질 수 있기 때문이다.</p>\n<p>이렇게 순수하지 않은 함수는 개발자가 함수의 결과를 예측하는 것이 불가능하기 때문에, 함수의 동작을 검사하는 테스트를 작성하는 것 또한 불가능하다. 애초에 아웃풋으로 뭘 내보낼 지도 감이 안오는 변덕스러운 녀석을 어떤 기준으로 검사한단 말인가?</p>\n<p>이렇듯 프로그래밍의 세계에서 이야기하는 함수는 수학의 함수보다 더 변수가 많고, 결과를 예측하기가 힘든 개념이다.</p>\n<h2 id=\"순수한-수학적-함수로-회귀하자\" style=\"position:relative;\">순수한 수학적 함수로 회귀하자<a href=\"#%EC%88%9C%EC%88%98%ED%95%9C-%EC%88%98%ED%95%99%EC%A0%81-%ED%95%A8%EC%88%98%EB%A1%9C-%ED%9A%8C%EA%B7%80%ED%95%98%EC%9E%90\" aria-label=\"순수한 수학적 함수로 회귀하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 이제 수학의 세계에서 말하는 함수와 프로그래밍의 세계에서 말하는 함수의 차이를 살펴보았으니, 다시 순수 함수의 정의를 가져와보자.</p>\n<blockquote>\n<ol>\n<li>동일한 인풋(인자)에는 항상 동일한 결과를 내야한다.</li>\n<li>함수 외부의 상태를 변경하거나, 외부의 상태에 영향을 받아서는 안된다.</li>\n</ol>\n</blockquote>\n<p>앞서 이야기 했듯이, 수학의 세계에서 함수는 단순히 인풋을 받으면 뭔가 계산을 해서 단 하나의 결과를 내는 개념이다.</p>\n<p>그리고 수학의 세계에는 뭔가 값을 저장해놓고 할당도 하고 호출할 수도 있는 상태라는 개념이 없으니, 함수가 함수 외부 상태에 영향을 주고 받는 사이드 이펙트라는 것도 당연히 존재할 수가 없다.</p>\n<p>즉, 수학에서의 함수를 프로그래밍에 그대로 적용하면 순수한 함수의 특성인 “함수의 결과는 함수의 인자에만 영향을 받는다”라는 조건과 “함수 외부의 상태를 변경하거나 영향을 받아선 안된다”라는 조건이 자연스럽게 충족되는 것이다.</p>\n<p>그리고 함수형 프로그래밍에서 이야기하는 불변성(immutable) 또한 수학과 맞닿아 있는 지점인데, 애초에 상태라는 개념이 존재하지 않는 수학의 함수를 프로그래밍으로 구현한 순수 함수를 사용하고 있으니, 상태를 변경한다는 개념 또한 없어야 하는 것이다.</p>\n<p>하지만 프로그래밍의 세계에는 엄연히 상태라는 개념이 존재하기 때문에, “함수의 인자를 직접 수정해서는 안된다”와 같은 제약들을 스스로 정의하고 지켜나갈 수 있도록 저런 개념을 명시적으로 이야기하는 것이다.</p>\n<p>또한 순수 함수를 사용함으로써 따라오는 장점들인 “테스트가 쉬워진다”, “참조 투명성이 보장된다”와 같은 이야기들도 수학적인 개념에서의 함수를 생각하면 사실 당연하기 그지 없는 이야기들이다.</p>\n<p>앞서 잠깐 이야기 했지만, 매번 다른 값이 나오는 함수에 대한 유닛 테스트를 짠다고 생각해보면 진짜 답이 없다. 애초에 개발자가 함수의 동작을 예측할 수 없으니 함수의 동작에 대한 모법 답안을 제시할 수도 없을 것이고, 당연히 테스트 작성도 불가능 하다.</p>\n<p>또한 순수 함수를 사용하면 참조 투명성이 보장된다는 말도 결국 우리가 수학에서 사용하고 있는 <code class=\"language-text\">=</code> 기호의 의미를 생각해보면 그렇게 특별한 말이 아니다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right\" columnspacing=\"\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mo>∴</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\nf(x) = 2x\\\\\n\\\\\nf(1) = 2\\\\\n\\\\\n\\therefore f(1) + 1 = 3\n\\end{aligned}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:7.5em;vertical-align:-3.5em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:4em;\"><span style=\"top:-6.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span></span></span><span style=\"top:-4.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"></span></span><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">2</span></span></span><span style=\"top:-1.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"></span></span><span style=\"top:-0.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mrel amsrm\">∴</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:3.5em;\"><span></span></span></span></span></span></span></span></span></span></span></span></div>\n<center>\n  <small>참조 투명성이라는 것은 $f(1)$(함수의 실행부)를 $2$(함수의 결과물)로 치환해도<br />계산 결과가 변하지 않는다는 것을 의미하는데, 애초에 우리는 예전부터 수학에서 그 개념을 사용하고 있었다</small>\n  <br />\n  <br />\n</center>\n<p>이렇듯 순수 함수는 어떤 인자를 사용했을 때 어떤 결과 값이 나올 지 동작을 예측할 수 있고, 상태라는 것을 아예 없애버린 개념이기 때문에, 개발자가 예측 가능한 어플리케이션을 개발하기 쉽게 만들어준다.</p>\n<p>또한 함수 자체가 함수 외부의 상태와 관계 없이 순수하게 단일한 연산에만 집중하고 있으니, 한 어플리케이션에서 선언한 순수 함수는 다른 어플리케이션에다가 가져다 붙혀도 반드시 동일한 동작을 한다는 것이 보장된다. 즉, 좋은 모듈화의 조건 중 하나인 “높은 응집도”에도 부합한다.</p>\n<p>이렇게 순수 함수를 사용하여 작성된 어플리케이션은 개발자가 구조와 동작을 쉽게 이해할 수 있기 때문에, 굳이 함수형 프로그래밍 패러다임이 아니더라도 전반적인 어플리케이션 설계에 꽤나 도움이 되는 개념이라고 할 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 처음 순수 함수라는 개념을 접했을 때 구글링과 다른 분들이 작성해주신 포스팅들을 통해 순수 함수의 특징, 장점, 단점 등을 먼저 접하게 되었는데, 당시에는 “또 새롭게 공부할게 나왔구만”이라는 생각이었다.</p>\n<center>\n  <div style=\"width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ec770d51e3153214eac6e428c748abbb/80e3c/study.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 113.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAECBAMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAfbjPCbFS86hpB//xAAcEAEAAgIDAQAAAAAAAAAAAAABAAIRIgMSMTL/2gAIAQEAAQUCvrURmScttj76ktTKURPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGBABAAMBAAAAAAAAAAAAAAAAEQEQIQD/2gAIAQEABj8CRsniJ202v//EABoQAQEAAwEBAAAAAAAAAAAAAAERACFBUXH/2gAIAQEAAT8hQlF4dz2h8cl2YJTqwM2io3OzBCpfuPSDunpgDf0rtwwmf//aAAwDAQACAAMAAAAQ7M8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8QKf/EAB0QAQACAwEAAwAAAAAAAAAAAAEAESExQWGBoeH/2gAIAQEAAT8QpGGti8i3Ae37AVU8OJVFeiG3V39RoErA9NvxLsE9hQU5GkhsIFAUZ7FabQBn/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"study\" title=\"\" src=\"/static/ec770d51e3153214eac6e428c748abbb/c08c5/study.jpg\" srcset=\"/static/ec770d51e3153214eac6e428c748abbb/0913d/study.jpg 160w,\n/static/ec770d51e3153214eac6e428c748abbb/cb69c/study.jpg 320w,\n/static/ec770d51e3153214eac6e428c748abbb/c08c5/study.jpg 640w,\n/static/ec770d51e3153214eac6e428c748abbb/80e3c/study.jpg 720w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>또 새로운 공부거리가 생겨버렸네...</small>\n  <br>\n  <br>\n</center>\n<p>사실 순수 함수와 같은 패러다임을 처음 접하게 되면 습관처럼 구글링을 통해 정보를 습득하고 공부를 하게 되는데, 이때 일반적으로 다른 사람들이 정리해놓은 포스팅을 보고 공부하게 되는 경우가 많았다.</p>\n<p>그러나 이렇게 공부를 하는 경우, 해당 패러다임의 근본적인 발생 이유나 원리에 대해서 깊이 파악하기 보다는 몇 가지 특징이나 장단점을 먼저 학습하게 되는 경우가 많았던 것 같다.</p>\n<p>그래서 순수 함수도 “새롭게 공부해야하는 것”이라는 느낌으로 받아들였었지만, 나중에 곰곰히 생각해보니 그냥 어릴 때 배웠던 수학적인 함수의 개념을 그대로 프로그래밍으로 구현한 것이라는 개념이라는 것을 깨닫고 꽤나 허무했던 기억이 있다.</p>\n<p>그래서 필자는 이 포스팅에서 “순수 함수는 이런저런 특징을 가진 함수”라고 설명하지 않았던 것이다. 개인적인 생각이기는 하지만, 대부분의 사람들은 어릴 때 이미 학교에서 함수에 대한 정의와 개념을 학습했기 때문에, “수학적인 함수”라는 키워드로 접근하는 것이 오히려 이해가 빠를 것이라고 생각했다.</p>\n<p>어쨌든 필자는 이 포스팅을 통해 순수 함수는 전혀 새로운 개념이 아니라는 이야기를 하고 싶었고, 대한민국 의무 교육을 받은 사람이라면 누구든지 다 익숙하게 받아들일 수 있는 개념이라는 것을 이야기하고 싶었다.</p>\n<p>물론 순수 함수를 사용하여 어떤 식으로 프로그램을 설계하는 것이 훌륭한 설계인지와 같은 이야기는 의무 교육과정에 없기 때문에 별도로 공부를 해야겠지만, 적어도 함수형 프로그래밍에서 중요한 키워드로 이야기하고 있는 순수 함수와 불변성에 대한 이해 정도는 그렇게 어려운 것은 아닐 것이라고 생각한다.</p>\n<p>다음 포스팅에서는 순수 함수와 함께 함수형 프로그래밍에서 중요한 개념 중 하나인 “불변성”에 대한 이야기를 해보려고 한다.</p>\n<p>이상으로 수학에서 기원한 프로그래밍 패러다임, 순수 함수 포스팅을 마친다.</p>","fields":{"slug":"20191229-about-pure-functions","path":"/2019/12/29/about-pure-functions/","lang":"ko"},"frontmatter":{"title":"수학에서 기원한 프로그래밍 패러다임, 순수 함수","subTitle":"순수 함수가 코드를 단순하게 만드는 이유","date":"Dec 29, 2019","categories":["프로그래밍","아키텍처"],"tags":["함수형 프로그래밍","Functional Programming","순수 함수","사이드 이펙트","Pure Functions","Side Effects"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/023de5bc6ce10c061b00421bd714ce0c/d803c/thumbnail.png","srcSet":"/static/023de5bc6ce10c061b00421bd714ce0c/d803c/thumbnail.png 320w,\n/static/023de5bc6ce10c061b00421bd714ce0c/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/023de5bc6ce10c061b00421bd714ce0c/fc5c5/thumbnail.webp 320w,\n/static/023de5bc6ce10c061b00421bd714ce0c/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/023de5bc6ce10c061b00421bd714ce0c/01fb2/thumbnail.png","srcSet":"/static/023de5bc6ce10c061b00421bd714ce0c/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/023de5bc6ce10c061b00421bd714ce0c/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"94d3d6f9-9057-528e-9d59-7fced49d84c6","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%EC%99%9C-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94\">함수형 프로그래밍을 왜 알아야하나요?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%86%92%EC%9D%80-%EC%88%98%EC%A4%80%EC%9D%98-%EC%B6%94%EC%83%81%ED%99%94\">높은 수준의 추상화</a></p>\n<ul>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%99%94%EC%9D%98-%EC%A0%95%ED%99%95%ED%95%9C-%EA%B0%9C%EB%85%90\">추상화의 정확한 개념</a></li>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%99%94%EC%9D%98-%EC%88%98%EC%A4%80%EC%9D%B4-%EB%86%92%EC%9C%BC%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EA%B1%B4%EA%B0%80%EC%9A%94\">추상화의 수준이 높으면 좋은 건가요?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%AA%85%EB%A0%B9%ED%98%95%EA%B3%BC-%EC%84%A0%EC%96%B8%ED%98%95%EC%9D%80-%EC%82%AC%EA%B3%A0-%EB%B0%A9%EC%8B%9D%EC%9D%B4-%EB%8B%A4%EB%A5%B4%EB%8B%A4\">명령형과 선언형은 사고 방식이 다르다</a></p>\n<ul>\n<li><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%A0%EA%B9%8C-%EB%AA%85%EB%A0%B9%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\">어떻게 문제를 해결할까? (명령형 프로그래밍)</a></li>\n<li><a href=\"#%EB%AC%B4%EC%97%87%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%A0%EA%B9%8C-%EC%84%A0%EC%96%B8%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\">무엇을 해결할까? (선언형 프로그래밍)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B3%BC-%ED%95%A8%EC%88%98%EB%A1%9C-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8\">객체로 이루어진 프로그램과 함수로 이루어진 프로그램</a></p>\n<ul>\n<li><a href=\"#%EB%8D%94-%EC%9E%91%EA%B2%8C-%EC%AA%BC%EA%B0%9C%EC%96%B4-%EC%83%9D%EA%B0%81%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\">더 작게 쪼개어 생각할 수 있다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"최근 많은 언어들이 함수형 프로그래밍 패러다임을 도입하며, 이에 대한 개발자들의 관심 또한 나날히 높아지고 있다. 필자 또한 “함수형 사고”라는 책을 읽으면서 기존의 패러다임과 사뭇 다른 함수형 프로그래밍에 대해 많은 관심을 가지게 되었던 기억이 있다.","html":"<p>최근 많은 언어들이 함수형 프로그래밍 패러다임을 도입하며, 이에 대한 개발자들의 관심 또한 나날히 높아지고 있다. 필자 또한 “함수형 사고”라는 책을 읽으면서 기존의 패러다임과 사뭇 다른 함수형 프로그래밍에 대해 많은 관심을 가지게 되었던 기억이 있다.</p>\n<!-- more -->\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9ef259e7b6e3fe6fc92d5652c070314f/9568a/functional_thinking_book.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAMEBQH/xAAXAQEBAQEAAAAAAAAAAAAAAAACAwAB/9oADAMBAAIQAxAAAAHkc9c1laBTxLxzVQj/AP/EABsQAAMBAQADAAAAAAAAAAAAAAECAwASERMx/9oACAEBAAEFAoy5l9PqOdj46bF1TRqUAu2ZiW//xAAXEQADAQAAAAAAAAAAAAAAAAABERIg/9oACAEDAQE/AZYx/8QAFREBAQAAAAAAAAAAAAAAAAAAASD/2gAIAQIBAT8BI//EABoQAAMAAwEAAAAAAAAAAAAAAAABESExQRD/2gAIAQEABj8CzslfmH0RHsiODbP/xAAbEAEBAQEBAAMAAAAAAAAAAAABEQAhMUFxof/aAAgBAQABPyEEb6Fmh+odfya7aPw+sAoVTzTZ8dmTwlvck8z2QXf/2gAMAwEAAgADAAAAECcHvv/EABkRAQACAwAAAAAAAAAAAAAAAAEAEBEhYf/aAAgBAwEBPxAehmexr//EABgRAQEAAwAAAAAAAAAAAAAAAAEAESFh/9oACAECAQE/ECu7HIi//8QAHhABAAIBBAMAAAAAAAAAAAAAAQARMSFBUXFhgdH/2gAIAQEAAT8QE0rAUs0PUXEfEswU2bzLgQVuuykrJwWK36iBgAgaDCtaxHjuGWu/D9iNZDP/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"functional thinking book\" title=\"\" src=\"/static/9ef259e7b6e3fe6fc92d5652c070314f/c08c5/functional_thinking_book.jpg\" srcset=\"/static/9ef259e7b6e3fe6fc92d5652c070314f/0913d/functional_thinking_book.jpg 160w,\n/static/9ef259e7b6e3fe6fc92d5652c070314f/cb69c/functional_thinking_book.jpg 320w,\n/static/9ef259e7b6e3fe6fc92d5652c070314f/c08c5/functional_thinking_book.jpg 640w,\n/static/9ef259e7b6e3fe6fc92d5652c070314f/6a068/functional_thinking_book.jpg 960w,\n/static/9ef259e7b6e3fe6fc92d5652c070314f/eea4a/functional_thinking_book.jpg 1280w,\n/static/9ef259e7b6e3fe6fc92d5652c070314f/9568a/functional_thinking_book.jpg 3024w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>재밌어서 여러 번 읽고 있는 귀여운 다람쥐 책</small>\n</center>\n<p>물론 이 책을 읽었다고 해서 함수형 프로그래밍을 자유롭게 할 수 있는 것은 아니다. 함수형 프로그래밍에서 사용하는 커링, 모나드, 고계 함수와 같은 개념와 기법들은 열심히 공부해서 이해하고 많이 써보면 금방 익숙해질 수 있는 것들이지만, 앞서 이야기했듯이 어떤 패러다임을 사용하여 프로그램을 제대로 설계하기 위해서는 말 그대로 사고 방식 자체를 바꿔야하기 때문이다.</p>\n<p>그런 이유로 이번 포스팅에서는 함수형 프로그래밍의 스킬들보다는 함수형 프로그래밍이 왜 이렇게 각광받는지, 또 이 패러다임이 어떤 개념들을 사용하여 프로그램을 바라보고 있는지에 대한 이야기를 해보려고 한다.</p>\n<h2 id=\"함수형-프로그래밍을-왜-알아야하나요\" style=\"position:relative;\">함수형 프로그래밍을 왜 알아야하나요?<a href=\"#%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%EC%99%9C-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"함수형 프로그래밍을 왜 알아야하나요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 객체지향적 사고와 명령형 프로그래밍을 사용하기만 해도 왠만한 프로그램을 설계하고 작성하는 데는 무리가 없다. 우리는 이미 몇십 년간 이러한 사고방식으로 거대한 프로그램을 만들어왔지 않은가?</p>\n<p>그러나 함수형 프로그래밍이 이렇게 주목받는 이유는 분명 기존의 그것들과는 분명한 차이가 있기 때문이고, 그 차이로 인해 개발자들이 조금 더 생산성있는 프로그래밍을 할 수 있기 때문일 것이다.</p>\n<p>그렇다면 도대체 함수형 프로그래밍의 어떤 점이 개발자들의 마음을 움직였던 것일까?</p>\n<p>뭐 개발자마다 각자 다른 이유들을 가지고 있겠지만, 일단 필자가 느꼈던 함수형 프로그래밍의 대표적인 장점은 바로 이런 것들이다.</p>\n<blockquote>\n<ol>\n<li>높은 수준의 추상화를 제공한다</li>\n<li>함수 단위의 코드 재사용이 수월하다</li>\n<li>불변성을 지향하기 때문에 프로그램의 동작을 예측하기 쉬워진다</li>\n</ol>\n</blockquote>\n<p>아마 함수형 프로그래밍에 대해 설명하는 다른 블로그 포스팅이나 책들을 봐도 비슷한 점을 함수형 프로그래밍의 장점으로 이야기하고 있을 것이다.</p>\n<p>이 장점들 중에서 불변성에 대한 것은 함수형 프로그래밍 자체의 장점이라기보다는 순수 함수(Pure Functions)를 사용함으로써 자연스럽게 따라오는 장점에 가깝기 때문에, 여기에 대한 이야기는 추후 순수 함수에 대한 설명을 할 때 다시 이야기하도록 하고, 이번 포스팅에서는 높은 수준의 추상화와 함수 단위의 재사용이라는 키워드에 대해 초점을 맞춰서 이야기해보려고 한다.</p>\n<h2 id=\"높은-수준의-추상화\" style=\"position:relative;\">높은 수준의 추상화<a href=\"#%EB%86%92%EC%9D%80-%EC%88%98%EC%A4%80%EC%9D%98-%EC%B6%94%EC%83%81%ED%99%94\" aria-label=\"높은 수준의 추상화 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>기본적으로 함수형 프로그래밍은 선언형 프로그래밍의 특성을 함수들의 조합을 사용하여 구현하는 패러다임이고, 선언형 프로그래밍의 대표적인 장점 중 하나가 바로 명령형 프로그래밍이나 객체지향 프로그래밍에서 사용하는 방법들보다 높은 수준의 추상화를 통해 개발자가 문제 해결에만 집중할 수 있게 해준다는 점이다.</p>\n<p>선언형 프로그래밍이 제공한다는 높은 수준의 추상화라는 것이 정확히 무엇을 의미하는 것이고 어떤 장단점이 있는지 이해하기 위해 먼저 추상화에 대한 개념적인 정리가 먼저 필요할 것 같다.</p>\n<h3 id=\"추상화의-정확한-개념\" style=\"position:relative;\">추상화의 정확한 개념<a href=\"#%EC%B6%94%EC%83%81%ED%99%94%EC%9D%98-%EC%A0%95%ED%99%95%ED%95%9C-%EA%B0%9C%EB%85%90\" aria-label=\"추상화의 정확한 개념 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>아마 객체지향 프로그래밍을 알고 있는 분들이라면 추상화가 현실에 존재하는 무언가의 특징을 뽑아내어 정리하는 행위라고 이야기할지도 모르겠다. 뭐 이것도 틀린 말은 아니고, 객체지향 프로그래밍을 처음 공부할 때는 이렇게 이해하는 것이 더 편하기도 하다.</p>\n<p>하지만 사실 추상화라는 단어의 근본적인 의미는 단순히 객체의 특징을 정리하여 클래스를 정의하는 것보다 훨씬 넓은 범위의 개념이다.</p>\n<p>추상화의 근본적인 의미는 어떤 작업을 수행할 때 그 이면에 존재하는 복잡한 것들을 간단한 것처럼 보이게 만들어주는 것들에 가깝다. 객체지향 프로그래밍에서 객체를 추상화하여 클래스를 정의하는 행위 또한 근본적으로는 이 정의에 부합한다.</p>\n<p>자, 이름을 가지고 있고 자신의 이름을 말할 수 있는 사람을 추상화한 <code class=\"language-text\">Human</code> 클래스를 사용하여 객체를 생성하고 메소드를 사용한다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hello, I am </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">.</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> me <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Human</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Evan'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>me<span class=\"token punctuation\">.</span><span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Hello, I am Evan.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 중요한 사실이 하나 있다. 대부분의 경우 우리가 직접 클래스도 만들고 객체도 만들기 때문에 쉽게 지나치는 사실이지만, 사실 <code class=\"language-text\">Human</code> 클래스가 어떻게 구현되었는지 전혀 모르는 상태라도 이 클래스를 사용하여 객체를 생성하고 메소드를 사용하는데는 아무 문제가 없다는 것이다.</p>\n<p>그냥 이 클래스가 외부로 노출하는 기능이 무엇인지만 알고 있으면 객체를 생성하고 메소드를 호출하여 원하는 동작을 이끌어낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">constructor</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Human<span class=\"token punctuation\">;</span>\n  <span class=\"token function-variable function\">say</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>객체지향 프로그래밍에서는 사용자에게 높은 수준의 추상화를 제공하기 위해 <code class=\"language-text\">public</code>, <code class=\"language-text\">private</code>과 같은 접근 제한자를 사용하여 클래스 외부로 노출시키고 싶은 것만 노출시키는 캡슐화라는 기법을 사용한다.</p>\n<p>또한 클래스 외에 일반적으로 우리가 사용하는 라이브러리들도 일종의 추상화된 모듈이라고 할 수 있다.</p>\n<p>만약 우리가 React나 RxJS와 같은 라이브러리를 사용할 때 해당 라이브러리의 구현체를 전부 파악해야만 사용할 수 있다면 굉장히 힘들것이다. 그러나 우리는 라이브러리의 구현 소스를 일일히 파악하지 않더라도 공식 문서를 통해 기능을 파악하기만 한다면 일단 사용하는 데는 별 지장이 없다. <small><del>(잘 쓰려면 봐야한다는 게 함정)</del></small></p>\n<p>그리고 우리가 프로그램을 작성할 때 유용하게 사용하고 있는 OS API나 브라우저 API와 같은 API들도 일종의 추상화된 기능 리스트이다. 이런 추상화된 기능 리스트가 있기에 우리는 어떤 API가 어떤 동작을 하는 지만 알고 있다면, 로우 레벨의 동작을 직접 다루지 않더라도 컴퓨터에게 편하게 명령을 내릴 수 있는 것이다.</p>\n<center>\n  <div style=\"width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d9fa4d13c36832f6cdcfb84a4637551c/37523/abstraction.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 97.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADOElEQVR42q3PXWgTWRQH8OsXorARNQEf3AcxWvBNir5pcAvqUlvjJ21Nqijqrk8u+iZSQdBVsBUEl+2DrtraSVPqR5tQ20lMWtu0ySSdTCbz0Ta1aTOp6ColutZA4tmTYSuzaSoVvPCbc+89/3u5Q0jhseC/WoQOoq3oGFqX1//msQytMRqN67Ea0BLyHcaCkpKSzcXFxfO87NChRXMymRbnLty2c+ePxt27l5KamoVfzc/ndbnPPpNp7an5vlBfWrlBb7ZuLGR1+ZEinanMuGbLtu2rfirfpN9/bM6socxiVP/IsO8o6PdapvV7rWktA1pZdiRttPyS3vHbhfS6qlPq2pCXU5mtnwxm62fDfusussJcDbrSyoxuTyVorSirguU/H4ai6jNgvngF1ltOq+vcfn5Wt6ciqyu3wA+lFeXkxLU/7XM5jqou37IfvnTTbsH6tezJ6/VUTX3rRnLr6Quoa6GzdS0u0Lphp6G+/QU8pBn4q6MfHnT64fZjL9Tifn62tsWV+cPhg3ttfWfJ1QZH+vdG59TVRmdK60qDI1XX3JW6296Tqn/qTd3BWmvrVPcLZKeuPezI3HcO/ErsdNDXTDN9+SjU0OHvu+/0oX5Vbk11zs7aupjeFjrE+HyxA+TRgAw2D5u1ecMwo8nDQptPBA87Cq7QCNAoN/eER6G1lwcK+9o85WUzbUwMHL3iOdLY6X+NEo1dfmVGA7K5GOVJd1h55A0rrR4WDSpPcE7RAbWvzeP5iSaaedvREz1O3AGZd/nlMOK06AGJe+aLcnS/oM5pPxoQuPxcjjswxOI9cpAdryCB0TfQzY9le6Jx+EIYBy83Cu2eADi6g+DwBqHN7QdnTwi6Iy/hf1mE5zOh+DtgxMQ54maGRDcjR54zMj9LQOLdfpGn+5GPxyrgvjQr5w7KnJcZGmZC41UkIiXjvJQcQTGtiKjEBvl4jI2OqyJiIsYJiVh+Ts1KyWFeTiqCkKwmb/8BmHj9MZt4Mw0zlL8/QXzyPQQGh4FhEdYgOwKD/BjEX31Q+9o8ns9MTQOMJT6cJ1FpsjkqvWrixSRVCCcoFCcqVFiYUOeFMlEp2ZS7h5cnt/4L+y9SOB3xvXcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"abstraction\" title=\"\" src=\"/static/d9fa4d13c36832f6cdcfb84a4637551c/6af66/abstraction.png\" srcset=\"/static/d9fa4d13c36832f6cdcfb84a4637551c/69538/abstraction.png 160w,\n/static/d9fa4d13c36832f6cdcfb84a4637551c/72799/abstraction.png 320w,\n/static/d9fa4d13c36832f6cdcfb84a4637551c/6af66/abstraction.png 640w,\n/static/d9fa4d13c36832f6cdcfb84a4637551c/37523/abstraction.png 720w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>추상화된 OS API만 안다면 하드웨어 구조를 모르더라도 프로그램을 만들 수 있다</small>\n  <br>\n  <br>\n</center>\n<p>만약 개발자가 아닌 분이라면 여러분이 평소에 사용하는 일반적인 프로그램을 생각해보면 된다.</p>\n<p>예를 들어 여러분이 포토샵을 사용하여 컬러 사진을 흑백 사진으로 변경한다고 생각해보자. 포토샵은 이미지 프로세싱이라는 복잡한 연산을 수행하는 프로그램이지만, 우리는 포토샵이 제공하는 여러가지 기능들을 사용하여 사진 보정이라는 행위에만 집중할 수 있다.</p>\n<p>실제로 컬러 사진을 흑백 사진으로 변경할 때는 행렬로 이루어진 사진의 픽셀 데이터를 순회하며 RGB 값의 평균을 내거나하는 등의 과정을 수행해야한다. 하지만 그런 복잡하고 귀찮은 과정이 추상화되어있기 때문에 사용자는 그저 포토샵이 외부로 노출해준 기능인 “Image > Adjustments > Desaturate”을 사용하면 되는 것이다.</p>\n<p>즉, 추상화란 복잡한 무언가에서 핵심적인 개념이나 기능을 간추려내어 단순하게 만드는 것을 의미하며, 추상화가 잘 되어있는 프로그램을 사용하는 사용자는 자신과 맞닿은 추상 계층 밑에 무엇이 있고 어떻게 작동하는지 모르더라도 해당 기능을 편하게 사용할 수 있다.</p>\n<h3 id=\"추상화의-수준이-높으면-좋은-건가요\" style=\"position:relative;\">추상화의 수준이 높으면 좋은 건가요?<a href=\"#%EC%B6%94%EC%83%81%ED%99%94%EC%9D%98-%EC%88%98%EC%A4%80%EC%9D%B4-%EB%86%92%EC%9C%BC%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EA%B1%B4%EA%B0%80%EC%9A%94\" aria-label=\"추상화의 수준이 높으면 좋은 건가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>방금 알아본 바와 같이 추상화란, 복잡한 무언가를 단순해보이도록 만들어주는 행위를 의미한다. 즉, 추상화의 수준이 높다는 것은 복잡한 것을 단순해보이도록 만드는 행위 자체의 수준이 높아졌다는 것을 의미하는 것이다.</p>\n<p>그런 의미에서 보면 확실히 추상화의 수준이 높을 수록 사용자가 편하긴 하다. 이 편하다는 의미가 잘 감이 안오시는 분들을 위해 더 쉽게 이야기해보면, 우리가 사용하는 프로그래밍 언어를 예시로 들어볼 수 있겠다.</p>\n<p>우리는 프로그램을 만들 때 <code class=\"language-text\">0</code>과 <code class=\"language-text\">1</code>로 이루어진 기계어를 사용할 수도 있고, 어셈블리를 사용할 수도, 자연어에 가까운 고급 언어인 자바를 사용할 수도 있다.</p>\n<p>만약 길가는 개발자를 붙잡고 “기계어로 코딩할래? 어셈블리로 코딩할래?”라고 묻는다면 기계어로 코딩하고 싶다는 변태는 거의 없을 것이다. 기계어는 거의 추상화되지 않은 날 것이나 마찬가지이기 때문에 사람이 이해하기 너무 어렵기 때문이다.</p>\n<p>또한 “어셈블리로 코딩할래? 자바로 코딩할래?”라고 물어본다면 어셈블리라고 대답하는 변태 또한 그렇게 많지 않을 것이다. 이 경우에는 어셈블리가 자바에 비해 추상화 수준이 매우 낮기 때문에, 자바로 코딩하는 것이 사람에게는 더 편한 것이다. 이게 바로 대표적인 추상화 수준의 차이이다.</p>\n<p>어셈블리로 거대한 프로그램을 작성하게 되면 개발자가 신경써줘야하는 것이 너무나도 많지만, 자바를 사용하면 <code class=\"language-text\">for</code>, <code class=\"language-text\">if</code> 등의 문법과 다양한 API를 사용하고 조합하여 프로그램을 작성함으로써 어셈블리보다 좀 더 편하게 프로그래밍 할 수 있다. 메모리에 값을 할당하고 레지스터로 모았다가 다시 빼내고하는 잡다한 일은 JRE(Java Runtime)가 다 알아서 해줄 것이기 때문이다.</p>\n<p>이렇게 예전의 기술보다 높은 수준의 추상화를 제공하며 사용자에게 편의를 안겨주는 경우는 함수형 프로그래밍이 처음이 아니고, 오히려 컴퓨터 공학 역사에서 굉장히 빈번하게 발생되었던 일이다. 이렇게 기술이 발전하며 추상화 수준을 높혀감으로써 점점 더 복잡한 프로그램을 만들 수 있게 되는 것이다.</p>\n<p>그러나 추상화의 수준이 높다는 것이 장점만 있는 것은 아니다. 이런 높은 추상화를 장점으로 내세우는 기술이 발표되면 높은 확률로 “성능이 안 좋다”, “이렇게 추상화해버리면 최적화는 어떻게 하냐”와 같은 논란에 휩싸이게 되는데, 이런 논란에 휩쓸렸던 대표적인 친구들이 바로 Java나 Garbage Collector이다. <small>(그리고 어셈블리가 있다…)</small></p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 490px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/80458efa897102920b95181e9337ff64/41d3c/von_neumann.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 130.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAIAAAA44esqAAAACXBIWXMAAA7zAAAO8wEcU5k6AAAElUlEQVR42i2UWSyeWxSGv0NKDX9pY55V1VzzUDUrLS1qlqJBBQklhqopjTGEqKHEXI2QiLlucEUI0gukKgTpkVAhgkQi4krO8/vPd7Gzs7/97vWud71rCdbW1g8fPjQxMXFwcHBycvL29vb39w8KCoqPj09MTHz79m10dPSbN2+eP3/+9OlTyR0+d3f3gIAAwdDQUENDw8DAwMLCwsXFxc/Pj9OQkJCkpKTs7Oz09HSeCA8PB/zs2TNHR0dXV1c3NzdPT8+XL18KqqqqsrKyKioq4O3t7bn06tWryMjIjIyMzMzMhISEmJiYuLi4sLAwCR4YG2KIwQ8ePJCRkZGXl1dWVjY3N/fy8iIymJycHEtLS2dnZ/bctrGx4TYZsff19ZUQFMD8c/tJSUlpa2vzmzw/f/5cWFiYnJw8Ojr69+/frq6u+/fvk2BwcDBgdAEfGBgo3Lt3TxAEwKwwJ71Pnz719va2tLTMzc3t7OycnZ1dXFyQPxfQDPF8fHwkov4PJiyrra1tdXX14ODg2NjY2tra/v7+8fHx5eXlzc3Nr1+/UBSaoaGhyPn69WtUEBQUFIDduXOHlSeXlpbm5+cBHx4eQvjo6Oj6+vrq6ur8/DwqKgqCSEA6KEoJBTk5OWCKiopKSkqksb6+Pjk52dnZ+fv37z9//vx7++3t7fEQGKQtKioqKCigkLGxseLI0tLSFExHRwdKXBoYGGhoaIDn5uYmyIODg93d3e3tbfTX09Orq6srKyvLz89PS0sTCEgmjx8/trKyghLR2tvbkQ3BpqenGxsbCUKd+/v7W1tbEYy1qqoKUfPy8gRdXV0jIyO8Rd3ev38/MTGBMT08PCSADx8+UBuCoMKPHz8wXHNzM6J+/PgxNzdXQEOM9eLFi3fv3vHYysrKly9furu729raxsfHyXZjYwPaJycnQ0NDPDEyMlJRUQEY/wm4HMchXVZWFqc/f/6Edl9fH5qR9tbWFitCLC4u4pyvX79+//69tLSUsotzxuh4DZLo8e3bN+LMzs729PSwJ3h5eTlv4RbCwnN4eJhDCJIgEIEWob9oA55EJGCrq6uoXVNTAxHsifgo1NHRgXIlJSWETU1NpS7ixrCzs4MPrqLdMLCZmRn3oMch9SA3GPEKKy4gRzoHb2FvgMLCwsLU1JS6ujpWEYlE1IxL9AYkERaFuYAf0JmuAMzY4ALBMbmAMAwDicloT3qD4KampikpKeiPmahccXExmdNz9DOlhjNpV1ZWiqNJvE1L4zMJmEOctLy8zCEvnp6ekqqamhpzgrBki53QUmwSkAwT4rMHzAoGhihH32J+hKyvrycsVHEECZM2dASmh6amJjF5mGGI29ijHM8h0szMDP5tamqqra0FTDOSC/3IHvMJGJM0IiIijI2NmTVEZp7x0JMnT2h3eGppaaE8daKonEiGKb5ktgnswOA1xIQPBaMGTC/JrKSBoUaeVIG/3KGT8RUxiCpQBmISgfJAQTLl0IwOBUwDIxjThrblUV6EM8MMIWAn0EAMfWoDHpH4ARKq9LlkpRYgWZFGX1//0aNHd28/kUj0Hzx0J4PMGZytAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"von neumann\" title=\"\" src=\"/static/80458efa897102920b95181e9337ff64/41d3c/von_neumann.png\" srcset=\"/static/80458efa897102920b95181e9337ff64/69538/von_neumann.png 160w,\n/static/80458efa897102920b95181e9337ff64/72799/von_neumann.png 320w,\n/static/80458efa897102920b95181e9337ff64/41d3c/von_neumann.png 490w\" sizes=\"(max-width: 490px) 100vw, 490px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>\n    존 폰 노이만 (1903 ~ 1957)<br>\n    괜히 어셈블리 같은 걸 만들어서 컴퓨터 성능 낭비하지 말라고 하신 분\n  </small>\n</center>\n<p>자바의 경우에는 바이트 코드와 JVM(Java Virtual Machine)이라는 개념을 사용하여 한번만 코드를 작성해도 모든 OS에서 동작하는 프로그램을 작성할 수 있다는 점이 굉장한 강점이었다. OS나 CPU에 종속되어있던 기존의 프로그래밍 언어들에 비해 추상화 수준이 높아진 것이다. 그러나 처음 자바가 나왔을 당시에는 C에 비해서 너무 느려서 못 써먹을 물건이라고 상당히 많이 까였다.</p>\n<p>또한 가비지 컬렉터도 개발자가 일일히 메모리를 할당하고 해제하지 않아도 되는 편리함을 제공하지만 GC가 객체의 메모리 해제 시점을 매번 추적하고 있어야하는 성능 문제나, 개발자가 객체가 메모리에서 해제되는 시점을 정확히 알기 어렵다던가, <a href=\"https://ko.wikipedia.org/wiki/%EC%B0%B8%EC%A1%B0_%ED%9A%9F%EC%88%98_%EA%B3%84%EC%82%B0_%EB%B0%A9%EC%8B%9D\" target=\"_blank\" rel=\"nofollow\">참조 횟수 계산 방식</a>을 사용할 때 순환 참조 객체를 해제하지 못하는 등 문제들이 여전히 존재하기 때문에 늘 완벽하게 동작하지는 않는다.</p>\n<p>하지만 그렇다고 자바나 가비지 컬렉터나 자바를 사용할 수 있는 환경에서 굳이 C를 사용하고 수동으로 메모리를 관리하고 싶어하는 사람이 많지는 않을 것이다. 애초에 이런 높은 수준의 추상화를 제공하는 기술이 가지는 성능 상의 단점을 머신이 어느 정도 커버할 수 있기 때문에 사람들이 많이 사용하는 것이기도 하다.</p>\n<p>함수형 프로그래밍도 높은 수준의 추상화를 지향하는 패러다임인 만큼 어느 정도 성능 면에서 불리한 점이 있긴 하다. 사실 함수 단위로 프로그램을 추상화하는 개념은 1958년에 <a href=\"https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%ED%94%84\" target=\"_blank\" rel=\"nofollow\">LISP</a>가 발표되었을 때부터 시작되었지만, 당시에는 아마 이런 개념이 사치로 느껴졌을 것이다. 메모리가 너무 부족해서 당장 작업 하나 하기도 빡센 데 추상화는 무슨 추상화란 말인가.</p>\n<p>그러나 요즘 머신의 성능은 함수형 프로그래밍이 지향하는 추상화 레벨을 충분히 커버할 수 있을 정도로 예전에 비해 많이 좋아졌기 때문에 성능에 관한 문제는 크게 중요하지 않다고 느껴진다.</p>\n<p>그리고 만약 성능이 진짜 중요한 프로그램을 작성할 때는 굳이 함수형 프로그래밍을 고집하지 않아도 된다. 애초에 이런 패러다임은 어떤 정답이라고 할 게 없기 때문이다. 지금도 최적화를 위해 C나 어셈블리를 사용하는 경우가 있는 것처럼, 함수형 프로그래밍도 상황에 따라 적재적소에 잘 사용하면 된다.</p>\n<p>그럼 함수형 프로그래밍이 제공하는 높은 수준의 추상화가 우리에게 어떤 형태로 나타나는지 알아보기 위해, 기존에 우리에게 익숙한 패러다임인 명령형 프로그래밍과 함수형 프로그래밍의 상위 개념인 선언형 프로그래밍을 한번 비교해보도록 하자.</p>\n<h2 id=\"명령형과-선언형은-사고-방식이-다르다\" style=\"position:relative;\">명령형과 선언형은 사고 방식이 다르다<a href=\"#%EB%AA%85%EB%A0%B9%ED%98%95%EA%B3%BC-%EC%84%A0%EC%96%B8%ED%98%95%EC%9D%80-%EC%82%AC%EA%B3%A0-%EB%B0%A9%EC%8B%9D%EC%9D%B4-%EB%8B%A4%EB%A5%B4%EB%8B%A4\" aria-label=\"명령형과 선언형은 사고 방식이 다르다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>명령형 프로그래밍은 문제를 “어떻게 해결해야 하는지” 컴퓨터에게 명시적으로 명령을 내리는 방법을 의미하고, 선언형 프로그래밍은 “무엇을 해결할 것인지”에 보다 집중하고 어떻게 문제를 해결하는 지에 대해서는 컴퓨터에게 위임하는 방법을 의미한다.</p>\n<p>처음 프로그래밍이라는 개념이 등장했을 때부터 비교적 최근까지도 우리는 컴퓨터에게 명시적으로 명령을 내리는 방법인 명령형 프로그래밍을 주로 사용해왔지만, 함수형 프로그래밍은 문제를 해결하는 방법에 더 집중하고 사소한 작업은 컴퓨터에게 넘겨버리는 선언형 프로그래밍의 일종이다.</p>\n<p>이처럼 컴퓨터에게 사소한 작업들을 위임해버리는 패러다임의 특성 상, 선언형 프로그래밍에는 필연적으로 “높은 수준의 추상화”라는 키워드가 따라오는 것이다. 추상화 수준이 낮다면 저 사소한 작업들을 개발자가 일일히 다 컨트롤해줘야한다는 이야기니 말이다.</p>\n<p>자, 그럼 명령형 프로그래밍과 선언형 프로그래밍을 사용하여 문제를 해결하는 과정을 비교해보며 이 두 패러다임 간의 추상화 수준의 차이에 대해서 한번 살펴보도록 하자. 우리가 해결해야하는 문제는 바로 이것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'evan'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'joel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'mina'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<blockquote>\n<p>배열을 순회하며 빈 문자열을 걸러내고, 각 원소의 첫 글자를 대문자로 변경해라.</p>\n</blockquote>\n<h3 id=\"어떻게-문제를-해결할까-명령형-프로그래밍\" style=\"position:relative;\">어떻게 문제를 해결할까? (명령형 프로그래밍)<a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%A0%EA%B9%8C-%EB%AA%85%EB%A0%B9%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"어떻게 문제를 해결할까 명령형 프로그래밍 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>명령형 프로그래밍은 말 그대로 컴퓨터에게 어떻게 작업을 수행할 지에 대한 자세한 명령을 내리는 것이다. 더 정확히 말하자면, 어떻게 문제를 해결하는지 일일히 명령을 내리면서 내가 원하는 결과를 만들어나가는 방식이라고 할 수 있다.</p>\n<p>사실 오늘날 현업에서 일하고 있는 대부분의 개발자는 처음 프로그래밍을 접할 때 전통적인 패러다임인 명령형 프로그래밍으로 공부를 시작했던 경우가 많기 때문에, 필자를 포함한 많은 개발자들에게 익숙한 방법이라고도 할 수 있다.</p>\n<p>대부분의 개발자는 이런 문제를 만났을 때, <code class=\"language-text\">for</code>문과 같은 반복문을 사용하여 순차적으로 배열의 원소를 탐색하고 작업하는 코드를 떠올릴 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> newArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    newArr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 <code class=\"language-text\">for</code>문을 사용하여 특정 행위를 반복하는 코드를 작성하는 일은 눈 감고도 작성할 수 있을 정도로 개발자들에게 익숙한 로직이지만, 너무 익숙한 나머지 이 짧은 코드 안에도 많은 명령이 들어가 있다는 사실을 간과하고는 한다.</p>\n<p>필자가 위 코드를 작성할 때 필자가 떠올렸던 생각을 대충 정리해보자면 이런 느낌이다.</p>\n<blockquote>\n<ol>\n<li>변수 <code class=\"language-text\">i</code>를 <code class=\"language-text\">0</code>으로 초기화</li>\n<li><code class=\"language-text\">i</code>가 <code class=\"language-text\">arr</code> 배열의 길이보다 작다면 구문을 반복 실행</li>\n<li><code class=\"language-text\">for</code>문 내부의 코드의 실행이 종료될 때마다 <code class=\"language-text\">i</code>에 <code class=\"language-text\">1</code>씩 더함</li>\n<li><code class=\"language-text\">arr</code> 배열의 <code class=\"language-text\">i</code> 번째 원소에 접근</li>\n<li>만약 원소의 길이가 <code class=\"language-text\">0</code>이 아니라면 원소의 첫 번째 글자를 대문자로 변경</li>\n<li>이렇게 합쳐진 문자열을 <code class=\"language-text\">newArr</code> 배열에 삽입</li>\n</ol>\n</blockquote>\n<p>필자가 코드를 작성할 때 생각했던 사고의 흐름은 필자가 컴퓨터에게 내려야하는 명령과 정확하게 매칭된다.</p>\n<p>즉, 필자는 <code class=\"language-text\">i</code>라는 상태를 직접 관리해야하며, 매 루프 때마다 <code class=\"language-text\">i</code>에 1을 더 해가면서 배열의 어느 인덱스까지 탐색했는지도 신경써줘야 하는 상황인 것이다. 게다가 배열의 원소에 접근할 때도 <code class=\"language-text\">i</code>를 사용하여 직접 접근 명령을 내려야하고 이 원소가 빈 문자열인지 아닌지 여부도 검사해줘야한다.</p>\n<p>이렇게 컴퓨터에게 일일히 명령을 내려서 자신이 원하는 결과를 만들어가는 과정을 통해 프로그램을 작성하는 방식을 명령형 프로그래밍이라고 하는 것이다.</p>\n<p>자 이 쯤에서 우리가 해결해야하는 문제를 다시 한번 보자.</p>\n<blockquote>\n<p>배열을 순회하며 빈 문자열을 걸러내고, 각 원소의 첫 글자를 대문자로 변경해라.</p>\n</blockquote>\n<p>저 명령들을 쭉 읽어보고 바로 이 문제를 떠올릴 수 있을까? 물론 이 문제는 굉장히 간단한 문제이기 때문에 바로 알아챌 수도 있겠지만, 이 문제보다 더 복잡한 문제라면 아마 몇 번은 읽어보고 그림도 그려봐야하지 않을까?</p>\n<p>즉, 명령형 프로그래밍은 사람이 생각하는 방식보다 컴퓨터가 생각하는 방식에 가깝기 때문에 그리 인간 친화적인 방식은 아니다. 그렇기 때문에 개발자들은 알고리즘 문제 풀이 등을 통해 이런 방식의 사고를 하는 것을 꾸준히 연습하기도 한다.</p>\n<p>자, 그럼 선언형 프로그래밍으로 같은 일을 수행하는 코드를 작성하면 어떻게 바뀔까?</p>\n<h3 id=\"무엇을-해결할까-선언형-프로그래밍\" style=\"position:relative;\">무엇을 해결할까? (선언형 프로그래밍)<a href=\"#%EB%AC%B4%EC%97%87%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%A0%EA%B9%8C-%EC%84%A0%EC%96%B8%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"무엇을 해결할까 선언형 프로그래밍 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>반면 선언형 프로그래밍은 컴퓨터에게 “나 이거 할거야!”라고 알려주기만 하는 느낌이다. 잡다한 일 처리는 컴퓨터가 알아서 하도록 위임해버리고 개발자는 문제 해결을 위해 무엇을 할 지만 신경쓰면된다.</p>\n<p>즉, 함수형 프로그래밍은 이런 선언형 프로그래밍의 특성을 함수를 통해 구현하게되는 패러다임이라고 할 수 있는 것이다. 그럼 방금 전과 같은 문제를 선언형 프로그래밍을 사용하여 구현해보도록 하자.</p>\n<blockquote>\n<p>배열을 순회하며 빈 문자열을 걸러내고, 각 원소의 첫 글자를 대문자로 변경해라.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> newArr2 <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> v<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 코드에서 사용된 <code class=\"language-text\">filter</code> 메소드는 배열을 순회하며 콜백 함수의 반환 값이 참이 아닌 원소를 걸러낸 새로운 배열을 생성 후 반환하는 역할을, <code class=\"language-text\">map</code> 메소드는 배열을 순회하며 콜백 함수의 반환 값을 사용한 새로운 배열을 생성한다.</p>\n<p>이 코드를 작성할 때 필자의 사고의 흐름은 다음과 같았다.</p>\n<blockquote>\n<ol>\n<li>인자로 받은 문자열의 첫 글자만 대문자로 변경하는 함수를 선언</li>\n<li><code class=\"language-text\">arr</code> 배열에서 원소의 길이가 0이 아닌 것들을 걸러냄</li>\n<li>걸러진 배열을 순회하면서 1번에서 선언한 함수를 사용하여 원소의 첫글자를 대문자로 변경</li>\n</ol>\n</blockquote>\n<p>분명 같은 작업을 수행하는 코드를 작성했지만 사고의 흐름이 많이 다른 것을 볼 수 있다. 물론 내부적으로는 아까 명령형 프로그래밍을 사용할 때의 필자 사고 방식과 유사한 방법으로 처리되겠지만, 적어도 필자가 자잘한 인덱스 변수의 선언이나 관리에 대해서 생각할 필요는 없어졌다.</p>\n<p>그리고 더 중요한 점은 필자가 해결해야하는 문제와 사고 방식의 흐름이 비슷해졌다는 것이다.</p>\n<blockquote>\n<p>배열을 순회하며 빈 문자열을 걸러내고(filter), 각 원소의 첫 글자를 대문자로 변경해라(convert + map).</p>\n</blockquote>\n<p>이렇게 선언형 프로그래밍은 개발자가 문제의 본질에 집중할 수 있게 만드는 것에 초점을 맞추고 있고, 결국 함수형 프로그래밍은 이런 선언형 프로그래밍의 패러다임을 함수를 사용하여 구현하는 것이다.</p>\n<p>하지만 이렇게 사소한 제어를 컴퓨터에게 맡겨버린다는 것이 장점만 있는 것은 아니다. 여기서 발생하는 대표적인 트레이드오프는 바로 추상화를 설명할 때 이야기했던 “성능”이다.</p>\n<p>필자가 명령형 프로그래밍을 사용하여 이 작업들을 수행한 경우 필자는 단 한 번의 루프 안에서 여러가지 작업을 수행했지만, 선언형 프로그래밍으로 작성한 예시는 <code class=\"language-text\">filter</code>와 <code class=\"language-text\">map</code> 메소드가 각각 전체 배열을 순회하기 때문에 성능 상 손해가 발생할 수 있는 것이다.</p>\n<p>아무리 요즘 머신의 성능이 좋아져서 저 정도의 추상화 레벨을 커버할 수 있다지만 만약 탐색해야하는 원소의 개수가 10억개라면 이런 사소한 차이가 전체 프로그램의 성능에 지대한 영향을 끼칠 수도 있다. 그래서 필자가 함수형 프로그래밍도 상황에 따라 적재적소에 잘 사용해야한다고 이야기 했던 것이다.</p>\n<h2 id=\"객체로-이루어진-프로그램과-함수로-이루어진-프로그램\" style=\"position:relative;\">객체로 이루어진 프로그램과 함수로 이루어진 프로그램<a href=\"#%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EA%B3%BC-%ED%95%A8%EC%88%98%EB%A1%9C-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8\" aria-label=\"객체로 이루어진 프로그램과 함수로 이루어진 프로그램 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 여기까지 명령형 프로그래밍을 사용할 때와 선언형 프로그래밍을 사용할 때 발생하는 사고의 차이에 대해 알아보았다.</p>\n<p>위에서 이야기했듯이 함수형 프로그래밍은 선언형 프로그래밍이라는 패러다임을 함수들의 집합과 연산으로 구현한 것이기 때문에 명령형 프로그래밍과도 많이 비교당하지만, 프로그램을 객체들의 집합과 관계로 정의하는 객체지향 프로그래밍과도 많이 비교를 당하게 된다.</p>\n<p>명령형 프로그래밍과 선언형 프로그래밍을 다루며 이야기했던 것과 마찬가지로, 객체지향 프로그래밍과 함수형 프로그래밍 간에도 어떠한 우위는 없다. 다만 서로의 차이에 따른 각기 다른 장단점이 있을 뿐이다.</p>\n<p>그렇다면 객체지향 프로그래밍을 사용하지 않고 함수형 프로그래밍을 사용함으로써 가져갈 수 있는 장점은 무엇일까?</p>\n<p>물론 여기에도 여러가지 장단점이 있겠지만 필자는 개인적으로 함수 단위의 코드 재사용이 더욱 쉬워진다는 것이 가장 큰 장점이라고 생각한다.</p>\n<h3 id=\"더-작게-쪼개어-생각할-수-있다\" style=\"position:relative;\">더 작게 쪼개어 생각할 수 있다<a href=\"#%EB%8D%94-%EC%9E%91%EA%B2%8C-%EC%AA%BC%EA%B0%9C%EC%96%B4-%EC%83%9D%EA%B0%81%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4\" aria-label=\"더 작게 쪼개어 생각할 수 있다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>기존의 객체지향 프로그래밍에 익숙한 개발자는 어떤 프로그램의 요구 사항을 들었을 때 머릿 속에 객체의 설계도가 떠오르게 된다. 그리고 이러한 객체들의 관계를 정의하여 거대한 프로그램을 만들기 위한 기반을 다져나간다.</p>\n<p>객체지향패턴에서 객체란 멤버 변수(상태)와 메소드(행위)로 이루어진, 프로그램을 구성하는 최소 단위이기 때문에, 객체지향패턴을 사용할 때 우리는 이 객체보다 더 작은 무언가를 사용하여 프로그램을 설계할 수 없다.</p>\n<p>우리가 객체지향패턴을 사용할 때는 객체를 생성하기 위해, 객체를 추상화하여 일종의 설계 도면 역할을 하는 클래스를 사용하여 객체가 가질 상태와 행위를 정의하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Queue<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> queue<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 내부 상태</span>\n\n  <span class=\"token comment\">// 메소드로 표현된 큐의 행위</span>\n  <span class=\"token keyword\">public</span> <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> length <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> head<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> myQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Queue<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyQueue<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">Queue</code> 클래스는 하나의 배열을 내부 상태로 가지고 이 배열에 원소를 추가하고 제거하는 큐의 기능을 구현한 클래스이다. 이때 이 클래스의 메소드를 통하지않고 클래스의 내부 상태인 <code class=\"language-text\">queue</code> 배열을 외부에서 맘대로 접근해서 수정하는 행위를 막기위해 <code class=\"language-text\">private</code> 접근제한자를 사용하여 외부에서의 접근을 막아주었다.</p>\n<p>사실 이 정도만 해도 일반적인 프로그래밍을 할 때 딱히 불편하거나 어려운 점은 없다. 하지만 여기에서 필자가 <code class=\"language-text\">Stack</code>이라는 클래스를 새로 만들면 어떻게 될까?</p>\n<p>간단히 생각해보면 큐의 동작인 <code class=\"language-text\">dequeue</code>는 그대로 사용하고 <code class=\"language-text\">enqueue</code>의 동작만 반대로 바꿔줘도 훌륭한 스택이 구현될 것 같다. 그러나 이미 클래스의 메소드로 구현되어버린 <code class=\"language-text\">dequeue</code>를 다른 클래스에서 가져다 자신의 메소드처럼 사용할 수 있는 방법은 상속 밖에 없는데, 그렇다고 큐를 상속한 스택을 만들어버리면 객체 간의 관계가 꼬이기 시작할 것이다.</p>\n<p>즉, 객체지향 프로그래밍에서 어떤 존재를 추상화하여 표현하고 재사용할 수 있는 최소 단위는 “객체”이기 때문에 그 이상 작게 쪼개기 힘들어지는 것이다. 하지만 함수형 프로그래밍에서는 객체로 표현된 큐나 스택이 아닌, 이 존재들이 자료를 다루는 동작에만 집중한다.</p>\n<blockquote>\n<ol>\n<li>배열의 꼬리에 원소를 추가하는 동작 (push)</li>\n<li>배열의 머리에서 원소를 빼오고 남은 원소를 앞으로 한 칸씩 당겨주는 동작 (shift)</li>\n</ol>\n</blockquote>\n<p>이처럼 자바스크립트의 빌트인 메소드인 <code class=\"language-text\">push</code>와 <code class=\"language-text\">shift</code>를 사용하면 굳이 클래스나 객체를 선언하거나, 필자가 위에서 구현한 것처럼 명령형 프로그래밍으로 큐의 동작을 구구절절 작성하지 않더라도 큐의 동작을 완벽하게 구현할 수 있다.</p>\n<p>또한 추가적으로 스택을 구현하고 싶다면, <code class=\"language-text\">shift</code> 메소드를 사용하여 원소를 빼오고 <code class=\"language-text\">push</code> 메소드 대신 <code class=\"language-text\">unshift</code> 메소드를 사용하여 원소를 추가하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> queue<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nqueue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> head <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> stack<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nstack<span class=\"token punctuation\">.</span><span class=\"token function\">unshift</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstack<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>굉장히 당연하다고 느껴지겠지만, 이것이 객체 단위로 요소를 구성하는 것과 함수 단위로 요소를 구성하였을때 누릴 수 있는 근본적인 장점이다. 어떤 요소를 재사용할 수 있는 범위가 넓어지는 것이다.</p>\n<p>다만 이렇게 작은 단위의 함수를 넓은 범위로 재사용하게 되면 프로그램의 복잡성이 빠르게 증가하기 때문에 이를 방어하기 위해서 함수가 함수 외부에 있는 값을 수정하면 안된다거나, 동일한 인자를 받은 함수는 동일한 값을 반환해야 한다거나 하는 몇 가지 제약 조건이 필요하게 된다.</p>\n<p>이런 제약을 가진 함수를 바로 “순수 함수(Pure Functions)“라고 부르는 것이다. 근데 보통 순수 함수라는 개념을 설명하다보면 방금 필자가 이야기한 것처럼 “몇 가지 제약 조건이 있는 함수”라는 개념으로 설명하게 되는데, 이거 근본적으로 그냥 수학에서 사용하는 함수랑 거의 동일한 개념이다.</p>\n<p>컴퓨터 공학의 함수는 수학의 함수에서 유래되기는 했지만, 이 두 개의 학문이 추구하는 방향과 발전되어온 과정이 꽤나 다르기 때문에 함수라는 개념도 이름만 똑같을 뿐, 사실은 서로 다른 부분이 많다. 즉, 순수 함수는 수학에서 이야기했던 함수의 본질 그 자체로 회귀하여 단순함을 확보하자는 개념에서 시작하는 것이다.</p>\n<p>그런 이유로 필자는 개인적으로 순수 함수를 프로그래밍적인 관점에서 접근하여 이해하는 것보다 수학적인 관점에서 접근하여 이해하는 것이 더 쉽고 빠르다고 생각한다.</p>\n<p>일단 이 포스팅의 주제는 함수형 프로그래밍보다는 함수로 사고하는 방식의 장단점과 특징에 대한 이야기이므로, 순수 함수나 불변성에 대한 이야기는 다음에 함수형 프로그래밍의 특징과 스킬을 설명할 때 조금 더 자세히 이야기해보도록 하겠다. <small>(이것도 은근히 꿀잼이다)</small></p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 사실 얼마 전까지만 해도 함수형 프로그래밍에 대한 관심이 깊은 편이 아니었다. 명령형 프로그래밍과 객체지향적인 사고만으로도 대부분의 어플리케이션은 충분히 설계할 수 있다고 생각했기 때문이다.</p>\n<p>하지만 이건 필자가 학교에서 처음 배웠던 패러다임이 명령형 프로그래밍과 객체지향 프로그래밍이었기 때문에 몸에 더 익어서 그랬던 것이다. 사실 어떤 패러다임을 자유자재로 다룰 수 있다는 것은 해당 패러다임이 요구하는 사고 방식에 이미 익숙해졌다는 이야기이기 때문에, 새로운 설계 패턴이나 패러다임을 익힌다는 것은 이런 기존의 사고 방식을 깨야하는 상황이기도 하다.</p>\n<p>개인적으로 커링이나 고계 함수, 모나드 같은 것들을 익히는 것보다 이런 사고 방식을 바꾸는 것이 훨씬 더 어렵다는 생각을 한다. 솔직히 말하면 어느 정도 함수형 프로그래밍에 대해 공부하고 마음이 열린 상태인 지금도 어떤 요구사항을 들었을 때 명령형과 객체지향을 먼저 떠올리고 있기도 하고 말이다.</p>\n<p>물론 포스팅에서 여러 번 이야기했듯이 함수형 프로그래밍이 객체지향 프로그래밍이나 명령형 프로그래밍을 대체하는 패러다임도 아닐 뿐더러, 이 패러다임들간에는 어떠한 우위도 없다. 각자의 장단점만 있을 뿐이고 상황에 따라 적당히 골라쓰면 되는 것이다.</p>\n<p>게다가 아직까지 많은 라이브러리들이 객체지향적인 개념으로 설계되었고, 사용 방법 또한 대부분 멤버 변수와 메소드를 내장한 객체를 생성하여 사용하는 방법을 채택하고 있기 때문에, 이런 라이브러리와 내 프로그램을 연동하려면 프로그램의 전체적인 아키텍쳐 또한 객체지향으로 설계하는 것이 편하다는 점도 무시할 수는 없다.</p>\n<p>일례로 자바스크립트 진형에서 상태관리 라이브러리로 자주 사용하는 Redux의 경우 순수 함수와 불변성을 기반으로 하여 상태 변경을 감지하게 되는데, 필자는 Web Audio API를 사용한 토이 프로젝트를 진행할 때 <code class=\"language-text\">AudioNode</code> 객체들의 상태를 Redux로 관리하는 것에 상당히 애를 먹고 있기도 하다.</p>\n<p>하지만 함수형 프로그래밍이 가져다주는 높은 수준의 추상화나 더 작은 수준의 코드 재사용과 같은 장점들은 분명히 복잡한 프로그램을 작성할 때 크게 도움이 되는 것들이다. 결국 함수형 프로그래밍을 잘 사용한다는 것은 단순히 이 패러다임을 깊게 이해하는 것보다는 이 패러다임이 어떤 상황에 적합한지 판단할 수 있는 능력 또한 포함하는 이야기라고 생각한다.</p>\n<p>다음 포스팅에서는 함수형 프로그래밍에서 빼놓을 수 없는 키워드인 순수 함수, 불변성, 지연 평가와 같은 개념들과 프로그램의 복잡도를 낮추기 위해 사용하는 다양한 스킬들을 소개하는 포스팅을 작성할 예정이다.</p>\n<p>이상으로 기존의 사고 방식을 깨부수는 함수형 사고 포스팅을 마친다.</p>","fields":{"slug":"20191215-about-functional-thinking","path":"/2019/12/15/about-functional-thinking/","lang":"ko"},"frontmatter":{"title":"기존의 사고 방식을 깨부수는 함수형 사고","subTitle":"명령형에서 선언형으로, 프로그래밍 사고를 전환하는 법","date":"Dec 15, 2019","categories":["프로그래밍","아키텍처"],"tags":["함수형 프로그래밍","함수형 사고","Functional Programming","Functional Thinking","명령형 프로그래밍","객체지향 프로그래밍","선언형 프로그래밍"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/9044dbb610cf83c50525198f5c9e28fb/d803c/thumbnail.png","srcSet":"/static/9044dbb610cf83c50525198f5c9e28fb/d803c/thumbnail.png 320w,\n/static/9044dbb610cf83c50525198f5c9e28fb/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/9044dbb610cf83c50525198f5c9e28fb/fc5c5/thumbnail.webp 320w,\n/static/9044dbb610cf83c50525198f5c9e28fb/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/9044dbb610cf83c50525198f5c9e28fb/01fb2/thumbnail.png","srcSet":"/static/9044dbb610cf83c50525198f5c9e28fb/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/9044dbb610cf83c50525198f5c9e28fb/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"81ba0914-9843-5c4a-87dd-3ca736527fb9","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%EC%99%9C-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\">객체 지향 프로그래밍을 왜 알아야 하나요?</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B2%83%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%9D%98%EB%AF%B8%ED%95%98%EB%82%98%EC%9A%94\">객체 지향이라는 것은 무엇을 의미하나요?</a></p>\n<ul>\n<li><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B0%9D%EC%B2%B4\">클래스와 객체</a></li>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%99%94%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%A1%B0%EA%B8%88-%EB%8D%94-%EA%B9%8A%EC%9D%B4-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EC%9E%90\">추상화에 대해서 조금 더 깊이 생각해보자</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-3%EB%8C%80%EC%9E%A5\">객체 지향 프로그래밍의 3대장</a></p>\n<ul>\n<li><a href=\"#%EC%83%81%EC%86%8D\">상속</a></li>\n<li><a href=\"#%EC%BA%A1%EC%8A%90%ED%99%94\">캡슐화</a></li>\n<li><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\">다형성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 객체 지향 프로그래밍(Object-Oriented Programming), 줄여서 흔히들 OOP라고 부르는 설계 방법론에 대해서 이야기해보려고 한다. OOP는 프로그래밍의 설계 패러다임 중 하나로, 현실 세계를 프로그램 설계에 반영한다는 개념을 기반으로 접근하는 방법이다. OOP는 90년대 초반부터 유명해지기 시작했지만 아직까지도 전 세계의 많은 개발자들이 사용하고 있는 설계 패턴 중 하나이기 때문에 알아둬서 나쁠 건 없다.","html":"<p>이번 포스팅에서는 객체 지향 프로그래밍(Object-Oriented Programming), 줄여서 흔히들 OOP라고 부르는 설계 방법론에 대해서 이야기해보려고 한다.</p>\n<p>OOP는 프로그래밍의 설계 패러다임 중 하나로, 현실 세계를 프로그램 설계에 반영한다는 개념을 기반으로 접근하는 방법이다. OOP는 90년대 초반부터 유명해지기 시작했지만 아직까지도 전 세계의 많은 개발자들이 사용하고 있는 설계 패턴 중 하나이기 때문에 알아둬서 나쁠 건 없다.</p>\n<!-- more -->\n<h2 id=\"객체-지향-프로그래밍을-왜-알아야-하나요\" style=\"position:relative;\">객체 지향 프로그래밍을 왜 알아야 하나요?<a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%EC%99%9C-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"객체 지향 프로그래밍을 왜 알아야 하나요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 OOP가 오랜 기간동안 전 세계에서 사랑받고있는 설계 패턴인 것은 맞지만 최근에는 OOP의 단점을 이야기하며 함수형 프로그래밍(Functional Programming)과 같은 새로운 설계 패러다임이 각광받기도 했다. <small>(함수형 프로그래밍도 사실 꽤 오래된 패러다임이다)</small> 사실 OOP니 FP이니 하는 이런 것들은 결국 “프로그램을 어떻게 설계할 것인가?”에 대한 방법이기 때문에 당연히 각각의 장단점 또한 존재하기 마련이고 시대나 용도에 맞게 개선된 패러다임이 제시되는 것은 자연스러운 흐름이다.</p>\n<p>필자는 개인적으로 아직까지 OOP가 괜찮은 설계 패턴이라고 생각하고 있지만, 여러분은 함수형 프로그래밍이 OOP보다 더 효율적이고 괜찮다고 생각할 수도 있다.</p>\n<p>당연히 어떤 패러다임을 선호하는지는 개인의 자유기 때문에 다르게 생각할 수 있지만, 어떤 기술을 선택할 때는 해당 기술의 장단점과 그 기술을 선택했을 때 얻을 수 있는 것과 잃을 수 있는 것을 제대로 파악하고 있어야 올바른 선택을 할 수 있기 때문에 여러분이 함수형 프로그래밍을 선택한다고 하더라도 OOP가 무엇인지 알고 있어야 하는 것은 마찬가지다.</p>\n<p>또한 OOP는 1990년대 초반부터 2019년인 현재까지도 모던 프로그래밍 설계에 중요한 역할을 하고 있는 개념이다. 아무리 함수형 프로그래밍과 같은 새로운 패러다임이 주목받기는 했지만 아직까지는 OOP가 대부분의 프로그램 설계에 사용되고 있다는 사실은 부정할 수 없는 현실이며, 이게 바로 우리가 OOP를 좋은 싫든 알고 있어야 하는 현실적인 이유 중의 하나이다. <small>(참고로 Java, Python, C++ 등 메이저 언어들도 전부 OOP를 지원하는 언어이다.)</small></p>\n<p>그래서 이번 포스팅에서는 OOP가 추구하는 것이 무엇인지, 또 OOP를 이루고 있는 개념들은 무엇이 있는지 간략하게 살펴보려고 한다.</p>\n<h2 id=\"객체-지향이라는-것은-무엇을-의미하나요\" style=\"position:relative;\">객체 지향이라는 것은 무엇을 의미하나요?<a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B2%83%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%9D%98%EB%AF%B8%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"객체 지향이라는 것은 무엇을 의미하나요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>OOP의 의미인 Object-Oriented Programming의 “Object-Oriented”를 한국말로 그대로 직역하면 “객체 지향”이다. 여기서 말하는 객체는 현실 세계에 존재하는 하나 하나의 독립된 무언가를 의미한다. 보통 OOP를 배울 때 가장 처음 접하는 개념이 바로 이 객체라는 개념인데, 사실 한번 이해하고나면 꽤 간단한 개념이지만 우리가 평소에 살면서 잘 생각해보지 않는 개념이기 때문에 잘 이해가 되지 않을 수도 있다.</p>\n<p>객체를 설명하기 위해서는 클래스라는 개념을 함께 설명해야하는데, 용어가 직관적이지 않아서 그렇지 조금만 생각해보면 누구나 다 이해할 수 있는 개념이다. 일반적으로 이걸 설명할 때 붕어빵과 붕어빵 틀과 같은 비유를 들며 설명하지만 필자는 일반적인 설명과 다르게 “클래스는 무엇이고, 객체는 무엇이다”라는 방식으로 접근하기보다는 일단 OOP의 포괄적인 설계 개념을 먼저 설명하는 방식으로 접근하도록 하겠다.</p>\n<p>재미없고 복잡한 용어는 일단 제쳐두고 일단 예시를 보면서 의식의 흐름대로 따라와보자.</p>\n<h3 id=\"클래스와-객체\" style=\"position:relative;\">클래스와 객체<a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B0%9D%EC%B2%B4\" aria-label=\"클래스와 객체 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자는 이 포스팅의 서두에서 OOP란 현실 세계를 프로그램의 설계에 반영하는 것이라고 이야기했다. 이 말이 뜻하는 의미를 먼저 이해하고 나면 클래스나 객체 같은 것은 자연스럽게 이해할 수 있으니 먼저 OOP가 왜 현실 세계를 반영한 설계 방식이라고 하는 지를 먼저 알아보도록 하자.</p>\n<p>뭐 여러가지 예시가 있겠지만 우리가 일상적으로 사용하고 있는 물건을 예로 드는 것이 좀 더 와닿을테니 필자는 스마트폰을 예로 들어서 설명을 진행하려고 한다. 필자는 애플에서 만든 iPhone7이라는 기종을 사용하고 있기 때문에 iPhone7을 예시로 설명을 시작하겠다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d1e74fbc89cf5f9b31acf2e22b89f6f9/b4294/iphone7.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAUGBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAasilDNWDihBqgf/xAAcEAACAwADAQAAAAAAAAAAAAACBAABAxEUIzT/2gAIAQEAAQUCZOwxXb1LeO/OsXvHK5XVGu1P/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQIAEBFicf/aAAgBAQAGPwIlThgRjoJoxF6povtf/8QAHRAAAQQCAwAAAAAAAAAAAAAAAQAQESExsWGRof/aAAgBAQABPyG7IC0K8cFi2942p5WDIHbWLjanMnIt/9oADAMBAAIAAwAAABA3wDz/xAAXEQADAQAAAAAAAAAAAAAAAAABESAh/9oACAEDAQE/EAG9j//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EAB8QAQACAgEFAQAAAAAAAAAAAAEAESExEEFRYXGBkf/aAAgBAQABPxCisAUGrfMvKSBAZ0lcKmmvu2MNWWfuPyGoZElKx6Te4dB2eP/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"iphone7\" title=\"\" src=\"/static/d1e74fbc89cf5f9b31acf2e22b89f6f9/b4294/iphone7.jpg\" srcset=\"/static/d1e74fbc89cf5f9b31acf2e22b89f6f9/0913d/iphone7.jpg 160w,\n/static/d1e74fbc89cf5f9b31acf2e22b89f6f9/cb69c/iphone7.jpg 320w,\n/static/d1e74fbc89cf5f9b31acf2e22b89f6f9/b4294/iphone7.jpg 600w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>먼저, 우리가 iPhone7이라는 것을 프로그램으로 구현하고 싶다면 제일 먼저 iPhone7이 무엇인지부터 정의해야한다. 너무 어렵게 생각할 필요없다. 진짜로 프로그램을 짜는 것이 아니기 때문에 대충 정의해도 된다.</p>\n<p>필자가 지금 바로 생각해낸 iPhone7은 약간 동글동글한 바디를 가지고 있고 햅틱 엔진이 내장된 홈 버튼을 가지고 있으며, 시리즈 최초로 3.5mm 이어폰 단자가 없어진 iPhone 시리즈라는 것이다. <small>(개인적으로 이어폰 단자 좀 다시 넣어줬으면 한다…)</small></p>\n<p>우리는 여기서 한발짝 더 나아가서 iPhone7의 상위 개념인 iPhone에 대해서도 정의해볼 수 있다. 결국 iPhone7은 iPhone이라는 개념을 기반으로 확장된 개념이기 때문이다.</p>\n<p>그럼 iPhone은 무엇일까? 아이폰은 애플에서 제조한 스마트폰으로, iOS를 사용하고 있는 스마트폰 시리즈의 명칭이다. 이때 iPhone은 iPhone7 외에도 iPhoneX, iPhone8, iPhone SE 등 수많은 iPhone 시리즈의 제품들을 포함하는 좀 더 포괄적인 개념이다.</p>\n<p>일상 속에서 우리가 친구한테 “너 핸드폰 뭐 써?”라고 물어봤을 때 친구가 아이폰 또는 갤럭시라고 대답하는 경우를 생각해보자. 이때 친구는 자신이 사용하는 스마트폰이 iPhoneX든 Galaxy S10이든 간에 무의식적으로 아이폰이나 갤럭시라는 좀 더 포괄적인 개념을 떠올리고 하위 개념들을 그룹핑한 것이다. 그 정도로 이런 접근 방법은 우리에게 이미 일상적이고 익숙한 방법이다. 어렵게 생각하지 말자.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c9f7250de3e9fbd0ea061467682c3265/deea3/iphones.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 77.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAG1UVNZpF//xAAcEAACAgIDAAAAAAAAAAAAAAABAwIRABIEEzL/2gAIAQEAAQUCHIZXeaW0nGsnttIlfj//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAcEAACAgIDAAAAAAAAAAAAAAAAAQJBETEhcZH/2gAIAQEABj8CWtOiqol2SxJ7oWJv0XOT/8QAGhABAQEBAQEBAAAAAAAAAAAAAREAITFBUf/aAAgBAQABPyFKTpsja16MCrsZ5iEKGAwb6/mWWS/Xf//aAAwDAQACAAMAAAAQ78//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAgMBAQEAAAAAAAAAAAABABEhMUFhoXH/2gAIAQEAAT8QUl6HsX2ON7cdRNb78gYlXLXUCIGIE3hayfsqxUlll7znyEMlZ2cs/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"iphones\" title=\"\" src=\"/static/c9f7250de3e9fbd0ea061467682c3265/c08c5/iphones.jpg\" srcset=\"/static/c9f7250de3e9fbd0ea061467682c3265/0913d/iphones.jpg 160w,\n/static/c9f7250de3e9fbd0ea061467682c3265/cb69c/iphones.jpg 320w,\n/static/c9f7250de3e9fbd0ea061467682c3265/c08c5/iphones.jpg 640w,\n/static/c9f7250de3e9fbd0ea061467682c3265/deea3/iphones.jpg 876w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>iPhone7의 상위 개념인 iPhone은 모든 iPhone 시리즈를 포괄할 수 있는 개념이 된다.</small>\n</center>\n<p>여기서 가장 중요한 점은 하위 개념인 iPhone7은 상위 개념인 iPhone의 특징을 모두 가지고 있다는 것이다. 마찬가지로 iPhone의 다른 하위 개념인 iPhoneX이나 iPhone SE와 같은 iPhone 시리즈들도 iPhone의 모든 특징을 가지고 있을 것이다. 여기서 끝내면 아쉬우니 한번만 더 해보도록 하자.</p>\n<p>아이폰의 상위 개념은 무엇일까? 아이폰은 애플에서 제조하고 iOS를 사용하는 스마트폰의 명칭이다. 즉, iPhone의 상위 개념은 스마트폰이라고 할 수 있다. 이때 스마트폰이라는 개념은 iPhone 뿐만 아니라 Galaxy, 샤오미, 베가와 같은 다른 스마트폰들까지 모두 포괄하는 개념일테고, 마찬가지로 이 스마트폰이라는 개념의 하위 개념들은 모두 스마트폰의 특징을 그대로 가지며 자신들만의 고유한 특징을 추가적으로 가질 수 있을 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/82818fc27e74af90ae342fdd9579d4f4/eea4a/smartphones.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAABQAG/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAABSKZGFbPR/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQMAAhIEEf/aAAgBAQABBQJ3tpcjXMzSnSwjwKu//8QAFhEAAwAAAAAAAAAAAAAAAAAAEBFB/9oACAEDAQE/Aax//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGxAAAwEAAwEAAAAAAAAAAAAAAAECESExMnH/2gAIAQEABj8CzcOPUm1apiF9LS60/8QAHBAAAwEAAgMAAAAAAAAAAAAAAAERITFRYZHx/9oACAEBAAE/IWVoi5XZKlyq+kmkb4E9hUeaUlxMI//aAAwDAQACAAMAAAAQCA//xAAYEQACAwAAAAAAAAAAAAAAAAABECFBof/aAAgBAwEBPxCAGKX/xAAWEQADAAAAAAAAAAAAAAAAAAABEEH/2gAIAQIBAT8QhX//xAAdEAEAAgIDAQEAAAAAAAAAAAABABEhMUFhcVGx/9oACAEBAAE/EKiTY9iMEgBug59fYl91bXjO/e4SdlNcxbsAL5pW/wAlvKwHRP/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"smartphones\" title=\"\" src=\"/static/82818fc27e74af90ae342fdd9579d4f4/c08c5/smartphones.jpg\" srcset=\"/static/82818fc27e74af90ae342fdd9579d4f4/0913d/smartphones.jpg 160w,\n/static/82818fc27e74af90ae342fdd9579d4f4/cb69c/smartphones.jpg 320w,\n/static/82818fc27e74af90ae342fdd9579d4f4/c08c5/smartphones.jpg 640w,\n/static/82818fc27e74af90ae342fdd9579d4f4/6a068/smartphones.jpg 960w,\n/static/82818fc27e74af90ae342fdd9579d4f4/eea4a/smartphones.jpg 1280w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>스마트폰이라는 개념은 아이폰, 갤럭시, 샤오미 등 모든 스마트폰을 포괄할 수 있는 개념이 된다.</small>\n</center>\n<p>이런 식으로 우리는 iPhone7이라는 개념에서 출발하여 계속해서 상위 개념을 정의해나갈 수 있다.</p>\n<blockquote>\n<p>iPhone7 -> iPhone -> 스마트폰 -> 휴대전화 -> 무선 전화기 -> 전화기 -> 통신 기기 -> 기계…</p>\n</blockquote>\n<p>결국 이렇게 상위 개념을 추적해나가면서 설계하는 것이 OOP의 기초이고, 이때 iPhone7, iPhone과 같은 개념들을 “클래스(Class)“라고 부르는 것이다.</p>\n<p>그리고 방금 했던 것처럼 상위 개념을 만들어나가는 행위 자체를 추상화(Abstraction)라고 한다. 추상화는 밑에서 다시 한번 설명할테니 일단 지금은 클래스라는 개념만 기억하도록 하자.</p>\n<p>그럼 객체(Object)는 무엇일까? 필자는 방금 클래스를 설명하면서 개념이라는 단어를 굉장히 많이 사용했다. 말 그대로 클래스의 역할은 어떠한 개념을 의미하는 것이다. 하지만 개념이라는 것 자체 만으로는 현실의 물건이 될 수는 없는 법이다.</p>\n<p>잘 생각해보면 iPhone7이라는 것 또한 그냥 어떠한 제품 라인의 이름이다. 어떤 고유한 물건의 이름이 아니라는 것이다. 여기서 필자가 말하는 “고유하다”라는 의미는 전 세계에 단 한개만 존재하는 수준의 고유함이다. 당장 내 iPhone7과 친구의 iPhone7만 봐도 실제로는 다른 iPhone7이지 않은가?</p>\n<p>즉, iPhone7이라는 클래스는 어떠한 실체가 있는 게 아니다. iPhone7 클래스에는 CPU, 디스플레이 해상도, 메모리와 같은 사양이 정의되어 있을 것이고 이를 기반으로 공장에서 “실제 iPhone7”을 찍어내고 일련번호를 부여한 후 출고하고나면 그제서야 우리 손에 잡을 수 있는 물건인 iPhone7이 되는 것이다.</p>\n<p>이때 생산된 iPhone7에는 고유한 ID인 일련번호가 부여되었기 때문에 우리는 전 세계에 일련번호가 <code class=\"language-text\">1234</code>인 iPhone7은 단 하나밖에 없다는 사실을 알 수 있다.</p>\n<p>이때 이렇게 생산된 iPhone7들을 객체라고 할 수 있다.</p>\n<blockquote>\n<p>즉, 클래스는 일종의 설계도이고 이것을 사용하여 우리가 사용할 수 있는 실제 물건으로 만들어내는 행위가 반드시 필요하다. 그리고 객체는 클래스를 사용하여 생성한 실제 물건이다.</p>\n</blockquote>\n<p>이러한 OOP의 설계 접근 방식으로 우리의 일상 속에 보이는 대부분의 개념들을 추상화할 수 있는데, 그냥 평소에 보이는 모든 것들을 이렇게 추상화해보는 연습을 하면 나름 재미도 있다. 몇 가지 예를 들어보겠다.</p>\n<hr>\n<ul>\n<li>소나타 -> 중형 세단 -> 세단 -> 자동차 -> 이동수단</li>\n<li>문동욱 -> 남자 -> 인간 -> 영장류 -> 포유류 -> 동물</li>\n<li>오버워치 ->  FPS 게임 -> 게임 -> 소프트웨어</li>\n</ul>\n<hr>\n<p>실제로 우리 일상 속에 존재하는 거의 대부분의 개념은 이런 추상화 기법으로 어느 정도 정리할 수 있다. 눈에 보이는 생활 속의 물건들을 추상화 해보는 것은 따로 시간을 내지 않아도 일상 속에서 할 수 있는 좋은 연습 방법이니 한번 해보기를 추천한다. 이 방법이 익숙해지면 카페에 가서 커피를 마시면서도 머릿 속에서 작은 카페를 만들어 볼 수도 있다.</p>\n<p>결국 객체 지향이라는 말의 의미는 이렇게 클래스를 사용하여 추상적인 개념들을 정의하고, 그 클래스를 사용하여 실제로 사용할 객체를 만들어냄으로써 현실 세계의 모든 것을 표현할 수 있다는 것에서 출발하는 것이다.</p>\n<h3 id=\"추상화에-대해서-조금-더-깊이-생각해보자\" style=\"position:relative;\">추상화에 대해서 조금 더 깊이 생각해보자<a href=\"#%EC%B6%94%EC%83%81%ED%99%94%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%A1%B0%EA%B8%88-%EB%8D%94-%EA%B9%8A%EC%9D%B4-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"추상화에 대해서 조금 더 깊이 생각해보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>방금 우리는 iPhone7부터 시작해서 상위 개념을 이끌어내는 간단한 추상화를 경험해보았다. 하지만 우리가 방금 저 예시를 진행할 때는 그렇게까지 깊은 고민이 없었을 것이다. 왜냐면 iPhone이나 스마트폰 같은 개념은 이미 우리에게 상당히 친숙한 개념이기 때문에 깊이 고민할 필요없이 이미 여러분의 머릿속에 어느 정도 추상화가 되어 정리된 상태였기 때문이다.</p>\n<p>하지만 실제로 프로그램 설계에 OOP를 사용할 때에는 우리에게 친숙한 iPhone과 같은 개념을 사용하는 것이 아니라 개발자가 이 개념 자체부터 정의해야하는 경우가 많다. 이때 추상화가 어떤 것인지 정확히 이해하고 있지 않다면 자칫 이상한 방향으로 클래스를 설계할 수 있기 때문에 정확히 추상화가 무엇인지 짚고 넘어가도록 하겠다.</p>\n<p>추상이라는 단어의 뜻부터 한번 생각해보자. 추상은 어떠한 존재가 가지고 있는 여러가지의 속성 중에서 특정한 속성을 가려내어 포착하는 것을 의미한다. 대표적인 추상파 화가 중 한명인 피카소가 소를 점점 추상화하며 그려가는 과정을 한번 살펴보면 추상화가 어떤 것인지 조금 더 이해가 된다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 488px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6dc8c06c81d4f63100e40d0026453f47/155ab/picasso_bull.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 94.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAEDBAL/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHfXvgoaQ7CQf/EABwQAQACAQUAAAAAAAAAAAAAAAECAxAAERIjMf/aAAgBAQABBQKn2iPXSPCJoNgwY//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EAB0QAAIBBAMAAAAAAAAAAAAAAAACEQEgMYEiMmH/2gAIAQEABj8Caktsfk8enZtmTNv/xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhMRBBceH/2gAIAQEAAT8hQ3+hijPo651uCwrv3Eu7MRrTKJ8gzTj/2gAMAwEAAgADAAAAEHAPPP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EAB8QAQEAAgEEAwAAAAAAAAAAAAERACGBEDFhcZGx0f/aAAgBAQABPxA3KMg07dn0esuiAjwTd4yIbWQA8YBrUSITv6xRXQClnwYrN8L8xBJC+MIFAL0//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"picasso bull\" title=\"\" src=\"/static/6dc8c06c81d4f63100e40d0026453f47/155ab/picasso_bull.jpg\" srcset=\"/static/6dc8c06c81d4f63100e40d0026453f47/0913d/picasso_bull.jpg 160w,\n/static/6dc8c06c81d4f63100e40d0026453f47/cb69c/picasso_bull.jpg 320w,\n/static/6dc8c06c81d4f63100e40d0026453f47/155ab/picasso_bull.jpg 488w\" sizes=\"(max-width: 488px) 100vw, 488px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>피카소가 소를 추상화하는 과정</small>\n</center>\n<p>이렇듯, 추상화라는 것은 그 존재가 가지고 있는 가장 특징적인 속성들을 파악해나가는 것을 의미한다.</p>\n<p>우리가 방금 전 iPhone7의 상위 개념인 iPhone을 떠올리게 되는 과정은 꽤나 직관적으로 진행되었지만 사실 추상화를 그렇게 직관적으로 접근하려고 하면 더 방향을 잡기가 힘들다. 원래대로라면 iPhone이라는 상위 개념을 만들고자 했을 때 iPhone7 뿐만이 아니라 다른 iPhone 시리즈들까지 모두 포함할 수 있는 iPhone들의 공통된 특성을 먼저 찾는 것이 올바른 순서이다. 이렇게 만들어진 올바른 상위 개념의 속성은 그 개념의 하위 개념들에게 공통적으로 적용할 수 있는 속성이 된다.</p>\n<blockquote>\n<p><strong>상위 개념</strong><br />\niPhone: 애플에서 만든 iOS 기반의 스마트폰</p>\n</blockquote>\n<blockquote>\n<p><strong>iPhone 클래스 기반의 하위 개념</strong><br />\niPhoneX: 애플에서 만든 iOS 기반의 스마트폰이며, 홈 버튼이 없고 베젤리스 디자인이 적용된 iPhone.<br />\niPhone7: 애플에서 만든 iOS 기반의 스마트폰이며, 햅틱 엔진이 내장된 홈 버튼을 가지고 있는 iPhone.<br />\niPhone SE: 애플에서 만든 iOS 기반의 스마트폰이며, 사이즈가 작아서 한 손에 잡을 수 있는 iPhone.<br /></p>\n</blockquote>\n<p>이 예시에서 볼 수 있듯이 하위 개념들은 상위 개념이 가지고 있는 모든 속성을 그대로 물려받는데, 그래서 이 과정을 상속(Inheritance)이라고 한다. 이 상속에 관해서는 밑에서 다시 자세하게 살펴보도록 하겠다.</p>\n<h2 id=\"객체-지향-프로그래밍의-3대장\" style=\"position:relative;\">객체 지향 프로그래밍의 3대장<a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-3%EB%8C%80%EC%9E%A5\" aria-label=\"객체 지향 프로그래밍의 3대장 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>방금까지 설명한 클래스, 객체, 추상화는 OOP를 이루는 근본적인 개념들이다. 필자는 여기서 좀 더 나아가서 OOP를 지원하는 언어들이 기본적으로 갖추고 있는 몇 가지 개념을 더 설명하려고 한다. OOP는 그 특성 상 클래스와 객체를 기반으로 조립하는 형태로 프로그램을 설계하게 되는데 이때 이 조립을 더 원활하게 하기 위해서 나온 유용한 몇가지 개념들이 있다.</p>\n<p>하지만 이 개념들은 JavaScript에는 구현되지 않은 개념도 있으므로 이번에는 Java를 사용해서 예제를 진행하도록 하겠다. 단편적인 문법만 보면 그렇게 이질감 느껴질 정도로 차이가 크지 않기 때문에 JavaScript만 하셨던 분들도 아마 금방 이해할 수 있을 것이다. 참고로 TypeScript도 OOP를 지원하기는 하지만 이거 세팅하는 것보다 그냥 Java 컴파일하는게 편하기 때문에 Java로 간다.</p>\n<p>그럼 이제 객체 지향의 3대장이라고 불리는 상속과 캡슐화, 그리고 다형성에 대해서 간단하게 알아보도록 하자.</p>\n<h3 id=\"상속\" style=\"position:relative;\">상속<a href=\"#%EC%83%81%EC%86%8D\" aria-label=\"상속 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>상속(Inheritance)은 방금 전 추상화에 대한 설명을 진행하면서 한번 짚고 넘어갔던 개념이다. OOP를 제공하는 많은 프로그래밍 언어에서 상속은 <code class=\"language-text\">extends</code>라는 예약어로 표현되는데, 하위 개념 입장에서 보면 상위 개념의 속성을 물려받는 것이지만 반대로 상위 개념 입장에서 보면 자신의 속성들이 하위 개념으로 넘어가면서 확장되는 것이므로 이 말도 맞다. 그럼 이제 상속이 어떻게 이루어지는지 코드로 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">IPhone</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">String</span> manufacturer <span class=\"token operator\">=</span> <span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">String</span> os <span class=\"token operator\">=</span> <span class=\"token string\">\"iOS\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n  \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">IPhone7</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IPhone</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> version <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n  \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> main <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">IPhone7</span> myIPhone7 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IPhone7</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>myIPhone7<span class=\"token punctuation\">.</span>manufacturer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>myIPhone7<span class=\"token punctuation\">.</span>os<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>myIPhone7<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">apple\niOS\n7</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">IPhone7</code> 클래스를 생성할 때 <code class=\"language-text\">extends</code> 예약어를 사용하여 <code class=\"language-text\">IPhone</code> 클래스를 상속받았다. <code class=\"language-text\">IPhone7</code> 클래스에는 <code class=\"language-text\">manufacturer</code>와 <code class=\"language-text\">os</code> 속성이 명시적으로 선언되지 않았지만 부모 클래스인 <code class=\"language-text\">IPhone</code> 클래스의 속성을 그대로 물려받은 것을 볼 수 있다.</p>\n<p>마찬가지로 이 상황에서 <code class=\"language-text\">IPhoneX</code> 클래스를 새로 만들어야 할때도 <code class=\"language-text\">IPhone</code> 클래스를 그대로 다시 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">IPhoneX</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IPhone</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> version <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>즉, 추상화가 잘된 클래스를 하나만 만들어놓는다면 그와 비슷한 속성이 필요한 다른 클래스를 생성할 때 그대로 재사용할 수 있다는 말이다. 그리고 만약 iPhone 시리즈 전체에 걸친 변경사항이 생겼을 때도 <code class=\"language-text\">IPhone7</code>, <code class=\"language-text\">IPhoneX</code>와 같은 클래스는 건드릴 필요없이 <code class=\"language-text\">IPhone</code> 클래스 하나만 고치면 이 클래스를 상속받은 모든 하위 클래스에도 자동으로 적용되므로 개발 기간도 단축시킬 수 있고 휴먼 에러가 발생할 확률도 줄일 수 있다.</p>\n<p>하지만 여기서 만약 요구사항이 변경되어서 Galaxy 시리즈를 만들어야한다면 어떻게 될까? Galaxy 시리즈는 iOS가 아니라 Android를 사용하고, 제조사도 애플이 아니라 삼성이기 때문에 우리가 방금 만든 <code class=\"language-text\">IPhone</code> 클래스를 사용할 수는 없다. 이때 우리는 <code class=\"language-text\">IPhone</code> 클래스를 그대로 냅두고 그냥 <code class=\"language-text\">Galaxy</code> 클래스를 새로 만들 수도 있지만 <code class=\"language-text\">SmartPhone</code>이라는 한단계 더 상위 개념을 만드는 방향으로 가닥을 잡을 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SmartPhone</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">SmartPhone</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> manufacturer<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> os<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>manufacturer <span class=\"token operator\">=</span> manufacturer<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>os <span class=\"token operator\">=</span> os<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">IPhone</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SmartPhone</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">IPhone</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"iOS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Galaxy</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">SmartPhone</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Galaxy</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"samsung\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"android\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n  \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">IPhone7</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">IPhone</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> version <span class=\"token operator\">=</span> <span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">GalaxyS10</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Galaxy</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">String</span> version <span class=\"token operator\">=</span> <span class=\"token string\">\"s10\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위의 코드에서 <code class=\"language-text\">super</code> 메소드는 부모 클래스의 생성자를 호출하는 메소드이다. 부모 클래스를 <code class=\"language-text\">Super Class</code>, 자식 클래스를 <code class=\"language-text\">Sub Class</code>라고 부르기도 하기 때문에 부모와 관련된 키워드 역시 <code class=\"language-text\">super</code>를 사용하는 것이다.</p>\n<p>그리고 이때 자식 클래스인 <code class=\"language-text\">IPhone7</code>이나 <code class=\"language-text\">GalaxyS10</code> 클래스가 부모 클래스의 <code class=\"language-text\">manufacturer</code>나 <code class=\"language-text\">os</code> 속성을 덮어쓰게 할 수도 있는데, 이러한 작업을 오버라이딩(Overriding)이라고 한다. 안드로이드 개발을 하다보면 밥먹듯이 쓰는 <code class=\"language-text\">@Override</code> 데코레이터도 부모 클래스의 메소드를 덮어쓰는 방식으로 세부 구현을 진행하는 것이다.</p>\n<p>이러한 OOP의 클래스 의존관계는 클래스의 재사용성을 높혀주는 방법이기도 하지만, 너무 클래스의 상속 관계가 복잡해지게 되면 개발자가 전체 구조를 파악하기가 힘들다는 단점도 가지고 있으므로 개발자가 확실한 의도를 가지고 적당한 선에서 상속 관계를 설계하는 것이 중요하다. <small>(근데 이 적당한 선의 기준이 개발자마다 다 다르다는 게 함정)</small></p>\n<h3 id=\"캡슐화\" style=\"position:relative;\">캡슐화<a href=\"#%EC%BA%A1%EC%8A%90%ED%99%94\" aria-label=\"캡슐화 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>캡슐화(Encapsulation)는 어떠한 클래스를 사용할 때 내부 동작이 어떻게 돌아가는지 모르더라도 사용법만 알면 쓸 수 있도록 클래스 내부를 감추는 기법이다.</p>\n<p>클래스를 캡슐화 함으로써 클래스를 사용하는 쪽에서는 머리 아프게 해당 클래스의 내부 로직을 파악할 필요가 없어진다. 또한 클래스 내에서 사용되는 변수나 메소드를 원하는 대로 감출 수 있기 때문에 필요 이상의 변수나 메소드가 클래스 외부로 노출되는 것을 방어햐여 보안도 챙길 수 있다.</p>\n<p>이렇게 클래스 내부의 데이터를 감추는 것을 정보 은닉(Information Hiding)이라고 하며, 보통 <code class=\"language-text\">public</code>, <code class=\"language-text\">private</code>, <code class=\"language-text\">protected</code> 같은 접근제한자를 사용하여 원하는 정보를 감추거나 노출시킬 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// Capsulation.java</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">String</span> address<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> address<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>address <span class=\"token operator\">=</span> address<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>자 이렇게 간단한 클래스를 하나 만들어보았다. <code class=\"language-text\">Person</code> 클래스는 생성자의 인자로 들어온 값들을 자신의 멤버 변수에 할당하는데, 이 멤버 변수들은 각각 <code class=\"language-text\">public</code>, <code class=\"language-text\">private</code>, <code class=\"language-text\">protected</code>의 접근제한자를 가지고 있는 친구들이다.</p>\n<p>그럼 한번 객체를 생성해보고 이 친구들의 멤버 변수에 접근이 가능한지를 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// Capsulation.java</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CapsulationTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> main <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Person</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Evan\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Seoul\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>자, 여기까지 직접 작성해보면 알겠지만 Java는 컴파일 언어이기 때문에 굳이 실행시켜보지 않더라도 IDE에서 이미 알아서 다 분석을 끝내고 빨간줄을 쫙쫙 그어주었을 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 523px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b7e9c57c1c6569986581fea72ac07cfa/3e286/private_error.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 26.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA+UlEQVR42lWQWW7CQBBEuVRY4n0278YLNhAsJZaClPtf4KWNEEo+nqp6mRqpN1F+IcgnAt0R5WeK+kYQN7ztUraHjN0hf7D6lb1XsN2nr3r31JWDV7LJ3YQuP0hEbdpjXYcTNXalQ5sjSh+JVIMy8mnS4LKRWHphXJOIatnVrseXetOfvtBZT2InTLkQZzOqWkjSK7ZeSNtvbCk9c5JHE8qOpPlVQsaHV/b08EZmkRrWwAWv7fCGC6q/Uww/EnInr2Z8N/NubvjJiB+2+NGT8PjyQdT+8xL4iV93bLuGWIKnaWEabszXhao6E4SF3NPI3Zxgn7g/+hfLLxZjturgt97DAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"private error\" title=\"\" src=\"/static/b7e9c57c1c6569986581fea72ac07cfa/3e286/private_error.png\" srcset=\"/static/b7e9c57c1c6569986581fea72ac07cfa/69538/private_error.png 160w,\n/static/b7e9c57c1c6569986581fea72ac07cfa/72799/private_error.png 320w,\n/static/b7e9c57c1c6569986581fea72ac07cfa/3e286/private_error.png 523w\" sizes=\"(max-width: 523px) 100vw, 523px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>에러가 난 부분은 <code class=\"language-text\">private</code> 접근제한자를 사용한 멤버변수인 <code class=\"language-text\">age</code>이다. 이처럼 <code class=\"language-text\">private</code> 접근제한자를 사용하여 선언된 멤버 변수나 메소드는 클래스 내부에서만 사용될 수 있고 외부로는 아예 노출 자체가 되지 않는다. <code class=\"language-text\">public</code>과 <code class=\"language-text\">protected</code>를 사용하여 선언한 멤버 변수인 <code class=\"language-text\">name</code>과 <code class=\"language-text\">address</code>는 정상적으로 접근이 가능한 상태이다.</p>\n<p><code class=\"language-text\">public</code> 같은 경우는 이름만 봐도 클래스 외부에서 마음대로 접근할 수 있도록 열어주는 접근제한자라는 것을 알 수 있지만, <code class=\"language-text\">protected</code>가 접근이 가능한 것은 조금 이상하다. 이름만 보면 왠지 이 친구도 <code class=\"language-text\">private</code>처럼 접근이 막혀야할 것 같은데 왜 외부에서 접근이 가능한 것일까?</p>\n<p><code class=\"language-text\">protected</code> 접근제한자는 해당 클래스를 상속받은 클래스와 같은 패키지 안에 있는 클래스가 아니면 모두 접근을 막는 접근제한자인데, 위의 예시의 경우 필자는 <code class=\"language-text\">Person</code> 클래스와 <code class=\"language-text\">CapsulationTest</code> 클래스를 같은 파일에 선언했으므로 같은 패키지로 인식되어 접근이 가능했던 것이다.</p>\n<p>그럼 <code class=\"language-text\">Person</code> 클래스를 다른 패키지로 분리해내면 어떻게 될까? 테스트 해보기 위해 먼저 <code class=\"language-text\">MyPacks</code>라는 디렉토리를 생성하고 그 안에 <code class=\"language-text\">Person.java</code> 파일을 따로 분리하여 별도의 패키지로 선언해주겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// MyPacks/Person.java</span>\n<span class=\"token keyword\">package</span> <span class=\"token class-name\">MyPacks</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">String</span> address<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> address<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>address <span class=\"token operator\">=</span> address<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// Capsulation.java</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token class-name\">MyPacks</span><span class=\"token punctuation\">.</span><span class=\"token class-name\">Person</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CapsulationTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> main <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Person</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Evan\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Seoul\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">.</span>address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 <code class=\"language-text\">Person</code> 클래스를 별도의 패키지로 분리하면 이제 <code class=\"language-text\">evan.address</code>에도 빨간 줄이 쫙 그어진다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 548px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/bcb46c7cb346bd57c5221ef85372471c/a58fe/protected_error.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 28.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABA0lEQVR42nWRaW6DMBCFuVTNDgbb2AaCA4WmbaJEXXL/I7wOpqkiVfnx6fnN5rEcsKgBizW8Ek9ESD6MzR36DvOQtT/Iqwm8OxFHdMMJbrqAi4mSa5H1REm7nUnZbyxM7F/sVhOnHQJuFmg9QzQTjJ3R6GdINaIWDppytZqQlz147TyCvKKanO9QVgNqOfoYr/c01NKG1CT6L1TtGcpdIc079PABvb/CDhc05kBNM2TzQo2L99q80kWz9ytKH7wm2Q7B+kw7fkP1Z1TdJzI+I5NvyNQRabUgKxxtuCclvLqN8uY38nKkgT0CUbSwRQORKsQxfUoowUIBxmpSSV79g0WP/Q8cfda8AFo/7wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"protected error\" title=\"\" src=\"/static/bcb46c7cb346bd57c5221ef85372471c/a58fe/protected_error.png\" srcset=\"/static/bcb46c7cb346bd57c5221ef85372471c/69538/protected_error.png 160w,\n/static/bcb46c7cb346bd57c5221ef85372471c/72799/protected_error.png 320w,\n/static/bcb46c7cb346bd57c5221ef85372471c/a58fe/protected_error.png 548w\" sizes=\"(max-width: 548px) 100vw, 548px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이렇게 외부 패키지로 불러온 클래스 내부 내의 <code class=\"language-text\">protected</code> 멤버 변수나 메소드에는 바로 접근할 수 없다. 그러나 Person 클래스를 상속한다면 외부 패키지인지 아닌지 여부와 상관 없이 자식 클래스 내에서는 <code class=\"language-text\">protected</code> 멤버에 접근이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// Capsulation.java</span>\n<span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token class-name\">MyPacks</span><span class=\"token punctuation\">.</span><span class=\"token class-name\">Person</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CapsulationTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> main <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Evan</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Evan</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Evan</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Evan</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Evan\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Seoul\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span>address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Seoul\nSeoul</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>접근제한자는 Java 뿐만 아니라 TypeScript, Ruby, C++ 등과 같이 OOP를 지원하는 많은 프로그래밍 언어들도 가지고 있는 기능이므로 이 개념을 잘 알아두면 클래스를 설계할 때 원하는 정보만 노출시키고 원하지 않는 정보는 감추는 방법을 사용하여 보안도 지킬 수 있고 클래스를 가져다 쓰는 사용자로 하여금 쓸데없는 고민을 안하게 해줄 수도 있다.</p>\n<h3 id=\"다형성\" style=\"position:relative;\">다형성<a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"다형성 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>다형성(Polymorphism)은 어떤 하나의 변수명이나 함수명이 상황에 따라서 다르게 해석될 수 있는 것을 의미한다. 다형성은 어떤 한가지 기능을 의미하는 것이 아니라 개념이기 때문에 여러가지 방법으로 표현할 수 있다.</p>\n<p>Java에서 다형성을 위한 대표적인 기능은 바로 추상 클래스(Abstract Class)와 인터페이스(Interface), 그리고 오버로딩(Overloading)이 있다.</p>\n<p>추상 클래스와 인터페이스는 사실 그 용도가 조금 다르지만 필자가 예로 들 간단한 예시에서는 그 차이를 크게 느끼기 힘들기도 하고 무엇보다 이 포스팅은 Java 포스팅이 아니라 단순히 다형성을 설명하기 위함이므로 필자는 이 중 추상 클래스만을 사용할 것이다.</p>\n<p>그럼 이 기능들이 어떤 역할을 하는 지 살펴보면서 다형성이 무엇인가를 좀 더 자세히 알아보도록 하자. 먼저, 추상 클래스를 사용하여 다형성을 만족시키는 예시를 먼저 설명할텐데, 사실 다형성이라는 단어를 모르고 있던 분들이라도 자신도 모르게 이런 설계 패턴을 사용하고 있었을 수도 있을 정도로 기본적인 예시이다.</p>\n<h4 id=\"추상-클래스를-사용한-다형성-구현\" style=\"position:relative;\">추상 클래스를 사용한 다형성 구현<a href=\"#%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1-%EA%B5%AC%ED%98%84\" aria-label=\"추상 클래스를 사용한 다형성 구현 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>추상 클래스는 Java에서 다형성을 만족시키기 위해 자주 사용되는 대표적인 기능이다. 말로만 설명하면 재미가 없으니 한번 코드를 직접 눈으로 보는 것이 좋은데, 필자는 오버워치를 좋아하기 때문에 추상 클래스에 대한 예시도 오버워치를 가져와서 설명하겠다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/06f8964ecaad79656b01074c90c0f24b/e5166/overwatch.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBP/EABQBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdK3UVKif//EABkQAAMBAQEAAAAAAAAAAAAAAAABAhMDFP/aAAgBAQABBQLZnoNx84MoFEn/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAYEAEBAAMAAAAAAAAAAAAAAAAAMRARMv/aAAgBAQAGPwLVxEco/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARITFRgf/aAAgBAQABPyHfBQ1llcAJz38ngws4g5//2gAMAwEAAgADAAAAEEvf/8QAFREBAQAAAAAAAAAAAAAAAAAAACH/2gAIAQMBAT8QiP/EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/EEf/xAAdEAEBAAIBBQAAAAAAAAAAAAABEQAhMVFxkbHB/9oACAEBAAE/EISskHadZiwJZeL7+YGG9ORcUurtTAqDqYJAeXP/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"overwatch\" title=\"\" src=\"/static/06f8964ecaad79656b01074c90c0f24b/c08c5/overwatch.jpg\" srcset=\"/static/06f8964ecaad79656b01074c90c0f24b/0913d/overwatch.jpg 160w,\n/static/06f8964ecaad79656b01074c90c0f24b/cb69c/overwatch.jpg 320w,\n/static/06f8964ecaad79656b01074c90c0f24b/c08c5/overwatch.jpg 640w,\n/static/06f8964ecaad79656b01074c90c0f24b/6a068/overwatch.jpg 960w,\n/static/06f8964ecaad79656b01074c90c0f24b/e5166/overwatch.jpg 1200w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>갓겜 고오급 시계</small>\n  <br>\n</center>\n<p>자, 필자는 이제 오버워치의 여러 영웅들을 클래스로 만드려고 한다. 오버워치의 영웅들은 공통적으로 “궁극기 게이지가 찼을 때 Q 버튼을 누르면 궁극기가 발동된다”라는 기능을 가지고 있다.</p>\n<p>하지만 오버워치의 영웅들은 각자 특색에 맞게 다른 궁극기를 가지고 있는데, 라인하르트는 망치를 내리치며 다른 영웅들을 기절시키고 맥크리는 시야에 보이는 여러 영웅에게 동시에 헤드샷을 날릴 수 있으며 메이는 로봇을 던져서 일정 범위 안의 영웅들을 얼린다.</p>\n<p>이런 경우 다형성을 가지지 않은 오버워치 영웅 클래스는 다음과 같은 모습을 보일 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Hero</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Hero</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Reinhardt</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Hero</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Reinhardt</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"reinhardt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> attackHammer <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"망치 나가신다!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">McCree</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Hero</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">McCree</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mccree\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> attackGun <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"석양이 진다. 빵야빵야\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Mei</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Hero</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Mei</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mei\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> throwRobot <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"꼼짝 마! 움직이지 마세요!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이때 만약 우리가 <code class=\"language-text\">Hero</code> 클래스를 상속받은 영웅 클래스들의 궁극기를 발동시키고 싶다면 어떻게 해야할까? 안봐도 뻔하겠지만 눈물나는 <code class=\"language-text\">if</code>문 또는 <code class=\"language-text\">switch</code>문의 향연이 펼쳐질 것이다.</p>\n<p>모든 영웅들의 궁극기 발동 메소드의 이름이 다르기 때문에 달리 방도가 없다. 그리고 추가적으로 <code class=\"language-text\">Hero</code> 클래스에는 궁극기 발동 메소드가 없기 때문에 객체를 해당 영웅의 클래스로 형변환 해줘야하는 불편한 작업도 해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> main <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Mei</span> myMei <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Mei</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Reinhardt</span> myReinhardt <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Reinhardt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">McCree</span> myMcCree <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">McCree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Main</span><span class=\"token punctuation\">.</span><span class=\"token function\">doUltimate</span><span class=\"token punctuation\">(</span>myMei<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Main</span><span class=\"token punctuation\">.</span><span class=\"token function\">doUltimate</span><span class=\"token punctuation\">(</span>myReinhardt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Main</span><span class=\"token punctuation\">.</span><span class=\"token function\">doUltimate</span><span class=\"token punctuation\">(</span>myMcCree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> doUltimate <span class=\"token punctuation\">(</span><span class=\"token class-name\">Hero</span> hero<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hero <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Reinhardt</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">Reinhardt</span> myHero <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Reinhardt</span><span class=\"token punctuation\">)</span>hero<span class=\"token punctuation\">;</span>\n            myHero<span class=\"token punctuation\">.</span><span class=\"token function\">attackHammer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hero <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">McCree</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">McCree</span> myHero <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">McCree</span><span class=\"token punctuation\">)</span>hero<span class=\"token punctuation\">;</span>\n            myHero<span class=\"token punctuation\">.</span><span class=\"token function\">attackGun</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hero <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Mei</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">Mei</span> myHero <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Mei</span><span class=\"token punctuation\">)</span>hero<span class=\"token punctuation\">;</span>\n            myHero<span class=\"token punctuation\">.</span><span class=\"token function\">throwRobot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">꼼짝 마! 움직이지 마세요!\n망치 나가신다!\n석양이 진다. 빵야빵야</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>여기에 영웅이 더 추가된다면 영웅의 종류 만큼 분기의 개수도 늘어날 것이고, 무엇보다 <code class=\"language-text\">Mei myHero = (Mei)hero</code>처럼 굳이 새로운 변수를 선언하면서 사용하고 있는 걸 보자니 마음이 한켠이 먹먹해져온다. 다형성은 바로 이럴 때 우리를 행복하게 만들어 줄 수 있는 단비와 같은 개념이다.</p>\n<p>자, 아까 위에서 필자는 다형성의 개념을 어떤 하나의 변수명이나 함수명이 상황에 따라서 다르게 해석될 수 있는 것이라고 했다. 그렇다면 이 경우 우리는 영웅들의 궁극기 호출 메소드명을 <code class=\"language-text\">ultimate</code>로 통일하되, 이 메소드를 호출했을 때 실행되는 코드는 영웅에 따라 달라지도록 만들면 다형성을 만족시킬 수 있는 것이다.</p>\n<p>이런 경우 그냥 <code class=\"language-text\">Hero</code> 클래스를 상속받은 영웅 클래스들에게 직접 하나하나 <code class=\"language-text\">ultimate</code>라는 메소드를 선언할 수도 있지만, 그렇게 되면 개발자가 실수할 확률이 존재한다. <small>(특히 오타로 인한 실수가 가장 많을 것이다)</small> 그래서 Java는 개발자가 특정 메소드를 강제로 구현하도록 만들어주는 기능을 제공한다.</p>\n<p>그 기능이 바로 추상 클래스(Abstract Class)와 인터페이스(Interface)인 것이다. 필자는 위에서 한번 이야기 했듯이 이 중 추상 클래스만을 사용하여 예제를 진행할 것이다.</p>\n<p>그래도 혹시 이 두 기능이 뭐가 다른지 궁금하신 분이 있을 것 같으니 최대한 간단히만 설명하고 넘어가자면, 추상 클래스는 어떤 클래스의 기능을 그대로 사용하면서 그 기능을 확장하고 싶을 때 사용하는 것이고 인터페이스는 아무런 구현체가 없는 그냥 껍데기만 구현하는 것이다.</p>\n<p>그렇기 때문에 인터페이스에는 자세한 메소드의 구현체가 들어갈 수 없지만 추상 클래스는 자체적인 메소드의 구현체를 가질 수도 있다. <small>(Java 8부터는 default 키워드를 사용하여 인터페이스에도 메소드 구현체를 넣을 수 있게 변경되긴했다. 덕분에 구분이 더 애매해짐.)</small></p>\n<p>이 예제의 <code class=\"language-text\">Hero</code> 클래스는 <code class=\"language-text\">name</code> 멤버 변수를 생성자로부터 받아서 자신의 멤버 변수로 추가하는 기능을 가지고 있기 때문에 추상 클래스를 사용하는 것이 더 적절하다. 그럼 이제 추상 클래스를 사용하여 <code class=\"language-text\">ultimate</code> 메소드의 구현을 강제해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Hero</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Hero</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 내부 구현체가 없는 추상 메소드를 선언한다.</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">void</span> ultimate <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Reinhardt</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Hero</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Reinhardt</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"reinhardt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> ultimate <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"망치 나가신다!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">McCree</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Hero</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">McCree</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mccree\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> ultimate <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"석양이 진다. 빵야빵야\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Mei</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Hero</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Mei</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mei\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> ultimate <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"꼼짝 마! 움직이지 마세요!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 추상 클래스인 <code class=\"language-text\">Hero</code>를 상속받은 영웅 클래스들은 무조건 <code class=\"language-text\">ultimate</code> 메소드를 구현해야한다. 이렇게 메소드명이 통일되면 영웅 클래스를 가져다 쓰는 입장에서는 궁극기를 발동시키고 싶을 때 어떤 메소드를 호출해야할지 이제 더 이상 고민할 필요가 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> main <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Mei</span> myMei <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Mei</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Reinhardt</span> myReinhardt <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Reinhardt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">McCree</span> myMcCree <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">McCree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Main</span><span class=\"token punctuation\">.</span><span class=\"token function\">doUltimate</span><span class=\"token punctuation\">(</span>myMei<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Main</span><span class=\"token punctuation\">.</span><span class=\"token function\">doUltimate</span><span class=\"token punctuation\">(</span>myReinhardt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Main</span><span class=\"token punctuation\">.</span><span class=\"token function\">doUltimate</span><span class=\"token punctuation\">(</span>myMcCree<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> doUltimate <span class=\"token punctuation\">(</span><span class=\"token class-name\">Hero</span> hero<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Hero 클래스를 상속받은 클래스는</span>\n        <span class=\"token comment\">// 무조건 ultimate 메소드를 가지고 있다는 것이 보장된다.</span>\n        hero<span class=\"token punctuation\">.</span><span class=\"token function\">ultimate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>어떤가? 코드가 훨씬 심플해지지 않았는가? 추상 메소드를 사용하여 클래스 내부의 <code class=\"language-text\">ultimate</code>라는 메소드의 구현을 강제했기 때문에 <code class=\"language-text\">Hero</code> 클래스를 상속받은 영웅 클래스에 해당 메소드가 없을 확률은 전혀 없다. 그렇기 때문에 사용하는 입장에서는 깊은 고민없이 안심하고 <code class=\"language-text\">ultimate</code> 메소드를 호출할 수 있다.</p>\n<p>또한 <code class=\"language-text\">ultimate</code> 메소드는 모든 영웅 클래스들이 가지고 있는 메소드이지만 내부 구현은 전부 다르기 때문에 발동하는 스킬 또한 영웅 별로 다르게 나올 것이다. 이런 것을 바로 다형성이라고 하는 것이다.</p>\n<h4 id=\"오버로딩을-사용한-다형성-구현\" style=\"position:relative;\">오버로딩을 사용한 다형성 구현<a href=\"#%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1-%EA%B5%AC%ED%98%84\" aria-label=\"오버로딩을 사용한 다형성 구현 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>이번에는 오버로딩(Overloading)을 사용한 다형성의 예시를 한번 살펴보도록 하자. 위의 상속 챕터에서 잠깐 언급하고 넘어간 오버라이딩(Overriding)과 헷갈리지 말자.</p>\n<p>오버라이딩은 부모 클래스의 멤버 변수나 메소드를 덮어 씌우는 것이고, 오버로딩은 같은 이름의 메소드를 상황에 따라 다르게 사용할 수 있게 해주는 다형성을 위한 기능이다.<small>(필자는 학교에서 시험볼 때 자주 헷갈렸다)</small></p>\n<p>오버로딩은 생각보다 단순한 개념이지만, 만약 오버로딩을 지원하지 않는 언어인 JavaScipt나 Python을 주로 사용하는 개발자들에게는 나름 충공깽일 수 있다. 그 이유는 바로 오버로딩이 “메소드의 인자로 어떤 것을 넘기냐에 따라서 이름만 같은 다른 메소드가 호출되는 기능”이기 때문이다.</p>\n<center>\n  <img src=\"/3abde762b5e8eea7abbf6e856bc86e9e/dog_voice.gif\" width=\"100%\">\n  <small>이게 뭔 개소리야?</small>\n</center>\n<p>어떤 클래스가 <code class=\"language-text\">sum</code>이라는 메소드를 가지고 있다고 생각해보자. 이때 <code class=\"language-text\">sum</code>은 두 개의 인자를 받은 후 이 두 값을 합쳐서 리턴하는 내부 구조를 가지고 있다. 근데 만약 3개를 합치고 싶다면 어떻게 해야할까? 이런 경우에 JavaScript와 같이 오버로딩을 지원하지 않는 언어에서는 편법을 사용할 수 밖에 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Calculator</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">sum</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span>args</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> args<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prev<span class=\"token punctuation\">,</span> current</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> prev <span class=\"token operator\">+</span> current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Calculator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nc<span class=\"token punctuation\">.</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">15</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>뭐 어쨌든 되긴 되니까 상관없다고 생각할 수 있지만, 이건 객체의 다형성이라기보다 그냥 JavaScript의 언어적인 특성을 사용하여 우회한 것에 불과하다. 이렇게 작성하면 “두 개의 인자를 더해서 반환하는 메소드”에서 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>개의 인자를 더해서 반환하는 메소드”로는 만들 수 있지만 객체의 다형성을 만족할 수는 없다. 이 메소드의 “더한다”라는 기능 자체도 변경할 수 있어야 그제서야 다형성을 만족한다고 할 수 있는 것이다.</p>\n<p>반면, Java나 C++과 같은 언어에서는 제대로 다형성을 만족시킬 수 있는 오버로딩을 지원한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Overloading</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> sum <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> sum <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">+</span> c<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> sum <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> a<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b <span class=\"token operator\">+</span> <span class=\"token string\">\"입니다.\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>쨘, 간단한 클래스를 하나 선언하고 <code class=\"language-text\">sum</code>이라는 메소드를 여러 개 선언했다. 만약 JavaScript에서 이렇게 선언했다가는 위에 선언된 두개의 <code class=\"language-text\">sum</code>은 무시되고 맨 아래의 <code class=\"language-text\">sum</code> 메소드로 덮어씌워지기 때문에 오버로딩을 할 수가 없다.</p>\n<p>그리고 문자열을 인자로 받는 <code class=\"language-text\">sum</code> 메소드의 경우에는 문자열 맨 뒤에 <code class=\"language-text\">입니다</code>도 붙히는 센스를 발휘하도록 만들어주었다. JavaScript에서는 이 동작을 구현하려면 반드시 타입을 체크하는 조건 분기문이 필요하지만 Java는 오버로딩을 지원하기 때문에 그럴 필요가 없다.</p>\n<p>그럼 이제 한번 이 메소드들이 잘 작동하나 호출해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> main <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Overloading</span> o <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Overloading</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"자\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"바\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">3\n6\n자바입니다.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위의 예시에서 볼 수 있듯이 <code class=\"language-text\">Overloading</code> 클래스는 여러 개의 <code class=\"language-text\">sum</code> 메소드를 가지고 있고, 메소드의 인자가 무엇인지에 따라서 이름만 동일한 다른 메소드들을 호출해주고 있다. 이것이 오버로딩이며, Java에서 제공해주는 대표적인 다형성 지원 기능 중 하나이다. <small>(오버라이딩이랑 헷갈리지 말자!)</small></p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이 포스팅을 작성할 때 생각했던 타겟 독자층은 컴퓨터 공학을 전공한 개발자들이 아니였다. 애초에 컴퓨터 공학을 전공하거나, 타 과라도 컴퓨터 공학 전공 수업을 들었던 사람들은 대부분 학교에서 객체 지향 프로그래밍이라는 수업을 들어보았을 것이기 때문에 이 개념에 대해서 어느 정도 알고 있을 것이다.</p>\n<p>필자가 이 포스팅의 타겟으로 하는 독자는 바로 학원이나 부트캠프에서 코딩을 처음 배우신지 얼마 안된 분들이다. 학원이나 부트캠프에서는 Java를 가르치는 경우가 아니라면 OOP에 대한 내용을 거의 언급하지 않고 넘어가는 경우가 많은 것으로 알고 있다.</p>\n<p>사실 학교와 다르게 학원은 짧은 기간 안에 실무를 할 수 있는 인재를 양성하여 취업시키는 것이 목적인 기관이라는 점을 생각해보면 이해가 안가는 것도 아니지만, OOP는 Java에만 국한된 개념이 아니라 어떤 언어를 사용하더라도 적용할 수 있는 범용적인 프로그래밍 패러다임이기 때문에 이에 대한 내용을 가르치지 않는 것이 안타깝긴 하다.</p>\n<p>참고로 필자는 “OOP가 좋은 패러다임이니까 배워야 한다”라고 이야기하는 것이 아니다. 이 포스팅의 서두에서 한번 언급했듯이 전 세계에서 상당한 점유율을 차지하고 있는 메이저 언어인 Java, Python, C++과 같은 언어들이 대부분 OOP를 기반으로 설계되었거나 OOP를 지원하기 때문에 2019년에 프로그래밍을 하는 개발자라면 좋든 싫든 OOP를 알고는 있어야 한다고 생각하기 때문에 OOP를 추천하는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/404c558b3a2fcd4454b64ed3fc28f4e5/7ca1f/language_index.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 41.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA6ElEQVR42nWS6RKDIAyEff8X9RwVjwJeqV86oYzT/thxIZtlAxbOOZmmSbZtk77vZVmWxGOMQr3rOhmGQcZx1Nq+7+K9l7Isdc0+9eM4pKDpPE8tADZpuK5L+bquukYD4IC+qqrSoYCeIoSgAsw49cOjhPBSA4SkNo0Z0tc0jfJ5nnVK9GpIEsRfHiXehnDEeXIA5/C2bZMmGVJgk+jGLeFxCxDSyPdpWNe1cmpMooYY/U7o08gY2tXkI+cJwf+ENw9+VYG97nNkDC0hdaCPYiZ2qr7knZY7RODcqCOhyUEAfif0docYvgE1GW9g4T9oMQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"language index\" title=\"\" src=\"/static/404c558b3a2fcd4454b64ed3fc28f4e5/6af66/language_index.png\" srcset=\"/static/404c558b3a2fcd4454b64ed3fc28f4e5/69538/language_index.png 160w,\n/static/404c558b3a2fcd4454b64ed3fc28f4e5/72799/language_index.png 320w,\n/static/404c558b3a2fcd4454b64ed3fc28f4e5/6af66/language_index.png 640w,\n/static/404c558b3a2fcd4454b64ed3fc28f4e5/d9199/language_index.png 960w,\n/static/404c558b3a2fcd4454b64ed3fc28f4e5/21b4d/language_index.png 1280w,\n/static/404c558b3a2fcd4454b64ed3fc28f4e5/7ca1f/language_index.png 1890w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>\n    TIOBE의 2019년 8월 전 세계 언어 순위<br>\n    C와 JavaScript, SQL을 제외한 모든 언어가 OOP를 사용한다.\n  </small>\n</center>\n<p>어차피 프로그래밍 패러다임에는 정답이 없다. 선언적 프로그래밍이 좋은 것이냐, 명령적 프로그래밍이 좋은 것이냐라고 물어보면 쉽사리 대답할 수 없는 것 처럼 말이다. 그냥 우리는 어떤 패러다임이 어떤 방향을 추구하는지, 거기서 파생된 개념은 어떤 것들이 있는 지를 학습하고 각기 상황에 맞는 패러다임을 도입해서 사용하면 되는 것이다.</p>\n<p>어쨌든 이 포스팅을 통해 혹시나 OOP를 모르고 있었거나, 아니면 너무 어렵게 느끼고 있던 분들이 좀 더 OOP를 친숙하게 받아들일 수 있기를 바라는 마음이다.</p>\n<p>이상으로 알고 보면 재밌는 객체 지향 프로그래밍, OOP 흝어보기 포스팅을 마친다.</p>","fields":{"slug":"20190824-what-is-object-oriented-programming","path":"/2019/08/24/what-is-object-oriented-programming/","lang":"ko"},"frontmatter":{"title":"알고 보면 재밌는 객체 지향 프로그래밍, OOP 흝어보기","subTitle":"클래스, 상속, 다형성으로 보는 OOP의 기본 개념","date":"Aug 24, 2019","categories":["프로그래밍","아키텍처"],"tags":["OOP","객체지향 프로그래밍","Object Oriendted Programming","프로그램 설계","SOLID","프로그램 설계 기초"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/2f02b656a28de12eb8100adecd7d55af/3a812/thumbnail.jpg","srcSet":"/static/2f02b656a28de12eb8100adecd7d55af/3a812/thumbnail.jpg 320w,\n/static/2f02b656a28de12eb8100adecd7d55af/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/2f02b656a28de12eb8100adecd7d55af/fc5c5/thumbnail.webp 320w,\n/static/2f02b656a28de12eb8100adecd7d55af/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/2f02b656a28de12eb8100adecd7d55af/2d839/thumbnail.jpg","srcSet":"/static/2f02b656a28de12eb8100adecd7d55af/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/2f02b656a28de12eb8100adecd7d55af/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"category":"아키텍처","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}