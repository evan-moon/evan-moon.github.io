{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/논리학/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"8cbe53c0-b1ad-5980-ba9e-035a2e8d9b9b","tableOfContents":"<ul>\n<li><a href=\"#%ED%83%80%EC%9E%85-%EA%B2%80%EC%82%AC%EB%8A%94-%EC%A0%95%EB%A7%90-%EA%B2%80%EC%82%AC%EC%9D%BC-%EB%BF%90%EC%9D%BC%EA%B9%8C\">타입 검사는 정말 “검사”일 뿐일까</a></li>\n<li><a href=\"#%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%84%B8-%EA%B8%B0%EB%91%A5-%ED%98%95%EC%8B%9D-%EB%85%BC%EB%A6%AC%ED%95%99-%EC%A7%91%ED%95%A9%EB%A1%A0-%EB%9E%8C%EB%8B%A4-%EB%8C%80%EC%88%98\">타입 시스템의 세 기둥: 형식 논리학, 집합론, 람다 대수</a></li>\n<li><a href=\"#%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EB%85%BC%EB%A6%AC%EC%A0%81-%EA%B5%AC%EC%A1%B0\">타입으로 보는 논리적 구조</a></li>\n<li><a href=\"#%ED%95%A9%EC%84%B1%EA%B3%BC-%EB%B3%80%ED%99%98\">합성과 변환</a></li>\n<li><a href=\"#typescript%EB%8A%94-100-%EB%85%BC%EB%A6%AC%EC%A0%81%EC%9D%B4%EC%A7%80-%EC%95%8A%EB%8B%A4\">TypeScript는 100% 논리적이지 않다</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","excerpt":"우리는 매일 타입을 사용하며, 무수한 타입 에러를 마주한다. 그때마다 에러 메시지를 읽고, 구글링해서 해결하긴 하지만 정작 “타입 시스템이 왜 이렇게 동작하는지”를 깊게 생각하며 문제를 해결하는 경우는 드물다. 타입을 쓸 줄 아는 것이 문법을 이해하는 것이라면, 타입 시스템을 이해하는 것은 그 문법이 왜 그렇게 설계되었는지에 대한 본질을 이해하는 것에 가깝다.","html":"<p>우리는 매일 타입을 사용하며, 무수한 타입 에러를 마주한다. 그때마다 에러 메시지를 읽고, 구글링해서 해결하긴 하지만 정작 “타입 시스템이 왜 이렇게 동작하는지”를 깊게 생각하며 문제를 해결하는 경우는 드물다.</p>\n<p>타입을 쓸 줄 아는 것이 문법을 이해하는 것이라면, 타입 시스템을 이해하는 것은 그 문법이 왜 그렇게 설계되었는지에 대한 본질을 이해하는 것에 가깝다.</p>\n<!-- more -->\n<p>사실 이러한 이해를 돕기 위해 <a href=\"/2024/01/30/category-theory-for-programmers-0-preface/\">“프로그래머를 위한 카테고리 이론”</a> 시리즈를 번역하면서 카테고리, 펑터, 합성 같은 개념을 다뤘었는데, 지금 돌아보니 진입 장벽이 꽤 높은 내용이라, 조금 더 쉬운 버전의 포스팅을 다시 작성하려고 한다.</p>\n<p>그래서 이번 포스팅에서는 타입과 논리학의 대응 관계를 중심으로, 타입 검사기가 “통과”라고 말할 때 그것이 정확히 무엇을 의미하는지 살펴보려 한다.</p>\n<h2 id=\"타입-검사는-정말-검사일-뿐일까\" style=\"position:relative;\">타입 검사는 정말 “검사”일 뿐일까<a href=\"#%ED%83%80%EC%9E%85-%EA%B2%80%EC%82%AC%EB%8A%94-%EC%A0%95%EB%A7%90-%EA%B2%80%EC%82%AC%EC%9D%BC-%EB%BF%90%EC%9D%BC%EA%B9%8C\" aria-label=\"타입 검사는 정말 검사일 뿐일까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>TypeScript를 처음 배울 때 대부분의 개발자는 타입 시스템을 일종의 린터(linter)처럼 받아들인다. 마치 린터처럼 잘못된 타입을 넣으면 빨간 줄이 그어지고, 올바른 타입을 넣으면 통과하기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Error: Argument of type 'string' is not assignable to parameter of type 'number'</span>\n<span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>틀린 말은 아니지만 이 관점에는 한 가지 빠진 것이 있다.</p>\n<p>타입 시스템은 단순히 에러를 잡는 도구가 아니다. 그 뒤에는 수학적 구조가 있고, 타입 검사를 통과한다는 것은 단순히 에러가 없다는 것 이상의 의미를 가진다. 타입은 논리학의 명제에 대응하고, 그 타입을 만족하는 코드는 그 명제의 증명에 대응한다.</p>\n<p>그렇다면 우리가 마주하는 타입 에러는 무엇일까? 단순한 실수일까, 아니면 우리가 암묵적으로 맺은 어떤 계약이 깨졌다는 신호일까.</p>\n<p>이 이야기를 이해하려면 가장 먼저 타입 시스템에 사용되는 기본적인 수학의 개념들에 대한 이야기를 해야한다.</p>\n<h2 id=\"타입-시스템의-세-기둥-형식-논리학-집합론-람다-대수\" style=\"position:relative;\">타입 시스템의 세 기둥: 형식 논리학, 집합론, 람다 대수<a href=\"#%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%84%B8-%EA%B8%B0%EB%91%A5-%ED%98%95%EC%8B%9D-%EB%85%BC%EB%A6%AC%ED%95%99-%EC%A7%91%ED%95%A9%EB%A1%A0-%EB%9E%8C%EB%8B%A4-%EB%8C%80%EC%88%98\" aria-label=\"타입 시스템의 세 기둥 형식 논리학 집합론 람다 대수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>타입 시스템은 세 가지 수학적 아이디어 위에 서 있다. 갑자기 수학에 대한 이야기가 나와서 어렵게 느껴질 수 있지만 걱정할 필요 없다. 이 개념들은 우리가 이미 코드로 매일 다루고 있는 것들이다.</p>\n<h4 id=\"형식-논리학-참이다를-증명한다는-것\" style=\"position:relative;\">형식 논리학: “참이다”를 증명한다는 것<a href=\"#%ED%98%95%EC%8B%9D-%EB%85%BC%EB%A6%AC%ED%95%99-%EC%B0%B8%EC%9D%B4%EB%8B%A4%EB%A5%BC-%EC%A6%9D%EB%AA%85%ED%95%9C%EB%8B%A4%EB%8A%94-%EA%B2%83\" aria-label=\"형식 논리학 참이다를 증명한다는 것 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>형식 논리학은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이다, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이거나 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이다, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이다 같은 논리들을 다루는 체계다. 핵심 아이디어는 “참이라고 주장하려면, 그것을 증명해야 한다는 것”이다.</p>\n<table>\n<thead>\n<tr>\n<th>기호</th>\n<th>일상적 의미</th>\n<th>예시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>∧</td>\n<td>그리고</td>\n<td>“우산도 있고 장화도 있다”</td>\n</tr>\n<tr>\n<td>∨</td>\n<td>또는</td>\n<td>“버스를 타거나 지하철을 탄다”</td>\n</tr>\n<tr>\n<td>→</td>\n<td>~하면 ~이다</td>\n<td>“비가 오면 땅이 젖는다”</td>\n</tr>\n</tbody>\n</table>\n<p>예를 들어 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\lor B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 참이라고 말하려면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>가 참임을 보여주거나, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 참임을 보여줘야 한다. “둘 중 하나는 참이겠지만 어느 쪽인지는 몰라요”라는 식의 주장은 증명으로 인정되지 않는다.</p>\n<p>그리고 일단 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\lor B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“를 받아들이면, 그로부터 무언가를 이끌어내기 위해서는 두 경우(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>)를 모두 다루는 분기가 필요하다는 것도 알 수 있다. 이는 마치 코드에서 <code class=\"language-text\">string | number</code>를 다룰 때 타입 좁히기가 필요한 이유와 같은 구조다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">  <span class=\"token comment\">// \"A 또는 B\"가 참이라고 주장하려면, 둘 중 하나를 구체적으로 보여줘야 한다</span>\n  <span class=\"token keyword\">type</span> <span class=\"token class-name\">Result</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> Result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// \"둘 중 하나겠지\"로는 안 된다. 어떤 경우인지 확인해야 한다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">.</span><span class=\"token function\">toFixed</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id=\"집합론-타입은-원소들의-모임이다\" style=\"position:relative;\">집합론: 타입은 원소들의 모임이다<a href=\"#%EC%A7%91%ED%95%A9%EB%A1%A0-%ED%83%80%EC%9E%85%EC%9D%80-%EC%9B%90%EC%86%8C%EB%93%A4%EC%9D%98-%EB%AA%A8%EC%9E%84%EC%9D%B4%EB%8B%A4\" aria-label=\"집합론 타입은 원소들의 모임이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>집합은 비슷한 것들을 모아놓은 주머니라고 생각하면 된다. 예를 들어 <code class=\"language-text\">number</code> 타입은 프로그램 상에서 표현할 수 있는 모든 숫자를 담은 주머니, <code class=\"language-text\">string</code> 타입은 모든 문자열을 담은 주머니이고, <code class=\"language-text\">number | string</code>은 이 두 주머니의 내용물을 합친 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 숫자 주머니에서 하나 꺼냄</span>\n<span class=\"token keyword\">const</span> n<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 문자열 주머니에서 하나 꺼냄</span>\n<span class=\"token keyword\">const</span> s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 둘 중 아무 주머니에서나 꺼낸 것</span>\n<span class=\"token keyword\">const</span> x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0.5</span> <span class=\"token operator\">?</span> <span class=\"token number\">42</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>타입을 집합으로 생각하면 많은 것이 자연스러워진다. <code class=\"language-text\">never</code> 타입은 빈 주머니이고, <code class=\"language-text\">unknown</code> 타입은 세상 모든 것이 들어있는 주머니다.</p>\n<p>물론 엄밀하게 이야기하자면 TypeScript의 실제 타입 시스템은 순수한 집합론과 다른 부분이 있지만, 이 정도 이해로도 직관을 잡기에는 충분하다.</p>\n<h4 id=\"람다-대수-함수-그-이상의-의미\" style=\"position:relative;\">람다 대수: 함수, 그 이상의 의미<a href=\"#%EB%9E%8C%EB%8B%A4-%EB%8C%80%EC%88%98-%ED%95%A8%EC%88%98-%EA%B7%B8-%EC%9D%B4%EC%83%81%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"람다 대수 함수 그 이상의 의미 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>람다 대수는 1930년대 알론조 처치(Alonzo Church)라는 수학자가 “계산이란 무엇인가?”라는 질문에 답하려고 만든 개념이다. 이름은 무시무시하게 느껴지지만, 사실 개발자라면 이미 매일 쓰고 있는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// 람다 대수로 표현하면 λx.x</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">identity</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 람다 대수로 표현하면 λx.λy.x</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">first</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token parameter\">y</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>화살표 함수는 람다(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span></span>) 표기의 현대적 문법에 가깝고, 람다 대수의 핵심 아이디어인 “함수 정의와 적용”을 가장 직접적으로 보여준다. 처치가 증명한 놀라운 사실은 이 단순한 개념만으로도 사칙연산, 조건문, 반복문, 심지어 숫자 자체까지 모두 표현할 수 있다는 것이다.</p>\n<p>물론 실제 JavaScript 함수는 부수효과, 예외, <code class=\"language-text\">this</code> 바인딩, 런타임 객체 모델 같은 것 때문에 람다 대수와 100% 동일하다고 말하기는 어렵다. 하지만 “계산이란 결국 함수를 만들고 적용하는 것”이라는 핵심적인 통찰은 공유하기 때문에 이 정도 이해로도 충분하다.</p>\n<h4 id=\"세-세계가-만나는-지점-curry-howard-대응\" style=\"position:relative;\">세 세계가 만나는 지점: Curry-Howard 대응<a href=\"#%EC%84%B8-%EC%84%B8%EA%B3%84%EA%B0%80-%EB%A7%8C%EB%82%98%EB%8A%94-%EC%A7%80%EC%A0%90-curry-howard-%EB%8C%80%EC%9D%91\" aria-label=\"세 세계가 만나는 지점 curry howard 대응 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>그렇다면 이 세 가지 개념이 타입 시스템에 어떻게 사용되고 있다는 것일까? 이 질문에 대한 답을 하려면 이 개념들을 하나로 묶어주는 Curry-Howard 대응에 대해 이야기해야한다.</p>\n<p>Curry-Howard 대응 또는 Curry-Howard 동형이라고 불리는 개념은 컴퓨터 프로그램과 논리적 증명을 직접적으로 연관시키는 대응 관계를 의미한다. 더 정확하게 말하자면 논리학의 증명 규칙과 타입 시스템의 타입 규칙이 서로 대응한다는 주장이다.</p>\n<p>이 개념은 이미 1930년대에 하스켈 커리(Haskell Curry)라는 논리학자가 람다 대수에 타입을 붙여보다가 발견한 규칙이며, 이후 1969년 윌리엄 하워드(William Howard)가 이 발견을 더 깊이 파고들어 아래와 같은 대응 관계를 확립했다.</p>\n<table>\n<thead>\n<tr>\n<th>논리학에서</th>\n<th>프로그래밍에서</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>명제</td>\n<td>타입</td>\n</tr>\n<tr>\n<td>증명</td>\n<td>프로그램</td>\n</tr>\n<tr>\n<td>A이면 B</td>\n<td>A를 받아 B를 반환하는 함수</td>\n</tr>\n<tr>\n<td>A 그리고 B</td>\n<td>A와 B를 둘 다 가진 튜플/객체</td>\n</tr>\n<tr>\n<td>A 또는 B</td>\n<td>A이거나 B인 유니온 타입</td>\n</tr>\n<tr>\n<td>거짓 (증명 불가능)</td>\n<td>never (값이 존재할 수 없음)</td>\n</tr>\n</tbody>\n</table>\n<p>결국 이 개념의 핵심을 한 줄로 요약해보면 아래와 같다.</p>\n<blockquote>\n<p>타입은 명제에 대응하고, 그 타입의 값을 만드는 프로그램은 그 명제의 증명에 대응한다.</p>\n</blockquote>\n<p>TypeScript는 실용을 위해 이 아이디어를 부분적으로 차용한 언어다. 부분적으로 차용한 언어라는 의미는 <code class=\"language-text\">any</code>나 타입 단언 같은 탈출구가 있기 때문이다.</p>\n<p>그래서 이 글에서 “증명”이라는 표현은 “타입 규칙이 요구하는 계약을 충족한다” 정도로 이해하면 된다. TypeScript의 한계에 대해서는 글 끝에서 다시 이야기해보겠다.</p>\n<h2 id=\"타입으로-보는-논리적-구조\" style=\"position:relative;\">타입으로 보는 논리적 구조<a href=\"#%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EB%85%BC%EB%A6%AC%EC%A0%81-%EA%B5%AC%EC%A1%B0\" aria-label=\"타입으로 보는 논리적 구조 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그렇다면 이 Curry-Howard 대응이 실제로 어떻게 나타나는지 하나씩 뜯어보자.</p>\n<h4 id=\"함수-a이면-b의-증거\" style=\"position:relative;\">함수: “A이면 B”의 증거<a href=\"#%ED%95%A8%EC%88%98-a%EC%9D%B4%EB%A9%B4-b%EC%9D%98-%EC%A6%9D%EA%B1%B0\" aria-label=\"함수 a이면 b의 증거 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>먼저 가장 핵심적인 대응인 함수 타입부터 살펴보자. 함수 타입 <code class=\"language-text\">(a: A) => B</code>는 논리학에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>에 해당한다.</p>\n<p>이게 무슨 말일까? 이해를 돕기 위해 조금 더 일상적인 비유로 풀어보면 이렇다.</p>\n<p>친구가 “네가 밀가루를 주면, 내가 빵을 만들어줄게”라고 약속했다고 하자. 이것은 “밀가루 → 빵”이라는 명제다. 그렇다면 이 약속이 진짜인지는 어떻게 확인할 수 있을까? 간단하다. 실제로 밀가루를 줬을 때 빵이 나오면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">makeBread</span><span class=\"token punctuation\">(</span>flour<span class=\"token operator\">:</span> Flour<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Bread <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 밀가루를 반죽하고, 발효시키고, 굽는 과정을 거친 뒤...</span>\n  <span class=\"token keyword\">return</span> bread<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수가 타입 검사를 통과한다는 것은, “밀가루를 주면 빵을 만들 수 있다”는 약속이 타입 규칙 안에서 이행 가능함을 보여준 것이다. 함수의 구현체 자체가 그 계약의 이행인 셈이다.</p>\n<p>그렇다면 반대로 타입 에러가 발생한다면 어떻게 되는 걸까?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">makeBread</span><span class=\"token punctuation\">(</span>flour<span class=\"token operator\">:</span> Flour<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Bread <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Error: Type 'Flour' is not assignable to type 'Bread'</span>\n  <span class=\"token keyword\">return</span> flour<span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>원래 밀가루를 주면 빵을 만들어서 주기로 했는데, 뜬금없이 밀가루를 다시 돌려줬으니 이것은 계약 불이행이라고 볼 수 있고, 따라서 타입 에러가 발생한다.</p>\n<p>또한 이 계약과 구조가 제대로 지켜지면 이제 우리는 함수의 동작 결과를 추론할 수 있게 된다.</p>\n<p>논리학에는 전건 긍정(Modus Ponens)이라는 추론 규칙이 있는데, 간단하게 정리해보면 아래와 같다.</p>\n<blockquote>\n<p>”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이다”가 참이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>가 참이면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>도 참이다.</p>\n</blockquote>\n<p>예를 들어 “비가 오면 땅이 젖는다”는 명제가 참이고 “비가 온다”라는 명제도 참이라면, 이에 따라 “땅이 젖는다”라는 명제도 참이라는 것을 손쉽게 추론할 수 있다. 이 구조는 프로그래밍에서 함수 호출과 같은 구조이기 때문에 우리는 함수의 결과 타입을 추론할 수 있게 되는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// \"밀가루 → 빵\" 약속</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">makeBread</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>flour<span class=\"token operator\">:</span> Flour<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Bread <span class=\"token operator\">=</span> <span class=\"token comment\">/* ... */</span><span class=\"token punctuation\">;</span>  \n\n<span class=\"token comment\">// 밀가루가 있음</span>\n<span class=\"token keyword\">const</span> flour<span class=\"token operator\">:</span> Flour <span class=\"token operator\">=</span> <span class=\"token function\">getFlour</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 따라서 빵을 얻음</span>\n<span class=\"token keyword\">const</span> bread<span class=\"token operator\">:</span> Bread <span class=\"token operator\">=</span> <span class=\"token function\">makeBread</span><span class=\"token punctuation\">(</span>flour<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>함수 <code class=\"language-text\">makeBread</code>는 “밀가루를 주면 빵을 만들어준다”라는 명제이다. 즉, 이 명제가 참이고 “밀가루를 준다”라는 명제도 참이라면 자연스럽게 <code class=\"language-text\">bread</code> 변수에 담기는 값이 <code class=\"language-text\">Bread</code> 타입이라는 명제도 참이 되는 것이다.</p>\n<p>우리가 매일 하는 함수의 호출과 결과 타입의 추론은 이러한 논리적 추론과 같은 구조를 가지고 있는 것이다.</p>\n<h4 id=\"튜플-그리고의-증거\" style=\"position:relative;\">튜플: “그리고”의 증거<a href=\"#%ED%8A%9C%ED%94%8C-%EA%B7%B8%EB%A6%AC%EA%B3%A0%EC%9D%98-%EC%A6%9D%EA%B1%B0\" aria-label=\"튜플 그리고의 증거 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>논리학의 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> 그리고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“는 프로그래밍의 튜플이나 객체에 해당한다.</p>\n<p>일상적인 예로 생각해보자. 해외여행을 가려면 “여권이 있고 비행기 표도 있다”는 조건을 만족해야 한다. 이 조건을 충족하려면? 여권과 비행기 표를 둘 다 보여주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">CanTravel</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>Passport<span class=\"token punctuation\">,</span> Ticket<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// \"여행 가능\" 조건의 충족 = 여권과 티켓을 모두 갖춘 튜플</span>\n<span class=\"token keyword\">const</span> proof<span class=\"token operator\">:</span> CanTravel <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>myPassport<span class=\"token punctuation\">,</span> myTicket<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 <code class=\"language-text\">CanTravel</code> 타입이 만족했다면, 다른 말로 “여권도 있고 비행기 표도 있다”는 조건이 만족했다면 아래와 같이 <code class=\"language-text\">CanTravel</code> 타입의 튜플에서 여권이나 비행기표 모두 자유롭게 꺼내올 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getPassport</span><span class=\"token punctuation\">(</span>travel<span class=\"token operator\">:</span> CanTravel<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Passport <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// \"A 그리고 B\"에서 A를 꺼냄</span>\n  <span class=\"token keyword\">return</span> travel<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getTicket</span><span class=\"token punctuation\">(</span>travel<span class=\"token operator\">:</span> CanTravel<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Ticket <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// \"A 그리고 B\"에서 B를 꺼냄</span>\n  <span class=\"token keyword\">return</span> travel<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이것은 논리학에서 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\land B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 참이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>도 참이다”라는 규칙과 같은 구조다. 튜플에서 요소를 꺼내는 것이 논리적 추론과 대응되는 셈이다.</p>\n<h4 id=\"유니온-또는의-증거\" style=\"position:relative;\">유니온: “또는”의 증거<a href=\"#%EC%9C%A0%EB%8B%88%EC%98%A8-%EB%98%90%EB%8A%94%EC%9D%98-%EC%A6%9D%EA%B1%B0\" aria-label=\"유니온 또는의 증거 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>TypeScript의 유니온 타입 <code class=\"language-text\">A | B</code>는 논리학의 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“에 해당한다. 여기서 중요한 점은 우리가 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“가 참이라고 주장하려면 반드시 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>가 참이라는 사실을 보여주거나, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 참이라는 사실을 보여줘야 한다는 것이다. 두 논리 중 하나를 구체적으로 제시해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">PaymentMethod</span> <span class=\"token operator\">=</span> CreditCard <span class=\"token operator\">|</span> BankTransfer<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// \"신용카드 또는 계좌이체\"의 충족 = 둘 중 하나를 구체적으로 제시</span>\n<span class=\"token keyword\">const</span> payment1<span class=\"token operator\">:</span> PaymentMethod <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'credit'</span><span class=\"token punctuation\">,</span> cardNumber<span class=\"token operator\">:</span> <span class=\"token string\">'1234...'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> payment2<span class=\"token operator\">:</span> PaymentMethod <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'bank'</span><span class=\"token punctuation\">,</span> accountNumber<span class=\"token operator\">:</span> <span class=\"token string\">'5678...'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“라는 명제가 참이라고 해도 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span> 둘 중 뭐가 참인지 구체적으로 확인하기 전까지는 알 수가 없다는 것과 같다.</p>\n<p>그래서 이 명제로부터 다른 무언가를 이끌어내려면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>에 대한 처리를 모두 해줘야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">processPayment</span><span class=\"token punctuation\">(</span>method<span class=\"token operator\">:</span> PaymentMethod<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Receipt <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'credit'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// A인 경우 처리</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">chargeCreditCard</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// B인 경우 처리</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">processBankTransfer</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이것이 TypeScript에서 Exhaustiveness check가 중요한 이유다. 논리적으로 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“를 다룰 때는 두 경우 모두에 대한 전략이 있어야만 완전한 처리가 되기 때문이다.</p>\n<p>다만 TypeScript가 모든 케이스를 다뤘는지 자동으로 체크해주는 것은 설정과 코드 패턴에 따라 달라진다. 그러니 확실하게 Exhaustiveness check를 강제하고 싶다면 아래와 같은 패턴을 사용하는 것이 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">assertNever</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">never</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unexpected value\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Shape</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'circle'</span><span class=\"token punctuation\">;</span> radius<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'square'</span><span class=\"token punctuation\">;</span> side<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'triangle'</span><span class=\"token punctuation\">;</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">area</span><span class=\"token punctuation\">(</span>shape<span class=\"token operator\">:</span> Shape<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>shape<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'circle'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token constant\">PI</span> <span class=\"token operator\">*</span> shape<span class=\"token punctuation\">.</span>radius <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'square'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> shape<span class=\"token punctuation\">.</span>side <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n      <span class=\"token comment\">// Argument of type '{ type: \"triangle\"; height: number; }' is not assignable to parameter of type 'never'.</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">assertNever</span><span class=\"token punctuation\">(</span>shape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>기본적으로 유니온 타입의 모든 케이스를 처리했다면 <code class=\"language-text\">default</code>에 도달할 일이 없고, <code class=\"language-text\">shape</code>는 <code class=\"language-text\">never</code> 타입이 된다. 하지만 만약 새로운 도형을 추가했는데 처리를 깜빡했다면, <code class=\"language-text\">shape</code>가 <code class=\"language-text\">never</code> 타입이 아니게 되고 컴파일 에러가 발생한다.</p>\n<h4 id=\"never-불가능의-표현\" style=\"position:relative;\">never: “불가능”의 표현<a href=\"#never-%EB%B6%88%EA%B0%80%EB%8A%A5%EC%9D%98-%ED%91%9C%ED%98%84\" aria-label=\"never 불가능의 표현 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>TypeScript의 <code class=\"language-text\">never</code> 타입은 “이런 값은 존재할 수 없다”를 의미한다. 논리학에서는 이것을 모순 또는 거짓이라고 표현한다.</p>\n<p>앞서 언급했던 집합론으로 비유하자면, <code class=\"language-text\">never</code> 타입은 빈 주머니다. 즉, <code class=\"language-text\">never</code>라는 주머니 안에는 아무것도 없고, 앞으로도 없을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">throwError</span><span class=\"token punctuation\">(</span>message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">never</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 이 함수는 정상적으로 반환되지 않는다</span>\n  <span class=\"token comment\">// 반환값이 \"존재할 수 없다\"</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서 논리학의 재미있는 원리 하나가 나온다. 바로 “모순으로부터는 무엇이든 도출할 수 있다”는 것이다. 이는 라틴어로 “Ex falso quodlibet”이라고 하는데, 쉽게 말하면 불가능한 상황이 발생했다면, 그 다음에는 뭐든지 가능하다는 것이다.</p>\n<p>이 원리는 타입스크립트에서 아래와 같은 함수를 선언해봄으로써 구현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">absurd</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// never에서는 어떤 타입으로든 변환 가능</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 ”<code class=\"language-text\">never</code>이면 <code class=\"language-text\">T</code>이다”라는 규칙을 표현하고 있다. 한번 <code class=\"language-text\">never</code> 타입을 다른 구체적인 타입으로 바꿔보면 바로 에러가 발생하는 것을 알 수 있다. <code class=\"language-text\">never</code>는 거짓, 모순이기 때문이 그 다음에는 어떤 타입이 오든 논리적으로 틀린 것이 아닌 것이다.</p>\n<p>사실 이 부분도 정확하게 뜯어보면 TypeScript가 Ex falso을 정확하게 구현한 것은 아니긴 하다.</p>\n<p><code class=\"language-text\">never</code> 타입은 모든 타입의 서브 타입으로 취급되는 바닥 타입(Bottom Type)이기 때문에, <code class=\"language-text\">never</code> 타입의 값은 어떤 타입 위치에도 대입 가능한 것으로 간주된다. 논리학의 Ex falso 원리와 닮긴 했지만 실제로는 서브타이핑의 결과라고 볼 수 있다.</p>\n<h4 id=\"제네릭-모든-경우에-통하는-계약\" style=\"position:relative;\">제네릭: “모든 경우에 통하는” 계약<a href=\"#%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%AA%A8%EB%93%A0-%EA%B2%BD%EC%9A%B0%EC%97%90-%ED%86%B5%ED%95%98%EB%8A%94-%EA%B3%84%EC%95%BD\" aria-label=\"제네릭 모든 경우에 통하는 계약 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>우리는 제네릭을 처음 배울 때 보통 “타입을 나중에 정하는 것”이라고 배운다. 사실 이것도 틀린 말은 아니지만, 제네릭이 의미하는 바는 더 심오하다.</p>\n<p>논리학에는 전칭 명제라는 것이 있는데, 이는 “모든 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>에 대해 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span></span>가 성립한다”는 형태의 명제다. 예를 들어 “모든 사람은 죽는다”처럼 말이다.</p>\n<p>그리고 제네릭 함수는 바로 이 전칭 명제와 비슷한 구조를 가진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">identity</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 “모든 타입 <code class=\"language-text\">T</code>에 대해, <code class=\"language-text\">T</code>를 주면 <code class=\"language-text\">T</code>를 돌려줄 수 있다”는 계약을 표현한다.</p>\n<p>여기서 중요한 것은 “모든 경우”에 대해 성립함을 보여야한다는 점인데, 이게 가능하려면 어떠한 특정 경우에 대한 가정도 하면 안된다.</p>\n<p>그래서 우리가 제네릭 타입을 사용했을 때 아래와 같은 가정을 하면 바로 타입 에러가 발생하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">broken</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 모든 T가 number임을 가정하면...</span>\n  <span class=\"token comment\">// Operator '+' cannot be applied to types 'T' and 'number'.</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위와 같이 <code class=\"language-text\">T</code>가 <code class=\"language-text\">number</code>라고 가정하는 순간, 이것은 더 이상 모든 <code class=\"language-text\">T</code>에 대한 계약이 아니라, <code class=\"language-text\">number</code>에 대한 계약으로 범위가 좁아져 버린다. 더이상 전칭 명제라고 보기 어려운 것이다.</p>\n<p>그래서 우리는 “모든” 이라는 전제에 제약을 추가함으로서 이 문제를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">addOne</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// OK</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위와 같이 <code class=\"language-text\">T</code>가 <code class=\"language-text\">number</code>를 상속받았다면 자연스럽게 <code class=\"language-text\">T</code>는 이제 ”<code class=\"language-text\">number</code>의 부분 집합인 <code class=\"language-text\">T</code>“로 개념이 변경된다. 즉, “모든” 이라는 개념의 범위를 조정하는 제약을 거는 것이다. 그래서 우리는 이런 제약을 걸때 <code class=\"language-text\">extends</code>라는 상속 키워드를 사용한다.</p>\n<h2 id=\"합성과-변환\" style=\"position:relative;\">합성과 변환<a href=\"#%ED%95%A9%EC%84%B1%EA%B3%BC-%EB%B3%80%ED%99%98\" aria-label=\"합성과 변환 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지는 타입과 논리학의 기본적인 대응 관계를 살펴봤다. 이제부터는 이것들을 조합하고 변환하는 방법에 대해서 이야기해보도록 하자.</p>\n<h4 id=\"함수-합성-추론을-연결하기\" style=\"position:relative;\">함수 합성: 추론을 연결하기<a href=\"#%ED%95%A8%EC%88%98-%ED%95%A9%EC%84%B1-%EC%B6%94%EB%A1%A0%EC%9D%84-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"함수 합성 추론을 연결하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>논리학에는 삼단논법이라는 것이 있다. 가장 기본적인 정언적 삼단논법은 “만약 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>라면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>이다”로 표현할 수 있다.</p>\n<p>이러한 삼단논법은 가정을 기반으로 한 가언적 삼단논법으로 표현할 수도 있는데, 이 경우 아래와 같은 명제가 된다.</p>\n<blockquote>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이다.\n<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>이다.\n그러므로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>이다.</p>\n</blockquote>\n<p>예를 들어 “밥을 먹으면 배부르다”라는 명제가 참이고, “배부르면 잠이온다”라는 명제가 참이라면, “밥을 먹으면 잠이 온다”라는 명제도 참이라는 것이다. 그리고 이것이 프로그래밍에서는 함수의 합성으로 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">g</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">C</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">C</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> parseNumber <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=></span> <span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> isPositive <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span> <span class=\"token operator\">=></span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// string → number와</span>\n<span class=\"token comment\">// number → boolean을 연결하면</span>\n<span class=\"token comment\">// string → boolean이 된다</span>\n<span class=\"token keyword\">const</span> isPositiveString <span class=\"token operator\">=</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>parseNumber<span class=\"token punctuation\">,</span> isPositive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">isPositiveString</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"42\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이는 마치 작은 추론들을 연결해서 더 크고 복잡한 추론을 만드는 것과 동일한데, 이렇게 작고 간단한 구조를 쌓아나가며 큰 구조를 만들 수 있다는 점이 함수 합성이 강력한 이유이다.</p>\n<p>그래서 함수형 프로그래밍에서는 <code class=\"language-text\">pipe</code>나 <code class=\"language-text\">compose</code>와 같은 개념이나 펑터(Functor)나 모나드(Monad)와 같이 함수의 합성과 관련된 개념들이 핵심이 된다.</p>\n<p>사실 카테고리 이론에서는 이 합성이야말로 카테고리의 본질이라고 말한다. 만약 관심이 있다면 <a href=\"/2024/01/30/category-theory-for-programmers-1-category/\">“프로그래머를 위한 카테고리 이론 - 1. 카테고리: 합성의 본질”</a>도 참고해보자.</p>\n<h4 id=\"커링-논리적으로-자연스러운-변환\" style=\"position:relative;\">커링: 논리적으로 자연스러운 변환<a href=\"#%EC%BB%A4%EB%A7%81-%EB%85%BC%EB%A6%AC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%90%EC%97%B0%EC%8A%A4%EB%9F%AC%EC%9A%B4-%EB%B3%80%ED%99%98\" aria-label=\"커링 논리적으로 자연스러운 변환 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>커링(Currying)은 여러 인자를 받는 함수를 한 인자씩 받는 함수의 체인으로 바꾸는 패턴을 의미한다. 커링을 사용하면 어떤 함수든 단항 함수라는 공통의 패턴으로 만들 수 있기 때문에 합성하기가 편해진다는 장점이 있다.</p>\n<p>한 가지 재미있는 점은 다항 함수를 단항 함수의 합성으로 변환하는 것이 항상 가능하다는 점이다. 왜 이 변환이 항상 가능한 것일까?</p>\n<p>논리학에는 수출 법칙(Exportation)이라는 동치 관계가 있는데, 커링은 바로 이 개념을 활용한 패턴이다.</p>\n<blockquote>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>∧</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>C</mi><mo>≡</mo><mi>A</mi><mo>→</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo>→</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(A \\land B) \\rightarrow C \\equiv A \\rightarrow (B \\rightarrow C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>“(A 그리고 B)이면 C이다”와 “A이면 (B이면 C이다)“는 논리적으로 동치다.</p>\n</blockquote>\n<p>엄밀히 말하면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>∧</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">(A \\land B) \\rightarrow C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>는 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>를 튜플로 받아 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>를 반환하는 함수”에 대응하며, JavaScript의 다중 인자 함수는 이를 실용적으로 근사한 형태라고 이해하는 것이 정확하다.</p>\n<p>조금 더 일상적인 상황을 예를 들어 보면, “밀가루와 물이 있으면 반죽을 만들 수 있다”라는 명제와 “밀가루가 있으면, (물이 있으면 반죽을 만들 수 있다)“라는 명제는 같은 의미를 가진다는 것이다. 그래서 이 변환은 항상 안전하게 진행된다는 것이 보장된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 두 인자를 한번에 받음</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">makeDough</span><span class=\"token punctuation\">(</span>flour<span class=\"token operator\">:</span> Flour<span class=\"token punctuation\">,</span> water<span class=\"token operator\">:</span> Water<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Dough <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">mix</span><span class=\"token punctuation\">(</span>flour<span class=\"token punctuation\">,</span> water<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 한 인자씩 받음 (커링)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">makeDoughCurried</span><span class=\"token punctuation\">(</span>flour<span class=\"token operator\">:</span> Flour<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>water<span class=\"token operator\">:</span> Water<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Dough <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>water<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">mix</span><span class=\"token punctuation\">(</span>flour<span class=\"token punctuation\">,</span> water<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 둘은 논리적으로 동등하다</span>\n<span class=\"token keyword\">const</span> dough1 <span class=\"token operator\">=</span> <span class=\"token function\">makeDough</span><span class=\"token punctuation\">(</span>flour<span class=\"token punctuation\">,</span> water<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dough2 <span class=\"token operator\">=</span> <span class=\"token function\">makeDoughCurried</span><span class=\"token punctuation\">(</span>flour<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>water<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>즉, 다항 함수를 단항 함수로 변경하는 커링이 가능한 이유는 단순한 프로그래밍 기법이 아니라 논리적 동치 관계와 닮아있기 때문이다.</p>\n<h4 id=\"타입-대수-덧셈과-곱셈처럼\" style=\"position:relative;\">타입 대수: 덧셈과 곱셈처럼<a href=\"#%ED%83%80%EC%9E%85-%EB%8C%80%EC%88%98-%EB%8D%A7%EC%85%88%EA%B3%BC-%EA%B3%B1%EC%85%88%EC%B2%98%EB%9F%BC\" aria-label=\"타입 대수 덧셈과 곱셈처럼 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>혹시 대수적 데이터 타입(Algebraic Data Type)이라는 말을 들어본 적이 있는가? 이 말은 타입에도 대수학에서의 사칙연산과 같은 연산 법칙들을 적용할 수 있다는 것이다.</p>\n<p>예를 들어 곱 타입과 합 타입이 있는데, 대표적인 곱 타입은 위에서 한번 언급했던 “그리고”를 의미하는 튜플, 그리고 합 타입은 “또는”을 의미하는 유니언 타입이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Bool</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token operator\">|</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 2가지 값</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Pair</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>Bool<span class=\"token punctuation\">,</span> Bool<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 2 * 2 = 4가지 값</span>\n<span class=\"token comment\">// [true, true], [true, false], [false, true], [false, false]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Three</span> <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'b'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 3가지 값</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Five</span> <span class=\"token operator\">=</span> Three <span class=\"token operator\">|</span> Bool<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 3 + 2 = 5가지 값</span>\n<span class=\"token comment\">// 'a', 'b', 'c', true, false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이것이 대수적 데이터 타입(Algebraic Data Types)이라는 이름이 붙은 이유다. 타입을 값의 경우의 수 관점에서 바라보면 합 타입은 덧셈처럼, 그리고 곱 타입은 곱셈처럼 동작한다.</p>\n<p>더 흥미로운 점은 대수학에서처럼 타입에서도 분배법칙이 등장한다는 것이다. 수학적으로는 다음과 같은 관계가 성립한다.</p>\n<blockquote>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo>+</mo><mi>C</mi><mo stretchy=\"false\">)</mo><mo>≡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>×</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\times (B + C) \\equiv (A \\times B) + (A \\times C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span></p>\n</blockquote>\n<p>TypeScript에서도 이 구조는 특정 지점에서 매우 명확하게 드러난다. 바로 조건부 타입(Conditional Type) 이다.</p>\n<p>TypeScript의 조건부 타입은 유니온 타입에 대해 자동으로 분배(distribute)된다. 이 성질을 이용하면 타입 대수의 분배법칙을 직접 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">PairWith<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token builtin\">any</span></span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token operator\">=</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token operator\">=</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// boolean = true | false이기 때문에 3가지 곱의 합으로 분배된다</span>\n<span class=\"token comment\">// [string, number] | [string, false] | [string, true]</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Result</span> <span class=\"token operator\">=</span> PairWith<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시는 <code class=\"language-text\">B</code>가 <code class=\"language-text\">number | boolean</code>이라는 합 타입일 때, <code class=\"language-text\">[A, B]</code>라는 곱타입은 다시 <code class=\"language-text\">[A, number] | [A, boolean]</code>이라는 합 타입으로 분배될 수 있음을 보여준다.</p>\n<p>즉, 타입 레벨에서도 대수의 분배 법칙과 동일하게 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo>+</mo><mi>C</mi><mo stretchy=\"false\">)</mo><mo>≡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>×</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\times (B + C) \\equiv (A \\times B) + (A \\times C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>의 모습이 보여지는 것이다.</p>\n<p>물론 TypeScript의 타입 시스템은 이러한 분배 구조를 항상 자동으로 동일한 타입으로 취급하지는 않는다. 하지만 최소한 타입을 계산하고 변환하는 규칙의 수준에서는 대수적 데이터 타입의 덧셈, 곱셈, 분배라는 아이디어가 분명하게 살아있다고 볼 수 있다.</p>\n<p>카테고리 이론에서는 이 곱과 합을 보편적 구성(Universal Construction)이라는 더 추상적인 관점에서 다룬다. <a href=\"/2024/04/18/category-theory-for-programmers-9-function-types/\">“프로그래머를 위한 카테고리 이론 - 9. 함수 타입”</a>에서 이 대수적 구조가 어떻게 확장되는지 볼 수 있다.</p>\n<h2 id=\"typescript는-100-논리적이지-않다\" style=\"position:relative;\">TypeScript는 100% 논리적이지 않다<a href=\"#typescript%EB%8A%94-100-%EB%85%BC%EB%A6%AC%EC%A0%81%EC%9D%B4%EC%A7%80-%EC%95%8A%EB%8B%A4\" aria-label=\"typescript는 100 논리적이지 않다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>기본적인 개념들에 대해서 살펴봤다면, 이제는 필자가 위에서 언급했던 TypeScript의 한계에 대해 한번 알아보자.</p>\n<p>필자는 TypeScript가 Curry-Howard 대응을 부분적으로 차용한 언어라고 했는데, 그 한계가 뭘까?</p>\n<p>TypeScript는 언어의 실용성을 높이기 위해 의도적으로 논리적 모순을 초래할 수 있는 몇 가지 탈출구를 제공한다. 이 포스팅에서는 그 중 대표적인 두 가지에 대해서 이야기해보려 한다.</p>\n<p>첫 번째 탈출구는 <code class=\"language-text\">any</code>와 타입 단언의 존재이다. <code class=\"language-text\">any</code>는 어떤 타입이든 검사하지 않고 통과시키겠다는 선언이다. 즉, 논리학적으로 보면 “검증 없이 뭐든 참으로 인정”하는 것과 같다. <code class=\"language-text\">as</code>를 통한 타입 단언도 마찬가지다.</p>\n<p>이것들은 증명 체계를 우회하는 탈출구이고, 이로 인해 TypeScript는 논리적인 모순을 허용하는 언어가 되어버렸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> x<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token comment\">// number 타입에 문자열 할당</span>\n\n<span class=\"token keyword\">const</span> z <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">unknown</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 타입 강제 변환</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 번째 탈출구는 바로 구조적 타이핑의 코너 케이스들이다. 대표적으로는 함수 파라미터의 이변성(Bivariance), 인덱스 시그니처, 옵셔널 프로퍼티 등의 탈출구로 인해 논리적 해석이 흔들리는 경우가 존재한다.</p>\n<p>논리적으로 함수 파라미터는 반공변(Contravariant)적이어야 한다. 쉽게 말해 <code class=\"language-text\">Dog</code>가 <code class=\"language-text\">Animal</code>의 서브타입이라면, <code class=\"language-text\">(animal: Animal) => void</code>가 <code class=\"language-text\">(dog: Dog) => void</code>의 서브타입이어야 한다는 것이다. 이는 더 넓은 타입을 받는 함수가 더 좁은 타입을 받는 함수를 대체할 수 있기 때문이다.</p>\n<p>하지만 TypeScript는 메소드 문법으로 선언된 함수에서 이를 이변적으로 처리한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">  <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Dog</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span> breed<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">type</span> <span class=\"token class-name\">Handler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>animal<span class=\"token operator\">:</span> Animal<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> dogHandler<span class=\"token operator\">:</span> Handler <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Dog만 처리하는 함수인데 Animal을 받는 자리에 할당됨</span>\n    <span class=\"token comment\">// strictFunctionTypes로도 잡히지 않음</span>\n    <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>dog<span class=\"token operator\">:</span> Dog<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>dog<span class=\"token punctuation\">.</span>breed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  dogHandler<span class=\"token punctuation\">.</span><span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"cat\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 런타임 에러 가능</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 인덱스 시그니처 또한 논리적인 모순을 초래할 수 있다. 객체에서 존재하지 않는 키에 접근하더라도 TypeScript는 <code class=\"language-text\">undefined</code>가 아닌 선언된 타입으로 추론하기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> scores<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> alice<span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> bobScore <span class=\"token operator\">=</span> scores<span class=\"token punctuation\">[</span><span class=\"token string\">\"bob\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 타입은 number, 실제 값은 undefined</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>bobScore<span class=\"token punctuation\">.</span><span class=\"token function\">toFixed</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 런타임 에러</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>조금 더 엄밀한 타입 체크를 원한다면 tsconfig의 <code class=\"language-text\">noUncheckedIndexedAccess</code> 옵션을 활성화하면 제대로 <code class=\"language-text\">number | undefined</code>로 추론되도록 만들 수 있다.</p>\n<p>마지막으로 옵셔널 프로퍼티와 <code class=\"language-text\">undefined</code>의 혼동도 문제가 된다. 예를 들어 <code class=\"language-text\">{ a?: string }</code>이라는 타입에서 <code class=\"language-text\">a</code>가 <code class=\"language-text\">undefined</code>인 상태와 아예 존재하지 않는 것이 논리적으로 구분되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Config</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> timeout<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> config1<span class=\"token operator\">:</span> Config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> timeout<span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n<span class=\"token keyword\">const</span> config2<span class=\"token operator\">:</span> Config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n\n<span class=\"token comment\">// 둘 다 같은 타입으로 취급되지만,</span>\n<span class=\"token comment\">// Object.hasOwn(config1, 'timeout')과 Object.hasOwn(config2, 'timeout')은 다르다</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 부분 또한 TypeScript 4.4 이후 도입된 <code class=\"language-text\">exactOptionalPropertyTypes</code> 옵션을 사용하면 “존재하지 않음”과 ”<code class=\"language-text\">undefined</code>로 존재함”을 더 엄밀하게 구분할 수 있다.</p>\n<p>이런 탈출구들은 TypeScript가 100% 논리적인 정합성보다는 실용적으로 JavaScript와의 호환성을 선택한 결과라고 볼 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이 글은 타입스크립트를 잘 쓰는 방법을 설명하려는 글은 아니다. 이미 실무에서 타입을 충분히 다뤄본 사람이라면, 여기서 등장하는 대부분의 예시는 익숙할 수도 있다.</p>\n<p>다만 필자가 이 글을 통해 전하고 싶었던 건, 타입 시스템을 대하는 관점에 가깝다. 타입 에러를 “통과시켜야 할 장애물”로 보는 대신, 내가 어떤 계약을 선언했고, 그 계약이 어디에서 깨지고 있는지를 읽어내는 도구로 바라보는 시선 말이다.</p>\n<p>이 관점이 한 번 자리 잡히면, 타입 에러를 대하는 태도도 자연스럽게 달라진다. 왜 안 되는지를 묻기 전에, 무슨 계약을 어기고 있는지를 먼저 떠올리게 된다.</p>\n<p>타입 시스템은 생각보다 많은 이야기를 하고 있다. 다만 그걸 단순한 컴파일 통과 여부로만 읽고 지나치기엔, 조금 아까운 도구일지도 모르겠다.</p>\n<p>이 글이 흥미로웠다면, <a href=\"/2024/01/30/category-theory-for-programmers-0-preface/\">“프로그래머를 위한 카테고리 이론”</a> 시리즈도 읽어보자. 여기서 다룬 합성, 곱과 합 타입, 함수 타입 같은 개념들이 카테고리 이론에서 어떻게 일반화되는지, 그리고 펑터나 자연 변환 같은 개념이 이 아이디어를 어떻게 확장하는지 볼 수 있다.</p>","fields":{"slug":"20260125-types-as-proofs-typescript-hidden-math","path":"/2026/01/25/types-as-proofs-typescript-hidden-math/","lang":"ko"},"frontmatter":{"title":"타입 시스템은 왜 증명처럼 동작하는가","subTitle":"타입 검사를 컴파일 통과로만 보던 시선에서, 논리로 읽는 타입 시스템까지","date":"Jan 25, 2026","categories":["프로그래밍"],"tags":["TypeScript","타입시스템","수학","논리학","Curry-Howard","람다대수"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/431b08e8376f331ee6da16cb53233c65/d803c/thumbnail.png","srcSet":"/static/431b08e8376f331ee6da16cb53233c65/d803c/thumbnail.png 320w,\n/static/431b08e8376f331ee6da16cb53233c65/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/431b08e8376f331ee6da16cb53233c65/fc5c5/thumbnail.webp 320w,\n/static/431b08e8376f331ee6da16cb53233c65/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/431b08e8376f331ee6da16cb53233c65/01fb2/thumbnail.png","srcSet":"/static/431b08e8376f331ee6da16cb53233c65/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/431b08e8376f331ee6da16cb53233c65/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"5d271804-0558-56d2-a68f-bb8daf257830","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%80-%EC%88%98%ED%95%99%EC%9D%B4%EB%8B%A4\">프로그래밍은 수학이다</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%88%98%ED%95%99%EC%97%90-%EC%AB%84%EC%A7%80-%EB%A7%90%EC%9E%90\">수학에 쫄지 말자!</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%95%8C%EB%A9%B4-%EB%8F%84%EC%9B%80%EC%9D%B4-%EB%90%98%EB%8A%94-%EC%88%98%ED%95%99-%EA%B0%9C%EB%85%90-3%EA%B0%80%EC%A7%80\">알면 도움이 되는 수학 개념 3가지</a></p>\n<ul>\n<li><a href=\"#%EB%AA%85%EC%A0%9Cproposition\">명제(Proposition)</a></li>\n<li><a href=\"#%EC%A7%91%ED%95%A9set\">집합(Set)</a></li>\n<li><a href=\"#%EC%88%98%ED%95%99%EC%A0%81-%EA%B7%80%EB%82%A9%EB%B2%95mathematical-induction\">수학적 귀납법(Mathematical Induction)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 필자가 많이 받은 질문 중 하나인 “개발자는 수학을 잘해야할까?”라는 질문에 대해서 한번 이야기 해볼까 한다. 물론 이 주제는 전 세계의 많은 개발자들 간에도 의견이 갈리는 내용이기 때문에 그냥 지나가는 개발자 한명의 생각일 뿐이라고 생각해줬으면 좋겠다.","html":"<p>이번 포스팅에서는 필자가 많이 받은 질문 중 하나인 “개발자는 수학을 잘해야할까?”라는 질문에 대해서 한번 이야기 해볼까 한다. 물론 이 주제는 전 세계의 많은 개발자들 간에도 의견이 갈리는 내용이기 때문에 그냥 지나가는 개발자 한명의 생각일 뿐이라고 생각해줬으면 좋겠다.</p>\n<!-- more -->\n<p>사실 필자도 수학을 잘하는 편이 아니라 그냥 컴퓨터 공부하신 다른 분들처럼 학교에서 배우긴 했는데 졸업하고 나서는 잘 기억안나는 그냥 그 정도의 수준이다. 게다가 필자는 손으로 푸는 계산이 굉장히 약하기 때문에 수학 성적이 좋았던 편도 아니다. <small>(사칙연산을 잘 틀린다.)</small></p>\n<p>그래도 인터넷에서 많은 분들이 이 주제에 대해서 이야기 해주시기도 했고, 실제로 개발자가 아닌 분들에게 이런 질문을 받은 적도 있어서 필자도 한번 이 주제에 대한 필자의 생각을 끄적여볼까한다.</p>\n<h2 id=\"프로그래밍은-수학이다\" style=\"position:relative;\">프로그래밍은 수학이다<a href=\"#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%80-%EC%88%98%ED%95%99%EC%9D%B4%EB%8B%A4\" aria-label=\"프로그래밍은 수학이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>일단 근본적으로 우리가 사용하고 있는 이 컴퓨터는 사실 <code class=\"language-text\">0</code>과 <code class=\"language-text\">1</code>을 사용하는 계산기다. 그렇기 때문에 컴퓨터에는 아무래도 수학적인 내용이 많이 들어갈 수 밖에 없고, 프로그래밍을 할 때도 알게 모르게 많이 녹아있는 수학적인 개념들이 많다.</p>\n<p>그래서 사실 필자는 개발자라면 수학을 조금은 할 줄 알아야한다고 생각하는 편이다. 이 얘기를 들은 여러분은 “어? 난 수학을 잘 못하는데 지금 개발을 하고 있는데?”라고 생각하실 수도 있겠다.</p>\n<p>그러나 여기서 필자가 말하는 수학은 무슨 선형대수학이나 미적분같은 고등수학을 말하는 것이 아니다. 필자가 얘기하는 수학은 대부분 명제나 집합, n진법과 같이 이미 우리가 중고등학교에서 배웠던 정도의 수준을 이야기하는 것이다.</p>\n<p>물론 이 개념들도 결국 파고들면 파고들수록 점점 추상적이고 어려운 개념들이 나오지만 솔직히 그렇게까지 알 필요는 없다고 생각한다. 우리가 무슨 수학을 연구하는 사람도 아니고, 우리는 그냥 개발자로써 프로그래밍에 필요한 정도만 알고 있으면 된다. 중요한 것은 수학이라는 키워드에 쫄지 않는 것이다.</p>\n<p>그래서 이번 포스팅에서는 필자가 생각했을 때 프로그래밍에 도움이 되는 수학 개념 3가지에 대해서 가볍게 한번 이야기 해보려고 한다.</p>\n<h2 id=\"수학에-쫄지-말자\" style=\"position:relative;\">수학에 쫄지 말자!<a href=\"#%EC%88%98%ED%95%99%EC%97%90-%EC%AB%84%EC%A7%80-%EB%A7%90%EC%9E%90\" aria-label=\"수학에 쫄지 말자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>요즘 핫한 주제인 머신러닝이나 인공 신경망 같은 경우 호기심을 자극하는 키워드지만, 구글링을 해보면 나오는 검색 결과는 우리의 공부 의욕을 꺾어놓는다.</p>\n<blockquote>\n<p>…</p>\n<p>해답이 어떤 데이터에 의존적인 경우, 비용은 관측값에 대한 함수가 되어야 하며, 그렇지 않을 경우에는 데이터와 관련된 어떤 것도 모델링할 수 없게 된다. 많은 경우 비용은 근사될수만 있는 통계로 주어진다.</p>\n<p>간단한 예로, 어떤 분포 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">D</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal {D}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 뽑아낸 데이터 쌍 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(x, y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span></span>에 대해 비용 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>=</mo><mi>E</mi><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>−</mo><mi>y</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">C = E[(f(x) - y)^{2}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mopen\">[(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span></span>을 최소화하는 모델 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>를 찾는 문제를 생각해보자. 실용적으로는 분포 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">D</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal {D}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 유한한 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>개의 샘플만을 뽑아낼 수 있으므로, 이 예의 경우 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>C</mi><mo>^</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\hat{C} = \\frac{1}{N}\\sum_{i=1}^{N}(f(x_i) - y_i)^{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9468em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9468em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">^</span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3262em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9812em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span></span>, 즉 전체 데이터 집합이 아니라 데이터의 샘플에 대한 비용만 최소화될 수 있을 것이다.</p>\n<p>…</p>\n<p><strong><a href=\"https://ko.wikipedia.org/wiki/%EC%9D%B8%EA%B3%B5_%EC%8B%A0%EA%B2%BD%EB%A7%9D\" target=\"_blank\" rel=\"nofollow\">인공 신경망 - 학습, 위키 백과</a></strong></p>\n</blockquote>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 250px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/921606ba067387cd7d78b791d22a41de/0479a/luckyjjang.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 128.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAaABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEBQL/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAGjHe4gEBvr7zQIw//EAB0QAAMAAgIDAAAAAAAAAAAAAAECAwARBBMUITH/2gAIAQEAAQUC7Za5Dp2VZwePEnNCqWULQehoAXnMUb4pPj5//8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAIBAAAQQCAQUAAAAAAAAAAAAAAAECESEDMUEQIiNxwf/aAAgBAQAGPwKsmOPR4qT6JOSVVJNcSQ5NENK2Wlcna8UdfT//xAAeEAEAAwEAAgMBAAAAAAAAAAABABEhMUFRYZGhwf/aAAgBAQABPyHlHbnp9SwboGhQ+xFZi1TVTCCppR5hqJVZ/I35HzL7K4yZ1m2zUqAcLo8z8EVYnPcOT//aAAwDAQACAAMAAAAQM84M/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHRABAAMAAgMBAAAAAAAAAAAAAQARITFBUXGxof/aAAgBAQABPxBsWqRgroVAylpUS8fX5HPWaWPWd0EVecIHwq+eJQ0s0Vp34XClQjm21EcUDWIOWqstl7U+S3iXbDG8Yepj3vky2mFprSYHqf/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"luckyjjang\" title=\"\" src=\"/static/921606ba067387cd7d78b791d22a41de/0479a/luckyjjang.jpg\" srcset=\"/static/921606ba067387cd7d78b791d22a41de/0913d/luckyjjang.jpg 160w,\n/static/921606ba067387cd7d78b791d22a41de/0479a/luckyjjang.jpg 250w\" sizes=\"(max-width: 250px) 100vw, 250px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>난 분명 수식을 보고 있는데 숫자보다 영어가 더 많이 보이고...</small>\n</center>\n<p>솔직히 저런 수식을 처음 보면 무슨 외계어 같기도 하고 무슨 말을 하는 지 도통 알 수가 없다. 게다가 간단한 예랍시고 설명하고 있는 것은 전혀 간단하지 않게 생겼다.</p>\n<p>이런 것들이 바로 우리의 공부 의욕을 깎아먹는 수학의 모습이다. 하지만 저 수식이 진짜 어렵고 복잡한 의미일까?</p>\n<p>저 기호와 알파벳이 어떤 의미인지만 알면 우리는 이 수식을 코드로 포팅할 수 있는데, 막상 짜놓고 보면 굉장히 간단하다. 그럼 딱 봤을 때 제일 복잡해보이는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>C</mi><mo>^</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\hat{C} = \\frac{1}{N}\\sum_{i=1}^{N}(f(x_i) - y_i)^{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9468em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9468em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">^</span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3262em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9812em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span></span>를 값 <code class=\"language-text\">C</code>를 구하는 코드로 한번 작성해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> inputs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> outputs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span> <span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">N</span> <span class=\"token operator\">=</span> inputs<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">exampleFunction</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getC</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    result <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span><span class=\"token function\">exampleFunction</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> y<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> result <span class=\"token operator\">/</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">C</span> <span class=\"token operator\">=</span> <span class=\"token function\">getC</span><span class=\"token punctuation\">(</span>inputs<span class=\"token punctuation\">,</span> outputs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>쨘, 이제 아까 저 수식이 어떤 내용인지 조금 더 이해가 잘될 것이라고 생각한다. 혹시 저 수식이 어떤 내용인지 이해하지 못했더라도 코드는 이해할 수 있으니 말이다.</p>\n<p>그럼 먼저 이상한 기호가 있어서 어려워 보이는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=1}^{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2809em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9812em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></span>를 한번 살펴보자.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo></mrow><annotation encoding=\"application/x-tex\">\\sum</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span></span></span></span></span><small>(Sum이라고 읽는다)</small> 기호는 그냥 뒤에 붙어 있는 값을 반복문 돌리면서 더하라는 뜻이다. 즉, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=1}^{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2809em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9812em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></span>은 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></span>를 1로 초기화하고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>까지 반복하면서 값을 더해라”라는 의미인 것이다. 우리가 <code class=\"language-text\">for</code>문을 사용할 때 관습적으로 사용하는 변수 <code class=\"language-text\">i</code>도 여기서 파생된 것이다.</p>\n<p>그러면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo></mrow><annotation encoding=\"application/x-tex\">\\sum</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span></span></span></span></span>의 뒤쪽으로 오는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">(f(x_i) - y_i)^{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span></span>에 포함된 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>나 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">y_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>의 의미도 자연스럽게 이해가 될 것이다. 그냥 어떤 집합의 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></span>번째 원소를 말하는 것이다.</p>\n<p>그리고 마지막에 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mi>N</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span>을 곱해주는데, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>번 반복하면서 모두 더한 값을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>으로 나누면 뭘까?</p>\n<blockquote>\n<p>네, <strong>평균</strong>입니다.</p>\n</blockquote>\n<p>여기까지 보고나면 이제 더 이상 저 수식이 낯설게만 느껴지지는 않을 것이다. 그리고 위에서도 한번 얘기했지만 필자가 말하고 싶은 것은 저 수식을 코드로 작성할 수 있냐 없냐가 아니다. 저런 수식도 코드로 바꿔보면 그렇게 어려운 수식이 아니라는 것을 말하고 싶은 것이다. 쫄 필요가 없다!</p>\n<p>그냥 우리에게 <code class=\"language-text\">for</code>문은 익숙하지만 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo></mrow><annotation encoding=\"application/x-tex\">\\sum</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span></span></span></span></span> 기호가 익숙하지 않을 뿐이다. 만약 어떤 수식을 보고 모르는 기호가 나오면 한번 의미를 찾아보자. 물론 그 중에는 의미 자체가 어려운 기호도 있다. <small>(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∫</mo></mrow><annotation encoding=\"application/x-tex\">\\int</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1111em;vertical-align:-0.3061em;\"></span><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;position:relative;top:-0.0006em;\">∫</span></span></span></span></span>같은 적분 기호…?)</small> 하지만 대부분의 경우 그냥 알파벳은 변수, 기호는 규칙(프로그래밍에서의 명령문)이나 특별한 함수를 의미하기 때문에 하나하나 뜯어보고 코드로 작성해보면 생각보다 단순한 경우가 많다.</p>\n<p>이제 더 이상 수학이 별 거 없다는 걸 알았으니 수학이라는 단어 자체에 쫄지 말고 한번 씹고 뜯고 맛보고 즐겨보자.</p>\n<h2 id=\"알면-도움이-되는-수학-개념-3가지\" style=\"position:relative;\">알면 도움이 되는 수학 개념 3가지<a href=\"#%EC%95%8C%EB%A9%B4-%EB%8F%84%EC%9B%80%EC%9D%B4-%EB%90%98%EB%8A%94-%EC%88%98%ED%95%99-%EA%B0%9C%EB%85%90-3%EA%B0%80%EC%A7%80\" aria-label=\"알면 도움이 되는 수학 개념 3가지 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자 그럼 이제 본론으로 들어가서, 우리가 프로그래밍을 할 때 도움이 될만한 수학의 3가지 개념들을 살펴보자.</p>\n<p>사실 필자가 이야기하고 싶은 것은 개념이기 때문에 위에서 예로 들었던 것처럼 수식이 나오는 대수학 같은 건 아니다. 그리고 이 포스팅에서 설명하는 개념들은 사실 수학보다 논리학에 가까운 느낌이기 때문에 반드시 숫자와 연관지어서 생각할 필요는 없다.</p>\n<p>이 개념들은 우리가 중학교, 고등학교에서 이미 배웠던 개념들이다. 다만 수능을 보고 나면 딱히 쓸 일이 없기 때문에 까먹었을 뿐이다. 물론 이과 계열의 전공을 택하신 분이나 문과 중에서도 경제학처럼 수학과 연관이 깊은 전공을 택하신 분은 계속 수학을 공부하기 때문에 까먹지 않았을 수 있지만 그 외의 경우는 사실 까먹을 수 밖에 없다.</p>\n<p>뭐 어쨌든 필자가 설명할 개념들은 전부 어릴 때 한번 정도는 들어봤던 논리에 대한 개념들이니까 조금은 가벼운 마음으로 한번 즐겨보도록 하자.</p>\n<h3 id=\"명제proposition\" style=\"position:relative;\">명제(Proposition)<a href=\"#%EB%AA%85%EC%A0%9Cproposition\" aria-label=\"명제proposition permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>자 처음으로 이야기하고 싶은 개념은 중학교 1학년인 때 배웠던 명제이다. 사실 명제는 굳이 프로그래밍을 위해서가 아니더라도 그냥 논리적인 사고를 하기 위해서 기본적으로 알고 있어야 하는 개념이다.</p>\n<p>명제는 참, 거짓과 같은 논리적인 진릿값을 가지는 것을 말한다. 즉, 참과 거짓을 구분할 수 없는 문장은 명제로 치지 않는다. 즉, “길동이는 키가 크다”와 같은 문장은 명제로 성립될 수 없다는 것이다. 다른 사람이 필자를 봤을 때 키가 크다고 생각할 수도 있고 작다고 생각할 수도 있는 주관성이 들어가는 문장이기 때문이다.</p>\n<p>그렇다면 명제는 우리가 프로그래밍을 할 때 어디에 사용된다는 걸까?</p>\n<p>명제가 말하는 참과 거짓은 우리가 프로그래밍할 때 사용하는 <code class=\"language-text\">True</code>, <code class=\"language-text\">False</code>나 <code class=\"language-text\">1</code>, <code class=\"language-text\">0</code>과 동일한 개념이다. 즉, 우리가 중학생 때 수학 교과서로 배웠던 명제는 조건식과 동일하다고 할 수 있다. 간단한 코드를 한번 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'array 변수에는 a가 들어있다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'array 변수에는 a가 들어있지 않다.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 코드에서 필자가 제시한 명제는 ”<code class=\"language-text\">array</code> 변수에 담긴 배열에는 <code class=\"language-text\">a</code>라는 원소가 포함되어있다”이고 이 명제가 참일 경우 <code class=\"language-text\">if</code>문 내부의 코드가, 거짓일 경우에는 <code class=\"language-text\">else</code>문 내부의 코드가 실행된다. 이처럼 조건문에 사용되는 조건은 반드시 명제여야하므로 명제에 익숙한 개발자는 어떤 요구사항을 들었을 때, 그 요구사항을 충족할 수 있는 명제를 빠르게 제시해나갈 수 있다.</p>\n<p>이 명제라는 개념은 필자가 앞으로 설명할 다른 개념들이나 다른 수학의 개념에서도 가장 기초가 되는 개념이기 때문에 우리가 중학교에 입학하자마자 배우는 것이다. 수학은 긴가민가한 학문이 아니라 정확한 질문과 정확한 답을 제시할 수 있어야하는 능력이 필요한 학문이기 때문에 명제가 가장 기초가 된다.</p>\n<h3 id=\"집합set\" style=\"position:relative;\">집합(Set)<a href=\"#%EC%A7%91%ED%95%A9set\" aria-label=\"집합set permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>다음으로 이야기 할 것은 명제와 마찬가지로 우리가 중학교 1학년 때 배웠던 집합이다. 집합도 명제와 마찬가지로 알게 모르게 많이 사용되는 개념이기 때문에 집합에 대한 확실한 개념을 알고 있다면 프로그래밍할 때 많은 도움을 준다.</p>\n<p>동글동글 귀여운 벤다이어그램과 프로그래밍은 왠지 거리가 멀어보이지만 사실 우리는 저 개념을 매일매일 프로그래밍할 때 사용하고 있다. 바로 논리식을 작성할 때 말이다. 논리식은 위에서 말한 명제처럼 <code class=\"language-text\">True</code>, <code class=\"language-text\">False</code> 둘 중에 하나로 평가받을 수 있는 식을 이야기한다. 보통 우리는 명제 여러 개를 논리 연산자로 묶은 식을 많이 사용한다. 이 논리식과 집합이 무슨 관계가 있다는 걸까?</p>\n<p>사실 우리가 사용하는 논리연산자는 <code class=\"language-text\">&amp;&amp;(AND) = 교집합</code>, <code class=\"language-text\">||(OR) = 합집합</code>으로 대응되기 때문에 복잡한 논리식을 마주쳤을 때 그 논리식을 벤다이어그램으로 그려보는 것도 가능하다. 그리고 우리가 어릴 때 외웠던 <a href=\"https://ko.wikipedia.org/wiki/%EB%93%9C_%EB%AA%A8%EB%A5%B4%EA%B0%84%EC%9D%98_%EB%B2%95%EC%B9%99\" target=\"_blank\" rel=\"nofollow\">드 모르간의 법칙</a>도 논리식에 그대로 적용된다. <small>(사실 드 모르간의 법칙은 집합에 대한 법칙이라기보다 좀 더 포괄적인 논리학의 법칙이다.)</small></p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c36c7088ac8fe07531617bca4bcd1f35/e17e5/dmorgan.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 133.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAElklEQVR42o1VW0xcVRQd44OPKsLwnPsCYqMmxho/TLT+qImNXyYkjZoYv/SjX6b9MCZQkEYxbaXlNXMHJAzc1ogvJKFaWiKFmsaEQKxKQB4DDAwzd+7wiBTsDL2Y5d7nzkQKQ+PHmrtm77X3OWfv83A90Rp7/TnDrJX1SIWiR0+moelLhEXxvZeNoXKsN/yJ6osccb3akzBqJgApkLC1ziQYpcZtKJ13UBQAPB3/oMRICDBnG/tYk9ZrHQm75MIdqIFbjS7VHwuUdt6GrMcSih6zVT1q5zWt26o/aj9vjNiH2idsd/O6wKH2cWFjn9CQlmMU3Uqo7Rug73mXpJuGamzRH5MFyG9exxvfdWNo/GVMzT2Jsdmn0XD9hADzSbKx703SsJZjOKnWmeAcDS76MTRKqOkRHhXl3/TCXPJgOVKA8KKKyJKMrYmHBJizjX2sYS3HaP7I3oQ8/ULvGr4efQtrUTeCoYNYCJciPKNifSRbIBxUEVosQXD+MaFhLcdw7F0JS4wkPD7LPtgaouW8BCtSjOCshrFxFda0B5ujB7A5cgDxoAc3/1AxPa0hHi0WWo6RfHG7hPqwY4ZJ+hO1i70r6P71KFaj+ZgLldFsNESDEjZGHxZgzjb2sYa1HMP1z1jD3KYNvP19F9ZMN2JLxVgMawiHVSTHswSYs419a9E80n4FjslYw3SXC5rXcOyHNtyceRYLPJuFMlz85R0B5mxj37FLbUK7b5c5ITlIYFLnbuHxz2dxpOsaDl8cRZG+jkLfX4KzjX2sYS3H3DMhQyOhpC+joHEF+bV/Qj47BuX8NPJPz6CgYVn4tP+S7Uroi3XQ0WFjkvj2TqjepW25bmpb+mxyWzo3Q3xS2BSfdZeOTkhSa9+E4jPrXXTkjkt6bFDWzR7ivbuh+OO9SutKCvHeTBpZt3oUvzWg6PH3XK90xY3KEaBYt2y1JQ6F4bccCB6H6jehtsQE3+N3/ts0oLPkshbTeKprC7IvXUMKJrHKwb4oFZ4a5V92wH62iUEsoU3F2Frgbyeh5DUNuSPdFFOIpcYQ8mqHkVszhJxTNyDV/S7AnG3sk5pCzqBO0r1dFjOkUT0kzKn+CdmVl5FT1YcHPxyEb+CoAHO2CR9pWMsxcqaT4iSMI+/TYRGQW92PrIrrONzYRjeLLPAC8ayKIeFjDWs5JmNCcVFSfXJP/YxHq67CXfUj7jvej3e/rKaj5kEs4iH+EVzv98FdeYk0/ULLMZk3dqop7o9vIPvkFbirr+CBDwZR3n6WkkkCzO8nm5uXzRrS7ntSeMlc5KK68VSNruKRqgEU1PRheOIZAeZsy0ktmbUcw7H7zpDeGBSc+U0sKafqMjXiGl7UvxBgzjb2sYa1/+ssO1tnHkXnJuk7K27lQu8q8WDKNp/aMhkS0mYNaB182zqvHoO7JnY/calu2lbqp2y1ad6W6+dsxdkNjial51dPnGV+9ei2Nkq7we+rLS7aNC4QApuQmxahNIe5JOKrBjYc306tkbRLvwXUzkSjS2mOlMve6BlqfzUVt2Y31NbVGnknfNYeDcfSE3Ja8Vqv/QtPwlWPwwPdQwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"dmorgan\" title=\"\" src=\"/static/c36c7088ac8fe07531617bca4bcd1f35/e17e5/dmorgan.png\" srcset=\"/static/c36c7088ac8fe07531617bca4bcd1f35/69538/dmorgan.png 160w,\n/static/c36c7088ac8fe07531617bca4bcd1f35/72799/dmorgan.png 320w,\n/static/c36c7088ac8fe07531617bca4bcd1f35/e17e5/dmorgan.png 400w\" sizes=\"(max-width: 400px) 100vw, 400px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c36c7088ac8fe07531617bca4bcd1f35/e17e5/dmorgan2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 133.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAElklEQVR42o1VW0xcVRQd44OPKsLwnPsCYqMmxho/TLT+qImNXyYkjZoYv/SjX6b9MCZQkEYxbaXlNXMHJAzc1ogvJKFaWiKFmsaEQKxKQB4DDAwzd+7wiBTsDL2Y5d7nzkQKQ+PHmrtm77X3OWfv83A90Rp7/TnDrJX1SIWiR0+moelLhEXxvZeNoXKsN/yJ6osccb3akzBqJgApkLC1ziQYpcZtKJ13UBQAPB3/oMRICDBnG/tYk9ZrHQm75MIdqIFbjS7VHwuUdt6GrMcSih6zVT1q5zWt26o/aj9vjNiH2idsd/O6wKH2cWFjn9CQlmMU3Uqo7Rug73mXpJuGamzRH5MFyG9exxvfdWNo/GVMzT2Jsdmn0XD9hADzSbKx703SsJZjOKnWmeAcDS76MTRKqOkRHhXl3/TCXPJgOVKA8KKKyJKMrYmHBJizjX2sYS3HaP7I3oQ8/ULvGr4efQtrUTeCoYNYCJciPKNifSRbIBxUEVosQXD+MaFhLcdw7F0JS4wkPD7LPtgaouW8BCtSjOCshrFxFda0B5ujB7A5cgDxoAc3/1AxPa0hHi0WWo6RfHG7hPqwY4ZJ+hO1i70r6P71KFaj+ZgLldFsNESDEjZGHxZgzjb2sYa1HMP1z1jD3KYNvP19F9ZMN2JLxVgMawiHVSTHswSYs419a9E80n4FjslYw3SXC5rXcOyHNtyceRYLPJuFMlz85R0B5mxj37FLbUK7b5c5ITlIYFLnbuHxz2dxpOsaDl8cRZG+jkLfX4KzjX2sYS3H3DMhQyOhpC+joHEF+bV/Qj47BuX8NPJPz6CgYVn4tP+S7Uroi3XQ0WFjkvj2TqjepW25bmpb+mxyWzo3Q3xS2BSfdZeOTkhSa9+E4jPrXXTkjkt6bFDWzR7ivbuh+OO9SutKCvHeTBpZt3oUvzWg6PH3XK90xY3KEaBYt2y1JQ6F4bccCB6H6jehtsQE3+N3/ts0oLPkshbTeKprC7IvXUMKJrHKwb4oFZ4a5V92wH62iUEsoU3F2Frgbyeh5DUNuSPdFFOIpcYQ8mqHkVszhJxTNyDV/S7AnG3sk5pCzqBO0r1dFjOkUT0kzKn+CdmVl5FT1YcHPxyEb+CoAHO2CR9pWMsxcqaT4iSMI+/TYRGQW92PrIrrONzYRjeLLPAC8ayKIeFjDWs5JmNCcVFSfXJP/YxHq67CXfUj7jvej3e/rKaj5kEs4iH+EVzv98FdeYk0/ULLMZk3dqop7o9vIPvkFbirr+CBDwZR3n6WkkkCzO8nm5uXzRrS7ntSeMlc5KK68VSNruKRqgEU1PRheOIZAeZsy0ktmbUcw7H7zpDeGBSc+U0sKafqMjXiGl7UvxBgzjb2sYa1/+ssO1tnHkXnJuk7K27lQu8q8WDKNp/aMhkS0mYNaB182zqvHoO7JnY/calu2lbqp2y1ad6W6+dsxdkNjial51dPnGV+9ei2Nkq7we+rLS7aNC4QApuQmxahNIe5JOKrBjYc306tkbRLvwXUzkSjS2mOlMve6BlqfzUVt2Y31NbVGnknfNYeDcfSE3Ja8Vqv/QtPwlWPwwPdQwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"dmorgan2\" title=\"\" src=\"/static/c36c7088ac8fe07531617bca4bcd1f35/e17e5/dmorgan2.png\" srcset=\"/static/c36c7088ac8fe07531617bca4bcd1f35/69538/dmorgan2.png 160w,\n/static/c36c7088ac8fe07531617bca4bcd1f35/72799/dmorgan2.png 320w,\n/static/c36c7088ac8fe07531617bca4bcd1f35/e17e5/dmorgan2.png 400w\" sizes=\"(max-width: 400px) 100vw, 400px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>드 모르간의 법칙을 벤다이어그램으로 나타낸 모습</small>\n</center>\n<p>필자는 드 모르간 법칙이 빛을 발하는 순간이 바로 자연어를 논리식으로 변환할 때라고 생각한다. 보통 회사에서 비즈니스 로직을 짜다보면 PO들이 어떤 기능의 작동 여부에 조건을 추가하는 경우가 많은데 문제는 조건을 추가할 때 기존에 있던 조건들까지 모두 생각하면서 말해주지 않는다는 것이다.</p>\n<p>필자가 지금까지 일을 하면서 겪은 조건 중에 가장 복잡했던 경우를 예로 들어보겠다. 필자는 예전에 멤버십 결제 기능을 개발한 적이 있었는데 문제는 결제 수단을 입력할 수 있는 폼의 렌더 조건이 굉장히 복잡하다는 것이었다. 물론 처음부터 이렇게 복잡한 건 아니였고, 기능이 추가됨에 따라 점점 조건이 복잡해진 케이스이다.</p>\n<p>당시 조건이었던 논리식을 자연어로 그대로 써보겠다.</p>\n<blockquote>\n<p>조건 1. 사용자의 멤버십이 해지 상태가 아니고 결제 수단도 가지고 있지 않다.<br />\n조건 2. 사용자가 결제수단을 가지고 있고 결제 수단을 핸드폰으로 가지고 있으며, 현재 사용자가 고른 상품이 현재 사용자가 가지고 있는 상품이 아니고 현재 멤버십이 해지 예약상태가 아니다.</p>\n<p><code class=\"language-text\">(조건 1 || 조건 2)</code>이면 결제 수단 등록 폼이 활성화 된다.</p>\n<p><strong>조건 version 1</strong></p>\n</blockquote>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c5eea607509f7340ae036675fc5d5a47/066f9/what-are-you-saying.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 67.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAwAF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3AYRY4//xAAZEAADAQEBAAAAAAAAAAAAAAAAARECEiL/2gAIAQEAAQUCqHv1o5Eq6f/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAMAAwAAAAAAAAAAAAAAAAABEBESMf/aAAgBAQAGPwIxrOIU/8QAGhABAQEBAAMAAAAAAAAAAAAAAREAIUFRkf/aAAgBAQABPyHrKZRwgfcC4UnDVAw9YHk3/9oADAMBAAIAAwAAABDQD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAQEAAgIDAQAAAAAAAAAAAAERACExQVFhgeH/2gAIAQEAAT8QRtXomBSkRZwZz+ZD0ceMAvVWrMpYirXRsxAGwDYS0p93n//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"what are you saying\" title=\"\" src=\"/static/c5eea607509f7340ae036675fc5d5a47/066f9/what-are-you-saying.jpg\" srcset=\"/static/c5eea607509f7340ae036675fc5d5a47/0913d/what-are-you-saying.jpg 160w,\n/static/c5eea607509f7340ae036675fc5d5a47/cb69c/what-are-you-saying.jpg 320w,\n/static/c5eea607509f7340ae036675fc5d5a47/066f9/what-are-you-saying.jpg 400w\" sizes=\"(max-width: 400px) 100vw, 400px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>뭐 사실 저 사단이 난건 1차적으로 개발자인 필자의 잘못이긴 하지만 굳이 핑계를 대자면 시간에 쫓겨서 맨날 야근하면서 개발하다보니 저런 괴물같은 논리식이 탄생해버렸다…</p>\n<p>저렇게 개판쳐놓고나서도 다른 할 것도 너무 많았기 때문에 일단 묻어놓고 다른 프로젝트를 또 개발하던 중에 PO가 필자에게 이야기 했다.</p>\n<blockquote>\n<p>에반, 저희 결제 수단 등록 폼에 조건 하나만 더 추가할 수 있을까요?</p>\n</blockquote>\n<p>저 얘기를 듣고 다시 저 코드를 보고 PO 얼굴을 한번 본 뒤, 저걸 어떻게든 뜯어고쳐야겠다는 결론에 다다른 필자는 조용히 노트북을 들고 화이트 보드 앞으로 간 후, 저 복잡한 조건들을 어떻게든 이해할 수 있는 수준으로 만들기 위해서 발버둥쳤는데 그 결과가 이것이다.</p>\n<blockquote>\n<p>조건 1. 사용자가 멤버십 가입 상태가 아니고, 사용자가 등록한 결제 수단이 카드가 아니다.<br />\n조건 2. 사용자가 멤버십 가입 상태이고 사용자가 등록한 결제 수단이 휴대폰이며, 현재 구매하려고 선택한 멤버십이 나의 멤버십과 다른 상품이다.<br />\n조건 3. 사용자의 결제 수단 정보가 없다.</p>\n<p><code class=\"language-text\">(조건 1 || 조건 2 || 조건3)</code>이고 사용자가 선택한 결제 수단이 카드라면 결제 수단 등록 폼이 활성화 된다.</p>\n<p><strong>조건 version 2</strong></p>\n</blockquote>\n<p>사실 이것도 간단한 논리식은 아니지만 그래도 조건 1, 조건 2, 조건 3만 읽어 보았을 때 이전의 조건에 비해서 어떤 상태인지 좀 더 알아보기 쉬워졌다. <small>(라고 자기합리화를 해봅니다.)</small> 이 당시 필자가 논리식을 정리할 때 사용했던 방법이 벤다이어그램과 드 모르간 법칙이었다.</p>\n<p>벤다이어그램으로 논리식을 펼쳐놓음으로써 여러 개의 논리식 중 사실 같은 명제이지만 역의 꼴을 취하고 있는 친구들을 쉽게 찾을 수 있었고 겹치는 명제들을 골라서 합치고 좀 더 알아보기 쉬운 단위로 조건을 나누고해서 저렇게라도 만들어 놓은 것이다.</p>\n<p>물론 이 코드는 언젠가 개선을 해야한다… <small>(언젠가…)</small></p>\n<p>그리고 추가적으로 이런 논리식 외에도 데이터베이스에 질의를 던질 때 사용하는 SQL의 JOIN 개념도 보통 벤다이어그램으로 표현한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6a3a0aaa506a8ad2f6693bcadfe974cf/68e9c/sqljoin.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 72.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsTAAALEwEAmpwYAAACM0lEQVR42n1Tv2/TQBTOH0SltogWiQWxsLIwwoIEA1IXBoTExtARFbEwIhbE0iKqqDFSg2PSEDsyduw4duK4+eFSO8GOfXYcO/Y5XOzUiTrwLf7u+b577333LjdPEMfxkqzxa8ii2YZc+gnD2VF78I6V+d5gAuyxZUEIs60AANuyhsPhJ+H8A6fowEnjuSg55rPY28L4rTz9EKtN/GA69YDjpGLP8ywAENmv8htH1e1T6UWlOY+iReZU/JaRb3wXdvP0PYzRgQvD0LbtVOw4DnBcRPaI+sZXcgdvP8L5MAgW4rQB3XZe0crjM+kLK81hZI7HQfI76ShcVBHHbE99Xmk+pZTKQENxGF/1HIVhS2wSBNFpiTiOg6TOOAEiOEHkTwpCg2dZpvKrCpOaV4ZFEHb7/XanM9R1SZJ831/32dQvOYo0dE2/UC963czLpRjtRr0hY5p91Z9OLctC1V5dT1xSR6+Z7kdOfs/Kb2hZHplLt1OxYY7RkvwzeoDR1sSbBb6dVI7QNe27GLP7o3XzsHzrmNostp6VODibrTL/NQwk/jnQ7xdow50gMzOxbFh3CsxtvLV9eLbzjdo8lZ7gSBysxFMEzwOuy5z3A99Hhs2Ss+OkvuOOukfKB2Rjn26/rMmNy9HS7dRP13GKxSJJkpIoYhimqur6GDa5erVcFrl6pYT/pqjMyGw8Q03T0AAahomI67rrbqNlR1FOChhVqxmmCa/N9n+Q5keNCIKAbmH9YfwD30n28wXkqg0AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"sqljoin\" title=\"\" src=\"/static/6a3a0aaa506a8ad2f6693bcadfe974cf/6af66/sqljoin.png\" srcset=\"/static/6a3a0aaa506a8ad2f6693bcadfe974cf/69538/sqljoin.png 160w,\n/static/6a3a0aaa506a8ad2f6693bcadfe974cf/72799/sqljoin.png 320w,\n/static/6a3a0aaa506a8ad2f6693bcadfe974cf/6af66/sqljoin.png 640w,\n/static/6a3a0aaa506a8ad2f6693bcadfe974cf/68e9c/sqljoin.png 654w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>이런 경우 복잡한 논리식이나 SQL의 JOIN문을 보고 벤다이어그램이 바로 머리 속에 떠오른다면 그냥 코드나 자연어로 이해하는 것 보다는 좀 더 직관적이고 빠르게 이해할 수 있지 않을까? 라는 생각을 해본다.</p>\n<h3 id=\"수학적-귀납법mathematical-induction\" style=\"position:relative;\">수학적 귀납법(Mathematical Induction)<a href=\"#%EC%88%98%ED%95%99%EC%A0%81-%EA%B7%80%EB%82%A9%EB%B2%95mathematical-induction\" aria-label=\"수학적 귀납법mathematical induction permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>수학적 귀납법(Mathematical Induction)은 수학에서 사용하는 증명 방법 중 하나이다. 주로 어떤 명제가 모든 자연수에 대하여 성립함을 보이기 위해 사용한다. 수학적 귀납법이 무엇인가를 자세히 알아보기 전에 먼저 우리는 논리학의 논증법 투톱인 귀납논증과 연역논증에 대해서 알아야한다.</p>\n<p>간단하게 이야기해보자면 귀납논증은 “지금까지 그래왔으니까 앞으로도 그럴 것이다”라는 느낌이고 연역논증은 “전제가 맞다면 결론도 반드시 맞다”라는 느낌이다. 이걸 너무 자세히 설명하면 글이 길어지기 때문에 간단한 예시로 간만 보겠다.</p>\n<p>먼저 귀납논증은 이런 느낌이다.</p>\n<blockquote>\n<p>2000년 여름은 더웠다, 2001년 여름도 더웠다…2019년 여름도 더웠다. <strong>그러므로 여름에는 반드시 덥다.</strong></p>\n</blockquote>\n<p>귀납적인 이런 논증 방식은 모든 전제가 참이라고 해도 반드시 결론도 참이라는 법이 없다. 당장 위의 예시만 봐도 2020년 여름에는 기상이변으로 인해서 눈이 올 수도 있지 않을까? <small>(투모로우…?)</small></p>\n<p>즉, 귀납논증은 언제나 오류가 존재할 확률이 있다. 여기까지만 보면 왠지 허점투성이 논증법인 것 같지만 그래도 현대 과학은 귀납논증을 통해 끊임없는 가설을 제시하고 그걸 증명함으로써 발전해왔으므로 상당한 가치가 있는 논증법이라고 할 수 있다.</p>\n<p>반면 연역논증은 이런 느낌이다.</p>\n<blockquote>\n<p>맥북은 애플이 만든다. 내 컴퓨터는 맥북이다. <strong>그러므로 내 컴퓨터는 애플이 만들었다.</strong></p>\n</blockquote>\n<p>위 예시는 연역논증 중에서 가장 대표적인 사례인 삼단논법이다. 이게 바로 위에서 얘기한 “어떤 부분적인 전제가 맞다면 결론도 반드시 맞다”라는 의미이다. 만약 결론이 거짓이라면 전제 중 하나도 무조건 거짓이다. 즉, 연역논증은 이미 전제에 담겨있던 것을 증명하는 데는 탁월하지만 귀납논증처럼 새로운 지식을 탐구하기에는 부적절하다.</p>\n<p>하지만 우리가 프로그래밍을 할때는 새로운 지식을 탐구하는 것이 아니라 그냥 내 코드가 오류없이 완벽한가를 증명하기 위한 논증법을 사용해야하므로 귀납논증보다는 연역논증이 더 알맞다.</p>\n<p>필자가 이 두 논증법을 전부 설명한 이유는 바로 “수학적 귀납법이 귀납논증이 아니라 연역논증”이기 때문이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 547px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/092534ee3a31b64fae8d24f559633f54/97d16/ah.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 59.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGZkU6a44j/xAAbEAEBAAEFAAAAAAAAAAAAAAACAQMEESIjRP/aAAgBAQABBQLO42eSesRXmlu4vX//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAdEAABBAIDAAAAAAAAAAAAAAABAAIRIQNBEFFx/9oACAEBAAY/Amk2I2jdjSg449TT0eGzdL//xAAcEAACAgMBAQAAAAAAAAAAAAABEQAhMUFRcaH/2gAIAQEAAT8hafhJ9l6j0Oh7CwAh1De6kQpna1Dk6EciJ//aAAwDAQACAAMAAAAQcy//xAAZEQABBQAAAAAAAAAAAAAAAAAAAREhMVH/2gAIAQMBAT8QuB0w/8QAFhEAAwAAAAAAAAAAAAAAAAAAEBFB/9oACAECAQE/EFR//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARITFBYf/aAAgBAQABPxDVYBJx3aoatjoao0+sTl3BbhKTOTxmYYNlVypQKiWf/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ah\" title=\"\" src=\"/static/092534ee3a31b64fae8d24f559633f54/97d16/ah.jpg\" srcset=\"/static/092534ee3a31b64fae8d24f559633f54/0913d/ah.jpg 160w,\n/static/092534ee3a31b64fae8d24f559633f54/cb69c/ah.jpg 320w,\n/static/092534ee3a31b64fae8d24f559633f54/97d16/ah.jpg 547w\" sizes=\"(max-width: 547px) 100vw, 547px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>아니...귀납법이라며...?</small>\n</center>\n<p>수학적 귀납법은 어떤 명제 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span></span>가 있을 때 다음 2가지만 충족시키면 모든 자연수에 대해서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span></span>가 성립한다는 것을 의미한다.</p>\n<blockquote>\n<ol>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>은 참이다<br /></li>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>이 참이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(n + 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>도 참이다.</li>\n</ol>\n<p>그러므로 명제 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span></span>는 모든 자연수에 대해서 참이다.</p>\n</blockquote>\n<p>이렇게만 얘기하면 또 머리가 아파지니까 예시를 살펴보자. 수학적 귀납법은 보통 도미노로 예시를 많이 들기 때문에 필자도 도미노를 예로 설명하겠다.</p>\n<blockquote>\n<ol>\n<li>맨 처음에 있는 도미노가 쓰러진다. <small>(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>이 참)</small><br /></li>\n<li>무작위로 고른 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>번째 도미노가 쓰러질 때 항상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>번째에 세워진 도미노도 쓰러진다. <small>(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>이 참이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(n + 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>도 참)</small><br /></li>\n</ol>\n<p>그러므로 맨 처음에 있는 도미노를 쓰러트리면 반드시 모든 도미노가 순서대로 쭉쭉 쓰러진다.</p>\n</blockquote>\n<p>이것이 수학적 귀납법의 논리 전개 방식이다. 간단하게 얘기하자면 전제가 참이라는 것을 먼저 보인 후에 그 전제에서 보편적인 결론을 이끌어 내는 것이다.</p>\n<p>이런 수학적 귀납법은 알고리즘의 정당성을 검증할 때 아주 유용하게 쓰일 수 있다. 왜냐면 알고리즘이란 것은 굉장히 보편적인 규칙이고, 어떤 형태로든 반드시 반복적인 요소를 가지고 있기 때문이다.</p>\n<p>그럼 한번 유명한 알고리즘인 팩토리얼을 구하는 알고리즘을 한번 수학적 귀납법으로 풀어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> n <span class=\"token operator\">*</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<ol>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">n = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span>인 경우 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">!</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n! = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>이다.<br /></li>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">!</mo><mo>=</mo><mi>n</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo>×</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mn>.3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n! = n \\times (n - 1) \\times (n - 2) \\times ... 3 \\times 2 \\times 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">...3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span> 이다.<br /></li>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>×</mo><mi>n</mi><mo stretchy=\"false\">!</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>×</mo><mi>n</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>×</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mn>.3</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">(n + 1) \\times n! = (n + 1) \\times n \\times (n - 1) \\times ... 3 \\times 2 \\times 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">...3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span> 이다.</li>\n</ol>\n<p>그러므로 이 논리는 참이다.</p>\n</blockquote>\n<p>이런 식의 논리적인 사고방식은 당장 코딩할때 직접적인 도움이 되지는 않겠지만, 복잡한 문제를 만났을 때 일반화된 해결법을 찾아낼 수 있는 능력을 키워준다. 사실 이런 논증법을 적용할 수 있는 문제는 일상에서도 얼마든지 찾아볼 수 있으므로 평소에도 한번 이렇게 생각하는 습관을 들여보는 것도 나쁘지 않다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이 포스팅에서 설명한 저런 것들 다 몰라도 느낌적인 느낌으로 프로그래밍을 잘 할수는 있다. 하지만 곰곰히 생각해보자. 저런 것들을 모르고 프로그래밍을 하고 있었다고 생각했던 분들도 그냥 이론으로 정리하지 않았을 뿐이지 알게모르게 저 개념들을 전부 사용하고 있었을 것이다.</p>\n<p>그리고 필자가 생각했을 때 수학을 배우면 가장 좋은 점은 내가 만들고 싶은 것을 만들때 적어도 이론에서 막히는 일은 없다는 것이다.</p>\n<p>필자가 예전에 작성했던 포스팅인 <a href=\"/2017/05/03/calculate-orbit-2\">행성 궤도 계산</a>이나 <a href=\"/2018/07/19/deep-learning-backpropagation\">역전파 알고리즘</a>같은 포스팅만 봐도 수식이 많이 나와서 어려워 보일 수 있다. 사실 필자도 저 친구들을 처음 만들 때 학교에서 배운 수학 같은 건 이미 가물가물한 상태였기 때문에 거의 처음부터 다시 공부해서 결국은 저 프로젝트를 완성할 수 있었다.</p>\n<p>물론 선형대수학부터 시작해서 오일러 회전, 쿼터니온 등 이름만 들어도 토할 것 같은 이론들이 처음에는 필자에게도 상당한 두려움으로 다가왔지만 일단 이해가 안되더라도 문서를 계속 보고 조금이라도 이해되는 부분이 있다면 코드로 작성한 후에 하나하나 실행시켜보면서 공식의 매커니즘을 눈으로 직접 보다보니까 어느 순간부터는 그래도 처음보다 많이 익숙해졌던 것 같다.</p>\n<p>수학은 그렇게 무서운 친구가 아니다. 위에서 예시로 나왔던 인공신경망 알고리즘의 수식도 처음 보면 뭔가 어려워보이고 복잡해보이지만 막상 코드로 풀어보니 별 거 아니였던 것처럼 말이다. 여러분은 이미 개발자로써 알게 모르게 수학이나 논리학의 개념이 몸에 배어있는 사람인데 이제 와서 수학을 겁내는 것도 좀 이상하지 않은가? 이제는 그런 마음을 다 털어버리고 한번 수학과 친해져보자.</p>\n<blockquote>\n<p>수학은 그냥 프로그래밍 언어처럼 여러분이 상상하는 것을 실현시켜줄 수 있는 <strong>도구</strong>라고 생각하자.</p>\n</blockquote>\n<p>이상으로 개발자는 수학을 잘해야할까? 포스팅을 마친다.</p>","fields":{"slug":"20190717-programmer-with-math","path":"/2019/07/17/programmer-with-math/","lang":"ko"},"frontmatter":{"title":"개발자는 수학을 잘해야할까?","subTitle":"수학은 도구일 뿐, 좋은 개발자는 논리로 성장한다","date":"Jul 17, 2019","categories":["프로그래밍","에세이","알고리즘"],"tags":["수학","프로그래밍","알고리즘","논리학","잘 하는 개발자","집합","귀납법","연역법","삼단논법"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/7dcd9f83bd0b0992a2a168e5c698d19b/3a812/thumbnail.jpg","srcSet":"/static/7dcd9f83bd0b0992a2a168e5c698d19b/3a812/thumbnail.jpg 320w,\n/static/7dcd9f83bd0b0992a2a168e5c698d19b/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/7dcd9f83bd0b0992a2a168e5c698d19b/fc5c5/thumbnail.webp 320w,\n/static/7dcd9f83bd0b0992a2a168e5c698d19b/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/7dcd9f83bd0b0992a2a168e5c698d19b/2d839/thumbnail.jpg","srcSet":"/static/7dcd9f83bd0b0992a2a168e5c698d19b/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/7dcd9f83bd0b0992a2a168e5c698d19b/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"논리학","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}