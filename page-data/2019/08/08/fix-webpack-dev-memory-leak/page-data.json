{"componentChunkName":"component---src-templates-post-tsx","path":"/2019/08/08/fix-webpack-dev-memory-leak/","result":{"data":{"markdownRemark":{"id":"70a872e7-c41c-54d0-a0e1-fd675a1dee3b","excerpt":"이번 포스팅에서는 최근에 고쳤던 Webpack Watch 기능의 메모리 누수에 대해서 간략하게 남겨보려고 한다. 필자가 회사에서 개발한 프로젝트가 점점 커짐에 따라서 Watch 중에 빌드를 여러 번 돌리게되면 어느 순간 갑자기 가 뜨면서 프로세스가 죽어버리는 이슈가 발생하였다. 이 문제는 사실 꽤 예전부터 발생했던 이슈지만 계속 비즈니스 이슈를 개발하느라고 외면받고 있던 이슈였는데 우연히 기회가 되어 해당 이슈를 자세히 들여다 볼 수 있었다.","html":"<p>이번 포스팅에서는 최근에 고쳤던 Webpack Watch 기능의 메모리 누수에 대해서 간략하게 남겨보려고 한다. 필자가 회사에서 개발한 프로젝트가 점점 커짐에 따라서 Watch 중에 빌드를 여러 번 돌리게되면 어느 순간 갑자기 <code class=\"language-text\">out of memory</code>가 뜨면서 프로세스가 죽어버리는 이슈가 발생하였다. 이 문제는 사실 꽤 예전부터 발생했던 이슈지만 계속 비즈니스 이슈를 개발하느라고 외면받고 있던 이슈였는데 우연히 기회가 되어 해당 이슈를 자세히 들여다 볼 수 있었다.</p>\n<!-- more -->\n<p>사실 구글에 <code class=\"language-text\">webpack watch memory leak</code>이라고 검색만 해봐도 같은 이슈로 고통받고 있는 전세계의 동지들이 많다는 것을 알 수 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/719ca011fe26513ab9402af9feb1e870/71ee9/out-of-memory.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75.625%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAAB+klEQVQ4y4VT2XarMAz0b3TJStgT1kDA7CRN2///INUj4hyS03v7MEeyMdJIIwnTdsn1D2Q5Lq02xp9YrrcP/vz8vlyT6IYzXb++qel6Kqua8qIkWTd0KiuK04yyU6HuJBWypmNeUJSk6q5kHyhkxeedZU8Bbdcnx9sTmM6zrbc7Wm0nFovV5m7nvn4Pi2C4E4cwpn0Qkbb7IFQtmBLsLOfhJw0dDHhbrB6gAkaUHHOFjMvMS6ms5HKj9MiJwji9lV+yHybTGbAcj6EJiCBK+AOCptmJEcYJJ4iS450lWvBcvma5MUwG3giIUDUt1W3HqBRk3TJbMMV3BIYY6Lfuubc/cDKwQ9CXt8VUsg5YNR11w0jnjyv141kp3pBU91C/6QYG7nFGQiDNcq7O8XwObJg2CTDBmICdHh2c235Qdz37SIZgUyU9M3x9X7JYz2oLLQICXj6/mAlYjjembT8y88v1kxMO5wsLhUA8WrOh5zmUqrTx8sHDi8z+IeD+ANggnHEPH4BvqCFG/6CsVte0nSlgEZdUnjoeF/RBqwWLh8B2Z3F/4M+tYVr37/qtqLOGoiClRDXYdr2nx5NFcPwEwP/frovQicmxfIp57lKeQ+wo1MM8YnNQlh5eJENp/4IoMrXcWcGioJ9QNIhi1cPgtgUuCzD/Se/0b/gBvZzFrVcS0qoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"out of memory\" title=\"out of memory\" src=\"/static/719ca011fe26513ab9402af9feb1e870/6af66/out-of-memory.png\" srcset=\"/static/719ca011fe26513ab9402af9feb1e870/69538/out-of-memory.png 160w,\n/static/719ca011fe26513ab9402af9feb1e870/72799/out-of-memory.png 320w,\n/static/719ca011fe26513ab9402af9feb1e870/6af66/out-of-memory.png 640w,\n/static/719ca011fe26513ab9402af9feb1e870/d9199/out-of-memory.png 960w,\n/static/719ca011fe26513ab9402af9feb1e870/71ee9/out-of-memory.png 1081w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  <small>Webpack&#xC744; &#xC0AC;&#xC6A9;&#xD558;&#xB2E4;&#xBCF4;&#xBA74; &#xC790;&#xC8FC; &#xBCFC; &#xC218; &#xC788;&#xB294; &#xC2AC;&#xD508; &#xD654;&#xBA74;</small>\n</center>\n<p>일단 이 문제의 가장 유명한 해결 방법은 바로 NodeJS의 <code class=\"language-text\">--max-old-space-size</code>을 사용하여 Old Space의 영역을 늘리는 것이다. 원래 Old Space의 기본 크기는 64비트 기준 1.4GB 정도이지만 이렇게 메모리가 터지는 경우 Old Space에 4GB나 8GB를 할당할 것을 권장하는 해결 방법이 많다.</p>\n<p>사실 이 방법을 사용하면 왠만큼 해결은 된다. 메모리 누수는 일반적으로 <code class=\"language-text\">GC(가비지 컬렉팅)</code> 때 수집되어야 할 쓰레기가 제대로 수집되지 않아서 발생하는 경우가 대부분인데, 이때 수집되지않은 쓰레기 객체들은 모두 Old Space에 있기 때문이다. 하지만 이 방법은 근본적인 해결 방법이 아니라 그냥 메모리가 터지는 시점을 좀 더 늦춘 것 뿐이다.</p>\n<blockquote>\n<p>Old Space에 4GB를 할당해주고 20번 빌드했더니 메모리가 터져서 Old Space에 8GB를 할당했다? 그레봤자 약 40번 정도 빌드하면 언젠간 또 터진다.</p>\n</blockquote>\n<p>그렇다고 이렇게 해결하는 것이 틀린 방법인 건 아니다. 필자도 사실 이미 <code class=\"language-text\">--max-old-space-size=4096</code> 옵션을 통해 Old Space에 4GB 정도를 할당해주고 있었다. 하지만 이건 마치 뭐랄까, 진통제 같은 느낌이지 근본적인 치료는 아니기 때문에 이번 기회에 필자는 이 이슈의 원인을 찾아내어 제대로 고쳐보고 싶었다.</p>\n<h2 id=\"nodejs-인스펙터-사용하기\" style=\"position:relative;\">NodeJS 인스펙터 사용하기<a href=\"#nodejs-%EC%9D%B8%EC%8A%A4%ED%8E%99%ED%84%B0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"nodejs 인스펙터 사용하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>먼저, 이런 메모리 누수가 고치기 까다로운 이유는 원인 추적이 힘들기 때문이다. 예를 들어 <code class=\"language-text\">TypeError</code>같은 경우는 로그에 아주 명확하게 <code class=\"language-text\">어디서, 왜</code> 타입에러가 발생했는지 알려주지만 메모리 누수는 그딴 거 없다.</p>\n<p>그냥 쭉쭉 잘 실행되고 있는 듯 보이다가 어느 순간 픽! <code class=\"language-text\">out of memory</code>를 남기고 프로그램이 죽어버리기 때문이다. 프로그램이 죽으면서 마지막 힘을 짜내어 몇 줄의 Stack Trace를 남겨주긴 하지만, 표면적인 원인만 보여주는 느낌이기 때문에 메모리 누수를 고칠 때는 별 도움이 안되었던 것 같다.</p>\n<p>그래서 이런 메모리 누수를 고칠 때는 가장 먼저, 자바스크립트의 Heap을 뜯어봐야한다. 프로그램 내에서 어떤 놈이 메모리를 점점 갉아먹고 있는 지 부터 파악하는 것이다. NodeJS를 실행시킬 때 몇가지 옵션을 사용하면 구글 크롬(Chrome)의 개발자 도구를 사용하여 Heap의 스냅샷을 찍을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ node --inspect --inspect-brk server</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 556px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f8fc7cade4bf23104fdd937cddf97b42/96638/inspector.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.125%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB2ElEQVQ4y61S25KaUBDkC5I8+qqACHKViwoCclkuy5ZJJb+R2i/Iv3dmJuKyqeQhVXno8kyfpntmjspT0+B6vaLvBlyqDN++T8jLHOfzGcM4YhgG9H2PruuEE+29HunedhysVivs93sYhgElKUtkWYoiLxGlIV5eWwRxgMDz0NYV2rZFQ6FVVcEjLo7jR813uqbi08cPcMjYsiwor6cToiSh1A6BH+ByztE2Nbw4hZmUSOIIaZqJWVEU0uHhcKDfCvklg5tksLwQNnUohj/SFNHxiM+3G8IwREOp0zjAI6GbD8jOJ9R1jSiKxGyaJhxJz+eCDK0ghnMqEEehaBSbRnBdF9vtFtZ9DzqfLROWuYNpmgJO57E49JLn6MdntE89BbxIE7cvX6nuoJxoXN/3xVDXdcFutxNjxsxrmiaGvEN+HDZs2g7D8yRGXT+ibloom81GPuBXyosrpZfSkXRKvE97vVYN0uwiQRygqip1vBdtGMXQqN6s18RvfhmygDtgkeO4dNaF4zs22Ns2bNsRDfMMw9jBoVXx34aDVVWTe2U2mw3Ue8dLfi3pb/V7/r3+YThj3uOf+KXh3/SPkWfMwiXHWBr+rp8NGcoyhcE7W774v/LKsv3/gZ+WcJAeLVwasAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"inspector\" title=\"inspector\" src=\"/static/f8fc7cade4bf23104fdd937cddf97b42/96638/inspector.png\" srcset=\"/static/f8fc7cade4bf23104fdd937cddf97b42/69538/inspector.png 160w,\n/static/f8fc7cade4bf23104fdd937cddf97b42/72799/inspector.png 320w,\n/static/f8fc7cade4bf23104fdd937cddf97b42/96638/inspector.png 556w\" sizes=\"(max-width: 556px) 100vw, 556px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  <br>\n</center>\n<p><code class=\"language-text\">--inspect</code> 옵션을 사용하여 어플리케이션을 시작하고나서 구글 크롬의 아무 창이나 선택한 후 개발자 도구를 켜보면 왼쪽 구석에 NodeJS의 아이콘이 생긴 것을 확인할 수 있다. 그 아이콘을 누르면 NodeJS를 프로파일링할 수 있는 새로운 인스펙터가 나타난다. 그리고 <code class=\"language-text\">--inspect-brk</code> 옵션은 코드를 실행하기 전 Debug Pause 기능을 이용하여 실행을 멈춰준다. 개발자가 직접 Resume 버튼을 눌러주면 코드가 실행된다.</p>\n<h2 id=\"메모리-누수-원인\" style=\"position:relative;\">메모리 누수 원인<a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EC%9B%90%EC%9D%B8\" aria-label=\"메모리 누수 원인 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자도 맨 처음에 했던 일이 바로 NodeJS의 인스펙터를 사용하여 Heap 스냅샷을 찍어보는 것이었다. 사실 필자는 이 이슈가 일반적인 메모리 누수 상황과는 조금 다르다고 생각했는데, 보통 일반적인 메모리 누수는 대략 이런 시나리오로 그려진다.</p>\n<blockquote>\n<ol>\n<li>객체를 생성!</li>\n<li>객체 참조를 해제함!</li>\n<li>근데 GC가 안됨…? 뭐지…?</li>\n<li>알고 보니 다른 놈이 참조를 하고 있었다는 결말</li>\n</ol>\n</blockquote>\n<p>그렇기 때문에 보통 메모리 누수는 <code class=\"language-text\">어떤 놈이 해제되어야 할 객체를 참조하고 있는거지?</code>로 시작하는 경우가 많다.\n그래서 보통 객체 할당을 하고 한번 Heap 스냅샷을 찍고, 다시 객체 참조를 해제한 다음 다시 Heap 스냅샷을 찍은 후 그 두 스냅샷을 비교하는 방법으로 디버깅을 진행한다. 분명히 나는 참조를 해제했는데 뭔가 아직도 유지되고 있는 놈이 보인다? 바로 그 놈이 범인일 가능성이 높다. 이 범인 색출이 오지게 힘들긴 하지만…</p>\n<p>하지만 Webpack의 메모리 누수 이슈는 이런 복잡한 이슈는 아닌 것 같았다. Stack Overflow에서 다른 사람들의 사례를 보면 프로젝트가 작을 때는 별 문제 없다가 프로젝트가 커질수록 이런 문제가 발생한다는 사례가 많았고, 필자 또한 그런 상황이었기 때문에 처음부터 방향은 <code class=\"language-text\">혹시 빌드할 때마다 파일이 계속 누적되고 있나?</code>라는 가설로 잡았기 때문이다.</p>\n<p>그래서 가설을 확인하기 위해 일단 빌드를 <code class=\"language-text\">n번</code> 진행한 후, 메모리 사용량의 변화를 살펴보기 위해 매 빌드마다 Heap 스냅샷을 찍었고, 그 결과 <code class=\"language-text\">Memory File System</code> 이라는 놈이 점점 비대해지고 있는 것을 발견했다.</p>\n<table>\n<thead>\n<tr>\n<th>빌드 횟수</th>\n<th>MFS의 메모리 사용량(byte)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>21,034,701</td>\n</tr>\n<tr>\n<td>2</td>\n<td>38,776,735</td>\n</tr>\n<tr>\n<td>3</td>\n<td>45,209,592</td>\n</tr>\n<tr>\n<td>4</td>\n<td>51,642,543</td>\n</tr>\n<tr>\n<td>7</td>\n<td>83,807,008</td>\n</tr>\n<tr>\n<td>10</td>\n<td>122,404,490</td>\n</tr>\n<tr>\n<td>13</td>\n<td>180,301,478</td>\n</tr>\n</tbody>\n</table>\n<p>여기까지 확인한 후 <code class=\"language-text\">Memory File System</code> 객체의 내부를 한번 까봤더니 예상한 대로 번들링했던 모든 파일이 계속 누적되고 있는 것을 확인할 수 있었다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/bc66d327ef24fa7aa752904a24cc3a4a/2e367/mfs.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 130.625%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAABYlAAAWJQFJUiTwAAAC7klEQVRIx4WV2ZaiQBBE/RQXPCpLUayyg4ozL3Pm//8mpiIBGxWdh2qhT3s7MiMya1VmJf5Uf9EVF9z737i1PdqmRdddkGUZiryQzyROkCTfTxzHWG22G0RejNproe0AZVxDKR9JlsLTCkf7iP1hj/V2Df4tz3a7xXpt3jdred5sNtjtdnJW/GHtLYROhNQ9owgqZCpHpSrUqkHuFCjdGmcnQ2wnCE8RbMfBOcsRJyl834fWGofDYQBaOws7a4fQjeSLhVvKaVWHq39D619w0z0qb4AmboogDFFWtUBD80zg6XR6BkYOgRVKrxJgo1pcCBzBtXnXRw3PKKrqFqmBBUGAyAAJY+mWZc0UGuCkLncLdOqCzqgjkKf2GgMMoAxwUkelYRg81D0BI/dZIVVd/KvACGbJP8BmABqFBDqmp4sKCZxUUtHV78eSe3n3TcmvQB7XdZeB+axkUaYGZVTKfk7AoqyRnjNoURguK2TJlXG5NAACm9EMwq56UBqMJVd1g8wEPvgGDJ3woTBz8rGPvfSvM9Cph55Sg0JTstZDyctAd3CZpmRuLpn7MeUqMXqULC4PCplB27bfXZ6bQihzR1USHzW5rBdcDj+7XMxcJmDI4FAyn99yOLq8qPA1h4zJTd/FHCqk4uAthyGiKPqmcIgMP6dJIZj94/u85HScY66s5RzOFE45pMu9UfmphwRSoed5n4FTDwkhlOqu45JQR//NlM8KJYfFWHIlveNh0CWP5h8wNo8cmklhD+M4+jQpsZRVyqlk1JhDGnMPfsvvBpe1rC9OylTyIjCYKeSksFSeeiyZbdAPhZVRmM9m2f1/D5sx2OzdsLF/9iFLZg/1uL7Yw6+TQpWMy2Ucubv+JWDpoa9QN93DlCSJPyh0XhV2j7U1LdjUOSN2E/gGNDfm6ZKS6+/lCuAhbJrjTl0fW+hsn+Eqbxi/cYVN40eVq721l2uULtNJGT2vHB3upWQ6zStVtpC5apX235xmH1nyP1GPNIbKl816AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"mfs\" title=\"mfs\" src=\"/static/bc66d327ef24fa7aa752904a24cc3a4a/6af66/mfs.png\" srcset=\"/static/bc66d327ef24fa7aa752904a24cc3a4a/69538/mfs.png 160w,\n/static/bc66d327ef24fa7aa752904a24cc3a4a/72799/mfs.png 320w,\n/static/bc66d327ef24fa7aa752904a24cc3a4a/6af66/mfs.png 640w,\n/static/bc66d327ef24fa7aa752904a24cc3a4a/d9199/mfs.png 960w,\n/static/bc66d327ef24fa7aa752904a24cc3a4a/2e367/mfs.png 1066w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  <small>&#xC9D5;&#xAE00;&#xC9D5;&#xAE00;&#xD55C; &#xAC83;&#xB4E4;...</small>\n</center>\n<p>왜 이런 문제가 발생했을까? 그 이유는 해당 프로젝트의 Webpack 세팅의 번들 파일 이름 패턴이 <code class=\"language-text\">client-bundle.[chunkhash].js</code>로 되어있었기 때문이다. <code class=\"language-text\">chunkhash</code>나 <code class=\"language-text\">hash</code> 옵션은 매 번들링 때 새로운 파일명을 만들어주므로 운영환경에서 발생하는 파일 캐싱 이슈에 대해서 자유롭게 해준다. 하지만 개발 환경에서는 이 옵션이 오히려 독이 된 것이다.</p>\n<p>Webpack은 개발 서버를 띄울 때 번들링된 파일을 <code class=\"language-text\">memory-fs</code>라는 라이브러리를 사용하여 저장한다. 이 라이브러리는 그냥 내부적으로 <code class=\"language-text\">맵(Map)</code>을 가지고 있고 파일 내용은 <code class=\"language-text\">파일의 각 라인을 원소로 가지고 있는 배열(Array)</code>이다. 즉 번들링된 파일 이름이 <code class=\"language-text\">main.js</code>이면 다음과 같은 구조를 가진 객체가 생성된다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">MFS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">'main.js'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'var a = 1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'console.log(a)'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>만약 필자가 <code class=\"language-text\">main.js</code> 파일이나 여기서 종속된 모듈을 수정하면 <code class=\"language-text\">main.js</code>는 다시 번들링 될 것이고 <code class=\"language-text\">MFS</code> 객체의 <code class=\"language-text\">main.js</code>키의 값을 새로 번들링된 파일의 내용으로 변경할 것이다. 그러나 문제는 <code class=\"language-text\">chunkhash</code>나 <code class=\"language-text\">hash</code>와 같이 빌드 때마다 파일 이름이 변경되는 경우에 생긴다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">MFS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">'main.1111.js'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'var a = 1'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 기존 파일</span>\n  <span class=\"token string\">'main.2222.js'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'var a = 2'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 새로 번들링된 파일</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">main.1111.js</code>는 이전 빌드 때 생성된 번들이고 <code class=\"language-text\">main.2222.js</code>는 이번 빌드 때 생성된 번들이다. <code class=\"language-text\">chunkhash</code>, <code class=\"language-text\">hash</code>는 파일을 다시 번들링하면 해쉬값이 변경되므로 번들링된 파일의 이름이 달라지게 되고, 결과적으로 <code class=\"language-text\">MFS</code> 객체에 저장되어있던 이전 버전 번들은 교체되지 않고 남아있게 된다. 즉, 파일이 누적된다.</p>\n<p>이 객체 자체나, 파일 라인들을 담고 있는 배열, 라인들의 값을 가지고 있는 문자열 모두 당연히 메모리에 저장되고, <code class=\"language-text\">memory-fs</code>가 이 친구들을 계속 참조하고 있으니 결과적으로 Old Space로 넘어간 후에도 계속 GC에 수집되지 않았던 것이다.</p>\n<h2 id=\"해결-방법\" style=\"position:relative;\">해결 방법<a href=\"#%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" aria-label=\"해결 방법 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이 문제를 처음 접했을 때 3가지 정도의 해결 방법을 생각했었다.</p>\n<blockquote>\n<ol>\n<li>개발 환경일 때는 파일 이름 패턴에 <code class=\"language-text\">hash</code>나 <code class=\"language-text\">chunkhash</code>를 사용하지 않는다.</li>\n<li>Webpack의 compiler hook에서 이전 빌드의 번들을 직접 제거(<code class=\"language-text\">HotModuleReplacement</code>가 사용하는 방법임)</li>\n<li>그냥 Old Space를 늘려준다. <small>(자존심을 버린 최후의 방법)</small></li>\n</ol>\n</blockquote>\n<p>사실 1번 방법인 <code class=\"language-text\">파일 이름 패턴에서 chunkhash를 제거하기</code> 만으로도 해결되는 문제긴 하지만, 혹시 모르니 다음 차선책까지 생각해둔 것이다. 필자는 보통 이런 문제를 만나면 한번에 해결된다는 기대를 잘 안하는 편이다. <small>(높은 데서 떨어지면 더 아픈 법이다. 아예 기대를 말자)</small></p>\n<p>하지만 다행히도 1번 해결 방법으로 한 방에 해결이 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// webpack.client.config.js</span>\n<span class=\"token comment\">// ...</span>\n<span class=\"token keyword\">const</span> isLocal <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">===</span> <span class=\"token string\">'local'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span>\n \nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  output<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    filename<span class=\"token operator\">:</span> isLocal <span class=\"token operator\">?</span> <span class=\"token string\">'client-bundle.[name].js'</span> <span class=\"token operator\">:</span> <span class=\"token string\">'client-bundle.[chunkhash].js'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">Built at: <span class=\"token number\">2019</span>-08-06 <span class=\"token number\">10</span>:29:34\n                                                     Asset       Size       Chunks             Chunk Names\n                                      client-bundle.app.js   <span class=\"token number\">4.16</span> MiB          app  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  app\n                                  client-bundle.app.js.map   <span class=\"token number\">2.98</span> MiB          app  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  app\n                                     client-bundle.chat.js    <span class=\"token number\">815</span> KiB         chat  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  chat\n                                 client-bundle.chat.js.map    <span class=\"token number\">503</span> KiB         chat  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  chat\n                                client-bundle.chat~user.js    <span class=\"token number\">312</span> KiB    chat~user  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  chat~user\n                            client-bundle.chat~user.js.map    <span class=\"token number\">200</span> KiB    chat~user  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  chat~user\n                                 client-bundle.polyfill.js   <span class=\"token number\">6.24</span> KiB     polyfill  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  polyfill\n                             client-bundle.polyfill.js.map   <span class=\"token number\">6.23</span> KiB     polyfill  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  polyfill\n                                   client-bundle.search.js    <span class=\"token number\">254</span> KiB       search  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  search\n                               client-bundle.search.js.map    <span class=\"token number\">224</span> KiB       search  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  search\n                              client-bundle.style-guide.js    <span class=\"token number\">135</span> KiB  style-guide  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  style-guide\n                          client-bundle.style-guide.js.map    <span class=\"token number\">105</span> KiB  style-guide  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  style-guide\n                                     client-bundle.user.js    <span class=\"token number\">134</span> KiB         user  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  user\n                                 client-bundle.user.js.map   <span class=\"token number\">70.2</span> KiB         user  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  user\n                                   client-bundle.vendor.js    <span class=\"token number\">4.6</span> MiB       vendor  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  vendor\n                               client-bundle.vendor.js.map   <span class=\"token number\">5.25</span> MiB       vendor  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  vendor\n  fontawesome-webfont.eot?674f50d287a8c48dc19ba404d20fe713    <span class=\"token number\">162</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n  fontawesome-webfont.ttf?b06871f281fee6b241d60582ae9369b9    <span class=\"token number\">162</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\nfontawesome-webfont.woff2?af7ae505a9eed503f8b8e6982036873e   <span class=\"token number\">75.4</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n fontawesome-webfont.woff?fee66e712a8a08eef5805a46892932ad   <span class=\"token number\">95.7</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n                                                index.html  <span class=\"token number\">804</span> bytes               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n                                                     sw.js   <span class=\"token number\">4.79</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n                                                 sw.js.map    <span class=\"token number\">4.2</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n                              vue-ssr-client-manifest.json    <span class=\"token number\">108</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>파일 이름 패턴에서 <code class=\"language-text\">chunkhash</code>을 삭제하고 <code class=\"language-text\">name</code>을 추가했기 때문에 이제 몇 번을 빌드하든 <code class=\"language-text\">client-bundle.app.js</code>처럼 늘 같은 이름으로 번들이 생성될 것이다. 그리고 위에서 얘기했듯 <code class=\"language-text\">memory-fs</code>는 파일 이름을 맵의 키로 사용하기 때문에 새로운 파일을 맵에 저장할 때 그 파일과 같은 이름을 가진 이전 빌드의 번들은 자동으로 덮어씌워질 것이다.</p>\n<p>아래는 해당 작업을 수행한 후 다시 Heap 스냅샷 사용하여 분석해본 <code class=\"language-text\">Memory File System</code> 내 dist 객체의 크기이다.</p>\n<table>\n<thead>\n<tr>\n<th>빌드 횟수</th>\n<th>MFS의 메모리 사용량(byte)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>21,031,408</td>\n</tr>\n<tr>\n<td>2</td>\n<td>21,023,274</td>\n</tr>\n<tr>\n<td>3</td>\n<td>21,023,224</td>\n</tr>\n<tr>\n<td>4</td>\n<td>21,023,310</td>\n</tr>\n</tbody>\n</table>\n<p>이제 여러 번 빌드를 하더라도 <code class=\"language-text\">memory-fs</code>가 사용하는 메모리가 점점 증가하지 않게 되었고 프론트엔드 챕터 개발자들은 드디어 쾌적한 환경에서 개발을 계속 할 수 있게 되었다!</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이 이슈는 처음 이슈를 접했을 때 세운 가설이 딱 맞아들어가서 빠르게 해결할 수 있었던 케이스였다. 하지만 그 가설을 증명하는데는 거의 하루 종일 걸렸는데, 그 이유는 구글 크롬 인스펙터가 Heap 스냅샷을 한번 찍는데 시간이 너무 오래 걸려서이다. 아니 무슨 한번 찍는데 거의 3~4분이 걸려…</p>\n<p>막상 원인을 파악하고 가설도 증명하고나니 해결 방법은 굉장히 심플했는데, 뭔가 손 안대고 코 푼 느낌이랄까…? 뭐 어쨌든 쉽게 해결할 수 있어서 다행이었다.</p>\n<p>이상으로 Webpack Watch의 메모리 누수 고치기 포스팅을 마친다.</p>","tableOfContents":"<ul>\n<li><a href=\"#nodejs-%EC%9D%B8%EC%8A%A4%ED%8E%99%ED%84%B0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">NodeJS 인스펙터 사용하기</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EC%9B%90%EC%9D%B8\">메모리 누수 원인</a></li>\n<li><a href=\"#%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\">해결 방법</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","fields":{"lang":"ko"},"frontmatter":{"title":"Webpack Watch의 메모리 누수 고치기","date":"2019-08-08","categories":["Programming","Web"],"tags":["Webpack","JavaScript","NodeJS","webpack dev server","webpack dev middleware","memory-fs","MFS","Memory leak"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABFElEQVQoz41SXVOCQBT1f/dLmlHKmopsfBAnFzWVhW2NZDKVsqYXkAVhWGLqF3T0VYRmzsP52Dv3zr1bq/e8QpzpfnOwAUCOvakdWoruXY+CthlqPNL4tm1GkDCrixvEU8fi/immC8ncHcyFhFQnQiFVxZfDoDuNrZW0P3O2/gHsj5ytJExEZcW7thMxekmNZarPv1UmbywJAjmep4ga5HgxBmtRYS6l5WYqS0+aXwAIJExECintfGsI41WiVdfJTkkEaLMMEiaiss7A1UPQs2Psia9z+v4LgDy6EiaiioXhqi0a9p1k+pbxPUAGTnJHw8ODF9z5vO9jwg7fkueEzBIQSJj/+iT7zfkXww3mBEAgC5/9AUUI879UeYwRAAAAAElFTkSuQmCC","aspectRatio":1.7699115044247788,"src":"/static/089564f2795d80e2fcfd651cd02ef782/ee604/thumbnail.png","srcSet":"/static/089564f2795d80e2fcfd651cd02ef782/69585/thumbnail.png 200w,\n/static/089564f2795d80e2fcfd651cd02ef782/497c6/thumbnail.png 400w,\n/static/089564f2795d80e2fcfd651cd02ef782/ee604/thumbnail.png 800w,\n/static/089564f2795d80e2fcfd651cd02ef782/f3583/thumbnail.png 1200w,\n/static/089564f2795d80e2fcfd651cd02ef782/5707d/thumbnail.png 1600w,\n/static/089564f2795d80e2fcfd651cd02ef782/eeb1b/thumbnail.png 1920w","sizes":"(max-width: 800px) 100vw, 800px"}}}}},"allMarkdownRemark":{"edges":[]}},"pageContext":{"slug":"/20190808-fix-webpack-dev-memory-leak/","previous":{"fields":{"slug":"/20190806-developer-with-organizational-culture/","path":"/2019/08/06/developer-with-organizational-culture/","lang":"ko","postGroup":"20190806-developer-with-organizational-culture"},"frontmatter":{"title":"개발자가 조직문화에 대해 관심을 가져야 하는 이유"}},"next":{"fields":{"slug":"/20190811-average-filter/","path":"/2019/08/11/average-filter/","lang":"ko","postGroup":"20190811-average-filter"},"frontmatter":{"title":"실시간 데이터의 평균을 효율적으로 구하기"}},"lang":"ko","postGroup":"20190808-fix-webpack-dev-memory-leak"}}}