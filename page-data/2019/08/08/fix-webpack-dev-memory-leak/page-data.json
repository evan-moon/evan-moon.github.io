{"componentChunkName":"component---src-templates-post-page-template-index-tsx","path":"/2019/08/08/fix-webpack-dev-memory-leak/","result":{"data":{"markdownRemark":{"id":"5a935b2f-2abd-5a56-9823-d8d97799183a","tableOfContents":"<ul>\n<li><a href=\"#nodejs-%EC%9D%B8%EC%8A%A4%ED%8E%99%ED%84%B0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">NodeJS 인스펙터 사용하기</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EC%9B%90%EC%9D%B8\">메모리 누수 원인</a></li>\n<li><a href=\"#%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\">해결 방법</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","excerpt":"이번 포스팅에서는 최근에 고쳤던 Webpack Watch 기능의 메모리 누수에 대해서 간략하게 남겨보려고 한다. 필자가 회사에서 개발한 프로젝트가 점점 커짐에 따라서 Watch 중에 빌드를 여러 번 돌리게되면 어느 순간 갑자기 가 뜨면서 프로세스가 죽어버리는 이슈가 발생하였다. 이 문제는 사실 꽤 예전부터 발생했던 이슈지만 계속 비즈니스 이슈를 개발하느라고 외면받고 있던 이슈였는데 우연히 기회가 되어 해당 이슈를 자세히 들여다 볼 수 있었다. 사실 구글에 이라고 검색만 해봐도 같은 이슈로 고통받고 있는 전세계의 동지들이 많다는 것…","html":"<p>이번 포스팅에서는 최근에 고쳤던 Webpack Watch 기능의 메모리 누수에 대해서 간략하게 남겨보려고 한다. 필자가 회사에서 개발한 프로젝트가 점점 커짐에 따라서 Watch 중에 빌드를 여러 번 돌리게되면 어느 순간 갑자기 <code class=\"language-text\">out of memory</code>가 뜨면서 프로세스가 죽어버리는 이슈가 발생하였다. 이 문제는 사실 꽤 예전부터 발생했던 이슈지만 계속 비즈니스 이슈를 개발하느라고 외면받고 있던 이슈였는데 우연히 기회가 되어 해당 이슈를 자세히 들여다 볼 수 있었다.</p>\n<p>사실 구글에 <code class=\"language-text\">webpack watch memory leak</code>이라고 검색만 해봐도 같은 이슈로 고통받고 있는 전세계의 동지들이 많다는 것을 알 수 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/719ca011fe26513ab9402af9feb1e870/71ee9/out-of-memory.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACAklEQVR42n1U2ZKjMAzkN7ZmchAIN4Q73DBAMfP/P6R1yzEzSc3uQ5exLLfUkozmeAGFt4QcL6SLaT1BN66Mi3nd9+eL+cu5xfbDSSdtmGZaty/qhpGqpqXiXlPddlRWDSVZIfaV+K7FWUd5WdEtydknK+68V3eMq03vR0Fouz4BpuXQ8XxhnHRjB6K+H8+/4nA6C3999+EMozghiVRET/nbDyOyHI+utsNSlDQlGYF0Q9pfA2qoH9JP85LudctS73XD+zQvuL4IBPmQfksyitOMz2BTCmUCLmlwxmFWlEwM4BJscZqzk5L/LVVmpcqjVGDVkFE3TNSNE/UPYI8mSLS7Ai+IyA1CCqIbl8Z2PXL9gIneDicpGYRtP3CXx4+Z5nWjcV6o6Xq29+MHDZPEtKy8x1nd9pSKQJCN0bM9nwzLJg0ZSMKJL8Gx7UG+PC4P1IqzaV7ZDgUg+PN2eJKuwIQAMsQ89oJ02bZHpitnDazbJwcAMeSidj+HXXVca0RGy/pJpegsOoWaqM4Brh8Ku/9kwxBjbtEwwBRSsTJhnTZUlQOPDJx/Pid5wdkJLMfdiWAD8P3tK8amK3qKIzkmtsgEBLikSLC+vm81Rq+vimsYOwm5TkBZWT7ebs0DjLnEPAZRzJHl8Ep5kPYvaFUpHndRcafxU8AKEtRSyXh9Xv8j/AvgrcdZKPOTrQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"out of memory\" title=\"\" src=\"/static/719ca011fe26513ab9402af9feb1e870/6af66/out-of-memory.png\" srcset=\"/static/719ca011fe26513ab9402af9feb1e870/69538/out-of-memory.png 160w,\n/static/719ca011fe26513ab9402af9feb1e870/72799/out-of-memory.png 320w,\n/static/719ca011fe26513ab9402af9feb1e870/6af66/out-of-memory.png 640w,\n/static/719ca011fe26513ab9402af9feb1e870/d9199/out-of-memory.png 960w,\n/static/719ca011fe26513ab9402af9feb1e870/71ee9/out-of-memory.png 1081w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Webpack을 사용하다보면 자주 볼 수 있는 슬픈 화면</small>\n</center>\n<p>일단 이 문제의 가장 유명한 해결 방법은 바로 NodeJS의 <code class=\"language-text\">--max-old-space-size</code>을 사용하여 Old Space의 영역을 늘리는 것이다. 원래 Old Space의 기본 크기는 64비트 기준 1.4GB 정도이지만 이렇게 메모리가 터지는 경우 Old Space에 4GB나 8GB를 할당할 것을 권장하는 해결 방법이 많다.</p>\n<p>사실 이 방법을 사용하면 왠만큼 해결은 된다. 메모리 누수는 일반적으로 GC(가비지 컬렉팅) 때 수집되어야 할 쓰레기가 제대로 수집되지 않아서 발생하는 경우가 대부분인데, 이때 수집되지않은 쓰레기 객체들은 모두 Old Space에 있기 때문이다. 하지만 이 방법은 근본적인 해결 방법이 아니라 그냥 메모리가 터지는 시점을 좀 더 늦춘 것 뿐이다.</p>\n<blockquote>\n<p>Old Space에 4GB를 할당해주고 20번 빌드했더니 메모리가 터져서 Old Space에 8GB를 할당했다? 그레봤자 약 40번 정도 빌드하면 언젠간 또 터진다.</p>\n</blockquote>\n<p>그렇다고 이렇게 해결하는 것이 틀린 방법인 건 아니다. 필자도 사실 이미 <code class=\"language-text\">--max-old-space-size=4096</code> 옵션을 통해 Old Space에 4GB 정도를 할당해주고 있었다. 하지만 이건 마치 뭐랄까, 진통제 같은 느낌이지 근본적인 치료는 아니기 때문에 이번 기회에 필자는 이 이슈의 원인을 찾아내어 제대로 고쳐보고 싶었다.</p>\n<h2 id=\"nodejs-인스펙터-사용하기\" style=\"position:relative;\">NodeJS 인스펙터 사용하기<a href=\"#nodejs-%EC%9D%B8%EC%8A%A4%ED%8E%99%ED%84%B0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"nodejs 인스펙터 사용하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>먼저, 이런 메모리 누수가 고치기 까다로운 이유는 원인 추적이 힘들기 때문이다. 예를 들어 <code class=\"language-text\">TypeError</code>같은 경우는 로그에 아주 명확하게 어디서, 왜 타입에러가 발생했는지 알려주지만 메모리 누수는 그딴 거 없다.</p>\n<p>그냥 쭉쭉 잘 실행되고 있는 듯 보이다가 어느 순간 픽! <code class=\"language-text\">out of memory</code>를 남기고 프로그램이 죽어버리기 때문이다. 프로그램이 죽으면서 마지막 힘을 짜내어 몇 줄의 Stack Trace를 남겨주긴 하지만, 표면적인 원인만 보여주는 느낌이기 때문에 메모리 누수를 고칠 때는 별 도움이 안되었던 것 같다.</p>\n<p>그래서 이런 메모리 누수를 고칠 때는 가장 먼저, 자바스크립트의 Heap을 뜯어봐야한다. 프로그램 내에서 어떤 놈이 메모리를 점점 갉아먹고 있는 지 부터 파악하는 것이다. NodeJS를 실행시킬 때 몇가지 옵션을 사용하면 구글 크롬(Chrome)의 개발자 도구를 사용하여 Heap의 스냅샷을 찍을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">node</span> <span class=\"token parameter variable\">--inspect</span> --inspect-brk server</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 556px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f8fc7cade4bf23104fdd937cddf97b42/96638/inspector.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB1ElEQVR42q2Ry5KaUBCGeYHJ1nUUUOQihdzvIAKCY6Uqr5Gss82b/+nu6Iw6U5VNFl3N+c/fX/dplP54RFVVmE4TsjzD959nNEONOIwxDAOmaZI8jiPSNEVZlvLd9z1OpxP2ex+LxQKmuYVhGFCiukaSJGjqBp6/x/yjQ1D4cJ0daSWO1LBtWxwOB3ieR4C9nDk6unNsC19eXghoSii/qGsSBBioa0A5CVKMNJFHE26TA3zfl6l2ux2KohCw7wekVWibGrswheXHsC0Ltm1D+Z3nSKjo9XJBFEVSfHk9EzCBU01I4hhd1yEMQwHO84wsy5BTXdtUMF0PVlwjIEZIAykOGV3XxWazkZF5D7quY7vdwjQ2km/BE/CTszTDQDs/DiOm+Uxr6XG+fMNImhIRkHezXq8FpOuawPm8vmbWNU2ThkHg00tigXX9SKsiMOWOoBzKarUSM0OyvERFP4cL/8J1WLSbujkgL0rR2atpKvnXpFWI4kR8y+VXMEuAqqrKwTD4Wc7VsMStmWVaBLZFV69+nSZnLwe/hDX2vgEFyhAKvrhpHPfwD/qT/wF46/JcqKra2x4f9Y/+T4HytH8U3se9X7kB7uP9jz9qn+nPfuW++/+IP7o1kh1aOCtnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"inspector\" title=\"\" src=\"/static/f8fc7cade4bf23104fdd937cddf97b42/96638/inspector.png\" srcset=\"/static/f8fc7cade4bf23104fdd937cddf97b42/69538/inspector.png 160w,\n/static/f8fc7cade4bf23104fdd937cddf97b42/72799/inspector.png 320w,\n/static/f8fc7cade4bf23104fdd937cddf97b42/96638/inspector.png 556w\" sizes=\"(max-width: 556px) 100vw, 556px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p><code class=\"language-text\">--inspect</code> 옵션을 사용하여 어플리케이션을 시작하고나서 구글 크롬의 아무 창이나 선택한 후 개발자 도구를 켜보면 왼쪽 구석에 NodeJS의 아이콘이 생긴 것을 확인할 수 있다. 그 아이콘을 누르면 NodeJS를 프로파일링할 수 있는 새로운 인스펙터가 나타난다. 그리고 <code class=\"language-text\">--inspect-brk</code> 옵션은 코드를 실행하기 전 Debug Pause 기능을 이용하여 실행을 멈춰준다. 개발자가 직접 Resume 버튼을 눌러주면 코드가 실행된다.</p>\n<h2 id=\"메모리-누수-원인\" style=\"position:relative;\">메모리 누수 원인<a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EC%9B%90%EC%9D%B8\" aria-label=\"메모리 누수 원인 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자도 맨 처음에 했던 일이 바로 NodeJS의 인스펙터를 사용하여 Heap 스냅샷을 찍어보는 것이었다. 사실 필자는 이 이슈가 일반적인 메모리 누수 상황과는 조금 다르다고 생각했는데, 보통 일반적인 메모리 누수는 대략 이런 시나리오로 그려진다.</p>\n<blockquote>\n<ol>\n<li>객체를 생성!</li>\n<li>객체 참조를 해제함!</li>\n<li>근데 GC가 안됨…? 뭐지…?</li>\n<li>알고 보니 다른 놈이 참조를 하고 있었다는 결말</li>\n</ol>\n</blockquote>\n<p>그렇기 때문에 보통 메모리 누수는 “어떤 놈이 해제되어야 할 객체를 참조하고 있는거지?”로 시작하는 경우가 많다. 그래서 보통 객체 할당을 하고 한번 Heap 스냅샷을 찍고, 다시 객체 참조를 해제한 다음 다시 Heap 스냅샷을 찍은 후 그 두 스냅샷을 비교하는 방법으로 디버깅을 진행한다. 분명히 나는 참조를 해제했는데 뭔가 아직도 유지되고 있는 놈이 보인다? 바로 그 놈이 범인일 가능성이 높다. 이 범인 색출이 오지게 힘들긴 하지만…</p>\n<p>하지만 Webpack의 메모리 누수 이슈는 이런 복잡한 이슈는 아닌 것 같았다. Stack Overflow에서 다른 사람들의 사례를 보면 프로젝트가 작을 때는 별 문제 없다가 프로젝트가 커질수록 이런 문제가 발생한다는 사례가 많았고, 필자 또한 그런 상황이었기 때문에 처음부터 방향은 “혹시 빌드할 때마다 파일이 계속 누적되고 있나?”라는 가설로 잡았기 때문이다.</p>\n<p>그래서 가설을 확인하기 위해 일단 빌드를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>번 진행한 후, 메모리 사용량의 변화를 살펴보기 위해 매 빌드마다 Heap 스냅샷을 찍었고, 그 결과 <code class=\"language-text\">Memory File System</code> 이라는 놈이 점점 비대해지고 있는 것을 발견했다.</p>\n<table>\n<thead>\n<tr>\n<th>빌드 횟수</th>\n<th>MFS의 메모리 사용량(byte)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>21,034,701</td>\n</tr>\n<tr>\n<td>2</td>\n<td>38,776,735</td>\n</tr>\n<tr>\n<td>3</td>\n<td>45,209,592</td>\n</tr>\n<tr>\n<td>4</td>\n<td>51,642,543</td>\n</tr>\n<tr>\n<td>7</td>\n<td>83,807,008</td>\n</tr>\n<tr>\n<td>10</td>\n<td>122,404,490</td>\n</tr>\n<tr>\n<td>13</td>\n<td>180,301,478</td>\n</tr>\n</tbody>\n</table>\n<p>여기까지 확인한 후 <code class=\"language-text\">Memory File System</code> 객체의 내부를 한번 까봤더니 예상한 대로 번들링했던 모든 파일이 계속 누적되고 있는 것을 확인할 수 있었다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/bc66d327ef24fa7aa752904a24cc3a4a/2e367/mfs.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 130.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAABYlAAAWJQFJUiTwAAADAUlEQVR42o1V25baMAzkU8q1CcSxc4PcDAmw29PT//8eVSPb2bAL7T7oGAIMM5qRvGiODf3u/tDQjHQf3+lqb2T7M10uAzWnhtqmpbquqSzKqYqioLIsvxSeL5arJRVJSVadyewz6ipLWmuq6iOlOqUojmj3c0v43mq9lHO9XtNy+YOLn61WU+H5YrPZ0Ga7pjwpqFYNdZmlJm3JpsxSj9Qnli7pQG3S0enATPcVHVRCTdfT8VSTMZkwi+P4ERAs8eNWdfJjgF3NnQY+b3z2rACAlTpSwfLa3gpgnuei6BPgRgA7Zbl6ATynF7rqmwADEO91ZCg1miz391Q3lGWO3X6/F8nAmgEWAgSGTdIysysNKWoUyWhBFmfcV0MdmwZAsEMBEOweARVL9gy7pBe5o7mK5JHB8RkANQP29szOtxNgkiRPAA+Fk8sMcUIipF708CAZgB0DnjhOkPwaMEiWaqV3YNez1JF7iTKxEcliiO8hAA+Hw1fAUrksoldgGZjBmJt5k/ci2bDk84WathPAsiyeM8xnptRJIycA0T/pIf+REVM0m2Inl18ydLHppeAyQGEKHIb0M58mMpPLte8h6rnLHhDM4ChMwDmEXvJrM3N5nsPnDL3LnZ+UORgkg2kADDnMWO5LhmXictj7HILhXcwYJeQAzOKcJ8WZAsnoH7bMv2OjXA3eDACjwDTEprMfk1JV1SvAR1MGvxzu2buAY85hCmIzBwRDpdRzyQEQJX0Tdy9u6/BM60hPORSX/8cwSAYbgIWlgF46yR/L4XgCw+J1D8tPy8GN21XA3rJf8tyESbFzU745KRg1Z4gbwdYDYlJaHxsjOXy1HOYM/SxDLgyBMWEfhm0TJgXB/pbLltlBNhhCMv7AfN7YeTaZ8nRjB0DZNukogOFeAftTwnfK4eii4xdE7qcliqKvd8o82ABzE+ImBZ+BOS4qxderjJ+Pznz8Frvdju/dHZVpxSuKeyjVy6a5ZrypNY9g/iZnoxhQ1aQzn0XeiWCIPiLc2+2W/gL8njeHrKhC/QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"mfs\" title=\"\" src=\"/static/bc66d327ef24fa7aa752904a24cc3a4a/6af66/mfs.png\" srcset=\"/static/bc66d327ef24fa7aa752904a24cc3a4a/69538/mfs.png 160w,\n/static/bc66d327ef24fa7aa752904a24cc3a4a/72799/mfs.png 320w,\n/static/bc66d327ef24fa7aa752904a24cc3a4a/6af66/mfs.png 640w,\n/static/bc66d327ef24fa7aa752904a24cc3a4a/d9199/mfs.png 960w,\n/static/bc66d327ef24fa7aa752904a24cc3a4a/2e367/mfs.png 1066w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>징글징글한 것들...</small>\n</center>\n<p>왜 이런 문제가 발생했을까? 그 이유는 해당 프로젝트의 Webpack 세팅의 번들 파일 이름 패턴이 <code class=\"language-text\">client-bundle.[chunkhash].js</code>로 되어있었기 때문이다. <code class=\"language-text\">chunkhash</code>나 <code class=\"language-text\">hash</code> 옵션은 매 번들링 때 새로운 파일명을 만들어주므로 운영환경에서 발생하는 파일 캐싱 이슈에 대해서 자유롭게 해준다. 하지만 개발 환경에서는 이 옵션이 오히려 독이 된 것이다.</p>\n<p>Webpack은 개발 서버를 띄울 때 번들링된 파일을 <code class=\"language-text\">memory-fs</code>라는 라이브러리를 사용하여 저장한다. 이 라이브러리는 그냥 내부적으로 맵(Map)을 가지고 있고 파일 내용은 파일의 각 라인을 원소로 가지고 있는 배열이다. 즉 번들링된 파일 이름이 <code class=\"language-text\">main.js</code>이면 다음과 같은 구조를 가진 객체가 생성된다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">MFS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">'main.js'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'var a = 1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'console.log(a)'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>만약 필자가 <code class=\"language-text\">main.js</code> 파일이나 여기서 종속된 모듈을 수정하면 <code class=\"language-text\">main.js</code>는 다시 번들링 될 것이고 <code class=\"language-text\">MFS</code> 객체의 <code class=\"language-text\">main.js</code>키의 값을 새로 번들링된 파일의 내용으로 변경할 것이다. 그러나 문제는 <code class=\"language-text\">chunkhash</code>나 <code class=\"language-text\">hash</code>와 같이 빌드 때마다 파일 이름이 변경되는 경우에 생긴다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">MFS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">'main.1111.js'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'var a = 1'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 기존 파일</span>\n  <span class=\"token string-property property\">'main.2222.js'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'var a = 2'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 새로 번들링된 파일</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">main.1111.js</code>는 이전 빌드 때 생성된 번들이고 <code class=\"language-text\">main.2222.js</code>는 이번 빌드 때 생성된 번들이다. <code class=\"language-text\">chunkhash</code>, <code class=\"language-text\">hash</code>는 파일을 다시 번들링하면 해쉬값이 변경되므로 번들링된 파일의 이름이 달라지게 되고, 결과적으로 <code class=\"language-text\">MFS</code> 객체에 저장되어있던 이전 버전 번들은 교체되지 않고 남아있게 된다. 즉, 파일이 누적된다.</p>\n<p>이 객체 자체나, 파일 라인들을 담고 있는 배열, 라인들의 값을 가지고 있는 문자열 모두 당연히 메모리에 저장되고, <code class=\"language-text\">memory-fs</code>가 이 친구들을 계속 참조하고 있으니 결과적으로 Old Space로 넘어간 후에도 계속 GC에 수집되지 않았던 것이다.</p>\n<h2 id=\"해결-방법\" style=\"position:relative;\">해결 방법<a href=\"#%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" aria-label=\"해결 방법 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이 문제를 처음 접했을 때 3가지 정도의 해결 방법을 생각했었다.</p>\n<blockquote>\n<ol>\n<li>개발 환경일 때는 파일 이름 패턴에 <code class=\"language-text\">hash</code>나 <code class=\"language-text\">chunkhash</code>를 사용하지 않는다.</li>\n<li>Webpack의 compiler hook에서 이전 빌드의 번들을 직접 제거(<code class=\"language-text\">HotModuleReplacement</code>가 사용하는 방법임)</li>\n<li>그냥 Old Space를 늘려준다. <small>(자존심을 버린 최후의 방법)</small></li>\n</ol>\n</blockquote>\n<p>사실 1번 방법인 파일 이름 패턴에서 chunkhash를 제거하는 것만으로도 해결되는 문제긴 하지만, 혹시 모르니 다음 차선책까지 생각해둔 것이다. 필자는 보통 이런 문제를 만나면 한번에 해결된다는 기대를 잘 안하는 편이다. <small>(높은 데서 떨어지면 더 아픈 법이다. 아예 기대를 말자)</small></p>\n<p>하지만 다행히도 1번 해결 방법으로 한 방에 해결이 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// webpack.client.config.js</span>\n<span class=\"token comment\">// ...</span>\n<span class=\"token keyword\">const</span> isLocal <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">===</span> <span class=\"token string\">'local'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span>\n \nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">output</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">filename</span><span class=\"token operator\">:</span> isLocal <span class=\"token operator\">?</span> <span class=\"token string\">'client-bundle.[name].js'</span> <span class=\"token operator\">:</span> <span class=\"token string\">'client-bundle.[chunkhash].js'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">Built at: <span class=\"token number\">2019</span>-08-06 <span class=\"token number\">10</span>:29:34\n                                                     Asset       Size       Chunks             Chunk Names\n                                      client-bundle.app.js   <span class=\"token number\">4.16</span> MiB          app  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  app\n                                  client-bundle.app.js.map   <span class=\"token number\">2.98</span> MiB          app  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  app\n                                     client-bundle.chat.js    <span class=\"token number\">815</span> KiB         chat  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  chat\n                                 client-bundle.chat.js.map    <span class=\"token number\">503</span> KiB         chat  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  chat\n                                client-bundle.chat~user.js    <span class=\"token number\">312</span> KiB    chat~user  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  chat~user\n                            client-bundle.chat~user.js.map    <span class=\"token number\">200</span> KiB    chat~user  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  chat~user\n                                 client-bundle.polyfill.js   <span class=\"token number\">6.24</span> KiB     polyfill  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  polyfill\n                             client-bundle.polyfill.js.map   <span class=\"token number\">6.23</span> KiB     polyfill  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  polyfill\n                                   client-bundle.search.js    <span class=\"token number\">254</span> KiB       search  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  search\n                               client-bundle.search.js.map    <span class=\"token number\">224</span> KiB       search  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  search\n                              client-bundle.style-guide.js    <span class=\"token number\">135</span> KiB  style-guide  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  style-guide\n                          client-bundle.style-guide.js.map    <span class=\"token number\">105</span> KiB  style-guide  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  style-guide\n                                     client-bundle.user.js    <span class=\"token number\">134</span> KiB         user  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  user\n                                 client-bundle.user.js.map   <span class=\"token number\">70.2</span> KiB         user  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  user\n                                   client-bundle.vendor.js    <span class=\"token number\">4.6</span> MiB       vendor  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  vendor\n                               client-bundle.vendor.js.map   <span class=\"token number\">5.25</span> MiB       vendor  <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>  vendor\n  fontawesome-webfont.eot?674f50d287a8c48dc19ba404d20fe713    <span class=\"token number\">162</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n  fontawesome-webfont.ttf?b06871f281fee6b241d60582ae9369b9    <span class=\"token number\">162</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\nfontawesome-webfont.woff2?af7ae505a9eed503f8b8e6982036873e   <span class=\"token number\">75.4</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n fontawesome-webfont.woff?fee66e712a8a08eef5805a46892932ad   <span class=\"token number\">95.7</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n                                                index.html  <span class=\"token number\">804</span> bytes               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n                                                     sw.js   <span class=\"token number\">4.79</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n                                                 sw.js.map    <span class=\"token number\">4.2</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span>\n                              vue-ssr-client-manifest.json    <span class=\"token number\">108</span> KiB               <span class=\"token punctuation\">[</span>emitted<span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>파일 이름 패턴에서 <code class=\"language-text\">chunkhash</code>을 삭제하고 <code class=\"language-text\">name</code>을 추가했기 때문에 이제 몇 번을 빌드하든 <code class=\"language-text\">client-bundle.app.js</code>처럼 늘 같은 이름으로 번들이 생성될 것이다. 그리고 위에서 얘기했듯 <code class=\"language-text\">memory-fs</code>는 파일 이름을 맵의 키로 사용하기 때문에 새로운 파일을 맵에 저장할 때 그 파일과 같은 이름을 가진 이전 빌드의 번들은 자동으로 덮어씌워질 것이다.</p>\n<p>아래는 해당 작업을 수행한 후 다시 Heap 스냅샷 사용하여 분석해본 <code class=\"language-text\">Memory File System</code> 내 dist 객체의 크기이다.</p>\n<table>\n<thead>\n<tr>\n<th>빌드 횟수</th>\n<th>MFS의 메모리 사용량(byte)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>21,031,408</td>\n</tr>\n<tr>\n<td>2</td>\n<td>21,023,274</td>\n</tr>\n<tr>\n<td>3</td>\n<td>21,023,224</td>\n</tr>\n<tr>\n<td>4</td>\n<td>21,023,310</td>\n</tr>\n</tbody>\n</table>\n<p>이제 여러 번 빌드를 하더라도 <code class=\"language-text\">memory-fs</code>가 사용하는 메모리가 점점 증가하지 않게 되었고 프론트엔드 챕터 개발자들은 드디어 쾌적한 환경에서 개발을 계속 할 수 있게 되었다!</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이 이슈는 처음 이슈를 접했을 때 세운 가설이 딱 맞아들어가서 빠르게 해결할 수 있었던 케이스였다. 하지만 그 가설을 증명하는데는 거의 하루 종일 걸렸는데, 그 이유는 구글 크롬 인스펙터가 Heap 스냅샷을 한번 찍는데 시간이 너무 오래 걸려서이다. 아니 무슨 한번 찍는데 거의 3-4분이 걸려…</p>\n<p>막상 원인을 파악하고 가설도 증명하고나니 해결 방법은 굉장히 심플했는데, 뭔가 손 안대고 코 푼 느낌이랄까…? 뭐 어쨌든 쉽게 해결할 수 있어서 다행이었다.</p>\n<p>이상으로 Webpack Watch의 메모리 누수 고치기 포스팅을 마친다.</p>","fields":{"slug":"20190808-fix-webpack-dev-memory-leak","path":"/2019/08/08/fix-webpack-dev-memory-leak/","lang":"ko"},"frontmatter":{"title":"Webpack Watch의 메모리 누수 고치기","subTitle":"메모리 누수를 추적하는 방법 – Chrome DevTools와 Heap Snapshot 활용","date":"Aug 08, 2019","categories":["프로그래밍","웹"],"tags":["Webpack","웹팩","JavaScript","자바스크립트","NodeJS","webpack dev server","webpack dev middleware","memory-fs","MFS","Memory leak","메모리 누수","Out of memory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#98b8d8","images":{"fallback":{"src":"/static/089564f2795d80e2fcfd651cd02ef782/d803c/thumbnail.png","srcSet":"/static/089564f2795d80e2fcfd651cd02ef782/8c230/thumbnail.png 80w,\n/static/089564f2795d80e2fcfd651cd02ef782/23e25/thumbnail.png 160w,\n/static/089564f2795d80e2fcfd651cd02ef782/d803c/thumbnail.png 320w,\n/static/089564f2795d80e2fcfd651cd02ef782/ed377/thumbnail.png 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/089564f2795d80e2fcfd651cd02ef782/3e5ca/thumbnail.webp 80w,\n/static/089564f2795d80e2fcfd651cd02ef782/b72f1/thumbnail.webp 160w,\n/static/089564f2795d80e2fcfd651cd02ef782/fc5c5/thumbnail.webp 320w,\n/static/089564f2795d80e2fcfd651cd02ef782/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#98b8d8","images":{"fallback":{"src":"/static/089564f2795d80e2fcfd651cd02ef782/3fbb4/thumbnail.png","srcSet":"/static/089564f2795d80e2fcfd651cd02ef782/61846/thumbnail.png 750w,\n/static/089564f2795d80e2fcfd651cd02ef782/d5395/thumbnail.png 1080w,\n/static/089564f2795d80e2fcfd651cd02ef782/cc835/thumbnail.png 1366w,\n/static/089564f2795d80e2fcfd651cd02ef782/3fbb4/thumbnail.png 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/089564f2795d80e2fcfd651cd02ef782/6858b/thumbnail.webp 750w,\n/static/089564f2795d80e2fcfd651cd02ef782/f5547/thumbnail.webp 1080w,\n/static/089564f2795d80e2fcfd651cd02ef782/29310/thumbnail.webp 1366w,\n/static/089564f2795d80e2fcfd651cd02ef782/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}},"allMarkdownRemark":{"edges":[]}},"pageContext":{"slug":"20190808-fix-webpack-dev-memory-leak","previous":{"fields":{"slug":"20190806-developer-with-organizational-culture","path":"/2019/08/06/developer-with-organizational-culture/","lang":"ko","postGroup":"20190806-developer-with-organizational-culture"},"frontmatter":{"title":"개발자가 조직문화에 대해 관심을 가져야 하는 이유"}},"next":{"fields":{"slug":"20190811-average-filter","path":"/2019/08/11/average-filter/","lang":"ko","postGroup":"20190811-average-filter"},"frontmatter":{"title":"실시간 데이터의 평균을 효율적으로 구하기"}},"lang":"ko","postGroup":"20190808-fix-webpack-dev-memory-leak"}},"staticQueryHashes":["3129619726","3523904809","376081736","650499039"],"slicesMap":{}}