{"componentChunkName":"component---src-templates-post-tsx","path":"/2018/09/25/universal-ssr/","result":{"data":{"markdownRemark":{"id":"a98c0774-470f-54f8-8a14-8bd3f642a960","excerpt":"이번 포스팅에서는 최근 모던 웹 어플리케이션에서 많이 사용하고 있는 에 대해서 설명하고자 한다. 과 의 방식을 간단하게 알아보고 이 두 렌더 방식을 조합한 의 방식을 설명한다.","html":"<p>이번 포스팅에서는 최근 모던 웹 어플리케이션에서 많이 사용하고 있는 <code class=\"language-text\">Universal SSR</code>에 대해서 설명하고자 한다. <code class=\"language-text\">Server Side Rendering</code>과 <code class=\"language-text\">Single Page Application</code>의 방식을 간단하게 알아보고 이 두 렌더 방식을 조합한 <code class=\"language-text\">Universal SSR</code>의 방식을 설명한다.</p>\n<!-- more -->\n<h2 id=\"server-side-rendering을-수행하는-multi-page-application\" style=\"position:relative;\">Server Side Rendering을 수행하는 Multi Page Application<a href=\"#server-side-rendering%EC%9D%84-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-multi-page-application\" aria-label=\"server side rendering을 수행하는 multi page application permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">SSR</code> 방식은 원래 전통적인 웹 어플리케이션에서 사용하던 방식이다. 최근에는 <code class=\"language-text\">SPA(Single Page Application)</code>과 대조하여 <code class=\"language-text\">MPA(Multi Page Application)</code>이라고도 불린다. <code class=\"language-text\">SSR</code> 어플리케이션은 라우팅이 수행된 후 새로운 페이지가 서버에 요청되면 싶으면 그때마다 HTML를 렌더한 후 클라이언트에서 전체 페이지를 다시 내려받는다.</p>\n<p>대략적인 실행 순서는 다음과 같다.</p>\n<center><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9052926c04e0b91148f091f6238be6c8/86a1e/ssr.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 61.875%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/0lEQVQoz42T6QqEMAyEff8nFPSnF9544G2WrxDpVvcIDCk1mUya6NV1LUEQSBiG0ratnOd54ZcdxyFN04jv+4aDszdNk1RVZcjmeb4lbNsm+76/QYvhyUEUgMvjA0EkgnVdZVkWc6ZQmqYSx7FkWSZJkkgURTIMg8khlqIQaRFDqAR8tKGtu/cQoYw8wJm7i1Ar/WPEobwoCinL0ngUQ/xIaA/lE56K0OFHwiezyRggb5rnuVHYdd13ha531dnvylkH+lfLrhGLIlTiAW94G8q3Vu0JowSSvu8NEX4cx3dCxq6Xugr2LrKHgB0kTol16cm/tax/gItfe6lvSD72AmXprgFdZA8BAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ssr\" title=\"ssr\" src=\"/static/9052926c04e0b91148f091f6238be6c8/6af66/ssr.png\" srcset=\"/static/9052926c04e0b91148f091f6238be6c8/69538/ssr.png 160w,\n/static/9052926c04e0b91148f091f6238be6c8/72799/ssr.png 320w,\n/static/9052926c04e0b91148f091f6238be6c8/6af66/ssr.png 640w,\n/static/9052926c04e0b91148f091f6238be6c8/d9199/ssr.png 960w,\n/static/9052926c04e0b91148f091f6238be6c8/21b4d/ssr.png 1280w,\n/static/9052926c04e0b91148f091f6238be6c8/86a1e/ssr.png 1296w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span></center>\n<hr>\n<ol>\n<li>클라이언트가 서버에 <code class=\"language-text\">example.com/products/12</code> URL로 요청을 보낸다.</li>\n<li>서버에서는 해당 URL과 연결되어있는 메소드가 실행되고 알맞는 <code class=\"language-text\">HTML Template</code>파일을 찾는다.</li>\n<li>Database에서 12번 상품의 데이터를 가져온다.</li>\n<li>가져온 데이터와 <code class=\"language-text\">HTML Template</code>을 사용해 최종 <code class=\"language-text\">HTML</code>을 렌더한다.</li>\n<li>클라이언트로 <code class=\"language-text\">HTML</code>을 내려준다.</li>\n<li>최종적으로 사용자가 뷰를 본다.</li>\n</ol>\n<hr>\n<p>사용자가 렌더된 페이지를 본 이후에도 <code class=\"language-text\">Ajax</code>를 사용하여 데이터를 추가로 더 받아올 수도 있겠지만 일단 사용자가 완성된 페이지를 보는 시점은 6번 과정이 끝난 이후기 때문에 <code class=\"language-text\">Ajax</code>와 같은 예외는 생략했다.</p>\n<p>또한 2번 과정에서 어째서 이 방식의 어플리케이션이 <code class=\"language-text\">MPA</code>라고 불리는 지 알 수 있는데, 각 페이지에 매칭된 <code class=\"language-text\">HTML Template</code>이 따로 존재하기 때문이다.\n다음과 같은 방식의 장단점은 다음과 같다.</p>\n<h4 id=\"장점\" style=\"position:relative;\">장점<a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>서버에서 완성된 <code class=\"language-text\">HTML</code>을 내려주기 때문에 <code class=\"language-text\">SEO(Search Engine Optimization)</code>에 최적화되어 있다.</li>\n<li>매 페이지에서 필요한 리소스만 로딩하기 때문에 초기 로딩속도를 최적화할 수 있다.</li>\n</ul>\n<h4 id=\"단점\" style=\"position:relative;\">단점<a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>매 페이지 로딩 시마다 새로운 리소스를 요청해야하므로 전체적인 트래픽이 증가한다.</li>\n<li>페이지 이동 시 마다 새로고침이 되며 전체 페이지를 다시 렌더하므로 로딩 시간이 길어진다.</li>\n</ul>\n<h2 id=\"client-side-rendering을-수행하는-single-page-application\" style=\"position:relative;\">Client Side Rendering을 수행하는 Single Page Application<a href=\"#client-side-rendering%EC%9D%84-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-single-page-application\" aria-label=\"client side rendering을 수행하는 single page application permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>최근 들어 많은 수의 Frontend 개발자가 <code class=\"language-text\">Client Side Rendering</code>을 수행하는 A.K.A <code class=\"language-text\">SPA(Single Page Application)</code>를 개발한다. 즉, 서버에서 실제로 다운로드 받는 페이지는 단 1개이고 그 이후 JavaScript를 통해 동적인 렌더링을 실시하는 어플리케이션을 의미한다.</p>\n<p>대략적인 실행 순서는 다음과 같다.</p>\n<center><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f7c73717983bb1dd64d902e6c3334943/01a87/csr.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 78.125%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABTUlEQVQ4y5WU2w6CMBBE+f/P84nw4guiQlC8oHJdc5pMUy5qbDIp2263M7tbojiOLUkSO51ONo6jx7eh/bqubbvd2mazsSzL7PF4WFSWpV0uF2uaZnJoGAbrum4B1jWwb7ebFUXhgmNHfd97Z4ICvs/ns7sVHA4H2+/3ttvtDAJt23q/1+vloBGxQdBQriTBBmd8mMUu9OOsAmJHGGjnNm4WsFmHGZJgueYHJgFDmSG4mfXr9epyDDgYpkhYMAQYSAI6BCOYHY9HN5N49kIVqww5iDPz/X5fVPzXkL9niByqV1WVmwn+z4ClD4gR9paqm+e5a5k0TV1h9M26OkPyn8/nsijzymldOVb7hAVUy0wCiu4/+aJAMAWkSynyDD+1A2vklADM8pmrWUj+FBDgzHul+mv7q33Iuw1l/PrbfG0bSdPbpMLzd/0LxFDAN+vr5M+L+16QAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"csr\" title=\"csr\" src=\"/static/f7c73717983bb1dd64d902e6c3334943/6af66/csr.png\" srcset=\"/static/f7c73717983bb1dd64d902e6c3334943/69538/csr.png 160w,\n/static/f7c73717983bb1dd64d902e6c3334943/72799/csr.png 320w,\n/static/f7c73717983bb1dd64d902e6c3334943/6af66/csr.png 640w,\n/static/f7c73717983bb1dd64d902e6c3334943/d9199/csr.png 960w,\n/static/f7c73717983bb1dd64d902e6c3334943/21b4d/csr.png 1280w,\n/static/f7c73717983bb1dd64d902e6c3334943/01a87/csr.png 1288w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span></center>\n<hr>\n<ol>\n<li>클라이언트가 서버에 <code class=\"language-text\">example.com/products/12</code> URL로 요청을 보낸다.</li>\n<li>서버에서는 뭐가 됐던 요청 URL이 <code class=\"language-text\">exmplate.com</code>으로 시작하면 <code class=\"language-text\">index.html</code>을 찾아서 내려준다.</li>\n<li>그리고 추가로 <code class=\"language-text\">JavaScript Bundle</code>을 같이 내려준다. 예를 들면 <code class=\"language-text\">Webpack</code>같은 모듈러로 빌드하면 나오는 <code class=\"language-text\">bundle.js</code>같은 파일이 되겠다.</li>\n<li><code class=\"language-text\">bundle.js</code>을 실행한 클라이언트가 <code class=\"language-text\">api.example.com/products/12</code> API를 사용하여 12번 상품의 데이터를 서버에 요청한다.</li>\n<li>서버는 Database에서 12번 상품의 데이터를 가져온 후 클라이언트에 데이터를 내려준다.</li>\n<li>클라이언트는 받아온 데이터를 사용하여 뷰가 렌더한다.</li>\n<li>최종적으로 사용자가 뷰를 본다.</li>\n</ol>\n<hr>\n<p>아까에 비해서 뭔가 복잡해졌다. 이 방식이 <code class=\"language-text\">SPA</code>인 이유는 2번 과정에 있다. 보통 <code class=\"language-text\">Nginx</code>나 <code class=\"language-text\">Apache</code>같은 서버 엔진의 설정에 해당 url을 선언하고 조건에 일치하는 url로 요청이 들어왔을 경우 <code class=\"language-text\">index.html</code>파일을 찾아서 보내준다. 어떤 url이든 조건에 일치하게 되면 <code class=\"language-text\">index.html</code> 하나만 보내주기 때문에 <code class=\"language-text\">Single Page</code>인 것이다.</p>\n<p>그리고 클라이언트는 현재 12번 상품의 데이터를 가지고 있지 않기 때문에 추가적으로 API 호출을 하여 12번 상품의 데이터를 받아와야 한다.</p>\n<p>그럼 <code class=\"language-text\">SPA</code>의 장단점도 한번 살펴보자.</p>\n<h4 id=\"장점-1\" style=\"position:relative;\">장점<a href=\"#%EC%9E%A5%EC%A0%90-1\" aria-label=\"장점 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>초기 로딩 시 서버로부터 모든 정적 리소스를 내려받은 후에는 페이지 이동 시 필요한 데이터만 내려받으므로 로딩 속도가 빠르고 전체적인 트래픽을 감소시킬 수 있다.</li>\n<li>페이지 이동 시 새로고침이 되지 않으므로 사용자 경험(UX)가 향상된다.</li>\n</ul>\n<h4 id=\"단점-1\" style=\"position:relative;\">단점<a href=\"#%EB%8B%A8%EC%A0%90-1\" aria-label=\"단점 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>초기 로딩 시 현재 페이지에서 사용하지않는 모든 정적 리소스를 받으므로 초기 로딩속도가 느리다.</li>\n<li><code class=\"language-text\">SEO</code>에 취약하다.\n<br></li>\n</ul>\n<h2 id=\"ssr-vs-spa\" style=\"position:relative;\">SSR vs SPA<a href=\"#ssr-vs-spa\" aria-label=\"ssr vs spa permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>각 방식의 대략적인 실행 흐름과 장단점을 살펴보았는데, <code class=\"language-text\">SSR</code>과 <code class=\"language-text\">SPA</code> 두 방식 모두 <code class=\"language-text\">로딩 속도</code>라는 장단점을 가지고 있다. 뭐가 다른 걸까?</p>\n<p><code class=\"language-text\">SSR</code>의 장점은 <code class=\"language-text\">초기 로딩속도</code>이다. <code class=\"language-text\">SPA</code>는 첫 로딩 시 전체 어플리케이션에서 사용하는 모든 정적 리소스를 내려받기 때문에 초기 로딩속도는 느리지만 그 이후에는 추가적으로 리소스를 다운로드 받을 필요가 없기 때문에 이후 구동 속도가 빠른 것이다.</p>\n<p>반면 <code class=\"language-text\">SSR</code>은 현재 페이지에서 필요한 리소스만 로딩하면 되기 때문에 초기 로딩속도는 <code class=\"language-text\">SPA</code>에 비해서 빠를 수 있다. 그러나 받아온 정적 리소스를 어딘가에 저장하고 있는 게 아니기 때문에 페이지를 이동할때마다 저번 페이지에서 받아왔던 리소스라고 하더라도 처음부터 다시 받아와야한다.</p>\n<p>그래서 어플리케이션 초기화 후 페이지 이동 시 로딩 시간은 <code class=\"language-text\">SSR</code>이 더 느릴 수 있다.  </p>\n<p>하지만 <code class=\"language-text\">SPA</code>방식의 어마무시한 단점은 바로 <code class=\"language-text\">SEO</code>다. <code class=\"language-text\">SEO</code>는 Search Engine Optimization의 약자로 직역 그대로 <code class=\"language-text\">검색엔진최적화</code>를 의미한다.</p>\n<p>검색 엔진은 기본적으로 크롤링을 해서 페이지를 수집하는 방식으로 이루어져있는데, 문제는 크롤링을 하는 봇들이 JavaScript를 실행할 수 있는 능력이 없다는 것이다.</p>\n<p>최근 구글 크롤러 같은 경우는 JavaScript 실행능력이 있다고 하지만 개인적으로 아직까지 그렇게까지 신뢰가 가는 정도는 아니라고 본다. 게다가 Facebook과 같은 SNS에 페이지 공유를 했을때에는 <code class=\"language-text\">og meta tag</code>를 크롤러가 읽어야지 공유된 사이트의 정보가 올바르게 표시되는데, JavaScript가 실행되지 않은 페이지를 크롤러가 읽었을 때는 그냥 빈페이지밖에 없으니 정보를 제대로 표시해주지 못하는 문제도 있었다.  </p>\n<p>필자도 이 문제를 해결하기 위해 <code class=\"language-text\">#!(해쉬뱅)</code>이라던가 <code class=\"language-text\">_esacped_fragment_</code>이러단가 <code class=\"language-text\">Pre rendering</code> 같은 방법들을 사용해봤었지만 검색엔진사에서 권장하는대로 어플리케이션을 작성해도 <code class=\"language-text\">SSR</code>방식에 비해 데이터를 제대로 못긁어가는 건 어쩔 수 없었다.</p>\n<h2 id=\"새로운-개념의-server-side-rendering의-등장\" style=\"position:relative;\">새로운 개념의 Server Side Rendering의 등장<a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B0%9C%EB%85%90%EC%9D%98-server-side-rendering%EC%9D%98-%EB%93%B1%EC%9E%A5\" aria-label=\"새로운 개념의 server side rendering의 등장 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">SSR</code>을 택하자니 <code class=\"language-text\">SPA</code>의 장점이 아깝고, <code class=\"language-text\">SPA</code>를 택하자니 <code class=\"language-text\">SSR</code>의 장점이 아깝다. 그럼 어떻게 해야할까? 그래서 나온 방식이 최근에 많이 사용하고 있는 <code class=\"language-text\">두 방식을 적당히 짬뽕한 방식</code>이다.\n사용자의 첫 요청시에만 <code class=\"language-text\">SSR</code>을 수행하고, 그 이후는 <code class=\"language-text\">SPA</code>처럼 동적인 렌더링을 수행하는 것이다. 이 방식은 아래와 같은 장점을 가진다.</p>\n<h4 id=\"장점-2\" style=\"position:relative;\">장점<a href=\"#%EC%9E%A5%EC%A0%90-2\" aria-label=\"장점 2 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<hr>\n<ol>\n<li>첫 요청을 <code class=\"language-text\">SSR</code>로 완성된 HTML을 내려줌으로써 <code class=\"language-text\">SEO</code>와 초기 렌더링 속도문제를 해결</li>\n<li>이후 클라이언트에서 렌더링을 수행함으로써 <code class=\"language-text\">SPA</code>의 장점인 페이지 이동 시 빠른 렌더 속도도 그대로 가져감</li>\n<li>Frontend 프레임워크 3대장인 <code class=\"language-text\">Angular</code>, <code class=\"language-text\">React</code>, <code class=\"language-text\">Vue</code> 모두 이러한 <code class=\"language-text\">SSR</code> 방식을 공식으로 지원하기 때문에 Client와 Server를 같은 Context로 묶을 수 있음. 즉, 내가 만든 컴포넌트는 클라이언트에서 렌더를 수행하든 서버에서 렌더를 수행하든 동일하게 실행된다.</li>\n</ol>\n<hr>\n<p>하지만 모든 기술에는 Trade-off가 있는 법…단점은 뭐가 있을까?</p>\n<h4 id=\"단점-2\" style=\"position:relative;\">단점<a href=\"#%EB%8B%A8%EC%A0%90-2\" aria-label=\"단점 2 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<hr>\n<ol>\n<li>코드가 복잡하다. 어플리케이션 구동 순서를 확실하게 파악하고 있지 않다면 진짜 헷갈린다.</li>\n<li>서버에서 렌더링을 수행하므로 단순 리소스 서빙보다는 아무래도 CPU를 많이 사용하게 되고, 부하가 걸릴 수 있다.</li>\n<li>서버에 익숙하지 않은 Frontend 개발자의 경우 클라이언트처럼 개발을 진행하게 되면 의도하지 않은 버그가 생길 수 있다.</li>\n</ol>\n<hr>\n<p>특히 2번과 3번 같은 경우 필자가 간과했던 부분인데, 클라이언트에서는 아무 문제 없었을 부분이 서버에서는 치명적인 실수가 되어 버그로 돌아오는 경험을 했다.</p>\n<p><a href=\"/2018/09/25/vue-ssr\">다음 포스팅</a>에서는 필자가 회사에 <code class=\"language-text\">Vue-ssr</code>을 도입했던 경험과 어떤 실수를 했는지에 대해서 적어보고 회고하려고 한다.</p>\n<p>이상으로 Universal Server Side Rendering이란? 포스팅을 마친다.</p>","tableOfContents":"<ul>\n<li><a href=\"#server-side-rendering%EC%9D%84-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-multi-page-application\">Server Side Rendering을 수행하는 Multi Page Application</a></li>\n<li><a href=\"#client-side-rendering%EC%9D%84-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-single-page-application\">Client Side Rendering을 수행하는 Single Page Application</a></li>\n<li><a href=\"#ssr-vs-spa\">SSR vs SPA</a></li>\n<li><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B0%9C%EB%85%90%EC%9D%98-server-side-rendering%EC%9D%98-%EB%93%B1%EC%9E%A5\">새로운 개념의 Server Side Rendering의 등장</a></li>\n</ul>","fields":{"lang":"ko"},"frontmatter":{"title":"Universal Server Side Rendering이란?","date":"2018-09-25","categories":["Programming","Web"],"tags":["Web","SPA","Single Page Application","SSR","Server Side Rendering","서버사이드 렌더링"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABPklEQVQY021RTUvDUBDM3/NHeBDEg+BPEEQEwaM9iOhBVKRFSkW81EZriGITCrUmbQVtEpRS02gTjUnsy8dzkjSlFB9z2dmdfbO7zC/1AQ+ISIqUickoxlRIZmqYVEloSJMX0ChNEBr4NPSzcIRM9sKMZDxKoPxwvmqqJHRl1ehDhlLT+9FNU7eG+MenwTdx+FbjtvlQrdclTUFf8IwbkYhS+VVZOthY3t8sctdIoGtvYJRuqhccHyThwLb2zkpbR4e5kwIriDA4FsPJo/Yyv7O6sL2WZ8uYE24LQmVud2XxeL1vfYIZOvbVnXhaYXPFPN9sYMhYnLgKddsst2uXstDpabCNnPyunMtc+enecCyENvGkbrejamK79dx7G9tOFhbrp5eBFQYZg14o+H9hkzO44QiYnGHCzJzKnTrVHwiGuiMxi5RDAAAAAElFTkSuQmCC","aspectRatio":2.5641025641025643,"src":"/static/101302650c27400e337e88ad4e0633a6/ee604/thumbnail.png","srcSet":"/static/101302650c27400e337e88ad4e0633a6/69585/thumbnail.png 200w,\n/static/101302650c27400e337e88ad4e0633a6/497c6/thumbnail.png 400w,\n/static/101302650c27400e337e88ad4e0633a6/ee604/thumbnail.png 800w,\n/static/101302650c27400e337e88ad4e0633a6/f3583/thumbnail.png 1200w,\n/static/101302650c27400e337e88ad4e0633a6/e4d72/thumbnail.png 1280w","sizes":"(max-width: 800px) 100vw, 800px"}}}}},"allMarkdownRemark":{"edges":[]}},"pageContext":{"slug":"/20180925-universal-ssr/","previous":{"fields":{"slug":"/20180719-deep-learning-backpropagation/","path":"/2018/07/19/deep-learning-backpropagation/","lang":"ko","postGroup":"20180719-deep-learning-backpropagation"},"frontmatter":{"title":"[Deep Learning이란 무엇인가?] Backpropagation, 역전파 알아보기"}},"next":{"fields":{"slug":"/20180925-vue-ssr/","path":"/2018/09/25/vue-ssr/","lang":"ko","postGroup":"20180925-vue-ssr"},"frontmatter":{"title":"Vue Server Side Rendering"}},"lang":"ko","postGroup":"20180925-universal-ssr"}}}