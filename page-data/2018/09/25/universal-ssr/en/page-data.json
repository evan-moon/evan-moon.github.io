{"componentChunkName":"component---src-templates-post-page-template-index-tsx","path":"/2018/09/25/universal-ssr/en/","result":{"data":{"markdownRemark":{"id":"6b505001-1847-54c5-a64d-08b31826cdf1","tableOfContents":"<ul>\n<li><a href=\"#multi-page-application-performing-server-side-rendering\">Multi Page Application Performing Server Side Rendering</a></li>\n<li><a href=\"#single-page-application-performing-client-side-rendering\">Single Page Application Performing Client Side Rendering</a></li>\n<li><a href=\"#ssr-vs-spa\">SSR vs SPA</a></li>\n<li><a href=\"#emergence-of-new-concept-server-side-rendering\">Emergence of New Concept Server Side Rendering</a></li>\n</ul>","excerpt":"In this post I want to explain Universal SSR, widely used in recent modern web applications. I’ll briefly learn about SSR (Server Side Rendering) and SPA (Single Page Application) methods, then explain the Universal SSR method combining these two rendering methods.","html":"<p>In this post I want to explain Universal SSR, widely used in recent modern web applications. I’ll briefly learn about SSR (Server Side Rendering) and SPA (Single Page Application) methods, then explain the Universal SSR method combining these two rendering methods.</p>\n<!-- more -->\n<h2 id=\"multi-page-application-performing-server-side-rendering\" style=\"position:relative;\">Multi Page Application Performing Server Side Rendering<a href=\"#multi-page-application-performing-server-side-rendering\" aria-label=\"multi page application performing server side rendering permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>The SSR method is originally the method used in traditional web applications. Recently it’s also called MPA (Multi Page Application) in contrast to SPA (Single Page Application). SSR applications, after routing is performed, when new pages are requested from the server, render HTML each time and download entire pages again on clients.</p>\n<p>The rough execution order is as follows:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9052926c04e0b91148f091f6238be6c8/86a1e/ssr.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 61.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA+klEQVR42p2S2a6DMAxE+f8fRMAz+w5iX3x1IhlRWnRpLVmZOM54Yscqy1IcxxHP86Sua9n3XZ7atm1SVZXYti2u6xpszfMsTdNI3/cCPts0TSaOD8Ng1q7rZF1Xc05x7hBr29ZgiwMAvizLC0Z9HMcSRZEkSWJwGIaGGHXksLIHYwchB1Q8+52N43goV/VvhHcEV3IKozzPcymKwqw8Wdv1L+GdnfPp6WOFn4zfQD/TNJUsy8xAGODPhNdeo04n/zUhA0EZU0cdGMWPe0hl/Uq47nmixsAvPSTA6LW56kyUKQZBYNz3/eMPkqv+RngmuPpZOfhTjt6F8A/UQK7TVvFzNAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ssr\" title=\"\" src=\"/static/9052926c04e0b91148f091f6238be6c8/6af66/ssr.png\" srcset=\"/static/9052926c04e0b91148f091f6238be6c8/69538/ssr.png 160w,\n/static/9052926c04e0b91148f091f6238be6c8/72799/ssr.png 320w,\n/static/9052926c04e0b91148f091f6238be6c8/6af66/ssr.png 640w,\n/static/9052926c04e0b91148f091f6238be6c8/d9199/ssr.png 960w,\n/static/9052926c04e0b91148f091f6238be6c8/21b4d/ssr.png 1280w,\n/static/9052926c04e0b91148f091f6238be6c8/86a1e/ssr.png 1296w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<hr>\n<ol>\n<li>Client sends a request to the server with URL <code class=\"language-text\">example.com/products/12</code>.</li>\n<li>Server executes the method connected with that URL and finds appropriate HTML Template files.</li>\n<li>Get data for product number 12 from Database.</li>\n<li>Render final HTML using fetched data and HTML Template.</li>\n<li>Send HTML down to client.</li>\n<li>Finally users see the view.</li>\n</ol>\n<hr>\n<p>Even after users see the rendered page, they could additionally receive more data using Ajax, but since the point when users see the completed page is after step 6 finishes, exceptions like Ajax were omitted.</p>\n<p>Also, in step 2, you can see why this method’s applications are called MPA - because HTML Templates matched to each page exist separately.\nPros and cons of methods like this are as follows:</p>\n<h4 id=\"advantages\" style=\"position:relative;\">Advantages<a href=\"#advantages\" aria-label=\"advantages permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>Since completed HTML is sent down from the server, it’s optimized for SEO (Search Engine Optimization).</li>\n<li>Since only resources needed on each page are loaded, initial loading speed can be optimized.</li>\n</ul>\n<h4 id=\"disadvantages\" style=\"position:relative;\">Disadvantages<a href=\"#disadvantages\" aria-label=\"disadvantages permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>New resources must be requested every page loading, so overall traffic increases.</li>\n<li>Refreshes occur every page move and entire pages are re-rendered, so loading time lengthens.</li>\n</ul>\n<h2 id=\"single-page-application-performing-client-side-rendering\" style=\"position:relative;\">Single Page Application Performing Client Side Rendering<a href=\"#single-page-application-performing-client-side-rendering\" aria-label=\"single page application performing client side rendering permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Recently many Frontend developers develop A.K.A SPAs (Single Page Applications) performing Client Side Rendering. In other words, it means applications where pages actually downloaded from servers are just 1, and afterward perform dynamic rendering through JavaScript.</p>\n<p>The rough execution order is as follows:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f7c73717983bb1dd64d902e6c3334943/01a87/csr.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 78.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABRElEQVR42p2T246DMAxE+f/vQzzwwBMUKJSKS7kV6upEcpQCu0s30ogoccZje/Cu16v4vi9RFEnTNPLtqutawjCUIAgkz3Px+r6XsiylbVuZ5/kjeFkWeT6fBu5+XVcbM02TEXK73QQuTw81GFLAnkRpmkqSJCY7+ziOjSrueUeiYRhkHEeTwBK+Xq9D8IBgBeqOYrQ6Q4hUsrhlaZmUgzp6DVS9C84QZQnJfBSIGu4gBdpnErnQ8i0h6rRsSIAqhASFRVEYhSQ4pfDxeFh0XWcCzy6EfPQQhff7XaqqMl8soBn/Rbidsp5dLhfJssx+1TYkdHtI7K5kDtSDW+gDN0bJdHCHPjxTGotBoZghMSyMTtt2ttnaQQ2rE+ahOmA75Q+FvxECjM/k1fx/+pAHNFr9xrS/Wbsp61+xnfRPPTw6RymEb4ZY5cKFHVMWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"csr\" title=\"\" src=\"/static/f7c73717983bb1dd64d902e6c3334943/6af66/csr.png\" srcset=\"/static/f7c73717983bb1dd64d902e6c3334943/69538/csr.png 160w,\n/static/f7c73717983bb1dd64d902e6c3334943/72799/csr.png 320w,\n/static/f7c73717983bb1dd64d902e6c3334943/6af66/csr.png 640w,\n/static/f7c73717983bb1dd64d902e6c3334943/d9199/csr.png 960w,\n/static/f7c73717983bb1dd64d902e6c3334943/21b4d/csr.png 1280w,\n/static/f7c73717983bb1dd64d902e6c3334943/01a87/csr.png 1288w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<hr>\n<ol>\n<li>Client sends a request to the server with URL <code class=\"language-text\">example.com/products/12</code>.</li>\n<li>Server, whatever it is, if request URL starts with <code class=\"language-text\">exmplate.com</code>, finds and sends down <code class=\"language-text\">index.html</code>.</li>\n<li>And additionally sends down JavaScript Bundle together. For example, it would be files like <code class=\"language-text\">bundle.js</code> that come out when building with modulers like Webpack.</li>\n<li>Client executing <code class=\"language-text\">bundle.js</code> requests product number 12’s data from server using API <code class=\"language-text\">api.example.com/products/12</code>.</li>\n<li>Server gets product number 12’s data from Database then sends data down to client.</li>\n<li>Client renders views using received data.</li>\n<li>Finally users see the view.</li>\n</ol>\n<hr>\n<p>It got kind of complicated compared to earlier. The reason this method is SPA is in step 2. Usually that url is declared in settings of server engines like Nginx or Apache, and if requests come to urls matching conditions, they find and send <code class=\"language-text\">index.html</code> files. Whatever url it is, if it matches conditions, only one <code class=\"language-text\">index.html</code> is sent, so it’s called Single Page.</p>\n<p>And since clients currently don’t have product number 12’s data, they must additionally make API calls to receive product number 12’s data.</p>\n<p>Then let’s also look at SPA’s pros and cons.</p>\n<h4 id=\"advantages-1\" style=\"position:relative;\">Advantages<a href=\"#advantages-1\" aria-label=\"advantages 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>After downloading all static resources from the server during initial loading, only necessary data is downloaded during page moves, so loading speed is fast and overall traffic can be reduced.</li>\n<li>Since refreshes don’t occur during page moves, user experience (UX) improves.</li>\n</ul>\n<h4 id=\"disadvantages-1\" style=\"position:relative;\">Disadvantages<a href=\"#disadvantages-1\" aria-label=\"disadvantages 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>During initial loading, all static resources not used on current page are received, so initial loading speed is slow.</li>\n<li>Vulnerable to SEO.</li>\n</ul>\n<h2 id=\"ssr-vs-spa\" style=\"position:relative;\">SSR vs SPA<a href=\"#ssr-vs-spa\" aria-label=\"ssr vs spa permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>We’ve looked at rough execution flows and pros and cons of each method. Both SSR and SPA methods have pros and cons of loading speed. What’s different?</p>\n<p>SSR’s advantage is initial loading speed. SPA downloads all static resources used in the entire application during first loading, so initial loading speed is slow, but afterward there’s no need to additionally download resources, so operating speed afterward is fast.</p>\n<p>On the other hand, SSR only needs to load resources needed on current pages, so initial loading speed can be faster compared to SPA. However, since received static resources aren’t stored somewhere, even resources received on previous pages must be received from scratch again whenever pages move.</p>\n<p>So loading time during page moves after application initialization can be slower in SSR.</p>\n<p>But SPA method’s tremendous disadvantage is exactly SEO. SEO is abbreviation for Search Engine Optimization, meaning search engine optimization as directly translated.</p>\n<p>Search engines are basically based on crawling and collecting pages. The problem is that bots doing crawling don’t have ability to execute JavaScript.</p>\n<p>Recently cases like Google crawler are said to have JavaScript execution ability, but personally I see it as not yet trustworthy to that degree. Moreover, when sharing pages on SNS like Facebook, crawlers must read Open Graph tags for shared site information to display correctly. When crawlers read pages where JavaScript didn’t execute, there’s just blank pages, so there were problems of not properly displaying information.</p>\n<p>I also tried methods like <code class=\"language-text\">#!</code> (hashbang), <code class=\"language-text\">_esacped_fragment_</code>, or <code class=\"language-text\">Pre rendering</code> to solve this problem, but even writing applications as recommended by search engine companies, compared to SSR methods, they couldn’t help not properly scraping data.</p>\n<h2 id=\"emergence-of-new-concept-server-side-rendering\" style=\"position:relative;\">Emergence of New Concept Server Side Rendering<a href=\"#emergence-of-new-concept-server-side-rendering\" aria-label=\"emergence of new concept server side rendering permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Choose SSR and SPA’s advantages are wasteful. Choose SPA and SSR’s advantages are wasteful. Then what should we do? So the method that came out is the method appropriately mixing both methods widely used recently.\nPerform SSR only during users’ first requests, and afterward perform dynamic rendering like SPAs. This method has advantages like below:</p>\n<h4 id=\"advantages-2\" style=\"position:relative;\">Advantages<a href=\"#advantages-2\" aria-label=\"advantages 2 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<hr>\n<ol>\n<li>Solve SEO and initial rendering speed problems by sending down completed HTML with SSR for first requests</li>\n<li>Also bring SPA’s advantage of fast render speed during page moves by performing rendering on client afterward</li>\n<li>Since all 3 major Frontend frameworks Angular, React, Vue officially support such SSR methods, Client and Server can be bound with same Context. In other words, components I made execute identically whether rendering on client or server.</li>\n</ol>\n<hr>\n<p>But all technologies have Trade-offs… what are the disadvantages?</p>\n<h4 id=\"disadvantages-2\" style=\"position:relative;\">Disadvantages<a href=\"#disadvantages-2\" aria-label=\"disadvantages 2 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<hr>\n<ol>\n<li>Code is complex. If you don’t clearly understand application operation order, it’s really confusing.</li>\n<li>Since rendering is performed on server, more CPU is used compared to simple resource serving, and load can be placed.</li>\n<li>For Frontend developers unfamiliar with servers, if development proceeds like clients, unintended bugs can occur.</li>\n</ol>\n<hr>\n<p>Especially cases like #2 and #3 were parts I overlooked. Parts that had no problems on clients became fatal mistakes on servers and came back as bugs.</p>\n<p>In the <a href=\"/2018/09/25/vue-ssr\">next post</a>, I want to write about and reflect on my experience introducing Vue-ssr at work and what mistakes I made.</p>\n<p>That’s all for this post on What is Universal Server Side Rendering?</p>","fields":{"slug":"20180925-universal-ssr-en","path":"/2018/09/25/universal-ssr/en/","lang":"en"},"frontmatter":{"title":"What is Universal Server Side Rendering?","subTitle":"Rendering Technique Capturing Both SEO Optimization and Performance","date":"Sep 25, 2018","categories":["Programming","Web","Tutorial"],"tags":["SPA","Single Page Application","SSR","Server Side Rendering","Universal Server Side Rendering","NextJS","NuxtJS","SEO"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/101302650c27400e337e88ad4e0633a6/d803c/thumbnail.png","srcSet":"/static/101302650c27400e337e88ad4e0633a6/d803c/thumbnail.png 320w,\n/static/101302650c27400e337e88ad4e0633a6/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/101302650c27400e337e88ad4e0633a6/fc5c5/thumbnail.webp 320w,\n/static/101302650c27400e337e88ad4e0633a6/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/101302650c27400e337e88ad4e0633a6/01fb2/thumbnail.png","srcSet":"/static/101302650c27400e337e88ad4e0633a6/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/101302650c27400e337e88ad4e0633a6/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}},"allMarkdownRemark":{"edges":[{"node":{"id":"1d86eea6-4784-5e03-b4bb-22e53a5b02db","tableOfContents":"<ul>\n<li><a href=\"#server-side-rendering%EC%9D%84-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-multi-page-application\">Server Side Rendering을 수행하는 Multi Page Application</a></li>\n<li><a href=\"#client-side-rendering%EC%9D%84-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-single-page-application\">Client Side Rendering을 수행하는 Single Page Application</a></li>\n<li><a href=\"#ssr-vs-spa\">SSR vs SPA</a></li>\n<li><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B0%9C%EB%85%90%EC%9D%98-server-side-rendering%EC%9D%98-%EB%93%B1%EC%9E%A5\">새로운 개념의 Server Side Rendering의 등장</a></li>\n</ul>","excerpt":"이번 포스팅에서는 최근 모던 웹 어플리케이션에서 많이 사용하고 있는 Universal SSR에 대해서 설명하고자 한다. SSR(erver Side Rendering)과 SPA(Single Page Application)의 방식을 간단하게 알아보고 이 두 렌더 방식을 조합한 Universal SSR의 방식을 설명한다.","html":"<p>이번 포스팅에서는 최근 모던 웹 어플리케이션에서 많이 사용하고 있는 Universal SSR에 대해서 설명하고자 한다. SSR(erver Side Rendering)과 SPA(Single Page Application)의 방식을 간단하게 알아보고 이 두 렌더 방식을 조합한 Universal SSR의 방식을 설명한다.</p>\n<!-- more -->\n<h2 id=\"server-side-rendering을-수행하는-multi-page-application\" style=\"position:relative;\">Server Side Rendering을 수행하는 Multi Page Application<a href=\"#server-side-rendering%EC%9D%84-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-multi-page-application\" aria-label=\"server side rendering을 수행하는 multi page application permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>SSR 방식은 원래 전통적인 웹 어플리케이션에서 사용하던 방식이다. 최근에는 SPA(Single Page Application)과 대조하여 MPA(Multi Page Application)이라고도 불린다. SSR 어플리케이션은 라우팅이 수행된 후 새로운 페이지가 서버에 요청되면 싶으면 그때마다 HTML를 렌더한 후 클라이언트에서 전체 페이지를 다시 내려받는다.</p>\n<p>대략적인 실행 순서는 다음과 같다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9052926c04e0b91148f091f6238be6c8/86a1e/ssr.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 61.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA+klEQVR42p2S2a6DMAxE+f8fRMAz+w5iX3x1IhlRWnRpLVmZOM54Yscqy1IcxxHP86Sua9n3XZ7atm1SVZXYti2u6xpszfMsTdNI3/cCPts0TSaOD8Ng1q7rZF1Xc05x7hBr29ZgiwMAvizLC0Z9HMcSRZEkSWJwGIaGGHXksLIHYwchB1Q8+52N43goV/VvhHcEV3IKozzPcymKwqw8Wdv1L+GdnfPp6WOFn4zfQD/TNJUsy8xAGODPhNdeo04n/zUhA0EZU0cdGMWPe0hl/Uq47nmixsAvPSTA6LW56kyUKQZBYNz3/eMPkqv+RngmuPpZOfhTjt6F8A/UQK7TVvFzNAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ssr\" title=\"\" src=\"/static/9052926c04e0b91148f091f6238be6c8/6af66/ssr.png\" srcset=\"/static/9052926c04e0b91148f091f6238be6c8/69538/ssr.png 160w,\n/static/9052926c04e0b91148f091f6238be6c8/72799/ssr.png 320w,\n/static/9052926c04e0b91148f091f6238be6c8/6af66/ssr.png 640w,\n/static/9052926c04e0b91148f091f6238be6c8/d9199/ssr.png 960w,\n/static/9052926c04e0b91148f091f6238be6c8/21b4d/ssr.png 1280w,\n/static/9052926c04e0b91148f091f6238be6c8/86a1e/ssr.png 1296w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<hr>\n<ol>\n<li>클라이언트가 서버에 <code class=\"language-text\">example.com/products/12</code> URL로 요청을 보낸다.</li>\n<li>서버에서는 해당 URL과 연결되어있는 메소드가 실행되고 알맞는 HTML Template파일을 찾는다.</li>\n<li>Database에서 12번 상품의 데이터를 가져온다.</li>\n<li>가져온 데이터와 HTML Template을 사용해 최종 HTML을 렌더한다.</li>\n<li>클라이언트로 HTML을 내려준다.</li>\n<li>최종적으로 사용자가 뷰를 본다.</li>\n</ol>\n<hr>\n<p>사용자가 렌더된 페이지를 본 이후에도 Ajax를 사용하여 데이터를 추가로 더 받아올 수도 있겠지만 일단 사용자가 완성된 페이지를 보는 시점은 6번 과정이 끝난 이후기 때문에 Ajax와 같은 예외는 생략했다.</p>\n<p>또한 2번 과정에서 어째서 이 방식의 어플리케이션이 MPA라고 불리는 지 알 수 있는데, 각 페이지에 매칭된 HTML Template이 따로 존재하기 때문이다.\n다음과 같은 방식의 장단점은 다음과 같다.</p>\n<h4 id=\"장점\" style=\"position:relative;\">장점<a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>서버에서 완성된 HTML을 내려주기 때문에 SEO(Search Engine Optimization)에 최적화되어 있다.</li>\n<li>매 페이지에서 필요한 리소스만 로딩하기 때문에 초기 로딩속도를 최적화할 수 있다.</li>\n</ul>\n<h4 id=\"단점\" style=\"position:relative;\">단점<a href=\"#%EB%8B%A8%EC%A0%90\" aria-label=\"단점 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>매 페이지 로딩 시마다 새로운 리소스를 요청해야하므로 전체적인 트래픽이 증가한다.</li>\n<li>페이지 이동 시 마다 새로고침이 되며 전체 페이지를 다시 렌더하므로 로딩 시간이 길어진다.</li>\n</ul>\n<h2 id=\"client-side-rendering을-수행하는-single-page-application\" style=\"position:relative;\">Client Side Rendering을 수행하는 Single Page Application<a href=\"#client-side-rendering%EC%9D%84-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-single-page-application\" aria-label=\"client side rendering을 수행하는 single page application permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>최근 들어 많은 수의 Frontend 개발자가 Client Side Rendering을 수행하는 A.K.A SPA(Single Page Application)를 개발한다. 즉, 서버에서 실제로 다운로드 받는 페이지는 단 1개이고 그 이후 JavaScript를 통해 동적인 렌더링을 실시하는 어플리케이션을 의미한다.</p>\n<p>대략적인 실행 순서는 다음과 같다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f7c73717983bb1dd64d902e6c3334943/01a87/csr.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 78.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAABRElEQVR42p2T246DMAxE+f/vQzzwwBMUKJSKS7kV6upEcpQCu0s30ogoccZje/Cu16v4vi9RFEnTNPLtqutawjCUIAgkz3Px+r6XsiylbVuZ5/kjeFkWeT6fBu5+XVcbM02TEXK73QQuTw81GFLAnkRpmkqSJCY7+ziOjSrueUeiYRhkHEeTwBK+Xq9D8IBgBeqOYrQ6Q4hUsrhlaZmUgzp6DVS9C84QZQnJfBSIGu4gBdpnErnQ8i0h6rRsSIAqhASFRVEYhSQ4pfDxeFh0XWcCzy6EfPQQhff7XaqqMl8soBn/Rbidsp5dLhfJssx+1TYkdHtI7K5kDtSDW+gDN0bJdHCHPjxTGotBoZghMSyMTtt2ttnaQQ2rE+ahOmA75Q+FvxECjM/k1fx/+pAHNFr9xrS/Wbsp61+xnfRPPTw6RymEb4ZY5cKFHVMWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"csr\" title=\"\" src=\"/static/f7c73717983bb1dd64d902e6c3334943/6af66/csr.png\" srcset=\"/static/f7c73717983bb1dd64d902e6c3334943/69538/csr.png 160w,\n/static/f7c73717983bb1dd64d902e6c3334943/72799/csr.png 320w,\n/static/f7c73717983bb1dd64d902e6c3334943/6af66/csr.png 640w,\n/static/f7c73717983bb1dd64d902e6c3334943/d9199/csr.png 960w,\n/static/f7c73717983bb1dd64d902e6c3334943/21b4d/csr.png 1280w,\n/static/f7c73717983bb1dd64d902e6c3334943/01a87/csr.png 1288w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<hr>\n<ol>\n<li>클라이언트가 서버에 <code class=\"language-text\">example.com/products/12</code> URL로 요청을 보낸다.</li>\n<li>서버에서는 뭐가 됐던 요청 URL이 <code class=\"language-text\">exmplate.com</code>으로 시작하면 <code class=\"language-text\">index.html</code>을 찾아서 내려준다.</li>\n<li>그리고 추가로 JavaScript Bundle을 같이 내려준다. 예를 들면 Webpack같은 모듈러로 빌드하면 나오는 <code class=\"language-text\">bundle.js</code>같은 파일이 되겠다.</li>\n<li><code class=\"language-text\">bundle.js</code>을 실행한 클라이언트가 <code class=\"language-text\">api.example.com/products/12</code> API를 사용하여 12번 상품의 데이터를 서버에 요청한다.</li>\n<li>서버는 Database에서 12번 상품의 데이터를 가져온 후 클라이언트에 데이터를 내려준다.</li>\n<li>클라이언트는 받아온 데이터를 사용하여 뷰가 렌더한다.</li>\n<li>최종적으로 사용자가 뷰를 본다.</li>\n</ol>\n<hr>\n<p>아까에 비해서 뭔가 복잡해졌다. 이 방식이 SPA인 이유는 2번 과정에 있다. 보통 Nginx나 Apache같은 서버 엔진의 설정에 해당 url을 선언하고 조건에 일치하는 url로 요청이 들어왔을 경우 <code class=\"language-text\">index.html</code>파일을 찾아서 보내준다. 어떤 url이든 조건에 일치하게 되면 <code class=\"language-text\">index.html</code> 하나만 보내주기 때문에 Single Page라고 하는 것이다.</p>\n<p>그리고 클라이언트는 현재 12번 상품의 데이터를 가지고 있지 않기 때문에 추가적으로 API 호출을 하여 12번 상품의 데이터를 받아와야 한다.</p>\n<p>그럼 SPA의 장단점도 한번 살펴보자.</p>\n<h4 id=\"장점-1\" style=\"position:relative;\">장점<a href=\"#%EC%9E%A5%EC%A0%90-1\" aria-label=\"장점 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>초기 로딩 시 서버로부터 모든 정적 리소스를 내려받은 후에는 페이지 이동 시 필요한 데이터만 내려받으므로 로딩 속도가 빠르고 전체적인 트래픽을 감소시킬 수 있다.</li>\n<li>페이지 이동 시 새로고침이 되지 않으므로 사용자 경험(UX)가 향상된다.</li>\n</ul>\n<h4 id=\"단점-1\" style=\"position:relative;\">단점<a href=\"#%EB%8B%A8%EC%A0%90-1\" aria-label=\"단점 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>초기 로딩 시 현재 페이지에서 사용하지않는 모든 정적 리소스를 받으므로 초기 로딩속도가 느리다.</li>\n<li>SEO에 취약하다.</li>\n</ul>\n<h2 id=\"ssr-vs-spa\" style=\"position:relative;\">SSR vs SPA<a href=\"#ssr-vs-spa\" aria-label=\"ssr vs spa permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>각 방식의 대략적인 실행 흐름과 장단점을 살펴보았는데, SSR과 SPA 두 방식 모두 로딩 속도라는 장단점을 가지고 있다. 뭐가 다른 걸까?</p>\n<p>SSR의 장점은 초기 로딩속도이다. SPA는 첫 로딩 시 전체 어플리케이션에서 사용하는 모든 정적 리소스를 내려받기 때문에 초기 로딩속도는 느리지만 그 이후에는 추가적으로 리소스를 다운로드 받을 필요가 없기 때문에 이후 구동 속도가 빠른 것이다.</p>\n<p>반면 SSR은 현재 페이지에서 필요한 리소스만 로딩하면 되기 때문에 초기 로딩속도는 SPA에 비해서 빠를 수 있다. 그러나 받아온 정적 리소스를 어딘가에 저장하고 있는 게 아니기 때문에 페이지를 이동할때마다 저번 페이지에서 받아왔던 리소스라고 하더라도 처음부터 다시 받아와야한다.</p>\n<p>그래서 어플리케이션 초기화 후 페이지 이동 시 로딩 시간은 SSR이 더 느릴 수 있다.</p>\n<p>하지만 SPA방식의 어마무시한 단점은 바로 SEO다. SEO는 Search Engine Optimization의 약자로 직역 그대로 검색엔진 최적화를 의미한다.</p>\n<p>검색 엔진은 기본적으로 크롤링을 해서 페이지를 수집하는 방식으로 이루어져있는데, 문제는 크롤링을 하는 봇들이 JavaScript를 실행할 수 있는 능력이 없다는 것이다.</p>\n<p>최근 구글 크롤러 같은 경우는 JavaScript 실행능력이 있다고 하지만 개인적으로 아직까지 그렇게까지 신뢰가 가는 정도는 아니라고 본다. 게다가 Facebook과 같은 SNS에 페이지 공유를 했을때에는 Open Graph 태그를 크롤러가 읽어야지 공유된 사이트의 정보가 올바르게 표시되는데, JavaScript가 실행되지 않은 페이지를 크롤러가 읽었을 때는 그냥 빈 페이지밖에 없으니 정보를 제대로 표시해주지 못하는 문제도 있었다.</p>\n<p>필자도 이 문제를 해결하기 위해 <code class=\"language-text\">#!</code>(해쉬뱅)이라던가 <code class=\"language-text\">_esacped_fragment_</code>이러단가 <code class=\"language-text\">Pre rendering</code> 같은 방법들을 사용해봤었지만 검색엔진사에서 권장하는대로 어플리케이션을 작성해도 SSR방식에 비해 데이터를 제대로 못긁어가는 건 어쩔 수 없었다.</p>\n<h2 id=\"새로운-개념의-server-side-rendering의-등장\" style=\"position:relative;\">새로운 개념의 Server Side Rendering의 등장<a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B0%9C%EB%85%90%EC%9D%98-server-side-rendering%EC%9D%98-%EB%93%B1%EC%9E%A5\" aria-label=\"새로운 개념의 server side rendering의 등장 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>SSR을 택하자니 SPA의 장점이 아깝고, SPA를 택하자니 SSR의 장점이 아깝다. 그럼 어떻게 해야할까? 그래서 나온 방식이 최근에 많이 사용하고 있는 두 방식을 적당히 짬뽕한 방식이다.\n사용자의 첫 요청시에만 SSR을 수행하고, 그 이후는 SPA처럼 동적인 렌더링을 수행하는 것이다. 이 방식은 아래와 같은 장점을 가진다.</p>\n<h4 id=\"장점-2\" style=\"position:relative;\">장점<a href=\"#%EC%9E%A5%EC%A0%90-2\" aria-label=\"장점 2 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<hr>\n<ol>\n<li>첫 요청을 SSR로 완성된 HTML을 내려줌으로써 SEO와 초기 렌더링 속도문제를 해결</li>\n<li>이후 클라이언트에서 렌더링을 수행함으로써 SPA의 장점인 페이지 이동 시 빠른 렌더 속도도 그대로 가져감</li>\n<li>Frontend 프레임워크 3대장인 Angular, React, Vue 모두 이러한 SSR 방식을 공식으로 지원하기 때문에 Client와 Server를 같은 Context로 묶을 수 있음. 즉, 내가 만든 컴포넌트는 클라이언트에서 렌더를 수행하든 서버에서 렌더를 수행하든 동일하게 실행된다.</li>\n</ol>\n<hr>\n<p>하지만 모든 기술에는 Trade-off가 있는 법…단점은 뭐가 있을까?</p>\n<h4 id=\"단점-2\" style=\"position:relative;\">단점<a href=\"#%EB%8B%A8%EC%A0%90-2\" aria-label=\"단점 2 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<hr>\n<ol>\n<li>코드가 복잡하다. 어플리케이션 구동 순서를 확실하게 파악하고 있지 않다면 진짜 헷갈린다.</li>\n<li>서버에서 렌더링을 수행하므로 단순 리소스 서빙보다는 아무래도 CPU를 많이 사용하게 되고, 부하가 걸릴 수 있다.</li>\n<li>서버에 익숙하지 않은 Frontend 개발자의 경우 클라이언트처럼 개발을 진행하게 되면 의도하지 않은 버그가 생길 수 있다.</li>\n</ol>\n<hr>\n<p>특히 2번과 3번 같은 경우 필자가 간과했던 부분인데, 클라이언트에서는 아무 문제 없었을 부분이 서버에서는 치명적인 실수가 되어 버그로 돌아오는 경험을 했다.</p>\n<p><a href=\"/2018/09/25/vue-ssr\">다음 포스팅</a>에서는 필자가 회사에 Vue-ssr을 도입했던 경험과 어떤 실수를 했는지에 대해서 적어보고 회고하려고 한다.</p>\n<p>이상으로 Universal Server Side Rendering이란? 포스팅을 마친다.</p>","fields":{"slug":"20180925-universal-ssr","path":"/2018/09/25/universal-ssr/","lang":"ko"},"frontmatter":{"title":"Universal Server Side Rendering이란?","subTitle":"SEO 최적화와 성능을 모두 잡는 렌더링 기법","date":"Sep 25, 2018","categories":["프로그래밍","웹","튜토리얼"],"tags":["SPA","Single Page Application","SSR","Server Side Rendering","서버사이드 렌더링","Universal Server Side Rendering","NextJS","NuxtJS","SEO"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/101302650c27400e337e88ad4e0633a6/d803c/thumbnail.png","srcSet":"/static/101302650c27400e337e88ad4e0633a6/d803c/thumbnail.png 320w,\n/static/101302650c27400e337e88ad4e0633a6/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/101302650c27400e337e88ad4e0633a6/fc5c5/thumbnail.webp 320w,\n/static/101302650c27400e337e88ad4e0633a6/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/101302650c27400e337e88ad4e0633a6/01fb2/thumbnail.png","srcSet":"/static/101302650c27400e337e88ad4e0633a6/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/101302650c27400e337e88ad4e0633a6/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"slug":"20180925-universal-ssr-en","previous":{"fields":{"slug":"20180719-deep-learning-backpropagation-en","path":"/2018/07/19/deep-learning-backpropagation/en/","lang":"en","postGroup":"20180719-deep-learning-backpropagation"},"frontmatter":{"title":"[Deep Learning Series] Understanding Backpropagation"}},"next":{"fields":{"slug":"20180925-vue-ssr-en","path":"/2018/09/25/vue-ssr/en/","lang":"en","postGroup":"20180925-vue-ssr"},"frontmatter":{"title":"Vue Server Side Rendering"}},"lang":"en","postGroup":"20180925-universal-ssr"}},"staticQueryHashes":["3129619726","3523904809","376081736","650499039"],"slicesMap":{}}