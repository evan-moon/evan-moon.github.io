{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/추상화/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"b7529b72-8f0e-5da0-aba5-3ec7b344e1ef","tableOfContents":"<ul>\n<li>\n<p><a href=\"#chatgpt-%EC%9D%B4%ED%9B%84-3%EB%85%84\">ChatGPT 이후 3년</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%91%EC%84%B1%EC%9E%90%EC%97%90%EC%84%9C-%EC%9D%98%EC%82%AC%EA%B2%B0%EC%A0%95%EA%B6%8C%EC%9E%90%EB%A1%9C\">작성자에서 의사결정권자로</a></p>\n<ul>\n<li><a href=\"#%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B1%85%EC%9E%84%EC%9D%84-%EC%A7%88-%EC%82%AC%EB%9E%8C%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4\">코드에 대한 책임을 질 사람이 필요하다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#ai-%EC%8B%9C%EB%8C%80%EC%97%90-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%EC%9A%94%EA%B5%AC%EB%90%98%EB%8A%94-%EC%97%AD%EB%9F%89\">AI 시대에 개발자에게 요구되는 역량</a></p>\n<ul>\n<li><a href=\"#%EC%9E%A5%EA%B8%B0-%EB%B3%80%EA%B2%BD-%EB%B9%84%EC%9A%A9%EC%9D%84-%EC%98%88%EC%B8%A1%ED%95%98%EB%8A%94-%EC%97%AD%EB%9F%89\">장기 변경 비용을 예측하는 역량</a></li>\n<li><a href=\"#%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%8B%A4%EA%B0%81%EB%8F%84%EB%A1%9C-%ED%8F%89%EA%B0%80%ED%95%98%EB%8A%94-%EC%97%AD%EB%9F%89\">코드를 다각도로 평가하는 역량</a></li>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%99%94-%EC%97%AD%EB%9F%89\">추상화 역량</a></li>\n<li><a href=\"#%EC%95%94%EB%AC%B5%EC%A7%80%EB%A5%BC-%EB%AA%85%EC%8B%9C%ED%99%94%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%97%AD%EB%9F%89\">암묵지를 명시화할 수 있는 역량</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%98%EB%8F%84%EC%A0%81-%EC%88%98%EB%A0%A8-%EC%84%A4%EA%B3%84%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\">의도적 수련 설계의 필요성</a></p>\n<ul>\n<li><a href=\"#ai%EC%97%90%EA%B2%8C-%EB%84%98%EA%B8%B0%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0-%EB%91%90-%EC%A7%80%EC%A0%90-%EC%84%A4%EA%B3%84%EC%99%80-%EB%A6%AC%EB%B7%B0\">AI에게 넘기지 말아야 할 두 지점: 설계와 리뷰</a></li>\n<li><a href=\"#%EC%9D%98%EB%8F%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A7%81%EC%A0%91-%EC%A7%9C%EB%B3%B4%EB%8A%94-%EC%8B%9C%EA%B0%84\">의도적으로 직접 짜보는 시간</a></li>\n<li><a href=\"#%EB%91%90-%EA%B0%80%EC%A7%80%EB%A5%BC-%EA%B4%80%ED%86%B5%ED%95%98%EB%8A%94-%ED%83%9C%EB%8F%84-%EC%99%9C%EB%A5%BC-%EC%96%B8%EC%96%B4%ED%99%94%ED%95%98%EB%8A%94-%EC%97%B0%EC%8A%B5\">두 가지를 관통하는 태도: “왜”를 언어화하는 연습</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EA%B5%AD-%EB%B3%B8%EC%A7%88%EC%9D%80-%EB%B3%80%ED%95%98%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4\">결국 본질은 변하지 않았다</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 AI 시대에 개발자의 역할이 어떻게 달라지고 있는지, 그리고 무엇을 준비해야 하는지 이야기해보려 한다. 최근 필자가 재직 중인 직장에서도 많은 개발자들이 이 주제에 대해 고민을 하고 있는데, 비단 이 주제는 필자 같은 개발자뿐 아니라 다양한 직군이 함께 고민하는 문제일 것이다.","html":"<p>이번 포스팅에서는 AI 시대에 개발자의 역할이 어떻게 달라지고 있는지, 그리고 무엇을 준비해야 하는지 이야기해보려 한다. 최근 필자가 재직 중인 직장에서도 많은 개발자들이 이 주제에 대해 고민을 하고 있는데, 비단 이 주제는 필자 같은 개발자뿐 아니라 다양한 직군이 함께 고민하는 문제일 것이다.</p>\n<!-- more -->\n<p>공통적으로는 AI로 인한 생산성 향상에 대한 기대와 함께, 대체 가능성에 대한 불안도 동시에 느끼는 것 같다.</p>\n<p>물론 AI로 인해 앞으로의 먼 미래가 어떻게 달라질 것인지에 대해서는 아무도 알지 못할테고, 필자 또한 마찬가지이다. 그래도 아무것도 안할 수는 없으니 필자가 그리는 미래의 개발자의 역할과 모습에 대해서 한번 가볍게 이야기해보려고 한다.</p>\n<h2 id=\"chatgpt-이후-3년\" style=\"position:relative;\">ChatGPT 이후 3년<a href=\"#chatgpt-%EC%9D%B4%ED%9B%84-3%EB%85%84\" aria-label=\"chatgpt 이후 3년 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>처음 ChatGPT가 등장한 2022년 말, 사실 필자는 AI가 이렇게 빠르게 발전할 것이라고는 상상하지 못 했다. 당시에는 할루시네이션 이슈도 많았고 무엇보다 출력의 퀄리티 자체가 그리 좋지 않았기 때문이다.</p>\n<p>하지만 이제 겨우 3년 정도가 지났음에도 불구하고 우리 개발자의 하루는 상당히 많은 부분이 변화했다.</p>\n<p>지금까지의 개발자라는 직업의 정의는 “프로그래밍이라는 행위를 통해 세상의 문제를 해결하는 사람” 정도였던 것 같다. 자연어로 된 요구사항을 분석하고, 설계에 대해 고민하고, 직접 키보드를 타이핑해 구현체를 만들어내는 일련의 과정을 직접 수행했다.</p>\n<p>그래서 불과 몇 년 전까지만 해도 아침에 출근하면 에디터를 열고 빈 파일에 커서를 놓는 것으로 하루를 시작했지만, 최근에는 직접 코딩을 하기보다는 AI에게 맥락을 전달하고, 생성된 코드를 읽고, 고치고, 다시 요청하는 것이 하루의 많은 부분을 차지한다.</p>\n<p>ChatGPT가 처음 등장한 지 3년 남짓한 시간 동안 변화가 워낙 빨랐기에, 나름 휴대폰과 스마트폰의 등장을 모두 겪어본 아재인 필자도 이렇게 빨리 세상이 바뀔 줄은 상상하지 못했다.</p>\n<p>이미 AI 코딩 에이전트의 성능은 단순 보조 수준을 넘어선지 오래다. 프롬프트만 잘 제공하면 함수 하나, 모듈 하나 정도는 사람이 작성한 것과 쉽게 구별하기 어려운 코드를 내놓는다. 이런 환경에서 개발자가 모든 코드를 직접 한 줄씩 작성하는 방식은, 최소한 일부 업무에서는 점점 비효율이 되어가고 있다.</p>\n<p>앞으로 변화 속도는 더 빨라질 가능성이 높다. 그리고 이 과정에서 개발자의 역할도 팀과 조직의 맥락에 따라 다르게 재편될 것이다. 그렇다면 지금 우리는 어떤 방향으로 미래를 준비해야 할까?</p>\n<h2 id=\"작성자에서-의사결정권자로\" style=\"position:relative;\">작성자에서 의사결정권자로<a href=\"#%EC%9E%91%EC%84%B1%EC%9E%90%EC%97%90%EC%84%9C-%EC%9D%98%EC%82%AC%EA%B2%B0%EC%A0%95%EA%B6%8C%EC%9E%90%EB%A1%9C\" aria-label=\"작성자에서 의사결정권자로 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이 질문에 답하려면 먼저 개발 과정에서 우리가 사용하는 시간이 어디에 주로 투자되고 있는지부터 봐야 한다. 예전에는 구현을 위해 직접 타이핑하는 시간이 길었다면 지금은 AI에게 프롬프트로 맥락을 전달하고, 생성된 코드를 읽고 고치고 다시 요청하는 시간이 빠르게 늘어나고 있다.</p>\n<p>즉, 코드를 통해 제품을 생산하는 행위는 직접적인 코드 작성에서 점점 “코드에 대한 판단”으로 이동하고 있다. 여기서 판단이란 단순히 AI 출력이 의도대로 됐는지 확인하는 것이 아니라 비즈니스 의도가 기술적 구현으로 올바르게 번역됐는지 검증하는 과정을 의미한다.</p>\n<p>물론 AI가 계속 발전하면 코드 리뷰조차 인간이 할 필요가 없어질 수 있다고 생각할 수 있겠지만, 필자 생각은 다르다. 그 이유는 기술적 가능성이 아닌 훨씬 더 근본적인 곳에 있다.</p>\n<h3 id=\"코드에-대한-책임을-질-사람이-필요하다\" style=\"position:relative;\">코드에 대한 책임을 질 사람이 필요하다<a href=\"#%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B1%85%EC%9E%84%EC%9D%84-%EC%A7%88-%EC%82%AC%EB%9E%8C%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4\" aria-label=\"코드에 대한 책임을 질 사람이 필요하다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>최근 많은 개발자들이 코드 리뷰에도 AI를 활용하고 있다. 보통 Pull Request에 AI가 코드를 읽어보고 코멘트를 남겨주는 방식으로 작동하는데, 의외로 예리한 부분을 지적하는 경우도 있어서 필자도 가끔 놀란다.</p>\n<p>하지만 필자는 기술이 얼마나 발전하든 결국 최종적인 “문제 없음”이라는 승인 도장을 찍는 인간의 역할은 여전히 존재할 것이라 생각한다.</p>\n<p>그 이유는 바로 이 질문 때문이다.</p>\n<blockquote>\n<p>과연 코드로 인해 문제가 발생했을 때 누가 책임을 지는가?</p>\n</blockquote>\n<p>AI는 법적으로 인격체가 아니기 때문에 책임을 질 수 없다. 그렇다면 AI가 생성한 코드로 인해 문제가 발생했다면 과연 누가 책임을 져야하는 것인지에 대한 질문을 던져볼 필요가 있다.</p>\n<p>만약 AI가 작성한 코드로 인해 결제 로직에 버그가 생겨 고객에게 잘못된 금액이 청구됐을 때 서비스 운영자가 이렇게 답변하면 어떻게 될까?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 268px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6d88ccc76e457cfbd94e60f058a4d6cf/6b6e1/dontknow.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe7lSWD/xAAXEAADAQAAAAAAAAAAAAAAAAAAAREg/9oACAEBAAEFAqLP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGhAAAQUBAAAAAAAAAAAAAAAAAQAQESFBYf/aAAgBAQABPyGmIyTbYEBE8b//2gAMAwEAAgADAAAAEAMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhAAAwEBAQEAAAAAAAAAAAAAAREhADEQUf/aAAgBAQABPxAoAYzdYSrUPjh9wgIEuO4Ub//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"dontknow\" title=\"\" src=\"/static/6d88ccc76e457cfbd94e60f058a4d6cf/6b6e1/dontknow.jpg\" srcset=\"/static/6d88ccc76e457cfbd94e60f058a4d6cf/0913d/dontknow.jpg 160w,\n/static/6d88ccc76e457cfbd94e60f058a4d6cf/6b6e1/dontknow.jpg 268w\" sizes=\"(max-width: 268px) 100vw, 268px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>AI가 작성한거라 전 왜 이렇게 됐는지 모르겠는디요</small>\n</center>\n<p>이딴 답변을 고객이 받아줄리가 없다. 입장바꿔서 생각해보면 아주 복장터지는 일이다.</p>\n<p>아무리 AI가 작성한 코드라고 해도 결국 누군가는 “책임”을 져야한다. 그리고 필자가 생각하기에 그 책임을 져야하는 사람은 바로 그 코드를 리뷰하고 승인한 개발자, 그리고 그 개발자가 속한 조직이다.</p>\n<p>이러한 방향성은 필자의 뇌피셜이 아니라 이미 여러 규제로 나타나고 있다.</p>\n<p>2024년 발효된 EU AI Act는 의료, 금융, 인프라 같은 고위험 영역에서 AI 시스템에 인간 감독을 의무화했다. 시행 자체는 단계적으로 진행 중이지만 방향성 자체는 분명하다. AI가 판단을 내리더라도 이 과정을 인간이 리뷰 가능하도록 만들어야 한다는 원칙을 법으로 못 박은 것이다.</p>\n<p>또한 EU 쪽에서는 제품책임 체계를 디지털 제품/소프트웨어까지 포괄하려는 논의도 이어지고 있다. “AI가 만들었으니 우리 책임이 아니다”는 주장이 법적으로 점점 통하기 어려워지는 방향으로 가고 있는 것이다.</p>\n<p>규제 뿐 아니라 다른 분야에서 나타난 실제 사례들도 보여지고 있다. 자율주행차는 사고가 나면 책임이 제조사와 운전자에게 돌아간다. FDA 승인을 받은 의료 AI 진단 도구도 최종 판단은 의사가 내려야 한다. 2010년 미국 주식시장에서 알고리즘 트레이딩이 연쇄 폭락을 일으킨 Flash Crash 사건에서도 알고리즘을 포함한 자동화 시스템을 운영하는 주체가 규제/집행의 대상이 된다는 걸 보여준다.</p>\n<p>자동화가 고도화될수록 책임 구조는 희미해지는 게 아니라 오히려 더 선명하게 인간 쪽으로 귀속되는 경향이 존재하는 것이다.</p>\n<p>그래서 필자는 앞으로 개발자의 역할이 사라지기보다는 코드를 작성하는 사람에서 “코드를 리뷰하고 승인 도장을 찍는 사람”으로 변화하게 될 것이라 생각한다.</p>\n<p>결국 개발자의 역할이 사라지는 것이 아니라 무게 중심이 이동하는 것에 가깝다. 코드를 생산하는 방법이 달라졌을 뿐, 최종 코드의 품질이 그것을 리뷰하는 개발자의 역량에 달려 있다는 사실은 변하지 않는다. 그렇다면 이 새로운 구조에서 개발자에게 구체적으로 어떤 역량이 필요해지는 걸까?</p>\n<h2 id=\"ai-시대에-개발자에게-요구되는-역량\" style=\"position:relative;\">AI 시대에 개발자에게 요구되는 역량<a href=\"#ai-%EC%8B%9C%EB%8C%80%EC%97%90-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%EC%9A%94%EA%B5%AC%EB%90%98%EB%8A%94-%EC%97%AD%EB%9F%89\" aria-label=\"ai 시대에 개발자에게 요구되는 역량 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>아무래도 AI 시대이니 프롬프트를 잘 다루거나 AI 도구에 능숙한 것이 핵심 역량이 될 것 같지만, 필자 생각은 조금 다르다.</p>\n<p>뭐 요즘에는 “유명한 개발자 누구처럼 짜줘”라고 하면 알아서 해준다고는 하는데, 반대로 생각해보면 그 프롬프트를 작성할 수 있는 누구나 그렇게 짤 수 있다는 말이다. 거기에 어떤 경쟁력이 있는 것일까.</p>\n<p>중요한 것은 그런 프롬프트를 작성하는 것이 아니라, 혹여나 그런 프롬프트를 넣었음에도 불구하고 퀄리티 기준을 충족하지 않는 코드가 출력됐을 경우 문제를 감지할 수 있는 능력이다. 그 프롬프트 넣는다고 무조건 결과물의 퀄리티가 좋은 것은 아닐테니 말이다.</p>\n<p>아이러니하게도, 필자는 AI 시대에 개발자에게 요구되는 역량 또한 지금 좋은 개발자에게 요구되는 역량과 크게 다르지 않을 것이라 생각한다.</p>\n<p>왜냐하면 리뷰 과정 속에서 인간은 이 코드가 런타임에서 큰 문제가 없을지, 장기적인 변화에 대비할 수 있는 코드인지, 빠진 예외처리는 없을지, 정책에 위반되는 코드는 없는지와 같은 고맥락의 체크 리스트를 확인해야하기 때문이다. 그리고 결정적으로 코드에 대해서 최종적으로 승인 도장을 찍는 사람이 존재한다는 것은 여전히 “인간이 이해하기 쉬운 코드”를 작성해야한다는 것을 의미한다.</p>\n<p>만약 인간이 코드를 읽을 필요가 없다면 모든 코드는 기계어로 작성해도 된다. 하지만 만약 이 코드에서 문제가 생기면 여러분이 책임을 져야하는데, 아무리 시대가 발전한다고 해도 그 코드를 읽지도 않고 라이브에 배포할 수 있겠는가?</p>\n<p>이 벽을 넘지 못하는 이상, 결국 인간이 코드를 읽고 이해해야하는 상황은 여전히 발생하기 때문에 인간이 이해하기 쉬운 코드란 무엇일지, 어떻게 하면 그런 코드를 작성할 수 있을지와 같은 지금 시대에 개발자들이 고민하고 있는 내용은 AI 시대에도 반복될 가능성이 높다.</p>\n<h3 id=\"장기-변경-비용을-예측하는-역량\" style=\"position:relative;\">장기 변경 비용을 예측하는 역량<a href=\"#%EC%9E%A5%EA%B8%B0-%EB%B3%80%EA%B2%BD-%EB%B9%84%EC%9A%A9%EC%9D%84-%EC%98%88%EC%B8%A1%ED%95%98%EB%8A%94-%EC%97%AD%EB%9F%89\" aria-label=\"장기 변경 비용을 예측하는 역량 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>최근 링크드인에 올라오는 게시물을 보면, 처음에는 “AI로 이런 거 만들었어요”라는 포스팅만 올라오더니, 요즘에는 간간히 “유지보수가 어려워서 개발자를 고용했습니다”, “기능을 도저히 못 붙히겠어서 접었습니다”와 같은 슬픈 엔딩도 보인다.</p>\n<p>이런 일이 발생하는 이유는 AI가 “작동하는 코드”를 만드는데 최적화되어있기 때문이다. 결국 학습 데이터에서 가장 빈번하게 등장하는 패턴을 재현하는 것이 AI의 동작 방식인데, 그 패턴들은 당연히 정상적으로 실행되는 코드들이다. 하지만 지금 당장 작동하는 코드와 6개월 뒤에도 유지보수가 쉬운 코드는 전혀 다른 기준이다.</p>\n<p>물론 최근 모델은 유지보수성까지 고려한 답을 제시하는 경우도 늘고 있다. 하지만 필자가 말하고자 하는 핵심은 단일 산출물의 품질과 장기 변경 비용 예측이 다른 문제라는 점이다.</p>\n<p>소프트웨어의 품질이라는 건 원래 즉시 드러나지 않는 성질의 것이다. 나쁜 설계의 비용은 코드를 작성한 시점이 아니라, 그 코드를 변경해야 하는 시점에 발생하기 때문이다.</p>\n<h3 id=\"코드를-다각도로-평가하는-역량\" style=\"position:relative;\">코드를 다각도로 평가하는 역량<a href=\"#%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%8B%A4%EA%B0%81%EB%8F%84%EB%A1%9C-%ED%8F%89%EA%B0%80%ED%95%98%EB%8A%94-%EC%97%AD%EB%9F%89\" aria-label=\"코드를 다각도로 평가하는 역량 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>나쁜 설계의 비용이 작성 시점이 아닌 변경 시점에 드러난다는 건 AI 등장 이전에도 마찬가지였지만, 코드 생성 속도가 빨라지면서 이 “지연된 비용”이 쌓이는 속도도 함께 빨라졌다는 게 차이점이다.</p>\n<p>검수의 대상도 다양하다. 단순히 “이 코드가 맞느냐 틀리느냐”와 같은 기능적 정확성은 테스트로 어느 정도 검증할 수 있다. 더 까다로운 건 구조적 품질이다.</p>\n<p>과연 이 모듈의 책임 범위가 적절한가? 이 의존성 방향이 맞는가? 이 인터페이스가 변경에 유연한가? 이런 질문들은 자동화된 테스트로는 잡기 어렵다. 그 너머에는 성능적 함의도 있다. AI가 생성한 코드가 작동은 하지만, 데이터가 10배 늘었을 때도 괜찮을까? 그리고 보안적 측면도 있다. 입력 검증이 충분한가, 권한 확인이 빠져 있지는 않은가. 이 모든 차원을 동시에 고려하면서 코드를 평가하는 건, 단순히 “코드를 읽을 줄 아는 것”과는 다른 수준의 역량이다.</p>\n<p>그리고 AI의 생성 속도가 빨라질수록 이 문제는 더 심각해진다.</p>\n<p>사람이 직접 코드를 작성하던 시절, 코드 생산량에는 물리적 상한이 있었다. 한 개발자가 하루에 만들어낼 수 있는 코드의 양이 제한되어 있었기 때문에, 팀 전체가 검토해야 할 코드의 규모도 그 속도에 맞춰 조절됐다. 생산 속도와 리뷰 역량 사이에 어느 정도의 균형이 자연스럽게 유지됐던 것이다. 물론 느리게 작성한다고 코드가 더 좋아지는 건 아니지만 생산량이 리뷰 역량을 크게 앞지르기 어려운 구조이기는 했다.</p>\n<p>하지만 AI가 수 초 만에 수백 줄의 코드를 생성할 수 있는 환경에서는 코드 생산 속도와 리뷰 역량 사이의 균형이 쉽게 깨질 수 있다.</p>\n<p>특히 리뷰 기준, 병렬 리뷰 체계, 자동화 게이트가 충분하지 않다면 코드 양이 두세 배 늘어도 리뷰 인력과 시간은 그대로라 검증 누락이 생기기 쉽다. 그 결과 기술 부채가 더 빠르게 쌓일 가능성이 커진다. 공장의 생산 라인이 빨라졌는데 품질 검사 체계가 그대로인 상황인 것이다.</p>\n<p>필자는 아마 많은 회사들이 AI를 도입했음에도 생산성 증가를 못 느끼는 이유가 이것이 아닐까 생각한다. 코드 생산은 빨라졌을지 몰라도 AI가 뱉은 코드를 리뷰하는 과정이 제일 병목이다.</p>\n<p>이 구조에서 코드를 제대로 빠르게 검수할 수 있는 개발자의 가치는 자연스럽게 올라간다. AI가 쏟아내는 코드의 양이 많아질수록 그 코드에 섞인 잠재적 위험과 기술 부채를 선별할 수 있는 사람의 필요성이 커지기 때문이다.</p>\n<h3 id=\"추상화-역량\" style=\"position:relative;\">추상화 역량<a href=\"#%EC%B6%94%EC%83%81%ED%99%94-%EC%97%AD%EB%9F%89\" aria-label=\"추상화 역량 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자는 추상화 역량도 중요한 포인트 중 하나라고 생각한다. 결국 추상화란 복잡한 시스템에서 무엇을 감추고 무엇을 드러낼지, 그리고 어디에 경계를 그을지 결정하는 능력이다.</p>\n<p>AI가 추상화를 못하느냐고 물으면 솔직히 그건 아니다. AI도 인터페이스를 정의하고 클래스를 나누고 모듈을 분리할 수 있다. 사실 형식적인 측면에서는 필자보다 잘 하는 경우도 있다. 하지만 AI가 만드는 추상화와 숙련된 개발자가 만드는 추상화 사이에는 결정적인 차이가 하나 있다.</p>\n<p>AI의 추상화는 학습 데이터의 통계적 평균에 기반한다. 수많은 프로젝트에서 본 “그럴듯한 패턴”을 현재 상황에 적용하는 방식이다. 하지만 실제 소프트웨어 설계는 정답을 맞히는 게임이 아니라, 한정된 자원과 불확실한 미래 속에서 무엇을 포기할지 결정하는 트레이드오프의 영역이다.</p>\n<p>AI는 코드 내부의 정합성을 맞추는 데 능숙할지 몰라도 코드 외부의 맥락까지 고려하여 “어디에 경계를 그을지” 결정하는 것은 어려워한다. 특정 맥락에서 최적인 코드는 통계적 평균 너머의 전략적 판단이 개입될 때 비로소 완성되기 때문이다.</p>\n<p>이건 AI의 결함이라기보다는 통계적 학습이라는 방식 자체가 가진 구조적 한계에 가깝다. 평균적으로 좋은 코드를 만들 수는 있지만, 특정 맥락에서 최적인 코드를 만드는 건 다른 문제다.</p>\n<p>AI가 출력한 코드의 위험한 점은 겉보기에 좋아 보인다는 것이다. 코드 리뷰에서도 쉽게 통과할 수 있다. 파일이 적절히 나뉘어 있고, 네이밍도 관례를 따르고, 패턴도 익숙하기 때문이다. 문제는 실제로 변경이 필요한 시점에 발견된다. 결제 수단을 하나 추가하려고 하는데, “깔끔하게 나뉘어 있던” 구조의 여기저기를 동시에 수정해야 한다는 걸 그제야 깨닫게 되는 것이다. 이런 종류의 결함은 코드를 쓸 때가 아니라 코드를 고칠 때 드러난다.</p>\n<p>AI가 만든 코드에서 이런 패턴은 꽤 자주 발견된다. 통계적으로 가장 흔한 구조를 따랐기 때문에 표면적으로는 나무랄 데가 없지만, 실제 요구사항과 어긋나 있는 경우가 적지 않다.</p>\n<p>또 다른 예로, 프론트엔드에서 흔히 보이는 상황을 생각해보자. AI에게 대시보드 컴포넌트를 만들어달라고 하면, 보통은 하나의 거대한 컴포넌트 안에 데이터 페칭, 상태 관리, UI 렌더링을 모두 담은 구조를 내놓는다. 혹은 반대로 학습 데이터에서 본 모범 사례를 과하게 적용해서, 간단한 차트 하나를 그리기 위해 커스텀 훅 세 개와 컨텍스트 프로바이더를 만들어놓기도 한다.</p>\n<p>전자는 추상화가 부족한 것이고, 후자는 추상화가 과잉인 것이다. 둘 다 현재 프로젝트의 복잡도 수준에 맞지 않는다는 점에서는 같은 문제다. 적절한 추상화란 결국 현재 상황에서 딱 필요한 만큼의 구조를 만드는 것이고, 이 “만큼”을 판단하는 건 맥락을 아는 사람만 할 수 있다.</p>\n<p>숙련된 개발자는 이런 코드를 읽을 때 “여기서 이렇게 나눈 건 이 도메인의 특성을 모르고 한 거구나”라는 걸 알아채고 도메인에 맞는 경계를 다시 긋는다. 이 과정에서 동원되는 건 코딩 스킬이 아니라 시스템에 대한 이해와 설계에 대한 감각이다.</p>\n<p>즉, AI가 만든 코드를 평가할 때도 사람이 만든 코드를 평가할 때와 동일한 기준이 적용된다. “이 추상화가 실제로 복잡도를 줄이고 있는가, 아니면 추적해야 할 간접 경로만 늘리고 있는가?” 이 질문을 던질 수 있는 것 자체가 이미 하나의 역량이다.</p>\n<h3 id=\"암묵지를-명시화할-수-있는-역량\" style=\"position:relative;\">암묵지를 명시화할 수 있는 역량<a href=\"#%EC%95%94%EB%AC%B5%EC%A7%80%EB%A5%BC-%EB%AA%85%EC%8B%9C%ED%99%94%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%97%AD%EB%9F%89\" aria-label=\"암묵지를 명시화할 수 있는 역량 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>추상화 역량이 “어디에 경계를 그을지 아는 것”이라면, 암묵지를 명시화하는 역량은 “왜 거기에 경계를 그어야 하는지 설명할 수 있는 것”이다. 서로 다른 능력이지만 실제로는 함께 작동한다.</p>\n<p>좋은 코드와 나쁜 코드를 구분하는 감각은 코드를 많이 읽고 쓰면서 자연스럽게 체득하게된다. 보통 “뭔가 이상한데”라는 직감으로 시작되는 암묵지는 언어로 명확하게 설명하기가 꽤나 어렵다.</p>\n<p>그런데 이 암묵지를 언어로 만드는 능력이 AI 시대에 특히 중요해진다. “뭔가 이상한데”라는 직감을 “이 함수는 두 가지 책임을 가지고 있다”, “이 인터페이스가 변경에 취약하다”는 구체적인 언어로 바꿀 수 있어야 AI에게 올바른 명령을 내릴 수 있기 때문이다.</p>\n<p>다만 여기서 말하는 건 few-shot 예시나 chain-of-thought 같은 형식적인 프롬프트 기법이 아니다. 어차피 그런 것들은 모델이 발전하면서 자연스럽게 희석된다.</p>\n<p>필자가 이야기하고 싶은 건 그 아래에 있는 능력, 즉 무엇을 만들어야 하는지 명확하게 정의하고, 어떤 맥락이 중요한지 판단해서 전달하는 것이다.</p>\n<p>대충 “이걸 만들어줘”라고 말할 수 있는 사람은 많다. 하지만 개발자는 AI가 뱉은 코드의 문제점을 정확하게 파악하고 “이걸 이런 방식이 아니라 저런 방식으로 만들어야 하는 이유”를 설명할 수 있는 사람이 되어야한다.</p>\n<p>“뭔가 이상한 코드”를 보고 그 이유를 구체적으로 알고 말할 수 있는 것이 곧 개발자의 설계 역량이 될 것이다. 즉, 시스템과 코드에 대한 이해가 깊을수록, AI에게 더 구체적이고 더 정확한 지시를 내릴 수 있다.</p>\n<p>메모리를 직접 다루지 않아도 메모리 모델을 이해해야 성능 문제를 해결할 수 있듯이, 코드를 직접 작성하지 않아도 추상화를 이해해야 설계 문제를 잡아낼 수 있다. 추상화의 계층이 하나 더 생겼을 뿐, 추상화를 다루는 능력의 필요성 자체는 사라지지 않았다.</p>\n<p>이 역량들의 유효기간은 도구 숙련도보다 훨씬 길다. 도구 숙련도의 수명은 도구의 교체 주기에 묶여 있다. jQuery가 React에 밀리는 데 몇 년이 걸렸고, Webpack이 Vite에 밀리는 데 또 몇 년이 걸렸다. 반면 설계 판단과 암묵지 언어화 역량의 수명은 소프트웨어의 본질적 복잡성이 존재하는 한 유효하다.</p>\n<p>이 복잡성은 도구가 바뀌어도 사라지지 않는다. 결제 시스템이 복잡한 이유는 프레임워크 때문이 아니라 결제 도메인 자체가 복잡하기 때문이고, 그 복잡성을 다루는 감각은 특정 도구에 종속되지 않는다.</p>\n<h2 id=\"의도적-수련-설계의-필요성\" style=\"position:relative;\">의도적 수련 설계의 필요성<a href=\"#%EC%9D%98%EB%8F%84%EC%A0%81-%EC%88%98%EB%A0%A8-%EC%84%A4%EA%B3%84%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"의도적 수련 설계의 필요성 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여기까지 읽으면 자연스럽게 떠오르는 질문이 하나 있다. 코드를 직접 작성하는 시간이 줄어드는데, 도대체 추상화나 설계 감각은 어떻게 기르라는 걸까?</p>\n<p>이건 “도구가 할 수 없는 것에 집중하라”고 말하면서 정작 그것을 기를 기회가 줄어드는 모순적인 상황이다.</p>\n<p>해법은 두 층으로 나뉜다. 하나는 업무 흐름 안에서 AI에게 넘기지 말아야 할 두 지점을 지키는 것이고, 다른 하나는 그 판단력의 바탕이 되는 설계 감각을 업무 밖에서 의도적으로 유지하는 것이다. 그리고 이 두 가지를 관통하는 태도가 하나 있다.</p>\n<h3 id=\"ai에게-넘기지-말아야-할-두-지점-설계와-리뷰\" style=\"position:relative;\">AI에게 넘기지 말아야 할 두 지점: 설계와 리뷰<a href=\"#ai%EC%97%90%EA%B2%8C-%EB%84%98%EA%B8%B0%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0-%EB%91%90-%EC%A7%80%EC%A0%90-%EC%84%A4%EA%B3%84%EC%99%80-%EB%A6%AC%EB%B7%B0\" aria-label=\"ai에게 넘기지 말아야 할 두 지점 설계와 리뷰 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>평소 업무 흐름 안에서 AI에게 넘기지 말아야 할 지점이 두 군데 있다. 바로 코드 작성 앞단의 설계와 뒷단의 리뷰다.</p>\n<p>설계를 직접 하는 것은 단순한 습관의 문제가 아니다. 프롬프트를 치기 전에 “이 모듈이 외부에 노출할 인터페이스는 무엇인가”, “책임의 경계는 어디에 그을 것인가”를 먼저 정의하는 과정을 거치고 구현을 AI에게 위임하면, AI가 만들어낸 결과물을 자신의 설계 결정과 비교할 수 있게 된다.</p>\n<p>AI가 다른 구조를 선택했다면 왜 그랬는지 분석하게 되고, 내가 놓친 것은 없는지, AI가 틀린 것은 아닌지 다시 생각하게 된다. 만약 이 과정이 부재한다면 단순히 AI가 출력한 코드를 소비하게 될 가능성이 높은데, 단순히 출력을 소비하는 것과 자신의 판단을 기준으로 출력을 평가하는 것은 완전히 다른 경험이다.</p>\n<p>또한 리뷰는 의도적으로 시간을 따로 내지 않아도 업무 흐름 안에서 자동으로 주어지는 역량 성장 기회다. 그렇기 때문에 이 기회를 그냥 흘려보내는 것이 가장 위험하다.</p>\n<p>AI에게 PR 리뷰를 맡기고 별다른 문제가 없으면 그냥 승인해버리는 습관은 마치 체육 시간에 운동장에 나가서 벤치에만 앉아 있다가 들어오는 것과 같다. 업무 자체는 어찌어찌 진행할 수 있겠지만, 그렇게 몇 년을 일을 해도 실력은 그대로일 가능성인 높다.</p>\n<p>코드 리뷰는 요구사항, 설계 의도, 비즈니스 맥락을 동시에 고려하면서 코드를 읽는 과정이고, 이 과정 자체가 설계 감각을 유지하는 훈련이라고 생각해야한다.</p>\n<h3 id=\"의도적으로-직접-짜보는-시간\" style=\"position:relative;\">의도적으로 직접 짜보는 시간<a href=\"#%EC%9D%98%EB%8F%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A7%81%EC%A0%91-%EC%A7%9C%EB%B3%B4%EB%8A%94-%EC%8B%9C%EA%B0%84\" aria-label=\"의도적으로 직접 짜보는 시간 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>업무 안에서 설계와 리뷰를 직접 한다고 해서 충분한 건 아니다. 설계 감각 자체가 구현의 고통을 알아야 생기기 때문이다. 어떤 구조가 변경에 취약한지를 직접 손으로 겪어봐야 “이 추상화가 잘못됐다”는 직감이 생긴다. 겪어보지 못한 고통은 감각으로 남지 않는다.</p>\n<p>주니어 개발자의 경우 특히 그렇다. 경험이 적은 상태에서 AI가 생성한 코드를 리뷰하는 건, 아직 운전을 배우는 중인 사람에게 자율주행차의 판단을 평가하라고 하는 것과 비슷한 면이 있다. 직접 핸들을 잡아봐야 도로 위의 감각이 생기는 것처럼 직접 코드를 짜봐야 구조에 대한 감각이 생긴다.</p>\n<p>미래의 개발자에게 코딩하는 역량은 매일 하는 업무가 아니라 판단력을 유지하기 위한 훈련이 될 가능성이 높다고 본다. <small>(아마 주니어 시절의 고통스러운 직접 구현 경험은 선택이 아니라 리뷰어로서 면허를 따는 과정 정도가 되지는 않을까.)</small></p>\n<p>그래서 사이드 프로젝트나 개인 학습에서는 의도적으로 AI를 내려놓고 처음부터 끝까지 직접 구현해보는 시간을 만드는 게 좋다.</p>\n<p>AI가 편리할수록 그 마찰이 귀찮게 느껴지지만 그 마찰과 고통을 겪어야 빠른 실력 향상이 생길 것이라고 생각한다. 그리고 구현이 막히는 지점이나 리팩토링을 해야 하는 순간이 깨달음을 얻을 수 있는 순간이다.</p>\n<h3 id=\"두-가지를-관통하는-태도-왜를-언어화하는-연습\" style=\"position:relative;\">두 가지를 관통하는 태도: “왜”를 언어화하는 연습<a href=\"#%EB%91%90-%EA%B0%80%EC%A7%80%EB%A5%BC-%EA%B4%80%ED%86%B5%ED%95%98%EB%8A%94-%ED%83%9C%EB%8F%84-%EC%99%9C%EB%A5%BC-%EC%96%B8%EC%96%B4%ED%99%94%ED%95%98%EB%8A%94-%EC%97%B0%EC%8A%B5\" aria-label=\"두 가지를 관통하는 태도 왜를 언어화하는 연습 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>업무에서 설계와 리뷰를 직접 하든, 따로 시간을 내서 직접 짜든 이 두 가지 모두에서 작동해야 하는 태도가 있다. 바로 “뭔가 이상한데”라는 직감이 드는 순간 그 감각을 그냥 넘기지 않고 왜 그렇게 느꼈는지 명확한 말로 표현할 수 있을 때까지 다듬는 것이다.</p>\n<p>“이상한데”에서 멈추면 그냥 직감에서 끝나버리지만, “이 함수가 두 가지 책임을 가지고 있다”까지 가면 언어가 된다. 직감은 나만 아는 것이고 언어는 쓸 수 있는 것이다. 언어가 되어야 AI에게 정확한 지시를 내릴 수 있고, 팀원에게 설명할 수 있고, 다음에 비슷한 패턴을 만났을 때 알아챌 수 있다.</p>\n<p>AI가 만들어낸 코드가 작동한다고 해서 거기서 멈추지 않고, “왜 이 구조를 선택했을까”, “다른 구조였다면 어떤 트레이드오프가 있었을까”를 스스로에게 물어보는 것. 이 습관이 있는 개발자와 없는 개발자 사이의 격차는 시간이 갈수록 벌어질 것이다.</p>\n<h2 id=\"결국-본질은-변하지-않았다\" style=\"position:relative;\">결국 본질은 변하지 않았다<a href=\"#%EA%B2%B0%EA%B5%AD-%EB%B3%B8%EC%A7%88%EC%9D%80-%EB%B3%80%ED%95%98%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4\" aria-label=\"결국 본질은 변하지 않았다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>AI의 등장으로 개발자의 역할이 코드 작성자에서 리뷰어로 이동하고 있다. 생산과 검수를 모두 인간이 하던 시대에서 생산은 AI가 하고 검수는 인간이 담당하는 시대로 변화하고 있는 것이다.</p>\n<p>그리고 이러한 변화가 기술적 한계가 아닌 책임 소재라는 사회적 문제에서 비롯된다는 걸 이해하면 역할 전환의 의미가 더 명확해진다.</p>\n<p>결국 필자는 리뷰 승인이라는 도장을 잘 찍으려면 작동하는 코드와 오래 살아남는 코드를 구분하는 눈, 맥락에 맞는 추상화를 판단하는 설계 감각, 그 감각을 언어로 만들어 정확한 방향을 잡는 역량이 필요해질 것이라 생각한다.</p>\n<p>즉, AI 시대의 차이는 생산량이 아니라 누가 맥락을 이해하고 책임 있게 승인하느냐에서 난다. 시대는 변화했지만 결국 개발자라는 사람이 책임져야하는 영역이 코드의 퀄리티라는 사실은 변하지 않는 것이다.</p>\n<p>AI가 이전 도구들과 근본적으로 다른 것은 사실이다. 농기구나 기계와 달리 AI는 스스로 추론하고 생성한다. “AI도 그냥 또 하나의 도구야”라는 식의 주장이 설득력을 잃는 건 당연하다. 그렇다면 왜 요구되는 역량이 바뀌지 않는다고 할 수 있을까.</p>\n<p>논리는 책임에서 시작한다. 책임을 진다는 건 판단을 한다는 뜻이고, 판단의 질은 코드의 구조적 건강함을 알아보는 눈, 도메인에 맞는 추상화를 구분하는 감각, 장기 변경 비용을 예측하는 능력에서 온다. 이것들이 항상 좋은 개발자와 평범한 개발자를 갈랐던 것들이다.</p>\n<p>프레드 브룩스(Fred Brooks)는 1986년에 소프트웨어의 복잡성을 두 가지로 나눴다. 우발적 복잡성은 도구의 한계에서 오는 것이고, 본질적 복잡성은 문제 자체에 내재된 것이다. AI가 해결하는 건 우발적 복잡성이다. 보일러플레이트, 반복 패턴, 문법 오류 같은 것들. 하지만 비즈니스 요구사항의 모호함, 상충하는 설계 목표 사이의 균형, 미래 변경 방향에 대한 불확실성 같은 본질적 복잡성은 AI가 아무리 발전해도 사라지지 않는다. 이 복잡성은 도구의 수준이 아니라 문제 자체의 성격에서 온다.</p>\n<p>그래서 AI의 성격이 이전 도구들과 달라도 인간이 판단과 책임의 주체로 남아 있는 한 그 판단에 필요한 역량의 본질은 바뀌지 않는다. 필자는 오히려 코드 생산이 자동화될수록 그 생산물을 검수하는 판단력의 비중이 오히려 부각될 것이라 생각한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 567px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cfed549021f0c0b30f757fa171543e0e/a7172/buffett.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 64.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAgADBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeYyjCUf/8QAGxAAAgIDAQAAAAAAAAAAAAAAAhEBAwAQEjL/2gAIAQEAAQUC5WGtCcs7FNnv/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAgMAAAAAAAAAAAAAAAAAABARITH/2gAIAQEABj8CtwYv/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARIUExYf/aAAgBAQABPyE467sWTrE+ysYV5LIIWp//2gAMAwEAAgADAAAAEKQP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHRABAAICAgMAAAAAAAAAAAAAAQARIUExUaGx8P/aAAgBAQABPxDEcgNGGLqrkx1qJeFUEoYj7cYsU4WvVRSnYPif/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"buffett\" title=\"\" src=\"/static/cfed549021f0c0b30f757fa171543e0e/a7172/buffett.jpg\" srcset=\"/static/cfed549021f0c0b30f757fa171543e0e/0913d/buffett.jpg 160w,\n/static/cfed549021f0c0b30f757fa171543e0e/cb69c/buffett.jpg 320w,\n/static/cfed549021f0c0b30f757fa171543e0e/a7172/buffett.jpg 567w\" sizes=\"(max-width: 567px) 100vw, 567px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>필자와 함께 일하는 코치 중 한 분은 이 상황을 빗대어<br>\n  \"물이 빠지면 비로소 누가 발가벗고 수영을 하고 있었는지 알 수 있을 것\"이라고 했는데<br>\n  아주 찰떡인 비유인 것 같다.\n  </small>\n</center>\n<p>그래서 필자는 최근 많은 사람들이 AI라는 도구를 잘 깎는 것에 집중하는 것을 보면서 뭔가 조금 이상하다는 생각을 했었다.</p>\n<p>불과 1년 전만해도 프롬프트 엔지니어링이 굉장히 중요한 화두였지만 지금은 그 얘기는 쏙 들어가고 스킬, 병렬 에이전트, 팀과 같은 기능들에 대한 이야기가 오간다. 아마 6개월만 지나도 이 키워드들도 쏙 들어갈 것이다.</p>\n<p>어차피 AI는 길가는 초등학생이 프롬프트를 갈겨도 제대로된 출력을 낼 수 있는 수준까지 발전할텐데, 지금 도구를 잘 사용하는 방법에 집중하는 것이 정말 옳은 방향일까? 오히려 필자는 도구를 잘 깎는 것에만 집중하면 도태되기 쉬워지지는 않을까 하는 생각을 가지고 있다.</p>\n<p>물론 필자가 그리는 미래가 실제로 그렇게 펼쳐질지는 모른다. AI가 어느 방향으로 얼마나 빠르게 발전할지 정확히 아는 사람은 없고, 필자도 예외가 아니다. 이 글도 결국 불확실한 미래를 앞에 두고 한 명의 개발자가 지금 할 수 있는 생각을 정리해본 것일 뿐이다.</p>\n<p>정답은 없지만, 물이 빠지는 속도 만큼은 분명히 빨라지고 있다. 이 글을 읽는 독자 분들도 물이 빠졌을 때 발가벗고 수영을 하고 있는 사람이 되지 않도록 최선을 다해 각자만의 답을 찾아보기를 바란다.</p>","fields":{"slug":"20260210-developer-in-ai-era","path":"/2026/02/10/developer-in-ai-era/","lang":"ko"},"frontmatter":{"title":"AI가 코드를 쓰는 시대, 개발자의 진짜 역량이 드러난다","subTitle":"물이 빠지면 누가 발가벗고 수영했는지 알 수 있다","date":"Feb 10, 2026","categories":["에세이"],"tags":["AI","개발자","추상화","소프트웨어 설계","커리어"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/669d1ffce728369397df91471ecb0088/d803c/thumbnail.png","srcSet":"/static/669d1ffce728369397df91471ecb0088/d803c/thumbnail.png 320w,\n/static/669d1ffce728369397df91471ecb0088/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/669d1ffce728369397df91471ecb0088/fc5c5/thumbnail.webp 320w,\n/static/669d1ffce728369397df91471ecb0088/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/669d1ffce728369397df91471ecb0088/01fb2/thumbnail.png","srcSet":"/static/669d1ffce728369397df91471ecb0088/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/669d1ffce728369397df91471ecb0088/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"39c07b0e-5478-5f00-a4c3-f14c55d64a05","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%B3%B5%EC%9E%A1%ED%95%9C-%EA%B2%83%EC%9D%84-%EB%8B%A8%EC%88%9C%ED%95%98%EA%B2%8C-%ED%91%9C%ED%98%84%ED%95%98%EC%9E%90\">복잡한 것을 단순하게 표현하자</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%99%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90-%EC%B6%94%EC%83%81%ED%99%94%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C\">왜 프로그래밍에 추상화가 필요할까?</a></p>\n<ul>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%99%94%EB%8A%94-%EB%8D%94-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EA%B2%83%EC%9D%84-%EB%A7%8C%EB%93%A4-%EC%88%98-%EC%9E%88%EA%B2%8C-%ED%95%B4%EC%A4%80%EB%8B%A4\">추상화는 더 복잡한 것을 만들 수 있게 해준다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B3%B5%ED%86%B5%EC%A0%90%EC%9D%84-%EB%BD%91%EC%95%84%EB%82%B4%EB%8A%94-%EC%B6%94%EC%83%81%ED%99%94-%EB%B0%A9%EB%B2%95%EC%97%90%EC%84%9C-%EB%B2%97%EC%96%B4%EB%82%98%EB%B3%B4%EC%9E%90\">공통점을 뽑아내는 추상화 방법에서 벗어나보자</a></p>\n<ul>\n<li><a href=\"#%ED%98%84%EC%9E%AC%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD%EC%9D%84-%EB%84%88%EB%AC%B4-%EC%B6%A9%EC%8B%A4%ED%95%98%EA%B2%8C-%EB%B0%98%EC%98%81%ED%95%98%EB%8A%94-%EC%84%A4%EA%B3%84\">현재의 요구사항을 너무 충실하게 반영하는 설계</a></li>\n<li><a href=\"#%EC%99%9C-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EB%90%98%EC%97%88%EC%9D%84%EA%B9%8C\">왜 이렇게 되었을까?</a></li>\n<li><a href=\"#%EC%B6%94%EC%83%81%EC%A0%81%EC%9D%B8-%EA%B2%83%EB%93%A4%EC%9D%84-%ED%95%A9%EC%84%B1%ED%95%98%EC%97%AC-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%EA%B2%83%EC%9D%84-%EB%A7%8C%EB%93%A4%EA%B8%B0\">추상적인 것들을 합성하여 구체적인 것을 만들기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A2%8B%EC%9D%80-%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%9C%84%ED%95%B4-%EA%B3%A0%EB%AF%BC%ED%95%B4%EB%B3%BC%EB%A7%8C%ED%95%9C-%EA%B2%83%EB%93%A4\">좋은 추상화를 위해 고민해볼만한 것들</a></p>\n<ul>\n<li><a href=\"#%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%EA%B3%BC%ED%95%9C-%EB%A7%A5%EB%9D%BD%EC%9D%84-%EB%B6%80%EC%97%AC%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0\">개발자에게 과한 맥락을 부여하지 않기</a></li>\n<li><a href=\"#%ED%91%9C%ED%98%84%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EA%B3%A0%EB%AF%BC%ED%95%98%EA%B8%B0\">표현에 대해서 고민하기</a></li>\n<li><a href=\"#%EC%9E%85%EB%A0%A5%EC%9D%98-%EC%9E%90%EC%9C%A0%EB%8F%84%EB%A5%BC-%EC%A0%9C%EC%96%B4%ED%95%B4%EC%84%9C-%EC%A2%8B%EC%9D%80-dx-%EB%A7%8C%EB%93%A4%EA%B8%B0\">입력의 자유도를 제어해서 좋은 DX 만들기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 추상(Abstraction)에 대한 이야기를 한번 해보려고 한다. 추상화는 비단 어플리케이션 설계 뿐만 아니라 컴퓨터 공학 전체에서 굉장히 중요한 자리를 차지하고 있는 개념이지만, 애초에 추상이라는 개념 자체도 워낙 추상적이라 이제 갓 개발을 시작한 많은 개발자들은 이 개념을 이해하는데 많은 혼란을 겪고는 한다. 이 추상이라는 개념은 복잡한 구조의 무언가를 만들어야 할 때 특히 빛을 발하는 개념이기 때문에, 거대하고 복잡한 어플리케이션을 설계할 때는 반드시 알고 있어야하는 개념이기도 하다.","html":"<p>이번 포스팅에서는 추상(Abstraction)에 대한 이야기를 한번 해보려고 한다. 추상화는 비단 어플리케이션 설계 뿐만 아니라 컴퓨터 공학 전체에서 굉장히 중요한 자리를 차지하고 있는 개념이지만, 애초에 추상이라는 개념 자체도 워낙 추상적이라 이제 갓 개발을 시작한 많은 개발자들은 이 개념을 이해하는데 많은 혼란을 겪고는 한다.</p>\n<p>이 추상이라는 개념은 복잡한 구조의 무언가를 만들어야 할 때 특히 빛을 발하는 개념이기 때문에, 거대하고 복잡한 어플리케이션을 설계할 때는 반드시 알고 있어야하는 개념이기도 하다.</p>\n<!-- more -->\n<p>필자가 예전에 작성했던 <a href=\"/2019/08/24/what-is-object-oriented-programming/#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B2%83%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%9D%98%EB%AF%B8%ED%95%98%EB%82%98%EC%9A%94\">알고 보면 재밌는 객체 지향 프로그래밍, OOP 흝어보기</a> 포스팅과 <a href=\"/2019/12/15/about-functional-thinking/\">기존의 사고 방식을 깨부수는 함수형 사고</a> 포스팅에서 간단하게 추상화에 대해 언급하기는 했지만, 추상이라는 개념이 꼭 OOP에만 국한된 개념이 아니기도 하고 포스팅의 메인 주제와는 다른 주제라 해당 포스팅들에서는 추상 자체에 대해 자세히 이야기하지 못 했던 것 같다.</p>\n<p>많은 분들이 추상화를 “공통된 부분을 추려내는 것”이라고만 인지하고 있는 경우가 많다. 물론 엄밀히 이야기하면 틀린 말은 아니지만, 사실 이건 추상적인 무언가를 정의하기 위해 수행하는 구체적인 추상화 스킬 중 하나일 뿐이지 추상이라는 것의 본질이 무엇인지를 설명해주는 것은 아니다.</p>\n<p>만약 이런 개념으로부터 추상을 이해하려고 한다면, 누군가가 여러분에게 “프로그래밍에서 추상화가 왜 필요해요?”와 같은 질문을 했을 때, “공통적인 부분을 뽑아내서 재사용성을 높힐 수 있습니다”와 같이 지엽적인 답변을 할 수 밖에 없게 되는 것이다. <small><del>(사실 필자가 면접 때 자주 물어본다)</del></small></p>\n<p>즉, 추상이라는 개념을 제대로 이해하기 위해서는 우선 프로그래밍에서 설명하는 추상화의 개념에서 벗어나, 본질적으로 추상이라는 것이 무엇인지, 그리고 이런 개념이 왜 필요한지에 대한 고민을 밑바닥부터 해보는 것이 중요하다.</p>\n<h2 id=\"복잡한-것을-단순하게-표현하자\" style=\"position:relative;\">복잡한 것을 단순하게 표현하자<a href=\"#%EB%B3%B5%EC%9E%A1%ED%95%9C-%EA%B2%83%EC%9D%84-%EB%8B%A8%EC%88%9C%ED%95%98%EA%B2%8C-%ED%91%9C%ED%98%84%ED%95%98%EC%9E%90\" aria-label=\"복잡한 것을 단순하게 표현하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 그렇다면 가장 근본적인 것부터 한번 고민해보도록 하자. 추상이라는 것은 도대체 무엇일까?</p>\n<p>여러분도 아시다시피 추상이라는 용어 자체는 프로그래밍의 세계에서만 사용되는 것은 아니다. 사실 이 용어는 프로그래밍이나 수학에서도 사용되기는 하지만, 미술이나 건축에서도 많이 사용되는 용어이며, 대표적인 추상파 화가로는 그 유명한 피카소 형이 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 560px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d79c5756053bcba4a159e4af28a84bb6/9342c/optimize.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAQFAgP/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB6tTmYZBgo//EABoQAAIDAQEAAAAAAAAAAAAAAAECAwQTABL/2gAIAQEAAQUCrhcfKddAE8Mi46r1pg8v/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAHRAAAQQCAwAAAAAAAAAAAAAAAAECESEyUTGRof/aAAgBAQAGPwJktTjRg3opIoakmXhKaP/EABwQAQACAQUAAAAAAAAAAAAAAAEAETFBUWGR8f/aAAgBAQABPyG3JdwngJUCFcEIoiGozjdpeWyk/9oADAMBAAIAAwAAABDEP//EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAwEBPxCYr//EABcRAAMBAAAAAAAAAAAAAAAAAAABETH/2gAIAQIBAT8QdosP/8QAHRABAAICAgMAAAAAAAAAAAAAAQARUYEhMUFh8P/aAAgBAQABPxB7mC1C7i4/dqBrEKIL5xK0AUV59RI51w6iAukzmf/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"optimize\" title=\"\" src=\"/static/d79c5756053bcba4a159e4af28a84bb6/9342c/optimize.jpg\" srcset=\"/static/d79c5756053bcba4a159e4af28a84bb6/0913d/optimize.jpg 160w,\n/static/d79c5756053bcba4a159e4af28a84bb6/cb69c/optimize.jpg 320w,\n/static/d79c5756053bcba4a159e4af28a84bb6/9342c/optimize.jpg 560w\" sizes=\"(max-width: 560px) 100vw, 560px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>소의 복잡한 부분을 전부 제거하고 가장 핵심적인 특징만을 나타낸 피카소의 그림</small>\n</center>\n<p>이런 모습에서도 알 수 있듯이 추상화가 된 대상은 현실의 대상보다 그 대상의 본질, 조금 더 쉽게 이야기하면 각각의 디테일한 특징이 배제되어 대상 자체를 표현하는 특징들이 강화된다.</p>\n<p>피카소가 그린 소 그림은 “소”라는 본질만 가지고 있다면, 모두 대응이 가능한 표현이다. 젖소든, 한우든, 황소든 간에 저 형태에서 크게 벗어나는 소는 없다는 이야기이다. 현실에서 이 소들은 각각 다른 모습을 가지고 있지만, 다리가 4개 달리고 머리에 뿔이 있다는, 소라는 것이 가지는 본질적인 형태에서는 크게 벗어나지 않는다.</p>\n<p>마치 인간 개개인의 생김새, 목소리, 성격 등은 모두 다르지만, 결국 기본적으로 팔 2개, 다리 2개, 머리가 1개 달린 형태라는 것은 변하지 않는 것처럼 말이다. 이것이 바로 그 대상이 가지는 본질이다.</p>\n<p>또한 이렇게 대상의 본질만을 표현하고 디테일한 요소들을 배제하면 표현이 단순해질 수 밖에 없다. 100개의 세세한 특징을 표현한 것보다 10개의 핵심적인 특징만을 표현한 것이 더 단순한 것은 당연하다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 394px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7a4c375ac990f976ecd9ebcade7cc3b3/cc097/zolaman.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 108.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAABAElEQVR42s2V2QqEMAxF/f+/89EPcF/rjluGW4gMjG1t9WECwVDhcJutHhnsOI7LWGUevWxa4L7vVNc1JUlCaZrKGGdOwHVdKYoi6rpOXhXetq0827bNHghF4zj+5K7ve8rz3A4IBQCqioIUqAp0CZznmYqiUFbdGgiL4/jMFQrBAMT4Z53Dpmkuc5VlmSyOqi+1bcNQOFIAF0I860Mo8n2fgiCQsWlatEAoQoGqqpJftFFZlu5AVgPwMAzvjB4MqqZpurUgbilEm/BVHwFZJeY3DEPjYtACWQmUYX7hPD06lVqFy7KcM80LA2fOV8bofa8qrDTnfWh6Dv7jCXABfgBbGs0YyiN/PwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"zolaman\" title=\"\" src=\"/static/7a4c375ac990f976ecd9ebcade7cc3b3/cc097/zolaman.png\" srcset=\"/static/7a4c375ac990f976ecd9ebcade7cc3b3/69538/zolaman.png 160w,\n/static/7a4c375ac990f976ecd9ebcade7cc3b3/72799/zolaman.png 320w,\n/static/7a4c375ac990f976ecd9ebcade7cc3b3/cc097/zolaman.png 394w\" sizes=\"(max-width: 394px) 100vw, 394px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>\n    간단한 원 하나와 직선 5개로 표현했지만, 아무도 이걸 개나 고양이라고 생각하지는 않는다.<br>\n    이것이 바로 대상의 본질을 뽑아내어 표현한, 추상화된 대상인 것이다.\n  </small>\n</center>\n<p>결국 추상화가 된 대상은 “어떤 복잡한 대상의 핵심적인 특징만 남기고 나머지는 제거하여 단순화시킨 것”이라고 볼 수 있다. 마치 감정, 동물, 사물과 같은 복잡한 덩어리와 의미를 가진 것들을 단순한 도형들로 구성하여 단순화시키고 핵심적인 부분만을 강조한 추상파 화가들의 그림들처럼 말이다.</p>\n<p>그리고 이렇게 일반화된 핵심적인 특징들은 이러한 개체, 물체들의 공통적인 부분이 될 수 밖에 없다. 그래서 OOP에서 객체들의 공통점을 뽑아내어 클래스를 정의하라고 가이드하는 것이다.</p>\n<p>만약 필자가 그린 인간 그림에서 원이 없어진다면, 여러분은 이 그림이 로켓인지, 화살표인지, 머리가 없는 인간인지 알기 어려울 것이다. 왜냐면 살아있는 인간이라면 누구나 저 위치에 머리가 있어야 하는 것이 일반적이기 때문이다. 즉, 머리의 위치와 형태는 인간이라면 누구나 다 가지고 있는 대표적인 공통점인 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ce0b65b1961f895989162cd9111bf383/eea4a/headless.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 91.25000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAMCBAH/xAAXAQEBAQEAAAAAAAAAAAAAAAACAQAD/9oADAMBAAIQAxAAAAG855O0oC5Og5r0S//EABsQAAICAwEAAAAAAAAAAAAAAAABERIDEBMx/9oACAEBAAEFArDyQ+hYoQLxa//EABYRAQEBAAAAAAAAAAAAAAAAABIAEP/aAAgBAwEBPwEQ3//EABcRAAMBAAAAAAAAAAAAAAAAAAABExD/2gAIAQIBAT8BqVY8/8QAGBAAAwEBAAAAAAAAAAAAAAAAARARACH/2gAIAQEABj8C0jpPWF//xAAdEAACAgEFAAAAAAAAAAAAAAAAAREhMUFRYXGh/9oACAEBAAE/IYb+FZZuJOrOJZuwEkUYhmNWf//aAAwDAQACAAMAAAAQLCdA/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQETH/2gAIAQMBAT8QRqLY/8QAFhEBAQEAAAAAAAAAAAAAAAAAAREg/9oACAECAQE/EGDG/8QAHBABAAIDAQEBAAAAAAAAAAAAAQAhETFBcVHR/9oACAEBAAE/EDgj1fkJtwvMewCZWz0GZtXyRVYABujnkKDTybn2Yl2273Mux3P/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"headless\" title=\"\" src=\"/static/ce0b65b1961f895989162cd9111bf383/c08c5/headless.jpg\" srcset=\"/static/ce0b65b1961f895989162cd9111bf383/0913d/headless.jpg 160w,\n/static/ce0b65b1961f895989162cd9111bf383/cb69c/headless.jpg 320w,\n/static/ce0b65b1961f895989162cd9111bf383/c08c5/headless.jpg 640w,\n/static/ce0b65b1961f895989162cd9111bf383/6a068/headless.jpg 960w,\n/static/ce0b65b1961f895989162cd9111bf383/eea4a/headless.jpg 1280w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이 사진을 보고 자연스럽다고 생각하는 사람은 아마 아무도 없을 것이다</small>\n</center>\n<p>이렇게 복잡한 특성을 가진 대상이 가진 핵심적인 특징을 제외한 나머지 자잘한 것들은 모두 쳐내 단순하게 표현하는 것, 이것이 바로 추상화의 본질이다.</p>\n<h2 id=\"왜-프로그래밍에-추상화가-필요할까\" style=\"position:relative;\">왜 프로그래밍에 추상화가 필요할까?<a href=\"#%EC%99%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90-%EC%B6%94%EC%83%81%ED%99%94%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C\" aria-label=\"왜 프로그래밍에 추상화가 필요할까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 추상화라는 것이 복잡한 특성을 가진 대상이 가진 핵심적인 특징을 제외한 나머지 자잘한 것들은 모두 쳐내 단순하게 표현하는 행위라고 설명했다.</p>\n<p>그럼 이런 행위가 프로그래밍을 할 때 도대체 왜 필요한 것일까? 우리는 피카소처럼 사물의 본질을 파악하여 예술적으로 표현하는 그런 사람들도 아닌데 말이다.</p>\n<p>사실 이 질문에 대한 답은 매우 간단하다. 바로…</p>\n<blockquote>\n<p><strong>더 복잡하고 어려운 것</strong>을 만들기 위해서이다.</p>\n</blockquote>\n<h3 id=\"추상화는-더-복잡한-것을-만들-수-있게-해준다\" style=\"position:relative;\">추상화는 더 복잡한 것을 만들 수 있게 해준다<a href=\"#%EC%B6%94%EC%83%81%ED%99%94%EB%8A%94-%EB%8D%94-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EA%B2%83%EC%9D%84-%EB%A7%8C%EB%93%A4-%EC%88%98-%EC%9E%88%EA%B2%8C-%ED%95%B4%EC%A4%80%EB%8B%A4\" aria-label=\"추상화는 더 복잡한 것을 만들 수 있게 해준다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>앞서 이야기했듯 추상화를 당한 대상은 본래 자신이 가지고 있던 특징들 중 가장 핵심적인 특징만을 표현하게 되기 때문에, 매우 단순한 형태를 가지게 된다. 여기서 중요한 점은 “실제로는 복잡한 것을 단순하게 표현한다는 것”이다.</p>\n<p>다만 미술에서 사용하는 추상적 표현은 대상의 복잡한 부분을 제거하여 추상화를 진행하지만, 산업에서의 추상적 표현은 복잡한 부분을 감춤으로써 추상화를 진행한다는 차이점이 존재한다.</p>\n<p>즉, 구체적이고 복잡한 구현을 감추어 단순한 형태로 표현함으로써, 내가 만든 모듈이나 부품, 혹은 제품을 사용하는 사용자가 근본적인 원리를 알지 못 하더라도 대상의 기능을 활용할 수 있도록 만들어주는 것이다.</p>\n<p>우리가 일상 속에서 사용하는 컴퓨터만 해도, 가장 기본이 되는 부품인 반도체의 원리까지 모두 이해하고 사용하는 사람은 그리 많지 않으며, 심지어는 CPU가 뭔지도 모르는 초등학생조차도 컴퓨터를 사용할 수 있다. 우리는 그냥 컴퓨터라는 개념을 “키보드, 마우스로 조작하여 모니터나 스피커를 통해 뭔가 결과를 볼 수 있는 장치” 정도로 추상화하여 이해해도 사용에는 아무 문제가 없으니, 굳이 컴퓨터의 디테일한 원리까지 모두 알 필요도, 이유도 없는 것이다.</p>\n<p>또한 포토샵을 사용하여 사진을 보정하는 사람은 그냥 포토샵의 사용 방법 자체에만 집중하면 되지, 포토샵이라는 프로그램이 어떤 원리로 작동하는지, OS가 이 프로그램을 굴리기 위해 프로세스에 자원을 어떻게 할당하는지와 같은 내용은 전혀 몰라도 된다.</p>\n<p>만약 포토샵을 사용하는 사람이 이런 것까지 모두 신경써야 한다면 “포토샵으로 사진을 편집한다”라는 행위 자체가 너무 어렵고 복잡해지지는 않을까?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/164a4e620bcf57d8857f4541b3fbe14b/6a068/photoshop.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAf/EABQBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAY6INFwoT//EABsQAAICAwEAAAAAAAAAAAAAAAABAhEDEiFB/9oACAEBAAEFAoSWrUVi6VR4f//EABYRAAMAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPwERf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAMAAwAAAAAAAAAAAAAAAAEQEQAhMf/aAAgBAQAGPwI3uE3ccX//xAAbEAADAQEAAwAAAAAAAAAAAAABESEAMUFRsf/aAAgBAQABPyEutTEs8PsOdxqfMGN514Ga+zv/2gAMAwEAAgADAAAAEIfP/8QAFhEBAQEAAAAAAAAAAAAAAAAAAREQ/9oACAEDAQE/EFDc/8QAFxEBAAMAAAAAAAAAAAAAAAAAARARIf/aAAgBAgEBPxBG8j//xAAeEAEAAgIBBQAAAAAAAAAAAAABESEAQdExUWFxkf/aAAgBAQABPxA3K1IRuaxL352LEa84x1I9eMVp0VYwXaBaWLmvmSubP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"photoshop\" title=\"\" src=\"/static/164a4e620bcf57d8857f4541b3fbe14b/c08c5/photoshop.jpg\" srcset=\"/static/164a4e620bcf57d8857f4541b3fbe14b/0913d/photoshop.jpg 160w,\n/static/164a4e620bcf57d8857f4541b3fbe14b/cb69c/photoshop.jpg 320w,\n/static/164a4e620bcf57d8857f4541b3fbe14b/c08c5/photoshop.jpg 640w,\n/static/164a4e620bcf57d8857f4541b3fbe14b/6a068/photoshop.jpg 960w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>\n    만약 포토샵으로 사진을 편집할 때 이미지 프로세싱의 모든 원리를 알고 활용해야 한다면<br>\n    인간 한 명의 리소스만으로는 너무 어려운 작업이 되어버릴 것이다.\n  </small>\n</center>\n<p>이미 추상화의 근본적 개념은 자동차, 스마트폰, 도시 인프라 시스템, 행정처리 시스템 등 다양한 부분에서 활용되고 있으며, 평소 우리가 당연하다고 생각하고 누리고 있는 많은 것들이 내부적으로 굉장히 복잡한 로직과 인프라가 추상화된 결과물이다.</p>\n<p>우리는 이러한 추상화 덕분에 모든 분야에 대한 방대한 지식을 쌓지 않아도 복잡한 현대 사회의 시스템을 활용할 수 있게 되었다.</p>\n<blockquote>\n<ul>\n<li>\n<p>수도꼭지를 돌리면 깨끗한 물이 나온다 👉 도시의 상수도 시스템이 추상화됨</p>\n</li>\n<li>\n<p>동사무소에 가면 주민등록을 할 수 있다 👉 국가의 행정처리 시스템이 분업화되어 추상화됨</p>\n</li>\n<li>\n<p>자동차의 액셀러레이터를 밟으면 차가 앞으로 전진한다 👉 흡기/압축/폭발/배기 과정을 다루는 ECU와 엔진의 로직이 추상화됨</p>\n</li>\n</ul>\n</blockquote>\n<p>이렇듯 현재 우리가 살아가는 세상은 다양한 추상 개념 위에 쌓아올려진 것이며, 복잡한 것을 단순하게 표현하는 이 개념 덕분에 사람들은 자신이 담당하는 것에만 집중하며 작업을 할 수 있게 되어 분업이 가능해지고, 기존보다 더욱 더 복잡한 것들을 만들 수 있게 된다.</p>\n<p>반도체를 생산하는 사람은 반도체라는 개념에만, 컴퓨터를 조립하는 사람은 컴퓨터라는 개념에만, 포토샵을 개발하는 사람은 이미지 프로세싱과 프로그래밍에만, 작품을 만드는 사람은 포토샵을 활용하는 것에만 집중하면되니, 각 분야에 대한 전문성을 가진 여러 사람이 모여 기존보다 더 거대하고 복잡한 것들을 만들 수 있게 되는 것이다. 만약 이 모든 것을 한 사람이 이해해야 제품을 생산할 수 있다면, 평생에 걸쳐서 지식을 쌓아도 복잡한 제품을 높은 퀄리티로 생산해내기 쉽지 않을 것이다.</p>\n<p>이런 추상화의 이점은 우리가 경험하는 프로그래밍에도 동일하게 적용되고 있다. 내가 만드는 소프트웨어 또한 다른 산업과 마찬가지로 전 세계의 수 많은 사람들이 기여한 여러가지 작은 모듈들의 조립품이기 때문이다.</p>\n<p>필자와 같은 프론트엔드 개발자들은 대부분 React나 Vue같은 라이브러리/프레임워크들을 사용하여 웹 어플리케이션을 개발하는데, 이렇게 작은 프로그램들인 라이브러리나 프레임워크를 조합하여 복잡한 어플리케이션을 만드는 것은 그리 어색한 일이 아니다.</p>\n<p>솔직히 JavaScript 엔진에 대한 자세한 동작 원리는 모르더라도, JavaScript에 대한 대략의 문법과 React라는 라이브러리에 대한 사용법만 알아도 어플리케이션을 개발하는 것이 불가능하지는 않다.</p>\n<p>또한 예전에는 Webpack을 개발자가 직접 세팅하여 어플리케이션을 번들링하는 것이 일상적이었지만, 이제는 CRA같은 Cli나 Next.js 같은 프레임워크가 자체적으로 Webpack Configuration을 만들어주고, 심지어 이를 감춰서 추상화해버리기 때문에 최근 개발을 시작하시는 분들은 Webpack을 직접 다뤄보지 않은 분들도 계신다. <small>(실제로 최근에는 Webpack에 대한 지식이 없어도 일반적인 어플리케이션을 개발하는 자체에는 큰 지장이 없다)</small></p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/eefb5d1a1b23c4fc1c4b4275d203c295/6fa81/webpack.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACOUlEQVR42p1U2XLbMAzM//9c+5Zp4vi2JEsiKYmnzi0Ax249E7uHZ3ZIQxKIxS74Ep1HnyIWADFGhBAwTROe/aZpRt/3GMYZqZ8wzsvt2UurFHzX0XaBMQZKaUk6zzN9MGIk8AHjb/thGOA9F5IQfJSkt4TXzbIsKJoBzic459ARHFUfY6JqBlmv++v7XNc882HDr4T8gJ/w2lKlzlmEyIku1DnO1cp7f/G7VThTH05Hg+2mprXBbttgvzP4WNV4f6so1uJcBNQ1oQpIafzyoDvKZalxPmscj2fsDwUOhxynU4ksqyhRC607NK2jPjew1BLvgxTyZULm3feRkKjJkfrSS2/GaSDqw79TZivstjVRPGNF2KxrgqaYxuq9oriiyi31luwyjKI0q/6QMpee5xXRLIhuhv0+E6pZVqIoaqLZCtW2s0K3s1bc8LSH3tOLnRWDMxIZPiZe0/+pnGcdKXtRV7BvcCCsP0iswhL4wCi9ZcqMpxUqRZOijVCxZGprvSjJe441bUcxTnpZGWydhwmNYa/VaBqLltFSn2ySpDH04G//xPxO5cNB4+1HKQqv19Wn0oq8qGRf5FZGk2edxzKE+LzCpjHQRgmM0WRkRTENQ3H250De5JUThngR62FCFkVrKxNRljQVyiH6kT7iq4pMnxZZU5yf0r6jvNmUpKzC9287vL6eiH5Gc5yL0XnGt5uK/hefo8c97kTpB6MH+ODklnHeXuA6uXl4JJdlFjBFvrL4JvrqcvgJBd93ox0YT8EAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"webpack\" title=\"\" src=\"/static/eefb5d1a1b23c4fc1c4b4275d203c295/6af66/webpack.png\" srcset=\"/static/eefb5d1a1b23c4fc1c4b4275d203c295/69538/webpack.png 160w,\n/static/eefb5d1a1b23c4fc1c4b4275d203c295/72799/webpack.png 320w,\n/static/eefb5d1a1b23c4fc1c4b4275d203c295/6af66/webpack.png 640w,\n/static/eefb5d1a1b23c4fc1c4b4275d203c295/d9199/webpack.png 960w,\n/static/eefb5d1a1b23c4fc1c4b4275d203c295/21b4d/webpack.png 1280w,\n/static/eefb5d1a1b23c4fc1c4b4275d203c295/6fa81/webpack.png 1856w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>\n    구글에 \"webpack eject\"로 검색해보면<br>\n    얼마나 많은 사람들이 추상화를 깨고 webpack을 직접 건드리는 것을 피하려고 하는지 알 수 있다.\n  </small>\n</center>\n<p>이러한 추상화 덕분에 오늘날의 프론트엔드 개발자들은 상태와 UI를 연동하여 렌더링하고, 프로젝트를 직접 번들링하는 등의 복잡한 개념에서 해방되어 조금 더 고차원적인 부분들에 집중할 수 있게 되었고, 그로 인해 예전보다 점점 더 거대하고 복잡한 웹 클라이언트 어플리케이션을 개발할 수 있게 된 것이다.</p>\n<p>바로 이것이 프로그래밍, 더 나아가서는 산업에서의 추상화가 우리에게 가져다주는 이점이다.</p>\n<h2 id=\"공통점을-뽑아내는-추상화-방법에서-벗어나보자\" style=\"position:relative;\">공통점을 뽑아내는 추상화 방법에서 벗어나보자<a href=\"#%EA%B3%B5%ED%86%B5%EC%A0%90%EC%9D%84-%EB%BD%91%EC%95%84%EB%82%B4%EB%8A%94-%EC%B6%94%EC%83%81%ED%99%94-%EB%B0%A9%EB%B2%95%EC%97%90%EC%84%9C-%EB%B2%97%EC%96%B4%EB%82%98%EB%B3%B4%EC%9E%90\" aria-label=\"공통점을 뽑아내는 추상화 방법에서 벗어나보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지는 추상이라는 개념이 프로그래밍에 국한되지 않은 일반적인 개념이라는 것과 프로그래밍의 세계에 추상화라는 개념이 필요한 이유에 대해서 살펴봤다면, 이제는 조금 더 국지적인 부분을 살펴보도록 하자.</p>\n<p>앞서 필자는 OOP에서 이야기하는 “구체적인 것들의 공통점을 뽑아내어 추상적인 것을 정의한다”라는 추상화의 가이드라인이 추상화의 본질을 제대로 설명하지 못 한다고 이야기했다. 이는 복잡한 무언가를 단순한 것으로 추상화를 하는 접근 방법 중 하나일 뿐이기 때문이다.</p>\n<p>물론 이 방법이 틀렸다는 것은 아니지만, 개인적으로 필자는 이 가이드라인으로부터 추상화를 이해하려는 것을 추천하지는 않는다. 이것은 그냥 “추상화를 하기 위해 대상에 접근하는 방법 중 하나일 뿐”이며, 오히려 너무 이 방법에 얽매이게 되면 추후 어플리케이션이 진화할 방향성에 대한 상상을 제한하게 되어 변경에 열려있지 않은 설계를 만들어낼 수도 있다.</p>\n<p>간단한 클래스를 한번 예로 들어보자.</p>\n<h3 id=\"현재의-요구사항을-너무-충실하게-반영하는-설계\" style=\"position:relative;\">현재의 요구사항을 너무 충실하게 반영하는 설계<a href=\"#%ED%98%84%EC%9E%AC%EC%9D%98-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD%EC%9D%84-%EB%84%88%EB%AC%B4-%EC%B6%A9%EC%8B%A4%ED%95%98%EA%B2%8C-%EB%B0%98%EC%98%81%ED%95%98%EB%8A%94-%EC%84%A4%EA%B3%84\" aria-label=\"현재의 요구사항을 너무 충실하게 반영하는 설계 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2dbad5fcbddeaeca5e18e36c521d345b/010c2/class.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABVklEQVR42p1T207CQBDd//8XH33zwQRioggViUBBikFDoYWWS/dCS3vc2QJpKwZxXrYzZ+bMzOkuwwVLIgnhBogjgb8YOxvNDmRiB9ey4dQtuK2B9lUJv4Iwr4jXHE7Nwv3NLUb6jFdRCb+aUEQcXneMZWeM+ZsDwcU/J9SmlALnHOk+RegtdI/U+BS/oGGWT1ToKqU0xfmw2enbTC2EwUt6FyRg1fGrBVXCY0PKOzthpleKudSr7cF1UnUlim+DlVn9hyQ6n3Cqzw44C4ef8KwhfC2+ErL0U9Jkj2Awgf8yRGBPjF/Ed1Jh0fsw9cRDpMxt9NGvNeE+9yEX69OaZrVgY+LtuwfM9T2Uywq+3GDWtGHXWyZPhVswv+Ng+tSD134vXNy8IJE7eK8jfD124euT/CIh5RM+bfTgdzSuYrCEay3mvz8t0ofPQo3L83hEeADiIQ2/Aaowpk7ljaFxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"class\" title=\"\" src=\"/static/2dbad5fcbddeaeca5e18e36c521d345b/6af66/class.png\" srcset=\"/static/2dbad5fcbddeaeca5e18e36c521d345b/69538/class.png 160w,\n/static/2dbad5fcbddeaeca5e18e36c521d345b/72799/class.png 320w,\n/static/2dbad5fcbddeaeca5e18e36c521d345b/6af66/class.png 640w,\n/static/2dbad5fcbddeaeca5e18e36c521d345b/d9199/class.png 960w,\n/static/2dbad5fcbddeaeca5e18e36c521d345b/21b4d/class.png 1280w,\n/static/2dbad5fcbddeaeca5e18e36c521d345b/010c2/class.png 1425w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<hr>\n<ol>\n<li>요구사항에는 A, B, C라는 객체가 존재한다.</li>\n<li>A, B, C 객체의 공통점은 분홍색의 동그라미 모양이라는 것이고, 차이점은 가운데 들어가는 글자가 다르다는 것이다.</li>\n<li>분홍색 동그라미 모양 + 가운데 글자를 주입할 수 있는 클래스를 정의한다.</li>\n</ol>\n<hr>\n<p>이렇게 정의된 클래스는 현재 제시된 요구사항의 모든 케이스를 커버할 수 있기 때문에 추상화가 잘 된 것처럼 보인다. 실제로 이 설계는 현재의 비즈니스 요구사항을 충실하게 만족시키고 있기 때문에 별다른 문제가 없다.</p>\n<p>하지만 항상 문제는 현재의 스펙을 벗어난 추가적인 변경사항이 들어왔을 때 발생한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cd8cf2080c160b648d0b3581bbd6019e/add4c/class_2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABa0lEQVR42qWSTU/CQBCG+/+PHLjzGzjoRb34FSSKKJIANSAVLdCWj3a33W73dWdpCcUgJE4y6aTzzjOzO2vhBBMshuAJpOdBpemfWutgRm0+bL7A7HkAvzNENP4+2tw6Jgj6Dhr1C+NLe/IPYD5hMHbhNN60d7Bw3P9NyDkHYwwsWCHUR2ecIYqiE4A0jVKlBIGSJDFxqhfBNJwsjmOTU7t6itWBCbMsQxiGEEJs/xGQ50CzdZ2jSUlbvia1AWZSQiZCC6QRpntPY8kE/BXLa9S2SQGlWqUZZsKUC3jdEWatAYLhBDLvWpzInjLU7lzUbl28z3gpR1pf10x1LTFkLGBFXx4+7l8xuH7E/MU23Xa3XG8HqJz1UDnvmXjXZJJi3rYxuHmCoxnEspJVBLfVx+ShC1+/ueJIxRTN4RrVSwfVKwfN0bqUI23QH+NTPytiEMvcIQVsGpiO+5ZKhZ7LjFP8a4m6hmqJQXf4A3G5pEjyiHUqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"class 2\" title=\"\" src=\"/static/cd8cf2080c160b648d0b3581bbd6019e/6af66/class_2.png\" srcset=\"/static/cd8cf2080c160b648d0b3581bbd6019e/69538/class_2.png 160w,\n/static/cd8cf2080c160b648d0b3581bbd6019e/72799/class_2.png 320w,\n/static/cd8cf2080c160b648d0b3581bbd6019e/6af66/class_2.png 640w,\n/static/cd8cf2080c160b648d0b3581bbd6019e/d9199/class_2.png 960w,\n/static/cd8cf2080c160b648d0b3581bbd6019e/21b4d/class_2.png 1280w,\n/static/cd8cf2080c160b648d0b3581bbd6019e/add4c/class_2.png 1452w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>\"PO/PD: 동욱님 B객체의 색을 바꿀 수 있게 해주세요\"</small>\n</center>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 480px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6d3c70bfde81787ab2b3a9eef6094d9d/7cc5e/sudden.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 77.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAABQAE/8QAFAEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABQNXzjgh5P//EABsQAQACAgMAAAAAAAAAAAAAAAECAwATBBES/9oACAEBAAEFAru9W+cD1xsQYtNVgjGX/8QAFREBAQAAAAAAAAAAAAAAAAAAEEH/2gAIAQMBAT8Bh//EABURAQEAAAAAAAAAAAAAAAAAABBB/9oACAECAQE/Aaf/xAAdEAACAQQDAAAAAAAAAAAAAAAAAQIREiFRIjFC/9oACAEBAAY/Anb2WuSq/TOc5SezJRrOxrR//8QAGxABAAIDAQEAAAAAAAAAAAAAAQARMVFxIUH/2gAIAQEAAT8hps1tqAefNBBPVeaMrRXk53fsjhyqn//aAAwDAQACAAMAAAAQwM//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREx/9oACAEDAQE/EE8FP//EABcRAAMBAAAAAAAAAAAAAAAAAAABITH/2gAIAQIBAT8Qa0Q//8QAHBAAAgIDAQEAAAAAAAAAAAAAAREAQTFRcSGh/9oACAEBAAE/EFjErRZicsQPyDZ1AOeRAvgFTbgOkDHUTFcMZ4YIEMn7YKn/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"sudden\" title=\"\" src=\"/static/6d3c70bfde81787ab2b3a9eef6094d9d/7cc5e/sudden.jpg\" srcset=\"/static/6d3c70bfde81787ab2b3a9eef6094d9d/0913d/sudden.jpg 160w,\n/static/6d3c70bfde81787ab2b3a9eef6094d9d/cb69c/sudden.jpg 320w,\n/static/6d3c70bfde81787ab2b3a9eef6094d9d/7cc5e/sudden.jpg 480w\" sizes=\"(max-width: 480px) 100vw, 480px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>요구사항을 들은 나의 심정.jpg</small>\n</center>\n<p>아마 독자 여러분도 이런 경험이 많이 있을 것이라고 생각한다. 이처럼 빠르게 변화하는 비즈니스 상황 속에서 내가 개발하고 있던 어플리케이션의 스펙이 이에 따라 변경되는 것은 너무나도 자연스러운 일이며, 이런 상황은 내가 OOP를 사용하던 FP를 사용하던 패러다임과는 무관하게 항상 발생하게 된다.</p>\n<p>사실 위 예시의 설계에서 객체의 색을 변경할 수 있게 만들어주는 것은 간단한 작업이라 크게 문제가 없어보일 수도 있지만, 현실 세계에서 우리에게 들어오는 변경사항이 이 정도 수준이 아니라는 것은 다른 누구보다 독자 여러분이 더 잘 아실거라고 생각한다. <small><del>(빌딩을 1cm만 오른쪽으로 옮겨주…읍읍)</del></small></p>\n<p>좋은 코드라는 것을 정의할 수 있는 조건은 여러 개가 있지만, 그 중 대표적인 조건 중 하나는 요구사항이 변경되더라도 기존의 설계를 최대한 건드리지 않고 확장할 수 있는 “변경에 열린 코드”이다. 비즈니스 요구사항은 시장의 상황에 따라 변화무쌍하게 변할 수 밖에 없는데, 코드가 이 속도를 따라가지 못 한다면 결국 제대로 된 비즈니스 임팩트를 낼 수 없기 때문이다.</p>\n<p>하지만 위 예시의 코드는 미래의 변경사항을 대처하지 못 했고, 결국 클래스에 수정을 가해야 하는 상황을 만들어냈다. 또한 추상 표현을 담당하는 클래스라는 개념의 특성 상 여기저기서 재사용되고 있을 가능성도 높으니, 이 클래스만 수정해서 끝날 일도 아닐 것이다.</p>\n<h3 id=\"왜-이렇게-되었을까\" style=\"position:relative;\">왜 이렇게 되었을까?<a href=\"#%EC%99%9C-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EB%90%98%EC%97%88%EC%9D%84%EA%B9%8C\" aria-label=\"왜 이렇게 되었을까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>왜 이 클래스는 변경에 열린 설계가 되지 못 했을까? 여러가지 이유가 있겠지만, 필자는 “현재의 요구사항에 충실한 설계를 했기 때문”이라고 생각한다.</p>\n<p>물론 우리는 비즈니스 요구사항에 맞춰 제품을 개발하는 사람들이니 현재의 요구사항에 맞춰 설계를 하는 것은 당연한 일이겠지만, 개발자라면 누구든 미래지향적인 설계, 추후 새로운 기능이 얼마나 붙든 기존 코드를 최대한 재사용할 수 있는 확장성있고 변경에 열린 설계를 하고 싶어한다.</p>\n<p>하지만 현재 나에게 주어진 기능의 스펙에서부터 공통점을 추려내는 방식으로 추상화를 진행하게된다면, 추상화된 대상 조차도 “당장 현재의 요구사항”만을 투영하고 있도록 설계될 가능성이 높아진다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b87aa75de4c1a353973fc1d2e9704b94/7a18f/bottom-up.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 62.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACe0lEQVR42oVT3WvSURh2uVkU25JGBUGEEIHQutiQ7oW6iwi86yK82F9Q7KpFN0EE0W3QhZtzo+HSWcsPRJ0Oh7ChE92cqPN7M+a3F+V2PD3vL3/DuYsOvJzzfj3nvO95H0m1Wu0cHR2xcrksSKVSYQcHByyRSLC9vT0WDodZNBpl+/v7bHd3l0UiEZbP54U4MQf5J61Wi29tbf2ScKxOp8N791wux5HIY7EYX15e5jabjQOYezwebjKZeCqVOhPPGBN2ypGUSiU9bpzDq2YRuBgMBr8fHh7qoM/hdrLPwbaKGH2hUBB0iqU4iqcz5QPHEAgEPkn61iXIze55oMd+q0cX9+uQy/0AVPIACZ01Go1MoVCMdu1SyCCJWq2+hl3W1S+QX6VSjWi12uGujXwyt9s9eAZ8ampqSATse+HVPp3WMOTiuRe6XK4Jn89nW19ft2xsbPwwm80/l5aWlOTzer3vNjc3V9fW1r7BZ8WHvBTzpqenbxsMhvdGo/GD3W5/7XQ6Z3Q63TiVdsXhcDxEgx80Gg1lPB5XAkToDcZkEvojq9X6BOfH+OX7IiDKG8PHvAqFQjO48K3f73+zsrIyLvpHIEN9jz/tLZa8v989PqlcLhfahMqk5wB7k/7TQ3ERyOiphjnSJ5PJhUwmo4csoJeTZLdYLGNgyhfMnh5lLxaLxXmw5zPKukF+9H0C7PmKGZwlP+ZwHnP4UdJsNjlAOcBOaNqR9IIStre379XrdV6r1Xg2m+1A6HwMegl9SqfTzykew39MzAH9/jEF6MTRNmj2hxxIeEYJ+NU7sDeJzzs7O23wuYOYCj7mLvnxcU8BSvT8DV8bOBzV5f8C3ToeMjy/hT4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bottom up\" title=\"\" src=\"/static/b87aa75de4c1a353973fc1d2e9704b94/6af66/bottom-up.png\" srcset=\"/static/b87aa75de4c1a353973fc1d2e9704b94/69538/bottom-up.png 160w,\n/static/b87aa75de4c1a353973fc1d2e9704b94/72799/bottom-up.png 320w,\n/static/b87aa75de4c1a353973fc1d2e9704b94/6af66/bottom-up.png 640w,\n/static/b87aa75de4c1a353973fc1d2e9704b94/d9199/bottom-up.png 960w,\n/static/b87aa75de4c1a353973fc1d2e9704b94/21b4d/bottom-up.png 1280w,\n/static/b87aa75de4c1a353973fc1d2e9704b94/7a18f/bottom-up.png 1284w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>애초에 나에게 주어진 재료인 요구사항을 기반으로 추상화를 하게 되니,<br>추상화된 개념도 자연스레 현재의 요구사항만을 반영하게 되기 쉽다</small>\n</center>\n<p>물론 디테일에서부터 추상화를 진행해도 얼마든지 변경에 열린 설계를 만들어낼 수는 있다. 흔히 객체지향에서 이야기하는 SOLID 원칙, 더 구체적으로는 <a href=\"https://en.wikipedia.org/wiki/Inversion_of_control\" target=\"_blank\" rel=\"nofollow\">IoC</a>, <a href=\"https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85\" target=\"_blank\" rel=\"nofollow\">DI</a> 같은 디자인 패턴들이 바로 그런 설계를 하기 위한 방법이라고 할 수 있다.</p>\n<p>그러나 이런 사고 과정을 통해 추상화를 하는 상황에서 변경에 열린 설계를 하려면, 개발자의 짬바에 의존한 미래 예측력과 비즈니스 도메인 지식이 필요할 수 밖에 없다. 왜냐하면 어디가 얼마나 자주 바뀔 것 같은지에 대한 감이 있어야 그 부분을 유연하게 설계해놓을 수 있기 때문이다.</p>\n<p>심지어 일반적으로 추상화에 대한 설명을 할 때 따라오는 “객체들의 공통점을 뽑아라”이라는 문장에는 이런 디자인 패턴에 대한 이야기가 담겨있지 않으니, 개발자가 이런 원칙들을 알아서 공부하고 적재적소에 사용해야한다.</p>\n<p>물론 짬바가 어느 정도 찬 개발자들은 “그냥 하면 되는거 아님?”이라고 생각할 수 있지만, 처음 개발을 접한 초보자 입장에서는 현재의 요구사항만 보고 “여기는 나중에 변경되기 쉬운 부분이니까 원하는 기능을 외부에서 주입할 수 있도록 설계해놔야겠다”라는 생각을 하기가 참 쉽지 않다.</p>\n<p>그래서 필자가 제안하고 싶은 방향은 구체적인 것에서 추상적인 것을 정의하는 방향이 아닌, 반대로 추상적인 것을 먼저 떠올려 보는 방법이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8900a6f2bd640ee40e97b7504d380a91/10d53/top-down.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 46.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbklEQVR42pVSy2rCQBSNVjdtqVqKgnTT0j/wL/oLrvsJXWfVjSshIohrN0qQtoEY20BbcBGCAcXsxPiKjwR02dCH0zNpAilIbS/cTOaec8/MvXeY8Xi8mc1mZDQaEcMwyGKxIKZpkul0uqH/k8nklef5U47j0vP5/I1ygW8o3+O5q2VZpNPpfDKDwUBAogRCAy4CfECShJi4XC6bELytVqvHxWIxAeweok2IiMPhUAJGuQ1wG7ZtS71e747ZYvvwPWa3hT3uTyOEhHyn+0wmEyuVSieCICTq9XqcZdlwkIsl5AumUqmDbRpBMlMuly9UVc1pmpaTZfmmUCgcergrjEMugecVRcnXarWrnXV4J0XhkWw2e4T+BcsP4cZp9O+s2+2et1qtJPNPi8EjgX0UHvfF/3I7tyxM8dpxnBdM+YlOst/vi7qui5joI40Be6acYKt+FVyv1xXybe+r1cp9o+12myBOYx/0g3glmOPbF2EDKjvl+1EUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"top down\" title=\"\" src=\"/static/8900a6f2bd640ee40e97b7504d380a91/6af66/top-down.png\" srcset=\"/static/8900a6f2bd640ee40e97b7504d380a91/69538/top-down.png 160w,\n/static/8900a6f2bd640ee40e97b7504d380a91/72799/top-down.png 320w,\n/static/8900a6f2bd640ee40e97b7504d380a91/6af66/top-down.png 640w,\n/static/8900a6f2bd640ee40e97b7504d380a91/d9199/top-down.png 960w,\n/static/8900a6f2bd640ee40e97b7504d380a91/21b4d/top-down.png 1280w,\n/static/8900a6f2bd640ee40e97b7504d380a91/10d53/top-down.png 1724w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>구체적인 요구사항을 달성하기 위해 필요한 재료가 무엇인지를 고민해보자</small>\n</center>\n<h3 id=\"추상적인-것들을-합성하여-구체적인-것을-만들기\" style=\"position:relative;\">추상적인 것들을 합성하여 구체적인 것을 만들기<a href=\"#%EC%B6%94%EC%83%81%EC%A0%81%EC%9D%B8-%EA%B2%83%EB%93%A4%EC%9D%84-%ED%95%A9%EC%84%B1%ED%95%98%EC%97%AC-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%EA%B2%83%EC%9D%84-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"추상적인 것들을 합성하여 구체적인 것을 만들기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>기존의 추상화 방법에 익숙한 분이라면, 구체적인 것보다 추상적인 것을 먼저 정의해보자고 했을 때 감이 잘 안 오실 수도 있지만, 사실 이 개념은 그렇게 새로운 것도 아니고 이상한 것도 아니다.</p>\n<p>앞서 필자는 추상이라는 개념을 사용하면 복잡한 것들을 감추어 단순하게 보이도록 만들 수 있고, 이런 추상의 효과 덕분에 우리가 복잡한 현대 사회를 구성하는 모든 지식을 알지 못 하더라도 현대 사회의 문물들을 충분히 이용하면서 살아갈 수 있다고 이야기했다.</p>\n<p>어플리케이션 설계 또한 마찬가지이다. 즉, 구체적인 객체 또는 구현체들의 공통점이 무엇이고 이런 공통점을 어떻게 추상화할지에 대한 고민보다는, 구체적인 구현 중에서 어떤 부분을 부품처럼 따로 나누어 포장하고, 또 이 부품들을 어떤 방식으로 조립하게 만들어줘야 내 코드를 사용하는 개발자들이 필요 이상의 맥락을 몰라도 내 코드를 편하게 사용할 수 있을 지에 대해 고민해야하는 것이다.</p>\n<p>물론 이런 접근 방식을 사용해도 결과적으로는 구체적인 개념들의 공통적인 부분이 추상화되는 결과가 나올테니 어떻게 보면 비슷하다고 느낄 수 있지만, 공통점을 뽑아내는 방법과는 사고의 방향이 정반대라는 차이가 있다.</p>\n<p>자, 만약 우리가 아이폰을 만들어야 하는 상황이라고 생각해보자. 객체들의 공통점을 뽑아내어 추상 개념을 정의하는 방식으로 접근하면 대략 이런 사고 흐름을 타게 될 것이다.</p>\n<blockquote>\n<ul>\n<li>\n<p>아이폰의 모든 기종에는 홈으로 이동할 수 있는 기능이 존재한다 (공통점)</p>\n</li>\n<li>\n<p>아이폰은 홈 버튼이 있는 놈이랑 없는 놈으로 나눌 수 있지 않나? (차이점)</p>\n</li>\n<li>\n<p>그럼 함수에 홈 버튼을 보이게 하거나, 안 보이게 하는 인자를 하나 추가하면 되려나? (차이점의 구현)</p>\n</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Props</span> <span class=\"token punctuation\">{</span>\n  showHomeButton<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">IPhone</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> showHomeButton <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isHomeScreen<span class=\"token punctuation\">,</span> setHomeScreen<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">moveHome</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setHomeScreen</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>showHomeButton <span class=\"token operator\">===</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HomeButton</span></span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>moveHome<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HomeGesture</span></span> <span class=\"token attr-name\">onSwipeUp</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>moveHome<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<center>\n  <small>\n    필자에게 더 익숙한 React의 함수 선언 패턴으로 작성해보았다.<br />\n    어차피 추상적인 무언가를 조합해서 복잡하고 구체적인 것을 만든다는 개념 자체는 변하지 않는다.\n  </small>\n  <br />\n  <br />\n</center>\n<p>뭐 대충 이런 모양이 되지 않을까? 얼핏 보면 현재의 요구 사항을 잘 맞추긴 했다. 아이폰은 기종에 따라 홈 버튼이 존재하는 구형 기종과 홈 버튼이 없는 신형 기종이 존재하기 때문이다.</p>\n<p>하지만 만약 나중에 <small><del>(그럴리 없겠지만)</del></small> 홈 버튼을 다이얼로 만든 아이폰이 출시된다면 어떻게 될까? 이 아이폰은 홈 버튼을 터치하거나 누른다는 개념이 없고 그저 돌릴 수만 있다.</p>\n<p>당연히 현재 우리의 함수는 그런 개념까지 생각하지 못 한 상태로 작성되었으니, 이제 이 함수에 <code class=\"language-text\">homeUIType</code>이라는 새로운 인자를 추가하고, 의미가 없어진 <code class=\"language-text\">showHomeButton</code> 인자는 제거해야 할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">IPhoneHomeButtonType</span> <span class=\"token operator\">=</span> <span class=\"token string\">'dial'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'gesture'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Props</span> <span class=\"token punctuation\">{</span>\n  homeUIType<span class=\"token operator\">:</span> IPhoneHomeButtonType<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">IPhone</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> homeUIType<span class=\"token punctuation\">,</span> onMoveHome <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isHomeScreen<span class=\"token punctuation\">,</span> setHomeScreen<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">moveHome</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setHomeScreen</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>homeUIType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'button'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HomeButton</span></span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>moveHome<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'gesture'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HomeGesture</span></span> <span class=\"token attr-name\">onSwipeUp</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>moveHome<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'dial'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HomeDial</span></span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>moveHome<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>단지 홈으로 이동하는 동작의 트리거 종류가 하나 추가되었을 뿐인데도 함수의 인자와 내부 로직이 전부 변경되었다. 게다가 함수의 인자가 변경되었으니 기존에 이 함수를 사용하고 있던 모든 곳에도 이 변경사항에 맞춰 수정을 해줘야 할 것이다.</p>\n<p>여기까지 보신 많은 개발자 분들은 이렇게 생각하실 수도 있겠다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 393px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/40dbc4952056f4f9a119e783e1850333/02e12/what.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAIB/9oADAMBAAIQAxAAAAFLEWm55eMf/8QAGhABAAIDAQAAAAAAAAAAAAAAAQACERMhEv/aAAgBAQABBQI6aZqSFzNXvuo//8QAFxEBAQEBAAAAAAAAAAAAAAAAAQAREv/aAAgBAwEBPwHRbq//xAAWEQEBAQAAAAAAAAAAAAAAAAABABH/2gAIAQIBAT8BBsv/xAAZEAADAQEBAAAAAAAAAAAAAAAAAREhAoH/2gAIAQEABj8C0k9pvSRBoeI//8QAGhABAAMBAQEAAAAAAAAAAAAAAQARMUFRIf/aAAgBAQABPyG9awqATN2DWvfIMaFpfJeTjPuLL6T/2gAMAwEAAgADAAAAELz/AP/EABcRAQEBAQAAAAAAAAAAAAAAAAEAESH/2gAIAQMBAT8Q4Egcy//EABYRAQEBAAAAAAAAAAAAAAAAAAERAP/aAAgBAgEBPxABXDS3f//EABsQAQACAwEBAAAAAAAAAAAAAAEAESExQWFx/9oACAEBAAE/EE4gEBoxtySv3RgG+X55AA9LvsI5BCRxfIBpFC1sPkRbNjcuDyf/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"what\" title=\"\" src=\"/static/40dbc4952056f4f9a119e783e1850333/02e12/what.jpg\" srcset=\"/static/40dbc4952056f4f9a119e783e1850333/0913d/what.jpg 160w,\n/static/40dbc4952056f4f9a119e783e1850333/cb69c/what.jpg 320w,\n/static/40dbc4952056f4f9a119e783e1850333/02e12/what.jpg 393w\" sizes=\"(max-width: 393px) 100vw, 393px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>아니 처음부터 IoC로 외부에서 주입하도록 유연하게 설계하면 되는데, 누가 저렇게 개발하냐!</small>\n</center>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Props</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">renderHomeUI</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token function-variable function\">moveHome</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> ReactNode<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">IPhone</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> renderHomeUI <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isHomeScreen<span class=\"token punctuation\">,</span> setHomeScreen<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">moveHome</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setHomeScreen</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">renderHomeUI</span><span class=\"token punctuation\">(</span>moveHome<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 애초에 외부에서 IoC 패턴으로 합성해놓으면,</span>\n<span class=\"token comment\">// IPhone 컴포넌트 내부의 로직을 아예 변경하지 않고도 다양한 Home UI를 사용할 수 있도록 설게할 수 있다.</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">IPhone</span></span> <span class=\"token attr-name\">renderHomeUI</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span>moveHome<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HomeButton</span></span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>moveHome<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">IPhone</span></span> <span class=\"token attr-name\">renderHomeUI</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span>moveHome<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HomeGesture</span></span> <span class=\"token attr-name\">onSwipeUp</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>moveHome<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">IPhone</span></span> <span class=\"token attr-name\">renderHomeUI</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span>moveHome<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HomeDialog</span></span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>moveHome<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>물론 필자도 그렇게 생각한다. 사실 홈으로 이동하는 기능은 “홈 버튼”과는 크게 관련이 없는 추상적인 기능이니, 홈으로 이동하는 이벤트를 호출하는 주체인 홈 버튼이라는 녀석은 스마트폰의 설계에 따라 변경될 가능성이 농후하기 때문이다.</p>\n<p>하지만 앞서 이야기했듯이 이러한 설계에 익숙하지 않은 개발자라면 이미 자신이 알고 있는 아이폰의 기능이나 현재 주어진 요구사항이라는 개념에 매몰되어 홈 버튼이라는 녀석이 굉장히 변경되기 쉬운 녀석이라는 사실을 인지하기 어려울 수도 있고, 변경될 가능성이 낮은 홈으로 이동하는 기능과 변경될 가능성이 높은 홈 버튼이 마치 하나의 개념인 것처럼 오인식하여 결합도가 높은 설계를 하게 되기가 쉽다.</p>\n<p>아마 처음부터 “엥 이건 외부에서 주입해야 할 것 같은데…?”라고 생각하신 분들은 과거에 직접 경험했던 여러 삽질을 통해서 해당 부분이 자주 변경될 것 같다는 인사이트를 쌓으셨기 때문에 문제의식을 가지게 되셨을거라고 생각한다. 쉽게 말해 짬바다.</p>\n<p>그러나 이런 인사이트가 부족한 초보 개발자들은 일종의 공식처럼 구체적인 것들의 공통점을 뽑아내어 추상화를 진행할 수 밖에 없고, 이후 비즈니스가 변화함에 따라 발생하는 이슈들을 대응할 때 주먹구구식으로 설계를 확장하게 되기 너무 쉬운 것이다.</p>\n<p>솔직히 IoC, DI 같은 개념들은 이런 삽질을 통해 몇 번 고생을 해보다 보면 자연스럽게 공부를 통해 알게 되는 것이지, 처음부터 이런 개념을 가지고 개발을 시작하는 사람은 그리 많지 않다고 생각한다.</p>\n<p>그렇기 때문에 추상적인 설계를 하기 위해서는 구체적인 것들로부터 공통점을 뽑아내는 것보다는 내가 구현해야하는 이 개념이 어떤 작은 부품들로 이루어져 있는지부터 고민해보고, 이 부품들을 어떤 방식으로 조립(합성)해가며 구체적인 개념을 만들어가는 방식으로 접근하는 것을 추천하는 것이다.</p>\n<blockquote>\n<ul>\n<li>\n<p>아이폰이라는 것은 마이크, 스피커, 디스플레이, 홈버튼 등으로 이루어져있다.</p>\n</li>\n<li>\n<p>각각의 부품들은 어떤 방식으로 조립되어야 할까?</p>\n</li>\n<li>\n<p>아마 스피커나 마이크 같은 애들은 다른 스마트폰이라도 위치가 크게 변하지 않을거야.</p>\n</li>\n<li>\n<p>홈 버튼은 스마트폰마다 모양도 다르지 않나? 요즘에는 심지어 없는 것도 있던데, 그럼 이걸 어떻게 조립해야할까?</p>\n</li>\n</ul>\n</blockquote>\n<p>이렇게 Bottom-Up 사고 방식으로 설계를 하게되면 자연스럽게, 아이폰이라는 개념과, 더 나아가서는 스마트폰이라는 개념까지도 포괄할 수 있는 설계를 만들기 쉬워진다.</p>\n<p>아무래도 구체적인 개념은 당장 현재의 비즈니스 상황만을 반영하게 되기 때문에, 구체적인 개념에서 공통점을 뽑아내어 추상적인 개념을 정의할 때는 미래의 변경 가능성까지 고려하기 어렵지만, 추상적인 개념들을 조립하여 구체적인 개념을 만들어내는 과정으로 사고하게 되면 내가 딱히 의식하지 않아도 어느 정도는 자연스럽게 추상적인 개념들을 갈아끼울 수 있게 만드는 설계를 하기 쉬워진다.</p>\n<h2 id=\"좋은-추상화를-위해-고민해볼만한-것들\" style=\"position:relative;\">좋은 추상화를 위해 고민해볼만한 것들<a href=\"#%EC%A2%8B%EC%9D%80-%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%9C%84%ED%95%B4-%EA%B3%A0%EB%AF%BC%ED%95%B4%EB%B3%BC%EB%A7%8C%ED%95%9C-%EA%B2%83%EB%93%A4\" aria-label=\"좋은 추상화를 위해 고민해볼만한 것들 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>추상화라는 개념과 추상화를 시작할 때의 접근 방법과 같은 거시적인 것들에 대해 알아보았다면, 지금부터는 실제로 추상화를 진행할 때 한번 고민해보면 좋을 법한 액션아이템들에 대한 이야기를 해보려고 한다.</p>\n<p>앞서 필자는 Bottom-Up 사고 방식을 통해, 구체적인 요구사항을 달성하기 위해서 어떤 추상화된 부품들이 필요할지에 대해 고민해보자고 이야기했었는데, 이런 방식을 통해 추상화를 진행하게 되면 이제 “부품을 어떤 단위로 설계해야하는지”, “부품의 기능을 어떻게 표현해줄지” 같은 고민이 새롭게 생겨난다.</p>\n<p>각각의 부품이 하나의 작은 역할만 담당하도록 관심사를 나눠서 설계할 수도 있지만 오히려 각 부품의 개념을 잘게 나누었다가 과한 추상화로 인해 맥락을 파악하기 어려운 코드가 될 수도 있으며, 각각의 부품의 기능을 제대로 표현하지 못 해 다른 부품과 합성이 어려운 부품을 만들어버리게 될 수도 있다.</p>\n<p>그래서 이번 챕터에서는 필자가 추상화를 진행할 때 신경쓰는 몇 가지 고민들을 함께 공유하려고 한다.</p>\n<h3 id=\"개발자에게-과한-맥락을-부여하지-않기\" style=\"position:relative;\">개발자에게 과한 맥락을 부여하지 않기<a href=\"#%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%EA%B3%BC%ED%95%9C-%EB%A7%A5%EB%9D%BD%EC%9D%84-%EB%B6%80%EC%97%AC%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0\" aria-label=\"개발자에게 과한 맥락을 부여하지 않기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>추상화의 장점이라고 하면 보통 재사용성에 대한 이야기를 많이 하지만, 필자가 여러 번 이야기 했듯이 추상화의 가장 큰 장점은 복잡한 것을 단순해보이게 만들 수 있다는 점이다.</p>\n<p>이러한 추상화의 장점은 오늘날 자주 사용하는 클래스, 함수, 컴포넌트 모두에게서 발견할 수 있는데, 대충 예를 들어보자면 이런 느낌이다.</p>\n<blockquote>\n<p>배열 내부에 있는 값들의 앞에 “I am “이라는 값을 붙혀주세요.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Evan'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Daniel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Martin'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> newArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  newArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">I am </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ['I am Evan', 'I am Daniel', 'I am Martin'];</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>사실 요즘 이렇게 명령형 프로그래밍을 하시는 분을 많지 않을 거라고 생각하지만, 설명을 위해 조금 과장되게 작성해보았다. 위 코드는 배열 내부의 값들에 <code class=\"language-text\">I am</code>이라는 값을 붙히기 위해 <code class=\"language-text\">for</code> 문을 사용하여 직접 배열을 순회하고 인덱스를 사용하여 각 원소에 접근하여 값을 재할당하고 있다.</p>\n<p>그리고 이 코드를 읽는 개발자는 자연스럽게 아래와 같은 맥락들을 파악하게 될 것이다.</p>\n<blockquote>\n<ol>\n<li>\n<p><code class=\"language-text\">for</code> 문을 사용하여 내부의 코드를 반복 실행할 것이다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">i</code>라는 변수를 <code class=\"language-text\">0</code>으로 초기화하고 반복이 한 번 종료될 때마다 해당 변수에 <code class=\"language-text\">1</code>을 더할 것이다.</p>\n</li>\n<li>\n<p>위에서 선언한 <code class=\"language-text\">i</code>를 배열의 인덱스로 사용하여 각 원소에 접근한다.</p>\n</li>\n<li>\n<p>템플릿 스트링을 사용하여 배열의 원소 값의 앞 쪽에 <code class=\"language-text\">I am</code>이라는 값을 합성한다.</p>\n</li>\n</ol>\n</blockquote>\n<p>사실 이 코드는 굉장히 많은 맥락을 내포하고 있는 코드이다. 왜냐하면 개발자는 이 코드가 배열 내부의 값들의 앞 쪽에 I am이라는 값을 붙힌다는 동작을 충실히 수행할 수 있는 코드인지만 알면 이 코드를 이해하는데 아무런 무리가 없기 때문이다. 인덱스를 어쩌고 <code class=\"language-text\">for</code> 문을 어쩌고 하는 것들을 알 필요가 없다는 것이다.</p>\n<p>그렇다면 이 동작을 여러가지 레벨로 추상화해보면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// 배열을 순회하며 새로운 배열을 만드는 부분까지만 추상화</span>\n<span class=\"token keyword\">const</span> newArray <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>v <span class=\"token operator\">=></span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">I am </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>v<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 템플릿 스트링으로 문자열을 합성하는 부분까지도 추상화</span>\n<span class=\"token keyword\">const</span> newArray <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>v <span class=\"token operator\">=></span> <span class=\"token function\">addPrefix</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> <span class=\"token string\">'I am'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// map을 사용한다는 사실까지도 추상화</span>\n<span class=\"token keyword\">const</span> newArray <span class=\"token operator\">=</span> <span class=\"token function\">addPrefixToItems</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token string\">'I am'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// \"I am\"이라는 문자열을 합성하는 과정까지 추상화</span>\n<span class=\"token keyword\">const</span> newArray <span class=\"token operator\">=</span> <span class=\"token function\">addIamToItems</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 코드들은 위에서 밑으로 내려갈수록 점차 높아지는 추상화 레벨을 보여주고 있다.</p>\n<p>가장 위 쪽에 있는 코드는 <code class=\"language-text\">for</code> 문을 사용하여 배열을 순회하고 새로운 배열을 반환하는 부분이 추상화되었으니, 이제 개발자는 배열 내부의 원소에 접근하기 위해 <code class=\"language-text\">for</code> 문을 사용하여 <code class=\"language-text\">i</code>라는 변수를 직접 초기화하고 관리해야 한다는 맥락이나 새로운 변수로 배열을 선언해야한다는 맥락을 잊을 수 있다.</p>\n<p>즉, 개발자는 배열을 순회하여 기존 원소들을 토대로 만들어낸 새로운 원소를 담은 배열을 생성한다는 <code class=\"language-text\">Array.prototype.map</code>이라는 메소드의 동작만 알고 있으면 되는 것이다. 이렇게 추상화된 코드는 컴퓨터가 수행하는 명령의 절차보다는 개발자가 의도한 행위 자체에 더 초점을 맞춰 표현되게 되므로 이를 <a href=\"https://ko.wikipedia.org/wiki/%EC%84%A0%EC%96%B8%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" target=\"_blank\" rel=\"nofollow\">선언적 프로그래밍</a>이라고 하기도 한다. <small>(어떻게 할 것인지 보다는, 무엇을 할 것인지에 초점을 맞춰 선언하며 프로그래밍을 진행한다)</small></p>\n<p>조금 더 일상적인 예시를 하나 더 보도록 하자. 아마 여러분은 이미 평소에 다양한 라이브러리를 사용하며 이러한 코드를 작성하는 경험을 하고 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> css <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@emotion/css'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> format <span class=\"token keyword\">from</span> <span class=\"token string\">'date-fns/format'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Foo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Date 객체를 생성하고 내부 상태를 오늘 날짜로 초기화하는 행위를 추상화</span>\n  <span class=\"token keyword\">const</span> now <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Date 객체를 토대로 원하는 String을 생성하는 행위를 추상화</span>\n  <span class=\"token keyword\">const</span> formattedDate <span class=\"token operator\">=</span> <span class=\"token function\">format</span><span class=\"token punctuation\">(</span>now<span class=\"token punctuation\">,</span> <span class=\"token string\">'yyyy-MM-dd'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token comment\">// React.createElement 함수로 VDOM 객체를 생성하는 행위를 추상화</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span> <span class=\"token attr-name\">className</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>\n      css<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n        font-size: 1.8rem;\n        font-weight: 800;\n      </span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token comment\">// 작성한 css를 style 태그로 감싸 &lt;head> 태그에 넣는 행위, class를 생성하는 행위를 추상화</span>\n    <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      Today is </span><span class=\"token punctuation\">{</span>formattedDate<span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 그리고 위 모든 행위를 추상화</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Foo</span></span> <span class=\"token punctuation\">/></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">Foo</code> 컴포넌트는 단순히 오늘 날짜를 <code class=\"language-text\">2023-03-02</code>와 같은 포맷으로 보여주는 굉장히 간단한 일을 하는 녀석이지만, 이렇게 작은 컴포넌트조차 동작을 하나하나 뜯어본다면 굉장히 많은 부분이 추상화되어있다는 사실을 알 수 있다.</p>\n<p>만약 여러분이 이 컴포넌트 하나를 만들기 위해 이 모든 행위에 대한 코드를 읽고 이해해야 하거나, 혹은 코드를 직접 작성해서 해결해야 한다면, 더 이상 이 녀석이 간단한 컴포넌트라고 말하기는 어려울 것이다. 즉, 추상화를 통해 간단해보이도록 만들었을 뿐 사실은 전혀 간단하지 않은 것이다. <small>(일단 VanilaJS로 React 구현하는 것부터 빡세다…)</small></p>\n<p>하지만 위 코드에 적혀있는 주석들이 이야기하고 있는 행위들이 모두 <code class=\"language-text\">emotion</code>, <code class=\"language-text\">date-fns</code>, <code class=\"language-text\">react</code> 등의 라이브러리에 추상화되어있으니, 우리는 이런 복잡한 행위를 신경쓰지 않고 “현재 시간을 렌더하는 것”에만 집중할 수 있게 되었다.</p>\n<p>다시 강조하지만 산업에서의 추상화가 가지는 가치는 복잡한 무언가를 단순해보이게 만들어, 각각의 인간들이 자신의 전문 분야에만 집중하여 협업함으로써 더 고도화되고 복잡한 것을 만들 수 있게 만들어준다는 것이다. 이러한 추상화의 본질적 가치는 우리가 매일 경험하고 있는 프로그래밍의 세계에서도 마찬가지로 통용되고 있는 것이다.</p>\n<p>흔히들 가독성이 부족한 코드에 대한 내용을 이야기할 때 많은 분들이 코드 라인의 수에 대한 이야기를 하시는데, 이것은 단순히 코드 라인의 수가 많다는 것보다는 “모듈의 동작을 이해하기 위해 읽고 분석해야 할 코드의 양이 많다”라는 것에 대한 문제를 이야기하는 것에 가깝다.</p>\n<p>간단하게 생각해서 위 예시의 코드에서 <code class=\"language-text\">emotion</code>, <code class=\"language-text\">date-fns</code>, <code class=\"language-text\">react</code> 라이브러리들의 내용물이 전부 <code class=\"language-text\">Foo</code> 컴포넌트와 같은 모듈에 선언되어있다면 어떨지 상상해보면 된다.</p>\n<p>아무것도 모르는 상태에서 해당 모듈을 딱 열었을 때 모든 라이브러리의 코드가 한번에 보인다면 내가 어디에서부터 어디까지 읽어야 하는 것인지, 어떤 부분은 그냥 무시하고 넘어가도 되는 것인지, 도대체 이 많은 코드 중에서 버그는 어디에 발생한 것인지 한 번에 파악하기 어려울 것이기 때문이다. 즉, 개발자에게 강요되는 맥락이 과하다.</p>\n<p>조직 내에서 자주 사용되는 모듈을 굳이 어플리케이션 내에서 분리해두는 것이 아닌, 별도 패키지로 구성하여 레지스트리에 배포하고 사용하게 하는 이유도 마찬가지이다. 두 방법 모두 비즈니스 로직과 분리되어있는 것은 마찬가지겠지만, 개발자가 소스코드를 까보는 행위 자체를 아예 차단해버리거나 귀찮게 만듦으로써 분리된 모듈에 대한 맥락을 인식하는 것을 제한하려는 의도인 것이다. <small>(물론 의존성 관리가 가능하다는 점, 여러 어플리케이션 간 재사용이 용이하다는 점도 사내라이브러리의 장점이다)</small></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// 딱 봐도 레퍼런스타면 @quotalab/utils.d.ts로 갈 것처럼 생김</span>\n<span class=\"token comment\">// 그래서 사람들이 소스코드를 까볼 시도를 잘 안 한다</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> uniq <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@quotalab/utils'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 왠지 레퍼런스 타자마자 소스를 볼 수 있을 것만 같은 기분이 든다</span>\n<span class=\"token comment\">// 경로가 이렇게 생기면 뭔가 이상하다 싶을 때 사람들이 바로 소스 까봄 -> 맥락이 노출된다.</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> uniq <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'utils/array'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<center>\n  <small>\n    개발자가 소스코드를 까보기 귀찮게 만들어버리면, 괜히 쓸데없는 맥락에 노출될 위험도 줄어든다.\n  </small>\n  <br />\n  <br />\n</center>\n<p>결국 우리가 추상화를 해야하는 근본적인 이유는 내 코드를 읽는 다른 개발자, 혹은 미래의 나 자신이 코드의 동작을 이해할 때 너무 과한 맥락에 노출되지 않도록 맥락의 스코프를 만들어주는 것에 가깝다. 마치 컴퓨터를 사용할 때 반도체의 원리를 몰라도 괜찮은 것처럼 말이다.</p>\n<p>그러니 추상화를 진행하는 사람은 다른 사람들이 내 코드의 동작을 이해하고 활용하기 위해 어떤 부분까지 알아야하는지, 어떤 부분은 굳이 몰라도 되는지에 대한 깊은 고민을 해볼 필요가 있다.</p>\n<h3 id=\"표현에-대해서-고민하기\" style=\"position:relative;\">표현에 대해서 고민하기<a href=\"#%ED%91%9C%ED%98%84%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EA%B3%A0%EB%AF%BC%ED%95%98%EA%B8%B0\" aria-label=\"표현에 대해서 고민하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>결국 좋은 추상화라는 것이 디테일한 코드를 숨겨, 개발자가 내부를 까보지 않더라도 코드의 동작을 이해하는 비용을 줄일 수 있도록 도와주는 수단이라면, 이제 우리는 추상화해놓은 모듈 내부에 존재하는 코드를 외부 세계에 어떻게 하면 잘 표현하여, 내가 작성한 모듈을 사용하는 개발자가 모듈 내부를 까보지 않아도 동작을 충분히 유추할 수 있을지에 대한 고민을 시작해야 한다.</p>\n<p>흔히들 사람들이 제품에 대한 설명서를 제대로 안 읽는다는 우스갯소리가 있는데, 결국 이런 밈이 가능한 이유도 사용자가 굳이 설명서를 처음부터 끝까지 읽지 않더라도 제품의 사용 방법을 대략적으로 예측할 수 있도록 만들어졌기 때문이다. 즉, 설명서를 읽지 않아도 제품을 사용할 수 있다는 것은 역설적으로 그 제품이 누구에게나 익숙한 UX 패턴을 가지고 있다는 것을 의미한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e76956dc70409588a90016bfaa880d8c/d2602/paper.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEA//EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAGpp0lqMQf/xAAaEAACAgMAAAAAAAAAAAAAAAAAEQEQEiEi/9oACAEBAAEFAoNUzHpn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxABAAMAAAAAAAAAAAAAAAAAEAARYf/aAAgBAQAGPwKa2f/EABoQAAMBAAMAAAAAAAAAAAAAAAABESExUXH/2gAIAQEAAT8hXPCzrnSieEMaLRkLk//aAAwDAQACAAMAAAAQOM//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPxBGf//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EBJ//8QAGRABAQEBAQEAAAAAAAAAAAAAAREAITFh/9oACAEBAAE/ECWysEsxQBB8XEhymNvxmKdq2WzJwXZd/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"paper\" title=\"\" src=\"/static/e76956dc70409588a90016bfaa880d8c/c08c5/paper.jpg\" srcset=\"/static/e76956dc70409588a90016bfaa880d8c/0913d/paper.jpg 160w,\n/static/e76956dc70409588a90016bfaa880d8c/cb69c/paper.jpg 320w,\n/static/e76956dc70409588a90016bfaa880d8c/c08c5/paper.jpg 640w,\n/static/e76956dc70409588a90016bfaa880d8c/6a068/paper.jpg 960w,\n/static/e76956dc70409588a90016bfaa880d8c/eea4a/paper.jpg 1280w,\n/static/e76956dc70409588a90016bfaa880d8c/d2602/paper.jpg 4032w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>당장 필자부터도 간단한 장비에 대해서는 제대로 설명서를 읽지 않는다.<br>사실 워런티 카드가 있다는 것도 방금 알았다.</small>\n</center>\n<p>사실 대부분의 제품은 설명서를 읽어보지 않더라도, 눈에 보이는 버튼을 몇 번 눌러보고 대충 이것저것 만져보기만 해도 금새 사용법을 유추할 수 있다. 필자도 3년 전에 구매한 모니터 설명서를 아예 뜯지도 않았지만 모니터를 연결하고 사용하는 것에는 아무런 무리가 없었다.</p>\n<p>오히려 설명서를 읽지 않고는 전혀 제품의 사용 방법이나 동작을 유추할 수 없는 제품이라면, 그 제품의 사용법이 일반적이지 않고 너무 어렵다는 이야기이니 소비자들에게 외면받지는 않을까?</p>\n<p>우리가 만들어야 하는 모듈도 이와 똑같다. 설명서를 소스 코드라고 생각해보자. 추상화를 진행하는 개발자는 사용자가 설명서, 즉 소스 코드를 직접 까보지 않더라도 모듈의 사용 방법을 대략적으로라도 유추할 수 있도록 모듈의 동작, 입력/출력에 대해서 명확하게 표현해줘야 하는 것이다.</p>\n<p>우리가 외부 세계에 내부 동작을 표현하고 싶을 때 사용할 수 있는 방법은 크게 2가지 정도이다.</p>\n<blockquote>\n<ol>\n<li>\n<p>변수나 모듈의 이름</p>\n</li>\n<li>\n<p>대상이 함수나 클래스라면, 모듈의 입력과 출력 타입</p>\n</li>\n</ol>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">addDays</span><span class=\"token punctuation\">(</span>date<span class=\"token operator\">:</span> Date<span class=\"token punctuation\">,</span> amount<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Date<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 예시는 <a href=\"https://date-fns.org/v2.29.3/docs/addDays\" target=\"_blank\" rel=\"nofollow\">addDays</a>라는 <code class=\"language-text\">date-fns</code> 라이브러리의 함수의 정의이다. 이 함수는 이름만 봐도 특정 대상에게 <code class=\"language-text\">days</code>라는 것을 더하는 역할을 한다는 것을 알 수 있으며, <code class=\"language-text\">Date</code> 타입의 값과 <code class=\"language-text\">number</code> 타입의 값을 입력으로 받고 다시 <code class=\"language-text\">Date</code> 타입을 출력하고 있으니, 인자로 받은 <code class=\"language-text\">Date</code> 객체에 <code class=\"language-text\">amount</code> 만큼의 일자를 더한 <code class=\"language-text\">Date</code> 객체를 반환해준다는 동작을 유추해볼 수 있다.</p>\n<p>물론 필자는 이 함수를 호출했을 때 내부에서 정확히 어떤 일이 발생하는지 모른다. 뭐 대충 유추해보자면 <code class=\"language-text\">Date.prototype.getDate</code>로 일자를 가져와서 <code class=\"language-text\">amount</code> 만큼 값을 더하고 어쩌고 하는 행위를 수행하겠지만, 필자가 이 함수를 사용하기 위해 굳이 이런 것까지 알 필요는 없기 때문이다.</p>\n<p>필자는 그저 “이 함수를 사용하면 <code class=\"language-text\">Date</code> 객체에 원하는 만큼의 일자를 더한 새로운 <code class=\"language-text\">Date</code>객체를 얻을 수 있다”라는 사실 하나만 알면 되며, 이러한 사실은 함수의 이름과 입출력 타입에서 충분히 유추해볼 수 있다.</p>\n<p>하지만 만약 이 함수의 이름과 입출력 타입이 이런 느낌이었다면 어땠을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 301px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/61f22ae5a2042768a1b9ea04e05fc12e/e8ddc/mental.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 125.62499999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAZABQDASIAAhEBAxEB/8QAGQAAAwEBAQAAAAAAAAAAAAAAAAIEAwUG/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3hr2OYSB6ZNIRBA//8QAHRAAAgMAAgMAAAAAAAAAAAAAAQMAAhEEEhQzQf/aAAgBAQABBQLyFx+GMcanjq6gYynJrUO+HMZWhtB6p//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EACEQAAECBQUBAAAAAAAAAAAAAAEAIQIQERJhAxMjMoGR/9oACAEBAAY/Am1IfiughIBxRdrmVPVyPRHbDYlhMTIy/8QAHRABAAIDAAMBAAAAAAAAAAAAAQARITFBEFFx8f/aAAgBAQABPyHHoXr8RM1AsMje4bMjZblCByZagSDJVvYAAVICqep211mWJGNnY6fD4fJ//9oADAMBAAIAAwAAABCTxTz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAdEAEBAAICAwEAAAAAAAAAAAABEQAhMVFBYbGh/9oACAEBAAE/ECqLiaIdTB4OoAQhvDuXzibAguK+NczNsBZomzQ9kwx5R6g3T6Zz7uEkMKpZvALl2fuFpvKgUdc5O4gYbd5+Bz7/AKY4P//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"mental\" title=\"\" src=\"/static/61f22ae5a2042768a1b9ea04e05fc12e/e8ddc/mental.jpg\" srcset=\"/static/61f22ae5a2042768a1b9ea04e05fc12e/0913d/mental.jpg 160w,\n/static/61f22ae5a2042768a1b9ea04e05fc12e/e8ddc/mental.jpg 301w\" sizes=\"(max-width: 301px) 100vw, 301px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>도대체 무슨 일을 하는 녀석인지 알 수가 없다...!!!</small>\n</center>\n<p>일단 이 함수도 이름이 <code class=\"language-text\">add</code>이니 뭔가를 더하긴 더하는 것 같은데, 도대체 뭘 더한다는 것인지, 그리고 함수가 어떤 값을 반환하는지 전혀 감을 잡을 수가 없다. 왜냐하면 이 함수는 입출력에 대한 타입이나 변수명 등으로 자신 내부의 동작을 충실하게 표현하고 있지 않기 때문이다.</p>\n<p>만약 여러분이 이 함수를 사용하는 사용자라면 이 함수의 동작을 믿고 사용할 수 있을까? 아니 믿는 것은 둘째치더라도 도대체 이 함수가 뭐 하는 녀석인지 감을 잡을 수 없으니 아예 사용 자체를 안 하게 될 수도 있을 것 같다.</p>\n<p>혹여나 어떻게든 사용을 한다고 해도 드러난 표현만으로는 함수의 동작을 이해할 수 없어 저 함수의 소스 코드를 까봐야지만 해당 함수를 사용할 수 있을테니, 복잡한 맥락을 감출 수 있다는 추상화의 장점 또한 잃어버리게 된다.</p>\n<p>이런 경우 외에도 함수의 인자가 지나치게 많다던가, 함수의 이름이 함수의 동작과 다른 맥락을 표현하고 있다던가 하는 것들 또한 내 코드를 사용하는 개발자가 함수의 역할을 쉽게 유추하지 못 하게 방해하는 요소일 수 있다.</p>\n<p>이러한 표현의 중요성은 비단 함수가 아니더라도 클래스나 일반 변수 등 모듈 밖으로 노출될 수 있는 모든 개념들에게 공통적으로 적용되는 사항이며, 내가 작성한 코드를 사용할 다른 개발자나 혹은 미래의 나 자신을 배려하는 설계의 기초가 되는 것이기도 하다.</p>\n<h3 id=\"입력의-자유도를-제어해서-좋은-dx-만들기\" style=\"position:relative;\">입력의 자유도를 제어해서 좋은 DX 만들기<a href=\"#%EC%9E%85%EB%A0%A5%EC%9D%98-%EC%9E%90%EC%9C%A0%EB%8F%84%EB%A5%BC-%EC%A0%9C%EC%96%B4%ED%95%B4%EC%84%9C-%EC%A2%8B%EC%9D%80-dx-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"입력의 자유도를 제어해서 좋은 dx 만들기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>추상화된 모듈의 동작을 외부 세계에 제대로 표현하는 것에 대해 익숙하다면 이제는 내 모듈을 사용하는 사용자들의 DX에 대해서 깊게 고민해볼 차례이다.</p>\n<p>물론 DX를 만들어내는 요인은 여러가지가 있겠지만, 그 중에서도 필자가 가장 신경쓰는 부분 중 하나는 바로 “기능을 어디까지 열어줄 것이냐”이다. 왜냐하면 이 의사결정에 의해 필자가 개발한 모듈을 사용하는 사람들의 작업 리소스, 인지해야하는 맥락의 정도, 휴먼 에러의 가능성 등이 달라질 수 있기 때문이다.</p>\n<p>예를 들어 간단한 버튼 컴포넌트 하나를 개발한다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Button</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> children <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> PropsWithChildren<span class=\"token operator\">&lt;</span><span class=\"token builtin\">unknown</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위 컴포넌트는 외부 세계에 자신의 기능을 많이 드러내지 않고 있는, 이른바 기능이 닫힌 컴포넌트이다. 애초에 컴포넌트 자체에서 <code class=\"language-text\">children</code>을 꽂아넣을 수 있는 기능만을 제공하고 있으니, 이런 컴포넌트를 사용하는 사용자는 선택의 자유도가 높지 않다.</p>\n<p>그나마 <code class=\"language-text\">children</code>이라는 프로퍼티는 합성을 통해 마음껏 외부에서 주입할 수 있겠지만, 그 외에 <code class=\"language-text\">button</code>의 <code class=\"language-text\">type</code>을 변경하고 싶다던가, 클릭 이벤트 핸들러를 사용하고 싶다던가 하는 것들은 전부 불가능하기 때문이다.</p>\n<p>그러나 제공해주고 있는 기능 자체가 매우 제한적이고 적기 때문에, 이 컴포넌트를 사용하는 사용자는 컴포넌트의 사용법에 대해서 크게 고민해야 할 필요가 사라졌다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> Button <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> ComponentProps<span class=\"token operator\">&lt;</span><span class=\"token string\">'button'</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>props<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>반면 위 컴포넌트는 React의 <code class=\"language-text\">button</code> 컴포넌트가 기존에 제공하고 있던 모든 기능을 입력으로 받을 수 있도록 설계되었다. 이런 컴포넌트를 사용하는 사용자는 자신이 원하는 <code class=\"language-text\">button</code> 컴포넌트의 프로퍼티를 모두 사용할 수 있으니 자유도가 높은 개발을 할 수 있을 것이다.</p>\n<p>그러나 컴포넌트가 제공하는 프로퍼티가 매우 많기 때문에 사용하는 입장에서도 자신의 목적과 다소 어긋난 맥락들에 지속적으로 노출될 수 있다. 필자는 이런 상황을 주로 “컴포넌트가 개발자에게 고민을 강요한다” 표현한다.</p>\n<p>또한 이 컴포넌트를 개발한 사람 입장에서는 사용자가 어떤 방식으로 내가 설계한 모듈을 사용하게 될 지에 대한 모든 경우의 수를 예측할 수 없으니 그만큼 버그나 설계 의도와 벗어난 사용 사례가 늘어날 수 있다는 리스크도 있다.</p>\n<p>즉, 추상화된 모듈을 만드는 개발자는 모듈의 입력 범위를 제어함으로써, 사용자가 어떤 방식으로 내 모듈을 사용하게 만들지도 어느 정도 제어할 수 있다는 것이다. 그러니 이런 입력에 대한 설계는 모듈을 사용하는 개발자의 DX와도 직결된다.</p>\n<p>이런 고민은 주로 다양한 개발자들이 함께 사용해야하는 사내라이브러리 등을 개발할 때 주로 하게 되는데, 특히 디자인 시스템 같은 경우는 이러한 인터페이스를 설계할 때 디자이너 분들의 의도까지 함께 녹여야하니 더 복잡한 상황이 펼쳐진다. <small>(코드에 정의된 프로퍼티들이 Figma, Framer 등에 정의된 프로퍼티와 유사할수록 개발자/디자이너 간 커뮤니케이션 비용이 낮아진다)</small></p>\n<p>사실 모듈의 입력을 많이 열어줄 것이 좋냐, 혹은 제한할 것이 좋냐에 대한 정답은 없다. 이는 모듈을 사용하는 사용자들의 전문성, 모듈의 목적과 용도, 혹은 오픈소스와 같은 불특정 다수의 사용자인지 사내라이브러리같은 제한된 그룹의 사용자인지에 따라서도 달라질 수 있기 때문이다.</p>\n<p>이렇게 비슷한 역할을 하는 도구라고 해도 제공해주는 기능의 범위를 제한함으로써 사용자의 경험을 만들어나가는 개념은 비단 코드 뿐 아니라 우리의 일상 속에서도 흔히 볼 수 있는 개념이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6754c9f5811dfe2b0eeedef280d18fc0/12609/synth2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 49.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMCBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAFkNwEFkP/EABwQAAAGAwAAAAAAAAAAAAAAAAABAgMSEwQQEf/aAAgBAQABBQJ1b103xjyriQ4Wv//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABsQAQACAgMAAAAAAAAAAAAAAAEAAhExECIy/9oACAEBAAY/ArlLOBnpndyzRNcf/8QAHBABAAEEAwAAAAAAAAAAAAAAAQARITFhQVGR/9oACAEBAAE/IcIAU6hHT5g3l1bzqa3kAMFJ/9oADAMBAAIAAwAAABD0D//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAQEAAgEFAAAAAAAAAAAAAAERADEhQVGB0fH/2gAIAQEAAT8QUDEIk4DNYk0eD1htaNXUvGO0BVirny2EwB2CZ//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"synth2\" title=\"\" src=\"/static/6754c9f5811dfe2b0eeedef280d18fc0/c08c5/synth2.jpg\" srcset=\"/static/6754c9f5811dfe2b0eeedef280d18fc0/0913d/synth2.jpg 160w,\n/static/6754c9f5811dfe2b0eeedef280d18fc0/cb69c/synth2.jpg 320w,\n/static/6754c9f5811dfe2b0eeedef280d18fc0/c08c5/synth2.jpg 640w,\n/static/6754c9f5811dfe2b0eeedef280d18fc0/6a068/synth2.jpg 960w,\n/static/6754c9f5811dfe2b0eeedef280d18fc0/eea4a/synth2.jpg 1280w,\n/static/6754c9f5811dfe2b0eeedef280d18fc0/12609/synth2.jpg 3000w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 498px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5a9317f4f11dd17948f8a328924b4d7d/4e442/piano.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 67.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABAADBv/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAV5CGdNHj//EABwQAAMAAQUAAAAAAAAAAAAAAAECAwAEERIUMf/aAAgBAQABBQJtau/YocnfkqIAlLk5Pz//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAeEAACAQMFAAAAAAAAAAAAAAAAASEikbECAxFBUf/aAAgBAQAGPwKi5GCVK8HudI400othH//EABwQAAICAwEBAAAAAAAAAAAAAAERADEhQYFRcf/aAAgBAQABPyHEAx6jWroWPJqMiLMQnOAzA5E21Z+mDlF//9oADAMBAAIAAwAAABAkD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB4QAQACAwACAwAAAAAAAAAAAAEAESExcUFhobHw/9oACAEBAAE/ELogc3huIwrZIHhtX65bX4TGaHCdltPnQb+hwdywJWqV/KP1DV1iT//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"piano\" title=\"\" src=\"/static/5a9317f4f11dd17948f8a328924b4d7d/4e442/piano.jpg\" srcset=\"/static/5a9317f4f11dd17948f8a328924b4d7d/0913d/piano.jpg 160w,\n/static/5a9317f4f11dd17948f8a328924b4d7d/cb69c/piano.jpg 320w,\n/static/5a9317f4f11dd17948f8a328924b4d7d/4e442/piano.jpg 498w\" sizes=\"(max-width: 498px) 100vw, 498px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>전문적인 오디오 지식이 있는 사람들은 기능이 다양한 신디사이저를 적재적소에 활용하지만<br>전문적인 지식이 없다면 차라리 기능이 제한된 디지털 피아노를 사용하는 게 더 목적에 맞을 수 있다.\n  <small>\n</small></small></center>\n<p>신디사이저라는 악기는 오디오 파형을 직접적으로 변경해가면서 원하는 소리를 만들 수 있는 악기이기에 사용자에게 무궁무진한 자유도를 가져다 주지만, 만약 오디오에 대한 전문적인 지식이 없는 사람에게 이런 악기를 가져다준다면 제대로 사용하지도 못 하고 이것저것 만져보다가 당근마켓에 올려버릴 가능성이 높다.</p>\n<p>게다가 이렇게 복잡한 장비들은 전압에 민감하게 반응하도록 설계된 경우도 있어, 사용자의 부주의로 인해 자칫 장비가 망가질 위험도 존재한다.</p>\n<p>그러니 오히려 전문적인 지식이 없는 사람이거나, 아예 이런 자유도가 필요없는 사람에게는 신디사이저보다 기능은 제한되어있지만 비전문가도 편하게 접근하여 이쁜 소리를 낼 수 있는 디지털 피아노가 더 적당할 수 있는 것이다.</p>\n<p>즉, 단순히 전문가가 더 많이 알고 있으니 기능을 노출시켜주자는 개념보다는 해당 도구가 사용되어야 하는 상황과 사용하는 사람이 도구의 원리에 대해서 알 필요가 있냐, 없냐에 따라 달라지는 개념이다. 애초에 단순히 피아노를 치고 싶어하는 사람이 신디사이저 같이 복잡하고 기능이 다양한 악기를 살 필요가 없다는 말이다.</p>\n<p>필자가 예시로 들었던 악기가 아니더라도 자동차의 수동 변속기와 자동 변속기, 휴대폰과 HAM에 사용하는 무선송수신기, C와 JavaScript처럼 비슷한 기능을 제공하지만 도구의 목적과 사용자의 페르소나에 따라 기능의 범위를 제한하는 개념은 무궁무진하게 많다.</p>\n<p>결국 우리는 사용자가 도구의 원리를 알 필요도 없는 상황에서 넓은 범위의 입력을 구현하여 괜히 고민하도록 만들거나, 반대로 도구의 원리를 이해하고 다양한 상황에 재사용해야하는 상황에서 좁은 범위의 입력을 구현하여 사용처를 제한해버리는 설계를 하지 않도록 주의해야 하는 것이다.</p>\n<p>앞서 이야기했던 것처럼 이는 비즈니스나 조직의 상황, 도구의 목적, 사용자들의 니즈 등의 문제를 모두 고려해서 의사결정해야하는 부분인 만큼 어떠한 정답이 있는 문제는 아니지만, 적어도 나 이외에 사용자들이 함께 사용해야하는 모듈을 추상화하여 만들어야 하는 입장이라면 한번 쯤 고민해볼만한 문제라고 생각한다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>오늘날 지구 상에 존재하는 모든 개발자들은 다른 개발자들과 긴밀한 협력 관계에 놓여있다. 물론 프리랜서나 초기 스타트업에서 일하는 분들처럼 혼자서 개발하는 분들도 있겠지만, 결국 그 분들도 다른 사람이 고안하고 개발한 도구를 가져다 쓰는 것을 피할 수는 없으며, 내가 작성한 코드를 무덤까지 가져가는 것도 아니니 언젠가는 다른 개발자가 내 코드를 이어받는 그 날이 반드시 찾아온다.</p>\n<p>결국 내가 지금 작성한 코드를 다른 사람이 읽고 이해해야하는 순간은 피할 수 없기 때문에, 우리는 기본적으로 사람이 이해하기 좋은 코드를 작성하는 것이 힘을 기울일 수 밖에 없는 것이다. 심지어 정말로 혼자서만 작성하는 코드라고 해도, 결국 미래의 나 자신이 모든 코드의 동작을 기억하고 있을거란 보장이 없으니 미래의 나 자신을 위해서라도 이런 코드를 작성해야한다.</p>\n<p>결국 프로그래밍에서의 추상화는 복잡한 원리를 가진 무언가 또는 컴퓨터는 이해하기 쉽지만 사람은 이해하기 어려운 무언가를 사람이 이해하기 쉽도록 만드는 과정이다. 물론 좋은 추상화를 하는 방법이나 노하우는 사람마다 다를 수 있지만, 결국 이러한 추상화의 본질 자체는 바뀌지 않는 것이다.</p>\n<p>필자는 개인적으로 추상화에 대한 방법이나 노하우는 그렇게 중요하지 않다고 생각한다. 앞서 말한 것처럼 변경에 열린 설계를 하기 위한 패턴이나 방법들은 이미 인터넷에 널려있고, 이미 깔끔하게 정리되어있는 개념들이 많기 때문에 그 정보들을 읽고 몇 번 사용해보는 것만으로도 익히는 것에는 크게 문제가 없을 것이다.</p>\n<p>다만 추상화라는 선물이 우리에게 가져다주는 근원적 가치에 대한 이해가 없다면, 이렇게 공부한 정보들이 나에게 정말로 유용한 것인지 아닌지에 대한 가치 판단마저도 하기 어렵게 되어버릴 수 있다.</p>\n<p>개발자들은 모든 문제를 해결할 수 있는 만능적인 해결책은 존재하지 않는다는 “No Silver Bullet”이라는 문장을 자주 사용한다. 이 문장이 의미하는 것처럼 우리가 접하는 수많은 정보들은 모두 이익만을 가져다주는 것이 아니며, 때로는 내가 내린 기술적 의사결정으로 인해서 오히려 잃는 것이 발생할 수도 있다.</p>\n<p>이런 상황 속에서 개발자는 항상 내가 내리는 의사결정이 가져다주는 이익과 그와 반대로 잃게되는 손해에 대해서 냉철하게 저울질해보고 판단해야하며, 필자는 이러한 의사결정에 도움이 되는 것이 바로 “해당 기술이 가져다주는 근원적 가치에 대한 이해”라고 생각한다.</p>\n<p>물론 이 포스팅에서 필자가 작성한 것이 정답이라는 이야기는 아니다. 이 내용은 필자가 지금까지 개발자로 일을 하면서 고민했던 내용에 불과하며, 전 세계에 존재하는 수천만 명의 개발자들 또한 각각 저마다의 고민 끝에 내려진 정의를 가지고 있으리라 생각한다.</p>\n<p>필자가 고민해온 이 내용들이 독자 여러분이 내렸던 혹은 앞으로 내릴 추상에 대한 정의에 조금이나마 도움이 되길 바라면서, 이상으로 추상이란 무엇일까 포스팅을 마친다.</p>","fields":{"slug":"20230115-what-is-abstract","path":"/2023/01/15/what-is-abstract/","lang":"ko"},"frontmatter":{"title":"추상이란 무엇일까","subTitle":"좋은 추상화는 구현보다 어렵다","date":"Jan 15, 2023","categories":["프로그래밍"],"tags":["추상","어플리케이션 설계","추상화"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/82222057f7a754072d2c49600010a527/3a812/thumbnail.jpg","srcSet":"/static/82222057f7a754072d2c49600010a527/3a812/thumbnail.jpg 320w,\n/static/82222057f7a754072d2c49600010a527/6a16a/thumbnail.jpg 629w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/82222057f7a754072d2c49600010a527/fc5c5/thumbnail.webp 320w,\n/static/82222057f7a754072d2c49600010a527/5fd7a/thumbnail.webp 629w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/82222057f7a754072d2c49600010a527/e1dd5/thumbnail.jpg","srcSet":"/static/82222057f7a754072d2c49600010a527/e1dd5/thumbnail.jpg 629w","sizes":"100vw"},"sources":[{"srcSet":"/static/82222057f7a754072d2c49600010a527/67948/thumbnail.webp 629w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5007949125596184}}}}}}]}},"pageContext":{"tag":"추상화","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}