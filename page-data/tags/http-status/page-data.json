{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/http-status/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"5fcbcf92-b72a-58d5-8d81-781a1ac6c721","tableOfContents":"<ul>\n<li>\n<p><a href=\"#rest%EA%B0%80-%EC%9D%98%EB%AF%B8%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">REST가 의미하는 것이 무엇인가요?</a></p>\n<ul>\n<li><a href=\"#%EC%82%AC%EC%8B%A4-%EC%A3%BC%EA%B3%A0-%EB%B0%9B%EB%8A%94-%EA%B2%83%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EA%B0%80-%EC%95%84%EB%8B%88%EB%8B%A4\">사실 주고 받는 것은 리소스가 아니다.</a></li>\n<li><a href=\"#%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%9C-%EC%83%81%ED%83%9C%EB%9D%BC%EB%8A%94-%EA%B2%83%EC%9D%98-%EC%9D%98%EB%AF%B8\">리소스를 표현한 상태라는 것의 의미</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#restful-api\">RESTful API</a></p>\n<ul>\n<li><a href=\"#uri%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%96%B4%EB%96%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%EC%9D%B8%EC%A7%80-%ED%91%9C%ED%98%84%ED%95%98%EC%9E%90\">URI를 사용하여 어떤 리소스인지 표현하자</a></li>\n<li><a href=\"#http-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%96%B4%EB%96%A4-%ED%96%89%EC%9C%84%EC%9D%B8%EC%A7%80-%ED%91%9C%ED%98%84%ED%95%98%EC%9E%90\">HTTP 메소드를 사용하여 어떤 행위인지 표현하자</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 프론트엔드 개발자와 백엔드 개발자가 만나는 지점인 API에 대한 이야기를 해보려고한다. 일반적으로 앱이나 웹 상에서 작동하는 어플리케이션을 개발할 때는 주로 HTTP나 HTTPS 프로토콜을 사용하여 API를 만들게 되는데, 이 API의 정의가 얼마나 직관적이고 명확하냐에 따라 프로젝트의 복잡도가 크게 낮아지게 될 만큼 시스템 설계에 있어서 꽤나 중요한 자리를 차지하고 있다.","html":"<p>이번 포스팅에서는 프론트엔드 개발자와 백엔드 개발자가 만나는 지점인 API에 대한 이야기를 해보려고한다.</p>\n<p>일반적으로 앱이나 웹 상에서 작동하는 어플리케이션을 개발할 때는 주로 HTTP나 HTTPS 프로토콜을 사용하여 API를 만들게 되는데, 이 API의 정의가 얼마나 직관적이고 명확하냐에 따라 프로젝트의 복잡도가 크게 낮아지게 될 만큼 시스템 설계에 있어서 꽤나 중요한 자리를 차지하고 있다.</p>\n<!-- more -->\n<p>그래서 우리는 일종의 약속을 통해 이 API가 어떤 동작을 수행하는 API인지를 명확하게 정의해야 하며, 이 API 정의 과정에서 우리가 사용할 수 있는 요소들이 바로 “HTTP 메소드”와 “URI(Uniform Resource Identifiers)“이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET https://evan.com/users/1</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>HTTP API의 엔드포인트는 위와 같이 HTTP 메소드와 URI를 사용하여 이 API가 어떠한 동작을 수행하는 API인지를 표현하게 된다.</p>\n<p>여기서 중요한 포인트는 사용자가 이 표현을 읽고난 뒤 API에게 기대하는 동작과 실제로 서버가 수행하는 동작이 명확하게 일치되어야 한다는 것이다. 우리가 서버에게 “앞으로 한 걸음 가줘!”라고 요청했는데 서버가 응답으로 “ㅇㅋ 뒤로 한 걸음 갔음!”이라고 한다면 꽤나 당황스럽지 않겠는가?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5304fec38eebf202dff1871c8dc2a88e/6aca1/doesnt_know.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAwAE/8QAFAEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABTEBjtgk//8QAGhABAQACAwAAAAAAAAAAAAAAAQIAAwQRMf/aAAgBAQABBQJvX3yLhDXDL7bkSM//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwFn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGxAAAgIDAQAAAAAAAAAAAAAAAAECERASIbH/2gAIAQEABj8Cu0yOngm5jx0//8QAGxABAAMAAwEAAAAAAAAAAAAAAQARITFBUZH/2gAIAQEAAT8hDdefeJhi76pNoCekB8YjTe6Qui2f/9oADAMBAAIAAwAAABBHH//EABYRAAMAAAAAAAAAAAAAAAAAAAEQIf/aAAgBAwEBPxCiv//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/EEf/xAAcEAEBAAICAwAAAAAAAAAAAAABEQAxUWEhQYH/2gAIAQEAAT8QC7sJVOqcd571u7BOzJ5BKJT5iKh5hnGBMkIPBlypaq5//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"doesnt know\" title=\"\" src=\"/static/5304fec38eebf202dff1871c8dc2a88e/c08c5/doesnt_know.jpg\" srcset=\"/static/5304fec38eebf202dff1871c8dc2a88e/0913d/doesnt_know.jpg 160w,\n/static/5304fec38eebf202dff1871c8dc2a88e/cb69c/doesnt_know.jpg 320w,\n/static/5304fec38eebf202dff1871c8dc2a88e/c08c5/doesnt_know.jpg 640w,\n/static/5304fec38eebf202dff1871c8dc2a88e/6aca1/doesnt_know.jpg 650w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>사람끼리든 컴퓨터끼리든 표현을 제대로 안하면 못 알아먹는다</small>\n</center>\n<p>그래서 우리는 <a href=\"https://ko.wikipedia.org/wiki/REST\" target=\"_blank\" rel=\"nofollow\">REST</a>와 같은 가이드라인을 사용한다. REST는 지난 2000년, 로이 필딩(Roy Fielding) 아저씨가 자신의 박사학위 논문에서 소개한 API 아키텍처 가이드라인이며, 무려 20년이 지난 현재까지도 널리 사용되고 있다.</p>\n<p>하지만 지난 번 <a href=\"/2020/03/15/about-http-status-code/\">서버의 상태를 알려주는 HTTP 상태 코드</a> 포스팅에서 이야기했듯이, 이건 말 그대로 가이드라인이기 때문에 지키지 않는다고 해서 에러가 발생하거나 하는 게 아니지만, 그렇다고해서 이런 가이드라인을 무시하고 마음대로 개발해도 된다는 것은 아니다. REST라는 용어와 개념은 이미 업계에 널리 퍼져있기 때문에, 많은 개발자들이 HTTP API를 만났을 때 이 API가 당연히 RESTful하게 작성되었을 것이라고 생각하기 때문이다. <small>(사실 상 표준이라고 봐도 무방할 정도의 영향력이다)</small></p>\n<p>그런 이유로 이번 포스팅에서는 이 REST라는 것이 도대체 왜 나오게 된 것인지, 또 REST가 뭘 의미하길래 사람들이 매번 RESTful, RESTful 하는 것인지에 대한 이야기를 나눠보려고 한다.</p>\n<h2 id=\"rest가-의미하는-것이-무엇인가요\" style=\"position:relative;\">REST가 의미하는 것이 무엇인가요?<a href=\"#rest%EA%B0%80-%EC%9D%98%EB%AF%B8%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\" aria-label=\"rest가 의미하는 것이 무엇인가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>REST는 <strong>RE</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer의 약자이다. 이 거창해보이는 단어의 핵심은 바로 Representational State, 한국말로 간단히 직역하면 대표적인 상태 정도의 뜻을 가진 단어이며, 이를 조금 더 유연하게 번역해보자면 “표현된 상태”라고 할 수 있다. 이때 이야기하는 상태라 함은 서버가 가지고 있는 리소스의 상태를 이야기한다.</p>\n<p>즉, REST는 통신을 통해 자원의 표현된 상태를 주고받는 것에 대한 아키텍처 가이드라인이라고 할 수 있다.</p>\n<p>REST에 대한 이야기를 할 때, 많은 분들이 이 표현된 상태(Representational State)에 대한 이해를 어려워하는데, 이는 클라이언트와 서버가 API 통신을 통해 주고 받고 있는 것들이 리소스 그 자체라고 생각하기 때문이다.</p>\n<p>하지만 조금만 생각해보면 우리가 통신을 통해 리소스를 직접 주고받고 있지 않다는 사실을 알 수 있다.</p>\n<h3 id=\"사실-주고-받는-것은-리소스가-아니다\" style=\"position:relative;\">사실 주고 받는 것은 리소스가 아니다.<a href=\"#%EC%82%AC%EC%8B%A4-%EC%A3%BC%EA%B3%A0-%EB%B0%9B%EB%8A%94-%EA%B2%83%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EA%B0%80-%EC%95%84%EB%8B%88%EB%8B%A4\" aria-label=\"사실 주고 받는 것은 리소스가 아니다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>우리가 API를 통해 주고 받는 리소스는 어떤 문서일수도 있고, 이미지 또는 단순한 JSON 데이터일 수도 있다. 하지만 사실 우리는 리소스를 직접 주고 받는 것이 아니다. 한번 간단한 예시를 통해 이 말이 어떤 의미인지 살펴보도록 하자.</p>\n<p>자, 여기 클라이언트가 서버에게 특정 유저의 정보를 받아오는 API 엔드포인트를 통해 요청을 보냈다고 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET https://iamserver.com/api/users/2\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">iamserver.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>클라이언트는 이 API 엔드포인트를 사용하여 서버에게 2번 유저의 자원을 요청했고, 서버가 요청을 성공적으로 처리했다면 클라이언트는 서버로부터 대략 이런 느낌의 응답을 받을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Length</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">45</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token application-json\">\n<span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token operator\">:</span> 'Evan'<span class=\"token punctuation\">,</span>\n  org<span class=\"token operator\">:</span> 'Viva Republica'<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>자, 서버가 보내준 응답의 바디에는 2번 유저의 데이터가 담겨있다. 일반적으로 우리는 이 상황을 <code class=\"language-text\">/api/users/2</code>라는 엔드포인트를 통해서 2번 유저 데이터 리소스를 받아왔다고 표현하고는 한다. 사실 필자도 편의상 이런 표현을 자주 사용하고는 한다.</p>\n<p>그런데…정말로 지금 서버가 보내준 저 JSON 데이터가 리소스 자체일까?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5fafe421bec63ab1a86624ca4488daf0/6a068/no.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 54.37499999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAQP/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABrlbpRogn/8QAGRABAQEAAwAAAAAAAAAAAAAAAQARAgMi/9oACAEBAAEFAh99xvLMhZtb/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGxAAAgEFAAAAAAAAAAAAAAAAAAFRAhARYYH/2gAIAQEABj8CdMGJEtHb/wD/xAAaEAACAgMAAAAAAAAAAAAAAAAAARFRITFB/9oACAEBAAE/IXPg3fBM7IcaIaUC9vIsO4//2gAMAwEAAgADAAAAEPgv/8QAFREBAQAAAAAAAAAAAAAAAAAAERD/2gAIAQMBAT8QSf/EABURAQEAAAAAAAAAAAAAAAAAABEA/9oACAECAQE/EBi//8QAHBABAAMAAgMAAAAAAAAAAAAAAQARITFRYXGB/9oACAEBAAE/EKoUDjSZxogWj5EWggiF1KCX1fJya1r3ANGPU//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"no\" title=\"\" src=\"/static/5fafe421bec63ab1a86624ca4488daf0/c08c5/no.jpg\" srcset=\"/static/5fafe421bec63ab1a86624ca4488daf0/0913d/no.jpg 160w,\n/static/5fafe421bec63ab1a86624ca4488daf0/cb69c/no.jpg 320w,\n/static/5fafe421bec63ab1a86624ca4488daf0/c08c5/no.jpg 640w,\n/static/5fafe421bec63ab1a86624ca4488daf0/6a068/no.jpg 960w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>땡. 저건 2번 유저의 리소스가 아니다!</small>\n</center>\n<p>사실 서버에서 보내준 저 JSON은 리소스 원본이 아니라 데이터베이스에 저장된 2번 유저의 데이터 리소스를 표현한 것에 불과하다. 서버는 클라이언트의 요청을 받고 2번 유저의 정보를 데이터베이스에서 조회한 후 요청의 헤더에 담겨있던 <code class=\"language-text\">application/json</code>이라는 방식으로 표현하여 응답에 담아준 것이다.</p>\n<p>곰곰히 생각해보면 당연한 이야기인 것이, 서버가 접근하는 진짜 리소스 원본은 그저 데이터베이스에 담겨있는 하나의 로우이거나 파일에 작성된 데이터일 것이다. 물론 서버의 로컬 시스템에 리소스를 JSON 파일로 저장하고 있을 수도 있지만 어쨌든 포인트는 서버가 보내준 저 JSON이 원본 리소스가 아니라는 것이다.</p>\n<p>서버가 보내준 JSON은 단지 데이터베이스에 저장되어있는 원본 데이터 리소스의 현재 상태를 표현한 것이다.</p>\n<h3 id=\"리소스를-표현한-상태라는-것의-의미\" style=\"position:relative;\">리소스를 표현한 상태라는 것의 의미<a href=\"#%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%9C-%EC%83%81%ED%83%9C%EB%9D%BC%EB%8A%94-%EA%B2%83%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"리소스를 표현한 상태라는 것의 의미 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>앞서 이야기했듯이 REST가 이야기하는 Representation State라는 단어는 원본 리소스를 표현한 상태라는 것을 의미한다. 원본 리소스는 데이터베이스에 저장된 하나의 로우로써 존재하지만 클라이언트에게 이걸 그대로 넘겨줄 수는 없으니 서버가 원본 리소스를 읽어와서 적당한 상태로 표현해주는 것이다.</p>\n<p>그리고 이 적당한 상태에 대한 힌트는 HTTP 요청 헤더나 응답 헤더에 전부 나와있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET https://iamserver.com/api/users/2\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">iamserver.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위에서 예시로 들었던 상황에서 클라이언트는 서버에게 2번 유저의 리소스를 요청하며 요청 헤더의 <code class=\"language-text\">Accept</code>라는 키에 <code class=\"language-text\">application/json</code>이라는 값을 담아서 보냈다. 클라이언트가 서버에게 “2번 유저의 상태를 json으로 표현해줘”라는 요청을 보낸 것이다. 만약 클라이언트가 <code class=\"language-text\">application/json</code>이 아닌 <code class=\"language-text\">application/xml</code>을 담아보냈고, 서버가 XML 포맷의 표현을 지원하도록 작성되어있다면 2번 유저의 리소스는 XML 형태로 표현되어 내려왔을 것이다.</p>\n<p>그리고 서버는 응답 헤더에 <code class=\"language-text\">Content-Type</code>이나 <code class=\"language-text\">Content-Language</code>와 같은 키를 사용하여 이 리소스가 어떤 방식으로 표현된 상태인지 클라이언트에게 알려주고, 클라이언트 또한 이 정보를 읽은 후 각 컨텐츠 타입에 맞게 정보를 파싱한다.</p>\n<p>즉, 클라이언트는 2번 유저의 리소스를 받은 것이 아니다. JSON으로 표현된 2번 유저 리소스의 현재 상태를 받은 것이다. 이처럼 REST는 클라이언트와 서버가 리소스의 타입이나 원하는 언어 등을 사용하여 자원을 자유롭고 명확하게 표현할 수 있는 것에 집중한다.</p>\n<h2 id=\"restful-api\" style=\"position:relative;\">RESTful API<a href=\"#restful-api\" aria-label=\"restful api permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 이야기했듯이, REST는 결국 리소스를 어떻게 하면 명확하게 표현할 수 있을지에 대한 것에 집중하는 아키텍처 스타일이다. 하지만 우리가 HTTP API를 사용할 때는 단순히 리소스의 표현 상태만으로는 클라이언트가 API를 호출했을 때 서버에서 정확히 어떤 일이 발생하는지 알기가 어렵다.</p>\n<p>REST는 단지 리소스가 표현된 상태만을 이야기할 뿐, 어떠한 “행위”에 대해서는 이야기하고 있지 않기 때문이다. 하지만 클라이언트가 서버의 API를 사용할 때 원하는 것은 소스를 생성하거나 삭제하거나 수정하는 등 명백히 어떠한 행위이다.</p>\n<p>그래서 RESTful API에서는 REST 아키텍처를 통해 표현된 리소스와 더불어 어떠한 행위를 명시할 수 있는 HTTP 메소드와 URI까지 활용하게 되며, 각 요소들이 표현하고 있는 것들은 다음과 같다.</p>\n<hr>\n<ol>\n<li>리소스가 어떻게 표현되는지? - <strong>REST</strong></li>\n<li>어떤 리소스인지? - <strong>URI</strong></li>\n<li>어떤 행위인지? - <strong>HTTP 메소드</strong></li>\n</ol>\n<hr>\n<p>즉, 이 요소들을 사용하여 명확하게 정의된 API를 사용하는 클라이언트는 굳이 API에 대한 구구절절한 설명이 없이 <code class=\"language-text\">GET /users/2</code>와 같은 엔드포인트만 보고도 “음, 2번 유저의 정보를 가져오는 API겠군”이라고 추측할 수 있게 되는 것이다.</p>\n<p>이 3가지 요소 중 리소스를 표현하는 방법인 REST에 대해서는 앞서 이미 이야기했으니, 이번 섹션에서는 어떤 리소스인지를 표현하는 URI와 어떤 행위인지를 표현하는 HTTP 메소드에 대해 알아보도록 하자.</p>\n<h3 id=\"uri를-사용하여-어떤-리소스인지-표현하자\" style=\"position:relative;\">URI를 사용하여 어떤 리소스인지 표현하자<a href=\"#uri%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%96%B4%EB%96%A4-%EB%A6%AC%EC%86%8C%EC%8A%A4%EC%9D%B8%EC%A7%80-%ED%91%9C%ED%98%84%ED%95%98%EC%9E%90\" aria-label=\"uri를 사용하여 어떤 리소스인지 표현하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>RESTful API의 URI는 이 API가 어떤 리소스에 대한 API인지를 나타내는 요소이다. 예를 들어, 서비스를 사용하는 유저의 목록을 가져오는 API가 있다고 생각해보자. 이 API를 사용하는 클라이언트가 접근하고자 하는 리소스는 “유저”가 될 것이고, 이 API의 URI는 명확하게 유저를 표현하고 있어야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET /users</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>솔직히 이 정도 URI면 지나가던 중학생이 봐도 뭔가 유저와 관련이 있다는 것을 알 수 있을 정도로 명확하다. 그런데 유저라는 리소스를 왜 <code class=\"language-text\">user</code>라고 표현하지 않고 굳이 <code class=\"language-text\">users</code>라는 복수형으로 표현하고 있는 것일까?</p>\n<p>그 이유는 유저라는 리소스가 특정한 하나의 객체가 아니기 때문이다. 이건 영어로 “나는 고양이를 좋아해!”라는 문장을 이야기할 때 “I love <strong>a cat</strong>“가 아닌 “I love <strong>cats</strong>“라고 하는 것과 같은 맥락이다.</p>\n<p>나는 어떤 특정한 고양이를 좋아하는 것이 아니라 고양이라는 생물 자체를 좋아하는 것이고, 이때 고양이라는 단어는 우리 아파트 앞에서 쓰레기통 뒤지고 있는 점박이 고양이, 이름 모를 사람이 인스타그램에 이쁘다고 자랑하는 지네 집 고양이, 길 가다가 우연히 마주치는 고양이까지 모두 포함되는 다소 추상적인 리소스를 의미하는 것이기 때문이다.</p>\n<p>자, 그럼 유저들이라는 추상적인 리소스에서 한 단계 더 구체화 시켜보도록 하자. 유저라는 추상적인 리소스를 조금 더 구체화한 다음 레벨의 리소스는 “특정 유저”이다.</p>\n<h4 id=\"리소스의-계층을-표현하기\" style=\"position:relative;\">리소스의 계층을 표현하기<a href=\"#%EB%A6%AC%EC%86%8C%EC%8A%A4%EC%9D%98-%EA%B3%84%EC%B8%B5%EC%9D%84-%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0\" aria-label=\"리소스의 계층을 표현하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>일반적으로 유저들은 각각 고유한 ID를 가지고 있는 경우가 많으니, 이 ID를 사용하면 특정한 유저를 대충 이런 URI로 표현할 수 있을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET /users/2</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>굳이 설명하지 않더라도 다들 눈치채셨겠지만, 이 URI는 유저들을 의미하던 <code class=\"language-text\">/users</code>라는 URI 뒤 쪽에 각 유저들이 고유하게 가지고 있는 ID를 추가하여 특정한 유저를 식별할 수 있도록 만든 것이다.</p>\n<p>또한 이 URI가 표현하고 있는 리소스인 “2번 유저”는 “유저”라는 리소스의 하위 집합이라고 할 수 있고, RESTful API는 이러한 리소스 간의 계층 구조를 <code class=\"language-text\">/</code>를 사용하여 표현할 것을 권장하고 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b57aa2a5b2149437f1bfe0021e65f2f7/5bb8b/resource_layer.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 98.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC+klEQVR42p2U7U4TQRSGeysmXoHxF5LS7m63xSCUtNtSW6C0hbYg1sIfo0BsKSY0oR9sheWjH6DEbNEYqoJGuADvwttQxryeWSiW0kThx5OZnHnPe85MZsa0sbHRRehEvRPr6+v1Ukmtq6pK87Ur65qm6cQ7mlc3Nzdvmcrl8uf9/X3UajW2s7ODViiGg4MGjo6+4vDwC3S9bsTadcQp96hUKssmcj6uVqug8SfBWlnXNLb3psY+HbxljQ97bKdWYdQNa9fxXF6IOlQNQ15ldXWVEWjnlVrAlpbHplZASS2ik4bn7u7ugoqppu3t7ZNsNotIJMKi0ShamZiYQDw+ienpBKampikWQ7uGMz4+zkqlEuj4VH6GJ6lUCmNjY4wb0KIBn4dCIczMJKGqJeRyecRjMV74QtPU8dyVlRXQ0Z0ZptNpnszi8ThilNRkcjKOF/NJLC/OIkXj/LOEEWvVcLhhLpf7a7i4uIhgMMh8Ph+GhoYMFEWB2+2Gh0av5wyPx2PEvV7vhc7v9181zGQyIDNmtVohCCIsFgucTidcLheZKhgYGDDo7+83sNlspBMM+Hx4eJjl8/mrhqIoQiaBKApchGQygYWFOSQSCSSfPMbc86d4uZSB4naBF5ckCbIsIxAIdDIcMjq875ARCysYDw7C7+1DZNSJaMiFYKDfiI36nZiaUDD7yIde0kqSrbMhnQfjW+Bd8m3zkXfAuWfuQY9VMOLW8zXZJhkj3/I/DZsI3JSYGbRhzGGBwAs0186Nr20omrvwY3cJH9NT6O7uMjpu1VzPkLYpKlF8b7yHXn2Nu3YfbCLXSP9neHZtzq6DKFhhFh14kNSwXG5gfq2BOw+X0KppXpt2w2N+semCMofDgXZkyQKLuRvWnm70ysKlNbvdjr6+PoyMjBgX23jL5PqNd0gv5Vc4HP5NT/Ay4cjvcISgMRSKXFnnOTz34qXQ13Wo6zoKhQIrFou4CfR9nZ5/0lkT/WFm+hjr1O6NoF9aJ/bJo7a1tXX7Dyntkgi4sEC8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"resource layer\" title=\"\" src=\"/static/b57aa2a5b2149437f1bfe0021e65f2f7/6af66/resource_layer.png\" srcset=\"/static/b57aa2a5b2149437f1bfe0021e65f2f7/69538/resource_layer.png 160w,\n/static/b57aa2a5b2149437f1bfe0021e65f2f7/72799/resource_layer.png 320w,\n/static/b57aa2a5b2149437f1bfe0021e65f2f7/6af66/resource_layer.png 640w,\n/static/b57aa2a5b2149437f1bfe0021e65f2f7/5bb8b/resource_layer.png 749w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>유저 &gt; 특정 유저 &gt; 특정 유저의 프로필 사진으로 이어지는 계층 구조<small>\n</small></small></center>\n<p>이러한 리소스 간의 계층 구조는 어플리케이션에서 사용하는 리소소들의 관계를 어떻게 설정할 것이냐에 대한 문제이기 때문에 API를 설계할 때 굉장히 중요하고 예민한 요소인데다가, 대부분의 설계 패턴이 그러하듯이 이건 정답이 정해져있는 것도 아니기 때문에 고민을 깊게 할 수 밖에 없는 문제다.</p>\n<p>정답이 정해져있지 않다는 것은 프로필 사진이라는 리소스를 <code class=\"language-text\">/users/2/profile-image</code>라는 계층 구조가 아니라 <code class=\"language-text\">/profile-images/users/2</code>와 같은 계층으로 설계해도 논리 상으로는 아무런 문제가 없다는 것을 의미한다. 여기에는 단지 프로필 사진이라는 리소스가 어떤 의미를 가질 것이냐의 차이만 있을 뿐이다.</p>\n<hr>\n<center>\n<code class=\"language-text\">/users/2/profile-image</code><br />\n<small>유저들 중 2번 유저의 프로필 사진</small>\n</center>\n<br />\n<center>\n<code class=\"language-text\">/profile-images/users/2</code><br />\n<small>프로필 사진들 중 유저들의 프로필 사진 중 2번 유저의 프로필 사진</small>\n</center>\n<hr>\n<p>이처럼 같은 프로필 사진이지만 리소스의 계층을 어떻게 설계하냐에 따라 의미가 완전히 달라지게 된다. 이 케이스의 경우 유저 외에 프로필 사진을 가질 수 있는 다른 리소스가 존재하지 않는다면 <code class=\"language-text\">/users/2/profile-image</code>가 적당하지만 유저 외에도 다양한 리소스가 프로필 사진을 가져야 하는 상황이라면 <code class=\"language-text\">profile-images/users/2</code>라는 계층 구조도 고민해볼 수 있을 것이다.</p>\n<p>결국 우리가 고민해야 할 문제는 특정 유저의 프로필 사진이라는 리소스를 포함하는 상위 계층 리소스가 “유저가 더 명확하냐”, “프로필 사진이 더 명확하냐”인 것이다.</p>\n<p>물론 앞서 이야기했듯이 정답은 없으니, 항상 빠르게 변화하는 비즈니스 상황에 유연하게 대처할 수 있도록 팀원들과 협의해보고 URI를 설계하도록 하자.</p>\n<h4 id=\"uri에는-행위가-표현되면-안된다\" style=\"position:relative;\">URI에는 행위가 표현되면 안된다<a href=\"#uri%EC%97%90%EB%8A%94-%ED%96%89%EC%9C%84%EA%B0%80-%ED%91%9C%ED%98%84%EB%90%98%EB%A9%B4-%EC%95%88%EB%90%9C%EB%8B%A4\" aria-label=\"uri에는 행위가 표현되면 안된다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>RESTful API의 URI를 설계할 때 또 한 가지 중요한 것은 URI에 어떠한 행위를 의미하는 표현이 포함되어서는 안된다는 것이다. 예를 들어 유저를 삭제하는 엔드포인트가 하나 있다고 생각해보자. 이때 HTTP 메소드에 익숙하지 않다면, 대략 이런 느낌의 엔드포인트를 설계할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">POST /users/2/delete</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 엔드포인트의 URI에는 삭제 행위를 의미하는 <code class=\"language-text\">delete</code>라는 표현이 포함되어 있다. 뭐 사실 이대로도 이 API가 어떤 역할을 수행하는 API인지 인지하기에는 큰 무리가 없지만, RESTful API는 URI를 사용하여 행위를 표현하지 않을 것을 권고한다. URI가 가지는 의미는 철저히 어떤 리소스인지, 그리고 리소스의 계층 구조에 대한 것 뿐이어야한다.</p>\n<p>API가 수행하는 행위는 되도록이면 올바른 HTTP 메소드를 사용하여 표현해주는 것이 좋다. 그리고 단순히 이건 RESTful API가 이런 설계를 권고하기 때문인 것도 있지만, RESTful API의 가이드라인을 지키지 않도록 개발된 여러분의 어플리케이션이 이미 RESTful API의 가이드라인을 지키며 개발된 다른 어플리케이션들과 통신할 때 어떤 부작용이 발생할지 모르기 때문이기도 하다. <small>(당장 웹 브라우저만 해도 HTTP 메소드와 상태 코드에 상당히 종속되어 설계되어 있다)</small></p>\n<p>그리하여 올바르게 작성된 엔드포인트는 삭제를 의미하는 HTTP 메소드인 <code class=\"language-text\">DELETE</code>를 사용한 요런 엔드포인트가 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">DELETE /users/2</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>자, 지금까지 URI를 사용하여 리소스를 표현하는 방법에 대해 살펴보았으니, 이제는 API의 행위를 표현하는 방법에 대해서 알아볼 차례이다.</p>\n<h3 id=\"http-메소드를-사용하여-어떤-행위인지-표현하자\" style=\"position:relative;\">HTTP 메소드를 사용하여 어떤 행위인지 표현하자<a href=\"#http-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%96%B4%EB%96%A4-%ED%96%89%EC%9C%84%EC%9D%B8%EC%A7%80-%ED%91%9C%ED%98%84%ED%95%98%EC%9E%90\" aria-label=\"http 메소드를 사용하여 어떤 행위인지 표현하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>RESTful API는 HTTP 메소드를 사용하여 API가 수행하는 행위를 표현하도록 권고하고있다. HTTP 메소드는 나름 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\" target=\"_blank\" rel=\"nofollow\">RFC-2616</a>에서 정의된 표준이기 때문에 상황에 맞지 않는 메소드를 사용하게 되면 어플리케이션이 예상하지 못한 동작을 일으킬 수 있다는 사실을 기억하도록 하자.</p>\n<p>사실 API를 사용하여 하게되는 행위는 대부분 “CRUD(Create, Read, Update, Delete)” 이기 때문에, 몇 가지 특수한 경우를 제외하면 단 5가지의 HTTP 메소드만으로도 대부분의 API를 정의할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>리소스를 조회한다</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>리소스를 대체한다</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>리소스를 삭제한다</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>리소스를 생성한다</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>리소스의 일부를 수정한다</td>\n</tr>\n</tbody>\n</table>\n<p>이 외에도 <code class=\"language-text\">HEAD</code>, <code class=\"language-text\">OPTION</code>, <code class=\"language-text\">TRACE</code> 등의 메소드도 존재하기는 하지만, 사실 이 5가지의 메소드가 가지는 역할만 확실히 알고 있어도 HTTP 메소드를 사용하여 올바른 행위를 표현하거나 RESTful API를 설계하기에는 전혀 무리가 없다.</p>\n<p>여기서 한 가지 헷갈릴만한 것은 바로 <code class=\"language-text\">PUT</code>과 <code class=\"language-text\">PATCH</code> 메소드인데, 이 메소드들은 동일하게 “리소스를 수정한다”라는 의미로 해석되는 경우가 많기 때문에 정확히 어떤 경우에 <code class=\"language-text\">PUT</code>을 사용하고 어떤 경우에 <code class=\"language-text\">PATCH</code>를 사용해야 하는지 구분하기 어려운 경우가 많다.</p>\n<h4 id=\"put과-patch의-차이는-무엇인가요\" style=\"position:relative;\">PUT과 PATCH의 차이는 무엇인가요?<a href=\"#put%EA%B3%BC-patch%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\" aria-label=\"put과 patch의 차이는 무엇인가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>흔히들 <code class=\"language-text\">PUT</code> 메소드를 리소스를 수정한다는 개념으로 설명하고는 하지만, 실제 <code class=\"language-text\">PUT</code> 메소드가 의미하는 것은 리소스를 수정하는 것이 아니라 리소스를 요청 바디에 담긴 것으로 대체하는 것이다.</p>\n<p>한번 <code class=\"language-text\">{ id: 1, name: 'evan' }</code>이라는 유저 리소스의 이름을 <code class=\"language-text\">ethan</code>으로 수정해야하는 상황을 생각해보자. 만약 우리가 <code class=\"language-text\">PUT</code> 메소드를 사용하여 이 리소스를 수정한다면 우리는 반드시 요청 바디에 유저 리소스 전체를 표현하여 보내야한다.</p>\n<p>즉, 수정할 사항만 보내는 것이 아니라 수정하지 않을 사항까지도 모두 보내야한다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">PUT /users/1\n{ id: 1, name: 'ethan' }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/01507d03747ddad000635c4cc253c959/1d499/put_method.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACUUlEQVR42o2S30taYRjHXdvFYFCbwQKLXexy4KWMlI7TNdOjHdO06dLjOeYmDcGlSO0qkBpa7kJYN8u04Vmixxt/JPgfiJfe9ResgUQFeqGn99l7YsZYEb3w8PyA98P3+SGR3PLsdvt9hUIxKpfLn4yNjT2VSqXDYu22PxK1Wv1QJpONTky8kI6MjDw2Go3j2Ww2yR3kOO5nbp/juGyxWOTK5XKuXKlky9XqfrVa5Q4PD5O1Wm1YZADAvSugRqNJ6XS6LrZfWq32N0VRbafTiWjXW2BoJ9hsNgiHw5BK7UFq9ztkf2RQJpMBnuc7rVbr+V/g0BVQr9eX3G432BfmBbOFAoZhYHr6tWAmCcE6qxHUakKgaVqIx+PC1+0vwt7ut34ymUTpdPq82WxeAtfX14f+bVmvUqk+K5XK0OTLySBWGg0Ggz3aw4LH40Usw0IoFIJEIgGx2DZsbsZQLBYDDOzcCBy8QRHLH19bW+sa9HqwWOeQwWgAq9UKJEkCZXoDFmoG4Q7g08pK5/j4+DpQTMTNYf9AzE9OTp6trq52Z02zeAx2ZKJMWKkH5vEsnQs4XjQjkjRAJBK5Gfi/wna7PY7b63q9XvD5fMj/wQ8sy4ox+N77YWnJj8R4a2urc3R0dLeWA4HAOUEQF3jjPUJL9LHvU+a5Pjnzqm82aXpTU1MXy8sfz05PT+8G3NjY6DocDlEZcrkWQVQrqqTd74BlFpHD4YRoNNq5FTg4znq9/qhUKu0UCgUe2wHPF3P5fP7SxLhQKOJaga9UKjuNRuPaYf8B+eZOndX+TzwAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"put method\" title=\"\" src=\"/static/01507d03747ddad000635c4cc253c959/6af66/put_method.png\" srcset=\"/static/01507d03747ddad000635c4cc253c959/69538/put_method.png 160w,\n/static/01507d03747ddad000635c4cc253c959/72799/put_method.png 320w,\n/static/01507d03747ddad000635c4cc253c959/6af66/put_method.png 640w,\n/static/01507d03747ddad000635c4cc253c959/d9199/put_method.png 960w,\n/static/01507d03747ddad000635c4cc253c959/21b4d/put_method.png 1280w,\n/static/01507d03747ddad000635c4cc253c959/1d499/put_method.png 1632w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>PUT 메소드는 리소스를 수정하는 것이 아니라 대체하는 것이다</small>\n</center>\n<p>이렇게 리소스를 대체한다는 <code class=\"language-text\">PUT</code> 메소드의 특성 상, 실수로 <code class=\"language-text\">{ id: null, name: 'ethan' }</code>과 같은 리소스를 전송해버리기라도 하면 이 유저는 영영 ID를 잃어버린 비운의 유저가 되어버리는 경우도 발생할 수 있다. <small>(사실 이 정도 예외처리는 다들 기본적으로 해놓긴 한다.)</small></p>\n<p>하지만 그냥 리소스를 받아서 대체하면 된다는 동작 자체가 워낙 심플하기 때문에 리소스를 수정하는 쪽이든 받아서 처리하는 쪽이든 이것저것 신경써줘야 할 일이 별로 없어서 편하기는 하다.</p>\n<p>반면 우리가 <code class=\"language-text\">PATCH</code> 메소드를 사용하여 방금과 동일한 행위를 하려고 하면 어떨까?</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">PATCH /users/1\n{ name: 'ethan' }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f42966e7e24473577e61e2dda4f7aa09/c1b63/patch_method.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAADFUlEQVR42n1Uz0sbQRSO2GJpD9ba0kObQsEIWvBkrEKycbPJRhOTTSKJWoxRYxrEisYoVjw1MaUFEX8galRE9ORJ/IGgiCfFgwqlXkpz6K1/Qqnbzdc3i4otTQc+vrfvvflm3puZ1WiyjKKiorySkpIXZWVlxaWlpQ/I1hUXFz/X6XRPfD5fbrZ5GgA5a2trasLe3t6zk5OTytPT03Lil9vb2+adnZ3qg4MDw9bWFs+wu7trOjs701/mVFLs6aVUjuamQcK5m5ubpwuLi5ienpZnZmZ+ES7m5uYuUqmUPD8/f8HA7LlUSqGYvLS0hI2NjUO2qWuthoYGbVNTkzsajdYnEvHvklQHe21NRhAEWCwWmEwmVFVVoqKigqBXWa/Xg+OMit1ux+zs7DkJ3r6qVhMMBkP9/f0YHHz7ozPSnhmMBvGmMwiXyw2b3QqD0QCtVovCwoe4n5+Px48KUHD/HhNW6urqMDEx8flKUN0hOe+Wl5drBwYGdGNjY9/8Ph/ckjvj8Xjg9XrgdrvhdDppAdclE4glSVIaGxuxsLBw/ofgVf3EeXQ46aGhIfT09CrUAsT6Yujr64Nqx2KIUSXRKPPF0NvbqwwPD4PmZBW8Mz4+nmZ9s1qtis1mA1dthCCYwXolCBaYeQ6OWh41ogk8b1Jzpqamsu+QSk6zyVSu4vf7YRarIbklvA6Hqfx61Np4RII1CDRYIIqC4nS6WA+zCy4vL6fDNDkQCCgtLS1oa20D4+bmZpVbW1vRHAgi0BJk30okEsHKykp2QQqmu7q6EAqFlI6ODjCEw69VJh9xGCFCBy3a3t6udHd3Y3V19f8lsx6Koqh4vV6INVaYLTy8Hi/ouUG0CqiXzHA5eLXPlIfJycnsgnQoXziOo4bzPx0Oh8ybeZnjOZmui0zXRDYaDbLDZpBtVoPMmap/Uh47lE//FMxkMnnr6+tfR0dHMTIyoiQSCSRHkkgmk2B2PB5H8j2zkxR/r+ZQRezpsYt96+/3rI79/f1XR0dHHw4PD98Rx69wfHys4qaP5RA+0s/Cf/3sNBrNbw2AJbS7KLM6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"patch method\" title=\"\" src=\"/static/f42966e7e24473577e61e2dda4f7aa09/6af66/patch_method.png\" srcset=\"/static/f42966e7e24473577e61e2dda4f7aa09/69538/patch_method.png 160w,\n/static/f42966e7e24473577e61e2dda4f7aa09/72799/patch_method.png 320w,\n/static/f42966e7e24473577e61e2dda4f7aa09/6af66/patch_method.png 640w,\n/static/f42966e7e24473577e61e2dda4f7aa09/d9199/patch_method.png 960w,\n/static/f42966e7e24473577e61e2dda4f7aa09/c1b63/patch_method.png 1200w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>PATCH 메소드는 리소스의 일부분을 수정하는 것이다</small>\n</center>\n<p><code class=\"language-text\">PUT</code> 메소드와 다르게 <code class=\"language-text\">PATCH</code> 메소드는 진짜로 현재 저장되어 있는 리소스에 수정을 가하는 행위를 의미하기 때문에 굳이 수정하지 않은 사항을 요청 바디에 담아줄 필요도 없다.</p>\n<p><code class=\"language-text\">PATCH</code>메소드는 <code class=\"language-text\">PUT</code>처럼 수정하지 않을 사항까지 보낼 필요가 없고 진짜 수정하고 싶은 사항만 깔끔하게 보내면 되기 때문에, 쓸데없이 큰 요청 바디를 만들지 않을 수 있다.</p>\n<p>또한 실제로 이러한 수정 동작을 수행하는 API를 사용할 때는 SQL의 <code class=\"language-text\">UPDATE</code>와 동일한 의미를 떠올리는 경우가 많기 때문에, 리소스를 대체하는 <code class=\"language-text\">PUT</code> 메소드보다 리소스의 일부를 수정하는 <code class=\"language-text\">PATCH</code> 메소드가 수정이라는 의미를 가지기에도 더 적합하다고 할 수 있다.</p>\n<p>아직까지는 리소스를 수정하는 행위를 표현할 때 <code class=\"language-text\">PUT</code> 메소드를 주로 사용하는 경우가 많기는 하지만, <code class=\"language-text\">PUT</code> 메소드와 <code class=\"language-text\">PATCH</code> 메소드의 의미적인 차이는 분명히 존재하므로 API의 엔드포인트를 설계할 때 “리소스를 대체”, “리소스를 수정” 중 원하는 행위와 일치하는 메소드를 사용하는 것을 권장한다.</p>\n<p>그러나 <code class=\"language-text\">PUT</code> 메소드와 <code class=\"language-text\">PATCH</code> 메소드의 진짜 중요한 차이점은 이런 행위의 의미가 아니라, <code class=\"language-text\">PUT</code> 메소드는 반드시 멱등성을 보장하지만 <code class=\"language-text\">PATCH</code> 메소드는 멱등성을 보장하지 않을 수도 있다는 것이다.</p>\n<h4 id=\"메소드가-멱등성을-보장하는가\" style=\"position:relative;\">메소드가 멱등성을 보장하는가?<a href=\"#%EB%A9%94%EC%86%8C%EB%93%9C%EA%B0%80-%EB%A9%B1%EB%93%B1%EC%84%B1%EC%9D%84-%EB%B3%B4%EC%9E%A5%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"메소드가 멱등성을 보장하는가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>멱등성이란, 수학이나 전산학에서 어떤 대상에 같은 연산을 여러 번 적용해도 결과가 달라지지 않는 성질을 이야기한다. 즉, 단순히 HTTP 메소드에만 국한된 이야기는 아니고 이는 데이터베이스나 파일에 자원을 읽고 쓰는 등 컴퓨터가 수행하는 모든 연산에 해당되는 이야기이다.</p>\n<p>가장 대표적으로 멱등성이 보장되는 연산은 바로 어떠한 수에 1을 곱하는 연산이다. <code class=\"language-text\">x => x * 1</code>과 같은 함수는 어떠한 값에 1번을 적용하든, 10,000번을 적용하든 항상 <code class=\"language-text\">x</code>를 반환한다.</p>\n<p>그러나 1을 곱하는 것이 아니라 1을 더하거나 빼는 함수라면 한번 호출될 때마다 인자로 주어진 값을 계속 증가시키거나 감소시킬 것이므로 항상 같은 값을 반환하지 않는다. 이러한 성질의 연산이 바로 멱등성을 보장하지 않는 연산의 대표적인 예이다.</p>\n<p>HTTP 메소드 또한 결국 어떠한 자원을 읽고 쓰고 수정하고 지우는 CRUD에 대한 의미를 가지기 때문에, 우리는 어떤 행위가 멱등성을 보장하고 어떤 행위가 멱등성을 보장하는지 알고 있어야 어플리케이션이 예상하지 못한 방향으로 동작하는 것을 방지할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>멱등성 보장</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>O</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>O</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>O</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>X</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<p>일단 깊게 생각하지말고 위 테이블을 한번 보자. <code class=\"language-text\">GET</code> 메소드는 단지 리소스를 읽어 오는 행위를 의미하기에 아무리 여러 번 수행해도 결과가 변경되거나 하지는 않을 것이다. 마찬가지로 요청에 담긴 리소스로 기존 리소스를 그대로 대체해버리는 <code class=\"language-text\">PUT</code> 메소드 또한 여러 번 수행한다한들 요청에 담긴 리소스가 변하지 않는 이상 연산 결과가 동일할 것이다.</p>\n<p>즉, 어떤 리소스를 읽어오거나 대체하는 연산은 멱등성을 보장한다고 이야기할 수 있다. 그렇다면 멱등성이 보장되지 않는 케이스는 어떤 것이 있을까?</p>\n<p><code class=\"language-text\">POST</code> 메소드의 경우 리소스를 새롭게 생성하는 행위를 의미하기 때문에 여러 번 수행하게 되면 매번 새로운 리소스가 생성될 것이고, 그 말인 즉슨 결국 연산을 수행하는 결과가 매번 달라진다는 것을 의미한다. <code class=\"language-text\">POST</code> 메소드와 같이 멱등성을 보장하지 않는 동작은 한 번 수행될 때마다 어플리케이션의 상황을 전혀 다르게 변화시킬 수도 있다.</p>\n<p>이러한 HTTP 메소드의 멱등성에 대한 지식은 에러에 대한 정보가 별로 없는 상태에서 디버깅을 진행할 때도 활용될 수 있기 때문에 여러모로 알고 있는 편이 좋다고 생각한다. 똑같이 통신 후에 발생하는 에러라고 해도 <code class=\"language-text\">GET</code>을 여러 번 수행했을 때 발생하는 에러와 <code class=\"language-text\">POST</code>를 여러 번 수행했을 때 발생하는 에러는 전혀 다른 컨텍스트를 가지고 있을 수 있다는 것이다.</p>\n<h4 id=\"patch는-왜-멱등성이-보장되지-않는다는걸까\" style=\"position:relative;\">PATCH는 왜 멱등성이 보장되지 않는다는걸까?<a href=\"#patch%EB%8A%94-%EC%99%9C-%EB%A9%B1%EB%93%B1%EC%84%B1%EC%9D%B4-%EB%B3%B4%EC%9E%A5%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4%EB%8A%94%EA%B1%B8%EA%B9%8C\" aria-label=\"patch는 왜 멱등성이 보장되지 않는다는걸까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>위 테이블에서 <code class=\"language-text\">PATCH</code> 메소드는 <code class=\"language-text\">POST</code> 메소드와 동일하게 멱등성이 보장되지 않는 메소드로 표기되어있다. 그러나 사실 정확하게 이야기하면 <code class=\"language-text\">PATCH</code> 메소드는 구현 방법에 따라서 <code class=\"language-text\">PUT</code> 메소드처럼 멱등성이 보장될 수도 있고, 혹은 보장되지 않을 수도 있다고 할 수 있다.</p>\n<p><code class=\"language-text\">PATCH</code> 메소드는 <code class=\"language-text\">PUT</code> 메소드처럼 리소스를 대체하는 행위가 아니기 때문에 요청을 어떤 방식으로 사용하는지에 대한 제한이 딱히 없기 때문이다. RFC 스펙 상의 <code class=\"language-text\">PATCH</code> 메소드는 단지 리소스의 일부를 수정한다는 의미만을 가질 뿐이다.</p>\n<p>예를 들어, 앞서 필자가 설명했던 예시처럼 <code class=\"language-text\">PATCH</code> 메소드에 수정할 리소스의 일부분만 담아서 보내는 경우에는 당연히 멱등성이 보장된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 기존 리소스</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'evan'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">PATCH users/1\n{ age: 31 }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 새로운 리소스</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'evan'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">31</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 변경!</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 <code class=\"language-text\">PATCH</code> 요청은 명확하게 <code class=\"language-text\">age</code>라는 필드를 <code class=\"language-text\">31</code>로 수정하는 행위만을 의미하므로 아무리 여러 번 수행한다고 해도 늘 <code class=\"language-text\">age</code>는 <code class=\"language-text\">31</code>이라는 값을 가질 것이기 때문이다. 이건 굉장히 일반적인 <code class=\"language-text\">PATCH</code> 메소드의 구현 방법이고, 실제로 필자도 <code class=\"language-text\">PATCH</code> 메소드를 사용해야한다면 이렇게 구현한다.</p>\n<p>근데 왜 <code class=\"language-text\">PATCH</code> 메소드는 멱등성 보장이 안될 수도 있다는 것일까?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/aaf02eaa6cd79f5891d97861cc8e7338/6a068/hm.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAIBAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgP/2gAMAwEAAhADEAAAAXv5u6LgYmv/xAAaEAADAAMBAAAAAAAAAAAAAAABAgMAERIT/9oACAEBAAEFApTCnme/GZzeSbpWoFP/xAAWEQEBAQAAAAAAAAAAAAAAAAABABL/2gAIAQMBAT8BCyX/xAAYEQEAAwEAAAAAAAAAAAAAAAABAAISUf/aAAgBAgEBPwG6hN37P//EABwQAAICAgMAAAAAAAAAAAAAAAARAQIQIRJRcf/aAAgBAQAGPwJ3mPDdWx8IjC6Fs//EABkQAQEBAAMAAAAAAAAAAAAAAAEAETFBYf/aAAgBAQABPyG0DY4icl5Jc6dpqgr/2gAMAwEAAgADAAAAEOwv/8QAFxEBAAMAAAAAAAAAAAAAAAAAABExYf/aAAgBAwEBPxCa2D//xAAXEQADAQAAAAAAAAAAAAAAAAAAARFR/9oACAECAQE/ELhGLH//xAAbEAEBAAMAAwAAAAAAAAAAAAABEQAhMUFxwf/aAAgBAQABPxDSDeDbjuyMtSm+cMLVquhPPvApXeOWgSj3ACiW9+5//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"hm\" title=\"\" src=\"/static/aaf02eaa6cd79f5891d97861cc8e7338/c08c5/hm.jpg\" srcset=\"/static/aaf02eaa6cd79f5891d97861cc8e7338/0913d/hm.jpg 160w,\n/static/aaf02eaa6cd79f5891d97861cc8e7338/cb69c/hm.jpg 320w,\n/static/aaf02eaa6cd79f5891d97861cc8e7338/c08c5/hm.jpg 640w,\n/static/aaf02eaa6cd79f5891d97861cc8e7338/6a068/hm.jpg 960w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>어쩌면 이게 `PATCH`를 구현하는 올바른 방법이 아닐 수도 있을 것이라는 킹리적 갓심이 들기 시작했다</small>\n</center>\n<p>뭐든지 원조가 중요하니 <code class=\"language-text\">PATCH</code> 메소드를 처음으로 정의해놓은 <a href=\"https://tools.ietf.org/html/rfc5789\" target=\"_blank\" rel=\"nofollow\">RFC-5789</a> 문서를 한번 까보도록 하자. 보통 RFC 문서에는 정의된 개념에 대한 설명과 간략한 예시도 포함되어 있는 경우가 많으니, <code class=\"language-text\">PATCH</code> 메소드의 올바른 구현 방법 또한 적혀있을 것 같다.</p>\n<center>\n.<br />\n.<br />\n.<br />\n</center>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ddc05d3c7f7b2e1d49eedd8538eb835e/d43b4/patch_example.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABaElEQVR42m2S547CQAyEef/3yV8ECIQiqiih915EB1EEc/osLdzlsGQ2rJ2ZsSeR8Xisdrut6/UqnqvVqhKJhGWj0VAQBPI8T/F4XOVy2c5oNCrf97Xb7US8Xi+5iNxuNwPj8n6/63K5WON6vRY19/9wOFjf8XjUYrHQfr/X4/FQOCL8PJ9P1et11Wo1zWYzbbdbe2m5XGqz2Wi1Wmk+n5va0Whk9dPpZCLCaYAwpVIpZbNZU8bYpVJJ3W5XmUzGstlsGmmhUDDFvPN71D8KKdJYqVTU6/XU6XRsXxAAClA6ndZgMDAielCMWupMBiHTvEfmslgsKp/Pq9VqaTKZmFnOmFgs9iZlBW4dnAAPh0Odz+ePQphRxXgAwNzv95XL5YyM52QyaaaEnf03MkUWTbIfmJwZJE7jOLUw0FdTiOl0amNiCk47MMA5IeA7pYcRv4G/FRLsgN25ZUPgPhFIAHBrwDTuvwH+AC4t69xt49FhAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"patch example\" title=\"\" src=\"/static/ddc05d3c7f7b2e1d49eedd8538eb835e/6af66/patch_example.png\" srcset=\"/static/ddc05d3c7f7b2e1d49eedd8538eb835e/69538/patch_example.png 160w,\n/static/ddc05d3c7f7b2e1d49eedd8538eb835e/72799/patch_example.png 320w,\n/static/ddc05d3c7f7b2e1d49eedd8538eb835e/6af66/patch_example.png 640w,\n/static/ddc05d3c7f7b2e1d49eedd8538eb835e/d9199/patch_example.png 960w,\n/static/ddc05d3c7f7b2e1d49eedd8538eb835e/d43b4/patch_example.png 1202w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>...는 그딴 건 없었습니다</small>\n</center>\n<p>놀랍게도<small><strike>어이없게도</strike></small> <a href=\"https://tools.ietf.org/html/rfc5789\" target=\"_blank\" rel=\"nofollow\">RFC-5789</a> 문서에 있는 예시 요청의 바디에는 단지 <code class=\"language-text\">description of changes</code>라는 설명만 적혀있을 뿐, 어떤 제약 조건도 적혀있지 않다. 즉, 별다른 제약없이 개발자 마음대로 API의 인터페이스를 정의해도 된다는 의미이기 때문에 이런 느낌으로 API를 구현하는 것도 가능하다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">PATCH users/1\n{\n  $increase: 'age',\n  value: 1,\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 요청의 <code class=\"language-text\">$increase</code> 필드의 값은 증가시키고 싶은 속성을 의미하고, <code class=\"language-text\">value</code> 필드의 값은 그 속성을 얼마나 증가시킬 것인지를 나타내고 있다. 이 경우 API가 호출될 때마다 에반의 나이는 1씩 증가<smal><strike>(…😢)</strike></small>할 것이기 때문에 이 API는 멱등성을 보장하지 않는다.</p>\n<p>물론 필자도 <code class=\"language-text\">PATCH</code> 메소드를 이렇게 사용하는 경우를 실제로 보지는 못했지만, 앞서 이야기했듯이 <a href=\"https://tools.ietf.org/html/rfc5789\" target=\"_blank\" rel=\"nofollow\">RFC-5789</a>에는 <code class=\"language-text\">PATCH</code> 메소드를 어떻게 구현해야 하는지에 대한 제약이 존재하지 않으니 이런 방식으로 사용한다고 해서 표준을 어기는 것도 아니다.</p>\n<p>즉, 자세한 스펙 상 구현 방법에 대한 제약이 없으니 API를 어떻게 구현하느냐에 따라서 <code class=\"language-text\">PATCH</code> 메소드는 멱등성을 보장할 수도 있고 아닐 수도 있는 것이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 REST는 네트워크 아키텍처를 설계하는 가이드라인이기 때문에 필자가 이야기했던 리소스의 표현 상태는 REST의 일부분에 불과하다. 그러나 애초에 이 포스팅은 RESTful API를 설명하는 것이 목적이었기 때문에 더 자세한 내용을 굳이 이야기하지는 않았다. 혹시 REST에 대해 더 관심이 가시는 분들은 로이 필딩 아저씨의 논문 중 <a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm\" target=\"_blank\" rel=\"nofollow\">REST 챕터</a>을 한번 읽어보는 것을 추천한다.</p>\n<p>RESTful API는 필자가 지금까지 프론트엔드 개발자로 일을 하면서 백엔드 개발자와 가장 많은 논의를 했던 주제였다. 그렇게 논의를 했던 이유는 개발자로써 명확한 API를 정의하고 싶다는 욕심이기도 했고, 어떻게 하면 명확한 API를 정의해서 새로 조직에 합류한 개발자들이 바로 API에 익숙해지게 만들 수 있을지에 대한 욕심이기도 했다. <small>(오늘도 역시 사무실에서 이런 이야기를 나누다 왔다)</small></p>\n<p>필자는 개인적으로 가장 좋은 API는 기능이 많은 API도 아니고 공짜로 사용할 수 있는 API도 아닌, 어떠한 정보도 없는 누군가가 구구절절 다른 설명 없이 엔드포인트만 봐도 어떤 동작을 하는 API인지 바로 이해할 수 있을 정도로 명확한 API가 가장 좋은 API라고 생각한다.</p>\n<p>물론 RESTful API와 같은 아키텍쳐 가이드라인을 학습하고 준수하는 것이 다소 번거로울 수는 있지만, 이런 표준이나 가이드라인이 가지는 의미가 전 세계의 수 많은 개발자들이 소통할 수 있는 획일화된 교통 정리인 만큼 가이드라인을 준수하기 위한 개개인의 작은 노력이 모여서 거대한 웹 아키텍처를 유지할 수 있게 만드는 것은 아닐까.</p>\n<p>이상으로 프론트엔드와 백엔드가 소통하는 엔드포인트, RESTful API 포스팅을 마친다.</p>","fields":{"slug":"20200407-about-restful-api","path":"/2020/04/07/about-restful-api/","lang":"ko"},"frontmatter":{"title":"프론트엔드와 백엔드가 소통하는 엔드포인트, RESTful API","subTitle":"표현과 행위 사이, REST의 철학을 이해하다","date":"Apr 07, 2020","categories":["프로그래밍","네트워크","아키텍처"],"tags":["REST","REST API","RESTful API","HTTP 메소드","HTTP Method","HTTP Status","HTTP 상태"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/eba52764a4c3657fcab1149679dc258c/d803c/thumbnail.png","srcSet":"/static/eba52764a4c3657fcab1149679dc258c/d803c/thumbnail.png 320w,\n/static/eba52764a4c3657fcab1149679dc258c/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eba52764a4c3657fcab1149679dc258c/fc5c5/thumbnail.webp 320w,\n/static/eba52764a4c3657fcab1149679dc258c/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/eba52764a4c3657fcab1149679dc258c/01fb2/thumbnail.png","srcSet":"/static/eba52764a4c3657fcab1149679dc258c/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/eba52764a4c3657fcab1149679dc258c/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"43a4e283-1828-56b2-9174-cc59fa365513","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EA%B5%B3%EC%9D%B4-%EC%9D%B4%EB%9F%AC%ED%95%9C-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\">굳이 이러한 가이드라인을 지켜야 하나요?</a></p>\n<ul>\n<li><a href=\"#%ED%91%9C%EC%A4%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A1%B4%EC%9E%AC-%EC%9D%B4%EC%9C%A0%EB%A5%BC-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EC%9E%90\">표준 인터페이스의 존재 이유를 생각해보자</a></li>\n<li><a href=\"#%EB%B0%B1%EC%97%94%EB%93%9C%EB%8A%94-%EC%9E%98-%EB%AA%A8%EB%A5%B4%EB%8A%94-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%9D%98-%EC%8A%AC%ED%94%88-%EC%82%AC%EC%A0%95\">백엔드는 잘 모르는 프론트엔드의 슬픈 사정</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%91%EC%97%85%EC%9D%98-%EC%88%98%ED%96%89-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C\">작업의 수행 상태를 알려주는 HTTP 상태 코드</a></p>\n<ul>\n<li><a href=\"#100%EB%B2%88%EB%8C%80\">100번대</a></li>\n<li><a href=\"#200%EB%B2%88%EB%8C%80\">200번대</a></li>\n<li><a href=\"#300%EB%B2%88%EB%8C%80\">300번대</a></li>\n<li><a href=\"#400%EB%B2%88%EB%8C%80\">400번대</a></li>\n<li><a href=\"#500%EB%B2%88%EB%8C%80\">500번대</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"최근의 모던 어플리케이션은 완전히 네트워크 위에서 돌아가는 프로그램이라고 해도 과언이 아닐 정도로 프로그램의 비즈니스 로직에서 통신이 차지하는 비중이 높다. 클라이언트 어플리케이션은 백엔드에 위치한 서버와 통신하여 현재 로그인한 사용자의 정보를 받아오거나, 새로운 게시글을 생성하기도 하고, 때로는 Web Socket을 통해 서버에서 발생한 이벤트를 구독하여 푸시 메세지나 채팅과 같은 기능을 구현하기도 한다.","html":"<p>최근의 모던 어플리케이션은 완전히 네트워크 위에서 돌아가는 프로그램이라고 해도 과언이 아닐 정도로 프로그램의 비즈니스 로직에서 통신이 차지하는 비중이 높다. 클라이언트 어플리케이션은 백엔드에 위치한 서버와 통신하여 현재 로그인한 사용자의 정보를 받아오거나, 새로운 게시글을 생성하기도 하고, 때로는 Web Socket을 통해 서버에서 발생한 이벤트를 구독하여 푸시 메세지나 채팅과 같은 기능을 구현하기도 한다.</p>\n<!-- more -->\n<p>이 과정에서 프론트엔드와 백엔드는 어떤 방식으로 통신을 할 것인지부터 시작하여 리소스의 생성과 삭제는 어떻게 정의할 것인지, 프론트엔드에서 요청한 백엔드 작업의 성공/실패 여부는 어떻게 알려줄 것인지 등 많은 규칙들을 정의해야한다.</p>\n<p>그래서 이러한 규칙들을 정의할 때 도움을 주는 몇 가지 가이드라인들이 존재하는데, 이때 등장하는 것들이 HTTP 메소드나 상태 코드같은 표준과 REST 같은 녀석들이다.</p>\n<p>이번 포스팅에서는 이 중에서  프론트엔드와 백엔드 간의 통신을 할 때 조금 더 명확한 정의를 위해 필요한 요소 중 하나인 HTTP 상태 코드를 파헤쳐보는 시간을 가져보려고 한다.</p>\n<h2 id=\"굳이-이러한-가이드라인을-지켜야-하나요\" style=\"position:relative;\">굳이 이러한 가이드라인을 지켜야 하나요?<a href=\"#%EA%B5%B3%EC%9D%B4-%EC%9D%B4%EB%9F%AC%ED%95%9C-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"굳이 이러한 가이드라인을 지켜야 하나요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 HTTP 메소드나 상태 코드, 그리고 REST 같은 것들은 말 그대로 가이드라인에 불과하다. 이것들을 지키지 않는다고 해서 프로그램이 작동하지 않는 것도 아니고 사용자가 프로그램을 사용하던 도중 런타임 에러가 발생하는 슬픈 일도 발생하지 않는다.</p>\n<p>즉, 지키지 않아도 사실 프로그램을 작성하는데는 아무런 지장이 없다는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgH/2gAMAwEAAhADEAAAAdFHeGZyL//EABwQAAEDBQAAAAAAAAAAAAAAAAACAxIBEyIjM//aAAgBAQABBQK4ZUVMbVsc5SP/xAAXEQADAQAAAAAAAAAAAAAAAAAAARIh/9oACAEDAQE/AXjJP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAQEBAQAAAAAAAAAAAAAAAAEAECL/2gAIAQEABj8ClXnCc//EABsQAAICAwEAAAAAAAAAAAAAAAABESExQVFh/9oACAEBAAE/IUje34sl0GmCI6npJS8JH//aAAwDAQACAAMAAAAQHO//xAAXEQEAAwAAAAAAAAAAAAAAAAAAETFR/9oACAEDAQE/EKGoP//EABYRAQEBAAAAAAAAAAAAAAAAAAEAEf/aAAgBAgEBPxABLb//xAAdEAEAAwACAwEAAAAAAAAAAAABABExcZEhUWGx/9oACAEBAAE/EKiWem1wSj+FUKG39MhTp3PLbaTkdjZ2W37AjTqf/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ebichu\" title=\"\" src=\"/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg\" srcset=\"/static/5ab263e405da8a4381a5fe32c5581820/0913d/ebichu.jpg 160w,\n/static/5ab263e405da8a4381a5fe32c5581820/cb69c/ebichu.jpg 320w,\n/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>그럼 굳이 안 지켜도 상관없는 것 아닌가요?</small>\n</center>\n<p>음, 이러한 규칙들을 지키지 않는 것은 자유지만 그로 인해 발생하는 사이드 이펙트들을 생각해보면 되도록이면 지켜주는 것이 좋다고 이야기하고 싶다.</p>\n<h3 id=\"표준-인터페이스의-존재-이유를-생각해보자\" style=\"position:relative;\">표준 인터페이스의 존재 이유를 생각해보자<a href=\"#%ED%91%9C%EC%A4%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A1%B4%EC%9E%AC-%EC%9D%B4%EC%9C%A0%EB%A5%BC-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"표준 인터페이스의 존재 이유를 생각해보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>산업 표준은 불특정 다수에 의해 생산되는 제품들의 호환성을 맞추고, 제품 생산자들 간의 커뮤니케이션을 원활하게 하기 위해서 제정되며, 이렇게 각자 다른 객체들을 호환하기 위해 정의하는 일련의 표준 규격을 우리는 “인터페이스(Interface)“라고 부른다.</p>\n<p>이 인터페이스라는 개념은 꽤나 광범위해서 뭐든 연결해주기만 할 수 있다면 인터페이스라고 생각하면 된다. 모니터와 컴퓨터를 연결하는 HDMI, 저장 장치에 사용되는 SATA, USB와 같은 친구들도 전부 인터페이스다. 심지어 UI(User Interface)같은 경우에는 기계와 기계가 아니라 인간과 기계를 이어준다는 개념으로까지 사용된다.</p>\n<p>그 중 개발자들에게 가장 친숙한 인터페이스는 바로 API(Application Programming Interface)이다. API는 응용 프로그램을 제작할 때 필요한 기능들을 일련의 인터페이스로 제공된 것을 의미한다.</p>\n<p>이때 API를 사용하는 쪽에서는 API의 사용법만 알면 되고 그 이면에 어떤 거대한 로직들이 숨어있는지는 일절 관심을 끊어도 되기 때문에 굉장히 편리하다는 장점이 있다. 대표적인 API의 한 종류로는 C에서 제공하는 Windows 운영체제의 API가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;Windows.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;tchar.h></span></span>\n\n<span class=\"token keyword\">int</span> APIENTRY <span class=\"token function\">_tWinMain</span><span class=\"token punctuation\">(</span>\n  HINSTANCE hInstance<span class=\"token punctuation\">,</span>\n  HINSTANCE hPrevInstance<span class=\"token punctuation\">,</span>\n  LPTSTR lpCmdLine<span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">int</span> nCmdShow\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">MessageBox</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token function\">TEXT</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, Windows!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">TEXT</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"App\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> MB_OK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>개발자는 Windows 운영체제가 어떻게 저 메세지박스를 렌더하는지 모르더라도 단지 <code class=\"language-text\">MessageBox</code>라는 API의 함수를 사용함으로써 간단하게 메세지박스를 사용할 수 있다. 그리고 이 과정은 필자가 작성하는 C 어플리케이션과 운영체제, 전혀 다른 두 프로그램 간의 통신이기도 하다.</p>\n<p>즉, API는 프로그램 간의 통신을 위한 인터페이스라고 할 수 있다. 마찬가지로 클라이언트가 서버에게 뭔가를 요청할 때도 특정 규칙으로 정의된 API를 사용하여 서버의 리소스를 사용하게 되는데, HTTP를 사용하여 통신하는 대부분의 모던 어플리케이션에서는 이 API를 엔드포인트(endpoint)라고 불리는 특정한 URL을 사용하여 정의하게되며, 서버는 일관된 방식으로 이 엔드포인트로 들어온 클라이언트 요청에 대한 응답을 보내줘야한다.</p>\n<p>이때 HTTP 상태 코드는 클라이언트가 보냈던 요청의 수행 결과를 의미하는 일종의 약속이며, API를 구성하는 중요한 요소 중 하나이다.</p>\n<h3 id=\"백엔드는-잘-모르는-프론트엔드의-슬픈-사정\" style=\"position:relative;\">백엔드는 잘 모르는 프론트엔드의 슬픈 사정<a href=\"#%EB%B0%B1%EC%97%94%EB%93%9C%EB%8A%94-%EC%9E%98-%EB%AA%A8%EB%A5%B4%EB%8A%94-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%9D%98-%EC%8A%AC%ED%94%88-%EC%82%AC%EC%A0%95\" aria-label=\"백엔드는 잘 모르는 프론트엔드의 슬픈 사정 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 섹션에서는 잘못 정의된 API를 사용하는 프론트엔드 개발자라면 한번쯤은 겪어보았음직한 일을 한번 짧게 이야기해보려고 한다. 아마 백엔드 개발자들은 프론트엔드 어플리케이션의 소스를 직접 보는 경우가 드물기 때문에 이런 상황이 있다는 사실조차 모를 수 있을 것 같다.</p>\n<p>바로 HTTP 상태 코드를 잘못 사용하고 있는 경우인데, 이런 상황에 대한 대표적인 예시는 바로 요청이 실패했을 때에도 상태 코드를 요청 성공을 의미하는 <code class=\"language-text\">200 Ok</code>로 내려주는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET /api/users/123</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK</span></span>\n{ \"success\": false }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이렇게 설계한 API의 경우, 위 예시처럼 HTTP 응답 바디에 요청의 성공/실패 여부나 실패 이유를 함께 담아서 보내주는 경우가 대다수인데, 그러면 프론트엔드 어플리케이션에서는 처리가 약간 애매해지는 상황이 발생한다.</p>\n<p>프론트엔드에서는 이런 비동기 요청을 Promise를 통해서 처리하게 되는데, 문제는 대부분의 HTTP 통신 라이브러리나 API들은 백엔드에서 보내주는 요청의 상태 코드에 따라 요청의 성공/실패 여부를 판단하고, 요청이 실패했을 경우에만 에러를 던진다는 것이다.</p>\n<p>그래서 일반적인 경우, 프론트엔드 어플리케이션에서는 대략 이런 느낌으로 통신을 담당하는 코드를 작성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUsers</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/users/123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'요청이 실패했어요!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>서버로 보냈던 요청이 실패했다면 서버는 반드시 400이나 500번대의 상태 코드를 보내줄 것이고, 그렇게 되면 <code class=\"language-text\">fetch</code> API는 에러를 발생시킨다. 그래서 <code class=\"language-text\">fetch</code>를 사용할 때는 단순히 외부에서 <code class=\"language-text\">try/catch</code> 구문을 사용하는 것만으로도 간단하게 통신에 대한 에러를 핸들링할 수 있는 것이다.</p>\n<p>하지만 위의 잘못된 예시처럼 백엔드 어플리케이션에서 요청이 실패했음에도 불구하고 상태 코드로 200번대 코드를 내려준다면 프론트엔드 어플리케이션의 코드에는 이런 슬픈 상황이 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUsers</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/users/123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> success <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'요청이 실패했어요'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>아까 전에는 없던 <code class=\"language-text\">if (!success)</code>가 생긴 것을 볼 수 있다. 즉, 불필요한 예외 처리가 한번 더 발생한 것인데, 이런 불필요한 예외처리는 코드의 가독성을 해치지만 프론트엔드 입장에서는 딱히 선택권이 없다. 그렇다고 서버가 보내주는 에러를 무시하고 핸들링을 안 할수도 없지 않은가?</p>\n<p>게다가 백엔드 어플리케이션이 미처 핸들링하지 못한 에러가 발생하거나 서버가 아예 죽어버리기라도 하면 응답의 상태 코드에는 에러 코드인 500이나 502가 내려올 것이기 때문에 <code class=\"language-text\">try/catch</code> 구문을 사용하지 않을 수도 없다.</p>\n<p>클라이언트에서 사용하는 모든 HTTP 통신 라이브러리들은 올바른 HTTP 상태 코드의 사용을 가정하고 설계되었기 때문에, 서버가 올바르지 않은 상태 코드를 사용한다면 이런 슬픈 상황이 발생할 수도 있다는 점을 이야기해두고 싶다. 그리고 사실 백엔드 어플리케이션에서 상황에 맞는 올바른 상태 코드를 내려주는 것이 그렇게 어려운 일도 아니다. <small>(다만 조금 귀찮을 뿐이다)</small></p>\n<p>클라이언트와 마찬가지로 대부분의 서버 프레임워크에서 제공하는 통신 라이브러리들도 모든 상황에 맞는 HTTP 상태 코드들을 제공하고 있으니 되도록이면 알맞은 상황에 맞는 상태 코드를 사용하는 것을 추천한다.</p>\n<p>자, 그럼 이제 본격적으로 이 수많은 HTTP 상태 코드들이 정확히 어떤 상태를 의미하는지 알아보도록하자.</p>\n<h2 id=\"작업의-수행-상태를-알려주는-http-상태-코드\" style=\"position:relative;\">작업의 수행 상태를 알려주는 HTTP 상태 코드<a href=\"#%EC%9E%91%EC%97%85%EC%9D%98-%EC%88%98%ED%96%89-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C\" aria-label=\"작업의 수행 상태를 알려주는 http 상태 코드 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>클라이언트가 서버에게 작업을 요청하면 서버는 요청받은 작업을 수행한 후 작업의 수행 결과를 응답으로 보내주는데, 이때 HTTP 상태 코드를 사용하여 작업의 성공/실패 여부와 작업이 실패했다면 어떤 이유로 실패했는지도 알려주게 된다. 위에서 보았던 잘못된 예시처럼 HTTP 응답 바디에 작업의 실패 여부를 담아서 응답해주는 경우도 있지만, 더 좋은 방법은 바로 올바른 HTTP 상태 코드를 사용하는 것이다.</p>\n<p>HTTP 상태 코드는 “200 = 성공”, “400 = 클라이언트가 요청 잘못함”, “500 = 서버가 잘못함”과 같이 각 상황에 맞는 코드가 표준으로 정해져있으며, 웹 상에서 돌아가는 기본적인 프로그램의 동작이나 프론트엔드, 백엔드 프레임워크들의 설계 또한 이 표준을 기준으로 만들어져 있기 때문에 되도록이면 이 표준을 지켜주는 것이 좋다.</p>\n<p>HTTP 프로토콜을 사용하는 대표적인 프로그램인 웹 브라우저 또한 이러한 상태 코드 표준을 엄격하게 지키는 녀석 중 하나인데, 실제로 브라우저는 서버가 어떤 상태 코드를 응답으로 내려주는지에 따라 이번에 자신이 보낸 요청의 성공/실패 여부를 구분하고, 이를 시각적으로 표현해주기도 한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/581d5098769863da7581ecc2a09a19ed/d7ab4/browser-response.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 44.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABO0lEQVR42o1S7XKDIBD0VRJj4kc1ioqCCJh+vP8bbe8uaaadJtP+2Dk4cbndJbHWIoSAGAOMsRj1hLZTUvthxEw9Y5d71dMsfaV6WQ+jRkdrrue2RTJNE9Z1FVhv6EeDqqqw3+8FacpI7zgcDnd87b/3k3me4ZzDYh0632JajNyWFwXqusHxeLwRp8iy7AfhIyQsOcaIQJK3sEH1vcgbtYZbA+0H1E0jYFIhv13wkNCQRPbQey9yeTr2zy4O02zg44bL2wfi9gpDPfaPz1Qv9UNS8ZAls4duuZpelpVIZZxOuSDPcxRkA9c8L5DRt6cT8nRu9XjvFSzJ7SWxTlJjibvdTvAsnF8ebtt29ZGmHMeRnoeDprDWEIWUAyrK8s9AhFApBU0BMNEwXAPoqNecW7Q0JYfCnnJY/0n5E8S6FKangsPMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"browser response\" title=\"\" src=\"/static/581d5098769863da7581ecc2a09a19ed/6af66/browser-response.png\" srcset=\"/static/581d5098769863da7581ecc2a09a19ed/69538/browser-response.png 160w,\n/static/581d5098769863da7581ecc2a09a19ed/72799/browser-response.png 320w,\n/static/581d5098769863da7581ecc2a09a19ed/6af66/browser-response.png 640w,\n/static/581d5098769863da7581ecc2a09a19ed/d9199/browser-response.png 960w,\n/static/581d5098769863da7581ecc2a09a19ed/d7ab4/browser-response.png 1014w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>브라우저는 200번대의 상태 코드와 400, 500번대의 상태 코드를 전혀 다르게 인식한다</small>\n</center>\n<p>이런 상황에서 서버가 상태 코드는 200인데 응답의 바디로만 에러를 표현한다고 하면, 브라우저는 요청이 성공했다고 생각하지만 실제로는 요청이 실패한, 요상한 상황이 발생하게 된다.</p>\n<p>심지어 서버가 응답의 상태 코드로 301과 같은 코드를 내려준다면, 브라우저는 자동으로 사용자를 다른 페이지로 리다이렉트(Redirect)해버리기 때문에 서버가 제대로 된 상태 코드를 응답에 담아주지 않는다면 브라우저가 예측하지 못한 동작을 일으킬 수도 있다.</p>\n<p>자, 그럼 이제 각 HTTP 상태 코드가 어떤 상태들을 의미하는 것인지 하나씩 살펴보도록 하자. HTTP 상태 코드는 100번대 부터 500번대까지로 이루어져 있으며 꽤나 다양한 상태들을 정의할 수 있지만, 이걸 다 알 필요도 없고 설명하려면 너무 길기도 하니, 필자가 단 한번이라도 사용해보았던 상태 코드들을 기준으로 설명을 진행하려고 한다.</p>\n<h3 id=\"100번대\" style=\"position:relative;\">100번대<a href=\"#100%EB%B2%88%EB%8C%80\" aria-label=\"100번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>100번대 코드는 프로토콜을 교체해도 된다거나 계속 요청을 보내도 된다거나하는 식의 정보성을 띄고 있는 상태를 의미하지만, 실제로 필자가 어플리케이션을 개발하며 이 상태 코드들을 만나본 사례는 아직 단 한번도 없기 때문에 건너뛰도록 하겠다.</p>\n<h3 id=\"200번대\" style=\"position:relative;\">200번대<a href=\"#200%EB%B2%88%EB%8C%80\" aria-label=\"200번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>200번대 코드들은 클라이언트가 요청한 작업을 서버가 성공적으로 수행했다는 상태라는 것을 알려주는 코드이다. 200번대 코드들은 브라우저의 콘솔의 네트워크 탭에서도 깔끔한 초록색으로 표시해준다.</p>\n<p>물론 “요청한 작업이 성공”이라는 응답만으로도 클라이언트가 원하는 정보를 모두 만족시킬 수 있긴 하지만, 조금 더 디테일한 상태를 정의해야하는 상황이라면 이 200번대의 상태 코드를 적극적으로 사용하여 클라이언트에게 더 자세한 정보를 알려줄 수도 있다.</p>\n<p><strong>200 OK</strong></p>\n<p>상태 코드 <code class=\"language-text\">200</code>은 단순히 작업이 성공했음을 의미한다. 대부분의 경우 클라이언트는 자신이 요청한 작업이 정확히 어떤 작업인지 알고 있기 때문에, 서버에서 “니가 보낸 요청이 성공했어”라는 정보만 알려주면 굳이 그 이상의 디테일한 정보는 알 필요가 없다. 그래서 이 상태 코드 하나만으로 모든 API 응답 성공 상태를 퉁치는 경우가 대다수이다.</p>\n<p><strong>201 Created</strong></p>\n<p>상태 코드 <code class=\"language-text\">201</code>은 말 그대로 요청이 정상적으로 수행되었고, 그로 인해 리소스가 새롭게 생성되었다는 것을 의미한다. 클라이언트가 서버에게 요청을 보내서 새로운 리소스를 생성하는 상황은 굉장히 흔한데, 그 중 필자가 경험했던 대표적인 사례는 바로 “회원가입”이다. 결국 클라이언트의 회원가입 요청으로 인해 데이터베이스에 새로운 유저의 로우가 생성되었기 때문에, 이런 경우가 <code class=\"language-text\">201</code> 상태 코드가 아주 잘 들어맞는 케이스라고 볼 수 있다.</p>\n<p><strong>204 No Content</strong></p>\n<p>상태 코드 <code class=\"language-text\">204</code>는 요청이 정상적으로 수행되었고, 이 요청과 관련되었던 컨텐츠 또한 더 이상 깔끔하게 존재하지 않음을 의미한다. 이 상태 코드는 클라이언트가 서버에게 요청을 보내서 뭔가를 삭제해야하는 응답으로 사용될 수 있고, 실제로 필자가 경험했던 사례 또한 게시글을 삭제하는 API였다.</p>\n<p>참고로 이때 이 삭제 작업이 Soft Delete냐 Hard Delete냐와는 아무런 상관이 없다. 서버에서 어떤 방식으로 리소스의 삭제를 표현하던 클라이언트가 알아야할 정보는 “이 리소스는 삭제되었고, 더 이상 사용할 수 없다” 뿐이라는 사실을 명심하자.</p>\n<h3 id=\"300번대\" style=\"position:relative;\">300번대<a href=\"#300%EB%B2%88%EB%8C%80\" aria-label=\"300번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>300번대 코드들은 리다이렉션에 관련된 상태들을 의미한다. 클라이언트가 요청한 리소스가 옮겨졌거나 리소스가 삭제되었거나해서 정상적인 방법으로는 더 이상 해당 리소스에 접근할 수 없고 다른 URL을 통해서 그 리소스에 접근해야하는 경우 서버는 “여기로 가면 니가 찾는 리소스가 있어!”라는 정보를 알려줄 수 있는데, 이때 사용되는 상태 코드들이 바로 300번대 코드들이다.</p>\n<p><strong>301 Moved Permanetly</strong></p>\n<p>상태 코드 <code class=\"language-text\">301</code>은 <code class=\"language-text\">301 Redirect</code>라는 별칭으로 불리기도 할 만큼 리다이렉션을 위한 코드 중 가장 많이 사용되는 녀석이다. 브라우저는 자신의 대한 요청의 응답으로 <code class=\"language-text\">301</code>을 받으면 HTTP 헤더에 들어있는 <code class=\"language-text\">Location</code> 필드를 찾아보고, 해당 필드가 존재할 경우 <code class=\"language-text\">Location</code> 필드에 담긴 URL로 자동으로 리다이렉션한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">301</span> <span class=\"token reason-phrase string\">Moved Permanetly</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Location</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">https://evan/moved-contents/1234</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또한 구글과 같은 검색 엔진의 봇들은 특정 페이지에 접근했는데 응답으로 <code class=\"language-text\">301</code> 상태 코드를 받을 경우 자동으로 페이지 정보를 갱신하기도 하기 때문에, SEO(Search Engine Optimization) 관점에서도 이 상태 코드를 올바르게 사용하는 것은 매우 중요하다.</p>\n<p>이런 리다이렉션 설정은 보통 서버 엔진의 설정 파일 내에서도 할 수 있고, 백엔드 어플리케이션 내에서 직접 할 수도 있다. 일반적인 경우 이 상태코드는 HTTP 프로토콜로 접속한 사용자를 HTTPS 프로토콜을 사용해야만 접근 가능한 포트로 보내버릴 때에도 많이 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-nginx line-numbers\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>         <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span>    evan.com</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">return</span>         <span class=\"token number\">301</span> https://<span class=\"token variable\">$host</span><span class=\"token variable\">$request_uri</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>         <span class=\"token number\">443</span> ssl</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span>    evan.com</span><span class=\"token punctuation\">;</span>\n    ...\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 경우 <code class=\"language-text\">80</code> 포트로 접속한 사용자를 발견한 Nginx는 HTTPS 프로토콜을 사용해야만 접근할 수 있는 <code class=\"language-text\">443</code> 포트로 리다이렉트시켜서 해당 프로토콜 사용을 강제할 수 있다.</p>\n<p><strong>304 Not Modified</strong></p>\n<p>상태 코드 <code class=\"language-text\">304</code>는 클라이언트가 요청한 리소스가 이전 요청때와 비교해보았을 때 전혀 달라진 점이 없다는 것을 의미한다. 즉, 말 그대로 Not Modified, 수정되지 않음이다.</p>\n<p>서버가 응답으로 이 상태 코드를 보내주면 클라이언트는 굳이 서버에게 리소스를 재전송받아야할 필요가 없기에 자신이 캐싱해놓았던 리소스를 사용하게되며, 이 과정에서 불필요한 통신 페이로드의 낭비를 줄일 수 있다.</p>\n<p>이 과정에서 클라이언트는 서버로부터 요청된 리소스를 받은 것이 아니라 자신의 캐싱해놓았던 리소스를 사용하는 것이므로 이 또한 캐싱된 리소스로 리다이렉션되었다고 치는 것이다. 그런 이유로 <code class=\"language-text\">304</code> 상태 코드는 암묵적인 리다이렉션으로 불리기도 한다.</p>\n<p>브라우저 역시 이 응답을 위한 자체 캐싱 기능을 가지고 있으며, 만약 <code class=\"language-text\">304</code> 상태 코드를 응답으로 받았는데 캐싱된 리소스가 없는 경우에는 빈 화면을 띄우거나 에러 화면이 노출된다. 그러니 이런 상황을 만나면 “브라우저에 Cached Resource가 없는 거 아님?”이라는 킹리적 갓심을 발휘해볼 수 있다.</p>\n<h3 id=\"400번대\" style=\"position:relative;\">400번대<a href=\"#400%EB%B2%88%EB%8C%80\" aria-label=\"400번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>400번대의 코드들은 클라이언트가 서버에게 보낸 요청이 잘못된 경우를 의미한다. 만약 이 상태 코드를 발견한다면 높은 확률로 프론트엔드 개발자가 예외 처리를 제대로 안 했거나 요청에 이상한 값이 묻은 경우가 많으니, 프론트엔드 개발자의 멱살을 잡도록 하자. <small><strike>(낮은 확률로 백엔드의 잘못인 경우도 있다…)</strike></small></p>\n<p><strong>400 Bad Request</strong></p>\n<p>상태 코드 <code class=\"language-text\">400</code>는 가장 많이 만날 수 있는 400번대 코드 중 하나이며, 밑도 끝도 없이 “클라이언트가 요청 잘못 날림”을 의미한다. 이때 뭘 어떻게 잘못 날렸는지는 보통 HTTP 응답 바디에 담아서 알려주는 경우도 있지만, 그렇지 않은 경우에는 백엔드 어플리케이션의 로그를 까봐야하는 슬픈 상황이 펼쳐질 수도 있다.</p>\n<p><strong>401 Unauthorized</strong></p>\n<p>상태 코드 <code class=\"language-text\">401</code>는 인증되지 않은 사용자가 인증이 필요한 리소스를 요청하는 경우에 “너 인증 필요함”이라고 알려주는 상태 코드이다. 보통 로그인이 필요한 API를 비로그인 사용자가 호출했을 때 많이 사용된다.</p>\n<p>클라이언트에서는 서버가 <code class=\"language-text\">401</code>을 응답으로 보내준 경우, 로그인이 필요하다는 것으로 판단하고 로그인 페이지로 사용자를 리다이렉션하기도 한다.</p>\n<p><strong>403 Forbidden</strong></p>\n<p>상태 코드 <code class=\"language-text\">403</code>는 클라이언트가 접근이 금지된 리소스를 요청했음을 의미한다. 이 상태 코드는 간혹 <code class=\"language-text\">401 Unauthorized</code>와 헷갈리고는 하는데, 상태 코드의 의미만 보면 확실히 애매모호하지만, 사실 분명한 한 가지 차이점이 있다.</p>\n<p><code class=\"language-text\">401</code>은 말 그대로 인증되지 않았다는 것을 의미하며, 인증이 되지 않았다는 것은 백엔드 어플리케이션이 현재 요청한 사용자가 누구인지 알 수가 없다는 것을 의미한다. 즉 이때 서버는 클라이언트에게 “너의 신원을 밝혀!”라고 말하고 있는 것이다.</p>\n<p>그러나 <code class=\"language-text\">403</code>의 경우, 백엔드 어플리케이션은 현재 리소스를 요청한 사용자가 누구인지 전혀 신경쓰지 않는다. 클라이언트가 현재 자신이 누구인지 밝혔던 밝히지 않았던, 인증이 되었던 안 되었던 간에, 이 리소스를 요청하는 것은 무조건 금지라고 말하고 있는 것이다.</p>\n<p>HTTPS 프로토콜로만 접근해야하는 리소스에 HTTP 프로토콜을 사용하여 접근했을 경우에 서버에서 <code class=\"language-text\">403</code> 응답을 보내주기도 한다.</p>\n<p><strong>404 Not Found</strong></p>\n<p>상태 코드 <code class=\"language-text\">404</code>는 말 그대로 요청한 리소스가 존재하지 않다는 것을 의미한다.</p>\n<p><strong>405 Method Not Allowed</strong></p>\n<p>상태 코드 <code class=\"language-text\">405</code>는 현재 리소스에 맞지않는 메소드를 사용했음을 의미한다. 백엔드 프레임워크의 경우 특정 컨트롤러에 해당 메소드를 사용하는 로직이 없다면 자동으로 <code class=\"language-text\">405</code>를 내려주기도 한다.</p>\n<p><strong>406 No Acceptable</strong></p>\n<p>상태 코드 <code class=\"language-text\">406</code>은 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation#%EC%84%9C%EB%B2%84_%EC%A3%BC%EB%8F%84_%EC%BB%A8%ED%85%90%EC%B8%A0_%ED%98%91%EC%83%81\" target=\"_blank\" rel=\"nofollow\">서버 주도 컨텐츠 협상</a>을 진행했음에도 불구하고 알맞은 컨텐츠 타입이 없다는 것을 의미한다.</p>\n<p>사실 클라이언트는 서버에게 리소스를 요청할 때, HTTP 헤더의 <code class=\"language-text\">Accept</code> 필드를 사용하여 어떤 컨텐츠 타입의 리소스를 원하는지도 함께 이야기해준다. 일반적으로 이 필드를 명시하지않을 경우 브라우저는 자동으로 <code class=\"language-text\">text/html</code>을 비롯한 몇 가지 타입들을 스스로 정의해서 헤더에 담아주고는 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET http://evan.com/\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html,application/xhtml+xml,application/xml,*/*</span></span>\n...</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이런 요청을 받은 서버는 클라이언트가 보낸 요청의 <code class=\"language-text\">Accept</code> 필드를 보고 앞에서부터 하나씩 찾아가며 요청받은 리소스와 알맞은 컨텐츠 타입이 있는지 하나씩 살펴보게 되고, 이후 알맞은 컨텐츠 타입이 있다면 HTTP 응답 헤더의 <code class=\"language-text\">Content-Type</code> 필드에 해당 컨텐츠 타입을 명시해주게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">HTTP/1.1 200 OK\nContent-Type: text/html</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 과정에서 어떤 컨텐츠 타입의 리소스를 응답으로 내려줄 것인지는 전적으로 서버가 결정하게 되므로 이 과정을 “서버 주도 컨텐츠 협상”이라고 하는 것이다. 위의 예시의 경우 클라이언트가 받기를 원했던 컨텐츠 타입 중 첫 번째 우선순위를 가진 <code class=\"language-text\">text/html</code>를 받아왔지만, 만약 서버에 <code class=\"language-text\">text/html</code> 타입의 리소스가 존재하지 않는 경우, 서버는 <code class=\"language-text\">application/xhtml+xml</code>, <code class=\"language-text\">application/xml</code> 순서로 리소스를 탐색하게 된다.</p>\n<p>만약 앞에 나열된 모든 컨텐츠 타입이 없는 경우 클라이언트가 요청했던 컨텐츠 타입 중 가장 마지막인 <code class=\"language-text\">*/*</code> 와일드 카드에 걸리기 때문에, 서버는 리소스가 어떤 컨텐츠 타입인지 상관하지 않고 그대로 응답해줄 것이다. 그러나 만약 클라이언트가 요청한 컨텐츠 타입을 모두 탐색했는데도 불구하고 알맞은 리소스가 없을 경우 서버는 <code class=\"language-text\">406</code> 상태 코드와 함께 “니가 찾는 컨텐츠 타입과 맞는 리소스가 없어”라는 응답을 주는 것이다.</p>\n<p><strong>408 Request Timeout</strong></p>\n<p>상태 코드 <code class=\"language-text\">408</code>은 클라이언트와 서버의 연결은 성사되었지만 요청의 본문이 계속 서버에 도착하지 않는 상황을 의미한다.</p>\n<p>HTTP 프로토콜을 사용하여 통신을 할 때는 반드시 클라이언트와 서버 간의 연결을 생성하고, 그 이후에 요청 본문에 해당하는 데이터를 전송하게 되는데, <code class=\"language-text\">408</code> 상태 코드는 이 과정에서 연결은 제대로 생성되었지만 서버가 아무리 기다려도 클라이언트가 보냈던 요청 본문을 받지 못하는 경우에 발생하게 된다.</p>\n<p><strong>429 Too Many Requests</strong></p>\n<p>상태 코드 <code class=\"language-text\">429</code>는 클라이언트가 서버에 너무 요청을 많이 보내는 경우에 발생한다. 너무 많이 보냈다는 것은, 너무 짧은 시간 안에 빠르게 요청을 마구 날려대서 서버가 “워워 진정해”라고 하는 경우일수도 있고, 유료 API를 사용하는 경우에는 현재 금액으로 사용할 수 있는 API 요청 횟수를 초과해서 “돈을 더 내세요”라는 의미로 사용되기도 한다.</p>\n<p>서버에서는 <code class=\"language-text\">429</code> 상태 코드와 함께 응답 헤더의 <code class=\"language-text\">Retry-After</code>라는 필드를 사용하여 “이 시간 이후에 재요청해봐”라는 의미를 전달할 수도 있다.</p>\n<h3 id=\"500번대\" style=\"position:relative;\">500번대<a href=\"#500%EB%B2%88%EB%8C%80\" aria-label=\"500번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>500번대의 코드들은 클라이언트가 아닌 서버에서 뭔가 말썽이 일어난 경우이다. 만약 이 상태 코드를 발견했다면 서버에서 뭔가 박살났다는 의미이므로 다소곳이 백엔드 개발자의 멱살을 잡아보도록 하자.</p>\n<p><strong>500 Internal Server Error</strong></p>\n<p>상태 코드 <code class=\"language-text\">500</code>은 백엔드 어플리케이션 내에서 뭔가 알 수 없는 에러가 발생했다는 의미이다. 대부분 제대로 핸들링되지 않은 에러가 발생한 경우가 많으므로, 에러의 원인을 클라이언트에게 알려주지 않는다.<small><strike>(라기 보다 알려줄 수 없는 상태인 경우가 많다)</strike></small></p>\n<p>또한 이렇게 핸들링되지 않은 에러의 원인을 클라이언트에게 고스란히 알려주는 것은 보안 사고가 발생할 가능성이 너무 크므로, <code class=\"language-text\">500</code> 상태 코드로 에러의 발생 자체만을 알려주는 경우가 대부분이다. 만약 이 상태 코드를 만난다면, 바로 서버 로그를 까보거나 <a href=\"https://sentry.io/welcome/\" target=\"_blank\" rel=\"nofollow\">Sentry</a>나 <a href=\"https://www.bugsnag.com/\" target=\"_blank\" rel=\"nofollow\">Bugsnag</a>과 같은 에러 모니터링 솔루션을 적극 활용하는 것을 추천한다.</p>\n<p><strong>502 Bad Gateway</strong></p>\n<p>상태 코드 <code class=\"language-text\">502</code>를 만날 수 있는 가장 흔한 상황은 바로 백엔드 어플리케이션이 죽은 상황이다. 근데 왜 “Server Died”와 같이 직접적인 메세지가 아니라 “Bad Gateway”와 같은 메세지를 보내주는 것일까?</p>\n<p>그 이유는 백엔드 아키텍처가 아무리 간단한 구조라고 해도 절대 어플리케이션 1개로만 구성되지 않기 때문이다. 여기서 말하는 게이트웨이는 어플리케이션 간의 추상적인 연결점을 의미하는데, 이 메세지가 의미하듯 백엔드의 아키텍처는 최소 2개 이상의 어플리케이션으로 구성된 경우가 대부분이다.</p>\n<p>일반적인 경우 클라이언트가 보낸 요청은 곧바로 백엔드 어플리케이션에 전달되는 것이 아니다. 사실 백엔드 어플리케이션에 앞단에는 아파치나 Nginx 같은 서버 엔진이나 로드밸런서 같은 친구들이 대신 요청을 받아서 백엔드 어플리케이션으로 전달해주는 경우가 대부분이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-nginx line-numbers\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span> <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span> evan.com</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://127.0.0.1:3000</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_http_version</span> 1.1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Upgrade <span class=\"token variable\">$http_upgrade</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Connection <span class=\"token string\">'upgrade'</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Host <span class=\"token variable\">$host</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_cache_bypass</span> <span class=\"token variable\">$http_upgrade</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Nginx를 사용하면 일반적으로 이런 설정을 사용하게 되는데, 이렇게 되면 Nginx는 80번 포트에서 대기하며 HTTP 프로토콜을 사용한 요청을 받아 3000번 포트에서 대기하고 있는 백엔드 어플리케이션에게 전달해주는 역할을 수행하게 된다.</p>\n<p>이런 아키텍처를 사용하는 이유는 보안과 처리 효율 때문이다. 백엔드 어플리케이션 자체가 완전무결한 친구가 아니기 때문에 모든 요청을 안심하고 백엔드 어플리케이션에게 먹여줄 수가 없는 것이다. 그렇다고 누가 사용하는 지도 모르는 클라이언트에서 안전한 요청만 보내줄 것이라는 기대 또한 어불성설이다.</p>\n<p>게다가 뭔가 연산이 필요한 요청이 아닌, 파일을 찾아서 보내주기만 하는 간단한 요청 같은 경우는 굳이 안 그래도 바쁜 백엔드 어플리케이션에게 시킬 필요가 없으므로 이런 서버 엔진이 대신 처리해주기도 한다.</p>\n<p>그래서 백엔드에서는 앞 단에 아예 프록시 서버를 두어서 문지기 역할을 시키는 것이다. 이때 이 프록시 서버와 백엔드 어플리케이션 간의 연결된 추상적인 통로를 “게이트웨이”라고 부르는 것이다. 백엔드 어플리케이션이 죽어버릴 경우 앞 단의 문지기인 프록시 서버는 백엔드 어플리케이션에게 아무런 응답을 받지 못하게 되고, 클라이언트에게 <code class=\"language-text\">502 Bad Gateway</code>라는 응답을 보내주는 것이다.</p>\n<p><strong>503 Service Unavailable</strong></p>\n<p>상태 코드 <code class=\"language-text\">503</code>은 서버가 요청을 처리할 준비가 되지 않았음을 의미한다. 간혹 <code class=\"language-text\">502 Bad Gateway</code>와 비슷한 느낌으로 사용되기는 하지만, <code class=\"language-text\">503</code>은 보다 “일시적인 상황”을 의미하는 상태 코드이며, 일반적으로 서버에 부하가 심해서 현재 요청을 핸들링 할 수 있는 여유가 없는 경우에 많이 사용된다.</p>\n<p>AWS Lambda에서는 요청을 처리할 때 컨테이너의 동시 실행 갯수를 초과할 정도의 리소스가 필요하거나 어떤 작업의 처리 시간이 Lambda에 설정된 컨테이너의 최대 수명 시간을 초과했을 경우에 발생하기도 한다.</p>\n<p>이렇듯이 <code class=\"language-text\">503</code>은 일시적인 상황을 의미하므로 <code class=\"language-text\">429 Too Many Requests</code>와 동일하게 응답 헤더의 <code class=\"language-text\">Retry-After</code> 필드를 사용하여 “이 시간 이후에 다시 요청해봐”라는 의미를 클라이언트에게 전달해줄 수 있다.</p>\n<p><strong>504 Gateway Timeout</strong></p>\n<p>상태 코드 <code class=\"language-text\">504</code>는 <code class=\"language-text\">408</code>과 마찬가지로 요청에 대한 타임아웃을 의미한다. 그러나 <code class=\"language-text\">504</code> 상태 코드는 클라이언트에서 보낸 요청 때문에 타임아웃이 발생하는 것이 아니라 백엔드 아키텍처 내부에서 서버끼리 주고받는 요청에서 발생한다.</p>\n<p>앞서 이야기했듯이 백엔드의 아키텍처는 단순히 백엔드 어플리케이션 하나로만 구성된 것이 아니기 때문에, 클라이언트의 요청이 서버에 닿은 뒤에도 백엔드 어플리케이션끼리의 통신이 발생하게 된다. 만약 프록시 서버 역할을 맡은 Nginx가 백엔드 어플리케이션에 클라이언트의 요청을 전달했는데, 백엔드 어플리케이션이 일정 시간 동안 응답을 하지 않는 경우 Nginx는 클라이언트에게 <code class=\"language-text\">504 Geteway Timeout</code>을 내려주게 되는 것이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이번 포스팅에서는 HTTP 상태 외에도 RESTful API에 대한 내용도 함께 이야기하려고 했지만, 다시 한번 분량 조절에 대실패하면서 포스팅을 나누어 작성하게 되었다.<small>(점점 빈도가 잦아진다…)</small></p>\n<p>앞서 이야기했듯이 이런 상태 코드와 같은 요소들은 딱히 안 지킨다고 해서 프로그램에서 에러가 발생하는 것도 아니기 때문에 가볍게 생각하고 넘어가기 쉽상이지만, 보다 명확한 인터페이스를 정의하게되면 프로그램의 작동을 예측하기도 쉬워지고, 프론트엔드와 백엔드 개발자 간의 커뮤니케이션에도 큰 도움이 되기 때문에 되도록이면 표준을 지켜주는 것을 권장한다.</p>\n<p>이상으로 서버의 상태를 알려주는 HTTP 상태 코드 포스팅을 마친다.</p>","fields":{"slug":"20200315-about-http-status-code","path":"/2020/03/15/about-http-status-code/","lang":"ko"},"frontmatter":{"title":"서버의 상태를 알려주는 HTTP 상태 코드","subTitle":"인터넷의 질서를 만드는 작은 숫자들","date":"Mar 15, 2020","categories":["프로그래밍","네트워크","아키텍처"],"tags":["HTTP","HTTP 상태코드","RESTful","Axios","HTTP Status"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/14576b0c5dc2ed40f94b7160f16c1e06/d803c/thumbnail.png","srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/d803c/thumbnail.png 320w,\n/static/14576b0c5dc2ed40f94b7160f16c1e06/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/fc5c5/thumbnail.webp 320w,\n/static/14576b0c5dc2ed40f94b7160f16c1e06/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/14576b0c5dc2ed40f94b7160f16c1e06/01fb2/thumbnail.png","srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"HTTP Status","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}