{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/axios/en/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"ef2a0def-88af-5483-99b3-c9a812e43ff7","tableOfContents":"<ul>\n<li>\n<p><a href=\"#do-we-really-need-to-follow-these-guidelines\">Do We Really Need to Follow These Guidelines?</a></p>\n<ul>\n<li><a href=\"#think-about-why-standard-interfaces-exist\">Think About Why Standard Interfaces Exist</a></li>\n<li><a href=\"#the-frontends-sad-story-that-backend-devs-dont-know-about\">The Frontend’s Sad Story That Backend Devs Don’t Know About</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#http-status-codes-reporting-the-result-of-your-work\">HTTP Status Codes: Reporting the Result of Your Work</a></p>\n<ul>\n<li><a href=\"#100-level\">100-Level</a></li>\n<li><a href=\"#200-level\">200-Level</a></li>\n<li><a href=\"#300-level\">300-Level</a></li>\n<li><a href=\"#400-level\">400-Level</a></li>\n<li><a href=\"#500-level\">500-Level</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#wrapping-up\">Wrapping Up</a></p>\n</li>\n</ul>","excerpt":"Modern applications are practically programs that run entirely on the network — communication makes up a huge portion of a program’s business logic. Client applications communicate with backend servers to fetch logged-in user information, create new posts, and sometimes subscribe to server events through WebSockets to implement features like push notifications or chat.","html":"<p>Modern applications are practically programs that run entirely on the network — communication makes up a huge portion of a program’s business logic. Client applications communicate with backend servers to fetch logged-in user information, create new posts, and sometimes subscribe to server events through WebSockets to implement features like push notifications or chat.</p>\n<!-- more -->\n<p>In this process, the frontend and backend need to define many rules — from how they’ll communicate, to how resource creation and deletion are defined, to how the success or failure of backend operations requested by the frontend should be reported.</p>\n<p>Several guidelines exist to help define these rules, and that’s where things like HTTP methods, status codes, and REST come in.</p>\n<p>In this post, I want to dive into HTTP status codes — one of the essential elements for clearer communication between frontend and backend.</p>\n<h2 id=\"do-we-really-need-to-follow-these-guidelines\" style=\"position:relative;\">Do We Really Need to Follow These Guidelines?<a href=\"#do-we-really-need-to-follow-these-guidelines\" aria-label=\"do we really need to follow these guidelines permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Honestly, HTTP methods, status codes, and REST are just guidelines. Not following them won’t break your program or cause runtime errors for users.</p>\n<p>In other words, you can write programs just fine without them.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgH/2gAMAwEAAhADEAAAAdFHeGZyL//EABwQAAEDBQAAAAAAAAAAAAAAAAACAxIBEyIjM//aAAgBAQABBQK4ZUVMbVsc5SP/xAAXEQADAQAAAAAAAAAAAAAAAAAAARIh/9oACAEDAQE/AXjJP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAQEBAQAAAAAAAAAAAAAAAAEAECL/2gAIAQEABj8ClXnCc//EABsQAAICAwEAAAAAAAAAAAAAAAABESExQVFh/9oACAEBAAE/IUje34sl0GmCI6npJS8JH//aAAwDAQACAAMAAAAQHO//xAAXEQEAAwAAAAAAAAAAAAAAAAAAETFR/9oACAEDAQE/EKGoP//EABYRAQEBAAAAAAAAAAAAAAAAAAEAEf/aAAgBAgEBPxABLb//xAAdEAEAAwACAwEAAAAAAAAAAAABABExcZEhUWGx/9oACAEBAAE/EKiWem1wSj+FUKG39MhTp3PLbaTkdjZ2W37AjTqf/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ebichu\" title=\"\" src=\"/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg\" srcset=\"/static/5ab263e405da8a4381a5fe32c5581820/0913d/ebichu.jpg 160w,\n/static/5ab263e405da8a4381a5fe32c5581820/cb69c/ebichu.jpg 320w,\n/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>So it doesn't matter if we don't follow them, right?</small>\n</center>\n<p>Well, not following these rules is your choice, but considering the side effects that can result, I’d recommend following them whenever possible.</p>\n<h3 id=\"think-about-why-standard-interfaces-exist\" style=\"position:relative;\">Think About Why Standard Interfaces Exist<a href=\"#think-about-why-standard-interfaces-exist\" aria-label=\"think about why standard interfaces exist permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Industry standards are established to ensure compatibility among products made by countless different producers and to facilitate communication between them. The set of standard specifications we define to make different entities compatible is what we call an “interface.”</p>\n<p>The concept of an interface is quite broad — if it connects things, it’s an interface. HDMI connecting monitors to computers, SATA used in storage devices, USB — they’re all interfaces. UI (User Interface) even extends the concept to connecting humans with machines.</p>\n<p>Among these, the interface most familiar to developers is the API (Application Programming Interface). An API provides the functionality needed to build applications as a set of interfaces.</p>\n<p>The convenience of APIs is that users only need to know how to use them — they can completely ignore whatever massive logic lies beneath. A classic example is the Windows OS API provided through C:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;Windows.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;tchar.h></span></span>\n\n<span class=\"token keyword\">int</span> APIENTRY <span class=\"token function\">_tWinMain</span><span class=\"token punctuation\">(</span>\n  HINSTANCE hInstance<span class=\"token punctuation\">,</span>\n  HINSTANCE hPrevInstance<span class=\"token punctuation\">,</span>\n  LPTSTR lpCmdLine<span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">int</span> nCmdShow\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">MessageBox</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token function\">TEXT</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, Windows!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">TEXT</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"App\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> MB_OK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Developers can display a message box simply by calling the <code class=\"language-text\">MessageBox</code> API function without knowing how the Windows OS renders it. And this interaction is communication between two entirely different programs — a C application and the operating system.</p>\n<p>In other words, an API is an interface for communication between programs. Similarly, when a client requests something from a server, it uses an API defined by specific rules to access server resources. In most modern applications that communicate via HTTP, these APIs are defined using specific URLs called endpoints, and the server must respond to client requests through these endpoints in a consistent manner.</p>\n<p>HTTP status codes are a kind of agreement that conveys the result of the client’s request — and they’re a crucial component of an API.</p>\n<h3 id=\"the-frontends-sad-story-that-backend-devs-dont-know-about\" style=\"position:relative;\">The Frontend’s Sad Story That Backend Devs Don’t Know About<a href=\"#the-frontends-sad-story-that-backend-devs-dont-know-about\" aria-label=\"the frontends sad story that backend devs dont know about permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>In this section, I want to briefly talk about something that frontend developers working with poorly designed APIs have likely experienced at least once. Backend developers rarely look at frontend application source code, so they might not even know this situation exists.</p>\n<p>It’s the case where HTTP status codes are used incorrectly — the classic example being a server that returns <code class=\"language-text\">200 OK</code> even when a request fails.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET /api/users/123</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK</span></span>\n{ \"success\": false }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>APIs designed this way typically include success/failure status and failure reasons in the HTTP response body, which creates an awkward situation for the frontend application.</p>\n<p>Frontends handle these async requests through Promises, and the problem is that most HTTP communication libraries and APIs determine success or failure based on the status code from the backend, throwing errors only when requests fail.</p>\n<p>So normally, frontend communication code looks something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUsers</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/users/123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'The request failed!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>If a request to the server fails, the server should send a 400 or 500-level status code, which causes <code class=\"language-text\">fetch</code> to throw an error. With that, a simple <code class=\"language-text\">try/catch</code> around <code class=\"language-text\">fetch</code> is all you need to handle communication errors.</p>\n<p>But when the backend returns a 200-level code even for failed requests, the frontend ends up in this sad situation:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUsers</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/users/123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> success <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'The request failed!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Notice the <code class=\"language-text\">if (!success)</code> that didn’t exist before. An unnecessary extra layer of error handling that hurts code readability, but the frontend has no choice. You can’t just ignore server errors and skip handling them.</p>\n<p>On top of that, if the backend encounters an unhandled error or the server dies entirely, the response will come back with a 500 or 502 error code anyway — so you can’t skip <code class=\"language-text\">try/catch</code> either.</p>\n<p>Every HTTP communication library on the client side is designed assuming correct HTTP status code usage. If the server uses incorrect status codes, these sad situations arise. And honestly, returning the correct status code for each situation isn’t even that hard on the backend side. <small>(Just a bit tedious.)</small></p>\n<p>Like client libraries, most server frameworks also provide HTTP status codes for every situation, so I recommend using the appropriate codes whenever possible.</p>\n<p>Now let’s dive into what each of these HTTP status codes actually means.</p>\n<h2 id=\"http-status-codes-reporting-the-result-of-your-work\" style=\"position:relative;\">HTTP Status Codes: Reporting the Result of Your Work<a href=\"#http-status-codes-reporting-the-result-of-your-work\" aria-label=\"http status codes reporting the result of your work permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>When a client requests work from a server, the server performs the work and sends back the result as a response. It uses HTTP status codes to indicate whether the work succeeded or failed, and if it failed, why. As we saw in the bad example above, some servers include failure information in the response body, but the better approach is to use the correct HTTP status codes.</p>\n<p>HTTP status codes have standardized numbers for each situation — “200 = success,” “400 = client screwed up,” “500 = server screwed up.” Basic web program behavior and frontend/backend frameworks are all designed around these standards, so it’s best to follow them.</p>\n<p>Web browsers — the quintessential HTTP programs — strictly follow these status code standards. Browsers actually distinguish between success and failure of their requests based on the status code the server returns, and they display this visually.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/581d5098769863da7581ecc2a09a19ed/d7ab4/browser-response.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 44.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABO0lEQVR42o1S7XKDIBD0VRJj4kc1ioqCCJh+vP8bbe8uaaadJtP+2Dk4cbndJbHWIoSAGAOMsRj1hLZTUvthxEw9Y5d71dMsfaV6WQ+jRkdrrue2RTJNE9Z1FVhv6EeDqqqw3+8FacpI7zgcDnd87b/3k3me4ZzDYh0632JajNyWFwXqusHxeLwRp8iy7AfhIyQsOcaIQJK3sEH1vcgbtYZbA+0H1E0jYFIhv13wkNCQRPbQey9yeTr2zy4O02zg44bL2wfi9gpDPfaPz1Qv9UNS8ZAls4duuZpelpVIZZxOuSDPcxRkA9c8L5DRt6cT8nRu9XjvFSzJ7SWxTlJjibvdTvAsnF8ebtt29ZGmHMeRnoeDprDWEIWUAyrK8s9AhFApBU0BMNEwXAPoqNecW7Q0JYfCnnJY/0n5E8S6FKangsPMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"browser response\" title=\"\" src=\"/static/581d5098769863da7581ecc2a09a19ed/6af66/browser-response.png\" srcset=\"/static/581d5098769863da7581ecc2a09a19ed/69538/browser-response.png 160w,\n/static/581d5098769863da7581ecc2a09a19ed/72799/browser-response.png 320w,\n/static/581d5098769863da7581ecc2a09a19ed/6af66/browser-response.png 640w,\n/static/581d5098769863da7581ecc2a09a19ed/d9199/browser-response.png 960w,\n/static/581d5098769863da7581ecc2a09a19ed/d7ab4/browser-response.png 1014w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Browsers treat 200-level status codes very differently from 400 and 500-level ones</small>\n</center>\n<p>If a server returns status code 200 but expresses the error only in the response body, the browser thinks the request succeeded while it actually failed — a bizarre situation.</p>\n<p>If the server returns a code like 301, the browser will automatically redirect the user to another page. So if the server doesn’t return proper status codes, the browser could exhibit unexpected behavior.</p>\n<p>Now let’s look at what each HTTP status code means. Status codes range from 100 to 500-level and can define quite a variety of states, but you don’t need to know them all. I’ll cover just the ones I’ve personally used at least once.</p>\n<h3 id=\"100-level\" style=\"position:relative;\">100-Level<a href=\"#100-level\" aria-label=\"100 level permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>100-level codes carry informational states like “you may switch protocols” or “continue sending requests.” I’ve never actually encountered these in application development, so I’ll skip them.</p>\n<h3 id=\"200-level\" style=\"position:relative;\">200-Level<a href=\"#200-level\" aria-label=\"200 level permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>200-level codes indicate that the server successfully performed the work the client requested. Browsers display these with a clean green color in the network tab.</p>\n<p>While “request succeeded” alone is often enough, if you need more detailed states, you can actively use 200-level codes to give the client more specific information.</p>\n<p><strong>200 OK</strong></p>\n<p>Status code <code class=\"language-text\">200</code> simply means the work succeeded. In most cases, the client knows exactly what it requested, so just knowing “your request succeeded” is sufficient — no additional detail needed. That’s why this single code is used for all successful API responses in the vast majority of cases.</p>\n<p><strong>201 Created</strong></p>\n<p>Status code <code class=\"language-text\">201</code> means the request was processed normally and a new resource was created as a result. Creating new resources through client requests is extremely common — the most representative case I’ve experienced is user registration. A registration request creates a new user row in the database, making it a perfect fit for <code class=\"language-text\">201</code>.</p>\n<p><strong>204 No Content</strong></p>\n<p>Status code <code class=\"language-text\">204</code> means the request was processed normally and the content associated with this request no longer cleanly exists. This code can be used as a response to deletion requests. My experience with it was a post deletion API.</p>\n<p>Note that whether the deletion is a soft delete or hard delete is completely irrelevant here. However the server represents resource deletion internally, the only information the client needs is “this resource has been deleted and is no longer available.”</p>\n<h3 id=\"300-level\" style=\"position:relative;\">300-Level<a href=\"#300-level\" aria-label=\"300 level permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>300-level codes relate to redirection. When a requested resource has been moved or deleted and can no longer be accessed normally, the server can tell the client “go here to find the resource you’re looking for” — and that’s what 300-level codes are for.</p>\n<p><strong>301 Moved Permanently</strong></p>\n<p>Status code <code class=\"language-text\">301</code> is also known as “301 Redirect” — the most commonly used redirection code. When a browser receives <code class=\"language-text\">301</code> in response, it checks the <code class=\"language-text\">Location</code> field in the HTTP header and automatically redirects to the URL specified there.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">301</span> <span class=\"token reason-phrase string\">Moved Permanently</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Location</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">https://evan/moved-contents/1234</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Search engine bots like Google’s also automatically update page information when they receive a <code class=\"language-text\">301</code> response, making correct use of this status code very important from an SEO (Search Engine Optimization) perspective.</p>\n<p>Redirection settings can typically be configured in the server engine’s configuration files or directly in the backend application. A common use case is redirecting users who connected via HTTP to the HTTPS-only port.</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-nginx line-numbers\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>         <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span>    evan.com</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">return</span>         <span class=\"token number\">301</span> https://<span class=\"token variable\">$host</span><span class=\"token variable\">$request_uri</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>         <span class=\"token number\">443</span> ssl</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span>    evan.com</span><span class=\"token punctuation\">;</span>\n    ...\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In this case, when Nginx detects a user connecting to port <code class=\"language-text\">80</code>, it redirects them to port <code class=\"language-text\">443</code> (which requires HTTPS), enforcing the secure protocol.</p>\n<p><strong>304 Not Modified</strong></p>\n<p>Status code <code class=\"language-text\">304</code> means the requested resource hasn’t changed at all compared to the previous request. Literally: Not Modified.</p>\n<p>When the server responds with this code, the client doesn’t need the server to retransmit the resource — it uses its cached version instead, reducing unnecessary communication payload.</p>\n<p>Since the client uses its cached resource rather than one received from the server, this is considered a redirection to the cached resource. That’s why <code class=\"language-text\">304</code> is sometimes called an implicit redirect.</p>\n<p>Browsers have their own caching mechanisms for this response. If a <code class=\"language-text\">304</code> response is received but there’s no cached resource, a blank screen or error page appears. So if you encounter this situation, you might want to check whether the browser actually has a cached resource.</p>\n<h3 id=\"400-level\" style=\"position:relative;\">400-Level<a href=\"#400-level\" aria-label=\"400 level permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>400-level codes mean something was wrong with the client’s request. If you spot one, there’s a high probability the frontend developer didn’t handle edge cases properly or sent bad data with the request. <small><strike>(There’s a small chance it’s the backend’s fault too…)</strike></small></p>\n<p><strong>400 Bad Request</strong></p>\n<p>Status code <code class=\"language-text\">400</code> is one of the most common 400-level codes, and it bluntly means “the client sent a bad request.” What exactly went wrong is sometimes included in the response body, but when it’s not, you might need to dig into the backend application logs.</p>\n<p><strong>401 Unauthorized</strong></p>\n<p>Status code <code class=\"language-text\">401</code> tells an unauthenticated user requesting a protected resource “you need to authenticate.” It’s commonly used when a non-logged-in user calls an API that requires login.</p>\n<p>When the client receives <code class=\"language-text\">401</code>, it often interprets this as “login required” and redirects the user to the login page.</p>\n<p><strong>403 Forbidden</strong></p>\n<p>Status code <code class=\"language-text\">403</code> means the client requested a forbidden resource. This code is sometimes confused with <code class=\"language-text\">401 Unauthorized</code> — the meanings seem ambiguous, but there’s one clear difference.</p>\n<p><code class=\"language-text\">401</code> literally means unauthenticated — the backend can’t identify who the current requester is. The server is saying “identify yourself!”</p>\n<p>With <code class=\"language-text\">403</code>, however, the backend doesn’t care at all who the requester is. Whether the client identified themselves or not, authenticated or not — accessing this resource is unconditionally forbidden.</p>\n<p>Servers may also return <code class=\"language-text\">403</code> when a resource requiring HTTPS is accessed via HTTP.</p>\n<p><strong>404 Not Found</strong></p>\n<p>Status code <code class=\"language-text\">404</code> simply means the requested resource doesn’t exist.</p>\n<p><strong>405 Method Not Allowed</strong></p>\n<p>Status code <code class=\"language-text\">405</code> means the wrong HTTP method was used for the current resource. Many backend frameworks automatically return <code class=\"language-text\">405</code> when a controller doesn’t have logic for the requested method.</p>\n<p><strong>406 Not Acceptable</strong></p>\n<p>Status code <code class=\"language-text\">406</code> means that even after <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#server-driven_content_negotiation\" target=\"_blank\" rel=\"nofollow\">server-driven content negotiation</a>, no suitable content type was found.</p>\n<p>When a client requests a resource, it uses the <code class=\"language-text\">Accept</code> header field to specify what content types it wants. If this field isn’t explicitly set, browsers typically fill in a few default types like <code class=\"language-text\">text/html</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET http://evan.com/\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html,application/xhtml+xml,application/xml,*/*</span></span>\n...</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>The server checks the <code class=\"language-text\">Accept</code> field from left to right, looking for a content type that matches the requested resource. If found, it specifies that type in the response’s <code class=\"language-text\">Content-Type</code> header.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">HTTP/1.1 200 OK\nContent-Type: text/html</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Since the server decides which content type to return, this process is called “server-driven content negotiation.” In the example above, the first-priority <code class=\"language-text\">text/html</code> was returned. If <code class=\"language-text\">text/html</code> doesn’t exist, the server tries <code class=\"language-text\">application/xhtml+xml</code>, then <code class=\"language-text\">application/xml</code>, and so on.</p>\n<p>If none of the listed types are available, the wildcard <code class=\"language-text\">*/*</code> at the end catches everything, and the server responds with whatever content type it has. But if even after checking all requested types no matching resource exists, the server returns <code class=\"language-text\">406</code>: “no resource matching your requested content types.”</p>\n<p><strong>408 Request Timeout</strong></p>\n<p>Status code <code class=\"language-text\">408</code> means the connection between client and server was established, but the request body never arrived.</p>\n<p>HTTP communication first establishes a connection, then transmits the request body data. <code class=\"language-text\">408</code> occurs when the connection was properly established but the server never receives the request body no matter how long it waits.</p>\n<p><strong>429 Too Many Requests</strong></p>\n<p>Status code <code class=\"language-text\">429</code> occurs when the client sends too many requests to the server. “Too many” could mean firing off requests so rapidly that the server says “whoa, calm down.” For paid APIs, it can also mean “you’ve exceeded your allowed request count — pay more.”</p>\n<p>The server can include a <code class=\"language-text\">Retry-After</code> header with the <code class=\"language-text\">429</code> response to tell the client “try again after this amount of time.”</p>\n<h3 id=\"500-level\" style=\"position:relative;\">500-Level<a href=\"#500-level\" aria-label=\"500 level permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>500-level codes mean something went wrong on the server side. If you spot one, something is broken on the server — time to have a word with the backend developer.</p>\n<p><strong>500 Internal Server Error</strong></p>\n<p>Status code <code class=\"language-text\">500</code> means some unknown error occurred in the backend application. It’s usually an unhandled error, which is why the error cause isn’t communicated to the client. <small><strike>(More like it can’t be communicated in most cases.)</strike></small></p>\n<p>Exposing unhandled error details to the client also poses a significant security risk, so <code class=\"language-text\">500</code> typically just signals that an error occurred. If you encounter this, I recommend checking server logs or leveraging error monitoring solutions like <a href=\"https://sentry.io/welcome/\" target=\"_blank\" rel=\"nofollow\">Sentry</a> or <a href=\"https://www.bugsnag.com/\" target=\"_blank\" rel=\"nofollow\">Bugsnag</a>.</p>\n<p><strong>502 Bad Gateway</strong></p>\n<p>The most common scenario for status code <code class=\"language-text\">502</code> is when the backend application has died. But why does it say “Bad Gateway” instead of something more direct like “Server Died”?</p>\n<p>Because no matter how simple a backend architecture is, it’s never just a single application. The “gateway” here refers to an abstract connection point between applications, and as the name implies, backend architectures are typically composed of at least two or more applications.</p>\n<p>In typical setups, client requests don’t go directly to the backend application. There’s usually a server engine like Apache or Nginx, or a load balancer, sitting in front to receive requests and forward them to the backend application.</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-nginx line-numbers\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span> <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span> evan.com</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://127.0.0.1:3000</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_http_version</span> 1.1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Upgrade <span class=\"token variable\">$http_upgrade</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Connection <span class=\"token string\">'upgrade'</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Host <span class=\"token variable\">$host</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_cache_bypass</span> <span class=\"token variable\">$http_upgrade</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>With a typical Nginx setup like this, Nginx listens on port 80, receives HTTP requests, and forwards them to the backend application running on port 3000.</p>\n<p>This architecture exists for security and processing efficiency. Backend applications aren’t bulletproof, so you can’t blindly feed them all requests. And expecting clients to always send safe requests is equally unrealistic.</p>\n<p>Plus, simple requests that just need to locate and serve files don’t need to bother the already-busy backend application — the server engine can handle those directly.</p>\n<p>So the backend places a proxy server at the front to act as a gatekeeper. The abstract passage connecting this proxy server to the backend application is called the “gateway.” When the backend application dies, the gatekeeper proxy receives no response and sends <code class=\"language-text\">502 Bad Gateway</code> to the client.</p>\n<p><strong>503 Service Unavailable</strong></p>\n<p>Status code <code class=\"language-text\">503</code> means the server isn’t ready to handle requests. It’s sometimes used similarly to <code class=\"language-text\">502 Bad Gateway</code>, but <code class=\"language-text\">503</code> implies a <strong>temporary</strong> situation — typically when the server is under heavy load and doesn’t have the capacity to handle the current request.</p>\n<p>In AWS Lambda, this can occur when processing a request requires more resources than the concurrent container execution limit, or when a task’s processing time exceeds the container’s maximum lifespan setting.</p>\n<p>Since <code class=\"language-text\">503</code> indicates a temporary situation, it can also use the <code class=\"language-text\">Retry-After</code> response header — same as <code class=\"language-text\">429 Too Many Requests</code> — to tell the client “try again after this amount of time.”</p>\n<p><strong>504 Gateway Timeout</strong></p>\n<p>Status code <code class=\"language-text\">504</code>, like <code class=\"language-text\">408</code>, indicates a request timeout. However, <code class=\"language-text\">504</code> isn’t caused by the client’s request timing out — it occurs within the backend architecture, between servers communicating with each other.</p>\n<p>As I mentioned, backend architecture isn’t just a single application. Even after a client’s request reaches the server, internal communication between backend applications continues. If Nginx (acting as a proxy) forwards a client request to the backend application but receives no response within a set time, Nginx returns <code class=\"language-text\">504 Gateway Timeout</code> to the client.</p>\n<h2 id=\"wrapping-up\" style=\"position:relative;\">Wrapping Up<a href=\"#wrapping-up\" aria-label=\"wrapping up permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>I originally planned to cover RESTful APIs alongside HTTP status codes in this post, but once again I failed spectacularly at controlling the length and had to split it into separate posts. <small>(This is happening more and more frequently…)</small></p>\n<p>As I mentioned, not following standards like status codes won’t cause program errors, so they’re easy to brush off. But defining clearer interfaces makes program behavior more predictable and greatly helps communication between frontend and backend developers — so I recommend following the standards whenever possible.</p>\n<p>That wraps up this post on HTTP status codes — the server’s way of talking back.</p>","fields":{"slug":"20200315-about-http-status-code-en","path":"/2020/03/15/about-http-status-code/en/","lang":"en"},"frontmatter":{"title":"HTTP Status Codes: The Server's Way of Talking Back","subTitle":"The small numbers that keep the internet in order","date":"Mar 15, 2020","categories":["Programming","Network","Architecture"],"tags":["HTTP","HTTP Status Code","RESTful","Axios","HTTP Status"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/14576b0c5dc2ed40f94b7160f16c1e06/d803c/thumbnail.png","srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/d803c/thumbnail.png 320w,\n/static/14576b0c5dc2ed40f94b7160f16c1e06/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/fc5c5/thumbnail.webp 320w,\n/static/14576b0c5dc2ed40f94b7160f16c1e06/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/14576b0c5dc2ed40f94b7160f16c1e06/01fb2/thumbnail.png","srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"Axios","lang":"en"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}