{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/tsconfig/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"198db2f8-2aa3-5519-a026-aa9af4081cdc","tableOfContents":"<ul>\n<li>\n<ul>\n<li><a href=\"#declaration\">declaration</a></li>\n<li><a href=\"#declarationdir\">declarationDir</a></li>\n<li><a href=\"#declarationmap\">declarationMap</a></li>\n<li><a href=\"#downleveliteration\">downlevelIteration</a></li>\n<li><a href=\"#emitbom\">emitBOM</a></li>\n<li><a href=\"#emitdeclarationonly\">emitDeclarationOnly</a></li>\n<li><a href=\"#importhelpers\">importHelpers</a></li>\n<li><a href=\"#importsnotusedasvalues\">importsNotUsedAsValues</a></li>\n<li><a href=\"#inlinesourcemap\">inlineSourceMap</a></li>\n<li><a href=\"#inlinesources\">inlineSources</a></li>\n<li><a href=\"#noemit\">noEmit</a></li>\n<li><a href=\"#noemithelpers\">noEmitHelpers</a></li>\n<li><a href=\"#noemitonerror\">noEmitOnError</a></li>\n<li><a href=\"#preserveconstenums\">preserveConstEnums</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 지난 [tsconfig의 모든 것] Compiler options / Modules 포스팅에 이어 의 컴파일 옵션 중 출력 파일을 컨트롤 하는 옵션들을 소개할 예정이다.","html":"<p>이번 포스팅에서는 지난 <a href=\"/20210808-tsconfig-compiler-options-modules\">[tsconfig의 모든 것] Compiler options / Modules</a> 포스팅에 이어 <code class=\"language-text\">tsconfig</code>의 컴파일 옵션 중 출력 파일을 컨트롤 하는 옵션들을 소개할 예정이다.</p>\n<!-- more -->\n<p>이 옵션들은 타입스크립트에서만 지원되는 문법들을 자바스크립트로 어떻게 표현할 것인지, 혹은 ES6 이상의 문법을 ES5로 트랜스파일링할 때 어떻게 표현할 것인지와 같이 타입스크립트로 작성된 코드를 컴파일한 이후에 생성되는 자바스크립트 코드의 모습을 결정하는 옵션들이다.</p>\n<p>물론 Babel과 같은 트랜스파일러가 제공해주는 기능과 중복되는 부분이 있기 때문에, TSC와 Babel을 함께 사용하는 경우에는 tsconfig에서 모든 옵션을 섬세하게 설정해주지 않아도 되는 경우도 있다.</p>\n<h2 id=\"declaration\" style=\"position:relative;\">declaration<a href=\"#declaration\" aria-label=\"declaration permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>컴파일 할 때 타입 선언 파일도 함께 생성한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>컴파일 할 때 자바스크립트 파일만을 생성한다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">declaration</code> 옵션은 타입스크립트의 <code class=\"language-text\">*.d.ts</code> 파일을 내보낼지 말지를 결정하는 옵션이다. 만약 기본적으로 이 옵션은 꺼져있기 때문에, 별도의 설정 없이 타입스크립트를 컴파일하게 되면 <code class=\"language-text\">*.js</code> 파일만 덩그러니 생성되는 모습을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// math.ts</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// math.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>하지만 <code class=\"language-text\">declaration</code> 옵션을 켜게 되면, 생성된 자바스크립트 파일 외에도 타입 선언을 담고 있는 <code class=\"language-text\">*.d.ts</code> 파일을 함께 생성하게된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// math.d.ts</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>만약 여러분이 만든 모듈이 타입스크립트를 지원하도록 하고 싶다면, 사용자가 직접 모듈의 소스코드를 가져올 수 있도록 허용하거나 자바스크립트 파일을 제공하되 타입 선언 파일인 <code class=\"language-text\">*.d.ts</code> 파일을 함께 제공해줘야 하기 때문에, 타입스크립트 대상의 라이브러리를 개발한다면 이 옵션을 사용하여 컴파일 시 타입 선언 파일까지 함께 생성하는 것을 추천한다.</p>\n<h2 id=\"declarationdir\" style=\"position:relative;\">declarationDir<a href=\"#declarationdir\" aria-label=\"declarationdir permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">string</code></td>\n<td>타입 선언 파일을 내보낼 디렉토리의 경로</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">declarationDir</code> 옵션은 이름 그대로 타입 선언 파일을 내보낼 경로를 설정할 수 있는 옵션이다. 이때 <code class=\"language-text\">.</code>가 의미하는 현재 경로는 <code class=\"language-text\">tsconfig</code> 파일이 위치한 곳을 의미하기 때문에, 만약 컴파일된 파일들이 위치한 디렉토리 안 쪽에 타입 선언 파일을 내보내고 싶다면 <code class=\"language-text\">./types</code>와 같은 경로가 아닌, <code class=\"language-text\">./{outDir}/types</code>와 같이 디렉토리를 직접 지정해줘야 한다.</p>\n<p>만약 <code class=\"language-text\">declarationDir</code> 옵션을 별도로 설정해주지 않는다면 타입 선언 파일은 자신의 원본 자바스크립트 파일과 동일한 위치에 생성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">declarationDir 옵션을 설정하지 않은 경우\n\nmyProject\n├── math.ts\n├── dist\n│   ├── math.d.ts &lt;\n│   └── math.js\n└── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">declarationDir 옵션을 \"./dist/types\"로 설정한 경우\n\nmyProject\n├── math.ts\n├── dist\n│   ├── math.js\n│   └── types\n│       └── math.d.ts &lt;\n└── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 하나의 디렉토리에 타입 선언 파일을 모아두게 되면 추후 <code class=\"language-text\">package.json</code>의 <code class=\"language-text\">types</code> 프로퍼티를 사용하여 편하게 해당 패키지의 타입 선언 파일들의 위치를 지정할 수 있으므로 필자는 <code class=\"language-text\">declarationDir</code> 옵션을 사용하여 타입 선언을 한 곳에 모아두는 편이다.</p>\n<h2 id=\"declarationmap\" style=\"position:relative;\">declarationMap<a href=\"#declarationmap\" aria-label=\"declarationmap permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>타입 선언과 소스 코드를 연결하는 매핑 파일을 생성한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>매핑 파일을 생성하지 않는다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">declarationMap</code> 옵션은 개발자가 IDE에서 제공하는 “Go to Definition” 같은 네비게이션 기능을 통해 원본 소스 파일로 이동할 수 있도록 도와주는 맵핑 파일을 함께 생성할 것인지에 대한 여부를 결정한다.</p>\n<p>앞서 알아보았듯이 <code class=\"language-text\">declaration</code> 옵션을 사용하여 타입 선언 파일을 생성하게 되면 다음과 같은 결과물이 컴파일된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// math.ts (원본 소스 파일)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// math.js (자바스크립트)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// math.d.ts (타입 선언)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 실제로 실행되는 코드를 담고 있는 자바스크립트 코드와 타입 선언을 담고 있는 타입 선언 파일의 연관 관계를 정의한 매핑 파일이 없다면, IDE에서 네비게이팅 기능을 사용했을 때 소스 코드가 아닌, <code class=\"language-text\">math.d.ts</code> 파일의 타입 선언으로 이동하게 된다.</p>\n<p>하지만 어차피 개발자 자신의 소스 코드에도 타입 선언에 대한 정보는 다 노출되고 있기 때문에, 네비게이팅을 사용하는 경우는 타입 선언 정의를 알고 싶다기 보다는 실제로 함수의 내부 구현을 보고 싶은 경우가 대부분일 것이다.</p>\n<p>이런 상황에서 <code class=\"language-text\">declarationMap</code> 옵션을 사용하면 개발자가 네비게이팅 기능을 사용했을 때 타입 선언이 아닌 소스 코드로 이동할 수 있도록 별도의 매핑 파일을 함께 생성해줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// math.d.ts (타입 선언)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">declare</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//# sourceMappingURL=math.d.ts.map</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// math.d.ts.map</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"file\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"math.d.ts\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"sourceRoot\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"sources\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"../../../utils/math.ts\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"names\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"mappings\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"AAAA,eAAO,MAAM,GAAG,MAAO,MAAM,SAAS,MAAM,WAAU,CAAC\"</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>매핑 파일은 JSON 포맷으로 구성되어 있으며, 타입 선언이 정의된 파일과 같은 경로에 생성된다. 이 매핑 파일은 원본 소스 코드의 경로를 가지고 있기 때문에, IDE의 네비게이팅 기능을 사용했을 때 “소스코드는 여기가 아니라 이 경로에 있음”이라고 알려줄 수 있는 것이다.</p>\n<p>즉, 이 기능을 100% 활용하고 싶다면 npm 레지스트리에 모듈을 배포할 때 반드시 소스 코드가 함께 포함되어야 한다. 일반적으로 npm 레지스트리에 배포할 때 소스코드가 아닌 빌드 결과물만을 배포하는 경우가 많은데, 이렇게 되면 어차피 라이브러리 내에 소스코드가 포함되어 있지 않기 때문에 매핑 파일을 함께 넣어줘도 의미가 없어지는 것이다.</p>\n<p>단순히 npm 레지스트리에 소스코드까지 포함해서 배포한다고 해서 내가 만든 모듈을 사용한 어플리케이션의 번들 사이즈가 늘어나는 것도 아니니, 내가 만든 라이브러리를 사용하는 개발자들의 생산성과 편의성을 많이 높혀주기 위해 <code class=\"language-text\">declarationMap</code>을 켜고 소스코드까지 포함해서 npm 레지스트리에 배포하는 것을 추천한다.</p>\n<h2 id=\"downleveliteration\" style=\"position:relative;\">downlevelIteration<a href=\"#downleveliteration\" aria-label=\"downleveliteration permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>ES6에 추가된 이터레이션 기능에 대한 명확한 구현을 함께 생성한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>기본적인 트랜스파일링만을 수행한다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">downlevelIteration</code> 옵션은 타입스크립트가 ES6에서 추가된 <code class=\"language-text\">for/of</code>, <code class=\"language-text\">Spread</code>, <code class=\"language-text\">Symbol.iterator</code> 등의 기능을 보다 명확하게 트랜스파일링을 하도록 만들 수 있는 옵션이다.</p>\n<p>컴파일 타겟인 자바스크립트 버전이 ES6 이상이라면 이 옵션은 크게 의미가 없지만, 크로스 브라우징 등을 위해 ES5 이하의 버전을 컴파일 타겟으로 삼는 경우에는 자바스크립트가 실행되는 런타임 때 이터레이터들이 개발자의 의도와 다르게 동작하는 것을 방지할 수 있다.</p>\n<p>예를 들어 <code class=\"language-text\">for/of</code>를 사용한 타입스크립트 코드를 ES5로 트랜스파일링한다면, 아래와 같은 결과물을 만나볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">'Hello!'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> s <span class=\"token keyword\">of</span> str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> str <span class=\"token operator\">=</span> <span class=\"token string\">'Hello!'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> _i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> str_1 <span class=\"token operator\">=</span> str<span class=\"token punctuation\">;</span> _i <span class=\"token operator\">&lt;</span> str_1<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> _i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> s <span class=\"token operator\">=</span> str_1<span class=\"token punctuation\">[</span>_i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">for/of</code>는 ES5에는 없는 기능이므로 타입스크립트는 <code class=\"language-text\">for/of</code>를 일반적인 <code class=\"language-text\">for</code>문으로 트랜스파일링 한 것이다.</p>\n<p>여기까지 보면 별로 문제가 없는 것 같지만, 사실 이렇게 트랜스파일링된 코드는 원본 코드와 정확히 일치하는 동작을 보여주지는 않는다. 바로 이런 코드 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">'🙏'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> s <span class=\"token keyword\">of</span> str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 코드에서 사용된 🙏 이모지는 필자가 개인적으로도 아주 애용하고 있는 이모지이다. 단순히 눈에 보이는 문자의 수가 한 개이기 때문에 이 이모지의 길이도 당연히 <code class=\"language-text\">1</code>이라고 생각할 수 있지만, 사실 이모지들의 길이는 <code class=\"language-text\">1</code>이 아니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'🙏'</span><span class=\"token punctuation\">.</span>length <span class=\"token comment\">// 2</span>\n<span class=\"token string\">'👩‍❤️‍💋‍👩'</span><span class=\"token punctuation\">.</span>length <span class=\"token comment\">// 11</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, 이 이모지의 길이를 사용하여 일반적인 <code class=\"language-text\">for</code> 문을 작성하게 되면 제대로 된 문자를 뽑아내기가 어려울 수 있다는 것이다. 무슨 말인지 잘 이해가 안 된다면, 아래 코드를 크롬 개발자도구에 복붙해서 한번 실행시켜보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"🙏\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> str<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">for문 > </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>str<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> s <span class=\"token keyword\">of</span> str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">for/of문 > </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>s<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">for문 > �\nfor문 > �\n\nfor/of문 > 🙏</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이것이 바로 <code class=\"language-text\">for/of</code> 문을 그냥 <code class=\"language-text\">for</code>문으로 트랜스파일링하면 안 되는 이유이다.</p>\n<p>이처럼 이모지의 길이가 1이 아닌 이유를 간단히만 설명하자면, 일단 이모지가 멀티바이트 문자이기 때문이기도 하고 계속 해서 새로운 이모지가 추가되기도 하고 기존 이모지들을 결합한 이모지들이 나오면서 이모지를 표현하는 방법이 괴랄해져서 그렇기도 하다. 이모지 길이에 대한 자세한 내용은 <a href=\"https://blog.jonnew.com/posts/poo-dot-length-equals-two\" target=\"_blank\" rel=\"nofollow\">이 포스팅</a>에 잘 설명되어있으니 한번 읽어보도록 하자.</p>\n<p>어찌됐던 여기서 중요한 포인트는 <code class=\"language-text\">for/of</code>와 <code class=\"language-text\">for</code>의 동작이 유사하다고 해서 묻어놓고 트랜스파일링을 했다가는 이런 참사가 발생할 수도 있다는 것이다.</p>\n<p>그래서 타입스크립트는 <code class=\"language-text\">downlevelIteration</code>이라는 옵션을 별도로 제공해서 <code class=\"language-text\">for/of</code>, <code class=\"language-text\">Spread</code>, <code class=\"language-text\">Symbol.iterator</code>와 같은 이터레이션 기능이 개발자의 의도와 다르게 동작하지 않도록 <code class=\"language-text\">Symbol.iterator</code> 같은 기능이 있는지 검사하거나, 아예 이런 기능을 구현해놓은 폴리필까지 함께 추가할 수 있도록 만들어 두었다.</p>\n<h2 id=\"emitbom\" style=\"position:relative;\">emitBOM<a href=\"#emitbom\" aria-label=\"emitbom permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>타입스크립트가 출력 파일을 생성할 때 BOM을 표시한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>타입스크립트가 출력 파일을 생성할 때 BOM을 표시하지 않는다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">emitBOM</code> 옵션은 타입스크립트가 출력 파일을 생성할 때 <a href=\"https://ko.wikipedia.org/wiki/%EB%B0%94%EC%9D%B4%ED%8A%B8_%EC%88%9C%EC%84%9C_%ED%91%9C%EC%8B%9D\" target=\"_blank\" rel=\"nofollow\">BOM(Bite Order Mark)</a>를 표시할지 말지를 결정할 수 있는 옵션이다.</p>\n<p>Bite Order Mark는 특별한 유니코드를 파일의 가장 앞 부분에 추가해서 이 파일이 어떤 인코딩 방식을 사용했는지를 나타내는 방법이다.</p>\n<p>BOM은 애초에 사람이 읽을 목적이 아니라 컴퓨터에게 현재 파일의 인코딩 정보를 알리기 위해서만 사용하기 때문에, 텍스트 에디터나 vim 같은 곳에서 파일을 열어보아도 BOM을 보여주지는 않는다.</p>\n<p>그러나 일반적으로 자바스크립트가 실행되는 런타임 환경에서 굳이 BOM까지 필요한 경우가 흔치 않기도 하고, 유니코드 3.2부터는 BOM을 사용하지 않을 것을 권장하고 있기도 해서, 굳이 켤 필요가 없는 옵션이기도 하다. <small>(타입스크립트 공식 문서에서도 굳이 안 켜도 된다고 하고 있다)</small></p>\n<h2 id=\"emitdeclarationonly\" style=\"position:relative;\">emitDeclarationOnly<a href=\"#emitdeclarationonly\" aria-label=\"emitdeclarationonly permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>자바스크립트 없이 타입 선언 파일만을 출력한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>자바스크립트 파일을 포함하여 출력한다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">emitDeclarationOnly</code> 옵션은 Declaration only라는 이름 그대로, 컴파일을 진행할 때 자바스크립트 파일 없이 타입 선언 파일만을 출력할지에 대한 여부를 결정하는 옵션이다.</p>\n<p>보통 타입스크립트를 자바스크립트로 변환할 때 타입스크립트 컴파일러가 아닌 별도의 도구를 사용하는 경우나, 기존에 자바스크립트로 만들어진 모듈에 타입 선언만을 제공해야하는 경우에 사용하게 된다.</p>\n<h2 id=\"importhelpers\" style=\"position:relative;\">importHelpers<a href=\"#importhelpers\" aria-label=\"importhelpers permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>출력 파일 내에서 tslib가 제공하는 헬퍼 함수들을 사용한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>tslib가 제공하는 헬퍼 함수를 사용하지 않고 직접 헬퍼를 구현하도록 한다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">importHelpers</code> 옵션은 타입스크립트를 자바스크립트 ES5 이하의 버전으로 트랜스파일링할 때 발생하는 헬퍼 함수들을 출력 파일 내에 직접 작성할 것이냐, 아니면 <code class=\"language-text\">tslib</code> 라이브러리가 제공하는 헬퍼 함수로 대체할 수 있도록 할 것이냐를 결정할 수 있는 옵션이다.</p>\n<p>한번 소스 코드와 출력 파일을 함께 보면서 이해해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>arr<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>arr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">fn</code> 함수는 인자로 받은 배열의 맨 앞에 <code class=\"language-text\">1</code>이라는 원소를 추가해서 반환하는 간단한 함수이다. 여러분도 아시다시피 <code class=\"language-text\">[...arr]</code>라는 문법으로 사용할 수 있는 Spread 기능은 ES5에 포함되어있지 않으므로, 타입스크립트는 <code class=\"language-text\">__spreadArray</code> 라는 헬퍼 함수를 출력 파일 내에 추가하여 Spread 기능을 트랜스파일링한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> __spreadArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>__spreadArray<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">to<span class=\"token punctuation\">,</span> from<span class=\"token punctuation\">,</span> pack</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pack <span class=\"token operator\">||</span> arguments<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> l <span class=\"token operator\">=</span> from<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> ar<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ar <span class=\"token operator\">||</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> from<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ar<span class=\"token punctuation\">)</span> ar <span class=\"token operator\">=</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      ar<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> from<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> to<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>ar <span class=\"token operator\">||</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">__spreadArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서 중요한 것은 ES6의 Spread 기능을 구현하기 위해 <code class=\"language-text\">__spreadArray</code>라는 함수의 구현이 출력 파일 내에 함께 포함되었다는 것이다. 사실 이런 구현이 출력 파일내에 포함되는 것이 큰 문제는 아닐 수 있지만, 만약 저 <code class=\"language-text\">__spreadArray</code>를 다른 곳에서 또 사용해야하는 경우에는 그 모듈에 또 다시 <code class=\"language-text\">__spreadArray</code> 함수의 구현이 추가되기 때문에 중복된 코드가 발생하게 된다.</p>\n<p>이때 <code class=\"language-text\">importHelpers</code> 옵션을 사용하게 되면 이러한 헬퍼 함수들을 <code class=\"language-text\">tslib</code> 라이브러리에서 가져오도록 변경하여 코드의 중복을 제거할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> __spreadArray <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'tslib'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">__spreadArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 되면 <code class=\"language-text\">__spreadArray</code> 함수를 <code class=\"language-text\">tslib</code>에서 불러와서 사용하게 되므로, 매번 <code class=\"language-text\">__spreadArray</code> 함수를 선언할 필요가 사라지기 때문에 코드의 중복을 제거할 수 있다. 하지만 이 옵션을 사용하여 트랜스파일링된 코드는 당연히 <code class=\"language-text\">tslib</code> 패키지를 설치되어있어야 제대로 작동하므로, 헬퍼 함수의 중복된 구현을 허용하는 것과 <code class=\"language-text\">tslib</code>를 내 어플리케이션에 설치하는 것의 득과 실을 잘 따져보고 옵션을 사용하도록 하자.</p>\n<h2 id=\"importsnotusedasvalues\" style=\"position:relative;\">importsNotUsedAsValues<a href=\"#importsnotusedasvalues\" aria-label=\"importsnotusedasvalues permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">remove</code></td>\n<td>출력 파일에서 런타임 때 필요없는 import 문을 제거한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">preserve</code></td>\n<td>출력 파일에서 타입 정보는 제거하되, import 문은 유지한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">error</code></td>\n<td>타입 정보만 가져오는 import 문을 사용했을 때 에러를 발생시킨다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">importsNotUsedAsValues</code> 옵션은 타입스크립트가 출력 파일을 생성할 때 필요없는 import 구문을 처리하는 방법을 제어할 수 있는 옵션이다. 이 옵션이 가지는 의미를 알기 위해서는 타입스크립트가 import 문을 처리하는 방법에 대해서 조금 알아야 한다.</p>\n<p>기본적으로 타입스크립트가 컴파일을 통해 자바스크립트 파일을 생성할 때, 타입과 관련된 정보는 지워버린다. 코드를 보면서 한번 이해해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> InterfaceFoo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../utils/foo'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> ClassBar <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../utils/bar'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> classBar<span class=\"token operator\">:</span> InterfaceFoo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassBar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> ClassBar <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../utils/bar'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> classBar <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassBar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>위 코드를 보면 <code class=\"language-text\">InterfaceFoo</code> 인터페이스를 가져오는 import 문이 자바스크립트 출력 파일 내에서는 사라진 것을 볼 수 있다. 왜냐하면 자바스크립트에는 타입스크립트의 타입이나 인터페이스 같은 기능이 없으니, 타입 정보를 남겨놔봤자 의미가 없기 때문이다.</p>\n<p>물론 앞서 이야기한대로 타입 정보는 어차피 자바스크립트에서 사용할 수 없으니, 이런 정보는 제거하는 것이 맞지만, 만약 <code class=\"language-text\">../utils/foo</code> 모듈이 의도적인 사이드이펙트를 포함하고 있을 경우에는 문제가 발생할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// utils/foo.ts</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">InterfaceFoo</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello world!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">utils/foo.ts</code> 모듈은 인터페이스만을 노출하고 있는 모듈이지만, 내부에는 <code class=\"language-text\">console.log</code>라는 사이드 이펙트를 포함하고 있다. 이 예시에서는 단순한 콘솔 출력이지만, 실제로 Angular 같은 경우는 이런 모듈 내부에서 명시적으로 모듈을 주입하고 등록하는 사이드 이펙트가 포함되기도 한다.</p>\n<p>문제는 이런 경우에도 타입스크립트는 자바스크립트를 출력할 때 <code class=\"language-text\">utils/foo</code> 모듈을 import 했던 구문 자체를 지워버린다는 것이다. 그러면 당연히 <code class=\"language-text\">console.log</code>라는 사이드 이펙트는 자바스크립트 런타임에서 실행되지 않는다. 그래서 이런 경우 개발자들은 의도적으로 사이드 이펙트를 실행시키기 위해 타입스크립트를 속일 수 있는 import 문을 하나 더 추가해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> InterfaceFoo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../utils/foo'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'../utils/foo'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> ClassBar <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../utils/bar'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> classBar<span class=\"token operator\">:</span> InterfaceFoo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassBar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token string\">'./utils/foo'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> ClassBar <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"../utils/bar\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> classBar <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassBar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그래서 타입스크립트 3.8버전에는 “이 import문이 타입 정보만을 가져오는 구문이다”라는 것을 명시적으로 표현할 수 있는 <code class=\"language-text\">import type</code> 기능을 추가했고, 혹여나 일반적인 import 문을 사용하여 타입 정보만을 가져오더라도 import문을 남겨둘 수 있도록 제어할 수 있는 <code class=\"language-text\">importsNotUsedAsValues</code> 옵션을 제공하는 것이다.</p>\n<h2 id=\"inlinesourcemap\" style=\"position:relative;\">inlineSourceMap<a href=\"#inlinesourcemap\" aria-label=\"inlinesourcemap permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td>소스맵 파일을 따로 생성한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>소스맵 파일의 내용을 Base64로 인코딩하여 소스 파일에 추가한다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">inlineSourceMap</code> 옵션은 타입스크립트가 컴파일 시 어떤 방식으로 소스맵을 생성할 것인지를 결정하는 옵션이다. 기본적으로 타입스크립트는 <code class=\"language-text\">*.js.map</code> 파일의 형태로 소스맵을 제공하는데, 만약 <code class=\"language-text\">inlineSourceMap</code>이 <code class=\"language-text\">true</code>일 경우에는 소스 파일 내부에 주석으로 소스맵을 추가한다.</p>\n<p>간단한 함수를 가지고 있는 모듈을 직접 컴파일해보며 어떤 차이가 있는지 직접 알아보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// math.ts</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>만약 <code class=\"language-text\">inlineSourceMap</code> 옵션이 꺼져 있는 경우, 타입스크립트는 별도의 소스맵 파일을 생성하고, 컴파일된 JS 파일에는 해당 소스맵의 경로만을 적어두는 형태로 소스맵을 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// math.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//# sourceMappingURL=math.js.map</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// math.js.map</span>\n<span class=\"token punctuation\">{</span><span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"file\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"math.js\"</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"sourceRoot\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"sources\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"../../utils/math.ts\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"names\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"mappings\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"AAAA,MAAM,CAAC,IAAM,GAAG,GAAG,UAAC,CAAS,IAAK,OAAA,UAAC,CAAS,IAAK,OAAA,CAAC,GAAG,CAAC,EAAL,CAAK,EAApB,CAAoB,CAAC\"</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 컴파일된 JS 파일에는 소스맵 파일의 경로가 <code class=\"language-text\">#sourceMappingURL=math.js.map</code>의 형태로 추가되고, 소스맵 파일에는 <code class=\"language-text\">\"sources\": [\"../../utils/math.ts\"]</code>처럼 원본 타입스크립트 소스 파일의 경로가 적혀있는 것을 확인할 수 있다.</p>\n<p>만약 <code class=\"language-text\">inlineSourceMap</code> 옵션을 켜게되면 이제 타입스크립트는 소스맵 파일을 생성하지 않고, 컴파일된 JS 파일 내에 직접 소스맵 파일의 내용을 Base64로 인코딩해서 추가한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3V0aWxzL21hdGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLElBQU0sR0FBRyxHQUFHLFVBQUMsQ0FBUyxJQUFLLE9BQUEsVUFBQyxDQUFTLElBQUssT0FBQSxDQUFDLEdBQUcsQ0FBQyxFQUFMLENBQUssRUFBcEIsQ0FBb0IsQ0FBQyJ9</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h2 id=\"inlinesources\" style=\"position:relative;\">inlineSources<a href=\"#inlinesources\" aria-label=\"inlinesources permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td>인라인 소스맵에 소스 코드의 내용은 포함시키지 않는다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>인라인 소스맵에 소스 코드의 내용도 함께 포함시킨다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">inlineSources</code> 옵션은 <code class=\"language-text\">inlineSourceMap</code> 옵션을 사용하여 만들어낸 인라인 소스맵에 원본 소스 코드의 내용도 함께 포함시킬 것인지 여부를 결정한다.</p>\n<p>이 옵션의 값이 <code class=\"language-text\">true</code>인 경우, 인라인 소스맵에 <code class=\"language-text\">sourceContent</code>라는 필드가 추가되고 해당 필드에는 소스 코드의 내용이 함꼐 포함된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3V0aWxzL21hdGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLElBQU0sR0FBRyxHQUFHLFVBQUMsQ0FBUyxJQUFLLE9BQUEsVUFBQyxDQUFTLElBQUssT0FBQSxDQUFDLEdBQUcsQ0FBQyxFQUFMLENBQUssRUFBcEIsQ0FBb0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBhZGQgPSAoeDogbnVtYmVyKSA9PiAoeTogbnVtYmVyKSA9PiB4ICsgeTtcbiJdfQ==</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// Decoding된 소스맵</span>\n\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"file\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"math.js\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"sourceRoot\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"sources\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"../../utils/math.ts\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"names\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"mappings\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"AAAA,MAAM,CAAC,IAAM,GAAG,GAAG,UAAC,CAAS,IAAK,OAAA,UAAC,CAAS,IAAK,OAAA,CAAC,GAAG,CAAC,EAAL,CAAK,EAApB,CAAoB,CAAC\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"sourcesContent\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"export const add = (x: number) => (y: number) => x + y;\\n\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>애초에 <a href=\"https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/preview#\" target=\"_blank\" rel=\"nofollow\">소스맵의 스펙</a> 상 <code class=\"language-text\">sourceContent</code> 필드는 원본 소스 파일에 접근하지 못한 경우를 대응하기 위한 일종의 예외처리에 가까우므로, 굳이 켜지 않아도 큰 문제가 없는 옵션이기도 하다.</p>\n<h2 id=\"noemit\" style=\"position:relative;\">noEmit<a href=\"#noemit\" aria-label=\"noemit permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td>컴파일 후에 출력 파일을 내보낸다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>컴파일 후에 출력 파일을 내보내지 않는다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noEmit</code> 옵션은 이름 그대로 타입스크립트가 컴파일을 한 이후에 출력 파일들을 내보낼 것인지에 대한 동작을 결정한다. 설명만 들어보면 이런 경우가 필요할까 싶기는 한데, 생각보다 유용하게 자주 쓰이는 옵션이다.</p>\n<p>대표적인 예로는 CI나 Git Hook 같은 타이밍에 정적 타입 체크만 진행해야 하는 경우 <code class=\"language-text\">tsc --noEmit</code>와 같은 명령어를 NPM 스크립트로 등록해놓거나, Webpack, Parcel, Rollup 등의 도구를 사용하여 컴파일을 진행할 때도 정적 타입 체크만을 TSC에게 시키기 위해 해당 옵션을 사용하는 경우가 많다.</p>\n<h2 id=\"noemithelpers\" style=\"position:relative;\">noEmitHelpers<a href=\"#noemithelpers\" aria-label=\"noemithelpers permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td>컴파일된 파일에 <code class=\"language-text\">__awaiter</code>와 같은 헬퍼 함수를 포함시킨다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>컴파일된 파일에는 <code class=\"language-text\">__awaiter</code>와 같은 헬퍼 함수를 포함시키지 않는다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noEmitHelpers</code> 옵션은 컴파일이 완료된 출력 파일에 <code class=\"language-text\">__awaiter</code>나 <code class=\"language-text\">__generator</code>와 같은 헬퍼 함수들을 포함시킬지 여부를 결정한다.</p>\n<p><code class=\"language-text\">noEmitHelpers</code> 옵션의 동작이 <a href=\"#importhelpers\">importHelpers</a>와 유사하기 때문에 조금 헷갈릴 수 있다. <code class=\"language-text\">importHelpers</code> 옵션은 헬퍼 함수들의 구현을 “소스에 포함할지”, “다른 곳에서 import할지”를 결정한다면, <code class=\"language-text\">noEmitHelpers</code> 옵션은 헬퍼 함수들의 구현을 “소스에 포함할지”, “아예 하지 않을 것인지”를 결정하기 때문이다.</p>\n<p>이 차이점을 직접 컴파일된 코드를 보면서 알아보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// importHelpers, noEmitHelpers가 모두 꺼져있는 경우에는 출력 파일에 헬퍼의 구현도 포함된다</span>\n\n<span class=\"token keyword\">var</span> __awaiter <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>__awaiter<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">thisArg<span class=\"token punctuation\">,</span> _arguments<span class=\"token punctuation\">,</span> <span class=\"token constant\">P</span><span class=\"token punctuation\">,</span> generator</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> __generator <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>__generator<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">thisArg<span class=\"token punctuation\">,</span> body</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">__awaiter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">__generator</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">_a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token comment\">/*return*/</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// importHelper가 켜져있는 경우에는 외부에서 헬퍼를 가져온다</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> __awaiter<span class=\"token punctuation\">,</span> __generator <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"tslib\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">__awaiter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">__generator</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">_a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token comment\">/*return*/</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// noEmitHelpers가 켜져있는 경우에는 아예 헬퍼를 가져오거나 선언하는 코드 조차 없다</span>\n\n<span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">__awaiter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">__generator</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">_a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token comment\">/*return*/</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>만약 <code class=\"language-text\">importHelpers</code>와 <code class=\"language-text\">noEmitHelpers</code> 옵션이 모두 켜져있다면 헬퍼 함수를 “외부에서 가져올 것이냐”, “출력 파일에 포함시키지 않을 것이냐”라는 설정이 충돌하게 되는데, 이 경우에는 <code class=\"language-text\">importHelpers</code>의 동작을 우선적으로 따르게 되니 이 점을 주의하도록 하자.</p>\n<h2 id=\"noemitonerror\" style=\"position:relative;\">noEmitOnError<a href=\"#noemitonerror\" aria-label=\"noemitonerror permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td>컴파일 중 에러가 발생하더라도 출력 파일을 내보낸다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>컴파일 중 에러가 발생한 경우 출력 파일을 내보내지 않는다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noEmitOnError</code> 옵션은 이름 그대로 컴파일 중 여러가지 요인으로 인해 에러가 발생하게 되는 경우 출력 파일을 내보낼 것인지에 대한 여부를 결정한다. 만약 이 옵션이 켜져있는 경우, 컴파일 중 에러가 발생하면 출력 파일이 내보내지지 않는다.</p>\n<p>이렇게만 보면 “당연히 에러가 나면 출력 파일을 안 만드는 게 맞지 않나?”라고 생각할 수 있지만, TSC의 Watch 옵션을 사용하고 있는 개발환경 같은 경우는 컴파일 중 에러가 발생해도 출력 파일을 생성하고 그로 인해 발생하는 사이드 이펙트 또한 함께 관찰하는 것이 더 편할 수도 있기 때문에, 개발환경에서는 해당 옵션을 끄고 운영환경 배포를 위한 빌드 타임 때는 켜놓는 것을 추천한다.</p>\n<h2 id=\"preserveconstenums\" style=\"position:relative;\">preserveConstEnums<a href=\"#preserveconstenums\" aria-label=\"preserveconstenums permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">const enum</code> 키워드를 사용한 Enum 선언을 컴파일 타임 때 제거한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">const enum</code> 키워드를 사용한 Enum 선언을 컴파일 타임 때 제거하지 않는다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">preserveConstEnums</code> 옵션은 컴파일 타임 때 <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html#const-enums\" target=\"_blank\" rel=\"nofollow\">const enum</a> 키워드를 사용한 Enum 선언을 제거할 것인지에 대한 옵션이다. 타입스크립트는 런타임 때의 메모리 비용을 절약하기 위해 <code class=\"language-text\">const enum</code> 키워드로 선언한 Enum의 값을 참조하는 부분을 해당 Enum의 값으로 치환한다.</p>\n<p><code class=\"language-text\">enum</code> 키워드만을 사용하여 선언한 Enum과 다르게 <code class=\"language-text\">const enum</code> 키워드를 사용한 Enum은 반드시 상수 값만 가지는 것이 보장되기 때문에 참조 투명성 또한 보장되고, 결국 컴파일 타임 때 값을 그냥 치환해버려도 아무 문제가 없는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">enum</span> Foo <span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">B</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">C</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> foo <span class=\"token operator\">=</span> Foo<span class=\"token punctuation\">.</span><span class=\"token constant\">A</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> Foo<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">Foo</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Foo<span class=\"token punctuation\">[</span>Foo<span class=\"token punctuation\">[</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">;</span>\n    Foo<span class=\"token punctuation\">[</span>Foo<span class=\"token punctuation\">[</span><span class=\"token string\">\"B\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">;</span>\n    Foo<span class=\"token punctuation\">[</span>Foo<span class=\"token punctuation\">[</span><span class=\"token string\">\"C\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"C\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>Foo <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>Foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token comment\">/* A */</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;= Foo.A가 아닌, 값으로 치환되었다</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이때 컴파일된 코드를 자세히 보면, Enum을 표현하기 위해 <code class=\"language-text\">Foo</code>라는 변수를 선언하고 IIFE를 사용하여 해당 변수에 값을 할당하고 있지만, 정작 이 변수에 접근하는 부분은 없는 것을 알 수 있다. 즉, 이 JS 코드가 실행되는 런타임 환경에서는 <code class=\"language-text\">Foo</code>라는 변수가 없어도 아무 문제가 없다는 것이다.</p>\n<p>이때 <code class=\"language-text\">preserveConstEnums</code> 옵션의 값을 <code class=\"language-text\">false</code>로 설정하면 이렇게 런타임에서는 아무 의미없는 Enum 선언을 제거할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token comment\">/* A */</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h1 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>이렇게 <code class=\"language-text\">tsconfig</code> 4번째 시리즈인 <code class=\"language-text\">Emit</code> 편을 마무리했다. Emit과 관련된 역할을 하는 옵션들은 주로 TSC와 다른 도구를 결합하여 사용하거나, 번들 사이즈를 최적화해야하는 경우에 주로 건드리게 되는데, 필자 또한 꽤나 오랜만에 이 옵션들을 공부하게 되었던 지라 예전에 써본 옵션들이 있음에도 불구하고 기억이 가물가물 했던 것 같다.</p>\n<p>이상으로 [tsconfig의 모든 것] Compiler options / Emit 포스팅을 마친다.</p>","fields":{"slug":"20211030-tsconfig-compiler-options-modules-emit","path":"/2021/10/30/tsconfig-compiler-options-modules-emit/","lang":"ko"},"frontmatter":{"title":"[tsconfig의 모든 것] Compiler options / Emit","subTitle":"빌드 결과물의 형태를 제어하는 옵션들, 출력 전략을 설계하는 법","date":"Oct 30, 2021","categories":["프로그래밍","튜토리얼","자바스크립트"],"tags":["TypeScript","타입스크립트","tsconfig"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/d96f04d4b1d49fa98ee91007f9ad0674/d803c/thumbnail.png","srcSet":"/static/d96f04d4b1d49fa98ee91007f9ad0674/d803c/thumbnail.png 320w,\n/static/d96f04d4b1d49fa98ee91007f9ad0674/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/d96f04d4b1d49fa98ee91007f9ad0674/fc5c5/thumbnail.webp 320w,\n/static/d96f04d4b1d49fa98ee91007f9ad0674/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/d96f04d4b1d49fa98ee91007f9ad0674/01fb2/thumbnail.png","srcSet":"/static/d96f04d4b1d49fa98ee91007f9ad0674/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/d96f04d4b1d49fa98ee91007f9ad0674/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"2212aca4-174d-5d3e-82d1-d5d732a31cca","tableOfContents":"<ul>\n<li>\n<p><a href=\"#allowumdglobalaccess\">allowUmdGlobalAccess</a></p>\n</li>\n<li>\n<p><a href=\"#baseurl\">baseUrl</a></p>\n</li>\n<li>\n<p><a href=\"#paths\">paths</a></p>\n</li>\n<li>\n<p><a href=\"#module\">module</a></p>\n<ul>\n<li><a href=\"#commonjs\">CommonJS</a></li>\n<li><a href=\"#amd\">AMD</a></li>\n<li><a href=\"#umd\">UMD</a></li>\n<li><a href=\"#system\">System</a></li>\n<li><a href=\"#es-module\">ES Module</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#moduleresolution\">moduleResolution</a></p>\n<ul>\n<li><a href=\"#classic\">Classic</a></li>\n<li><a href=\"#node\">Node</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#noresolve\">noResolve</a></p>\n</li>\n<li>\n<p><a href=\"#resolvejsonmodule\">resolveJsonModule</a></p>\n</li>\n<li>\n<p><a href=\"#rootdir\">rootDir</a></p>\n</li>\n<li>\n<p><a href=\"#rootdirs\">rootDirs</a></p>\n</li>\n<li>\n<p><a href=\"#typeroots\">typeRoots</a></p>\n</li>\n<li>\n<p><a href=\"#types\">types</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 지난 [tsconfig의 모든 것] Compiler options / Type Checking 포스팅에 이어 의 컴파일 옵션 중 모듈과 관련된 옵션들에 대한 이야기를 해보려고 한다.","html":"<p>이번 포스팅에서는 지난 <a href=\"/20210808-tsconfig-compiler-options-type-check\">[tsconfig의 모든 것] Compiler options / Type Checking</a> 포스팅에 이어 <code class=\"language-text\">tsconfig</code>의 컴파일 옵션 중 모듈과 관련된 옵션들에 대한 이야기를 해보려고 한다.</p>\n<!-- more -->\n<p>이 옵션들은 타입스크립트를 컴파일할 때 모듈들이 어떤 모듈 시스템을 따르도록 할 것인지, 어떤 경로에 있는 파일들을 컴파일 할 것인지, 빌드된 자바스크립트 파일들이 어떤 모듈 방식을 따르게 할 것인지 등을 컨트롤 할 수 있는 것들인데, 일반적인 서비스를 만드는 경우보다는 타입스크립트로 작성된 라이브러리를 만들 때 자주 다루게 되는 옵션들이기도 하다.</p>\n<h2 id=\"allowumdglobalaccess\" style=\"position:relative;\">allowUmdGlobalAccess<a href=\"#allowumdglobalaccess\" aria-label=\"allowumdglobalaccess permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>umd 모듈로의 접근을 허용한다</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>umd 모듈로의 접근을 허용하지 않는다</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">allowUmdGlobalAccess</code> 옵션은 타입스크립트 모듈이 전역 객체에 모듈을 포함시켜 내보내는 UMD(Universal Module Definition)형태의 모듈에 접근이 가능하게 할 것인지를 컨트롤 하는 옵션이다.</p>\n<p>만약 이 옵션이 꺼져 있다면 jQuery의 <code class=\"language-text\">$</code>와 같은 전역 변수에 그냥 접근하는 것이 불가능해지고, 무조건 <code class=\"language-text\">import</code> 문을 통해서 모듈을 가져와야 한다.</p>\n<p>UMD 방식을 사용하여 만들어진 라이브러리들은 보통 이런 형태의 글로벌 타입 선언을 가지고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">doThing1</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> version<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">AnInterface</span> <span class=\"token punctuation\">{</span>\n  foo<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">namespace</span> myLibrary<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 타입 파일이 네임스페이스를 export 하도록 선언되어 있는 경우, 타입스크립트는 이 모듈이 암묵적으로 전역 변수인 <code class=\"language-text\">myLibrary</code>에 할당된다고 판단한다. 그렇기 때문에 이런 타입 선언을 내 소스에 포함시키면 <code class=\"language-text\">myLibrary</code>라는 네임스페이스를 통해 이 모듈의 내용물에 접근할 수가 있는 것이다.</p>\n<p>만약 <code class=\"language-text\">allowUmdGlobalAccess</code> 옵션이 꺼져있는 상태라면 이런 에러를 만나게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> b <span class=\"token operator\">=</span> myLibrary<span class=\"token punctuation\">.</span><span class=\"token function\">doThing1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 'myLibrary' refers to a UMD global, but the current file is a module. Consider adding an import instead.ts(2686)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이때 <code class=\"language-text\">allowUmdGlobalAccess</code> 옵션을 켜게 되면 네임스페이스로 export된 UMD 모듈에 접근하는 것이 허용된다. 하지만 굳이 암묵적으로 전역 변수에 선언되어있는 모듈에 접근해서 사용하는 것보다 <code class=\"language-text\">import</code> 키워드로 명시적으로 모듈을 가져와서 사용하는 것이 더 안전하니, 피치 못하는 경우가 아니라면 가급적 해당 옵션을 켜두도록 하자.</p>\n<h2 id=\"baseurl\" style=\"position:relative;\">baseUrl<a href=\"#baseurl\" aria-label=\"baseurl permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">baseUrl</code> 옵션은 상대 경로로 모듈의 경로를 지정할 때 기준이 되는 위치를 지정할 수 있는 옵션이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">myProject\n├── index.ts\n├── utils\n│   └── foo.ts\n└── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>예를 들어 위와 같은 상황일 때, <code class=\"language-text\">index.ts</code>에서 상대 경로를 사용하여 <code class=\"language-text\">foo.ts</code> 모듈을 가져오려면 <code class=\"language-text\">./utils/foo</code>와 같이 현재 기준이 되는 위치를 <code class=\"language-text\">./</code> 처럼 지정한 후 해당 모듈에 접근하게 된다.</p>\n<p>하지만 잘 생각해보면 아무리 상대 경로를 사용한다고 해도, 기준이 되는 위치 자체가 변하는 경우는 많지 않다는 것을 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">myProject\n├── index.ts\n├── utils\n│   └── foo.ts\n├── remotes\n│   └── bar.ts\n└── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>만약 이런 구조의 프로젝트의 <code class=\"language-text\">remotes/bar</code> 모듈에서 <code class=\"language-text\">utils/foo</code> 모듈에 접근하려고 한다면 결국 <code class=\"language-text\">../utils/foo</code> 처럼 프로젝트의 루트까지 올라간 후 다시 내려오는 방식으로 접근을 하기 때문이다.</p>\n<p>그래서 <code class=\"language-text\">baseUrl</code> 옵션은 상대경로를 사용할 때마다 반복되는 “루트로의 여정”을 없애주는 역할을 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"include\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"src/*\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"baseUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이때 <code class=\"language-text\">baseUrl</code>에 입력하는 상대 경로의 기준은 <code class=\"language-text\">tsconfig</code>가 위치하는 곳이기 때문에 일반적으로는 프로젝트의 루트가 된다. 즉, 이렇게 설정한 후 우리가 모듈에 접근하기 위해 상대 경로를 사용하게 되면, 타입스크립트는 <code class=\"language-text\">baseUrl</code>에 입력된 루트의 위치에서부터 해당 모듈을 찾아가게 되는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> foo <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'utils/foo'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 사실 .(루트)/utils/foo</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> bar <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'remotes/bar'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 사실 .(루트)/remotes/bar</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이렇게 <code class=\"language-text\">baseUrl</code> 옵션을 사용하면 매번 <code class=\"language-text\">./</code>나 <code class=\"language-text\">../</code> 등을 사용하여 루트를 먼저 찾은 후 모듈에 접근하는 상대 경로를 절대 경로처럼 사용할 수 있다.</p>\n<h2 id=\"paths\" style=\"position:relative;\">paths<a href=\"#paths\" aria-label=\"paths permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">paths</code> 옵션은 특정한 모듈 이름을 지정했을 때 컴파일러가 어디서 부터 모듈을 탐색해야 할 지를 지정할 수 있는 맵을 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"baseUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./src\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"paths\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"app/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"app/*\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"config/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"app/_config/*\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"environment/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"environments/*\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"shared/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"app/_shared/*\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"helpers/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"helpers/*\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"tests/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"tests/*\"</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>맵에 포함되는 경로들은 <code class=\"language-text\">baseUrl</code>을 기준으로 상대 경로로 계산되기 때문에, <code class=\"language-text\">paths</code> 옵션을 사용하기 위해서는 반드시 <code class=\"language-text\">baseUrl</code> 옵션에 값을 채워주어야 한다. 즉, 위 예시의 <code class=\"language-text\">app/*</code>는 <code class=\"language-text\">./src/app/*</code>를 의미하며, 모듈을 불러올 때 <code class=\"language-text\">import foo from 'app/math'</code>와 같이 접근하게 되면, 타입스크립트는 자동으로 맵에 해당하는 경로인 <code class=\"language-text\">./src/app/math</code>를 탐색한 후 모듈을 가져오게 된다.</p>\n<p>만약 <code class=\"language-text\">paths</code> 옵션에 설정된 위치들을 전부 탐색했는데도 모듈을 찾지 못 했다면, <code class=\"language-text\">moduleResolution</code> 옵션에서 설정한 전략에 따라 추가적인 탐색을 진행하게 된다.</p>\n<p>사실 패스 매핑 자체는 워낙 간단한 설정이기 때문에 크게 어려울 것이 없지만, 종종 패스 매핑이 반드시 <code class=\"language-text\">baseUrl</code>을 기준으로 시작한다는 점을 까먹어서 실수를 하곤 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">myProject\n├── src\n│   └── index.ts\n├── node_modules\n│   └── foo\n└── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위와 같은 구조의 프로젝트에서 <code class=\"language-text\">baseUrl</code>로 <code class=\"language-text\">./src</code>를 지정한 상황을 생각해보자. 우리가 <code class=\"language-text\">foo</code>라는 패스에 <code class=\"language-text\">node_modules/foo</code>를 매핑하려면 어떻게 해야할까?</p>\n<p>이때 자주 하는 실수는 <code class=\"language-text\">tsconfig.json</code>의 위치를 기준으로 <code class=\"language-text\">\"foo\": \"./node_modules/foo\"</code>라고 설정하는 것이다. 아무래도 내가 지금 패스 매핑 작업을 하고 있는 파일이 <code class=\"language-text\">tsconfig.json</code>이니 별 생각없이 현재 파일 기준으로 경로를 지정하는 것이다.</p>\n<p>하지만 패스 매핑은 <code class=\"language-text\">baseUrl</code>을 기준으로 진행되기 때문에 이 경우에는 <code class=\"language-text\">src</code> 디렉토리가 기준점이 된다. 즉, <code class=\"language-text\">\"foo\": \"../node_modules/foo\"</code>로 매핑을 진행해주어야 한다는 것이다.</p>\n<p>간혹 이 점을 잊고 <code class=\"language-text\">tsconfig.json</code>의 위치를 기준으로 패스 매핑을 진행했다가 모듈 탐색에 실패하는 경우가 왕왕 있으니 주의하도록 하자.</p>\n<h2 id=\"module\" style=\"position:relative;\">module<a href=\"#module\" aria-label=\"module permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">CommonJS</code> (default)</td>\n<td>CommonJS 형식으로 모듈을 컴파일한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">AMD</code></td>\n<td>Asynchronous Module Definition 형식으로 모듈을 컴파일한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">UMD</code></td>\n<td>Universal Module Definition 디자인 패턴을 사용하여 모듈을 컴파일한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">System</code></td>\n<td>System.js 형식으로 모듈을 컴파일한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">ES6</code>, <code class=\"language-text\">ES2015</code>, <code class=\"language-text\">ES2020</code>, <code class=\"language-text\">ESNext</code></td>\n<td>ESM(ES Module) 방식으로 모듈을 컴파일한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">module</code> 옵션은 컴파일을 마친 자바스크립트 모듈이 어떤 모듈 시스템을 사용할 지를 설정하는 옵션이다.</p>\n<p>물론 ECMAScript에서 지정한 공식 모듈 시스템은 <code class=\"language-text\">import</code>, <code class=\"language-text\">export</code> 키워드를 사용하는 ESM 방식이기는 하지만, 현실적으로 이러한 모듈 시스템을 지원하는 브라우저가 아직 많지 않고, NodeJS 같은 경우 지난 12.0.0 버전에서 <code class=\"language-text\">--experimental-modules</code> 플래그 없이 ESM을 사용할 수 있는 기능이 추가되기는 했지만, 아직 생태계 전체에 ESM 시스템이 퍼져있는 상황은 아니다. <small>(NodeJS 진영은 아직 CommonJS를 많이 사용한다)</small></p>\n<p>이런 이유들로 인해 우리의 모듈이 무조건 ESM 시스템을 사용하도록 컴파일하기는 현실적으로 어렵기 때문에, 적절히 상황에 맞는 모듈 시스템을 선택할 수 있어야 하는 것이다.</p>\n<p>이 포스팅에서 자바스크립트의 모듈 시스템에 대한 모든 것을 다룰 수는 없으니, 각 모듈 시스템들의 특징 정도만 간단하게 알아보고 넘어가도록 하겠다. 한번 간단하게 두 개의 모듈로 구성된 어플리케이션을 상상해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// utils/math.ts</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// index.ts</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> add <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./utils/math'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> add2 <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 어플리케이션의 <code class=\"language-text\">index.ts</code> 모듈은 <code class=\"language-text\">utils/math.ts</code> 모듈에서 <code class=\"language-text\">add</code>라는 함수를 가져와서 커링을 통해 <code class=\"language-text\">add2</code> 함수를 생성하고 다시 내보내는 모듈이다. 이제 이 어플리케이션을 각각의 모듈 시스템을 사용하도록 컴파일하면 <code class=\"language-text\">index.ts</code>가 어떻게 변경되는지, 그리고 각 모듈 시스템의 특징이 무엇인지 살펴보도록 하자.</p>\n<h3 id=\"commonjs\" style=\"position:relative;\">CommonJS<a href=\"#commonjs\" aria-label=\"commonjs permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span>__esModule <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span>add2 <span class=\"token operator\">=</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> math_1 <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./utils/math\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span>add2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> math_1<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">CommonJS</code>는 Common이라는 이름답게, 자바스크립트 모듈을 브라우저 뿐 아니라 서버 환경이나 데스크탑 어플리케이션 내에서도 자유롭게 사용하는 것을 표방하고 있는 모듈 시스템이다.</p>\n<p>그런 이유로 서버 사이드에서 주로 사용하는 런타임인 NodeJS 같은 경우에는 아직까지 CommonJS 시스템을 사용하고 있는 환경이 많기 때문에 서버 사이드에서 사용할 라이브러리 등을 만든다면 해당 CommonJS 시스템을 사용하는 것을 고민해봐야 한다.</p>\n<p>CommonJS는 <code class=\"language-text\">exports</code> 또는 <code class=\"language-text\">module.exports</code> 객체의 프로퍼티에 모듈을 할당하고, 전역함수 <code class=\"language-text\">require</code>를 통해 동기적으로 모듈을 직접 가져오는 방식을 사용한다. 위 예시에서도 <code class=\"language-text\">math_1</code>이라는 변수에 <code class=\"language-text\">require</code>라는 함수를 통해 모듈을 할당하고, <code class=\"language-text\">exports.add2</code> 프로퍼티에 <code class=\"language-text\">add2</code> 함수를 다시 할당하고 있는 것을 볼 수 있다.</p>\n<p>이렇게 <code class=\"language-text\">require</code> 함수가 실행될 때 동기적으로 모듈을 가져오는 CommonJS의 특징 덕분에 <code class=\"language-text\">if</code> 문을 사용하여 “이럴 땐 A 모듈, 저럴 땐 B 모듈을 가져와!” 같은 짓을 하는 것도 가능하다.</p>\n<h3 id=\"amd\" style=\"position:relative;\">AMD<a href=\"#amd\" aria-label=\"amd permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"require\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"exports\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"./utils/math\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">require<span class=\"token punctuation\">,</span> exports<span class=\"token punctuation\">,</span> math_1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n    exports<span class=\"token punctuation\">.</span>__esModule <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    exports<span class=\"token punctuation\">.</span>add2 <span class=\"token operator\">=</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    exports<span class=\"token punctuation\">.</span>add2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> math_1<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">AMD(Asynchronous Module Definition)</code>는 이름에 걸맞게 비동기적으로 모듈을 가져오는 방식을 사용하는 모듈 시스템이다.</p>\n<p>기존의 CommonJS는 동기적으로 모듈을 가져오는 것을 전제로 개발되었기 때문에 항상 비동기적으로 모듈을 가져오는 방식을 구현하기 위한 활발한 논의가 있었는데, 이 논의 과정 속에서 기존의 CommonJS의 정신인 “모든 환경에서 작동하는 자바스크립트 모듈”에 공감하지 못하는 사람들이 나왔고, 이 사람들이 따로 독립하여 AMD 그룹을 만들게 되었다.</p>\n<p>사실 브라우저 환경은 애초에 서버와 다르게, 필요한 모듈들을 서버로부터 받아와서 사용해야 하는 환경이다. 그렇기 때문에 필요한 모든 모듈을 한번에 받아서 실행하는 것보다 모듈 중에서 필요한 부분만 서버로부터 비동기적으로 가져와서 사용하는 것이 더 효율적인 것이다. 하지만 “모든 환경에서 작동하는 자바스크립트 모듈”을 목표로 하는 CommonJS 그룹에서는 이런 환경 차이를 통합하기가 쉽지 않았다.</p>\n<p>이 과정에서 “브라우저만이라도 제대로 해보자”라는 의견을 가진 사람들이 독립하여 AMD 시스템이 탄생하게 되었고, 그런 이유로 AMD 시스템은 브라우저에서의 비동기 모듈 호출에 초점을 맞추고 개발되었다. <small>(물론 CommonJS도 이후 비동기 모듈 로딩 기능을 따로 추가했다)</small></p>\n<p>하지만 결국 CommonJS에서 떨어져 나온 그룹인만큼 CommonJS와 AMD는 서로 호환할 수 있는 기능들을 많이 제공하고 있기 때문에, 기존의 CommonJS 모듈을 AMD 방식으로 래핑해서 사용하는 등의 응용도 가능하다.</p>\n<p>위 예시에서도 AMD 시스템의 <code class=\"language-text\">define</code> 함수가 기본적으로 CommonJS의 <code class=\"language-text\">require</code>, <code class=\"language-text\">export</code> 함수를 가져와서 사용하고 있는 모습을 볼 수 있다. 기본적으로 내부 구조는 CommonJS와 비슷하지만, <code class=\"language-text\">require</code>함수를 통해 모듈을 가져오는 것이 아니라, <code class=\"language-text\">define</code> 함수의 3번째 인자인 <code class=\"language-text\">math_1</code>을 통해 모듈을 주입받고 있다는 것이 CommonJS 시스템과의 결정적인 차이이다.</p>\n<h3 id=\"umd\" style=\"position:relative;\">UMD<a href=\"#umd\" aria-label=\"umd permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">factory</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> module <span class=\"token operator\">===</span> <span class=\"token string\">\"object\"</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">===</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> v <span class=\"token operator\">=</span> <span class=\"token function\">factory</span><span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">,</span> exports<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> define <span class=\"token operator\">===</span> <span class=\"token string\">\"function\"</span> <span class=\"token operator\">&amp;&amp;</span> define<span class=\"token punctuation\">.</span>amd<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"require\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"exports\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"./utils/math\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> factory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">require<span class=\"token punctuation\">,</span> exports</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n    exports<span class=\"token punctuation\">.</span>__esModule <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    exports<span class=\"token punctuation\">.</span>add2 <span class=\"token operator\">=</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> math_1 <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./utils/math\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    exports<span class=\"token punctuation\">.</span>add2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> math_1<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">UMD(Universal Module Definition)</code>은 모듈 시스템이라기보다 다양한 환경에서 Universal, 즉, 범용으로 사용할 수 있는 형태의 디자인 패턴이라고 볼 수 있다.</p>\n<p>그렇기 때문에 UMD 패턴은 보통 <code class=\"language-text\">RequireJS</code> 같은 라이브러리를 통해 사용하는 AMD나 CommonJS와 다르게, 직접 개발자가 직접 UMD 패턴을 사용한 코드를 작성해줘야 한다. 쉽게 말해 위의 예시처럼 IIFE(Immediately Invoked Function Expression, 즉시실행함수)를 사용하여 개발자가 직접 소스 코드 내에서 분기를 쳐주는 것이 결국 UMD 패턴이라는 것이다.</p>\n<p>위 예시를 보면 <code class=\"language-text\">module</code>과 <code class=\"language-text\">module.exports</code>가 존재한다면 CommonJS 시스템을, <code class=\"language-text\">define</code> 함수가 존재한다면 AMD 시스템을 사용하는 것을 볼 수 있다. 이처럼 UMD 패턴은 모듈이 사용되는 환경이 어떤 모듈 시스템을 사용하는지 여부와 상관없이 항상 동일한 경험을 제공할 수 있다는 장점이 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9a3cbcb2d8922dd1e01e855b408e4af4/22475/all_taken.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 55.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC10lEQVR42k2SSU9TURiGK1opBUpRFBREoy5ETYhKjDGaOEaN08aoCyMhaqIGB9hoxAEBK8YBp1Kwg9iR3tKWFluo4oSgSAMBozaGpYk7/QuP361GXTy55yb3Puf93nM0RX1PKertSTMnHmGWuk7EWNgbYGHMx/xoiNJwmBKhKNhFcTDMXCWEwauQ7e4UfGS7fpMjaAp7/xPGIqzzPqLYaqY8YWNt4iHL4iHKYrJBNMKSaJSybnmGujG6veg8frK9gtP7TzgjHKRAUsyJRyno66HM5+S4uZVLE5/Y9WaAc2NjVI+McHBgkKvjHzk9PELlwHvKXWZKLS3k2DrQq0ldIpVNNAa/n/xQF4VPu5mtCu+1UHfxIq9SXzieTOKanKR+fILDQ+/o//ady6Pj7In3s995h/VnjpDf1IxeCUpKz29hbqcfY0BhpiQtjIbZbGqgreEUV/pitHydpGpwiCqRbU8849S7Qfa9eEW5v4u5dVeYd7IanekW+j8d/hXmSso8RaFASi/pDqOLRDg2/IHUj5/cSn2lJt7HI1sblf2d7I4naJTvNjQ2sfxsLfuvNlDicJKZ7tGNJsfnR0UVGoNB8oIhpvuV9Ijmzyk2979ksRR/2mGn1uOlSrqskfWh2lq2XL/BxkAAvQj1HZ50j2lhrioUSZ4/gFFQT+/E0DAXkmPc/ZTi6NAHHKMTWOS9ZjjJoZ4Y8x62UnLvAfntdrQOd1qoIoeioI6dJ2MbJIlBZDrpY+fzl+ztfcbWrgCbFB/1g28wJUc58vY9B1+8Zqb8o3W6ybI/IcvmQmd3keVwibBTkgk6KTRDZFphmtNHxhMP2sduFjWZONBQx47GenaamimSRBkeH9oOJ1Otj5ki12a63Y1BUuaLXKOmyhTJOhHubjez0uZgjd3KUquDBdZ2tl2uZk3zTVbcvsPq89eouN/GKpudJa0WKtpaqbC0Y7TYKJW7WGzr4BekrCjuRnfpjQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"all taken\" title=\"\" src=\"/static/9a3cbcb2d8922dd1e01e855b408e4af4/6af66/all_taken.png\" srcset=\"/static/9a3cbcb2d8922dd1e01e855b408e4af4/69538/all_taken.png 160w,\n/static/9a3cbcb2d8922dd1e01e855b408e4af4/72799/all_taken.png 320w,\n/static/9a3cbcb2d8922dd1e01e855b408e4af4/6af66/all_taken.png 640w,\n/static/9a3cbcb2d8922dd1e01e855b408e4af4/d9199/all_taken.png 960w,\n/static/9a3cbcb2d8922dd1e01e855b408e4af4/22475/all_taken.png 1039w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>UMD === 뭘 좋아할 지 몰라서 모든 모듈 시스템을 다 준비했어</small>\n</center>\n<p>추가적으로, 모듈을 사용하는 환경이 CommonJS, AMD 두 시스템 모두 지원하지 않는 경우에는 UMD 패턴을 사용하여 전역 객체인 <code class=\"language-text\">globalThis</code>, <code class=\"language-text\">window</code>, <code class=\"language-text\">global</code> 등의 프로퍼티로 모듈을 넣는 최후의 방법도 있기는 하다.</p>\n<p>하지만 이 방법은 전역 스코프를 오염시키기 때문에 가급적이면 피하는 것이 좋기도 하고, 최근의 자바스크립트 런타임 환경에서 모듈 시스템 자체가 지원되지 않는 환경이 강제되는 경우는 흔치 않으므로 타입스크립트는 이런 방법까지는 사용하지 않는 것으로 보인다.</p>\n<h3 id=\"system\" style=\"position:relative;\">System<a href=\"#system\" aria-label=\"system permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">System<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"./utils/math\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">exports_1<span class=\"token punctuation\">,</span> context_1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> math_1<span class=\"token punctuation\">,</span> add2<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> __moduleName <span class=\"token operator\">=</span> context_1 <span class=\"token operator\">&amp;&amp;</span> context_1<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token literal-property property\">setters</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n            <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">math_1_1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                math_1 <span class=\"token operator\">=</span> math_1_1<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        <span class=\"token function-variable function\">execute</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">exports_1</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"add2\"</span><span class=\"token punctuation\">,</span> add2 <span class=\"token operator\">=</span> math_1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>UMD 패턴이 “네가 뭘 좋아할 지 몰라서 다 준비했어”의 디자인 패턴 버전이라면, <code class=\"language-text\">SystemJS</code>는 이걸 라이브러리로 구현한 모듈 로더이다. <small>(한 술 더 떴다)</small></p>\n<p>즉, SystemJS는 모듈 로더이기 때문에 모듈을 어떻게 정의하는지에 대한 것은 관여하지 않고, 그저 이미 CommonJS, AMD, ESM 방식으로 정의된 모듈을 로드해주기만 하는 녀석이다.</p>\n<p>SystemJS는 2016년 ECMA 재단이 ES6의 공식 모듈 스펙으로 <code class=\"language-text\">import</code>, <code class=\"language-text\">export</code> 키워드를 사용하는 ESM 패턴을 발표했을 때 즈음 꽤나 많이 사용되던 녀석인데, 그 이유는 이 당시 브라우저들이 이 스펙을 지원하지 않았기 때문이다.</p>\n<p>모듈링에 대한 공식 스펙은 정해졌으나 정작 그걸 실행시킬 브라우저 벤더들의 대응이 늦는 상황이라 ESM을 사용하고 싶어도 할 수가 없는 상황이었는데, 이때 SystemJS가 이 중간 다리 역할을 해줬었다. 당시에는 <a href=\"https://github.com/ModuleLoader/es-module-loader\" target=\"_blank\" rel=\"nofollow\">es-module-loader</a>라는 폴리필을 사용하여 ESM 방식의 모듈을 불러오도록 구현되어있었다.</p>\n<p>그런데 여기서 한 가지 의문이 드는 것이 “브라우저가 지원하지 않는 모듈을 불러와도 트랜스파일링을 하지 않으면 실행을 시킬 수 없는 경우도 있을텐데, SystemJS는 이 문제를 어떻게 해결하는 걸까?”라는 것인데, 정답은 의외로 가까운 곳에 있었다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/934e6cd11f70c175f5171121f4db2f65/47311/cool.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 62.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABAACBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB56Spyjs0/wD/xAAZEAEBAAMBAAAAAAAAAAAAAAABAgADEUL/2gAIAQEAAQUCjrIGbBb8VHJOuf/EABgRAAIDAAAAAAAAAAAAAAAAAAABESEx/9oACAEDAQE/AVTk0//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAECAQE/AYf/xAAZEAACAwEAAAAAAAAAAAAAAAAAAQIRITH/2gAIAQEABj8Ct2YOiCHrOn//xAAYEAADAQEAAAAAAAAAAAAAAAABESEAMf/aAAgBAQABPyGnEOXAlvy4sBMDcyKrzDMHBp5B5//aAAwDAQACAAMAAAAQj/8A/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEhMf/aAAgBAwEBPxC4NaP/xAAXEQADAQAAAAAAAAAAAAAAAAAAASEx/9oACAECAQE/EKUMh//EAB0QAQEAAgEFAAAAAAAAAAAAABEBACExUWFxgZH/2gAIAQEAAT8QEYDaY9sW2mi1n25ZldIzxkYiAAnnD+oHA9cvhnpz/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"cool\" title=\"\" src=\"/static/934e6cd11f70c175f5171121f4db2f65/c08c5/cool.jpg\" srcset=\"/static/934e6cd11f70c175f5171121f4db2f65/0913d/cool.jpg 160w,\n/static/934e6cd11f70c175f5171121f4db2f65/cb69c/cool.jpg 320w,\n/static/934e6cd11f70c175f5171121f4db2f65/c08c5/cool.jpg 640w,\n/static/934e6cd11f70c175f5171121f4db2f65/6a068/cool.jpg 960w,\n/static/934e6cd11f70c175f5171121f4db2f65/47311/cool.jpg 1080w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>복잡한 건 잘 모르겠고, 그냥 babel 가져와서 런타임에 쿨하게 트랜스파일링 돌리자</small>\n</center>\n<p>그렇다. 이 방법을 쓰면 불러올 대상 모듈의 언어가 ES2020나 타입스크립트라도 아무 문제가 없고, 모듈 시스템으로 CommonJS를 사용하던 AMD를 사용하던 아무 문제가 없다. 물론 이 기능은 SystemJS의 기본 기능이 아니라서 <a href=\"https://github.com/systemjs/systemjs-babel\" target=\"_blank\" rel=\"nofollow\">systemjs-babel</a>이라는 익스텐션을 사용해야 하지만, 문제 해결 방식 자체가 상당히 화끈한 것이 인상적이다.</p>\n<p>하지만 런타임에 모듈을 트랜스파일링한다는 것은 단순히 트랜스파일링만의 문제가 아니라 모듈 간의 의존관계도 파악해야하고, 심지어 타입스크립트를 사용하는 경우에는 정적 타입 체크를 거친 컴파일까지 해야하기 때문에, 당연히 빌드 타임에 이런 무거운 작업을 수행해버리면 퍼포먼스가 떨어질 수 밖에 없다.</p>\n<p>2021년 현재, 모두가 알다시피 이런 무거운 작업들은 모두 빌드 타임에 진행해도 아무 문제가 없으니, 굳이 런타임에 이런 짓을 벌이는 SystemJS는 특수한 상황이 아니면 쓰이지 않는 분위기인 것 같다.</p>\n<h3 id=\"es-module\" style=\"position:relative;\">ES Module<a href=\"#es-module\" aria-label=\"es module permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> add <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./utils/math'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">var</span> add2 <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">ESM(ES Module)</code> 방식은 ECMA 재단에서 공식으로 정의한 자바스크립트 생태계의 모듈 시스템이다.</p>\n<p>그런 이유로 <code class=\"language-text\">require</code>나 <code class=\"language-text\">define</code> 같은 별도의 함수에 의존하여 모듈을 불러오는 CommonJS나 AMD와 다르게 <code class=\"language-text\">import</code>, <code class=\"language-text\">export</code>라는 키워드를 사용하여 모듈을 불러오는 것을 볼 수 있다.</p>\n<p>2015년에 등장한 ESM은 2009년부터 사용하던 CommonJS나 AMD에 비하면 후발 주자인 주제에, 모듈에 <code class=\"language-text\">use strict</code> 디렉티브가 반드시 포함되어야 한다던가, <code class=\"language-text\">this</code>가 전역 객체인 <code class=\"language-text\">window</code>를 바라보지 않는 등의 변경 사항이 많았던 스펙이기도 했다.</p>\n<p>그래서 이런 제약이 없는 CommonJS나 AMD 시스템을 사용하던 어플리케이션들이 손쉽게 마이그레이션을 할 수 있는 상황이 아니였고, 그 상황이 지금까지도 이어져오고 있다.</p>\n<p>그런 이유로 오늘 날에도 네이티브 자바스크립트 환경에서 ESM을 사용하기 위해서 <code class=\"language-text\">script</code> 태그에 <code class=\"language-text\">type=\"module\"</code> 속성을 추가하거나, <code class=\"language-text\">package.json</code>에 <code class=\"language-text\">\"type\": \"module\"</code>이라는 필드를 추가해줘야 하는 등 별도의 작업이 필요한 것이다.</p>\n<p>물론 예전에 비하면 최근 많은 벤더들이 ESM을 지원하고 있지만, 그래도 아직까지 ESM을 안전하게 사용하기 위해서는 Webpack이나 Babel같은 번들러와 트랜스파일러를 조합하여 빌드 타임에 모듈 간의 의존 관계를 파악하고 런타임이 알아들을 수 있는 형태로 변환해주는 과정이 필요하기 때문에, 모듈을 사용하는 환경이 어떤 환경인지에 따라서 때로는 사용하기 번거로운 포맷이 될 수 있다는 것을 염두에 두어야 한다.</p>\n<p>다만 ESM은 이런 단점을 모두 씹어먹을 수 있을 정도의 한 가지 장점을 가지고 있는데, 바로 Webpack으로 모듈을 번들링할 때 트리쉐이킹이 수월하다는 것이다.</p>\n<p>Webpack의 <a href=\"https://webpack.js.org/plugins/module-concatenation-plugin/\" target=\"_blank\" rel=\"nofollow\">ModuleConcatenationPlugin</a>은 모듈들을 하나의 클로저로 통합하여 브라우저 환경에서 더 높은 퍼포먼스를 만들어내는데, 이때 CommonJS와 ESM 중 어떤 모듈 시스템을 사용하냐에 따라 결과물이 많이 달라지게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// CommonJS</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">/* harmony import */</span> <span class=\"token keyword\">var</span> _utils__WEBPACK_IMPORTED_MODULE_0__ <span class=\"token operator\">=</span> <span class=\"token function\">__webpack_require__</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> add2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>_utils__WEBPACK_IMPORTED_MODULE_0__<span class=\"token comment\">/* .add */</span> <span class=\"token punctuation\">.</span><span class=\"token constant\">DG</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Webpack을 통해 번들링 했을 때 CommonJS 시스템을 사용한 모듈은  <code class=\"language-text\">__webpack_require__</code>라는 함수를 통해 불러와지게 되는데, 문제는 이게 모듈 내부에 있는 <code class=\"language-text\">add</code> 함수만 불러오는 것이 아니라 전체 모듈을 다 불러오는 코드라는 것이다.</p>\n<p>다음 라인인 <code class=\"language-text\">(0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .add */ .DG)</code>를 보면, 불러온 모듈의 <code class=\"language-text\">DG</code>라는 프로퍼티에 접근하고 있는 것을 볼 수 있는데, 이 <code class=\"language-text\">DG</code>가 난독화된 <code class=\"language-text\">add</code> 함수의 이름이다.</p>\n<p>애초에 CommonJS는 <code class=\"language-text\">exports</code>라는 전역 객체의 프로퍼티에 값들을 할당하는 방식을 사용하기 때문에, “이 모듈에서 A라는 함수만 사용한다”라는 것을 파악하기가 쉽지가 않은 것이다.</p>\n<p>하지만 ESM 시스템을 사용한 모듈은 각각의 <code class=\"language-text\">export</code> 키워드를 사용하여 원하는 값을 따로 내보낼 수 있고, 그로 인해 상세한 의존 관계를 파악하기가 한결 수월하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// ESM</span>\n\n<span class=\"token comment\">/******/</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// webpackBootstrap</span>\n<span class=\"token comment\">/******/</span>    <span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// CONCATENATED MODULE: ./utils/math.js**</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// CONCATENATED MODULE: ./index.js**</span>\n<span class=\"token keyword\">var</span> add2 <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/******/</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Webpack을 통해 번들링한 ESM 시스템의 모듈을 보면, 애초에 모듈을 불러오는 코드 자체가 없고 심지어 모듈 내부에 있던 함수를 인라인으로 박아버렸다.</p>\n<p>물론 필자가 불러온 <code class=\"language-text\">add</code> 함수는 매우 작은 함수라 이런 식으로 표현될 수 있는 것이기는 하지만, 중요한 점은 모듈 내부에 있는 “특정 함수”만 가져왔다는 것이다.</p>\n<p>앞서 이야기 했듯이 ESM은 <code class=\"language-text\">import</code>, <code class=\"language-text\">export</code> 키워드를 통한 상세 의존 관계 파악이 쉬운 편이기 때문에 빌드 타임에 효율적으로 사용하는 코드와 사용하지 않는 코드를 발라내는 것이 가능하다.</p>\n<p>이렇게 트리쉐이킹이 쉽다는 강력한 이유 때문에 <del>Lodash를 제외한</del> 유명한 라이브러리들은 대부분 ESM 방식을 공식적으로 지원하고 있다.</p>\n<h2 id=\"moduleresolution\" style=\"position:relative;\">moduleResolution<a href=\"#moduleresolution\" aria-label=\"moduleresolution permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">Node</code></td>\n<td>Node 전략을 사용하여 모듈을 탐색한다. <code class=\"language-text\">module</code> 옵션이 CommonJS일 때 Default.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Classic</code></td>\n<td>Classic 전략을 사용하여 모듈을 탐색한다. <code class=\"language-text\">module</code> 옵션이 CommonJS가 아닐 때 Default.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">moduleResolution</code> 옵션은 타입스크립트가 모듈을 불러올 때 이 모듈이 정확히 무엇을 참조하는 지를 확인하는 프로세스를 다루는 옵션이다. 이건 그냥 말로 설명하면 너무 어려우니 직접 코드를 보면서 알아보도록 하자.</p>\n<p>우선 타입스크립트는 크게 상대 경로와 절대 경로, 2가지 방법을 사용하여 모듈의 경로를 정의하는 방법을 사용하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> add <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./utils/math'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 상대 경로</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> debounce <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'lodash'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 절대 경로</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>상대 경로의 경우에는 현재 위치를 나타내는 <code class=\"language-text\">.</code>이나 상위 디렉토리를 나타내는 <code class=\"language-text\">..</code> 등의 식별자를 사용하여 탐색을 위한 기점을 지정함으로써 정확한 모듈의 위치를 나타낼 수 있는 반면, 절대 경로의 경우에는 단순히 모듈의 이름만 적고 있기 때문에 정확한 모듈의 위치를 찾기 위해서 특정한 규칙을 기반으로 모듈을 찾아나서는 여행을 떠나야 한다.</p>\n<p>또한 상대 경로, 절대 경로 두 방법 모두 모듈의 확장자까지는 적고 있지 않기 때문에, 이 모듈이 <code class=\"language-text\">math.ts</code>, <code class=\"language-text\">math.d.ts</code> 등 어떤 확장자를 가지고 있는 파일인지도 알아내어야 한다.</p>\n<p>그렇기 때문에 타입스크립트는 모듈의 정확한 위치를 찾아내는 전략을 세워야 하는데, 이때 <code class=\"language-text\">moduleResolution</code> 옵션으로 Classic과 Node 중 어떤 전략을 사용할 것인지를 선택할 수 있는 것이다.</p>\n<p>사실 두 전략 모두 모듈의 위치를 찾는 기본적인 방법 자체는 크게 다르지 않다.</p>\n<p>만약 <code class=\"language-text\">import { add } from './math'</code>와 같이 상대 경로를 사용한 모듈을 찾을 때는 찾아 볼 디렉토리가 명확하기 때문에 해당 디렉토리 내에서만 파일을 찾아보고, <code class=\"language-text\">import { add } from 'math'</code>와 같이 절대 경로를 사용한 모듈을 찾을 때는 찾아야 할 디렉토리가 명확하지 않으니, 우선 해당 모듈을 불러온 파일이 위치한 디렉토리부터 뒤져보고, 없다면 한 단계 상위 디렉토리로, 그래도 없다면 또 한 단계 상위 디렉토리로 거슬러 올라가는 방식으로 모듈을 찾는다.</p>\n<p>이때 찾고자 하는 파일의 확장자가 무엇인지, 그리고 모듈을 찾을 때 어디를 먼저 찾아보는지에 따라서 Classic 전략과 Node 전략 간의 차이가 발생한다.</p>\n<h3 id=\"classic\" style=\"position:relative;\">Classic<a href=\"#classic\" aria-label=\"classic permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Classic</code> 전략은 사실 상 타입스크립트의 기본 모듈 탐색 전략으로, 예전부터 사용하던 전략이기도 해서 하위 버전의 타입스크립트과의 호환성을 맞출 때에도 사용한다.</p>\n<p>Classic 전략은 상대 경로를 사용하여 불러온 모듈을 찾을 때, 해당 모듈을 불러오는 모듈의 위치를 기점으로 <code class=\"language-text\">*.ts</code>, <code class=\"language-text\">*.d.ts</code>의 순서로 탐색을 시작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// /root/src/index.ts</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> add <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./math'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<blockquote>\n<ol>\n<li>\n<p><code class=\"language-text\">/root/src/math.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/math.d.ts</code></p>\n</li>\n</ol>\n</blockquote>\n<p>앞서 이야기 했듯이 상대 경로를 사용한 경우에는 찾아봐야 하는 디렉토리의 위치가 명확하기 때문에 후보가 되는 확장자만 탐색을 진행한 후, 해당 모듈이 없는 경우 탐색을 종료하게 된다.</p>\n<p>반면 <code class=\"language-text\">import { add } from 'math'</code>와 같이 절대 경로를 사용한 모듈의 경우에는 현재 모듈을 불러온 경로부터 시작해서 한 단계씩 부모 디렉토리로 거슬러 올라가면서 탐색을 진행하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// /root/src/index.ts</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> add <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'math'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<blockquote>\n<ol>\n<li>\n<p><code class=\"language-text\">/root/src/math.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/math.d.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/math.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/math.d.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/math.ts</code></p>\n</li>\n</ol>\n</blockquote>\n<p>절대 경로를 사용한 경우, 가장 처음으로 모듈을 불러온 파일이 위치한 <code class=\"language-text\">/root/src</code>에서부터 탐색을 시작한다. 이후 이 디렉토리에서 모듈을 찾지 못 하면 한 단계 씩 거슬러 올라가며 다시 탐색을 진행하고, 루트까지 탐색했는데도 해당 모듈이 없는 경우 탐색을 종료하게 된다.</p>\n<h3 id=\"node\" style=\"position:relative;\">Node<a href=\"#node\" aria-label=\"node permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Node</code> 전략은 이름 그대로 NodeJS가 모듈을 찾는 방식을 그대로 모방하는 전략이며, Node 전략은 Classic 전략과 다르게 <code class=\"language-text\">*.ts</code>나 <code class=\"language-text\">*.d.ts</code> 확장자를 탐색하는 것을 넘어서서 조금 더 다양한 형태의 모듈까지 탐색을 한다.</p>\n<p>상대 경로를 사용한 경우는 Classic 전략과 비슷하게, 지정된 디렉토리 내부에서 다음과 같은 순서로 파일을 탐색하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// /root/src/index.ts</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> add <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./math'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<blockquote>\n<ol>\n<li>\n<p><code class=\"language-text\">/root/src/math.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/math.tsx</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/math.d.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/math/package.json</code> (<code class=\"language-text\">types</code> 필드를 사용하는 경우에 한해)</p>\n</li>\n<li>\n<p><code class=\"language-text\">root/src/math/index.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">root/src/math/index.tsx</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">root/src/math/index.d.ts</code></p>\n</li>\n</ol>\n</blockquote>\n<p>뭔가 많이 추가된 것 같지만, 기본적으로는 Classic 전략과 마찬가지로 지정된 디렉토리 내부의 파일을 찾되, <code class=\"language-text\">*.tsx</code> 확장자를 가진 모듈과 <code class=\"language-text\">package.json</code> 내부의 <code class=\"language-text\">types</code> 속성, 그리고 모듈 이름과 동일한 디렉토리의 <code class=\"language-text\">index.*</code> 파일을 추가로 탐색할 뿐이다.</p>\n<p>이처럼 상대 경로를 사용한 모듈을 탐색할 때는 Node 전략과 Classic 전략 모두 비슷한 순서로 디렉토리 트리를 탐색하지만, 절대 경로로 지정된 모듈을 찾을 때는 차이가 커진다.</p>\n<p>왜냐하면 Node 전략은 Classic과 다르게, 절대 경로를 사용한 모듈을 찾을 때는 <code class=\"language-text\">node_modules</code> 디렉토리를 탐색하기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// /root/src/index.ts</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> add <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'math'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<blockquote>\n<ol>\n<li>\n<p><code class=\"language-text\">/root/src/node_modules/math.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/node_modules/math.tsx</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/node_modules/math.d.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/node_modules/math/package.json</code> (<code class=\"language-text\">types</code> 필드를 사용하는 경우에 한해)</p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/node_modules/@types/math.d.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/node_modules/math/index.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/node_modules/math/index.tsx</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/src/node_modules/math/index.d.ts</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">/root/node_modules/math.ts</code> (부모 디렉토리로 이동 후 반복)</p>\n</li>\n</ol>\n<p>…</p>\n</blockquote>\n<p>Node 전략을 사용하게 되면 가장 먼저 <code class=\"language-text\">math</code> 모듈을 호출한 파일이 위치한 <code class=\"language-text\">/root/src</code> 디렉토리에 있는 <code class=\"language-text\">node_modules</code> 디렉토리에서 탐색을 진행한다.</p>\n<p>이때 상대 경로에서와 동일하게 <code class=\"language-text\">*.ts</code>, <code class=\"language-text\">*.tsx</code>, <code class=\"language-text\">*.d.ts</code> 파일과 <code class=\"language-text\">package.json</code>의 <code class=\"language-text\">types</code> 필드를 찾아보며, 그 이후에는 <code class=\"language-text\">@types</code> 디렉토리와 모듈 이름과 동일한 이름을 가진 디렉토리 밑에 있는 <code class=\"language-text\">index</code> 파일을 탐색한다.</p>\n<p>이렇게 한 번의 탐색 과정이 끝나도 원하는 모듈을 찾지 못했다면, 부모 디렉토리로 이동한 후 이 과정을 다시 반복한다. 그 후 루트에 도달하여 로컬 머신에 전역 설치된 모듈이 있는지까지 탐색했는데도 해당 모듈이 없다면 탐색을 종료하게 된다.</p>\n<p>이러한 탐색 과정은 NodeJS가 모듈을 찾는 과정과 동일하지는 않지만, 매우 비슷하다. NodeJS는 먼저 모듈과 동일한 이름의 파일을 찾은 후, <code class=\"language-text\">package.json</code>의 <code class=\"language-text\">main</code> 필드에 적힌 경로의 파일을 찾아 보고, 마지막으로 모듈과 동일한 디렉토리 밑에 있는 <code class=\"language-text\">index</code> 파일을 탐색하는데, 타입스크립트의 Node 전략이 바로 이 탐색 과정을 모방한 것이기 때문이다.</p>\n<p>타입스크립트 공홈에는 NodeJS가 사용하는 방식과 비교해서 크게 복잡하지 않으니 걱정말라고 하지만, 사실 애초에 NodeJS가 사용하고 있는 패키지 탐색 방식 자체가 비효율적이기는 하다. 그런 이유로 타입스크립트 4.0 버전부터는 불러오지 않은 모듈에 대해서는 더 이상 위와 같은 과정을 통해 타입 정보를 찾지 않도록 업데이트가 되었다.</p>\n<h2 id=\"noresolve\" style=\"position:relative;\">noResolve<a href=\"#noresolve\" aria-label=\"noresolve permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>어플리케이션에 포함된 모든 모듈을 해석한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>명시적으로 어플리케이션에 포함하기로한 모듈만 해석한다.</td>\n</tr>\n</tbody>\n</table>\n<p>기본적으로 타입스크립트 컴파일러는 어플리케이션에 포함된 모든 모듈을 컴파일하려고 시도한다. 즉, tsconfig 루트의 <a href=\"/2021/07/30/tsconfig-options-root-fields/#include\">include</a>나 <a href=\"/2021/07/30/tsconfig-options-root-fields/#files\">files</a> 필드에 포함하지 않은 파일이라고 해도, 어플리케이션 내에서 직접 <code class=\"language-text\">import</code> 문이나 <code class=\"language-text\">/// &lt;reference path=\"...\" /></code> 같은 디렉티브를 사용하여 모듈을 불러왔다면, 그 모듈 또한 컴파일 대상이라는 것이다.</p>\n<p>어찌보면 암시적으로 모듈을 컴파일 대상에 포함시킨다는 이야기인데, 이때 <code class=\"language-text\">noResolve</code> 옵션을 <code class=\"language-text\">true</code>로 설정하면 이런 암시적인 모듈 컴파일을 막을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"include\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"src/index.ts\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"outDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"noResolve\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// src/index.ts</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> add <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./utils/math'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> add2 <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시의 <code class=\"language-text\">include</code> 필드에는 <code class=\"language-text\">src/index.ts</code>만 포함되어 있고, <code class=\"language-text\">utils/math</code> 모듈은 포함되어있지 않다.</p>\n<p>이런 경우일 때 <code class=\"language-text\">noResolve</code> 옵션의 값이 <code class=\"language-text\">false</code>라면 <code class=\"language-text\">index.ts</code>에서 사용하는 <code class=\"language-text\">utils/math</code> 모듈도 아무 문제 없이 컴파일되지만, <code class=\"language-text\">true</code>인 경우에는 해당 모듈을 찾을 수 없다는 에러가 발생하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">src/index.ts:1:21 - error TS2307: Cannot find module './utils/math' or its corresponding type declarations.\n\n1 import { add } from './utils/math';</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>즉, 반드시 명시적으로 <code class=\"language-text\">include</code>나 <code class=\"language-text\">files</code> 필드에 선언된 모듈들만 컴파일을 하고 있는 것이다. 이와 마찬가지 이유로 <code class=\"language-text\">/// &lt;reference path=\"...\" /></code> 같이 디렉티브를 사용하여 불러온 모듈들도 해당 필드에 포함되어 있지 않기 때문에 컴파일 대상에서 제외된다.</p>\n<p><code class=\"language-text\">noResolve</code> 옵션은 개발자가 타입스크립트의 컴파일 대상을 명시적으로 선언하게 만듦으로써 수월한 모듈 관리를 도와주기는 하지만, 디렉티브를 사용하여 불러온 모듈까지 컴파일 대상에서 제외한다는 특성 때문에 디렉티브를 사용하여 타입 정의 파일을 불러오는 NextJS 같은 라이브러리를 사용하고 있는 상황에서는 그냥 기본 값인 <code class=\"language-text\">false</code>로 사용하는 것이 정신 건강에 이롭다.</p>\n<h2 id=\"resolvejsonmodule\" style=\"position:relative;\">resolveJsonModule<a href=\"#resolvejsonmodule\" aria-label=\"resolvejsonmodule permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td><code class=\"language-text\">*.json</code> 확장자로 끝나는 모듈의 import를 허용하지 않는다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">*.json</code> 확장자로 끝나는 모듈의 import를 허용한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">resolveJsonModule</code> 옵션은 이름 그대로 JSON 파일로 구현된 모듈을 끌어다 쓸 수 있게 허용할 것인지에 대한 여부를 결정한다.</p>\n<p>만약 해당 옵션이 <code class=\"language-text\">false</code>라면, JSON 모듈을 가져왔을 때 타입스크립트는 해당 모듈을 찾을 수 없다는 에러를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// me.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"evan-moon\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"age\"</span><span class=\"token operator\">:</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"role\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Frontend Engineer\"</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> me <span class=\"token keyword\">from</span> <span class=\"token string\">'./me.json'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Cannot find module './settings.json'. Consider using '--resolveJsonModule' to import module with '.json' extension.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">resolveJsonModule</code> 옵션을 켜게 되면 일반적인 타입스크립트 모듈과 동일하게 JSON 모듈을 가져와서 사용할 수 있게 되고, 심지어 해당 파일을 분석하여 자동으로 타입 추론까지 해준다.</p>\n<p>하지만 이 경우 당연히 Enum이나 Union Type을 사용한 추론은 불가능하기 때문에 모든 값들은 <code class=\"language-text\">string</code>이나 <code class=\"language-text\">number</code> 등의 원시 타입으로 추론된다. 그러니 만약 강력한 타입 선언을 강제해야하는 경우라면 JSON 모듈이 아니라 타입스크립트 모듈을 사용하여 모델을 선언해주는 것이 좋다.</p>\n<h2 id=\"rootdir\" style=\"position:relative;\">rootDir<a href=\"#rootdir\" aria-label=\"rootdir permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">rootDir</code> 옵션은 모듈을 컴파일 한 이후 어떤 디렉토리를 루트로 하여 현재 구조를 유지할 것 인지를 결정한다.</p>\n<p>기본적으로 타입스크립트는 컴파일을 수행할 때 입력된 디렉토리의 구조를 그대로 유지하며 컴파일된 파일들을 출력하는데, 이때 <code class=\"language-text\">rootDir</code> 옵션을 사용하여 어떤 디렉토리를 루트로 설정할 것인지를 정하는 것이다.</p>\n<p>만약 이 옵션을 따로 설정하지 않는다면, 타입스크립트는 자동으로 해당 모듈의 엔트리 포인트가 되는 파일을 찾고, 해당 파일이 위치한 디렉토리를 루트로 설정하여 출력 디렉토리 구조를 설정하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">myProject\n├── src\n│   ├── index.ts\n│   └── utils\n│       └── math.ts\n└── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"outDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위와 같은 구조의 프로젝트가 있다고 생각해보자. <code class=\"language-text\">rootDir</code> 옵션이 주어지지 않았을 때의 타입스크립트는 이 어플리케이션의 엔트리 포인트인 <code class=\"language-text\">src/index.ts</code>를 찾아내고, 이 파일의 위치인 <code class=\"language-text\">src</code>를 루트로 인식하게 된다.</p>\n<p>그렇기 때문에 출력 디렉토리는 루트를 <code class=\"language-text\">src</code> 디렉토리로 하는 다음과 같은 구조를 가지게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">dist\n├── index.ts\n└── utils\n    └── math.ts</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그러나 만약 이 상태에서 <code class=\"language-text\">rootDir</code> 옵션을 현재 경로를 의미하는 <code class=\"language-text\">.</code>로 설정하게 되면, 출력 디렉토리의 구조가 변경되게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"outDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"rootDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\".\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">dist\n└── src\n    ├── index.ts\n    └── utils\n        └── math.ts</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>필자가 루트 디렉토리를 현재 <code class=\"language-text\">tsconfig.json</code>이 위치한 <code class=\"language-text\">myProject</code> 디렉토리로 변경했기 때문에, 출력 디렉토리인 <code class=\"language-text\">dist</code>는 기존 프로젝트 디렉토리와 완전히 동일한 구조를 가지게 되고, 이로 인해 디렉토리 내부에 <code class=\"language-text\">src</code> 디렉토리까지 함께 생성된 형태로 출력되게 된다.</p>\n<p>어찌보면 굉장히 간단한 동작이지만, 이 옵션을 사용할 때는 한 가지 주의해야 할 점이 있다. 바로 <code class=\"language-text\">rootDir</code> 옵션은 컴파일 대상에 아무런 영향을 끼치지 않는다는 것이다.</p>\n<p>즉, 만약 <code class=\"language-text\">rootDir</code> 옵션을 사용한다면 모든 컴파일 대상 파일은 해당 디렉토리 밑에 위치해야 한다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">myProject\n├── src\n│   ├── index.ts\n│   └── utils\n│       └── math.ts\n├── foo.ts\n└── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"outDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"rootDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./src\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"include\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"*\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 설정을 살펴보면 루트 디렉토리로 <code class=\"language-text\">src</code> 디렉토리를 설정하고, <code class=\"language-text\">include</code> 옵션을 사용하여 모든 파일을 컴파일 할 것이라고 설정해주었다.</p>\n<p>문제는 이 “모든 파일”의 대상 중 하나인 <code class=\"language-text\">foo.ts</code>는 <code class=\"language-text\">src</code> 디렉토리에 들어가 있지 않은 녀석이라는 것이다. 즉, 설정에 모순이 발생한 것이다.</p>\n<p>이렇게 <code class=\"language-text\">rootDir</code> 옵션으로 루트 디렉토리를 정했다고 해도, 타입스크립트는 자동으로 <code class=\"language-text\">foo.ts</code>를 컴파일 대상에 포함시키지 않고, 이런 에러를 발생시킨다.</p>\n<blockquote>\n<p>File ‘/Users/john/myProject/foo.ts’ is not under ‘rootDir’ ‘/Users/john/myProejct/src’. <strong>‘rootDir’ is expected to contain all source files.</strong></p>\n</blockquote>\n<p>이 에러를 보면 알 수 있듯이, <code class=\"language-text\">rootDir</code> 옵션을 사용하여 루트 디렉토리를 설정했다면 반드시 모든 소스 파일들은 루트 디렉토리 내부에 들어있어야 하며, 만약 <code class=\"language-text\">include</code> 등을 사용하여 루트 디렉토리 밖에 있는 파일을 컴파일 대상으로 지정했다고 해도 자동으로 컴파일 해주거나 하지 않는다.</p>\n<h2 id=\"rootdirs\" style=\"position:relative;\">rootDirs<a href=\"#rootdirs\" aria-label=\"rootdirs permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">rootDirs</code> 옵션은 일종의 가상 루트를 만들어 줄 수 있는 옵션이다. 이 옵션은 말로 설명하기 보다 코드로 보는 것이 훨씬 이해가 편하니, 바로 예시를 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">myProject\n├── core\n│   └── index.ts\n├── utils\n│   └── math.ts\n└── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>만약 이런 구조의 어플리케이션이 있다고 생각해보자. 만약 <code class=\"language-text\">core/index.ts</code>에서 <code class=\"language-text\">utils/math.ts</code> 모듈을 가져오고 싶다면 어떻게 해야할까?</p>\n<p>만약 <code class=\"language-text\">paths</code> 옵션을 사용하지 않았다면, 상대 경로를 사용하여 한 단계 상위 디렉토리로 거슬러 올라가서 해당 모듈에 접근할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// core/index.ts</span>\n<span class=\"token keyword\">import</span> math <span class=\"token keyword\">from</span> <span class=\"token string\">'../utils/math'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">rootDirs</code> 옵션은 이런 상황일 때 가상의 루트를 만들어서, <code class=\"language-text\">core</code> 디렉토리와 <code class=\"language-text\">utils</code> 디렉토리 내부에 있는 모듈들이 마치 “하나의 디렉토리” 내부에 있는 것처럼 사용할 수 있도록 만들어준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"outDir\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"rootDirs\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"core\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"utils\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// core/index.ts</span>\n<span class=\"token keyword\">import</span> math <span class=\"token keyword\">from</span> <span class=\"token string\">'./utils/math'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 마치 같은 디렉토리에 있는 것처럼 사용한다</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>만약 <code class=\"language-text\">core/components/Foo/index.tsx</code>와 같이 디렉토리 깊이가 깊다고 해도 <code class=\"language-text\">rootDirs</code>에 해당 디렉토리를 등록하게 되면, <code class=\"language-text\">rootDirs</code>에 등록된 디렉토리 끼리는 항상 같은 디렉토리에 있는 것처럼 모듈을 불러올 수 있다.</p>\n<p>그리고 <code class=\"language-text\">rootDirs</code> 옵션은 일종의 “가상 디렉토리”를 만들어서 이런 기능을 구현하는 방식을 사용하기 때문에, 컴파일한 이후의 출력 디렉토리 구조에는 전혀 영향을 주지 않는다. 말 그대로 가상이다.</p>\n<p>이처럼 <code class=\"language-text\">rootDirs</code> 옵션은 디렉토리의 깊이가 깊은 상황에도 간단하게 상대 경로를 사용할 수 있도록 만들어 주기 때문에 어찌 보면 편하다고 생각할 수도 있다.</p>\n<p>하지만 이런 설정을 사용하게 되면 실제 디렉토리 구조와 코드에서 모듈에 접근하기 위해 사용하는 경로 간의 괴리가 발생하게 됨으로써 직관적인 이해가 어려운 코드가 될 수도 있으며, 심지어 이 괴리의 원인을 확인하기 위해서는 <code class=\"language-text\">tsconfig.json</code>을 까봐야 하는 슬픈 상황이 발생할 수도 있다는 점을 꼭 염두에 두도록 하자.</p>\n<h2 id=\"typeroots\" style=\"position:relative;\">typeRoots<a href=\"#typeroots\" aria-label=\"typeroots permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>기본적으로 타입스크립트는 <code class=\"language-text\">@types</code> 패키지 디렉토리 밑에 있는 파일들을 자동으로 컴파일 대상으로 포함한다. 이때 앞서 설명했던 <code class=\"language-text\">resolve</code> 전략에 따라 <code class=\"language-text\">./node_modules/@types</code>, <code class=\"language-text\">../node_modules/@types</code> 등 디렉토리를 거슬러 올라가면서 <code class=\"language-text\">node_modules</code> 내부에 있는 <code class=\"language-text\">@types</code> 디렉토리를 탐색하는 것이다.</p>\n<p>하지만 <code class=\"language-text\">typeRoots</code> 옵션을 사용하면 타입스크립트가 찾아 헤매는 타입 파일들이 특정한 곳에 있다고 지정할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"typeRoots\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"./typings\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"./node_modules/@types\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">typeRoots</code> 옵션에 적용하는 경로는 <code class=\"language-text\">tsconfig.json</code> 기준의 상대 경로이다. 또한 위 예시에서는 <code class=\"language-text\">./node_modules/@types</code> 디렉토리를 옵션에 포함시켰지만, 사실 없어도 아무 문제 없다.</p>\n<p>이렇게 <code class=\"language-text\">typeRoots</code>를 지정한 경우, 타입스크립트는 기존의 모듈 탐색 전략을 버리고 배열에 들어있는 경로에서만 타입 선언 모듈들을 찾기 때문에, 계속 부모 디렉토리로 거슬러 올라가며 타입 선언 모듈을 찾는 기존의 모듈 탐색 전략보다 효율적인 탐색 전략을 가져갈 수 있다.</p>\n<h2 id=\"types\" style=\"position:relative;\">types<a href=\"#types\" aria-label=\"types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 설명했듯이 타입스크립트는 <code class=\"language-text\">@types</code> 패키지 디렉토리 밑에 있는 모든 파일들을 자동으로 컴파일 대상으로 포함하고, 이 과정에서 타입 선언을 전역 스코프에 뿌려버린다.</p>\n<p>이 타입 선언이 전역 스코프에 존재하기 때문에 우리가 <code class=\"language-text\">@types/node</code> 같은 모듈 내부에 포함된 <code class=\"language-text\">process</code> 객체 같은 녀석들을 별도의 타입 선언 없이도 사용할 수 있는 것이다.</p>\n<p>하지만 <code class=\"language-text\">types</code> 옵션을 사용하면, 특정한 패키지들의 타입만 전역 스코프에 포함시킬 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// @types/node, @types/jest, @types/express만 가져온다</span>\n    <span class=\"token property\">\"types\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"jest\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"express\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위와 같이 설정할 경우, <code class=\"language-text\">node</code>, <code class=\"language-text\">jest</code>, <code class=\"language-text\">express</code> 패키지의 타입은 전역 스코프에 포함되어 <code class=\"language-text\">import express from 'express';</code>라는 구문만 적어도 자동으로 타입 평가가 진행되지만, 여기에 포함되지 않은 다른 라이브러리들은 직접 타입 선언 모듈을 가져와야 한다.</p>\n<p>여기서 주의해야할 점은 <code class=\"language-text\">types</code> 옵션의 대상 자체가 애초에 <code class=\"language-text\">@types</code> 패키지 디렉토리 내부에 존재하는 타입 선언 모듈들이라는 것이다.</p>\n<p>예를 들어 날짜 관련 라이브러리인 <code class=\"language-text\">moment</code>는 <code class=\"language-text\">@types/moment</code> 같은 타입 패키지를 추가적으로 설치하지 않고, 자체적으로 내장하고 있는 타입 선언 모듈을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"moment\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// ...</span>\n    <span class=\"token property\">\"main\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./moment.js\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"jsnext:main\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./dist/moment.js\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"typings\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./moment.d.ts\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// 자체적으로 타입 선언 파일을 포함하고 있다</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이런 경우는 <code class=\"language-text\">import moment from 'moment'</code> 구문으로 이 라이브러리를 가져옴과 동시에 <code class=\"language-text\">moment.d.ts</code>도 자동으로 컴파일 대상으로 포함되므로, 당연히 제대로 타입을 사용할 수 있다.</p>\n<p>즉, <code class=\"language-text\">types</code> 옵션의 대상은 어디까지나 <code class=\"language-text\">@types/*</code> 패키지 내부에 포함된 타입 선언 모듈이고, 타입스크립트가 해당 타입 선언 모듈을 전역 공간에 뿌리는 경우에만 해당된다는 점을 헷갈리지 말자.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇게 <code class=\"language-text\">tsconfig</code> 3번째 시리즈인 <code class=\"language-text\">Modules</code> 편을 마무리 했다. 모듈과 관련된 옵션들의 개수 자체는 많지 않지만, 아무래도 컴파일 과정에서 어떤 모듈 시스템을 사용할 지, 어떤 모듈 탐색 전략을 사용할 지 등을 다루는 옵션이다보니 부연 설명이 길어진 것 같다.</p>\n<p>그리고 여기까지 적고 나서 새삼스럽게 드는 생각은…</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2f03c5fd1831cbdc146edbf1130bd061/00d43/tsconfig.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 94.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAAC1UlEQVR42oVTZ1PbQBTU//8vhJrQMcaUDKGXTBKKcbflpi5Zstnsni1iEmbyYefda/v2nk5WEIXo9HuwB320e10EoxhjABlekb5O3tkc8j/EOIMVPj/BvblG+vhgkPz8geD7Pfy7WwT3d/9Y7/YGIfOqzebx8AtprQorPj9DvLmBeHcHCZEV95HuFz6EyRX2kNJmf2NvF+nFOSzv9BT9tVUMtzYRqvjoEEnpwCA+KGJ0WMKoVJr6xSJS+gnj8rPjoz9gPOVNreDsGwKSqWjy9QTR/h5aS0toL09hryyjM4O9sgJ7dYX5RWMDqvJ5K9mRVF5fwUquLzGhKk0ZExFVNhYW0Fz8ZBpFZOzylFTxNn0NU6z3eQ1d3tBZ/4KI4qz46hLZnPwRz5rq7WwbGxYK8GdKTHymKOBgd3sLDuGqljYyOzw5hk92Q6rdsHDIqQPtldbb2IDLvLe5zvO6UTJg3OXZ195JFnFATMLs8oKEzQaSVhOp3TGI6Q/4lIblZzgvZbiVl3foPz0a65TLJh+xPqjXEBIZ37Ll+R6SdIQ0S5FNxvDDAFW+p0argVqjblBlcYXQuVKvokxCod6c1lRYL/iBz4/CP2VCsjFJs1GCgAOaLBLsThv9ro0h/ySH03u8wYB/k9BlTnG73TK5iGTislxniAETQwZTEsYM6uwMB/A9FyELVSN4rmP8sW4jAXNQr2CpSM2yCiRxZFTOQzlZkWmg6kZJ/A5vhCKzeRU1aFLEHUqhVOfKVKNB883/VZhfWYStZhNtfvkO9yObQ369VjO7zVehXlkNNITak0gFkSlhlM0G5evId5j7Dn2JEJTTAKm38sY+v5ysSKWgx6/b5So6PA/600b5dqdj1pHndQ58n33hlFCBuh4mJ7zyHcqKUMV5Q5fN5glxqIhyZVqBrG6lj2UIpUpFUqblBiSsVSvcVdW8xRYfb6/bfXtGOfLnJpvHRPwbAA92vl9EkpcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tsconfig\" title=\"\" src=\"/static/2f03c5fd1831cbdc146edbf1130bd061/6af66/tsconfig.png\" srcset=\"/static/2f03c5fd1831cbdc146edbf1130bd061/69538/tsconfig.png 160w,\n/static/2f03c5fd1831cbdc146edbf1130bd061/72799/tsconfig.png 320w,\n/static/2f03c5fd1831cbdc146edbf1130bd061/6af66/tsconfig.png 640w,\n/static/2f03c5fd1831cbdc146edbf1130bd061/d9199/tsconfig.png 960w,\n/static/2f03c5fd1831cbdc146edbf1130bd061/00d43/tsconfig.png 1000w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>어...? 아직도 여기까지밖에 못 썼다고...?</small>\n</center>\n<p>사실 <code class=\"language-text\">tsconfig</code> 옵션이 많은 줄은 이미 알고 있었지만 이렇게까지 힘들 줄은 상상도 못 했다. <small><del>(글 쓰다가 손목이 아픈 적은 또 처음…)</del></small></p>\n<p>물론 공식 문서를 번역하는 느낌으로 쭉쭉 써내려간다면 금방 끝내겠지만, 애초에 이 포스팅 시리즈를 시작한 것은 그 정도의 정보를 원해서가 아니라 <code class=\"language-text\">tsconfig</code>를 완전 분석해보자는 목적이었으므로 한번 달려보도록 하겠다.</p>\n<p><a href=\"/2021/10/30/tsconfig-compiler-options-modules-emit/\">다음 포스팅</a>에서는 타입스크립트가 출력 파일을 생성할 때의 동작들을 다루는 방법에 대한 옵션들에 대해서 이야기해볼 예정이다.</p>\n<p>이상으로 [tsconfig의 모든 것] Compiler options / Modules 포스팅을 마친다.</p>","fields":{"slug":"20210822-tsconfig-compiler-options-modules","path":"/2021/08/22/tsconfig-compiler-options-modules/","lang":"ko"},"frontmatter":{"title":"[tsconfig의 모든 것] Compiler options / Modules","subTitle":"모듈 해석부터 경로 매핑까지, import 동작을 결정하는 컴파일러 옵션","date":"Aug 22, 2021","categories":["프로그래밍","튜토리얼","자바스크립트"],"tags":["TypeScript","타입스크립트","tsconfig"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/bd1dff385c51f51e8cdfb5ce1bf76e9e/d803c/thumbnail.png","srcSet":"/static/bd1dff385c51f51e8cdfb5ce1bf76e9e/d803c/thumbnail.png 320w,\n/static/bd1dff385c51f51e8cdfb5ce1bf76e9e/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/bd1dff385c51f51e8cdfb5ce1bf76e9e/fc5c5/thumbnail.webp 320w,\n/static/bd1dff385c51f51e8cdfb5ce1bf76e9e/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/bd1dff385c51f51e8cdfb5ce1bf76e9e/01fb2/thumbnail.png","srcSet":"/static/bd1dff385c51f51e8cdfb5ce1bf76e9e/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/bd1dff385c51f51e8cdfb5ce1bf76e9e/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"15882f84-a7e3-57de-9c8b-d0e275040f44","tableOfContents":"<ul>\n<li>\n<p><a href=\"#unreachable-unused\">Unreachable, Unused</a></p>\n<ul>\n<li><a href=\"#allowunreachablecode\">allowUnreachableCode</a></li>\n<li><a href=\"#allowunusedlabels\">allowUnusedLabels</a></li>\n<li><a href=\"#nounusedlocals\">noUnusedLocals</a></li>\n<li><a href=\"#nounusedparameters\">noUnusedParameters</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%95%94%EB%AC%B5%EC%A0%81%EC%9D%B8-%EC%84%A0%EC%96%B8-%EA%B8%88%EC%A7%80\">암묵적인 선언 금지</a></p>\n<ul>\n<li><a href=\"#noimplicitany\">noImplicitAny</a></li>\n<li><a href=\"#noimplicitoverride\">noImplicitOverride</a></li>\n<li><a href=\"#noimplicitreturns\">noImplicitReturns</a></li>\n<li><a href=\"#noimplicitthis\">noImplicitThis</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#strict\">Strict</a></p>\n<ul>\n<li><a href=\"#alwaysstrict\">alwaysStrict</a></li>\n<li><a href=\"#strictbindcallapply\">strictBindCallApply</a></li>\n<li><a href=\"#strictfunctiontypes\">strictFunctionTypes</a></li>\n<li><a href=\"#strictnullchecks\">strictNullChecks</a></li>\n<li><a href=\"#strictpropertyinitialization\">strictPropertyInitialization</a></li>\n<li><a href=\"#useunknownincatchvariables\">useUnknownInCatchVariables</a></li>\n<li><a href=\"#strict-1\">strict</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#etc\">etc</a></p>\n<ul>\n<li><a href=\"#exactoptionalpropertytypes\">exactOptionalPropertyTypes</a></li>\n<li><a href=\"#nofallthroughcasesinswitch\">noFallthroughCasesInSwitch</a></li>\n<li><a href=\"#nopropertyaccessfromindexsignature\">noPropertyAccessFromIndexSignature</a></li>\n<li><a href=\"#nouncheckedindexedaccess\">noUncheckedIndexedAccess</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 의 컴파일 옵션의 타입 체킹 옵션들에 대한 이야기를 해보려고 한다. 사실 타입스크립트를 사용하는 이유는 대부분 자바스크립트가 제공하지 않는 강력한 타입 시스템이 가져다 주는 안정성 때문이므로 수없이 많은 컴파일 옵션들 중에서도 타입 체크에 대한 옵션들은 타입스크립트의 가장 핵심 기능을 관리하는 옵션들이라고 할 수 있다.","html":"<p>이번 포스팅에서는 <code class=\"language-text\">tsconfig</code>의 컴파일 옵션의 타입 체킹 옵션들에 대한 이야기를 해보려고 한다.</p>\n<p>사실 타입스크립트를 사용하는 이유는 대부분 자바스크립트가 제공하지 않는 강력한 타입 시스템이 가져다 주는 안정성 때문이므로 수없이 많은 컴파일 옵션들 중에서도 타입 체크에 대한 옵션들은 타입스크립트의 가장 핵심 기능을 관리하는 옵션들이라고 할 수 있다.</p>\n<!-- more -->\n<p>그만큼 타입스크립트는 “이런 코드는 금지야”라는 느낌의 단순한 옵션부터 타입 시스템의 원리를 알고 있어야 동작을 제대로 이해할 수 있는 옵션까지, 굉장히 다양한 옵션들을 제공하고 있다.</p>\n<p>대부분의 타입체크 컴파일 옵션들은 모두 타입스크립트의 타입 안정성을 더욱 단단하게 만들어 줄 수 있는 옵션들이기 때문에, 타입스크립트 팀에서도 가급적 모든 옵션을 켜는 것을 추천하고 있다.</p>\n<p>하지만 타입 안정성이 단단해진다는 것을 반대로 말하면, 평소라면 그냥 <code class=\"language-text\">any</code>타입을 타고 어물쩍 넘어갈 수 있었던 것들도 허용되지 않는다는 의미이다.</p>\n<p>즉, 타입스크립트를 점진적으로 도입하고 있는 어플리케이션에서는 타입 에러만 고치다가 많은 시간을 허비할 수도 있기 때문에, 현재 내가 속해있는 조직의 비즈니스 상황까지 잘 고려하여 옵션을 켜는 것을 추천한다.</p>\n<p>그럼 이제 타입스크립트의 타입 체킹 컴파일 옵션들이 실제로 내 코드에 어떤 영향을 끼치는 지에 대해서 한번 자세히 알아보도록 하자.</p>\n<h2 id=\"unreachable-unused\" style=\"position:relative;\">Unreachable, Unused<a href=\"#unreachable-unused\" aria-label=\"unreachable unused permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">Unreachable, Unused</code> 라는 이름으로 시작하는 옵션들은 소스코드에서 사용하지 않거나, 절대로 실행될 수 없는 코드를 어떻게 관리할 것인지에 대한 옵션들이다.</p>\n<h3 id=\"allowunreachablecode\" style=\"position:relative;\">allowUnreachableCode<a href=\"#allowunreachablecode\" aria-label=\"allowunreachablecode permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">undefined</code> (default)</td>\n<td>도달 할 수 없는 코드를 만나면 경고를 띄운다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>도달 할 수 없는 코드를 만나도 무시한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td>도달 할 수 없는 코드를 만나면 에러를 발생시킨다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">allowUnreachableCode</code> 옵션은 컴파일러가 도달 할 수 없는 코드를 만났을 때 어떻게 반응할 것인지에 대한 설정을 의미한다. 도달할 수 없는 코드란, 다시 말해 실행될 수 없는 코드라는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">></span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// Unreachable code detected.ts(7027)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">foo</code> 함수는 <code class=\"language-text\">if-else</code> 문에서 어떤 조건에 걸리던 무조건 값을 반환하고 함수를 종료시키는 동작을 가지고 있기 때문에, 함수 맨 마지막 라인의 <code class=\"language-text\">return true</code> 구문은 절대로 실행될 수가 없다. 바로 이 부분이 도달 할 수 없는 코드, Unreachable 코드인 것이다.</p>\n<p>이 옵션은 기본 값으로만 설정해도 저런 코드를 무시하는 것이 아니라 경고를 띄우도록 되어있기 때문에 딱히 해당 옵션을 켜지 않아도 어느 정도는 Unreachable 코드가 발생하는 상황을 방어할 수는 있다.</p>\n<p>그래도 저런 의미없는 구문이 소스코드에 남아있다면 개발자가 어플리케이션의 흐름을 잘못 이해하는 경우가 발생할 수도 있고, 저런 코드는 어차피 죽은 라인이라 그냥 지워버려도 어플리케이션에 어떠한 영향을 주지 않기 때문에, 되도록이면 옵션을 켜고 컴파일 타임 때 에러가 나도록 설정하는 것을 추천한다. <small><del>(물론 알 수 없는 이유로 저런 코드를 지웠는데 버그가 나는 경우도 간혹 있…)</del></small></p>\n<h3 id=\"allowunusedlabels\" style=\"position:relative;\">allowUnusedLabels<a href=\"#allowunusedlabels\" aria-label=\"allowunusedlabels permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">undefined</code> (default)</td>\n<td>사용하지 않는 라벨을 만나면 경고를 띄운다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>사용하지 않는 라벨을 만나도 무시한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td>사용하지 않는 라벨을 만나면 에러를 발생시킨다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">allowUnusedLabels</code> 옵션은 컴파일러가 코드 내에서 사용하지 않는 라벨을 만났을 때 어떻게 반응할 것인지에 대한 설정을 의미한다.</p>\n<p>프로그래밍을 시작한 지 오래 되지 않은 분들은 이 “라벨”이라는 것이 익숙하지 않으실 수도 있는데, 사실 이 라벨이라는 기능은 타입스크립트에만 있는 것은 아니고 다른 언어들에도 있는 기능이다.</p>\n<p>필자는 6년 전 쯤 학교에서 C를 처음 배울 때 라벨을 사용해보기는 했는데, 그 이후로는 딱히 사용해본 적이 없다.</p>\n<p>라벨은 특정 문(statements)을 대상으로 하기 때문에 <code class=\"language-text\">if</code> 문, <code class=\"language-text\">for</code> 문 등에 이름을 붙히는 것이 가능해지며, 이렇게 이름을 붙힌 문의 이름을 통해 해당 문으로 접근하여 <code class=\"language-text\">break</code>나 <code class=\"language-text\">continute</code> 등의 명령으로 제어할 수 있게 해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">;</span>\n\nouterLoop<span class=\"token operator\">:</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  innerLoop<span class=\"token operator\">:</span> <span class=\"token comment\">// Unused Label</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">===</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// i도 1이고 j도 1이면 바깥 루프를 건너뛴다.</span>\n      <span class=\"token keyword\">continue</span> outerLoop<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">i=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>i<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, j=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>j<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">번 루프 끝</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">i=0, j=0\ni=0, j=1\ni=0, j=2\n1번 루프 끝\ni=1, j=0\ni=2, j=0\ni=2, j=1\ni=2, j=2\n3번 루프 끝</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시를 보면 안 쪽에 위치한 <code class=\"language-text\">for</code> 문에서 <code class=\"language-text\">i</code>와 <code class=\"language-text\">j</code>가 둘 다 <code class=\"language-text\">1</code>인 상황을 만나면 바깥 쪽 <code class=\"language-text\">for</code> 문을 건너뛰도록 동작하고 있다. 그래서 출력을 확인해보면 <code class=\"language-text\">i=1, j=0</code>이 찍힌 이후 “n번 루프 끝”이라는 로그도 출력되지 않고 바로 세번째 순회를 실행하는 모습을 확인할 수 있다.</p>\n<p>이 때, 바깥 쪽 <code class=\"language-text\">for</code> 문의 라벨인 <code class=\"language-text\">outerLoop</code>는 안 쪽 <code class=\"language-text\">for</code> 문에서 사용된 것을 볼 수 있지만, 안 쪽 <code class=\"language-text\">for</code> 문의 라벨인 <code class=\"language-text\">innerLoop</code>는 어디서도 사용되지 않았다. 이것이 바로 Unused Label인 것이고, 우리는 <code class=\"language-text\">allowUnusedLabels</code> 옵션을 통해 타입스크립트 컴파일러가 이러한 사용되지 않은 라벨을 만났을 때 어떻게 반응할 지를 설정할 수 있는 것이다.</p>\n<p>하지만 라벨은 대부분 위에서 밑으로 실행되는 프로그램의 실행 흐름을 역행하게 만드는 주범이기도 하고, 함수처럼 명확한 스코프를 가지고 관심사가 분리된 녀석도 아니기 때문에, 가독성을 해쳐 개발자가 프로그램의 흐름을 읽기 어렵게 만드는 주범이다. <small>(애초에 라벨 + goto 문은 어셈블리 쓰던 시절에 나온 개념이라 C에서도 안티패턴이라고 싫어한다. )</small></p>\n<p>그러니 이 옵션을 켤지 말지를 고민하는 것이 아니라, 아예 라벨 자체를 사용하지 않는 것을 추천한다.</p>\n<h3 id=\"nounusedlocals\" style=\"position:relative;\">noUnusedLocals<a href=\"#nounusedlocals\" aria-label=\"nounusedlocals permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>사용하지 않는 로컬 변수가 있다면 에러를 발생시킨다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>사용하지 않는 로컬 변수가 있어도 무시한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noUnusedLocals</code> 옵션은 함수 내부에 사용하지 않는 지역 변수가 존재할 경우 어떻게 처리할 지에 대한 옵션이다. 만약 이 옵션이 <code class=\"language-text\">true</code>일 경우, 컴파일러는 사용하지 않는 지역 변수에 대해 에러를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">foo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 'bar' is declared but its value is never read.ts(6133)</span>\n  <span class=\"token keyword\">const</span> bar <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">noUnusedLocals</code> 옵션은 옵션 이름에 충실하게 함수 스코프가 아닌, 전역 스코프나 모듈 스코프에 있는 변수는 사용하지 않더라도 어떠한 에러나 경고도 발생시키지 않으니, 이 점을 유의하도록 하자.</p>\n<h3 id=\"nounusedparameters\" style=\"position:relative;\">noUnusedParameters<a href=\"#nounusedparameters\" aria-label=\"nounusedparameters permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>사용하지 않는 인자가 있다면 경고를 발생시킨다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>사용하지 않는 인자가 있어도 무시한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noUnusedParameters</code> 옵션은 함수의 인자 중 사용하지 않는 것이 있을 경우 어떻게 처리할 지에 대한 옵션이다. 만약 이 옵션이 <code class=\"language-text\">true</code>일 경우, 컴파일러는 사용하지 않는 인자에 대해 에러를 발생시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// 'name' is declared but its value is never read.ts(6133)</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">foo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id=\"암묵적인-선언-금지\" style=\"position:relative;\">암묵적인 선언 금지<a href=\"#%EC%95%94%EB%AC%B5%EC%A0%81%EC%9D%B8-%EC%84%A0%EC%96%B8-%EA%B8%88%EC%A7%80\" aria-label=\"암묵적인 선언 금지 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>타입스크립트의 타입 체킹 컴파일 옵션들을 보면 <code class=\"language-text\">noImplicit</code>라는 이름으로 시작하는 많은데, 이 의미는 “암묵적인 무언가”를 금지한다는 말이다.</p>\n<p>암묵적이라는 말은 결국 어떤 정보도 제공하지 않은채 몰래 뭔가를 수행한다는 의미이기 때문에, 개발자가 예측하지 못한 곳에서 문제가 발생할 가능성이 높아지는 것이다.</p>\n<p>그러니 되도록 <code class=\"language-text\">noImplicit</code>로 시작하는 옵션들을 모두 켜서, 타입스크립트 컴파일 타임에 나 몰래 뭔가를 알아서 평가해버리는 상황을 최대한 방어하도록 하자.</p>\n<h3 id=\"noimplicitany\" style=\"position:relative;\">noImplicitAny<a href=\"#noimplicitany\" aria-label=\"noimplicitany permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>타입 추론이 불가능하고 타입 선언도 되지 않은 값을 암묵적으로 <code class=\"language-text\">any</code> 타입으로 사용하는 것을 금지한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>타입 추론이 불가능하고 타입 선언도 되지 않은 값을 암묵적으로 <code class=\"language-text\">any</code> 타입으로 사용하는 것을 허용한다.</td>\n</tr>\n</tbody>\n</table>\n<p>타입스크립트는 딱히 개발자가 타입을 명시적으로 선언하지 않았고, 추론도 불가능한 값에 대해서 <code class=\"language-text\">any</code> 타입으로 평가하는데, <code class=\"language-text\">noImplicitAny</code> 옵션은 이렇게 <code class=\"language-text\">any</code> 타입으로 평가된 값이 존재할 때 에러를 발생시킬 지 여부를 결정하는 옵션이다.</p>\n<p>물론 이렇게 <code class=\"language-text\">any</code>타입으로 평가된 값이 존재한다면 타입 안정성에 좋지 않은 영향을 끼치기 때문에, 타입스크립트는 이 옵션을 켜지 않아도 <code class=\"language-text\">any</code> 타입에 대해서 경고를 띄워주기는 한다.</p>\n<p>하지만 단순 경고는 컴파일 타임 때 그냥 무시하고 넘어가게 되기 때문에, <code class=\"language-text\">noImplicitAny</code> 옵션을 사용하여 이런 <code class=\"language-text\">any</code> 타입에 대해서 아예 컴파일 타임 때 에러를 발생시키고 컴파일을 막아버리는 편이 훨씬 안전하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Parameter 's' implicitly has an 'any' type.ts(7006)</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">subtr</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"noimplicitoverride\" style=\"position:relative;\">noImplicitOverride<a href=\"#noimplicitoverride\" aria-label=\"noimplicitoverride permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>서브 클래스의 암묵적인 오버라이딩을 금지한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>서브 클래스의 암묵적인 오버라이딩을 허용한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noImplicitOverride</code> 옵션은 클래스를 상속받은 서브 클래스가 슈퍼 클래스의 멤버 변수나 메소드를 암묵적으로 오버라이딩하는 것을 허용할 것인지에 대한 옵션이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Album</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">download</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token function\">upload</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SharedAlbum</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Album</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// This member must have an 'override' modifier because it overrides a member in the base class 'Album'.ts(4114)</span>\n  <span class=\"token function\">download</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// overriding 키워드를 사용한 명시적 오버라이딩은 허용</span>\n  override <span class=\"token function\">upload</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>만약 이런 암묵적인 오버라이딩이 발생했을 때 컴파일러가 아무런 경고 또는 에러를 띄워주지 않는다면, 개발자가 인지하지 못한 채 슈퍼 클래스의 기능을 오버라이딩 해버리는 상황이 발생할 수 있다. <small>(<del>슈퍼 클래스의 모든 멤버 변수와 메소드 이름을 외우고 있는 것도 아니니 말이다</del>)</small></p>\n<p>이 경우 개발자가 의도치 않게 슈퍼 클래스의 기능을 훼손하여 예상하지 못한 에러가 발생할 수 있으므로, 가급적이면 암묵적인 오버라이딩을 금지하는 <code class=\"language-text\">noImplicitOverride</code>을 켜고 개발하는 것을 추천한다.</p>\n<h3 id=\"noimplicitreturns\" style=\"position:relative;\">noImplicitReturns<a href=\"#noimplicitreturns\" aria-label=\"noimplicitreturns permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>함수가 암묵적으로 <code class=\"language-text\">undefined</code>를 반환하는 상황을 금지한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>함수가 암묵적으로 <code class=\"language-text\">undefined</code>를 반환하는 상황을 허용한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noImplicitReturns</code> 옵션은 함수가 암묵적으로 <code class=\"language-text\">undefined</code>를 반환하는 상황을 어떻게 처리할 것인지에 대한 옵션이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// Not all code paths return a value.ts(7030)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시의 <code class=\"language-text\">foo</code> 함수는 자신이 받은 인자가 <code class=\"language-text\">1</code>일 경우에는 <code class=\"language-text\">true</code>를 반환하고 그 외에는 아무것도 반환하지 않기 때문에 타입스크립트는 이 함수가 <code class=\"language-text\">boolean</code> 타입의 값을 반환한다고 추론한다.</p>\n<p>하지만 실제로는 <code class=\"language-text\">foo(2)</code>와 같이 조건에 맞지 않는 인자와 함께 함수를 호출하게 되면 아무것도 명시적으로 반환하지 않고 함수가 종료되면서, 암묵적으로 <code class=\"language-text\">undefined</code>가 반환되게 된다. 이 동작은 브라우저의 개발자 도구에서 아무 함수가 선언한다음 호출해보면 바로 확인해볼 수 있으니 한번 해보도록 하자.</p>\n<p>여기서 문제는 타입스크립트가 추론한 함수의 반환 타입은 분명 <code class=\"language-text\">boolean</code> 타입이지만, 실제로는 암묵적인 반환 타입인 <code class=\"language-text\">undefined</code>가 합쳐져 최종적으로 <code class=\"language-text\">boolean | undefined</code>가 반환될 수 있다는 것이다. 결국 이 모순으로 인해 런타임 때 예상하지 못한 에러가 발생할 수 있는 빌미를 제공하게 된다.</p>\n<p>그래서 <code class=\"language-text\">noImplicitReturns</code> 옵션은 이렇게 함수가 암묵적으로 <code class=\"language-text\">undefined</code>를 반환하는 상황일 경우, 함수가 값을 제대로 반환하고 있지 않다는 경고를 보여주는 역할을 한다. 해당 옵션을 켜는 경우, 위 예시의 <code class=\"language-text\">foo</code> 함수는 명시적으로 <code class=\"language-text\">undefined</code>를 반환하는 형태로 변경되어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>v <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"noimplicitthis\" style=\"position:relative;\">noImplicitThis<a href=\"#noimplicitthis\" aria-label=\"noimplicitthis permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">this</code>가 암묵적으로 <code class=\"language-text\">any</code>로 평가되는 경우를 금지한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td><code class=\"language-text\">this</code>가 암묵적으로 <code class=\"language-text\">any</code>로 평가되는 경우를 허용한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noImplicitThis</code> 옵션은 <code class=\"language-text\">this</code>가 암묵적으로 <code class=\"language-text\">any</code>로 평가되는 경우를 금지한다. 이 옵션의 동작을 이해하려면 우선 자바스크립트나 타입스크립트의 <code class=\"language-text\">this</code>가 어떤 녀석인지 알아야 할 필요가 있지만, 이 포스팅은 <code class=\"language-text\">this</code>의 동작에 대한 주제가 아니므로 간단하게만 설명하고 넘어가도록 하겠다. <code class=\"language-text\">this</code>에 대해 더 깊은 지식을 원하시는 분은 이 <a href=\"https://poiemaweb.com/js-this\" target=\"_blank\" rel=\"nofollow\">포스팅</a>을 참고하도록 하자.</p>\n<p>기본적으로 자바스크립트의 <code class=\"language-text\">this</code>라는 녀석은 동적으로 바인딩 된다. 함수가 어떤 방식으로 호출되냐에 따라서 이 <code class=\"language-text\">this</code>가 가리키고 있는 것이 달라진다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">sayThis</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Human</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> sayThis <span class=\"token operator\">=</span> evan<span class=\"token punctuation\">.</span>sayThis<span class=\"token punctuation\">;</span>\n\nevan<span class=\"token punctuation\">.</span><span class=\"token function\">sayThis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Human {}</span>\n<span class=\"token function\">sayThis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// globalThis</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시를 보면, 같은 <code class=\"language-text\">Human</code> 클래스의 메소드인데도 호출 방법에 따라 <code class=\"language-text\">this</code>가 동적으로 변경되고 있는 것을 확인할 수 있다. 자바스크립트의 <code class=\"language-text\">this</code>는 이처럼 예측하기 어려운 동작을 하기 때문에 개발자가 직접 <code class=\"language-text\">this</code>가 무엇인지를 정할 수 있는 <code class=\"language-text\">call</code>, <code class=\"language-text\">apply</code>, <code class=\"language-text\">bind</code>와 같은 메소드들이나 <code class=\"language-text\">this</code> 바인딩 자체를 하지 않는 ES6의 화살표 함수 같은 녀석들이 필요한 것이다.</p>\n<p>바로 이 동적 바인딩이라는 방식 때문에 타입스크립트가 <code class=\"language-text\">this</code>의 타입 추론을 할 수 없는 상황도 왕왕 발생하는데, 그 중 대표적인 예가 함수 안의 함수, 흔히들 이야기하는 Inner Function에서 <code class=\"language-text\">this</code>에 접근하는 경우이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Human</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">sayThis</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">say</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 'this' implicitly has type 'any' because it does not have a type annotation.ts(2683)</span>\n      <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Human</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nevan<span class=\"token punctuation\">.</span><span class=\"token function\">sayThis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// globalThis</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시를 보면 <code class=\"language-text\">sayThis</code> 메소드 내부에서 다시 <code class=\"language-text\">say</code> 함수를 선언한 후 호출하고 있고, 안 쪽에 선언된 함수에서 <code class=\"language-text\">this</code>에 접근하고 있다. 상식적으로 생각하면 이 함수의 <code class=\"language-text\">this</code>는 왠지 <code class=\"language-text\">Human</code> 클래스가 되어야 할 것 같지만, 현실은 시궁창처럼 <code class=\"language-text\">globalThis</code>가 튀어나온다. <small>(이런 경우에는 화살표 함수 씁시다…)</small></p>\n<p>바로 이런 경우가 타입스크립트가 <code class=\"language-text\">this</code>에 대한 추론을 하지 못하는 경우이다. 이때 타입스크립트는 암묵적으로 <code class=\"language-text\">say</code> 함수 내부의 <code class=\"language-text\">this</code>를 <code class=\"language-text\">any</code>타입으로 바인딩하게 되고, 이로 인해 타입 안정성이 와장창 깨지게 된다.</p>\n<p>즉, <code class=\"language-text\">noImplicitThis</code> 옵션은 이렇게 <code class=\"language-text\">this</code> 타입이 암묵적으로 <code class=\"language-text\">any</code>로 평가되는 상황을 용인할 것인지에 대한 옵션인 것이다. 애초에 메소드 내부에 선언된 함수의 <code class=\"language-text\">this</code>에 전역 객체가 바인딩되는 동작을 응용하는 상황 자체가 거의 없으므로 이 옵션 또한 가급적이면 켜는 것을 추천한다.</p>\n<h2 id=\"strict\" style=\"position:relative;\">Strict<a href=\"#strict\" aria-label=\"strict permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">Strict</code> 옵션들은 타입스크립트가 일반적인 상황에서 타입을 평가할 때 얼마나 엄격하게 평가할 것인지를 관리하는 옵션들이다.</p>\n<p>이런 옵션들을 타입스크립트 팀에서는 Strict mode family라고 호칭하고 있는데, 간단하게는 자바스크립트의 <code class=\"language-text\">'use strict'</code> 디렉티브로 켤 수 있는 Strict 모드의 동작을 위반했는지 검사하는 옵션부터, 타입의 공변성과 반공변성을 검사하는 옵션까지, 다양한 상황에서 타입스크립트가 조금 더 엄격하게 타입을 평가할 수 있는 옵션들을 제공하고 있다.</p>\n<h3 id=\"alwaysstrict\" style=\"position:relative;\">alwaysStrict<a href=\"#alwaysstrict\" aria-label=\"alwaysstrict permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>소스 코드 내에서 Strict 룰을 위반하는 방법을 사용하면 에러를 발생시킨다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>소스 코드 내에서 Strict 룰을 위반하는 방법을 사용해도 무시한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">alwaysStrict</code> 옵션은 개발자가 타입스크립트를 사용할 때 자바스크립트의 Strict 룰을 위반하는 방법을 사용했을 때 에러를 발생시킨다. 이 옵션을 <code class=\"language-text\">true</code>로 설정하게 되면 타입스크립트는 각 소스 파일들의 상단에 마치 <code class=\"language-text\">use strict</code> 디렉티브가 선언되어 있는 것처럼 구문을 파싱하게 된다.</p>\n<p>참고로 타입스크립트의 대부분의 Strict 모드 관련 옵션들은 “모듈이 아닌 코드”를 위한 것이다. 타입스크립트는 ECMAScript 2015의 <a href=\"https://262.ecma-international.org/6.0/#sec-strict-mode-code\" target=\"_blank\" rel=\"nofollow\">Strict Mode Code</a> 섹션의 정의에 따라 모든 모듈 코드는 반드시 Strict 모드로 컴파일하기 때문이다.</p>\n<p>이 옵션을 사용할 때 한 가지 알아둬야 할 점은 <code class=\"language-text\">use strict</code> 디렉티브를 “소스 파일”에 내보내는 것이지, 결과물에 내보낸다는 것이 아니라는 것이다. 예시를 한번 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// index.ts</span>\n\n<span class=\"token comment\">// Octal literals are not allowed in strict mode.ts(1121)</span>\n<span class=\"token keyword\">const</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">023</span><span class=\"token punctuation\">;</span> </code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// index.js</span>\n\n<span class=\"token keyword\">var</span> number <span class=\"token operator\">=</span> <span class=\"token number\">023</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위 예시 같은 경우 IDE에서 <code class=\"language-text\">Octal literals are not allowed in strict mode.ts(1121)</code>라는 에러를 보여주기는 하지만, 정작 컴파일을 할 때는 아무 에러가 발생하지 않고 컴파일 후에 생긴 결과 파일을 확인해도 <code class=\"language-text\">use strict</code> 디렉티브는 포함되어 있지 않은 것을 볼 수 있다. 즉, 소스 코드를 파싱할 때는 에러를 인지하지만, 컴파일 결과에서까지 Strict 모드가 적용되는 것은 보장하지 않는 것이다.</p>\n<p>하지만 앞서 말한대로 모듈을 사용하고 있을 경우, 타입스크립트는 해당 옵션의 여부와 상관없이 소스 코드 파싱 및 컴파일 결과물에도 Strict 모드를 적용하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// index.ts</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">023</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// index.js (common.js)</span>\n\n<span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span>__esModule <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span>n <span class=\"token operator\">=</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span>n <span class=\"token operator\">=</span> <span class=\"token number\">023</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>exports<span class=\"token punctuation\">.</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"strictbindcallapply\" style=\"position:relative;\">strictBindCallApply<a href=\"#strictbindcallapply\" aria-label=\"strictbindcallapply permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">call</code>, <code class=\"language-text\">apply</code>, <code class=\"language-text\">bind</code>를 사용하여 함수를 호출했을 때에도 인자의 타입을 검사한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td><code class=\"language-text\">call</code>, <code class=\"language-text\">apply</code>, <code class=\"language-text\">bind</code>를 사용하여 함수를 호출했을 때에도 인자의 타입을 검사하지 않는다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">strictBindCallApply</code> 옵션은 <code class=\"language-text\">call</code>, <code class=\"language-text\">apply</code>, <code class=\"language-text\">bind</code>와 같이 함수의 실행 컨텍스트를 변경할 수 있는 메소드를 사용하여 함수를 호출하거나 선언을 했을 때에도 함수에 올바른 타입의 인자가 주어졌는지를 검사할 수 있는 옵션이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hi, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n \n<span class=\"token function\">sayHi</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"evan\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token comment\">// Argument of type 'boolean' is not assignable to parameter of type 'string'.ts(2345)</span>\n<span class=\"token function\">sayHi</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>물론 함수의 실행 컨텍스트를 변경하는 일이 자주 발생하는 것은 아니지만, 이 옵션이 꺼져있는 상태에서 <code class=\"language-text\">call</code>, <code class=\"language-text\">apply</code>, <code class=\"language-text\">bind</code>를 사용하게 되면 타입스크립트는 함수의 인자에 제대로 된 타입이 넘겨졌는지 검사하지 않기 때문에, 이로인한 런타임 타입 에러가 발생할 수도 있다.</p>\n<h3 id=\"strictfunctiontypes\" style=\"position:relative;\">strictFunctionTypes<a href=\"#strictfunctiontypes\" aria-label=\"strictfunctiontypes permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>함수의 인자가 반공변적인 타입으로 평가된다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>함수의 인자가 이변적인 타입으로 평가된다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">strictFunctionTypes</code> 옵션은 함수의 인자를 반공변적으로 평가되게 할 것인지에 대한 옵션이다. 이 포스팅은 공변성과 반공변성에 대한 주제가 아니니, 공변과 반공변에 대해 자세히 알고 싶으신 분들은 이 <a href=\"https://seob.dev/posts/%EA%B3%B5%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/\" target=\"_blank\" rel=\"nofollow\">포스팅</a>을 한번 보고 오도록 하자.</p>\n<p>이 포스팅에서는 공변과 반공변에 대해서 간략하게만 설명하고 넘어가도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> foo<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> bar<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*\nType '(string | number)[]' is not assignable to type 'string[]'.\n  Type 'string | number' is not assignable to type 'string'.\n    Type 'number' is not assignable to type 'string'.ts(2322)\n*/</span>\nfoo <span class=\"token operator\">=</span> bar<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시에서 필자는 <code class=\"language-text\">Array&lt;string></code>인 <code class=\"language-text\">foo</code> 변수에 <code class=\"language-text\">Array&lt;string | number></code> 타입인 <code class=\"language-text\">bar</code> 변수의 값을 할당하려고 했고, 타입스크립트는 <code class=\"language-text\">string | number</code> 타입은 <code class=\"language-text\">string</code> 타입인 값에 할당할 수 없다고 말하고 있다.</p>\n<p>왜 에러가 발생하는 것일까? 그 이유는 <code class=\"language-text\">string</code> 타입이 <code class=\"language-text\">string | number</code> 타입보다 작은 개념이기 때문이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b0ad89a090e9426b629aea7e838d5c43/38124/unionset.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60.62500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABsklEQVR42q2TX2+bMBTF+f7fZJqqSn1YXzZtT9vDlLSEAqEBG8JfQ+uQhjTb1HB6L4SUTOlbQQcsS/752PdcA4enbVus9Q6xWEHMHxA4FaKFxmO5xf6lBb/rPw2K5hHJkyKVUI3G5u8zrx4wMPjzQgsY5ExzODc57GkK9zYnFXAmOcSiQrIuIVcphE7pn0HqfixoTtEm+3b/BkxkDXuSwbcrTH76uLr4gctPX/Ht+jd85wG39xJmKJA2FX7ZE3z+comr79dwswAxuRU6gdrqHvhU78hVAc9S8GYKc5Nc3WS4mya0SQrHSzAjmBkIeEWMkNwtVAS/WnbjqM47sfuGjm+kYQ2XgTN11L1VHmUFIQHJoZC4i0JaXHSuWANsAJbk0uACsKsxsJNJbq0CliCglEdJnZ2ABrHbbFPBkN4HA88deSwriAgkRkfOz4orX25XfVHcUVH+d2nPh6JIeHmM5bp4F9j82w2x6TN4Fkpz5kLCiiQd6z13fUFOgs1Qdsph5jtldcGmjaRfIT0Em+8qrA/igHfB1qfBfmu9Z8QEDtyq09I/03qbofVU1yHceu2o9V4BQOhy3IbwEtMAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"unionset\" title=\"\" src=\"/static/b0ad89a090e9426b629aea7e838d5c43/6af66/unionset.png\" srcset=\"/static/b0ad89a090e9426b629aea7e838d5c43/69538/unionset.png 160w,\n/static/b0ad89a090e9426b629aea7e838d5c43/72799/unionset.png 320w,\n/static/b0ad89a090e9426b629aea7e838d5c43/6af66/unionset.png 640w,\n/static/b0ad89a090e9426b629aea7e838d5c43/38124/unionset.png 953w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>string | number 타입은 string과 number가 합쳐진 합집합을 의미한다.</small>\n</center>\n<p>이처럼 <code class=\"language-text\">string | number</code> 타입은 두 개의 타입이 합쳐진 합집합을 의미하고 있으니, 당연하게도 <code class=\"language-text\">string</code> 타입은 자신보다 더 큰 개념인 <code class=\"language-text\">string | number</code> 타입을 품을 수 없다.</p>\n<p>이 경우, 작은 개념인 <code class=\"language-text\">string</code> 타입을 <code class=\"language-text\">string | number</code> 타입의 “서브 타입”이라고 부르고, 큰 개념인 <code class=\"language-text\">string | number</code>을 <code class=\"language-text\">string</code> 타입의 “슈퍼 타입”이라고 부른다. <small>(참고로 부분 집합, 상위 집합도 영어로 subset, superset이다. 사실 상 여기서 이름을 따온 것이라고 보면 된다.)</small></p>\n<p>이와 동일하게 <code class=\"language-text\">Array&lt;string></code> 또한 <code class=\"language-text\">Array&lt;string | number></code> 타입보다 작은 개념이다. <code class=\"language-text\">string</code>만 가지고 있도록 선언한 배열에 <code class=\"language-text\">string</code>과 <code class=\"language-text\">number</code>를 모두 가진 배열을 할당할 수는 없는 노릇이니 타입스크립트는 에러를 발생시킨다.</p>\n<blockquote>\n<p>이처럼 어떠한 타입 <code class=\"language-text\">T</code>가 타입 <code class=\"language-text\">T'</code>의 서브 타입인 경우, <code class=\"language-text\">C&lt;T></code> 또한 <code class=\"language-text\">C&lt;T'></code>의 서브 타입이라면 이때 타입 <code class=\"language-text\">C</code>를 <strong>공변적</strong>, 또는 <strong>공변성을 가지고 있다</strong>고 이야기한다.</p>\n</blockquote>\n<p>공변성이 무엇인지 이해했다면 나머지는 쉽다. 반공변성은 공변성의 반대이기 때문이다. 즉 타입 <code class=\"language-text\">T</code>가 타입 <code class=\"language-text\">T'</code>의 서브 타입일 때, 반대로 <code class=\"language-text\">C&lt;T'></code>가 <code class=\"language-text\">C&lt;T></code>의 서브 타입이 된다면, 이때 타입 <code class=\"language-text\">C</code>를 <strong>반공변적</strong>이라고 한다.</p>\n<p>이렇게 타입이 반공변적으로 평가되어야 하는 경우가 있을까 싶기도 한데, 의외로 가까운 곳에 있다. 바로 <code class=\"language-text\">strictFunctionTypes</code> 옵션이 다루고 있는 주체인 함수의 인자이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Func<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> stringOrNumber<span class=\"token operator\">:</span> Func<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> onlyString<span class=\"token operator\">:</span> Func<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*\nType 'Func&lt;string>' is not assignable to type 'Func&lt;string | number>'.\n  Type 'string | number' is not assignable to type 'string'.\n    Type 'number' is not assignable to type 'string'.ts(2322)\n*/</span>\nstringOrNumber <span class=\"token operator\">=</span> onlyString<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>앞서 보았던 공변성 예시에서 <code class=\"language-text\">string</code> 타입은 <code class=\"language-text\">string | number</code>의 서브 타입이라고 이야기 했었다.</p>\n<p>만약 함수의 인자가 공변적으로 평가된다면, <code class=\"language-text\">Func&lt;string></code> 또한 <code class=\"language-text\">Func&lt;string | number></code>의 서브 타입이 되어야한다는 의미이기 때문에 <code class=\"language-text\">Func&lt;string></code> 타입에 <code class=\"language-text\">Func&lt;string | number></code> 타입을 할당해도 문제가 발생하지 않아야 한다.</p>\n<p>하지만 이 예시를 보면 그게 아니라는 것을 알 수 있다. <code class=\"language-text\">Func&lt;string | number></code>는 분명 슈퍼 타입인 <code class=\"language-text\">string | number</code>를 인자로 받는 함수 타입이지만, 이 타입에 인자로 서브 타입인 <code class=\"language-text\">string</code>만을 받는 <code class=\"language-text\">Func&lt;string></code> 타입의 함수를 할당하려고 하면 타입스크립트는 에러를 발생시킨다.</p>\n<p>즉, 함수의 인자는 반공변적으로 평가되기 때문에, 공변성을 가지고 있는 <code class=\"language-text\">Array</code> 타입과는 정반대로 작동하고 있는 것이다.</p>\n<p>이 동작이 어렵게 느껴질 수도 있지만 잘 생각해보면 이해가 되는 것이, <code class=\"language-text\">onlyString</code> 함수는 <code class=\"language-text\">Func&lt;string></code> 타입이기 때문에 인자가 반드시 <code class=\"language-text\">string</code> 타입일 것이라고 가정하고 정의된 함수이기 때문이다.</p>\n<p>만약 이런 함수를 <code class=\"language-text\">string | number</code> 타입의 인자를 받을 수 있다는 함수라고 인정해버린다면, 개발자가 실수로 <code class=\"language-text\">onlyString</code> 함수에 <code class=\"language-text\">number</code> 타입의 인자를 넘길 수도 있다는 것이고, 이 경우 <code class=\"language-text\">onlyString</code> 함수는 장렬한 런타임 타입 에러와 함게 전사할 것이다.</p>\n<center>\n  <div style=\"max-width: 400px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/300c81767ca8abe09ea1f7f958e3a5ae/80e3c/cube.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAMCBAX/xAAXAQADAQAAAAAAAAAAAAAAAAAAAQID/9oADAMBAAIQAxAAAAHtRRi95grMG6AX/8QAGhAAAgIDAAAAAAAAAAAAAAAAAhIAAQMQEf/aAAgBAQABBQIzShzPrNF6ddiU5BR6/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/ARIiv//EABgRAAIDAAAAAAAAAAAAAAAAAAARARAh/9oACAECAQE/AdYyK//EABwQAAIBBQEAAAAAAAAAAAAAAAABIQIQERJBUf/aAAgBAQAGPwImmyxL8KdnAzfos8m3/8QAGxABAAMAAwEAAAAAAAAAAAAAAQARIRAxUUH/2gAIAQEAAT8hPQV8IVhguu4AFBkvo1fDNLB0Psa1mxQ6oVMJ704//9oADAMBAAIAAwAAABDL14L/xAAZEQACAwEAAAAAAAAAAAAAAAABIQAQEYH/2gAIAQMBAT8Qb0OdjgbX/8QAGREAAgMBAAAAAAAAAAAAAAAAAREAECFx/9oACAECAQE/ECeUDBqYOV//xAAcEAEBAAMBAAMAAAAAAAAAAAABEQAhMUEQUXH/2gAIAQEAAT8QpkXMAhFRdFyOYPM3RXZKl7M0/EK4Pn9cviwwp0+8W+3O9Rx5s8Rm/j//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"cube\" title=\"\" src=\"/static/300c81767ca8abe09ea1f7f958e3a5ae/c08c5/cube.jpg\" srcset=\"/static/300c81767ca8abe09ea1f7f958e3a5ae/0913d/cube.jpg 160w,\n/static/300c81767ca8abe09ea1f7f958e3a5ae/cb69c/cube.jpg 320w,\n/static/300c81767ca8abe09ea1f7f958e3a5ae/c08c5/cube.jpg 640w,\n/static/300c81767ca8abe09ea1f7f958e3a5ae/80e3c/cube.jpg 720w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>이건 마치 네모만 끼울 수 있게 만든 구멍에<br>별 모양도 어떻게든 끼울 수 있다고 설명서를 제공하는 꼴이랄까...</small>\n  <br>\n  <br>\n</center>\n<p>이런 함수의 특성으로 인해 함수의 인자는 반공변적으로 평가되는 것이 훨씬 안전하기 때문에, 타입스크립트는 <code class=\"language-text\">strictFunctionTypes</code> 옵션을 제공하고 있는 것이다.</p>\n<p>만약 이 옵션이 꺼져있다면 함수의 인자가 반공변적으로 평가되지 않기 때문에 위 예시에서 보았던 할당의 제약이 모두 사라지게 된다. 이렇게 되면 앞서 말한대로 개발자의 실수로 함수의 인자로 잘못된 타입을 넘겨 런타임 에러가 발생할 확률이 커지게 되므로 가급적이면 <code class=\"language-text\">strictFunctionTypes</code>을 켜도록 하자. <small><del>(생각보다 크게 불편하지도 않다)</del></small></p>\n<h3 id=\"strictnullchecks\" style=\"position:relative;\">strictNullChecks<a href=\"#strictnullchecks\" aria-label=\"strictnullchecks permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>구체적인 값이 존재해야하는 상황에서 값이 <code class=\"language-text\">null</code>이거나 <code class=\"language-text\">undefined</code>일 가능성이 존재하는 경우 에러를 발생시킨다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>구체적인 값이 존재해야 하는 상황에서, 값이 <code class=\"language-text\">null</code>이거나 <code class=\"language-text\">undeinfed</code>일 가능성이 존재해도 무시한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">strictNullChecks</code> 옵션은 구체적인 값이 반드시 존재해야하는 상황일 때, 어떠한 값이 <code class=\"language-text\">null</code>이거나 <code class=\"language-text\">undefined</code>일 가능성이 존재한다면 에러를 발생시키는 옵션이다.</p>\n<p>구체적인 값이 반드시 존재해야하는 상황은 대부분 <code class=\"language-text\">foo.a</code>처럼 어떤 객체의 프로퍼티에 접근하려고 시도하는 상황이라고 볼 수 있는데, 이렇게 접근할 때 만약 <code class=\"language-text\">foo</code> 변수의 값이 <code class=\"language-text\">null</code>이거나 <code class=\"language-text\">undefined</code>라면 레퍼런스 런타임 에러가 발생하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> people<span class=\"token operator\">:</span> Person<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'evan'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> myPerson <span class=\"token operator\">=</span> people<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> name <span class=\"token operator\">===</span> <span class=\"token string\">'john'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Uncaught ReferenceError: myPerson is not defined</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myPerson<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시에서 사용한 <code class=\"language-text\">Array.prototype.find</code> 메소드는 <code class=\"language-text\">T | undefined</code> 타입을 반환하도록 정의되어있는데, 이는 <code class=\"language-text\">find</code> 메소드가 배열에서 목표로 했던 원소를 찾을 수도 있고 없을 수도 있기 때문이다.</p>\n<p>그렇기 때문에 이 예시에서의 <code class=\"language-text\">myPerson</code> 변수는 <code class=\"language-text\">Human | undefined</code>의 타입을 가지게 되며, 실제로 위 코드를 실제로 실행시켜보면 이름으로 <code class=\"language-text\">evan</code>이라는 값을 가지고 있는 원소가 배열 내에 없기 때문에 결국 <code class=\"language-text\">myPerson</code> 변수의 값은 <code class=\"language-text\">undefined</code>가 되고, 마지막 콘솔 라인에서 런타임 레퍼런스 에러가 발생하게 된다.</p>\n<p>만약 <code class=\"language-text\">strictNullChecks</code> 옵션이 꺼져있는 상태라면 이런 상황이라도 타입스크립트는 값이 <code class=\"language-text\">undefined</code>일 가능성이 존재하는 <code class=\"language-text\">myPerson</code>의 프로퍼티에 접근할 때 어떠한 경고나 에러도 주지 않지만, 옵션을 켜게되면 다음과 같은 에러가 발생하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> people<span class=\"token operator\">:</span> Person<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'evan'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> myPerson <span class=\"token operator\">=</span> people<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=></span> value<span class=\"token punctuation\">.</span>name <span class=\"token operator\">===</span> <span class=\"token string\">'john'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Object is possibly 'undefined'.ts(2532)</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myPerson<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이런 상황에서는 명시적으로 <code class=\"language-text\">if</code> 문을 사용하여 <code class=\"language-text\">myPerson</code> 변수가 <code class=\"language-text\">null</code> 또는 <code class=\"language-text\">undefined</code> 인지 검사하거나, <code class=\"language-text\">myPerson?.name</code> 처럼 옵셔널 체이닝을 사용하여 프로퍼티에 접근함으로써 타입 안정성을 유지하며 문제를 해결할 수 있다.</p>\n<h3 id=\"strictpropertyinitialization\" style=\"position:relative;\">strictPropertyInitialization<a href=\"#strictpropertyinitialization\" aria-label=\"strictpropertyinitialization permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>객체가 생성된 시점에 반드시 존재해야 하는 멤버 변수가 초기화되지 않았다면 에러를 발생시킨다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>객체가 생성된 시점에 반드시 존재해야 하는 멤버 변수가 초기화되지 않았어도 무시한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">strictPropertyInitialization</code> 옵션은 클래스의 멤버 변수가 안전하지 않은 타입을 가지게 되었을 때 어떻게 처리할 지에 대한 옵션이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">UserAccount</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Property 'email' has no initializer and is not definitely assigned in the constructor.</span>\n  email<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\n  address<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n \n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시에서 클래스 <code class=\"language-text\">UserAccount</code>는 총 3개의 멤버 변수를 가지고 있는데, <code class=\"language-text\">name</code>과 <code class=\"language-text\">email</code>은 값이 반드시 존재해야하는 타입으로 선언된 멤버 변수이고, <code class=\"language-text\">address</code>는 값이 <code class=\"language-text\">undefined</code>일 수도 있는 옵셔널한 타입으로 선언된 멤버 변수이다.</p>\n<p>하지만 클래스의 생성자를 보면 <code class=\"language-text\">name</code> 멤버 변수만 초기화를 하고 있다. 이대로라면 객체가 생성되었을 때 반드시 <code class=\"language-text\">string</code> 타입의 값을 가지고 있어야 하는 <code class=\"language-text\">email</code> 멤버 변수가 <code class=\"language-text\">undefined</code>로 할당된 채로 객체가 생성되어 버리는 것이다. 즉, 타입 안정성이 깨져버리게 된다.</p>\n<p><code class=\"language-text\">strictPropertyInitialization</code> 옵션을 사용하면 이렇게 클래스를 사용하여 생성한 객체가 정의된 타입과 맞지 않는 멤버 변수를 가지게 되는 경우에 에러를 발생시키기 때문에, 높은 타입 안정성을 가지고 갈 수 있다.</p>\n<h3 id=\"useunknownincatchvariables\" style=\"position:relative;\">useUnknownInCatchVariables<a href=\"#useunknownincatchvariables\" aria-label=\"useunknownincatchvariables permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>catch 문의 error 인자를 <code class=\"language-text\">unknown</code> 타입으로 평가한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>catch 문의 error 인자를 <code class=\"language-text\">any</code> 타입으로 평가한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">useUnknownInCatchVariables</code> 옵션은 그 이름이 말해주듯이, catch 문의 인자로 주어지는 <code class=\"language-text\">error</code> 값을 어떤 타입으로 평가할 지에 대한 옵션이다.</p>\n<p>기본적으로 타입스크립트는 Catch 문의 인자를 <code class=\"language-text\">any</code> 타입으로 평가하기 때문에 이런 느낌으로 코드를 작성하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>whatever<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>기본적으로 아무런 옵션도 주지 않았을 때, 타입스크립트는 catch 문의 인자인 <code class=\"language-text\">e</code>를 <code class=\"language-text\">any</code> 타입으로 평가하기 때문에, 이 값을 가지고 어떤 짓을 하던 컴파일 타임에는 아무 에러도 발생하지 않는 것이다. 하지만 만약 <code class=\"language-text\">e</code>가 <code class=\"language-text\">null</code>이나 <code class=\"language-text\">undefined</code>라면 바로 런타임 레퍼런스 에러가 발생할 수 있는 위험한 상황이다.</p>\n<p>이제 <code class=\"language-text\">useUnknownInCatchVariables</code>을 켜게 되면 타입스크립트는 이제 catch 문의 인자로 넘어오는 값을 더 이상 <code class=\"language-text\">any</code> 타입이 아닌, <code class=\"language-text\">unknown</code> 타입으로 평가하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Property 'message' does not exist on type 'unknown'.ts(2339)</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 이건 통과</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>단순히 “무시해라”라는 의미를 가진 <code class=\"language-text\">any</code> 타입과 다르게, <code class=\"language-text\">unknown</code> 타입은 “타입을 알 수 없으니 정의가 필요하다”라는 의미를 가지고 있기 때문에, 반드시 타입에 대한 정보를 타입스크립트에게 알려줘야 한다.</p>\n<p>물론 이렇게 catch 문의 인자를 <code class=\"language-text\">unknown</code>으로 평가하게 되면, catch 문 내부에서 인자의 타입을 체크하는 과정이 필요해지기 때문에 조금 귀찮아 질 수는 있지만, 개인적으로는 예상하지 못 한 순간에 런타임 에러가 터지느니 프로그래밍할 때 조금 귀찮은 게 훨씬 낫다고 생각한다.</p>\n<h3 id=\"strict-1\" style=\"position:relative;\">strict<a href=\"#strict-1\" aria-label=\"strict 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>컴파일러 옵션의 Strict 관련 옵션들을 일괄적으로 켠다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>컴파일로 옵션의 Strict 관련 옵션들을 개별적으로 켠다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">strict</code> 옵션은 그 자체로 어떤 역할을 하는 것이 아니라, 다른 Strict 관련 옵션들을 일괄적으로 켜고 끌 수 있는 옵션이다. <code class=\"language-text\">strict</code> 옵션으로 켜고 끌 수 있는 일명 Strict mode family는 다음과 같다.</p>\n<hr>\n<ul>\n<li><a href=\"#alwaysstrict\">alwaysStrict</a></li>\n<li><a href=\"#strictbindcallapply\">strictBindCallApply</a></li>\n<li><a href=\"#strictfunctiontypes\">strictFunctionTypes</a></li>\n<li><a href=\"#strictnullchecks\">strictNullChecks</a></li>\n<li><a href=\"#strictpropertyinitialization\">strictPropertyInitialization</a></li>\n<li><a href=\"#useunknownincatchvariables\">useUnknownInCatchVariables</a></li>\n<li><a href=\"#noimplicitany\">noImplicitAny</a></li>\n<li><a href=\"#noimplicitthis\">noImplictThis</a></li>\n</ul>\n<hr>\n<p>만약 <code class=\"language-text\">strict</code> 옵션을 <code class=\"language-text\">true</code>로 설정하면 Strict mode family 옵션들의 값도 함께 <code class=\"language-text\">true</code>로 적용되지만, 만약 개별 옵션을 <code class=\"language-text\">false</code>로 오버라이딩한다면 해당 옵션만 끌 수도 있다.</p>\n<p>타입스크립트 팀은 추후 배포될 타입스크립트 버전에 추가되는 새로운 Strict mode family 옵션도 모두 <code class=\"language-text\">strict</code> 옵션으로 관리할 수 있도록 만들 예정이라고 하니, 타입스크립트 버전을 업데이트하게 되면 기존에는 없던 새로운 타입 에러가 발생할 수도 있다는 사실을 유념하도록 하자.</p>\n<h2 id=\"etc\" style=\"position:relative;\">etc<a href=\"#etc\" aria-label=\"etc permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이 섹션은 필자가 옵션들을 정리하면서, 카테고라이징을 하기 애매하다고 생각한 옵션들을 모아둔 섹션이다. 물론 이 옵션들 또한 안전한 프로그래밍에 큰 도움이 되는 옵션들이기 때문에 가급적 켜는 것을 추천한다.</p>\n<h3 id=\"exactoptionalpropertytypes\" style=\"position:relative;\">exactOptionalPropertyTypes<a href=\"#exactoptionalpropertytypes\" aria-label=\"exactoptionalpropertytypes permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>옵셔널 프리픽스가 정말로 객체 내에 없다는 것을 보장한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>옵셔널 프리픽스를 사용한 값에 <code class=\"language-text\">undefined</code>를 할당하는 것을 허용한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">exactOptionalPropertyTypes</code> 옵션은 <code class=\"language-text\">?</code> 프리픽스로 표현되는 타입이나 인터페이스 내부의 옵셔널 프로퍼티를 얼마나 엄격하게 처리할 지를 결정하는 옵션이다. 한번 같이 예시를 보면서 어떤 차이점이 있는지 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserDefaults</span> <span class=\"token punctuation\">{</span>\n  color<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token string\">\"dark\"</span> <span class=\"token operator\">|</span> <span class=\"token string\">\"light\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위 인터페이스가 가지고 있는 <code class=\"language-text\">color</code> 프로퍼티는 <code class=\"language-text\">?</code>로 표현되는 옵셔널 프리픽스와 함께 선언되었기 때문에, 해당 프로퍼티가 인터페이스 내에 존재할 수도 있고 없을 수도 있다는 것을 표현하고 있다. 그렇기 때문에 기본적으로 타입스크립트는 이 프로퍼티의 타입을 <code class=\"language-text\">dark | light | undefiend</code>로 평가하게 된다.</p>\n<p>여기서 약간 모순이 생기는데, 옵셔널 프로퍼티는 사실 “이 프로퍼티가 있을 수도 있고 없을 수도 있어”라는 의미이지, “이 프로퍼티가 존재는 하는데 값이 <code class=\"language-text\">undefined</code>야”라는 의미가 아니기 때문이다. 그러나 타입스크립트에서는 옵셔널로 선언된 프로퍼티에 <code class=\"language-text\">undefined</code>를 직접 할당함으로써 옵셔널 프로퍼티의 조건을 만족시킬 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> user<span class=\"token operator\">:</span> UserDefaults <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  color<span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// dark | light | undefined</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>하지만 <code class=\"language-text\">exactOptionalPropertyTypes</code> 옵션을 켜게 되면 이제 이런 행위가 불가능해진다. 개발자는 옵셔널 프로퍼티로 선언된 프로퍼티에 <code class=\"language-text\">undefined</code>를 할당할 수 없으며, 만약 할당을 시도했다가는 다음과 같은 에러를 만나며 컴파일러에게 혼쭐이 나게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> user<span class=\"token operator\">:</span> UserDefaults <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Type 'undefined' is not assignable to type '\"light\" | \"dark\"'.ts(2322)</span>\n  color<span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이때 컴파일러가 던진 에러 메세지를 보면, 기존에는 <code class=\"language-text\">dark | light | undefeind</code>와 같이 <code class=\"language-text\">undefined</code>까지 유니온 타입으로 묶어서 선언하던 방식과 다르게, 타입 자체는 <code class=\"language-text\">dark | light</code>으로만 정의되어있고 키의 존재 유무로만 옵셔널 프로퍼티를 판단하는 모습을 볼 수 있다.</p>\n<h3 id=\"nofallthroughcasesinswitch\" style=\"position:relative;\">noFallthroughCasesInSwitch<a href=\"#nofallthroughcasesinswitch\" aria-label=\"nofallthroughcasesinswitch permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">switch</code> 문 내에 Fallthrough 케이스가 존재하면 경고를 보여준다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td><code class=\"language-text\">switch</code> 문 내에 Fallthrough 케이스가 존재해도 무시한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noFallthroughCasesInSwitch</code> 옵션은 Fallthrough, 즉 <code class=\"language-text\">switch</code> 문이 완료되지 않는 케이스가 존재하는 경우에 경고를 보여줄 지에 대한 옵션이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> v<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token operator\">:</span>\n    <span class=\"token comment\">// Fallthrough case in switch.ts(7029)</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token operator\">:</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 경우 첫 번째 케이스 문이 수행되고 <code class=\"language-text\">switch</code> 문이 종료되는 것이 아니라, 이에 이어서 두 번째 케이스 문까지 수행되기 때문에, 개발자가 의도하지 않은 동작이 되어버릴 가능성이 존재한다.</p>\n<p>이렇게 <code class=\"language-text\">switch</code> 문을 종료시키지 않고 다음 케이스로 그냥 흘려버리는 케이스를 <code class=\"language-text\">Fallthrough case</code>라고 부르는데, C++이나 Swift 같은 언어에서는 이런 케이스에 명시적으로 <code class=\"language-text\">[[fallthrough]]</code>와 같은 키워드를 작성하게 함으로써 개발자가 한 눈에 “이 케이스 문은 다음 케이스까지 실행시키겠구나”라는 것을 알 수 있지만, 자바스크립트는 이렇게 명시적으로 Fallthrough case를 표현하는 문법이 없기 때문에 개발자가 실수하기 쉬운 구조이다.</p>\n<p>그래서 타입스크립트는 이런 Fallthrough case가 발생했을 때 경고를 보여주는  <code class=\"language-text\">noFallthroughCasesInSwitch</code> 옵션을 제공함으로써 개발자가 Fallthrough case를 확실하게 인지할 수 있도록 도와주고 있다.</p>\n<h3 id=\"nopropertyaccessfromindexsignature\" style=\"position:relative;\">noPropertyAccessFromIndexSignature<a href=\"#nopropertyaccessfromindexsignature\" aria-label=\"nopropertyaccessfromindexsignature permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>인덱스 시그니처로 선언된 프로퍼티에 <code class=\"language-text\">.</code> 문법을 사용하여 접근하는 것을 방어한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>인덱스 시그니처로 선언된 프로퍼티에 <code class=\"language-text\">.</code> 문법을 사용하여 접근하는 것을 허용한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noPropertyAccessFromIndexSignature</code> 옵션은 인터페이스나 타입에 미리 정의되지 않은 프로퍼티에 <code class=\"language-text\">.</code> 문법을 사용하여 접근하는 것을 방어한다.</p>\n<p>물론 아예 정의되지 않은 프로퍼티에 접근한다는 상황은 당연히 에러가 나야하는 상황이지만, 이 옵션이 관여하는 상황은 조금 애매하게 타입 선언이 되어있는 경우이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">GameSettings</span> <span class=\"token punctuation\">{</span>\n  speed<span class=\"token operator\">:</span> <span class=\"token string\">'fast'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'medium'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'slow'</span><span class=\"token punctuation\">;</span>\n  quality<span class=\"token operator\">:</span> <span class=\"token string\">'high'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'low'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">GameSettings</code> 인터페이스는 명확하게 선언된 <code class=\"language-text\">speed</code>와 <code class=\"language-text\">quality</code>라는 프로퍼티와, <code class=\"language-text\">[key: string]: string</code> 이라는 인덱스 시그니처 프로퍼티를 가지고 있다. 이렇게 인덱스 시그니처로 선언한 프로퍼티는 키의 타입과 값의 타입이 <code class=\"language-text\">string</code> 타입이만 하면 모든 것을 허용하겠다는 것과 마찬가지이므로 모호한 타입이라고 하는 것이다.</p>\n<p>이런 타입 정의를 바탕으로 개발자가 <code class=\"language-text\">GameSettings</code> 타입인 객체의 프로퍼티에 접근하는 상황을 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> getSettings <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> GameSettings <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    speed<span class=\"token operator\">:</span> <span class=\"token string\">'fast'</span><span class=\"token punctuation\">,</span>\n    quality<span class=\"token operator\">:</span> <span class=\"token string\">'high'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> settings <span class=\"token operator\">=</span> <span class=\"token function\">getSettings</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsettings<span class=\"token punctuation\">.</span>speed<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Good</span>\nsettings<span class=\"token punctuation\">.</span>quality<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Good</span>\nsettings<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Good...?</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시에서 개발자는 <code class=\"language-text\">GameSettings</code> 타입인 <code class=\"language-text\">settings</code> 객체의 프로퍼티들에 접근하고 있다. 물론 명확하게 선언된 <code class=\"language-text\">speed</code>와 <code class=\"language-text\">quality</code> 프로퍼티는 반드시 존재하는 것이 확실하지만, <code class=\"language-text\">settings.user</code>는 다르다.</p>\n<p>이 프로퍼티는 <code class=\"language-text\">[key: string]: string</code> 이라는 타입 선언에 의존하고 있는 녀석이기 때문에, 이 값이 명확히 존재한다고 말할 수 없기 때문이다.</p>\n<p><code class=\"language-text\">noPropertyAccessFromIndexSignature</code> 옵션은 이처럼 반드시 존재하는 프로퍼티는 <code class=\"language-text\">.</code> 문법을 통해 접근할 수 있게 하되, 존재하지 않을 가능성이 있는 프로퍼티는 <code class=\"language-text\">settings['user']</code>와 같은 Index 문법을 사용하여 접근하도록 함으로써 이 두 가지 케이스를 구분하도록 강제한다.</p>\n<h3 id=\"nouncheckedindexedaccess\" style=\"position:relative;\">noUncheckedIndexedAccess<a href=\"#nouncheckedindexedaccess\" aria-label=\"nouncheckedindexedaccess permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td>인덱스 시그니처로 선언된 프로퍼티를 Optional 타입으로 평가한다.</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">false</code> (default)</td>\n<td>인덱스 시그니처로 선언된 프로퍼티도 정의된 타입으로만 평가한다.</td>\n</tr>\n</tbody>\n</table>\n<p><code class=\"language-text\">noUncheckedIndexedAccess</code> 옵션은 인덱스 시그니처로 선언한 프로퍼티를 어떻게 추론할 것인지에 대한 옵션이다.</p>\n<p>기본적으로 타입스크립트는 <code class=\"language-text\">[key: string]: string</code> 처럼 인덱스 시그니처로 선언된 프로퍼티가 있다면, 딱 선언된 대로만 추론해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">EnvironmentVars</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n \n<span class=\"token keyword\">const</span> env<span class=\"token operator\">:</span> EnvironmentVars <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> nodeEnv <span class=\"token operator\">=</span> env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// string</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>하지만 앞서 말했듯이 인덱스 시그니처로 선언된 프로퍼티는 실제로는 있을 수도 있고 없을 수도 있는 옵셔널한 값이다. 즉, <code class=\"language-text\">env.NODE_ENV</code>의 타입은 사실 <code class=\"language-text\">string</code>이 아니라 <code class=\"language-text\">string | undefined</code>인 것이다.</p>\n<p><code class=\"language-text\">noUncheckedIndexedAccess</code> 옵션은 이렇게 인덱스 시그니처로 선언한 프로퍼티를 <code class=\"language-text\">T | undefined</code> 타입으로 평가하여 혹시나 발생할 수 있는 런타임 레퍼런스 에러를 방지해준다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>타입스크립트의 타입 체킹 컴파일 옵션들은 높은 타입 안정성을 유지할 수 있도록 도움을 주는 녀석들이지만, 타입스크립트와 같은 정적 타이핑 언어 자체에 익숙하지 않은 개발자에게는 가파른 러닝 커브로 다가올 수도 있는 부분이다.</p>\n<p>또한 처음 프로젝트를 생성할 때부터 타입스크립트를 사용하는 경우도 있지만, 자바스크립트를 사용하다가 점진적으로 타입스크립트를 도입하고 있는 조직도 존재하기 때문에, 이렇게 다양한 옵션을 제공하여 개발자가 원하는 정적 타이핑 환경을 구축할 수 있게 해주는 것은 큰 장점이라고 생각한다. <small><del>(물론 옵션도 공부해야 함…)</del></small></p>\n<p><a href=\"/2021/08/22/tsconfig-compiler-options-modules/\">다음 포스팅</a>에서는 컴파일 옵션 중에서도 타입스크립트가 컴파일을 수행할 때 “어떤 소스코드를 어떤 방식으로 컴파일하여 결과물을 만들어 낼 지에 관여하는 옵션들”에 대해서 이야기해보도록 하겠다.</p>\n<p>이상으로 [tsconfig의 모든 것] Compiler options / Type Checking 포스팅을 마친다.</p>","fields":{"slug":"20210808-tsconfig-compiler-options-type-check","path":"/2021/08/08/tsconfig-compiler-options-type-check/","lang":"ko"},"frontmatter":{"title":"[tsconfig의 모든 것] Compiler options / Type Checking","subTitle":"타입 검사의 강도와 안정성, 실무에서 체감되는 옵션들의 차이","date":"Aug 08, 2021","categories":["프로그래밍","튜토리얼","자바스크립트"],"tags":["TypeScript","타입스크립트","tsconfig"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/56bd7d19cbdec50908e5f57ff0589f62/d803c/thumbnail.png","srcSet":"/static/56bd7d19cbdec50908e5f57ff0589f62/d803c/thumbnail.png 320w,\n/static/56bd7d19cbdec50908e5f57ff0589f62/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/56bd7d19cbdec50908e5f57ff0589f62/fc5c5/thumbnail.webp 320w,\n/static/56bd7d19cbdec50908e5f57ff0589f62/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/56bd7d19cbdec50908e5f57ff0589f62/01fb2/thumbnail.png","srcSet":"/static/56bd7d19cbdec50908e5f57ff0589f62/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/56bd7d19cbdec50908e5f57ff0589f62/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"0ac439ab-855f-5520-af64-44ebedcb8b80","tableOfContents":"<ul>\n<li><a href=\"#include\">include</a></li>\n<li><a href=\"#files\">files</a></li>\n<li><a href=\"#exclude\">exclude</a></li>\n<li><a href=\"#extends\">extends</a></li>\n<li><a href=\"#references\">references</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","excerpt":"필자가 타입스크립트를 사용하게 된 지도 어언 4년 정도가 지났다. 필자는 자바스크립트에는 없던 타입스크립트가 제공하는 강력한 정적 타입 검사 기능에 흠뻑 빠져버렸고, 지금까지 꽤 많은 프로젝트들을 타입스크립트로 작성해왔다.","html":"<p>필자가 타입스크립트를 사용하게 된 지도 어언 4년 정도가 지났다. 필자는 자바스크립트에는 없던 타입스크립트가 제공하는 강력한 정적 타입 검사 기능에 흠뻑 빠져버렸고, 지금까지 꽤 많은 프로젝트들을 타입스크립트로 작성해왔다.</p>\n<!-- more -->\n<p>그러다가 며칠 전 타입스크립트로 작성한 프로젝트를 새롭게 만들게 되면서 평소처럼 자연스럽게 <code class=\"language-text\">tsconfig</code>를 세팅하고 있었는데, 뭔가 마음처럼 잘 안되어서 <a href=\"https://www.typescriptlang.org/tsconfig\" target=\"_blank\" rel=\"nofollow\">tsconfig 공식 문서</a>를 한참 들여다보던 중 문득 이런 생각이 들었다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5fe0821bc535c0c02b3be547c5507fb8/7bf67/jordan-peele.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHlNNiqGkC//8QAGhAAAgIDAAAAAAAAAAAAAAAAAQIAAxARIf/aAAgBAQABBQIjTNg9iypQV//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/Aar/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAEAAwAAAAAAAAAAAAAAAAAAASAx/9oACAEBAAY/AkUx/8QAGBABAAMBAAAAAAAAAAAAAAAAAQARITH/2gAIAQEAAT8hG5ex2OHCabs3Y6Syttn/2gAMAwEAAgADAAAAEKjv/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAh/9oACAEDAQE/EMBH/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAgEBPxB5So//xAAbEAEAAwEAAwAAAAAAAAAAAAABABFBITFRcf/aAAgBAQABPxBRQTZsIZvplZEPynD7tjX44cc5GAlctn//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"jordan peele\" title=\"\" src=\"/static/5fe0821bc535c0c02b3be547c5507fb8/c08c5/jordan-peele.jpg\" srcset=\"/static/5fe0821bc535c0c02b3be547c5507fb8/0913d/jordan-peele.jpg 160w,\n/static/5fe0821bc535c0c02b3be547c5507fb8/cb69c/jordan-peele.jpg 320w,\n/static/5fe0821bc535c0c02b3be547c5507fb8/c08c5/jordan-peele.jpg 640w,\n/static/5fe0821bc535c0c02b3be547c5507fb8/7bf67/jordan-peele.jpg 680w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>어...? 내가 이걸 진짜 알고 쓰는 게 맞나...?</small>\n</center>\n<p>필자만 그런 것일 수도 있지만, 사실 이런저런 프로젝트를 만들다보면 <code class=\"language-text\">tsconfig</code>를 직접 손으로 한땀 한땀 작성하는 경우가 많지는 않게 되는 것 같다.</p>\n<p>물론 맨 처음 타입스크립트로 프로젝트를 개발했을 때는 손수 정성을 들여 작성했을 것이다. <small><del>(사실 오래 되서 잘 기억이…)</del></small> 하지만 언젠가부터는 그냥 기존에 잘 돌아가고 있는 프로젝트의 <code class=\"language-text\">tsconfig</code>를 복붙해서 새로운 프로젝트에 꽂아넣고 약간의 커스터마이징만 직접 해주는 방식으로 프로젝트를 세팅하고 있었던 것이다.</p>\n<p>그래서 다시 초심으로 돌아가 <code class=\"language-text\">tsconfig</code>에 있는 옵션들이 내 타입스크립트 프로젝트에 어떤 영향을 주는 지 한번 찬찬히 뜯어보려고 한다.</p>\n<p>사실 <code class=\"language-text\">tsconfig</code>의 모든 것을 하나의 포스팅으로 풀어내고 싶었지만, 이 놈의 컴파일 옵션들이 워낙 많다보니 포스팅이 500줄이 넘어가는 슬픈 상황을 마주하게 되었으므로, 이번 포스팅에서는 <code class=\"language-text\">tsconfig</code>의 루트에 있는 필드들에 대해서만 자세히 알아보고, 이후 다른 포스팅에서 컴파일 옵션들에 대한 설명을 이어가도록 하겠다.</p>\n<h2 id=\"include\" style=\"position:relative;\">include<a href=\"#include\" aria-label=\"include permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">string[]</code></td>\n<td><code class=\"language-text\">[]</code>, <code class=\"language-text\">['**/*']</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"include\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"src/**/*\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"tests/**/*\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">include</code> 필드는 타입스크립트 어플리케이션에 포함할 파일 목록을 선언할 때 사용하며, <code class=\"language-text\">files</code> 필드의 존재 여부에 따라 기본값이 변경되는데, 만약 <code class=\"language-text\">ㅋ</code> 필드가 선언되어 있다면 <code class=\"language-text\">[]</code>로, 선언되어 있지 않다면 <code class=\"language-text\">[\"**/*\"]</code>으로 기본 값이 설정된다.</p>\n<p>이 필드는 <code class=\"language-text\">files</code> 필드와 하는 일이 비슷하지만, <code class=\"language-text\">include</code> 필드에는 glob 문법을 사용하여 포함할 파일 경로의 패턴을 표현할 수 있기 때문에 일반적으로는 <code class=\"language-text\">files</code> 보다 <code class=\"language-text\">include</code>를 주로 사용한다.</p>\n<p>glob 문법은 <code class=\"language-text\">*</code>이나 <code class=\"language-text\">?</code> 같은 와일드 카드를 사용하여 여러 파일 이름의 패턴을 나타내게 되는데, 문법 자체는 정규 표현식과 유사하기 때문에 익히기에 크게 어렵지 않다.</p>\n<table>\n<thead>\n<tr>\n<th>와일드카드</th>\n<th>설명</th>\n<th>예시</th>\n<th>일치하는 파일이름</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">*</code></td>\n<td><code class=\"language-text\">/</code>를 제외한 0번 이상 나타나는 문자를 매칭</td>\n<td><code class=\"language-text\">types*.ts</code></td>\n<td>types.d.ts, types.ts, types.test.ts</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">**</code></td>\n<td><code class=\"language-text\">/</code>를 포함한 0번 이상 나타나는 문자를 매칭</td>\n<td><code class=\"language-text\">src/**/index.ts</code></td>\n<td>src/index.ts, src/utils/index.ts, src/test/index.ts</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">?</code></td>\n<td>하나의 문자를 매칭, 정규식의 <code class=\"language-text\">.</code>과 동일</td>\n<td><code class=\"language-text\">?at.ts</code></td>\n<td>Cat.ts, Bat.ts, Rat.ts</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">[ab]</code></td>\n<td><code class=\"language-text\">[]</code> 안에 있는 문자 중 하나를 매칭</td>\n<td>`[C</td>\n<td>B]at.ts`</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">[a-z]</code></td>\n<td><code class=\"language-text\">[]</code> 안에 있는 문자의 범위</td>\n<td><code class=\"language-text\">test[0-9].ts</code></td>\n<td>test0.ts, test1.ts, test9.ts</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">{ab,bc}</code></td>\n<td><code class=\"language-text\">{}</code> 안에 있는 문자열 중 하나를 매칭</td>\n<td><code class=\"language-text\">*.{ts,tsx}</code></td>\n<td>foo.ts, foo.tsx</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">{ab,bc}</code></td>\n<td><code class=\"language-text\">{}</code> 안에 있는 문자열 중 하나를 매칭</td>\n<td><code class=\"language-text\">*.{ts,tsx}</code></td>\n<td>foo.ts, foo.tsx</td>\n</tr>\n</tbody>\n</table>\n<p>glob 문법은 파일 경로를 통해 원하는 파일을 잡아내야하는 거의 모든 상황에서 유용하게 사용되기 때문에, 한번만 익숙해지고 나면 앞으로 프로그래밍을 하면서 만나게 될 설정 파일들이 조금은 친숙하게 다가올 것이다.</p>\n<h2 id=\"files\" style=\"position:relative;\">files<a href=\"#files\" aria-label=\"files permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">string[]</code></td>\n<td><code class=\"language-text\">false</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"files\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"./src/index.ts\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"./src/utils.ts\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"./src/models.ts\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">files</code> 필드는 타입스크립트 어플리케이션에 포함할 파일 목록을 명시적으로 선언할 때 사용한다. <code class=\"language-text\">includes</code> 필드와 비슷하지만, <code class=\"language-text\">files</code> 필드는 <code class=\"language-text\">src/**/*</code>와 같은 glob 문법을 사용할 수 없기 때문에, 일일히 파일명을 입력해줘야 한다는 단점이 있다.</p>\n<p>만약 <code class=\"language-text\">files</code> 필드에 값이 존재한다면 <code class=\"language-text\">includes</code> 필드의 기본 값은 <code class=\"language-text\">['**/*']</code>에서 빈 배열인 <code class=\"language-text\">[]</code>으로 변경된다. 즉, 기존에 <code class=\"language-text\">includes</code> 필드의 기본 값에 의존하고 있었다면, <code class=\"language-text\">files</code> 필드에 값을 추가함으로써 컴파일 결과물이 완전히 달라질 수 있으니 이 점을 유의해야 한다.</p>\n<h2 id=\"exclude\" style=\"position:relative;\">exclude<a href=\"#exclude\" aria-label=\"exclude permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">string[]</code></td>\n<td><code class=\"language-text\">['node_modules', 'bower_components', 'jspm_packages']</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"include\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"src/**/*\"</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"exclude\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"src/**/*.test.ts\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"node_modules\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">exclude</code> 필드는 “제외하다”라는 사전적 의미 그대로 <code class=\"language-text\">include</code> 필드에 선언한 파일들 중에서 “이 파일들은 포함하지마”라는 설정을 할 때 사용한다.</p>\n<p>이 필드의 기본 값인 <code class=\"language-text\">node_modules</code>, <code class=\"language-text\">bower_components</code>, <code class=\"language-text\">jspm_packages</code> 라는 친구들을 보면 알 수 있겠지만, 보통 타입스크립트로 작성된 패키지는 <code class=\"language-text\">js</code> + <code class=\"language-text\">*.d.ts</code> 파일들의 조합으로 빌드해서 배포하기 때문에, 타입스크립트는 기본적으로 이런 외부 패키지들이 빌드가 되어있다고 가정하고 있는 것이다.</p>\n<p>만약 외부에서 받아온 패키지도 컴파일이 필요한 상황이라면 <code class=\"language-text\">exclude</code> 필드를 수정해주면 된다. <small>(참고로 <code class=\"language-text\">Next.js</code>는 이 필드에 기본적으로 <code class=\"language-text\">node_modules</code>가 포함되어 있도록 프로젝트를 세팅하고, 이 값을 지워도 빌드할 때 자동으로 다시 넣어버린다…)</small></p>\n<p>그리고 한 가지 중요한 점은 <code class=\"language-text\">exlucde</code> 필드는 단지 <code class=\"language-text\">include</code> 필드에 세팅해준 파일들을 찾아올 때 “이건 찾지마”라는 의미이기 때문에 이 필드에 넣어준 파일들이라고 해서 반드시 내 어플리케이션에 포함되지 않는 것이 아니라는 것이다.</p>\n<p>즉, <code class=\"language-text\">exlucde</code> 필드에 <code class=\"language-text\">node_modules</code> 같은 디렉토리가 세팅되어있다고 해도 코드 내에서 import 문을 사용하여 직접 해당 모듈을 가져오는 경우나 <code class=\"language-text\">/// &lt;reference path=\"...\" /></code> 처럼 트리플 슬래시 디렉티브를 사용하여 컴파일러에게 특정 모듈을 포함하라고 직접 지시하는 경우, 그리고 <code class=\"language-text\">files</code> 필드를 사용하여 직접 컴파일할 파일을 명시하는 경우에는 <code class=\"language-text\">exlucde</code> 필드에 뭘 세팅했던 무시하고 해당 모듈을 가져온다.</p>\n<h2 id=\"extends\" style=\"position:relative;\">extends<a href=\"#extends\" aria-label=\"extends permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">string</code></td>\n<td><code class=\"language-text\">false</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.base.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"noImplicitAny\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"strictNullChecks\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// tsconfig.base.json의 설정을 가져와서 확장한다.</span>\n  <span class=\"token property\">\"extends\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./tsconfig.base.json\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"files\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"./src/main.ts\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">extends</code> 필드는 이름 그대로 다른 <code class=\"language-text\">tsconfig</code>의 경로를 지정하면 해당 <code class=\"language-text\">tsconfig</code>를 상속할 수 있는 필드이다. 필자 같은 경우에는 다른 사람이 미리 만들어 놓은 설정을 가져와서 조금 커스터마이징하는 상황이나, 모노 레포지토리에 포함된 모든 프로젝트에 공통적으로 적용하고 싶은 설정이 있는 경우에 주로 사용했던 것 같다.</p>\n<p>만약 상속 대상인 <code class=\"language-text\">tsconfig.base.json</code>의 내부 필드에 <code class=\"language-text\">./src</code>와 같은 상대 경로가 지정되어 있는 경우에는 해당 상속 파일을 불러온 주체인 <code class=\"language-text\">tsconfig.json</code> 기준으로 상대 경로가 계산된다.</p>\n<p>또한 이렇게 다른 <code class=\"language-text\">tsconfig</code>를 상속하여 새로운 <code class=\"language-text\">tsconfig</code>를 정의하는 경우, <code class=\"language-text\">files</code>, <code class=\"language-text\">include</code>, <code class=\"language-text\">exclude</code> 처럼 배열을 사용하여 선언된 필드들은 확장되는 것이 아니라 필드 자체가 덮어씌워지기 때문에 이 점을 유의해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.base.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"files\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"./src/main.ts\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"extends\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./tsconfig.base.json\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"files\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"./src/index.ts\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그러므로 위의 예시 같은 상황이라면 최종 <code class=\"language-text\">files</code>필드는 <code class=\"language-text\">[\"./src/main.ts\", \"./src/index.ts\"]</code>로 합쳐지는 것이 아니라 <code class=\"language-text\">[\"./src/index.ts\"]</code>로 평가된다. <code class=\"language-text\">extends</code>라는 필드 이름을 보면 왠지 필드의 값도 확장해줄 것 같지만, 아무런 경고나 에러도 없이 그냥 쿨하게 오버라이팅 해버리므로 주의하도록 하자.</p>\n<h2 id=\"references\" style=\"position:relative;\">references<a href=\"#references\" aria-label=\"references permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">Array&lt;{ path: string; prepend: boolean; }></code></td>\n<td><code class=\"language-text\">false</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// my-project/test/tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"references\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token comment\">// my-project/src/tsconfig.json을 참조한다</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token property\">\"path\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"../src\"</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">reference</code> 필드는 같은 프로젝트 안에서 모듈 별로 여러 개의 <code class=\"language-text\">tsconfig</code>를 사용하는 경우, 이 모듈들의 참조 관계를 표현하기 위한 필드이다. 보통 하나의 프로젝트에서는 하나의 <code class=\"language-text\">tsconfig</code>만 사용하는 경우가 많기 때문에 거의 사용할 일이 없기는 하다.</p>\n<p>사실 타입스크립트가 이런 옵션을 제공하는 이유는 바로 이런 경우 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">├── src/\n│   ├── converter.ts\n│   └── units.ts\n├── test/\n│   ├── converter-tests.ts\n│   └── units-tests.ts\n└── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 프로젝트는 소스 코드와 테스트 코드가 별도의 디렉토리로 분리되어있고, 루트에는 하나의 <code class=\"language-text\">tsconfig</code>가 전체 프로젝트의 컴파일 옵션을 관리하고 있다. 이런 구조의 프로젝트는 상당히 흔한 구조이기는 하지만, 막상 이렇게 만들어놓고 개발을 하다보면 몇 가지 불편한 점이 생긴다.</p>\n<blockquote>\n<ol>\n<li>소스 코드인 <code class=\"language-text\">src</code> 모듈에서도 테스트 코드인 <code class=\"language-text\">test</code> 모듈을 불러올 수가 있음…</li>\n<li>소스 코드에서 절대 오류가 발생하지 않는 부분을 수정했는데도 테스트 코드까지 다시 타입 검사해야 함…</li>\n<li>반대로 테스트 코드를 고치면 소스 코드까지 다시 타입 검사해야 함…</li>\n</ol>\n</blockquote>\n<p>물론 평소라면 어느 정도 감당이 가능한 불편함이기는 하지만, 프로젝트의 크기가 커지면 커질 수록 컴파일러의 타입 검사도 비례해서 느려지기 때문에 어느 순간부터는 개발 자체에 어려움을 느낄 수도 있다. 그렇다면 프로젝트의 모듈마다 <code class=\"language-text\">tsconfig</code>를 만들어 두고 따로 컴파일하면 어떨까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">├── src/\n│   ├── converter.ts\n│   ├── units.ts\n│   └── tsconfig.json\n└── test/\n    ├── converter-tests.ts\n    ├── units-tests.ts\n    └── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 각각의 모듈 별로 <code class=\"language-text\">tsconfig</code>를 가지도록 구성하면 위에서 이야기했던 문제들은 어느 정도 해결된다. 하지만 이 경우에는 각각의 모듈 별로 따로 컴파일해줘야 하는데다가, 기본적으로 <code class=\"language-text\">tsc</code>는 하나의 프로세스만 띄울 수 있도록 만들어졌기 때문에 동시에 여러 개의 <code class=\"language-text\">tsconfig</code>를 토대로 빌드를 하거나 소스 코드의 변경 사항을 감시하는 것이 불가능하다.</p>\n<p>그래서 타입스크립트 팀에서는 <code class=\"language-text\">references</code>라는 필드로 이 문제를 해결하려고 하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// my-project/test/tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"references\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token comment\">// my-project/src/tsconfig.json을 참조한다</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token property\">\"path\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"../src\"</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 예시는 <code class=\"language-text\">references</code> 필드를 사용하여 <code class=\"language-text\">test</code> 모듈에서 <code class=\"language-text\">src</code> 모듈을 참조하고 있다는 것을 표현하고 있다. 이때 <code class=\"language-text\">test</code> 모듈에서 <code class=\"language-text\">src</code> 모듈에 있는 하위 모듈들을 불러오게 되면 소스 코드인 <code class=\"language-text\">*.ts</code>가 아니라 빌드가 완료된 결과물인 <code class=\"language-text\">*.d.ts</code> 파일을 가져온다. <small>(<code class=\"language-text\">tsc --build</code>를 사용하면 해당 모듈의 최신 상태를 감지하고 증분 빌드도 해준다.)</small></p>\n<p>프로젝트 레퍼런스에 대한 자세한 내용은 이 포스팅의 주제는 아니니, 더 궁금하신 분들은 타입스크립트 공식 문서의 <a href=\"https://www.typescriptlang.org/docs/handbook/project-references.html\" target=\"_blank\" rel=\"nofollow\">Project Referneces</a> 문서를 확인해보도록 하자.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이번 포스팅에서는 <code class=\"language-text\">tsconfig</code>의 루트에 있는 몇 가지 필드들의 역할을 알아보았다. 사실 하나의 포스팅으로 <code class=\"language-text\">tsconfig</code>를 깔끔하게 정리하고 싶었는데, 이 친구가 워낙 방대한 옵션들을 가지고 계신지라 부득이하게 여러 개의 포스팅으로 나눠서 집필하게 되었다.</p>\n<p>이어지는 <a href=\"/2021/08/08/tsconfig-compiler-options-type-check/\">다음 포스팅</a>에서는 타입스크립트의 컴파일 옵션들 중 타입 체크에 관한 옵션들에 대해서 이야기해보도록 하겠다.</p>\n<p>이상으로 [tsconfig의 모든 것] Root fields 포스팅을 마친다.</p>","fields":{"slug":"20210730-tsconfig-options-root-fields","path":"/2021/07/30/tsconfig-options-root-fields/","lang":"ko"},"frontmatter":{"title":"[tsconfig의 모든 것] Root fields","subTitle":"복붙하던 tsconfig를 다시 읽다 - 루트 필드가 만드는 프로젝트의 기준점","date":"Jul 30, 2021","categories":["프로그래밍","튜토리얼","자바스크립트"],"tags":["TypeScript","타입스크립트","tsconfig"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/18562cf9f40ec5572baa9105e9ecddbd/d803c/thumbnail.png","srcSet":"/static/18562cf9f40ec5572baa9105e9ecddbd/d803c/thumbnail.png 320w,\n/static/18562cf9f40ec5572baa9105e9ecddbd/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/18562cf9f40ec5572baa9105e9ecddbd/fc5c5/thumbnail.webp 320w,\n/static/18562cf9f40ec5572baa9105e9ecddbd/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/18562cf9f40ec5572baa9105e9ecddbd/01fb2/thumbnail.png","srcSet":"/static/18562cf9f40ec5572baa9105e9ecddbd/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/18562cf9f40ec5572baa9105e9ecddbd/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"tsconfig","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}