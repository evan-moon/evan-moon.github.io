{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/pure-functions/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"3e41aa97-cbc8-576b-b589-204ba89ff96d","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EC%99%80-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%80-%EB%AC%B4%EC%8A%A8-%EA%B4%80%EA%B3%84%EC%9D%B8%EA%B0%80%EC%9A%94\">순수 함수와 불변성은 무슨 관계인가요?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\">불변성이란?</a></p>\n<ul>\n<li><a href=\"#%EC%9A%B0%EB%A6%AC%EB%8A%94-%EB%B3%80%EC%88%98%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%9C%EB%8B%A4\">우리는 변수를 통해 메모리에 접근한다</a></li>\n<li><a href=\"#%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C%EA%B3%BC-%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C\">값에 의한 호출과 참조에 의한 호출</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%ED%82%A4%EB%A9%B4-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%9D%B4-%EC%A2%8B%EC%9D%80%EA%B0%80%EC%9A%94\">불변성을 지키면 어떤 점이 좋은가요?</a></p>\n<ul>\n<li><a href=\"#%EB%AC%B4%EB%B6%84%EB%B3%84%ED%95%9C-%EC%83%81%ED%83%9C%EC%9D%98-%EB%B3%80%EA%B2%BD%EC%9D%84-%EB%A7%89%EB%8A%94%EB%8B%A4\">무분별한 상태의 변경을 막는다</a></li>\n<li><a href=\"#%EC%83%81%ED%83%9C%EC%9D%98-%EB%B3%80%EA%B2%BD%EC%9D%84-%EC%B6%94%EC%A0%81%ED%95%98%EA%B8%B0%EA%B0%80-%EC%89%BD%EB%8B%A4\">상태의 변경을 추적하기가 쉽다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%98%84%EC%8B%A4%EC%A0%81%EC%9D%B8-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%98-%EC%83%81%ED%99%A9\">현실적인 불변성의 상황</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 순수 함수에 이어 함수형 프로그래밍에서 중요하게 여기는 개념인 불변성(Immutable)에 대한 이야기를 해보려고 한다. 사실 순수 함수를 설명하다보면 불변성에 대한 이야기가 꼭 한번은 나오게 되는데, 대부분 “상태를 변경하지 않는 것”이라는 짧은 정의로 설명하거나, 혹은 불변성을 해치는 행위들을 예시로 들고 이런 행위들을 금지 행위로 규정하며 설명을 진행하게된다.","html":"<p>이번 포스팅에서는 순수 함수에 이어 함수형 프로그래밍에서 중요하게 여기는 개념인 불변성(Immutable)에 대한 이야기를 해보려고 한다.</p>\n<p>사실 순수 함수를 설명하다보면 불변성에 대한 이야기가 꼭 한번은 나오게 되는데, 대부분 “상태를 변경하지 않는 것”이라는 짧은 정의로 설명하거나, 혹은 불변성을 해치는 행위들을 예시로 들고 이런 행위들을 금지 행위로 규정하며 설명을 진행하게된다.</p>\n<!-- more -->\n<p>그러나 개인적으로 이런 설명 방식은 상태와 메모리에 대한 개념이 확실하게 정립되지 않은 사람에게 별로 와닿지 않는 방식일 수도 있다고 생각한다. 그래서 이번 포스팅에서는 정확히 “불변”이라는 것이 무엇을 의미하는지에 대한 이야기를 해보려고 한다.</p>\n<h2 id=\"순수-함수와-불변성은-무슨-관계인가요\" style=\"position:relative;\">순수 함수와 불변성은 무슨 관계인가요?<a href=\"#%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EC%99%80-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%80-%EB%AC%B4%EC%8A%A8-%EA%B4%80%EA%B3%84%EC%9D%B8%EA%B0%80%EC%9A%94\" aria-label=\"순수 함수와 불변성은 무슨 관계인가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>저번에 작성했던 <a href=\"/2019/12/29/about-pure-functions/\">수학에서 기원한 프로그래밍 패러다임, 순수 함수</a>에서 한 번 이야기 했듯이, 순수 함수는 수학의 함수를 프로그래밍의 세계로 가져온 모델이다.</p>\n<p>프로그래밍의 세계에는 무언가를 저장하고 변경하고 불러올 수 있는 상태라는 개념이 존재하지만, 수학의 세계에는 그런 개념이 없기 때문에 모든 함수는 함수 외부의 무언가에 절대 영향을 받지 않고 독립적으로 존재한다.</p>\n<p>그렇기 때문에 상태라는 개념 자체가 존재하지 않는 수학의 함수를 프로그래밍으로 구현한 모델인 순수 함수 또한 함수 외부의 상태에 영향을 받지 않아야한다는 규칙을 가질 수 밖에 없는 것이다.</p>\n<p>또한 수학의 세계에는 상태라는 개념이 없기에 당연히 상태를 변경한다는 개념도 없을 수 밖에 없고, 우리는 이를 “불변성(Immutable)“이라고 부른다.</p>\n<p>하지만 프로그래밍의 세계에서 상태를 변경하지 않는다는 것은 꽤나 신경을 많이 써줘야 하는 일이다. 그래서 우리는 “변수에 값을 재할당하지 않는다”와 같은 몇 가지 규칙들을 정해놓고 프로그래밍을 하면서 불변성을 유지한다.</p>\n<p>하지만 프로그램에서 변이(Mutation)가 발생하는 근본적인 원인을 파악하고 불변성을 스스로 지켜나간다면, 이러한 규칙들이 커버할 수 없는 변태같은 상황을 마주치더라도 대응할 수 있기 때문에 우리는 불변(Immutation)이 정확히 무엇을 의미하는 지 알아야 할 필요가 있다.</p>\n<h2 id=\"불변성이란\" style=\"position:relative;\">불변성이란?<a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%B4%EB%9E%80\" aria-label=\"불변성이란 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>보통 불변성의 의미는 “상태를 변경하지 않는 것”이라는 간단한 정의로 설명된다.</p>\n<p>그러나 대부분 불변성에 대한 설명을 할 때, “함수 외부의 변수에 접근, 재할당해서는 안된다”, “함수의 인자를 변경하면 안 된다”와 같이 상태를 변경하는 행위를 금지하는 예시 정도만 설명하고, 상태를 변경한다는 것이 정확히 무엇을 의미하는지는 자세히 설명하지 않는다.</p>\n<p>그래서 이런 설명 방식은 상태를 변경한다는 것이 정확히 어떤 의미인지 모르는 사람에게는 잘 와닿지 않을 수 있다고 생각한다.</p>\n<p>그렇다면 불변성이 이야기하고 있는 상태의 변경이라는 것이 정확히 어떤 행위를 의미하는 것일까? 단순히 프로그램의 변수를 변경하거나 재할당 하지 않는 것을 이야기하는 것일까?</p>\n<p>사실 불변성이 이야기하는 상태의 변경이라는 것은 단순한 변수의 재할당을 이야기하는 것이 아니다. 정확히 말하면 메모리에 저장된 값을 변경하는 모든 행위를 의미하며, 여기에 변수의 재할당과 같은 행위도 포함되는 것이다.</p>\n<p>즉, 상태의 변경이라는 행위를 제대로 이해하기 위해서는 컴퓨터가 값을 어떤 방식으로 메모리에 저장하고 접근하는지에 대한 간단한 지식이 필요하다.</p>\n<h3 id=\"우리는-변수를-통해-메모리에-접근한다\" style=\"position:relative;\">우리는 변수를 통해 메모리에 접근한다<a href=\"#%EC%9A%B0%EB%A6%AC%EB%8A%94-%EB%B3%80%EC%88%98%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%9C%EB%8B%A4\" aria-label=\"우리는 변수를 통해 메모리에 접근한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>대부분의 프로그래밍 언어에서는 메모리의 특정 공간에 저장된 값에 조금 더 쉽게 접근할 수 있도록 도와주는 변수라는 기능을 제공하고 있다.</p>\n<p>변수라는 개념은 프로그래밍을 배울 때 가장 처음 배우는 것이기 때문에, 개발자라면 누구나 다 알고 있는 개념일 것이다. 한번 간단한 변수를 선언해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">let</span> a<span class=\"token punctuation\">;</span>\na <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">1</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>필자는 <code class=\"language-text\">a</code>라는 변수를 “선언”하고, 그 다음 라인에서 <code class=\"language-text\">a</code> 변수에 <code class=\"language-text\">1</code>이라는 값을 “할당”했다.</p>\n<p>일반적으로는 <code class=\"language-text\">let a = 1;</code>와 같이 선언과 동시에 할당을 진행하지만, 엄밀히 말해서 선언과 할당은 다른 행위이기에 조금 더 편한 이해를 위해 코드를 나눠서 작성했다.</p>\n<p><code class=\"language-text\">let a;</code>라는 명령을 사용하여 변수를 선언하면 자바스크립트는 메모리에 <code class=\"language-text\">a</code>라는 변수를 통해 접근할 수 있는 메모리 공간을 마련한다. 필자는 변수를 선언만 하고 값을 할당하지 않았으니 이때 <code class=\"language-text\">a</code> 변수에 접근하려 한다면, “아무것도 정의되지 않았다”라는 의미의 <code class=\"language-text\">undefined</code>를 뱉어낼 것이다.</p>\n<p>그 후 필자는 <code class=\"language-text\">a = 1</code>이라는 명령을 사용하여 마련된 메모리 공간에 <code class=\"language-text\">1</code>이라는 값을 저장했고, 그 이후부터 필자가 <code class=\"language-text\">a</code>라는 변수를 통해 해당 메모리 공간에 접근하면 저장되어 있던 <code class=\"language-text\">1</code>이라는 값을 얻어낼 수 있는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/758e65bb220cb568f802edf2c320b13f/fe720/memory-value.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAABB0lEQVR42mNgIAwYoTQXECsCsQwQcyLJ8wCxMhBLATEzg4mJia+usUGouq5WiK6BQYieoV6wsbFxpIGBgT5Mh5aWFpucnFyIlJRUkrS0dJyMjEyKioqKjJqamqKmpmayqqpSvLq6ehKQ7c9gbGLy097c+r+Prct/R3v7//Zmdn8sLa3/6+vrL6yvrxfasmWLAdBMAy8vr/8xMTH/w8PDf0VFRf3X1dVN1dHRKbawtPhvY27/y8Lc4j/Qca8ZjIyN7lmZmr92NLd5aWVh9dLCxOKZqYnpd6CB3f///2d59OiRNMg7VlZWz52dnT85OTm9BuL/QMPCQK4DeuS/saH5GwMDw69APTcBnf5M6tKki8EAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"memory value\" title=\"\" src=\"/static/758e65bb220cb568f802edf2c320b13f/6af66/memory-value.png\" srcset=\"/static/758e65bb220cb568f802edf2c320b13f/69538/memory-value.png 160w,\n/static/758e65bb220cb568f802edf2c320b13f/72799/memory-value.png 320w,\n/static/758e65bb220cb568f802edf2c320b13f/6af66/memory-value.png 640w,\n/static/758e65bb220cb568f802edf2c320b13f/d9199/memory-value.png 960w,\n/static/758e65bb220cb568f802edf2c320b13f/21b4d/memory-value.png 1280w,\n/static/758e65bb220cb568f802edf2c320b13f/fe720/memory-value.png 1448w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>즉, 변수라는 것은 메모리에 저장되어 있는 어떠한 값에 접근하는 일종의 단축어같은 개념이며, 만약 변수가 없다면 우리는 일일히 <code class=\"language-text\">0x0018fa</code>와 같은 메모리 주소를 사용하여 메모리에 값을 저장할 공간을 마련하고 값을 저장하거나 접근해야한다는 것이다.</p>\n<p>만약 필자가 <code class=\"language-text\">a = 2</code>처럼 해당 변수의 값을 다시 할당한다면, <code class=\"language-text\">0x0018fa</code>라는 주소를 가진 메모리 공간에 저장되어 있는 값을 변경하는 것이며, 상태를 변경하는 행위라고 말할 수 있는 것이다.</p>\n<p>자바스크립트는 재할당 할 수 있는 변수를 선언하는 <code class=\"language-text\">let</code> 키워드와 재할당 할 수 없는 <code class=\"language-text\">const</code> 키워드를 구분하여 제공함으로써 개발자가 실수로 메모리 공간에 저장되어있는 값을 변경하는 행위를 방어할 수 있는 기능을 제공한다.</p>\n<p>그렇다면 우리가 변수를 재할당하지만 않는다면 불변이라는 개념을 지킬 수 있는 것일까?</p>\n<center>\n  <div style=\"width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f4617a9e1f692a7df11953b0a4b86f44/d7854/nope.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQDAv/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAABs2lpGpALaQbsY1//xAAbEAEBAAIDAQAAAAAAAAAAAAABAgASAwQFEf/aAAgBAQABBQImqLTWLKPO+vWpTNqwkOMrZz//xAAYEQACAwAAAAAAAAAAAAAAAAAAARARMf/aAAgBAwEBPwHShR//xAAXEQEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/AWpr/8QAHxAAAgEDBQEAAAAAAAAAAAAAAAERAiFBEBIyYXFy/9oACAEBAAY/AppQqFup7RI/oTmHmDky1vBzi2n/xAAdEAEAAgICAwAAAAAAAAAAAAABABEhMRBBcZGh/9oACAEBAAE/IcpB03LYaGiUNZ5gCV2r5ChuKDSLb9sJVqBjAcRmA6K4/9oADAMBAAIAAwAAABBQ/wAD/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQETH/2gAIAQMBAT8QbYuaj//EABgRAQEAAwAAAAAAAAAAAAAAAAEAEBEx/9oACAECAQE/EAC1uMf/xAAgEAEBAAIBAwUAAAAAAAAAAAABEQAhMUFhsRBRcYGh/9oACAEBAAE/EGfNgAVPb7yZYA6Wrp31k+cmyLEMcBcNgdyLzcp1cdaHSnbnneJWrtHjADmNbAah3cGBXqTRf30//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"nope\" title=\"\" src=\"/static/f4617a9e1f692a7df11953b0a4b86f44/d7854/nope.jpg\" srcset=\"/static/f4617a9e1f692a7df11953b0a4b86f44/0913d/nope.jpg 160w,\n/static/f4617a9e1f692a7df11953b0a4b86f44/cb69c/nope.jpg 320w,\n/static/f4617a9e1f692a7df11953b0a4b86f44/d7854/nope.jpg 550w\" sizes=\"(max-width: 550px) 100vw, 550px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <br>\n</center>\n<p>슬프게도 그렇지 않다. 프로그램이 변수가 가리키고 있는 메모리 공간에 있는 값을 불러오고 사용하는 방법은 그렇게 단순하지 않기 때문이다.</p>\n<p>바로 여기서 그 유명한 “값에 의한 호출(Call by value)“과 “참조에 의한 호출(Call by reference)“이 등장한다.</p>\n<h3 id=\"값에-의한-호출과-참조에-의한-호출\" style=\"position:relative;\">값에 의한 호출과 참조에 의한 호출<a href=\"#%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C%EA%B3%BC-%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%ED%98%B8%EC%B6%9C\" aria-label=\"값에 의한 호출과 참조에 의한 호출 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>값에 의한 호출과 참조에 의한 호출은 특정 컨텍스트에서 다른 컨텍스트에게 변수를 넘길 때 어떤 방식으로 값을 넘겨줄 것인지에 대한 방법들이다.</p>\n<p>이렇게 컨텍스트 간 변수를 넘기는 상황은 함수 외부의 스코프에서 함수에게 인자를 넘겨주는 상황으로 많이 표현되며, 또 실제로도 그런 상황이 대부분이다.</p>\n<p>이에 대해서 조금 더 쉽게 알아보기 위해 간단한 함수를 선언해보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">foo</code> 함수는 문자열을 인자로 받아서 가장 앞의 두 글자만 잘라내어 반환하는 순수 함수이다. 즉, <code class=\"language-text\">foo</code> 함수는 자신의 인자로 받은 값을 재료로 하여 자신의 반환 값을 만들어내는 셈이다.</p>\n<p>그럼 <code class=\"language-text\">foo</code> 함수를 한번 사용해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, World!'</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">He</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">foo</code> 함수는 자신의 인자로 받은 문자열을 잘라서 반환하기 때문에, 마치 인자로 받은 <code class=\"language-text\">str</code> 변수를 직접 수정하는 것처럼 보인다.</p>\n<p>하지만 <code class=\"language-text\">foo</code> 함수의 인자로 사용했던 <code class=\"language-text\">str</code> 변수를 콘솔에 출력해보면 처음 필자가 할당했던 값인 <code class=\"language-text\">Hello, World!</code>가 그대로 저장되어 있는 것을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">He\nHello<span class=\"token punctuation\">,</span> World<span class=\"token operator\">!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이게 어떻게 된 것일까? 정답은 <code class=\"language-text\">str</code> 변수의 자료형인 String 타입의 호출 방식이 “값에 의한 호출” 방식을 사용하기 때문이다.</p>\n<p>자바스크립트에서 <code class=\"language-text\">string</code>, <code class=\"language-text\">number</code>, <code class=\"language-text\">boolean</code>과 같이 원시 타입을 사용하는 변수들은 모두 값에 의한 호출 방식을 사용한다.</p>\n<p>값에 의한 호출 방식은 함수의 인자로 어떤 변수를 넘길 때 해당 변수가 가지고 있는 값을 그대로 복사하여 함수에게 넘겨주는 방식을 의미하기 때문에, 기존에 <code class=\"language-text\">str</code> 변수가 가리키고 있는 메모리 공간에 있는 값을 함수에 인자로 넘기는 것이 아니라 그 값을 복사하여 새로운 메모리 공간에 저장하고나서 넘겨준다는 뜻이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/44d1018198529f57a7dbd342e7c5557c/6569d/call-by-value.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC1klEQVR42pVTzU8TURBfBIkm2BZLSaBCldIPut0u+0X3ox/sttra0gIlTRtLhBjLwdjIzXggkYsQ/wX0RAInQggnGw+IEBLDid4kfhAUMWo4eFBD5TmPQELQEJzkt/Pm92ZmZ968RxCnk3MAJ8ACMB/bw3YboAlwhuB53s0wDO+knJyTojin08lRoEFYURTP4wiTydSu1+tDBoMhiLXZbPZgHnzd5uYWzWKxqGazVbXZbDTBsOz3Dk747RekXYX3ln0+364oibssyyJBEEIQZwwEAp+TySRKJBK/enp6kCSJb4C/KHWw6/l+FWV7fT9j1yRE0+0bBMOxPwJeGWX8MRSXNJToSqBoNLoHFSJI2gWBl8Ph8LdcLodSqVQ5k8kgv9+/Afwln8y/vZe/igazgXJ/uhP8uU0CAlWao+NWloxcIR19LS22uN1uvw7VRWFPj1traGjgjEajWldXFwCtNTY2MphvbW1lXC67RrXZAiTpUK1WK3f88HXpdLryYF2BPy6XqxrOatjhcIyRJDkKGAeuAFtVDO2+Gwnx4yGVG+U5eoykqGFifzIEcZjEMDEx8XR2dvZZTU2NCexqAN/d3f21UCigfD5fxjoej+GWm7RO6d3IcBe6Mxgu38yG4cy9m3/dj5WVFe/y8nIoGAxWHVBGaH1RluUNSZLWYWgfwX4O/IUOgS7eSCkfervE14mIuOnx0AvEfwo+06ojdsUxEASuZGBgAF9cAlq9PT09XZqamlqcmZl5CfaLubm5BdBF4F9NTk7ewn4IoTMn/hYc9rPPz8+7YS3v7Oy0A9jV1VVtbW0tViwWI0tLS8lSqWQ96v9Pgak9dLvdjyk79ajeVP9Ep9ONwEu4D3hQW1vbfHTipxKBF5ASVJCaU1Fftg9lM1mkadoeDAC/lF7sMzQ0dBa3eWJlhwLv9j3DMtucwm3JPnlbUZRPkGjL4/F8gfumHbhVnrbCP+ts8mF/LuM/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"call by value\" title=\"\" src=\"/static/44d1018198529f57a7dbd342e7c5557c/6af66/call-by-value.png\" srcset=\"/static/44d1018198529f57a7dbd342e7c5557c/69538/call-by-value.png 160w,\n/static/44d1018198529f57a7dbd342e7c5557c/72799/call-by-value.png 320w,\n/static/44d1018198529f57a7dbd342e7c5557c/6af66/call-by-value.png 640w,\n/static/44d1018198529f57a7dbd342e7c5557c/d9199/call-by-value.png 960w,\n/static/44d1018198529f57a7dbd342e7c5557c/21b4d/call-by-value.png 1280w,\n/static/44d1018198529f57a7dbd342e7c5557c/6569d/call-by-value.png 1328w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>결국 <code class=\"language-text\">foo(str)</code>라는 코드로 함수를 호출하며 인자로 넘긴 <code class=\"language-text\">str</code>이라는 변수가 가지고 있는 값과, <code class=\"language-text\">foo</code> 함수 내부에서 <code class=\"language-text\">s</code>라는 변수를 통해 접근하는 값은 전혀 다른 메모리 공간에 저장되어 있는 새로운 값이다.</p>\n<p>그렇기 때문에 <code class=\"language-text\">foo</code> 함수가 아무리 자신의 인자로 받은 변수를 지지고 볶아도 원본 변수는 절대로 영향을 받지 않는다. 심지어 <code class=\"language-text\">foo</code> 함수 내부에서 <code class=\"language-text\">s</code> 변수를 재할당하더라도 원본 변수에 담겨져 있는 값은 변하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, World!'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  s <span class=\"token operator\">=</span> <span class=\"token string\">'재할당합니다'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">Hello<span class=\"token punctuation\">,</span> World<span class=\"token operator\">!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">foo</code> 함수는 인자로 넘어온 변수에 값을 재할당했음에도 함수 외부에 있는 <code class=\"language-text\">str</code> 변수의 값은 변하지 않았다.</p>\n<p>즉, 불변성을 유지한다는 것은 단순히 “함수의 인자를 변경하지 않는다”라던가 “변수를 재할당하지 않는다”는 개념이 아닌 것이다. 포인트는 메모리에 이미 담겨있는 값을 변경하지 않는 것이다.</p>\n<p>반면 값에 의한 호출 방식을 사용하지 않는 <code class=\"language-text\">Array</code>, <code class=\"language-text\">Object</code>와 같은 객체들은 조금 상황이 다르다.</p>\n<p>이번에는 인자로 배열을 받은 후 그 배열에 <code class=\"language-text\">hi</code>라는 문자열 원소를 추가하는 간단한 함수를 선언하고, 어떤 결과가 나오는지 살펴보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">bar</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hi'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>원시 자료형이었던 <code class=\"language-text\">str</code> 변수는 값에 의한 호출 방식을 사용하지만, 객체인 <code class=\"language-text\">Array</code>는 “참조에 의한 호출” 방식을 사용한다. 그럼 함수를 사용해보고 원본 변수가 어떻게 되는지 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">bar</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">'hi'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>함수 내부에서 인자를 지지고 볶아도 원본 변수에는 전혀 영향이 없었던 <code class=\"language-text\">foo</code> 함수와 다르게, 이번에는 <code class=\"language-text\">bar</code> 함수의 인자로 넘겼던 <code class=\"language-text\">array</code> 변수의 값이 변경된 것을 확인해볼 수 있다.</p>\n<p>함수의 인자로 변수를 넘길 때 값을 복사하여 새로운 공간에 저장한 후 넘겨주는 값에 의한 호출 방식과 다르게, 참조에 의한 호출 방식은 “변수가 가리키고 있는 메모리 공간의 주소”를 넘기는 방식이다.</p>\n<p>즉, <code class=\"language-text\">array</code> 변수가 가리키고 있는 메모리 공간에 저장된 배열과 <code class=\"language-text\">bar</code> 함수가 인자로 받은 배열은 정확히 같은 메모리 공간에 저장되어 있는, “같은 배열” 이라는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8e28402edf974ba2f299767cd19f1f12/6569d/call-by-reference.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACE0lEQVR42mNgwA8YobQ0EOsCsRIQCyDJMwOxFhBrALEUWETPVE9NyUBTVdPAQFVJSUlVWVlZxcTERN3Y2FgEJM/Pzy/Ax8dnwsnJacrFxWUMYsvJyQna29uzANVqy8jImAoLC5vIysqaAPXLMViamn+1N7X+ZGVq8dnaxuaznZ3dB3Nz8/9GRkbzQAYaGhq2urq6/vf09PwAxB+B+D/QwjqQAQYGBn9NTU0/2drafgQ64Jeent4ZBk9rp/8x9r7/fWxd/wcGB/2Pjo7+A9IENGg11MA5CQkJIPG/ILmYmJj/lpaWXUCX2ZuZmf23sbH55+3t/Rco9h9owQ0GHUO9XDV9rWwtfd1sDQ2NbDU1tUygRDFQgRPIQHV1dRMFBYVyoDfLQBjorQogNtHS0hLS0dEpBuIiILtQV1e3TFNTM5yBBMAFxJxIkcWIVVVoaChzfX09k7y8PAcwwIWAQnwTJkyoWLdu3ZKZM2cuBuJ4oBgHMOClREVFef7//w8yiAlkIEgvMgaLgwwDGSwoKMgvKSnJBZKYMmVK0q5du7qWL1/euXjxYm+QPNBbbDhdhSOtiSN5iXygq607V1dNd4aKiso6JWWlxcBIma6vr78MiFNhQUKSgbaetv8doh3+BwWBk8z/qKioP8C0CEqHa0HysCAhGhiaGr41tDZ8bWFp8QaYpt4Ac8BLYNr7qa2tPR2qhCQDAXhMmtiBpCW6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"call by reference\" title=\"\" src=\"/static/8e28402edf974ba2f299767cd19f1f12/6af66/call-by-reference.png\" srcset=\"/static/8e28402edf974ba2f299767cd19f1f12/69538/call-by-reference.png 160w,\n/static/8e28402edf974ba2f299767cd19f1f12/72799/call-by-reference.png 320w,\n/static/8e28402edf974ba2f299767cd19f1f12/6af66/call-by-reference.png 640w,\n/static/8e28402edf974ba2f299767cd19f1f12/d9199/call-by-reference.png 960w,\n/static/8e28402edf974ba2f299767cd19f1f12/21b4d/call-by-reference.png 1280w,\n/static/8e28402edf974ba2f299767cd19f1f12/6569d/call-by-reference.png 1328w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>즉, <code class=\"language-text\">bar</code> 함수의 인자로 받은 배열은 참조에 의한 호출 방식을 사용하는 객체이기 때문에, 함수 내에서 이 배열을 지지고 볶아 버린다면 원본 배열 자체가 지지고 볶아지는 것이다.</p>\n<p>이 경우에는 메모리 공간에 저장되어있던 배열을 직접 변경해버리는 것이므로, 상태가 변경되었다고 말할 수 있고, 불변성이 깨져버린 것이다.</p>\n<p>똑같이 함수의 내부에서 인자를 수정하는 행위지만 인자가 값에 의한 호출 방식을 사용하는 자료형인지 참조에 의한 호출 방식을 사용하는 자료형인지에 따라 결과는 큰 차이가 나기 때문에, 불변성을 지키고 싶다면 항상 이 점을 염두에 두고 코드를 작성해야한다.</p>\n<h2 id=\"불변성을-지키면-어떤-점이-좋은가요\" style=\"position:relative;\">불변성을 지키면 어떤 점이 좋은가요?<a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A7%80%ED%82%A4%EB%A9%B4-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%9D%B4-%EC%A2%8B%EC%9D%80%EA%B0%80%EC%9A%94\" aria-label=\"불변성을 지키면 어떤 점이 좋은가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>프로그래밍을 하면서 상태의 불변성을 지키려면 자연스럽게 이것저것 신경써줘야하는 것들이 늘어날 수 밖에 없다. 그럼에도 불구하고 불변이라는 개념은 현재 많은 개발자들에게 환영받고 있는 개념이라는 것이 사실이다.</p>\n<p>도대체 상태가 변경되지 않게 함으로써 얻을 수 있는 것이 무엇이길래, 다들 이렇게 불변불변하는 것일까?</p>\n<h3 id=\"무분별한-상태의-변경을-막는다\" style=\"position:relative;\">무분별한 상태의 변경을 막는다<a href=\"#%EB%AC%B4%EB%B6%84%EB%B3%84%ED%95%9C-%EC%83%81%ED%83%9C%EC%9D%98-%EB%B3%80%EA%B2%BD%EC%9D%84-%EB%A7%89%EB%8A%94%EB%8B%A4\" aria-label=\"무분별한 상태의 변경을 막는다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>상태는 프로그램의 현재 상황을 보여주는 좋은 역할도 하지만, 여기저기서 무분별하게 이 상태를 참조하거나 변경하는 경우, 개발자조차 현재 프로그램이 어떻게 돌아가는지 파악하기 힘든 슬픈 상황이 발생할 수도 있다.</p>\n<p>그래서 개발자들은 상태를 변경하는 행위에 특정한 규칙과 제약을 정해서 무분별한 상태 변화를 최대한 피하고, 이런 변화를 추적할 수 있는 상황을 선호할 수 밖에 없다.</p>\n<p>무분별한 상태 변경 때문에 프로그램이 터지게 되는 가장 대표적인 상황은 바로 “전역 변수의 남용”이다. 자바스크립트에서 전역 변수의 사용을 아예 금지하는 컨벤션을 추천하는 것도 바로 이 이유이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">let</span> greeting <span class=\"token operator\">=</span> <span class=\"token string\">'Hi'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">setName</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  name <span class=\"token operator\">=</span> <span class=\"token string\">'Evan'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  greeting <span class=\"token operator\">=</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>greeting<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">greeting</code> 변수는 전역 스코프에서 선언된 전역 변수이고, <code class=\"language-text\">setName</code> 함수 내부에서도 암묵적으로 전역 변수를 선언하고 있으며, <code class=\"language-text\">setTimeout</code>의 콜백 함수 내에서도 전역 변수인 <code class=\"language-text\">greeting</code>의 값을 재할당하고 있다.</p>\n<p>이런 상황에서는 어디서 어떤 놈이 <code class=\"language-text\">greeting</code>이라는 전역 변수의 상태를 변경했는지 추적이 거의 불가능하며, 갑자기 콘솔에 <code class=\"language-text\">Hi, Evan</code>이 아닌 <code class=\"language-text\">Get out, Evan</code>이라고 출력된다고 해도 전혀 이상할 것이 없다.</p>\n<p>개발자가 이런 상황을 만났을 때 야근을 하는 이유는, 슬프게도 이게 버그가 아니기 때문이다. 이 코드들은 콘솔에는 어떠한 에러도 출력되지 않는 지극히 정상적인 로직이다. <small>(차라리 에러라도 나는 것이 디버깅은 더 쉽다)</small></p>\n<p>불변성을 유지하며 순수 함수를 사용한다는 것은 함수 외부의 상태에 접근하여 이미 메모리에 할당되어 있는 값을 변경하지 않는다는 의미이므로, 이렇게 예측하지 못한 상태의 변경을 방어할 수 있다.</p>\n<h3 id=\"상태의-변경을-추적하기가-쉽다\" style=\"position:relative;\">상태의 변경을 추적하기가 쉽다<a href=\"#%EC%83%81%ED%83%9C%EC%9D%98-%EB%B3%80%EA%B2%BD%EC%9D%84-%EC%B6%94%EC%A0%81%ED%95%98%EA%B8%B0%EA%B0%80-%EC%89%BD%EB%8B%A4\" aria-label=\"상태의 변경을 추적하기가 쉽다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>일반적으로 자바스크립트의 객체의 프로퍼티나 배열의 원소를 변경해야하는 경우, 필연적으로 불변성이 깨질 수 밖에 없다.</p>\n<p>애초에 배열이나 객체가 처음 나왔을 때, 어딘가에 구조화된 데이터를 저장해놓고 상태를 유지하고 변경해가며 사용하고자 하는 목적을 가지고 있었기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nevan<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Not Evan'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 상태 변화!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>하지만 이렇게 기존에 메모리에 저장되어있는 값을 변경하는 행위는 불변의 법칙을 정면으로 위반하는 것이기 때문에, 불변성을 유지하고 싶은 개발자는 이런 식으로 객체의 프로퍼티나 배열의 원소를 변경할 수 없다.</p>\n<p>게다가 방금 보았던 무분별한 전역 변수의 사용과 마찬가지로 객체나 배열의 상태 변화 또한 추적할 수 없는 문제이기 때문에, 어디서 이상한 놈이 엄한 객체나 배열의 상태를 변경하여 버그가 발생하더라도 개발자가 이를 디버깅하기란 쉽지 않은 문제이다.</p>\n<p>그렇다고 객체의 프로퍼티나 배열의 원소를 변경하지 못하도록 할 수도 없는 노릇이다. 그럼 어떻게 이 문제를 해결해야할까?</p>\n<p>한번 객체의 프로퍼티를 변경하는 간단한 함수를 통해 객체의 프로퍼티를 변경할 때 발생하는 상태 변화의 재현과 해결 방법을 알아보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">convertToJohn</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">person<span class=\"token punctuation\">,</span> name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  person<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> person<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">convertToJohn</code> 함수는 객체를 인자로 받아, 해당 객체의 <code class=\"language-text\">name</code> 프로퍼티에 <code class=\"language-text\">John</code>이라는 문자열을 할당하는 역할을 하는 함수이다. 즉, 이 함수는 객체의 상태를 변경하는 역할을 하고 있다.</p>\n<p>일단 결론부터 이야기하자면 이 함수는 순수 함수가 아닌데, 그 이유는 함수가 참조에 의한 호출 방식을 사용하는 객체의 프로퍼티를 직접 변경하면 함수 외부에 있는 원본 객체의 상태도 변경되기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> john <span class=\"token operator\">=</span> <span class=\"token function\">convertToJohn</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>john<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// ?</span>\n<span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">convertToJohn</code> 함수를 사용하는 사람은 함수의 이름만 보고 “오호, 이 함수는 어떤 객체를 존 객체로 바꿔주는 함수로군?”이라고 생각하겠지만, 이 함수는 개발자 몰래 자신의 인자로 받은 객체까지 변경해버리는 나쁜 함수였다.</p>\n<p>이렇게 의도하지않은 객체의 프로퍼티가 변경되는 것도 문제지만, 사실 더 큰 문제는 이런 상태의 변화를 전혀 추적할 수 없다는 것이다. 당장 위 예시의 <code class=\"language-text\">evan</code> 객체와 <code class=\"language-text\">john</code> 객체를 비교해보면 자바스크립트는 두 객체가 같은 객체라고 평가해버린다.</p>\n<p>두 객체는 메모리 공간에 접근할 수 있는 변수명만 다를 뿐, 실제로는 같은 메모리 공간에 저장되어 있는 같은 객체이기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan <span class=\"token operator\">===</span> john<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이런 상황에서 개발자는 “의도하지 않은 객체의 상태 변화”와 “상태의 변화를 추적할 수 없다”는 고약한 문제를 떠안게 된다. 그렇다면 이 문제를 어떻게 해결할 수 있을까?</p>\n<p>이 문제는 생각보다 간단하게 해결할 수 있는데, <code class=\"language-text\">name</code>을 <code class=\"language-text\">John</code>으로 가지는 객체를 그냥 새로 생성해버리면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">convertToJohn</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">person</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> newPerson <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  newPerson<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'John'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> newPerson<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> evan <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> john <span class=\"token operator\">=</span> <span class=\"token function\">convertToJohn</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>john<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Evan'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>변경된 <code class=\"language-text\">convertToJohn</code> 함수는 더 이상 인자로 받은 <code class=\"language-text\">person</code> 객체에 직접 접근해서 값을 수정하지 않는다. 다만 <code class=\"language-text\">Object.assgin</code> 메소드를 사용하여 <code class=\"language-text\">person</code> 객체와 동일한 구조를 가진 새로운 객체를 생성하고 <code class=\"language-text\">name</code> 프로퍼티를 <code class=\"language-text\">John</code>으로 변경한 후 반환할 뿐이다.</p>\n<p>이런 과정이 너무 불편하게 느껴진다면 ES6의 <code class=\"language-text\">spread</code> 연산자를 사용하면 더 간단한 문법으로 변경할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">convertToJohn</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">person</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>person<span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 새로운 객체를 생성하게 되면 의도하지 않은 객체의 상태 변화도 방어할 수 있고 상태 변화를 추적할 수도 있게 된다. 왜냐하면 <code class=\"language-text\">convertToJohn</code> 함수가 뱉어낸 객체는 <code class=\"language-text\">evan</code> 객체와는 전혀 다른, 새로운 객체이기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>evan <span class=\"token operator\">===</span> john<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>객체의 상태를 변화시킬때, “상태가 변화된 객체”를 새로 생성한다면 우리는 이전 상태를 가진 객체와 다음 상태를 가진 객체를 비교하며 <code class=\"language-text\">false</code>가 나온다는 사실을 이용하며 객체의 상태가 변화되었음을 알 수 있는 것이다.</p>\n<p>이런 원리는 웹 프론트엔드의 UI 라이브러리인 React에서 상태의 변화를 감지하는 데에도 사용되고 있는데, React는 개발자가 <code class=\"language-text\">setState</code>와 같은 메소드를 사용하여 상태를 변경했을 때 <code class=\"language-text\">Object.is</code> 메소드를 사용하여 이전 상태와 다음 상태를 비교하고 두 객체가 같지 않다고 평가되면 상태가 변이되었다고 판단하고 컴포넌트를 다시 렌더한다.</p>\n<p>또한 상태 관리 라이브러리인 Redux 또한 동일한 원리로 상태의 변화를 판단하기 때문에, 리듀서(Reducer)를 작성할 때는 기존 <code class=\"language-text\">state</code> 객체의 프로퍼티를 직접 변경하지 않고 새로운 객체를 생성해서 반환해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">reducer</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">state<span class=\"token punctuation\">,</span> action</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token constant\">SET_NAME</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">...</span>state<span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> action<span class=\"token punctuation\">.</span>payload<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이러한 불변성의 특징들은 참조에 의한 호출을 사용하는 자료형들의 상태 변화를 쉽게 감지할 수 있도록 만들어주기 때문에 개발자가 예상하지 못하는 방향으로 버그가 발생하는 것을 어느 정도 막을 수 있다.</p>\n<p>또한 불변성은 멀티 쓰레딩을 사용할 때도 매우 유용한데, 여러 개의 쓰레드가 한 개의 상태를 정신없이 수정하고 참조하게되면 어느 순간부터는 도대체 쓰레드가 참조한 게 어떤 값인지 파악하기가 힘들기 때문이다.</p>\n<p>이건 마치 하나의 종이에 여러 명의 화가가 물감을 칠하면서 그림을 완성해가는 느낌이라고 할 수도 있을 것 같다. 그러나 불변성이 제대로 지켜진다면 각자 쓰레드마다 종이를 주고 그림을 그려서 제출하라는 상황과 비슷하다.</p>\n<p>개발자는 각 쓰레드가 그림을 제출할 때마다 상태가 변경되었음을 감지할 수도 있고, 이를 이용하여 그림의 상태가 변경되는 로그를 쌓을 수도 있다. 이후 그 그림들을 어떻게 취합하던, 필요없는 그림은 버리던 그건 그 후의 문제로 분리하면 되는 것이다.</p>\n<h2 id=\"현실적인-불변성의-상황\" style=\"position:relative;\">현실적인 불변성의 상황<a href=\"#%ED%98%84%EC%8B%A4%EC%A0%81%EC%9D%B8-%EB%B6%88%EB%B3%80%EC%84%B1%EC%9D%98-%EC%83%81%ED%99%A9\" aria-label=\"현실적인 불변성의 상황 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇게 불변성을 지키면서 프로그래밍을 하면 상태 변화를 쉽게 추적할 수 있고 관리할 수 있다는 점에서 더할 나위 없이 좋지만, 그렇다고 해서 장점만 있는 것은 아니다.</p>\n<p>불변성의 가장 큰 문제는 기존의 객체지향 프로그래밍과의 접점을 만들기 어렵다는 것이다.</p>\n<p>불변성을 지향한다는 함수형 프로그래밍의 특징은 기존에 우리가 익숙하게 사용하는 객체지향 프로그래밍과는 많이 다르다.</p>\n<p>객체지향 프로그래밍은 <code class=\"language-text\">private</code>과 같은 접근 제한자로 상태를 외부에 노출시키지 않음으로써 사용자가 단순한 인터페이스를 접할 수 있도록 하지만, 함수형 프로그래밍은 아예 프로그램의 상태를 변경하지 않는 불변성을 지향하면서 프로그램의 동작을 예측하기 쉽고 단순하게 만든다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/def489f1400293515499d529e83b420a/e9140/oop_fp.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 43.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAACXklEQVR42m2RyU9TURTGL05xgUtj4k4sJAwxIS7Y+SfoQhRkJTPEKSRuTCQyJCx4xCHQFHi0ry21lilVEINBGV+hpeWVliHpI4gR6EAhAjXQ9tF+3leCQeNJvpyTc5Pf+e45hBCSREUyMjKSs9NTb1zPVFwlR5F0/PafSPRzsjPTc7KyLp3sER64PLiLtKEDKAbCSB0GUoYAhaxV4Py/JPWE92K7bTONnQoo9HMHV966D1Lkun1iPa2DD14gjaq5HUbtBtPhlhjWLTWyrkOGdUVe6z2obZhqlyEAEtO7F3BOY/E7Ome2wfG+qMbiO9TwCUWMwh7UvE9LHt3qQ3Vxf7y2fBA1ZR/xvLAfdRWD8arcXlTe7IlW3u65duyOApN11i3ROLsLzhKI6a1B6KaD4KYCUs98GJ22bTN58nImXMLYUMZY4+VNNpQyVlnSg5ZFVL+yaxIg4HQijwaSqQvR6NiBcmQ9VvNhBfUD38BOeKUu1z6oUzMp1i+G8lg3Cti5eAHrQv6RooWmH2gYWq2XQW0OnD0JNNh/Qj3pi5VwC3ja5aEuA5LpGPi4c3HnTrMjnq90Ru+pnNLdFkHKVwr7pYYVMJ9W646Ajj9AzuJfMti20DKyEWn+uia9GV6T2sa9YZMQkvfaR6p6v4cKdcso0nniFYZl3Nd6UKQXow/NQTR9Cf7tkO7QOBsSuxciMAl7MZMzhC4qo3NPei8C74RfZkIv9bl1bGO+bcw72zruFeg0QTW2Yad7EXXTm3ky6MXo6JlEBk5pLX6OHmRJw/sdVAL9pkBd2zneL2onfc9+A3kmnpn735kWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"oop fp\" title=\"\" src=\"/static/def489f1400293515499d529e83b420a/6af66/oop_fp.png\" srcset=\"/static/def489f1400293515499d529e83b420a/69538/oop_fp.png 160w,\n/static/def489f1400293515499d529e83b420a/72799/oop_fp.png 320w,\n/static/def489f1400293515499d529e83b420a/6af66/oop_fp.png 640w,\n/static/def489f1400293515499d529e83b420a/d9199/oop_fp.png 960w,\n/static/def489f1400293515499d529e83b420a/e9140/oop_fp.png 1226w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>\n    OOP는 변경 가능한 상태를 감추며 단순함을 만들어내지만,<br>\n    FP는 아예 변경 가능한 상태를 없앰으로써 단순함을 만들어낸다\n  </small>\n</center>\n<p>즉, 객체지향 프로그래밍과 함수형 프로그래밍은 상태를 바라보는 관점 자체가 다르다는 것이다. 애초에 객체지향 프로그래밍은 상태를 “잘 변경하는 것”에 초점을 맞추는 패러다임이기 때문에 불변성과는 약간 거리가 있다.</p>\n<p>또한 아직까지 우리가 사용하는 대부분의 API나 라이브러리들은 객체지향 프로그래밍을 기반으로 설계되고 있기 때문에 우리는 객체지향 프로그래밍에서 완벽하게 독립할 수 없는 상황이다.</p>\n<p>문제는 이렇게 객체지향 프로그래밍을 기반으로 설계된 것들을 불변의 법칙으로 관리하려면 꽤 많은 비용이 들 수도 있다는 것이다.</p>\n<p>쉬운 이해를 위해 웹 오디오 API를 사용하여 객체를 하나 생성하고, 이 객체의 상태를 변경해야하는 상황을 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AudioContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">node</span><span class=\"token operator\">:</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">createGain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>상태를 표현하기 위해 간단한 객체를 생성하고 그 안에 <code class=\"language-text\">GainNode</code>를 할당했다. <code class=\"language-text\">GainNode</code>는 오디오 신호의 크기를 키웠다 줄였다 할 수 있는 값인 <code class=\"language-text\">gain</code> 프로퍼티를 가지고 있고, 개발자는 이 프로퍼티의 값을 변경함으로써 간단하게 오디오 신호를 조작할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">state<span class=\"token punctuation\">.</span>node<span class=\"token punctuation\">.</span>gain <span class=\"token operator\">=</span> <span class=\"token number\">1.2</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그러나 이렇게 객체에 직접 접근하여 프로퍼티를 변경하는 행위는 불변성을 위배한다. 이 상황에서 불변성을 만족하기 위해서는 <code class=\"language-text\">gain</code> 프로퍼티의 값을 변경할 때마다 새로운 게인 노드 객체를 생성해줘야 하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">setGain</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> newGain <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">createGain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  newGain<span class=\"token punctuation\">.</span>gain <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> newGain<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nstate <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>state<span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">node</span><span class=\"token operator\">:</span> <span class=\"token function\">setGain</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>물론 이렇게 불변성을 지켜주면 게인 노드의 상태 변화를 추적할 수 있다는 장점을 가지지만, 객체를 생성하는 비용이 클 경우에는 문제는 발생할 수 있다.</p>\n<p>웹 오디오 API가 제공하는 게인 노드 객체는 멤버 변수와 메소드를 가지고 있는 엄연한 인스턴스이며, <code class=\"language-text\">{ gain: 1 }</code>처럼 간단한 프로퍼티만을 가지고 있는 객체가 아니다.</p>\n<p>만약 인스턴스가 가지고 있는 멤버 변수와 메소드가 많거나 객체를 생성할 때 무거운 작업이 동반되어야 한다면, 프로퍼티를 변경할 때마다 객체를 생성하는 것은 퍼포먼스에 상당한 부담이 될 수도 있다.</p>\n<p>이미 생성된 객체를 복사하는 방법도 있겠지만, 저렇게 생성자를 통해 생성된 객체는 복사한 후에 프로토타입 링크도 전부 다시 연결해줘야하기 때문에, 일반 객체를 복사하는 것에 비해 그리 가벼운 작업은 아니다.<small>(실제로 몇 번 해봤는데, 퍼포먼스가 생각보다 안 나온다)</small></p>\n<p>이런 상황에서 섣불리 불변성을 유지한답시고 저런 코드를 작성하면 프로그램 전체의 퍼포먼스가 크게 저하될 수도 있기 때문에 각 상황에 맞는 현명한 판단이 필요하다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이번 포스팅에서는 불변성에 대한 설명과 더불어, 일급 시민이라는 개념을 사용한 커링과 같이 기술적인 부분에 대한 이야기도 함께 하려고 했는데, 또 분량 조절에 실패해버렸다.</p>\n<p>아무래도 요즘 관심을 많이 가지고 있는 내용이다보니 자꾸 내용이 길어지는 듯 하다.</p>\n<p>최근 불변성이라는 키워드가 프론트엔드 쪽에서 많이 주목받고 있기는 하지만 사실 불변성이 프론트엔드에서만 주목받는 키워드는 아니다. 본래 불변성이 주목받기 시작한 이유는 변경 가능한 상태를 여러 곳에서 공유하게 됨으로써 발생하는 여러가지 문제를 해결하기 위함이었기 때문이다.</p>\n<p>일반적으로 이런 문제는 멀티 쓰레딩과 같은 동시성 프로그래밍을 사용할 때 많이 발생했는데, 기존에는 상태에 접근할 수 있는 권한을 의미하는 일종의 락(Lock)을 걸어놓고 락이 풀린 상태에만 쓰레드가 상태에 접근할 수 있도록 허가하는 방식을 주로 사용했었다.</p>\n<p>그러나 이러한 상태가 한두개도 아닐 뿐더러, 실수로 락을 잘못 걸어서 상태가 꼬여버려도 개발자가 알아차리기 힘든 것은 매한가지이기 때문에, 변경 가능한 상태를 아예 없애버리는 불변의 개념이 각광받기 시작한 것이다.</p>\n<p>오히려 Erlang이나 Rust 같은 언어들은 자바스크립트보다 더 빡빡한 방법으로 불변성을 지원하고 있기 때문에, 이 키워드에 관심이 많으신 분들은 해당 언어를 한 번 체험해보는 것도 좋겠다는 생각이 든다. <small>(필자는 Rust를 한번 해볼까 생각 중이다)</small></p>\n<p>하지만 자바스크립트 또한 특유의 자유로운 언어의 성격 때문에 ES5 시절부터 무분별한 상태 관리에 많은 개발자들이 고통받았었고, 점점 더 웹 프론트엔드 어플리케이션이 고도화되고 복잡한 상태 관리를 요구하게 되면서 이런 개념을 사용하게 되었다.</p>\n<p>실제로 필자 또한 상태의 변화를 추적할 수 없는 상황에서 발생한 버그를 디버깅하느라 고생한 적이 너무나도 많았기 때문에, 이러한 불변의 개념을 처음 알았을 때 꽤나 관심있게 지켜봤던 기억이 있다.</p>\n<p>하지만 앞서 이야기했듯이 불변성을 유지하며 프로그래밍을 한다는 것이 모든 상황에서의 정답이 될 수는 없다.</p>\n<p>필자도 현재 작업 중인 토이 프로젝트인 <a href=\"https://github.com/evan-moon/simple-waveform-visualizer\" target=\"_blank\" rel=\"nofollow\">Web Audio 에디터</a>에 아무 생각없이 리덕스를 붙혔다가 위에서 이야기했던 객체 생성 비용 문제때문에 퍼포먼스가 안 나와서 고생 중이다.<small>(위에서 예로 든 상황은 필자의 경험담이었다)</small></p>\n<p>늘 이야기하는 것이지만 모든 상황에 맞아떨어지는 절대적인 기술이라는 것은 없기 때문에, 불변성이 무조건 좋다고 이야기하기보다 그저 각 상황에 맞는 현명한 의사결정을 통해 불변성을 이용하면 된다고 생각한다.</p>\n<p>이상으로 변하지 않는 상태를 유지하는 방법, 불변성 포스팅을 마친다.</p>","fields":{"slug":"20200105-what-is-immutable","path":"/2020/01/05/what-is-immutable/","lang":"ko"},"frontmatter":{"title":"변하지 않는 상태를 유지하는 방법, 불변성(Immutable)","subTitle":"상태를 지키는 프로그래밍, 불변성의 의미와 가치","date":"Jan 05, 2020","categories":["프로그래밍","아키텍처"],"tags":["함수형 프로그래밍","Functional Programming","순수 함수","불변성","Pure Functions","Immutable","Immer","Redux","Reducer"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/5015b01788f79d9bfd780840b41814f1/d803c/thumbnail.png","srcSet":"/static/5015b01788f79d9bfd780840b41814f1/d803c/thumbnail.png 320w,\n/static/5015b01788f79d9bfd780840b41814f1/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/5015b01788f79d9bfd780840b41814f1/fc5c5/thumbnail.webp 320w,\n/static/5015b01788f79d9bfd780840b41814f1/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/5015b01788f79d9bfd780840b41814f1/01fb2/thumbnail.png","srcSet":"/static/5015b01788f79d9bfd780840b41814f1/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/5015b01788f79d9bfd780840b41814f1/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"6492e3b5-e104-5bfb-8485-dae6c08b7131","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EB%8A%94-%EA%B7%B8%EB%83%A5-%EC%88%98%ED%95%99%EC%A0%81-%ED%95%A8%EC%88%98%EB%8B%A4\">순수 함수는 그냥 수학적 함수다</a></p>\n<ul>\n<li><a href=\"#%EC%88%98%ED%95%99%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98\">수학에서의 함수</a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98\">프로그래밍에서의 함수</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%88%9C%EC%88%98%ED%95%9C-%EC%88%98%ED%95%99%EC%A0%81-%ED%95%A8%EC%88%98%EB%A1%9C-%ED%9A%8C%EA%B7%80%ED%95%98%EC%9E%90\">순수한 수학적 함수로 회귀하자</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이전에 작성했던 기존의 사고 방식을 깨부수는 함수형 사고 포스팅에 이어, 이번 포스팅에서는 함수형 프로그래밍이 지향하는 관점을 실제 프로그램에 구현하기 위해 알고 있어야하는 필수적인 개념 중 하나인 “순수 함수(Pure functions)“에 대한 이야기를 해볼까 한다.","html":"<p>이전에 작성했던 <a href=\"/2019/12/15/about-functional-thinking/\">기존의 사고 방식을 깨부수는 함수형 사고</a> 포스팅에 이어, 이번 포스팅에서는 함수형 프로그래밍이 지향하는 관점을 실제 프로그램에 구현하기 위해 알고 있어야하는 필수적인 개념 중 하나인 “순수 함수(Pure functions)“에 대한 이야기를 해볼까 한다.</p>\n<!-- more -->\n<p>2017년 쯤, 함수형 프로그래밍이라는 패러다임이 떠오르면서 순수 함수라는 개념 또한 함께 주목받기 시작했고, 지금도 구글에 “순수 함수”라고 검색하면 많은 개발자 분들이 순수 함수의 특징에 대한 포스팅을 작성해놓은 것을 볼 수 있다.</p>\n<p>일반적으로 우리가 순수 함수에 대해서 공부하려고 하면 다음과 같은 두 가지 특징을 가지는 함수라고 정의하는 경우를 많이 볼 수 있다.</p>\n<blockquote>\n<ol>\n<li>동일한 인풋(인자)에는 항상 동일한 결과를 내야한다.</li>\n<li>함수 외부의 상태를 변경하거나, 외부의 상태에 영향을 받아서는 안된다.</li>\n</ol>\n</blockquote>\n<p>그러나 이렇게 공부하게 되면 “순수 함수는 이런저런 특징을 가지고 있는 함수”라고 외우게 되기 쉬운데, 사실 순수 함수는 이렇게 접근할 필요가 없는, 더 심플한 개념이다.</p>\n<p>뭐 그냥 이렇게만 외워놔도 순수 함수가 어떤 것인지 이해하고 사용하는 데는 전혀 무리가 없지만, 필자는 순수 함수의 이러한 특징이 어디서 나온 것인지, 순수 함수라는 것이 정확하게 무엇을 의미하는지에 대해 조금 더 근본적인 이야기를 해보려고 한다.</p>\n<h2 id=\"순수-함수는-그냥-수학적-함수다\" style=\"position:relative;\">순수 함수는 그냥 수학적 함수다<a href=\"#%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EB%8A%94-%EA%B7%B8%EB%83%A5-%EC%88%98%ED%95%99%EC%A0%81-%ED%95%A8%EC%88%98%EB%8B%A4\" aria-label=\"순수 함수는 그냥 수학적 함수다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리가 순수 함수라고 이름을 붙히고 순수 함수의 특징은 이러이러한 것들이 있다고 공부하기 때문에 뭔가 특별한 함수인 것 같지만, 사실 순수 함수는 그냥 수학에서 사용하는 함수를 프로그래밍의 세계에 똑같이 구현해놓은 것에 불과하다.</p>\n<p>위키 백과의 함수형 프로그래밍의 정의를 보면 이 개념에 대해 조금 더 자세하게 작성된 설명을 볼 수 있다.</p>\n<blockquote>\n<p><strong>함수형 프로그래밍</strong>(functional programming)은 자료 처리를 <strong>수학적 함수</strong>의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다. 명령형 프로그래밍에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다.</p>\n<p><strong>함수형 프로그래밍 - 위키 백과</strong> <em><a href=\"https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" target=\"_blank\" rel=\"nofollow\">원문 링크</a></em></p>\n</blockquote>\n<p>이 설명에서 가장 중요한 키워드는 바로 “수학적 함수”라는 단어이다. 우리가 이런저런 특징을 외우며 공부하는 순수 함수라는 녀석은 말 그대로 순수한 함수, 즉 수학에서 사용하는 함수를 의미하는 것이다.</p>\n<p>우리가 수학의 세계와 프로그래밍의 세계에서 동일하게 함수라는 개념을 사용하고 있기 때문에 간혹 잊어버리긴 하지만, 사실 프로그래밍에서의 함수는 수학의 그것과는 다른 점이 상당히 많다.</p>\n<p>그럼 수학적인 함수와 프로그래밍의 함수 간 차이점을 알아보기 위해, 수학적인 함수의 정의부터 다시 한번 확실하게 짚고 넘어가도록 하자.</p>\n<h3 id=\"수학에서의-함수\" style=\"position:relative;\">수학에서의 함수<a href=\"#%EC%88%98%ED%95%99%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98\" aria-label=\"수학에서의 함수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>우리가 중학생 때 배웠던 함수라는 녀석은 대략 다음과 같은 정의를 가지는 개념이다.</p>\n<blockquote>\n<p>임의의 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">x \\in X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span>에 대하여 그에 대응하는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">y \\in Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span>가 <strong>유일하게 존재하는</strong> 대응 관계</p>\n</blockquote>\n<p>수학이라는 학문 특유의 어려워 보이는 문법을 사용하긴 했지만 뜯어보면 별 거 없다. 이 정의에서 등장하는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span>는 정의역, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span></span>는 치역이라고 하며, 각각 정의역은 함수의 입력, 치역은 함수의 출력에 사용될 수 있는 값의 집합이라고 생각하면 된다.</p>\n<p>즉, 정의역은 함수의 인자로 사용되는 값들, 치역은 함수의 결과물로 사용되는 값들이라는 뜻이라고 봐도 무방하다.</p>\n<p>하지만 이 정의에서 가장 중요한 것은 정의역이니 치역이니 하는 개념이 아니라, 함수의 인자로 사용되는 값 하나에 대응하는 함수의 결과 값이 “유일하게 존재한다”라는 개념이다.</p>\n<p>어떤 값을 함수에 던지면 반드시 하나의 값을 반환하는 것, 이것이 본래 함수의 정의다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/33c48b0d809a227af542dee05cf064b5/80cfc/functions.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABNklEQVR42m2T207DMAyG3axt0tM6YBsgJC6QuNlASLvhqXggXoEX4zGK034GD7D0K4kPvx07ERE5Kk6KR0Uhi7SKF8U9OtNfK14Vz4pRfuQBXZMPSdFDYrLi3DqyLAHfTlE6fUIXBYdKscaQCTbok2VFGnQt/gUkl6ydsedsA4YctFdcucwmPdVnny22C8UNLcj+38xrKsv7HYSBcwAtyRtg5NFVPx8yagIqSBIBRmh9DfjYviE22jUi1fkK91wp/ENYYr8jZuTKAz5nldhgrJcFfQtuv6LCLf2ztbIBtrBvMNRk3PnJIR1Bg3tmeb1F19jkLLBw78omXDvC2pEm9zZtML38aeyb4mO+VvKNdhKx1QfFtPS0dEOiqnG+8kne9Qt9zk0Xmc5+yW95UsLDtHxZdV18vwAdIhBsPqNo7AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"functions\" title=\"\" src=\"/static/33c48b0d809a227af542dee05cf064b5/6af66/functions.png\" srcset=\"/static/33c48b0d809a227af542dee05cf064b5/69538/functions.png 160w,\n/static/33c48b0d809a227af542dee05cf064b5/72799/functions.png 320w,\n/static/33c48b0d809a227af542dee05cf064b5/6af66/functions.png 640w,\n/static/33c48b0d809a227af542dee05cf064b5/d9199/functions.png 960w,\n/static/33c48b0d809a227af542dee05cf064b5/21b4d/functions.png 1280w,\n/static/33c48b0d809a227af542dee05cf064b5/80cfc/functions.png 1844w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>오른쪽 그림처럼 정의역의 원소에 대응하는 치역의 원소가 없거나 2개 이상인 경우는<br>함수의 정의에서 벗어나게 된다</small>\n</center>\n<p>조금 더 편한 이해를 위해 인자로 받은 값에 2를 곱하는 간단한 함수를 생각해보자. 우리는 이런 함수를 정의할 때 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">f(x) = 2x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span></span></span></span></span>와 같은 식으로 나타낸다.</p>\n<p>이제 이 함수의 인자인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>를 1이라고 생각해보면 우리는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mo>×</mo><mn>1</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">f(1) = 2 \\times 1 = 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span></span>라는 결과를 얻을 수 있다. 만약 어느 날 갑자기 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">f(1) = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span>이 되어버린다면, 이 함수는 특정한 정의역의 원소에 맞대응되는 치역의 원소가 유일하지 않으므로 더 이상 함수라고 부를 수 없는 것이다.</p>\n<p>일반적으로 이야기하는 순수 함수의 특징들은 바로 이러한 수학적 함수의 성질에서 기원한다.</p>\n<h3 id=\"프로그래밍에서의-함수\" style=\"position:relative;\">프로그래밍에서의 함수<a href=\"#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98\" aria-label=\"프로그래밍에서의 함수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그러나 프로그래밍에서의 함수에는 이러한 제약이 전혀 없다. 이런 저런 예시를 들 것도 없이, 어떤 값도 반환하지 않는 <code class=\"language-text\">void</code>형 함수가 있지 않은가?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> y <span class=\"token operator\">=</span> x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">undefined</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>수학적인 함수의 정의로 비춰볼 때 이러한 <code class=\"language-text\">void</code>형 함수는 함수가 아니다. 정의역의 원소인 <code class=\"language-text\">x</code>와 맞대응하는 치역의 원소가 없기 때문이다. 그래서 프로그래밍에서의 함수라는 개념이 수학의 함수와 약간 다르다고 이야기하는 것이다.</p>\n<p>사실 프로그래밍의 함수는 수학의 함수에서 “어떤 값을 던져주면 뭔가를 계산한다”라는 개념만 들고 온 것에 불과하며, 수학적인 관점에서 바라보면 프로그래밍의 함수는 사실 함수가 아닌 경우가 더 많다.</p>\n<p>무엇보다 수학의 함수와 프로그래밍에서의 함수가 가장 큰 차이를 보이는 점은 바로 함수의 동작이 일관되지 않을 수 있다는 것이다.</p>\n<p>아까 예시로 들었던 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">f(x) = 2x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span></span></span></span></span>라는 수학의 함수는 내부 구현이 어떻게 되어있던 항상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>로 1을 받으면 2를 뱉어내는 것이 보장되어 있지만, 프로그래밍에서는 그렇지 않은 함수도 얼마든지 만들어 낼 수 있다.</p>\n<p>예를 들면 <code class=\"language-text\">Math.random</code>이라던가, <code class=\"language-text\">Date.prototype.getTime</code>과 같은 메소드들을 사용한 함수 같은 것들 말이다. 이 메소드들은 함수의 동작과 전혀 상관없는 값을 만들어내기 때문에, 함수의 연산이 이러한 값들에 종속되어 버린다면 개발자는 이 함수가 어떤 값을 뱉어낼 지 절대 예측할 수가 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">sum</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token number\">5</span> <span class=\"token comment\">// ?</span>\n<span class=\"token number\">4</span> <span class=\"token comment\">// ?</span>\n<span class=\"token number\">9</span> <span class=\"token comment\">// ?</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이런 개념은 특정한 의미를 가지는 값들을 저장, 할당, 호출할 수 있는 프로그래밍의 세계에서만 존재하는 것들이며, 수학의 세계에서는 이런 개념 자체가 없다.</p>\n<p>이렇게 특정한 의미를 가지는 값들을 우리는 상태(State)라고 부른다. 상태는 프로그램의 현재 상황을 보여주는 좋은 역할도 하지만, 여기저기서 무분별하게 이 상태를 참조하거나 변경하는 경우, 개발자조차 현재 프로그램이 어떻게 돌아가는지 파악하기 힘든 슬픈 상황이 발생할 수도 있다.</p>\n<p>그래서 개발자들은 상태를 변경하는 행위에 특정한 규칙과 제약을 정해서 무분별한 상태 변화를 최대한 피하고, 이런 변화를 추적할 수 있는 상황을 선호한다.</p>\n<p>문제는 프로그래밍에서의 함수는 이런 상태들, 더 정확히 이야기하자면 함수 외부의 상태들과 뭔가 썸씽이 생기는 경우가 많다는 것이다. 여기 인자로 받은 수를 함수 외부에 선언된 변수와 더한 후 반환하는 <code class=\"language-text\">addState</code>라는 간단한 함수가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">let</span> state <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">addState</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> state <span class=\"token operator\">+</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">addState</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">4</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">addState</code> 함수는 자신 외부에 있는 <code class=\"language-text\">state</code>라는 값을 참조하여 자신이 인자로 받은 수를 더해주는 간단한 일을 한다.</p>\n<p>즉, 이 함수의 결과 값은 함수의 외부 상태인 <code class=\"language-text\">state</code> 변수에 종속되어 있다는 것이며, 이런 상황은 개발자가 함수의 동작을 예측할 수 없게 만드는 위험 요소로 작용할 수 있다.</p>\n<p>만약 다른 곳에서 <code class=\"language-text\">state</code> 변수의 값을 변경이라도 하면 상황은 더욱 꼬이기 시작할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">state <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">addState</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">11</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이전과 같은 함수에 같은 인자를 사용했지만, 결과값은 전혀 다르게 나왔다. 이 함수는 외부 상태의 변화에 따라 자신의 결과 값도 변경되기 때문에, 개발자는 이 함수의 동작을 전혀 예측할 수 없는 것이다.</p>\n<p>이렇게 함수가 함수 외부 상태에 영향을 받거나, 함수 외부 상태를 직접 변경하는 행위를 “사이드 이펙트(Side Effect)“라고 하며, 사이드 이펙트를 발생시키는 함수는 개발자가 예측하지 못한 버그를 발생시키는 위험 요소 중 하나이다.</p>\n<p>그런 이유로 자바스크립트와 같은 언어에서는 전역 변수의 선언 및 할당을 최대한 지양하는 컨벤션을 내놓기도 하며, React Hooks에서는 사이드 이펙트를 발생시키는 동작을 따로 구분하기 위해 <code class=\"language-text\">useEffect</code>라는 훅을 제공하기도 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">TestComponent</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">setItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'greeting'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Hi'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">removeItme</span><span class=\"token punctuation\">(</span><span class=\"token string\">'greeting'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">TestComponent</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>지금 이게 간단한 함수인데다가 의도적으로 연출한 상황이라 부자연스러워 보일 수도 있지만, 실제 어플리케이션에는 이거보다 훨씬 복잡하고 이상한 짓들을 하는 함수가 수두룩하다.</p>\n<p>예를 들면 API 서버와 통신한 결과물을 뱉어내는 간단한 함수 또한 순수하지 않은 함수의 일종이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getUsers</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/users'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> e<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>딱 봐도 <code class=\"language-text\">getUsers</code>는 호출할 때마다 항상 같은 값을 반환하는 함수는 아니다. 현재 데이터베이스의 상태에 따라 유저 리스트는 매번 달라질 수 있기 때문이다.</p>\n<p>이렇게 순수하지 않은 함수는 개발자가 함수의 결과를 예측하는 것이 불가능하기 때문에, 함수의 동작을 검사하는 테스트를 작성하는 것 또한 불가능하다. 애초에 아웃풋으로 뭘 내보낼 지도 감이 안오는 변덕스러운 녀석을 어떤 기준으로 검사한단 말인가?</p>\n<p>이렇듯 프로그래밍의 세계에서 이야기하는 함수는 수학의 함수보다 더 변수가 많고, 결과를 예측하기가 힘든 개념이다.</p>\n<h2 id=\"순수한-수학적-함수로-회귀하자\" style=\"position:relative;\">순수한 수학적 함수로 회귀하자<a href=\"#%EC%88%9C%EC%88%98%ED%95%9C-%EC%88%98%ED%95%99%EC%A0%81-%ED%95%A8%EC%88%98%EB%A1%9C-%ED%9A%8C%EA%B7%80%ED%95%98%EC%9E%90\" aria-label=\"순수한 수학적 함수로 회귀하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 이제 수학의 세계에서 말하는 함수와 프로그래밍의 세계에서 말하는 함수의 차이를 살펴보았으니, 다시 순수 함수의 정의를 가져와보자.</p>\n<blockquote>\n<ol>\n<li>동일한 인풋(인자)에는 항상 동일한 결과를 내야한다.</li>\n<li>함수 외부의 상태를 변경하거나, 외부의 상태에 영향을 받아서는 안된다.</li>\n</ol>\n</blockquote>\n<p>앞서 이야기 했듯이, 수학의 세계에서 함수는 단순히 인풋을 받으면 뭔가 계산을 해서 단 하나의 결과를 내는 개념이다.</p>\n<p>그리고 수학의 세계에는 뭔가 값을 저장해놓고 할당도 하고 호출할 수도 있는 상태라는 개념이 없으니, 함수가 함수 외부 상태에 영향을 주고 받는 사이드 이펙트라는 것도 당연히 존재할 수가 없다.</p>\n<p>즉, 수학에서의 함수를 프로그래밍에 그대로 적용하면 순수한 함수의 특성인 “함수의 결과는 함수의 인자에만 영향을 받는다”라는 조건과 “함수 외부의 상태를 변경하거나 영향을 받아선 안된다”라는 조건이 자연스럽게 충족되는 것이다.</p>\n<p>그리고 함수형 프로그래밍에서 이야기하는 불변성(immutable) 또한 수학과 맞닿아 있는 지점인데, 애초에 상태라는 개념이 존재하지 않는 수학의 함수를 프로그래밍으로 구현한 순수 함수를 사용하고 있으니, 상태를 변경한다는 개념 또한 없어야 하는 것이다.</p>\n<p>하지만 프로그래밍의 세계에는 엄연히 상태라는 개념이 존재하기 때문에, “함수의 인자를 직접 수정해서는 안된다”와 같은 제약들을 스스로 정의하고 지켜나갈 수 있도록 저런 개념을 명시적으로 이야기하는 것이다.</p>\n<p>또한 순수 함수를 사용함으로써 따라오는 장점들인 “테스트가 쉬워진다”, “참조 투명성이 보장된다”와 같은 이야기들도 수학적인 개념에서의 함수를 생각하면 사실 당연하기 그지 없는 이야기들이다.</p>\n<p>앞서 잠깐 이야기 했지만, 매번 다른 값이 나오는 함수에 대한 유닛 테스트를 짠다고 생각해보면 진짜 답이 없다. 애초에 개발자가 함수의 동작을 예측할 수 없으니 함수의 동작에 대한 모법 답안을 제시할 수도 없을 것이고, 당연히 테스트 작성도 불가능 하다.</p>\n<p>또한 순수 함수를 사용하면 참조 투명성이 보장된다는 말도 결국 우리가 수학에서 사용하고 있는 <code class=\"language-text\">=</code> 기호의 의미를 생각해보면 그렇게 특별한 말이 아니다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right\" columnspacing=\"\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mo>∴</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\nf(x) = 2x\\\\\n\\\\\nf(1) = 2\\\\\n\\\\\n\\therefore f(1) + 1 = 3\n\\end{aligned}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:7.5em;vertical-align:-3.5em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:4em;\"><span style=\"top:-6.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span></span></span><span style=\"top:-4.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"></span></span><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">2</span></span></span><span style=\"top:-1.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"></span></span><span style=\"top:-0.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mrel amsrm\">∴</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:3.5em;\"><span></span></span></span></span></span></span></span></span></span></span></span></div>\n<center>\n  <small>참조 투명성이라는 것은 $f(1)$(함수의 실행부)를 $2$(함수의 결과물)로 치환해도<br />계산 결과가 변하지 않는다는 것을 의미하는데, 애초에 우리는 예전부터 수학에서 그 개념을 사용하고 있었다</small>\n  <br />\n  <br />\n</center>\n<p>이렇듯 순수 함수는 어떤 인자를 사용했을 때 어떤 결과 값이 나올 지 동작을 예측할 수 있고, 상태라는 것을 아예 없애버린 개념이기 때문에, 개발자가 예측 가능한 어플리케이션을 개발하기 쉽게 만들어준다.</p>\n<p>또한 함수 자체가 함수 외부의 상태와 관계 없이 순수하게 단일한 연산에만 집중하고 있으니, 한 어플리케이션에서 선언한 순수 함수는 다른 어플리케이션에다가 가져다 붙혀도 반드시 동일한 동작을 한다는 것이 보장된다. 즉, 좋은 모듈화의 조건 중 하나인 “높은 응집도”에도 부합한다.</p>\n<p>이렇게 순수 함수를 사용하여 작성된 어플리케이션은 개발자가 구조와 동작을 쉽게 이해할 수 있기 때문에, 굳이 함수형 프로그래밍 패러다임이 아니더라도 전반적인 어플리케이션 설계에 꽤나 도움이 되는 개념이라고 할 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 처음 순수 함수라는 개념을 접했을 때 구글링과 다른 분들이 작성해주신 포스팅들을 통해 순수 함수의 특징, 장점, 단점 등을 먼저 접하게 되었는데, 당시에는 “또 새롭게 공부할게 나왔구만”이라는 생각이었다.</p>\n<center>\n  <div style=\"width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ec770d51e3153214eac6e428c748abbb/80e3c/study.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 113.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAECBAMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAfbjPCbFS86hpB//xAAcEAEAAgIDAQAAAAAAAAAAAAABAAIRIgMSMTL/2gAIAQEAAQUCvrURmScttj76ktTKURPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGBABAAMBAAAAAAAAAAAAAAAAEQEQIQD/2gAIAQEABj8CRsniJ202v//EABoQAQEAAwEBAAAAAAAAAAAAAAERACFBUXH/2gAIAQEAAT8hQlF4dz2h8cl2YJTqwM2io3OzBCpfuPSDunpgDf0rtwwmf//aAAwDAQACAAMAAAAQ7M8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8QKf/EAB0QAQACAwEAAwAAAAAAAAAAAAEAESExQWGBoeH/2gAIAQEAAT8QpGGti8i3Ae37AVU8OJVFeiG3V39RoErA9NvxLsE9hQU5GkhsIFAUZ7FabQBn/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"study\" title=\"\" src=\"/static/ec770d51e3153214eac6e428c748abbb/c08c5/study.jpg\" srcset=\"/static/ec770d51e3153214eac6e428c748abbb/0913d/study.jpg 160w,\n/static/ec770d51e3153214eac6e428c748abbb/cb69c/study.jpg 320w,\n/static/ec770d51e3153214eac6e428c748abbb/c08c5/study.jpg 640w,\n/static/ec770d51e3153214eac6e428c748abbb/80e3c/study.jpg 720w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>또 새로운 공부거리가 생겨버렸네...</small>\n  <br>\n  <br>\n</center>\n<p>사실 순수 함수와 같은 패러다임을 처음 접하게 되면 습관처럼 구글링을 통해 정보를 습득하고 공부를 하게 되는데, 이때 일반적으로 다른 사람들이 정리해놓은 포스팅을 보고 공부하게 되는 경우가 많았다.</p>\n<p>그러나 이렇게 공부를 하는 경우, 해당 패러다임의 근본적인 발생 이유나 원리에 대해서 깊이 파악하기 보다는 몇 가지 특징이나 장단점을 먼저 학습하게 되는 경우가 많았던 것 같다.</p>\n<p>그래서 순수 함수도 “새롭게 공부해야하는 것”이라는 느낌으로 받아들였었지만, 나중에 곰곰히 생각해보니 그냥 어릴 때 배웠던 수학적인 함수의 개념을 그대로 프로그래밍으로 구현한 것이라는 개념이라는 것을 깨닫고 꽤나 허무했던 기억이 있다.</p>\n<p>그래서 필자는 이 포스팅에서 “순수 함수는 이런저런 특징을 가진 함수”라고 설명하지 않았던 것이다. 개인적인 생각이기는 하지만, 대부분의 사람들은 어릴 때 이미 학교에서 함수에 대한 정의와 개념을 학습했기 때문에, “수학적인 함수”라는 키워드로 접근하는 것이 오히려 이해가 빠를 것이라고 생각했다.</p>\n<p>어쨌든 필자는 이 포스팅을 통해 순수 함수는 전혀 새로운 개념이 아니라는 이야기를 하고 싶었고, 대한민국 의무 교육을 받은 사람이라면 누구든지 다 익숙하게 받아들일 수 있는 개념이라는 것을 이야기하고 싶었다.</p>\n<p>물론 순수 함수를 사용하여 어떤 식으로 프로그램을 설계하는 것이 훌륭한 설계인지와 같은 이야기는 의무 교육과정에 없기 때문에 별도로 공부를 해야겠지만, 적어도 함수형 프로그래밍에서 중요한 키워드로 이야기하고 있는 순수 함수와 불변성에 대한 이해 정도는 그렇게 어려운 것은 아닐 것이라고 생각한다.</p>\n<p>다음 포스팅에서는 순수 함수와 함께 함수형 프로그래밍에서 중요한 개념 중 하나인 “불변성”에 대한 이야기를 해보려고 한다.</p>\n<p>이상으로 수학에서 기원한 프로그래밍 패러다임, 순수 함수 포스팅을 마친다.</p>","fields":{"slug":"20191229-about-pure-functions","path":"/2019/12/29/about-pure-functions/","lang":"ko"},"frontmatter":{"title":"수학에서 기원한 프로그래밍 패러다임, 순수 함수","subTitle":"순수 함수, 복잡한 코드를 단순하게 만드는 힘","date":"Dec 29, 2019","categories":["프로그래밍","아키텍처"],"tags":["함수형 프로그래밍","Functional Programming","순수 함수","사이드 이펙트","Pure Functions","Side Effects"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/023de5bc6ce10c061b00421bd714ce0c/d803c/thumbnail.png","srcSet":"/static/023de5bc6ce10c061b00421bd714ce0c/d803c/thumbnail.png 320w,\n/static/023de5bc6ce10c061b00421bd714ce0c/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/023de5bc6ce10c061b00421bd714ce0c/fc5c5/thumbnail.webp 320w,\n/static/023de5bc6ce10c061b00421bd714ce0c/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/023de5bc6ce10c061b00421bd714ce0c/01fb2/thumbnail.png","srcSet":"/static/023de5bc6ce10c061b00421bd714ce0c/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/023de5bc6ce10c061b00421bd714ce0c/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"Pure Functions","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}