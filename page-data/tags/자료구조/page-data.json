{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/자료구조/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"67beef61-375c-5350-835e-920406b53ae9","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%9E%99heap%EC%9D%B4%EB%9E%80\">힙(Heap)이란?</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%99%84%EC%A0%84-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%ACcomplete-binary-tree\">완전 이진 트리(Complete Binary Tree)</a></p>\n<ul>\n<li><a href=\"#%EB%B0%B0%EC%97%B4%EC%9D%B4-%EB%8D%94-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%9D%B4%EC%9C%A0\">배열이 더 효율적인 이유</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%99%84%EC%A0%84-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%99%80-%ED%9E%99%EC%9D%98-%EC%B0%A8%EC%9D%B4\">완전 이진 트리와 힙의 차이</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%9E%99%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EC%9E%90\">힙을 구현해보자</a></p>\n<ul>\n<li><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B0%92%EC%9D%98-%EC%82%BD%EC%9E%85-%EB%B2%84%EB%B8%94-%EC%97%85\">새로운 값의 삽입. 버블 업!</a></li>\n<li><a href=\"#%EB%A3%A8%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B0%92%EC%9D%84-%EB%B9%BC%EC%98%A4%EC%9E%90-%ED%8A%B8%EB%A6%AD%ED%81%B4-%EB%8B%A4%EC%9A%B4\">루트에서 값을 빼오자. 트릭클 다운!</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 대표적인 자료 구조 중 하나인 힙(Heap)에 대한 설명과 구현을 한번 해보려고 한다. 이전의 포스팅에서 몇 번 언급한 적이 있지만 필자는 지금 백수다. 이제 프라하에서 한 달간의 힐링도 끝났으니 슬슬 면접을 보러 다녀야 하는데, 모두들 알다시피 면접에서는 기초 알고리즘이나 자료 구조에 대한 질문이 들어올 확률이 굉장히 높다. 하지만 필자는 최근 1년 정도 기초 공부를 게을리 했기 때문에 다시 공부를 해야하는 상황이다.","html":"<p>이번 포스팅에서는 대표적인 자료 구조 중 하나인 힙(Heap)에 대한 설명과 구현을 한번 해보려고 한다.</p>\n<p>이전의 포스팅에서 몇 번 언급한 적이 있지만 필자는 지금 백수다. 이제 프라하에서 한 달간의 힐링도 끝났으니 슬슬 면접을 보러 다녀야 하는데, 모두들 알다시피 면접에서는 기초 알고리즘이나 자료 구조에 대한 질문이 들어올 확률이 굉장히 높다. 하지만 필자는 최근 1년 정도 기초 공부를 게을리 했기 때문에 다시 공부를 해야하는 상황이다.</p>\n<!-- more -->\n<p>그래서 일단은 자료 구조부터 다시 살펴볼 생각인데, 그 중 제일 기억이 잘 나지 않는 힙(Heap)부터 한번 부셔볼까 한다.</p>\n<h2 id=\"힙heap이란\" style=\"position:relative;\">힙(Heap)이란?<a href=\"#%ED%9E%99heap%EC%9D%B4%EB%9E%80\" aria-label=\"힙heap이란 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>힙은 기본적으로 완전 이진 트리(Complete Binary Tree)를 기본으로 한 자료 구조이며, 부모 노드와 자식 노드 간의 대소관계가 성립하는 자료 구조이다. 그렇기 때문에 힙의 루트 노드는 힙 내의 데이터들 중 가장 큰 값이거나 가장 작은 값이라고 할 수 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/26d27d27a40c51726b85a6765778022c/29114/heap.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABPUlEQVR42o1Sy0oDMRTt5/gH7gU/wB9w4UrQn9CFvyCC24obV1KhC0GhilAUoVCkUGydSWbUeSeZRx43TmZaQaelvYuThNxz77knaelGAECJnudhZLn4Iwh8vSRayy60zG+e8HF7lBBmKq5LBqWUWU87eOdkFCZ5JUc1KyzuLIRwMA6jhGYSI5tSulK2KQwi5n4P2RPG0pl8KTF26GcPMus3rUEGWUKGroLbjczrV1IlaDOA5CS432RvR/M0+Ec2Z5bmrjXM3Y6D3qWE2vrKeZ/YXd/uhxFdJBsKRmMbYc55eYpj4jpTyLFWlARjx/2qPSs3sT/Ron48mJHTwb7/cihkbXZRIhmfJY9bbHAQPmyLglRZSoGOnvfY6+6fzvn0nKP2XL+ZU5FhgS6Ed1egy/mQBsV3l7vXqz7JGvEDXwN3AjESS6YAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"heap\" title=\"\" src=\"/static/26d27d27a40c51726b85a6765778022c/6af66/heap.png\" srcset=\"/static/26d27d27a40c51726b85a6765778022c/69538/heap.png 160w,\n/static/26d27d27a40c51726b85a6765778022c/72799/heap.png 320w,\n/static/26d27d27a40c51726b85a6765778022c/6af66/heap.png 640w,\n/static/26d27d27a40c51726b85a6765778022c/d9199/heap.png 960w,\n/static/26d27d27a40c51726b85a6765778022c/21b4d/heap.png 1280w,\n/static/26d27d27a40c51726b85a6765778022c/29114/heap.png 1920w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>\n    루트에 최대 값이 오게 되는 Max Heap의 모습<br>\n    생긴 건 완전 이진 트리랑 똑같이 생겼다\n  </small>\n</center>\n<p>즉, 힙 내의 가장 큰 값이나 가장 작은 값에 접근하고 싶을 때 비교 연산없이 한번에 접근할 수 있다는 의미이며, 이 접근 연산의 시간 복잡도는 당연히 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>이다. 이런 힙의 성격 때문에 힙은 여러 개의 데이터 중에서 가장 크거나 작은 값을 빠르게 찾아야 하는 영역에서 유용하게 사용된다.</p>\n<p>사실 단순히 어떤 데이터 뭉치 안에서 최대 값이나 최소 값에 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>의 시간 복잡도로 접근하고 싶다면 그냥 링크드 리스트(Linked List)나 배열(Array)을 정렬해서 사용해도 무방하긴 하다. 한번 정렬만 해놓으면 그 다음부터는 그냥 헤드에서 값을 쏙쏙 뽑아다 쓰면 되기 때문이다.</p>\n<p>그러나 이렇게 정렬되어 있는 데이터 뭉치에 새로운 데이터를 추가할 때는 전체 데이터 뭉치를 싹 다 뒤져서 다시 최대, 최소 값이 무엇인지 찾아내고 재정렬하는 과정을 거쳐야한다.</p>\n<p>배열과 링크드 리스트과 같은 선형 자료 구조는 이 과정에 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>의 시간 복잡도가 소요되는 반면, 부모가 자식보다 크거나 작게 정렬된 이진 트리의 경우는 새로운 추가된 노드의 부모 노드들과만 비교해도 정렬 상태를 유지할 수 있기 때문에 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>의 시간 복잡도만 소요된다.</p>\n<p>즉, 정렬하고 싶은 데이터가 많을 수록 더 유리하다는 소리다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/47f8478a4454f5e1e36018547cc390aa/29114/compares.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABRUlEQVR42pWSzUoDMRDH+zi+gldBfBVBH8KjB19AUG+Klx48eFNQ1F5aCrJYkVq02Oxmt7vb/c7HJBOztLUHbdWBBDLML/+Zf9IwywOZQqlXFDSWgagM+FfsZR9Z8R8YrZpWwiRPB1Frq0qosfqo/6oMAK5HszDQVUw8v0gSA7/AWC9IZXRPRu9lWdU5CcC56wc5udVJf1ryE2ynNIaRZny9xsL2bG7UKJViSXy3Xvb2UNoEfIfr+8qK048ep5ceeVMKp8bZbex52eAicjuTSWZH+tKewyjKIh0RV0ppT2maU2+I3DW6yONX6o+NNlqAH4xpSIosMBoXcOVsR91dUFOzhd3zwWHW2iidncnDJoi8zkuBXDQfT5rOsa6Y1Z/BfHgkyem8/9pYnfcEOYPwRpDzhUna9En3edS2Rq74JMvDNjx/tk8Qa3f4BKGthQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"compares\" title=\"\" src=\"/static/47f8478a4454f5e1e36018547cc390aa/6af66/compares.png\" srcset=\"/static/47f8478a4454f5e1e36018547cc390aa/69538/compares.png 160w,\n/static/47f8478a4454f5e1e36018547cc390aa/72799/compares.png 320w,\n/static/47f8478a4454f5e1e36018547cc390aa/6af66/compares.png 640w,\n/static/47f8478a4454f5e1e36018547cc390aa/d9199/compares.png 960w,\n/static/47f8478a4454f5e1e36018547cc390aa/21b4d/compares.png 1280w,\n/static/47f8478a4454f5e1e36018547cc390aa/29114/compares.png 1920w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>전체 데이터를 비교할 필요없이 이 부분만 비교하면 다시 재정렬할 수 있다</small>\n</center>\n<p>힙은 완전 이진 트리를 기초로 하기 때문에 구현하는 방법 또한 완전 이진 트리와 흡사하다. 그렇기 때문에 힙을 구현해보기에 앞서 완전 이진 트리의 특징을 먼저 이야기 해보려고 한다.</p>\n<h2 id=\"완전-이진-트리complete-binary-tree\" style=\"position:relative;\">완전 이진 트리(Complete Binary Tree)<a href=\"#%EC%99%84%EC%A0%84-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%ACcomplete-binary-tree\" aria-label=\"완전 이진 트리complete binary tree permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>먼저, 힙의 기본이 되는 완전 이진 트리의 특징을 한번 살펴보자. 이진 트리(Binary Tree)란 어떤 하나의 노드가 자식 노드를 최대 2개까지만 가질 수 있는 트리를 말한다.</p>\n<p>그 말인 즉슨, 한 레벨에 최대로 들어설 수 있는 노드의 개수가 정해져있다는 뜻이고, 노드들에게 고유한 인덱스를 부여할 수 있다는 것을 의미한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e856823cf8415cb0c25f814a983547b7/3a5d5/not_allow_new_node.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 36.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABIUlEQVR42n1Qu07DMBTNH8IHMDPxB+wwIXVi4BdAzLAjoS7AwkMoIokD5GHydFPXrxwSJ61aoFiyr2zfc8/DwT+rbbWtM3KB/O4AZdVASgmt1VpPu4FxtoyyZw+MogRZQtCUAXw/QJqmYIzZLYSAMWYD5mxTN+cchBALXC6leoIIWZZbpXX3V5Wl7dFcAEL9GNhZ7LXN3RPQp1MMho21Za2N9or4EdX9PlpVw2iNRY+5PoOc7P1WWDEO6l0hC286lfrPMGjsofTPEUfhMh2Ytwfo28v1gQacfSIMic1FdvZCEkA08aDStjAkkYcsLyyC0i/Q7g4zW9E5aIdQTeOinO5C8mJFIdg7qukOWv4x5PpyiPp1MvIvbKmfj8Dd4/FN4Rtc0Rneo/vvfgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"not allow new node\" title=\"\" src=\"/static/e856823cf8415cb0c25f814a983547b7/6af66/not_allow_new_node.png\" srcset=\"/static/e856823cf8415cb0c25f814a983547b7/69538/not_allow_new_node.png 160w,\n/static/e856823cf8415cb0c25f814a983547b7/72799/not_allow_new_node.png 320w,\n/static/e856823cf8415cb0c25f814a983547b7/6af66/not_allow_new_node.png 640w,\n/static/e856823cf8415cb0c25f814a983547b7/d9199/not_allow_new_node.png 960w,\n/static/e856823cf8415cb0c25f814a983547b7/21b4d/not_allow_new_node.png 1280w,\n/static/e856823cf8415cb0c25f814a983547b7/3a5d5/not_allow_new_node.png 1807w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>부모 노드는 반드시 2개 이하의 자식 노드를 가져야 한다.</small>\n</center>\n<p>완전 이진 트리(Complete Binary Tree)는 이진 트리의 노드를 생성할 때 트리의 왼쪽부터 차곡차곡 채워 나가는 트리를 의미한다. 이때 완전 이진 트리의 한 레벨이 꽉 차기 전에는 다음 레벨에 노드를 생성할 수 없다. 즉, 마지막 레벨을 제외한 모든 레벨에는 노드가 꽉 차 있어야 한다는 뜻이다.</p>\n<p>트리는 보통 링크드 리스트(Linked List)나 배열(Array)과 같은 선형 자료 구조를 사용하여 구현하는데, 이때 링크드 리스트와 배열의 특징에 따라 장단점이 갈리기 때문에 선택이 필요하다. <small>(링크드 리스트와 배열의 차이에 대한 내용은 이 포스팅의 주제가 아니므로 따로 설명하지는 않겠다.)</small></p>\n<p>일반적으로 트리는 링크드 리스트를 사용하여 구현하지만 완전 이진 트리의 경우에는 배열로 구현하는 것이 더 효율적이다.</p>\n<h3 id=\"배열이-더-효율적인-이유\" style=\"position:relative;\">배열이 더 효율적인 이유<a href=\"#%EB%B0%B0%EC%97%B4%EC%9D%B4-%EB%8D%94-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%9D%B4%EC%9C%A0\" aria-label=\"배열이 더 효율적인 이유 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>사실 일반적으로 트리를 구현할 때 링크드 리스트를 사용하는 이유는 배열을 사용하여 트리를 구현하면 메모리 고정 할당 방식이라는 배열의 특성 상 불편한 점이 너무 많기 때문이다.</p>\n<p>그러나 완전 이진 트리에서는 이 불편한 점들이 사라지기 때문에 배열의 장점을 오롯이 가져갈 수 있다.</p>\n<h4 id=\"원하는-노드로의-접근이-쉽다\" style=\"position:relative;\">원하는 노드로의 접근이 쉽다<a href=\"#%EC%9B%90%ED%95%98%EB%8A%94-%EB%85%B8%EB%93%9C%EB%A1%9C%EC%9D%98-%EC%A0%91%EA%B7%BC%EC%9D%B4-%EC%89%BD%EB%8B%A4\" aria-label=\"원하는 노드로의 접근이 쉽다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>이건 배열의 최대 장점인 인덱스만 알면 해당 원소에 바로 접근이 가능하다는 장점을 그대로 살린 것이다. 이진 트리는 각 레벨에 들어설 수 있는 노드의 최대 개수가 정해져 있기 때문에 간단한 수식만으로 특정 노드의 인덱스를 알아내어 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>의 시간 복잡도로 노드에 접근할 수 있다.</p>\n<p>먼저, 특정 노드를 기반으로 부모나 자식 노드에 접근하고 싶다면 다음과 같이 인덱스를 계산해볼 수 있다.</p>\n<blockquote>\n<p>루트 노드가 0번 인덱스를 가지고, 현재 노드가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></span>번 인덱스를 가지고 있을 때</p>\n<ul>\n<li>부모 노드: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">(i-1) / 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/2</span></span></span></span></span></li>\n<li>왼쪽 자식 노드: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></li>\n<li>오른쪽 자식 노드: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2i+2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span></span></li>\n</ul>\n</blockquote>\n<p>위와 같이 특정 노드의 인덱스를 기반으로 부모와 자식들의 인덱스를 알아내는 방법도 있지만, 배열로 만든 완전 이진 트리의 진짜 장점은 간단한 수식을 통해서 원하는 레벨, 원하는 순번의 노드로 바로 접근할 수도 있다는 것이다.</p>\n<p>완전 이진 트리의 성질을 이용하면 특정 레벨까지의 최대 노드 개수인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></span>를 간단히 계산할 수 있기 때문에 가능한 일이다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>c</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">c = 2^{level} - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9824em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">getAllNodeCountByLevel</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">level <span class=\"token operator\">=</span> <span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">2</span> <span class=\"token operator\">**</span> level <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">getAllNodeCountByLevel</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">7</span> <span class=\"token comment\">// 3 레벨로 구성된 완전 이진 트리 내 노드의 최대 개수</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 식을 사용하면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>번째 레벨의 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span>번째 노드의 인덱스도 간단하게 알아낼 수 있다.</p>\n<p>예를 들어, 완전 이진 트리의 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> 레벨에 있는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span>번째 노드의 인덱스인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></span>를 구하고 싶다면, 내가 접근하고 싶은 레벨의 바로 위 레벨인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span> 레벨까지의 모든 노드의 개수 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></span>을 구하고, 거기에 해당 레벨 내에서 내가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span>번째 노드에 접근하고 싶은지만 더해주면 된다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>i</mi><mo>=</mo><mi>c</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i = c + m - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">getNodeIndex</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">level <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> count <span class=\"token operator\">=</span> <span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">getAllNodeCountByLevel</span><span class=\"token punctuation\">(</span>level <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> count <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">getNodeIndex</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">5</span> <span class=\"token comment\">// 3 레벨의 3 번째로 위치한 노드의 인덱스</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>마지막에 1을 빼주는 이유는 우리가 구하고 싶은 것이 노드의 순번이 아닌 인덱스이기 때문이다. 배열의 인덱스는 <code class=\"language-text\">0</code>부터 시작한다는 사실을 잊지 말자.</p>\n<p>이처럼 배열로 구현한 완전 이진 트리는 간단한 계산만으로 원하는 노드에 접근하기가 용이하지만, 링크드 리스트로 구현하게되면 원하는 노드에 바로 접근할 수 없고, 트리를 순회하여 접근해야한다.</p>\n<h4 id=\"배열의-원소를-뒤로-밀어줘야-할-일이-없다\" style=\"position:relative;\">배열의 원소를 뒤로 밀어줘야 할 일이 없다<a href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%9B%90%EC%86%8C%EB%A5%BC-%EB%92%A4%EB%A1%9C-%EB%B0%80%EC%96%B4%EC%A4%98%EC%95%BC-%ED%95%A0-%EC%9D%BC%EC%9D%B4-%EC%97%86%EB%8B%A4\" aria-label=\"배열의 원소를 뒤로 밀어줘야 할 일이 없다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>배열은 메모리에 연속적인 공간을 할당하여 사용하기 때문에, 배열 중간에 원소를 끼워넣으려면 새로운 메모리 공간을 확보하기 위해 원소를 한 칸씩 뒤로 밀어줘야하는 슬픈 상황이 발생하지만, 링크드 리스트는 그냥 <code class=\"language-text\">prev</code> 값과 <code class=\"language-text\">next</code> 값만 변경함으로써 중간에 새로운 원소를 끼워넣기가 편하다.</p>\n<p>그러나 이진 트리의 경우, 자식 노드를 최대 2개까지만 가질 수 있다는 제약이 있기 때문에 높이가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span></span>인 트리는 최대 노드 개수가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{h} -1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9324em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>개로 정해져있다. 즉, 이 크기 만큼만 배열을 메모리에 할당하고 나면 중간에 노드를 새로 삽입하기 위해 배열의 원소를 뒤로 밀어야하는 경우가 발생하지 않는다는 것이다.</p>\n<h4 id=\"트리가-기울어지지-않는다\" style=\"position:relative;\">트리가 기울어지지 않는다<a href=\"#%ED%8A%B8%EB%A6%AC%EA%B0%80-%EA%B8%B0%EC%9A%B8%EC%96%B4%EC%A7%80%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4\" aria-label=\"트리가 기울어지지 않는다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>일반적으로 배열로 구현한 트리가 기울어지게 되면 메모리 공간에 심한 낭비가 생기게 되는데, 그 이유는 그림으로 보면 이해하기가 한결 편하다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/594a877d7281f11d27e067794310ed3f/0f98f/balanced.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAQACBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvGiGav//EABcQAAMBAAAAAAAAAAAAAAAAAAEQESD/2gAIAQEAAQUCOIv/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAbEAACAwADAAAAAAAAAAAAAAABEQAQUTFhof/aAAgBAQABPyEl3Gjr8pBk7AA4Ff/aAAwDAQACAAMAAAAQlw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAgEBPxCn/8QAGxABAAIDAQEAAAAAAAAAAAAAAREhABAxUfD/2gAIAQEAAT8Qh0S8MFQ38H5GgiF9OPqQvdf/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"balanced\" title=\"\" src=\"/static/594a877d7281f11d27e067794310ed3f/c08c5/balanced.jpg\" srcset=\"/static/594a877d7281f11d27e067794310ed3f/0913d/balanced.jpg 160w,\n/static/594a877d7281f11d27e067794310ed3f/cb69c/balanced.jpg 320w,\n/static/594a877d7281f11d27e067794310ed3f/c08c5/balanced.jpg 640w,\n/static/594a877d7281f11d27e067794310ed3f/6a068/balanced.jpg 960w,\n/static/594a877d7281f11d27e067794310ed3f/eea4a/balanced.jpg 1280w,\n/static/594a877d7281f11d27e067794310ed3f/0f98f/balanced.jpg 1920w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>위 그림은 이상적으로 균형이 잡힌 균형 이진 트리(Balanced Binary Tree)의 모습이다. 만약 이 트리를 배열로 구현한다면 메모리에는 이렇게 값들이 담길 것이다.</p>\n<table>\n<thead>\n<tr>\n<th>index</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>A</td>\n<td>B</td>\n<td>C</td>\n<td>D</td>\n<td>E</td>\n<td>F</td>\n</tr>\n</tbody>\n</table>\n<p>배열 중간에 빈 공간이 없이 차곡차곡 메모리에 담겼다. 노드의 인덱스는 트리의 왼쪽부터 순차적으로 부여되기 때문에 자식 노드를 왼쪽부터 생성한다면 메모리에 빈 공간을 만들지 않을 수 있다.</p>\n<p>물론 자식 노드를 생성할 때 왼쪽을 건너 뛰고 오른쪽부터 생성하면 빈 공간이 생기긴 하지만, 더 큰 문제는 트리가 한 쪽으로 크게 기울어지게 되게 되는 편향 트리가 되는 경우이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9b55af495204108a9d6c5989a4f0ee15/0f98f/unbalanced.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvyqDVf//EABUQAQEAAAAAAAAAAAAAAAAAABBC/9oACAEBAAEFAmj/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAQMf/aAAgBAgEBPwGn/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGxABAAICAwAAAAAAAAAAAAAAAQARITEQcYH/2gAIAQEAAT8hWi2UuXyF1ncNuuf/2gAMAwEAAgADAAAAEFQP/8QAFREBAQAAAAAAAAAAAAAAAAAAEDH/2gAIAQMBAT8Qh//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EBj/xAAbEAADAAIDAAAAAAAAAAAAAAABESEAQRAxof/aAAgBAQABPxAbiY5EEFprIIirrKfoF7z/AP/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"unbalanced\" title=\"\" src=\"/static/9b55af495204108a9d6c5989a4f0ee15/c08c5/unbalanced.jpg\" srcset=\"/static/9b55af495204108a9d6c5989a4f0ee15/0913d/unbalanced.jpg 160w,\n/static/9b55af495204108a9d6c5989a4f0ee15/cb69c/unbalanced.jpg 320w,\n/static/9b55af495204108a9d6c5989a4f0ee15/c08c5/unbalanced.jpg 640w,\n/static/9b55af495204108a9d6c5989a4f0ee15/6a068/unbalanced.jpg 960w,\n/static/9b55af495204108a9d6c5989a4f0ee15/eea4a/unbalanced.jpg 1280w,\n/static/9b55af495204108a9d6c5989a4f0ee15/0f98f/unbalanced.jpg 1920w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<table>\n<thead>\n<tr>\n<th>index</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>index</td>\n<td>A</td>\n<td>B</td>\n<td>C</td>\n<td>D</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>H</td>\n</tr>\n</tbody>\n</table>\n<p>위 그림처럼 한 쪽으로 크게 기운 편향 트리는 중간 인덱스를 건너뛰고 다음 레벨에 노드를 생성한 경우이기 때문에 메모리에 빈 공간이 생길 수 밖에 없다. 그렇기 때문에 메모리 공간이 낭비된다고 하는 것이다. 물론 오른쪽으로 기울었다면 건너뛰어야 하는 인덱스도 더 크기 때문에 메모리 공간의 낭비가 더 심해진다.</p>\n<p>그러나 완전 이진 트리는 노드를 왼쪽부터 차곡차곡 채워나가고, 한 레벨의 노드가 다 채워지기 전까지는 다음 레벨에 노드를 채울 수 없다는 제약들이 걸려있기 때문에 애초에 트리가 기울어질 일 자체가 없으니 메모리에 빈 공간이 생길 일도 없다.</p>\n<p>이런 이유들로 인해 완전 이진 트리는 원소에 바로 접근이 가능한 배열의 장점을 살려서 구현하는 경우가 많고, 완전 이진 트리를 기반으로 하는 힙(Heap) 또한 마찬가지 이유로 인해 주로 배열로 구현하게된다.</p>\n<h2 id=\"완전-이진-트리와-힙의-차이\" style=\"position:relative;\">완전 이진 트리와 힙의 차이<a href=\"#%EC%99%84%EC%A0%84-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%99%80-%ED%9E%99%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"완전 이진 트리와 힙의 차이 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>힙(Heap)은 완전 이진 트리를 기초로 하기 때문에 기본적인 노드의 삽입 및 삭제 알고리즘은 일반적인 완전 이진 트리와 동일하다. 노드의 삽입은 반드시 배열의 끝에만 가능하며, 노드를 삭제하고 나면 빈 공간이 남지 않도록 남은 노드들을 다시 당겨서 빈 공간을 채워줘야한다.</p>\n<p>다만 힙은 부모와 자식 노드 간의 대소관계가 성립되어야 한다는 조건이 있기 때문에, “삽입 및 삭제 후 노드를 다시 정렬해주는 기능”이 추가로 필요하다.</p>\n<p>또한 힙은 사실 트리 내의 최대 값이나 최소 값을 쉽게 찾고자 하는 자료 구조이기 때문에, 트리 중간에 위치한 노드에 바로 접근할 일도 거의 없다. 항상 <code class=\"language-text\">Array[0]</code>에 위치한 루트 노드를 뽑아다 쓰면 되기 때문이다. 루트 노드를 뽑아온다는 것은 곧 루트 노드의 삭제를 의미하기 때문에 마찬가지로 힙을 다시 정렬해줘야한다.</p>\n<p>힙은 최대 힙(Max Heap)과 최소 힙(Min Heap)으로 나누어지는데, 최대 힙은 항상 부모의 값이 자식보다 커야하고, 최소 힙은 반대로 부모의 값이 자식보다 작아야 한다. 즉, “최대 힙의 루트는 힙 내에서 가장 큰 값”, “최소 힙의 루트는 힙 내에서 가장 작은 값”을 의미한다는 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7ef8339acc6f0333106978ece7c8b376/00d43/min-max-heap.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAC4jAAAuIwF4pT92AAABYUlEQVR42nVS2ZKDIBDM/3/hvmw2ajwCiNyHEdxWEjebqowU1bTdM8PoabRSelPWTTCmODeCSk7EuIORSADJ1FTWIYbxJL1e98g5D33fXq91VRFCLj+Xru0A2uZKKQVu6gZgU+JZV+E1zOY4lxTLsuQ9UkovIJXjIYbxaS4snDmtHyLlD+a0syq6M23Ts4u3qNhAFT/E/yqHZdazd3NAirf6OJrZ2zno6Nw9lty72W0DA/tN23tagDtBa357NdfjMAgGAMHXUCHRw6y8icuMaiiLHRfjQaOICHYbVc4yWFSbgoZz46NV0aJN5e1JBVOzXgenve0nCl1DB1z7TFpIbfQV67d29lcDvrQzKtiaDdj/7ky9ZF4RJ1hQmOc+2VyKo53O8tHrmxMy2vwysMdPAlZGBwXafpszsiAvGh6Dxg4mLndmxIlbhe6xbHAmOPQJgCMSF74A8Cb4otHeVVPfCvILGpu2RzRW2cIAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"min max heap\" title=\"\" src=\"/static/7ef8339acc6f0333106978ece7c8b376/6af66/min-max-heap.png\" srcset=\"/static/7ef8339acc6f0333106978ece7c8b376/69538/min-max-heap.png 160w,\n/static/7ef8339acc6f0333106978ece7c8b376/72799/min-max-heap.png 320w,\n/static/7ef8339acc6f0333106978ece7c8b376/6af66/min-max-heap.png 640w,\n/static/7ef8339acc6f0333106978ece7c8b376/d9199/min-max-heap.png 960w,\n/static/7ef8339acc6f0333106978ece7c8b376/00d43/min-max-heap.png 1000w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>즉, 힙을 구현한다는 것은 완전 이진 트리를 구현하고, 최대 힙과 최소 힙에 맞는 정렬 기능을 추가하면 된다는 것을 의미한다.</p>\n<h2 id=\"힙을-구현해보자\" style=\"position:relative;\">힙을 구현해보자<a href=\"#%ED%9E%99%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"힙을 구현해보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>일단 최대 힙과 최소 힙의 차이는 사실 정렬할 때 조건 밖에 없으니, 필자는 최대 힙만 구현해보려고 한다. 위에서 이야기 했듯이 완전 이진 트리의 경우는 링크드 리스트를 이용하는 것보다 배열을 이용하는 것이 더 효율적이기 때문에 배열을 이용하여 구현할 것이다.</p>\n<p>일단 작고 귀여운 <code class=\"language-text\">MaxHeap</code> 클래스를 하나 만들어주자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MaxHeap</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>만약 링크드 리스트로 구현하고자 한다면 <code class=\"language-text\">Node</code> 클래스를 별도로 선언해서 사용하겠지만 필자가 사용할 자료 구조는 배열이기 때문에 단촐하기 그지 없다. 그럼 이제 힙에 값을 삽입하는 메소드부터 한번 만들어보도록 하자.</p>\n<h3 id=\"새로운-값의-삽입-버블-업\" style=\"position:relative;\">새로운 값의 삽입. 버블 업!<a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B0%92%EC%9D%98-%EC%82%BD%EC%9E%85-%EB%B2%84%EB%B8%94-%EC%97%85\" aria-label=\"새로운 값의 삽입 버블 업 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>힙에 새로운 값을 삽입할 때는 완전 이진 트리의 규칙대로 무조건 트리의 왼쪽부터 채워나간다. 그 말인 즉슨, 그냥 <code class=\"language-text\">push</code> 메소드를 사용하여 배열의 꼬리로 값을 하나씩 쑤셔넣어주면 된다는 것이다. 잘 이해가 되지 않는다면 위의 완전 이진 트리 설명 부분을 다시 읽어보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">insert</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>최대 힙은 항상 부모가 자식보다 큰 값을 가져야한다는 제약이 있으므로, 만약 우리가 힙에 삽입한 노드가 부모 노드보다 큰 값을 가지고 있다면 두 노드의 위치를 바꿔줘야한다.</p>\n<p>그리고 이 작업을 현재 삽입한 노드가 루트까지 올라가거나, 부모보다 작은 값을 가지게 되거나, 두 조건 중 하나를 만족할 때까지 반복한다.</p>\n<p>이때 새로 추가한 값이 부모 노드와 스왑되면서 점점 트리의 위로 올라가는 모양새가 거품이 뽀글뽀글 올라오는 모양새랑 비슷하다고 해서 “버블 업(Bubble Up)“이라고 부른다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ba74af93911b1287276f76834eaa6b01/29114/bubbleup.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABMklEQVR42qWSy0rDQBSG+zi+gluh7yLoI/gIgmulW8VFXYlLoUgUQbTUQhWk1NJMpiGZ1GRmkrnljJmmFUpFK57Fv/g537lxGvYf0fjehrISQzpieAig/gJXJJQV/fF6RLxmweJlOdios9YaBTjLZqCZjzBj9NfOrjDoVBEP+e+c57VrjAkCzEIPxOQrbQ0GU0mBLpLrrSJ+cAZoa+fLS5rcbPPnAyssyALWYOfwXEwnAzG9wmhkzDwHnMYkoaNLMr6fJZmVyiq9CoPkLPVRoJS7bZrSKR6DCGzJKBniMKoAkDqM4pDgPA1X4Ly/S572tanvKiulw+Psbof392a3Ta2om4xmVpt2t9XundSLL2Axbil0upzf7VnSgURnOu5IdL44kjGWF2/o8SXq/fgkm33YJyCFeIuZ4cs3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"bubbleup\" title=\"\" src=\"/static/ba74af93911b1287276f76834eaa6b01/6af66/bubbleup.png\" srcset=\"/static/ba74af93911b1287276f76834eaa6b01/69538/bubbleup.png 160w,\n/static/ba74af93911b1287276f76834eaa6b01/72799/bubbleup.png 320w,\n/static/ba74af93911b1287276f76834eaa6b01/6af66/bubbleup.png 640w,\n/static/ba74af93911b1287276f76834eaa6b01/d9199/bubbleup.png 960w,\n/static/ba74af93911b1287276f76834eaa6b01/21b4d/bubbleup.png 1280w,\n/static/ba74af93911b1287276f76834eaa6b01/29114/bubbleup.png 1920w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>부모와 자리를 바꾸면서 트리의 위쪽으로 점점 올라간다</small>\n</center>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">insert</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">bubbleUp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">bubbleUp</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">index <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> currentNode <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> parentIndex <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> parentNode <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>parentIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parentNode <span class=\"token operator\">>=</span> currentNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> parentNode<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>parentIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> currentNode<span class=\"token punctuation\">;</span>\n  index <span class=\"token operator\">=</span> parentIndex<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">bubbleUp</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">bubbleUp</code> 메소드는 인자로 받은 인덱스의 노드의 값과 부모 노드의 값을 비교하여, 해당 노드가 부모 노드의 값보다 큰 값을 가지고 있다면 두 노드의 위치를 스왑하는 역할을 한다. 트리의 특성 상 이 작업은 분할 정복이 가능한 부분이므로 재귀 호출로 구현하였다.</p>\n<p>여기까지 작성하고 간단히 테스트를 해보면 힙 내의 가장 큰 값이 배열의 헤드, 즉 트리의 루트에 위치하게 된다는 것을 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> heap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MaxHeap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">23</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span> <span class=\"token number\">32</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span> <span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <img src=\"/9e2a2f66409a09f23bc1717c7002b9fd/max-heap.gif\" width=\"100%\">\n  <br>\n  <small>부모보다 큰 값이 추가되면 부모와 자리를 바꾼다</small>\n  <br>\n  <br>\n</center>\n<h3 id=\"루트에서-값을-빼오자-트릭클-다운\" style=\"position:relative;\">루트에서 값을 빼오자. 트릭클 다운!<a href=\"#%EB%A3%A8%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B0%92%EC%9D%84-%EB%B9%BC%EC%98%A4%EC%9E%90-%ED%8A%B8%EB%A6%AD%ED%81%B4-%EB%8B%A4%EC%9A%B4\" aria-label=\"루트에서 값을 빼오자 트릭클 다운 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>값의 삽입과 버블 업을 구현해보았으면 이번에는 루트에서 값을 빼오는 메소드를 만들어보자. 즉, 삭제 연산이다. 이 경우 루트 노드를 뽑아버리면 루트 노드의 자리가 비게 되니 힙을 재정렬해서 다시 루트 노드를 채워줘야한다.</p>\n<p>이때 기존 루트 노드의 자식 노드들을 루트 노드로 올리는 것이 아니라 트리의 가장 마지막에 위치한 노드를 가져와서 루트 노드로 삽입하게 되는데, 이는 수정될 힙에서 빈 공간이 생기지 않게 함으로써 연산량을 줄이기 위해서이다.</p>\n<p>바로 루트의 바로 밑에 있는 자식들을 끌어올려서 루트로 사용해버리면 자연스럽게 그 노드가 있던 곳은 공백이 생기게 되고, 그럼 또 다음 레벨에서 어떤 노드를 끌여올려야 할지 비교 연산이 필요하게 되기 때문이다.</p>\n<p>그리고 힙은 반드시 완전 이진 트리의 형태를 유지해야하기 때문에 이 과정에서 트리가 한 쪽으로 기울게 되버리면 또 트리의 균형을 맞춰줘야하는 번거로움도 생길 수 있다.</p>\n<p>그래서 가장 마지막에 위치한 노드를 새로운 루트 노드로 사용하고 자식들과 값을 비교해나가면서 자리를 바꿔나가는데, 이때 새로운 루트 노드가 트리의 아래 쪽으로 점점 이동하는 모양새가 물방울이 떨어지는 모양새랑 비슷하다고 해서 “트릭클 다운(Trickle Down)“이라고 부른다. <small>(컴퓨터 용어 주제에 왠지 갬성적이다…)</small></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">extract</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> max <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">trickleDown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> max<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">trickleDown</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">index <span class=\"token operator\">=</span> <span class=\"token number\">0</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> leftChildIndex <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> rightChildIndex <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> index <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> length <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> largest <span class=\"token operator\">=</span> index<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leftChildIndex <span class=\"token operator\">&lt;=</span> length <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>leftChildIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>largest<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    largest <span class=\"token operator\">=</span> leftChildIndex<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rightChildIndex <span class=\"token operator\">&lt;=</span> length <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>rightChildIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>largest<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    largest <span class=\"token operator\">=</span> rightChildIndex<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>largest <span class=\"token operator\">!==</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>largest<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">[</span>largest<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">trickleDown</span><span class=\"token punctuation\">(</span>largest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>트릭클 다운 또한 버블 업과 마찬가지로 재귀 호출을 통한 분할 정복으로 해결할 수 있다.</p>\n<p><code class=\"language-text\">trickleDown</code> 메소드는 부모 노드와 왼쪽 자식 노드, 오른쪽 자식 노드의 값을 비교한 후 자식 노드가 부모 노드보다 큰 값을 가지고 있다면 부모 노드와 해당 자식 노드의 위치를 변경한다.</p>\n<p>쉽게 말하면 세 개의 노드 중 가장 큰 값을 가지고 있는 놈이 부모 자리를 먹는 것인데, 만약 이 힘싸움에서 밀린 것이 부모 노드라면 자신의 자식이 있던 곳으로 좌천되는 것이라고 보면 된다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8cb9ae698e4cb007189258112e07a9b6/d7854/Arthas_King.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 126.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAZABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAf/EABYBAQEBAAAAAAAAAAAAAAAAAAACAf/aAAwDAQACEAMQAAABmbOqp0WG417IykP/xAAeEAACAQQDAQAAAAAAAAAAAAAAAQIDERITISIxM//aAAgBAQABBQJLlpIujNFO7c49tbtFYmuTKf1Je//EABcRAQADAAAAAAAAAAAAAAAAAAAQESH/2gAIAQMBAT8BYuP/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAACAgMBAAAAAAAAAAAAAAAAARAhAhExYf/aAAgBAQAGPwJI9LK6jtF5G09ocOf/xAAdEAEAAgICAwAAAAAAAAAAAAABABEhMRBBcYGh/9oACAEBAAE/IbDdstdW1ElrTGsVgzENQ6ZmRS+osx0R0qutMVXVeWfMzs4v/9oADAMBAAIAAwAAABAA5/P/xAAZEQACAwEAAAAAAAAAAAAAAAAAEQEQMVH/2gAIAQMBAT8QiHouhsr/xAAXEQEBAQEAAAAAAAAAAAAAAAAAEQFB/9oACAECAQE/EF1Oo//EAB8QAQACAgICAwAAAAAAAAAAAAEAESExQVEQYXGBsf/aAAgBAQABPxA2yAWOtYgIOlXFG371BJrbqCQU6pp4SLULRVVtsI+Z+G7R1Eb7KnJ8kwQDRDS9zEj0IfOD8Sf/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Arthas King\" title=\"\" src=\"/static/8cb9ae698e4cb007189258112e07a9b6/d7854/Arthas_King.jpg\" srcset=\"/static/8cb9ae698e4cb007189258112e07a9b6/0913d/Arthas_King.jpg 160w,\n/static/8cb9ae698e4cb007189258112e07a9b6/cb69c/Arthas_King.jpg 320w,\n/static/8cb9ae698e4cb007189258112e07a9b6/d7854/Arthas_King.jpg 550w\" sizes=\"(max-width: 550px) 100vw, 550px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>썩씌딩하는 꼬라지가 왠지 이 놈을 닮았다</small>\n</center>\n<p>만약 이 과정에서 부모 노드와 자식 노드의 위치가 변경되었다면 변경된 부모 노드의 인덱스를 다시 <code class=\"language-text\">tickleDown</code> 메소드의 인자로 넘겨서 이 과정을 계속 반복한다.</p>\n<p>여기까지 작성했으면 버블 업과 마찬가지로 간단한 테스트를 한번 해보자. 힙에 들어가는 값은 이전에 버블 업에서 사용했던 값과 동일한 값들을 사용했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> heap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MaxHeap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">23</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nheap<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> length <span class=\"token operator\">=</span> heap<span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'MAX_VALUE = '</span><span class=\"token punctuation\">,</span> heap<span class=\"token punctuation\">.</span><span class=\"token function\">extract</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'HEAP = '</span><span class=\"token punctuation\">,</span> heap<span class=\"token punctuation\">.</span>nodes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token constant\">MAX_VALUE</span> <span class=\"token operator\">=</span> <span class=\"token number\">32</span>\n<span class=\"token constant\">HEAP</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">]</span>\n\n<span class=\"token constant\">MAX_VALUE</span> <span class=\"token operator\">=</span> <span class=\"token number\">23</span>\n<span class=\"token constant\">HEAP</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">]</span>\n\n<span class=\"token constant\">MAX_VALUE</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token constant\">HEAP</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span>\n<span class=\"token operator\">...</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<center>\n  <img src=\"/95d84ea96d74c0b03c6309156fa60dad/min-heap.gif\" width=\"100%\">\n  <br>\n  <small>트리의 맨 끝에서 노드를 빼와서 루트 노드로 사용한다는 것에 주의하자</small>\n  <br>\n  <br>\n</center>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>힙 자체는 단순히 데이터들이 느슨하게 정렬되어있는 완전 이진 트리이지만, 루트에는 항상 힙 내부에 있는 데이터들의 최대 값과 최소 값이 위치한다는 특징 때문에 다양하게 응용하여 사용할 수 있다.</p>\n<p>그 중 대표적인 것은 선형 자료 구조를 정렬할 때 사용하는 방법인데, 이 정렬 알고리즘을 힙 정렬(Heap Sort)라고 한다. 현재 V8의 <code class=\"language-text\">Array.prototype.sort</code> 메소드는 퀵 정렬(Quick Sort)을 사용하고 있지만, 초반에는 힙을 사용하는 정렬 알고리즘인 힙 정렬을 잠깐 사용하기도 했었다.</p>\n<p>어쨌든 그 동안 잊고 있었던 기초적인 자료 구조를 한번 다시 보니 왠지 기분이 좋다.</p>\n<p>힙은 굉장히 다양한 곳에서 사용되고 있는 자료 구조이니 만큼, 알고 있어서 나쁠 게 없기도 하고 면접 때도 꽤 자주 물어봤던 것 같다. 이제 필자는 회사의 비즈니스 로직과 전혀 관련 없는 백수 개발랭이 신분이 되었으니, 그 동안 소홀했던 기초 이론 부분을 이 기회에 조금 더 자세히 공부해봐야겠다.</p>\n<p>이상으로 최소 값과 최대 값을 빠르게 찾을 수 있게 도와주는 힙(Heap) 포스팅을 마친다.</p>","fields":{"slug":"20191012-introduction-data-structure-heap","path":"/2019/10/12/introduction-data-structure-heap/","lang":"ko"},"frontmatter":{"title":"최소 값과 최대 값을 빠르게 찾을 수 있게 도와주는 힙(Heap)","subTitle":"O(log n)의 마법, 힙을 활용한 빠른 최소·최대 값 탐색","date":"Oct 12, 2019","categories":["프로그래밍","알고리즘"],"tags":["Heap","힙","자료구조","자바스크립트","JavaScript","트리 탐색","트리 정렬","알고리즘"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/bbb54a15b5551610fa2986be824555fd/d803c/thumbnail.png","srcSet":"/static/bbb54a15b5551610fa2986be824555fd/d803c/thumbnail.png 320w,\n/static/bbb54a15b5551610fa2986be824555fd/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/bbb54a15b5551610fa2986be824555fd/fc5c5/thumbnail.webp 320w,\n/static/bbb54a15b5551610fa2986be824555fd/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/bbb54a15b5551610fa2986be824555fd/01fb2/thumbnail.png","srcSet":"/static/bbb54a15b5551610fa2986be824555fd/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/bbb54a15b5551610fa2986be824555fd/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"f303bf14-a278-563b-b4f0-d10bb116f3e6","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94hash-table%EC%9D%B4-%EB%AD%94%EA%B0%80%EC%9A%94\">해시 테이블(Hash Table)이 뭔가요?</a></p>\n<ul>\n<li><a href=\"#%EC%A7%81%EC%A0%91-%EC%A3%BC%EC%86%8C-%ED%85%8C%EC%9D%B4%EB%B8%94direct-address-table\">직접 주소 테이블(Direct Address Table)</a></li>\n<li><a href=\"#%EC%A7%81%EC%A0%91-%EC%A3%BC%EC%86%8C-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EB%8B%A8%EC%A0%90%EC%9D%84-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98%EB%A1%9C-%EB%B3%B4%EC%99%84%ED%95%98%EC%9E%90\">직접 주소 테이블의 단점을 해시 함수로 보완하자!</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%95%B4%EC%8B%9C%EC%9D%98-%EC%B6%A9%EB%8F%8Ccollision\">해시의 충돌(Collision)</a></p>\n<ul>\n<li><a href=\"#%EC%B6%A9%EB%8F%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\">충돌 해결하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%85%8C%EC%9D%B4%EB%B8%94-%ED%81%AC%EA%B8%B0-%EC%9E%AC%ED%95%A0%EB%8B%B9resizing\">테이블 크기 재할당(Resizing)</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 많이 사용되는 자료구조 중 하나인 해시 테이블(Hash Table)에 대해서 정리하려고 한다. 먼저 해시 테이블이 무엇인지, 왜 사용하는지 알아보자.","html":"<p>이번 포스팅에서는 많이 사용되는 자료구조 중 하나인 해시 테이블(Hash Table)에 대해서 정리하려고 한다. 먼저 해시 테이블이 무엇인지, 왜 사용하는지 알아보자.</p>\n<!-- more -->\n<h2 id=\"해시-테이블hash-table이-뭔가요\" style=\"position:relative;\">해시 테이블(Hash Table)이 뭔가요?<a href=\"#%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94hash-table%EC%9D%B4-%EB%AD%94%EA%B0%80%EC%9A%94\" aria-label=\"해시 테이블hash table이 뭔가요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>해시 테이블은 어떤 특정 값을 받으면 그 값을 해시 함수에 통과시켜 나온 인덱스(index)에 저장하는 자료구조이다. 보통 배열을 사용해서 구현하는 경우가 많은 것 같다. 일단 해시 함수가 뭐길래 사용한다는 건지 해시가 뭔지 설명하기 전에 해시 테이블이라는 개념이 어디서부터 출발한 것인지 알아보자.</p>\n<h3 id=\"직접-주소-테이블direct-address-table\" style=\"position:relative;\">직접 주소 테이블(Direct Address Table)<a href=\"#%EC%A7%81%EC%A0%91-%EC%A3%BC%EC%86%8C-%ED%85%8C%EC%9D%B4%EB%B8%94direct-address-table\" aria-label=\"직접 주소 테이블direct address table permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>해시 테이블의 아이디어는 직접 주소 테이블(Direct Address Table)이라는 자료구조에서 부터 출발한다. 직접 주소 테이블은 입력받은 값을 키로 사용하는 데이터 매핑 방식이다. 코드로 보면 더 이해가 쉽다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">DirectAddressTable</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>table <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">setValue</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>table<span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">getValue</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>table<span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">getTable</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>table<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> myTable <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DirectAddressTable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyTable<span class=\"token punctuation\">.</span><span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyTable<span class=\"token punctuation\">.</span><span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyTable<span class=\"token punctuation\">.</span><span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token number\">90</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myTable<span class=\"token punctuation\">.</span><span class=\"token function\">getTable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>만약 데스크톱으로 이 포스팅을 보고 있다면 이 코드를 복붙한 후 브라우저 콘솔이나 NodeJS로 실행해보자. 그러면 콘솔에 우리의 이쁜 테이블이 출력된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">3</span> empty items<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">6</span> empty items<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">79</span> empty items<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token number\">90</span> <span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리가 <code class=\"language-text\">3</code>을 테이블에 넣으면 이 값은 배열의 <code class=\"language-text\">3</code>번 인덱스의 요소가 되고 <code class=\"language-text\">90</code>을 넣으면 <code class=\"language-text\">90</code>번 인덱스의 요소가 된다. 그야말로 초 심플하다. 이렇게 직접 주소 테이블을 사용할때는 들어오는 값이 뭔지 알면 이 값이 저장된 인덱스도 함께 알 수 있기 때문에 저장된 데이터에 바로 접근해서 값을 가져올 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">myTable<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>찾고자 하는 값과 테이블의 인덱스가 동일하므로 테이블을 뒤적거릴 필요없이 값이 저장된 공간에 바로 접근해서 값을 가져올 수 있으므로 시간복잡도는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>이다. 마찬가지로 테이블에 있는 값을 삽입, 수정, 삭제하는 행위도 값이 어디 있는지만 알고있으면 모두 한방에 해결할 수 있으므로 역시 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span>의 시간복잡도로 해결할 수 있다.</p>\n<p>보통 이런 단순한 자료구조에서 값을 탐색, 삽입, 수정, 삭제하는 알고리즘이 시간을 잡아먹게 되는 이유는 대부분 비슷비슷하다.</p>\n<hr>\n<ol>\n<li>내가 찾고 싶은 값이 어디 있는지 모른다. 일단 효율적으로 뒤져보자.(e.g. 이진트리탐색)</li>\n<li>내가 이 값을 삽입하거나 삭제하면 다른 값이 영향을 받는다.(e.g. 링크드 리스트)</li>\n</ol>\n<hr>\n<p>이렇게 직접 주소 테이블은 내가 보고 싶은 값이 어디 있는지 알고 있기 때문에 바로 접근해서 이후 작업을 수행할 수 있다는 점에서 굉장히 편리하다고 할 수 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 441px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/db3a598bfb9db0b88f1811fc6087af73/eed25/fantastic.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHYdSJCD//EABsQAAIDAAMAAAAAAAAAAAAAAAECAAMREiEi/9oACAEBAAEFAmwBY59MdFZ5Svsf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAwADAQAAAAAAAAAAAAAAAAERECFBgf/aAAgBAQAGPwKyZ8psbfWf/8QAGxABAAICAwAAAAAAAAAAAAAAAQARIUExYeH/2gAIAQEAAT8h3S4GWrLbKEY7jnfpGNxtpSf/2gAMAwEAAgADAAAAEDAP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAQACAgMAAAAAAAAAAAAAAREAITGxQWFx/9oACAEBAAE/ELh8mAdZcho0pQc042Fe5mq2uDFT7k13moKpfjOjP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"fantastic\" title=\"\" src=\"/static/db3a598bfb9db0b88f1811fc6087af73/eed25/fantastic.jpg\" srcset=\"/static/db3a598bfb9db0b88f1811fc6087af73/0913d/fantastic.jpg 160w,\n/static/db3a598bfb9db0b88f1811fc6087af73/cb69c/fantastic.jpg 320w,\n/static/db3a598bfb9db0b88f1811fc6087af73/eed25/fantastic.jpg 441w\" sizes=\"(max-width: 441px) 100vw, 441px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>하지만 직접 주소 테이블도 당연히 단점이 있다. 바로 공간의 효율성이 좋지 않다는 것이다. 방금 선언했던 <code class=\"language-text\">myTable</code>의 테이블 상태를 한번 보면 이해가 바로 된다. 이 테이블에는 <code class=\"language-text\">3</code>, <code class=\"language-text\">10</code>, <code class=\"language-text\">90</code>의 값을 넣었고 이 값들은 크기 차이가 꽤나 큰 편이다.</p>\n<p>그 결과 우리의 <code class=\"language-text\">myTable</code>은 이렇게 듬성듬성한 구조로 데이터를 저장하게 된 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">91</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span>\n <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">90</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위에서도 볼 수 있듯이 저장된 데이터를 제외하고 <code class=\"language-text\">0</code>으로 채워진 나머지 공간은 값은 없지만 메모리 공간은 할당되어 있는 상태이다. 즉, 사용하지 않는 아까운 공간이다. 결국 직접 주소 테이블을 사용할 때 테이블에 넣고자 하는 데이터 값의 범위보다 값의 개수가 작다면 공간적인 효율이 떨어지는 것이다.</p>\n<p>이런 상황을 적재율이 낮다고 표현하는데, 적재율은 <code class=\"language-text\">값의 개수/테이블의 크기</code>로 나타내게 된다. 필자가 방금 만든 이 테이블의 현재 적재율은 <code class=\"language-text\">3/91 = 0.03296...</code>으로 약 <code class=\"language-text\">3%</code> 정도이므로 높은 적재율은 아니라고 볼 수 있다.</p>\n<p>만약 <code class=\"language-text\">1000</code>과 같이 큰 값이 하나만 더 테이블에 들어온다고 해도 테이블의 크기는 <code class=\"language-text\">1001</code>이 되고 적재율은 <code class=\"language-text\">0.003996...</code>으로 약 <code class=\"language-text\">0.4%</code>가 된다. 즉, 직접 주소 테이블이 큰 힘을 발휘할 수 있는 순간은 <code class=\"language-text\">1, 2, 3</code>과 같이 연속적인 값을 저장하거나 혹은 값들의 범위 차이가 크지 않은 데이터라고 할 수 있다.</p>\n<h3 id=\"직접-주소-테이블의-단점을-해시-함수로-보완하자\" style=\"position:relative;\">직접 주소 테이블의 단점을 해시 함수로 보완하자!<a href=\"#%EC%A7%81%EC%A0%91-%EC%A3%BC%EC%86%8C-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EB%8B%A8%EC%A0%90%EC%9D%84-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98%EB%A1%9C-%EB%B3%B4%EC%99%84%ED%95%98%EC%9E%90\" aria-label=\"직접 주소 테이블의 단점을 해시 함수로 보완하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이렇게 직접 주소 테이블은 값에 접근하기는 편하지만 공간 효율이 좋지 않다는 단점이 있다. 그래서 이 단점을 보완한 게 바로 해시 테이블인 것이다.</p>\n<p>해시 테이블은 직접 주소 테이블처럼 값을 바로 테이블의 인덱스로 사용하는 것이 아니라 해시 함수(Hash Function)라는 것에 한번 통과시켜서 사용한다. 해시 함수는 임의의 길이를 가지는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 이때 이 함수가 뱉어내는 결과물을 해시(Hash)라고 부른다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 420px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9ab3259234eddda6c50fdda48c352e4e/65f94/hashbrown.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAQX/xAAUAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHtT2qExoz/AP/EABgQAQEBAQEAAAAAAAAAAAAAAAIBABAS/9oACAEBAAEFAm/GiT6ZDN//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwEZ/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8BRWf/xAAXEAADAQAAAAAAAAAAAAAAAAAAECEB/9oACAEBAAY/Aia4v//EABgQAQEBAQEAAAAAAAAAAAAAAAERABCh/9oACAEBAAE/ITFR1/w4gkS6IEOf/9oADAMBAAIAAwAAABDbD//EABcRAQADAAAAAAAAAAAAAAAAAAEQITH/2gAIAQMBAT8QAMuP/8QAFhEBAQEAAAAAAAAAAAAAAAAAERAh/9oACAECAQE/EFDk/8QAHBABAQACAgMAAAAAAAAAAAAAAREAMRAhQXGR/9oACAEBAAE/EC6lGddfcmYabM9XCwu8dCD4cEn2cf/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"hashbrown\" title=\"\" src=\"/static/9ab3259234eddda6c50fdda48c352e4e/65f94/hashbrown.jpg\" srcset=\"/static/9ab3259234eddda6c50fdda48c352e4e/0913d/hashbrown.jpg 160w,\n/static/9ab3259234eddda6c50fdda48c352e4e/cb69c/hashbrown.jpg 320w,\n/static/9ab3259234eddda6c50fdda48c352e4e/65f94/hashbrown.jpg 420w\" sizes=\"(max-width: 420px) 100vw, 420px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>해시(Hash)의 사전적 정의는 사실 \"잘게 썬 요리\" 같은 뉘앙스로 사용된다. 롯데리아에서 파는 해시브라운을 생각해보자.<br>해시 함수도 어떤 값이 들어오든 간에 다 뭉개서 내가 원하는 길이의 값으로 만든다는 점에서 일맥상통한다.</small>\n</center>\n<p>그럼 한번 이해를 돕기위해 간단한 해시 함수를 만들어보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">hashFunction</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">key</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> key <span class=\"token operator\">%</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">hashFunction</span><span class=\"token punctuation\">(</span><span class=\"token number\">102948</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 8</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">hashFunction</span><span class=\"token punctuation\">(</span><span class=\"token number\">191919191</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">hashFunction</span><span class=\"token punctuation\">(</span><span class=\"token number\">13</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">hashFunction</span><span class=\"token punctuation\">(</span><span class=\"token number\">997</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 7</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이게 끝이다. 물론 허접한 해시 함수이지만 그래도 해싱이라는 본연의 역할을 잘 수행하는데는 별로 문제가 없다.</p>\n<p>필자의 허접한 해시 함수는 무조건 들어온 값을 <code class=\"language-text\">10</code>으로 나눈 후의 나머지를 반환하는 일을 할 뿐이지만 어떤 값이 들어오든 그 값의 <code class=\"language-text\">1</code>의 자리만 반환될 것이기 때문에 반환되는 값은 무조건 <code class=\"language-text\">0-9</code> 사이의 값이라는 것이 보장된다.</p>\n<p>그리고 해시 함수의 특성 중 하나가 해시만 보고는 인자로 어떤 값을 받았는지 추측하기 힘들다는 것이다. 1의 자리만 보고 원래 수가 얼마였는지 맞출 수는 없을 것이다. 그래서 이러한 해시 함수의 특징은 암호학에서도 아주 잘 사용하고 있다.</p>\n<p>자, 하지만 우리에게 중요한건 암호학이 아니라 바로 이것이다.</p>\n<blockquote>\n<p>어떤 값이 해시 함수로 들어오든 무조건 <strong>0-9</strong>사이의 값이 반환된다!</p>\n</blockquote>\n<p>직접 주소 테이블의 단점이 바로 <code class=\"language-text\">10000</code>이라는 값이 하나만 들어오더라도 <code class=\"language-text\">10000</code>번 인덱스에 값을 저장하기 위해 <code class=\"language-text\">10000</code>의 크기를 가진 테이블을 생성해야하기 때문에 나머지 <code class=\"language-text\">9999</code>개의 버리는 공간이 생기는 것이다.</p>\n<p>그러나 필자의 해시 함수를 사용하면 <code class=\"language-text\">100</code>이 들어오면 <code class=\"language-text\">0</code>을 반환할 것이고 <code class=\"language-text\">10001</code>이 들어오면 <code class=\"language-text\">1</code>을 반환, 심지어 <code class=\"language-text\">8982174981274</code>가 들어와도 <code class=\"language-text\">4</code>를 반환한다.</p>\n<p>즉, 고정된 테이블의 길이를 정해둘 수 있고 그 안에만 데이터를 저장할 수 있게 된 것이다. 해시 함수의 이러한 성질을 이용해서 아주 간단한 해시테이블을 한번 작성해보겠다. 필자는 해시 테이블 크기를 <code class=\"language-text\">5</code>로 설정하고 어떤 값이 들어와도 이 테이블 안에 저장될 수 있도록 해시 함수를 작성할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> myTableSize <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> myHashTable <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span>myTableSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">hashFunction</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">key</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 들어온 값을 테이블의 크기로 나눠주고 나머지를 반환하면 된다.</span>\n  <span class=\"token keyword\">return</span> key <span class=\"token operator\">%</span> myTableSize<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nmyHashTable<span class=\"token punctuation\">[</span><span class=\"token function\">hashFunction</span><span class=\"token punctuation\">(</span><span class=\"token number\">1991</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1991</span><span class=\"token punctuation\">;</span>\nmyHashTable<span class=\"token punctuation\">[</span><span class=\"token function\">hashFunction</span><span class=\"token punctuation\">(</span><span class=\"token number\">1234</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1234</span><span class=\"token punctuation\">;</span>\nmyHashTable<span class=\"token punctuation\">[</span><span class=\"token function\">hashFunction</span><span class=\"token punctuation\">(</span><span class=\"token number\">5678</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">5678</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myHashTable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [empty, 1991, empty, 5678, 1234]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>들어온 값들은 <code class=\"language-text\">1991</code>, <code class=\"language-text\">1234</code>, <code class=\"language-text\">5678</code>로, 해시 테이블의 사이즈인 <code class=\"language-text\">5</code>보다 훨씬 큰 값이지만 해시 함수를 거친 결과 <code class=\"language-text\">0-4</code> 사이의 값만 반환되기 때문에 필자의 작고 귀여운 해시 테이블 안에 값이 차곡차곡 저장될 수 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 295px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/10cfbdd4e3d4fbc641b29aaa9dedb7e7/1c91a/cute.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABAADBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe8FGAmHH//EABkQAAMBAQEAAAAAAAAAAAAAAAABAhIRMf/aAAgBAQABBQLiKh2p82yqe0f/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAABBQAAAAAAAAAAAAAAAAABAAIRIHH/2gAIAQEABj8CThIGV//EABwQAAEEAwEAAAAAAAAAAAAAAAABESExQWFxUf/aAAgBAQABPyHQh7HMJ6Uy5oQUWhnYy6f/2gAMAwEAAgADAAAAECDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAQACAgMAAAAAAAAAAAAAAREAITFRQfDx/9oACAEBAAE/EPlYxVVCgEaVetZcEoAbtoFs8256DiUs3jwvGKL7Ty5//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"cute\" title=\"\" src=\"/static/10cfbdd4e3d4fbc641b29aaa9dedb7e7/1c91a/cute.jpg\" srcset=\"/static/10cfbdd4e3d4fbc641b29aaa9dedb7e7/0913d/cute.jpg 160w,\n/static/10cfbdd4e3d4fbc641b29aaa9dedb7e7/1c91a/cute.jpg 295w\" sizes=\"(max-width: 295px) 100vw, 295px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>내 해시 테이블...자그마해 귀여워</small>\n</center>\n<p>이로써 직접 주소 테이블의 단점이었던 밑도 끝도 없이 낭비되는 공간을 줄일 수 있게 되었다!</p>\n<h2 id=\"해시의-충돌collision\" style=\"position:relative;\">해시의 충돌(Collision)<a href=\"#%ED%95%B4%EC%8B%9C%EC%9D%98-%EC%B6%A9%EB%8F%8Ccollision\" aria-label=\"해시의 충돌collision permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇게 해피 엔딩으로 끝나면 좋겠지만 해시 테이블의 단점도 있다. 그 단점은 바로 해시의 충돌이다. 충돌이 뭔지 설명하기 전에 필자의 해시 함수를 가지고와서 한번 충돌을 일으켜보고 직접 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">hashFunction</span><span class=\"token punctuation\">(</span><span class=\"token number\">1991</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1</span>\n<span class=\"token function\">hashFunction</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<blockquote>\n<p>다른 값을 해시 함수에 넣었지만 같은 값이 튀어나오는 것이 바로 <strong>충돌(Collision)</strong> 이다.</p>\n</blockquote>\n<p>사실 상식적으로 생각해보면 직접 주소 테이블은 동적으로 테이블을 늘려나갔지만 해시 테이블은 처음부터 고정적인 공간을 할당하고 값을 계속 우겨넣는 방식이다.</p>\n<p>그렇다면 테이블의 크기를 <code class=\"language-text\">100</code>으로 잡고 그 테이블에 <code class=\"language-text\">200</code>개의 데이터를 넣는다면 100개만 저장되고 100개는 남을텐데 얘네는 어떻게 되는걸까?</p>\n<p>걱정하지 말자. 애초에 해시 테이블은 담고자 하는 데이터의 개수보다 테이블의 크기를 작게 하고 싶다는 의지에서 나온 자료구조이기 때문에 충돌을 해결할 수 있는 방법 또한 같이 고안되었다.</p>\n<h3 id=\"충돌-해결하기\" style=\"position:relative;\">충돌 해결하기<a href=\"#%EC%B6%A9%EB%8F%8C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"충돌 해결하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이처럼 해시 테이블에는 해시의 충돌이라는 단점이 있기 때문에 해시 테이블을 운용할 때 가장 중요한 것은 사실 해시 함수가 얼마나 균일하게 값을 퍼트릴 수 있느냐이다. 어떤 값을 넣어도 같은 인덱스만 주구장창 나올 확률이 높다면 좋은 해시 함수가 아니라는 것이다.</p>\n<p>그러나 해시 함수를 아무리 잘 짜더라도 근본적으로 충돌을 완전히 방지한다는 것은 힘든 일이다. 그렇기 때문에 어느 정도는 충돌을 감안하되 최소화하기 위해 해시 함수의 알고리즘을 개발하거나, 혹은 충돌이 발생하더라도 우회해서 해결할 수 있는 방법을 사용한다.</p>\n<p>그 중 이 포스팅에서는 충돌이 발생하더라도 우회해서 해결하는 방법 중 몇가지를 설명하려고 한다.</p>\n<h4 id=\"개방-주소법open-address\" style=\"position:relative;\">개방 주소법(Open Address)<a href=\"#%EA%B0%9C%EB%B0%A9-%EC%A3%BC%EC%86%8C%EB%B2%95open-address\" aria-label=\"개방 주소법open address permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>개방 주소법은 해시 충돌이 발생하면 테이블 내의 새로운 주소를 탐사한 후, 비어있는 곳에 충돌된 데이터를 입력하는 방식이다. 해시 함수를 통해서 얻은 인덱스가 아니라 다른 인덱스를 허용한다는 의미로 개방 주소(Open Address)라고 한다.</p>\n<p>개방 주소법은 어떤 방식으로 비어있는 공간을 탐사할 것이냐에 따라 4가지로 나누어 진다.</p>\n<h5 id=\"1-선형-탐사법linear-probing\" style=\"position:relative;\">1. 선형 탐사법(Linear Probing)<a href=\"#1-%EC%84%A0%ED%98%95-%ED%83%90%EC%82%AC%EB%B2%95linear-probing\" aria-label=\"1 선형 탐사법linear probing permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>선형 탐사법(Linear Probing)은 말 그대로 선형으로 순차적으로 탐사하는 방법이다. 위에서 해시 충돌의 예로 들었던 <code class=\"language-text\">1991</code>과 <code class=\"language-text\">6</code>의 상황을 한번 예시로 알아보자.</p>\n<br />\n<ul class=\"hash-table-dummy\">\n  <li><dt>0</dt><dd></dd></li>\n  <li><dt>1</dt><dd>1991</dd></li>\n  <li><dt>2</dt><dd></dd></li>\n  <li><dt>3</dt><dd></dd></li>\n  <li><dt>4</dt><dd></dd></li>\n  <li><dt>5</dt><dd></dd></li>\n  <li><dt>6</dt><dd></dd></li>\n</ul>\n<br />\n<p>처음에 <code class=\"language-text\">1991</code>을 해시 함수에 통과 시킨 후 해시 테이블에 넣었을 때에는 테이블의 <code class=\"language-text\">1</code>번 인덱스에 위치했을 것이다. 그 이후 <code class=\"language-text\">6</code>을 해시 함수에 통과시켰더니 또 <code class=\"language-text\">1</code>이 나왔다. 하지만 이미 <code class=\"language-text\">1</code>번 인덱스에는 <code class=\"language-text\">1991</code>이 들어가 있기 때문에 <code class=\"language-text\">6</code>은 더 이상 해시 테이블에 들어갈 자리가 없게 되었다. 충돌이 발생한 것이다!</p>\n<p>선형 탐사법은 이렇게 충돌이 났을 때 정해진 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> 칸만큼의 옆 방을 주는 방법이다. 만약에 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>이라면 <code class=\"language-text\">2</code>번 인덱스를, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">n = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span>이라면 <code class=\"language-text\">4</code>번 인덱스에 <code class=\"language-text\">6</code>을 저장할 것이다.</p>\n<br />\n<ul class=\"hash-table-dummy\">\n  <li><dt>0</dt><dd></dd></li>\n  <li><dt>1</dt><dd>1991</dd></li>\n  <li><dt>2</dt><dd><strong style=\"color: #ff0000;\">6</strong></dd></li>\n  <li><dt>3</dt><dd></dd></li>\n  <li><dt>4</dt><dd></dd></li>\n  <li><dt>5</dt><dd></dd></li>\n  <li><dt>6</dt><dd></dd></li>\n</ul>\n<center><small>아쉬운대로 옆 방이라도 들어가야지...</small></center>\n<br />\n<p>이런 식으로 충돌이 났을 때 순차적으로 정해진 만큼의 옆 방을 주는 것이 바로 선형 탐사법이다. 만약 여기서 또 충돌이 발생한다면 이번에는 그 값을 <code class=\"language-text\">3</code>번 인덱스에 저장할 것이다. 이런 방식으로 빈 공간이 나타날 때까지 순차적으로 탐사를 한다.</p>\n<p>선형 탐사법의 단점은 특정 해시 값의 주변이 모두 채워져있는 일차 군집화(Primary Clustering) 문제에 취약하다는 것이다.</p>\n<br />\n<ul class=\"hash-table-dummy\">\n  <li><dt>0</dt><dd></dd></li>\n  <li><dt>1</dt><dd>1991</dd></li>\n  <li><dt>2</dt><dd>6</dd></li>\n  <li><dt>3</dt><dd>13</dd></li>\n  <li><dt>4</dt><dd>21</dd></li>\n  <li><dt>5</dt><dd></dd></li>\n  <li><dt>6</dt><dd></dd></li>\n</ul>\n<br />\n<p>같은 해시가 여러 번 나오는 경우 선형 탐사법을 사용하면 데이터가 연속되게 저장될 가능성이 높아진다. 즉, 데이터의 밀집도가 높아진다는 것이다. 이런 경우 해시의 값이 <code class=\"language-text\">1</code>이 나왔을 때 뿐만 아니라 <code class=\"language-text\">2</code>나 <code class=\"language-text\">3</code>이 나왔을 때도 충돌이 발생한다.</p>\n<p>이게 진짜 악순환의 반복인데, 이런 식으로 충돌이 계속 될 수록 데이터가 연속되게 저장되기 때문에 나중에 가면 데이터가 밀집되어 있는 거대한 덩어리가 생긴다. 그럼 해시로 어떤 값이 나오더라도 그 덩어리가 차지한 인덱스와 충돌이 날 확률이 올라가고, 충돌난 값은 또 그 덩어리 뒤에 저장되게 되므로 데이터 덩어리가 더 커진다.</p>\n<blockquote>\n<p><strong>충돌!</strong> -> 데이터 덩어리 뒤에 충돌난 값 저장 -> 충돌 발생 확률 증가 -> <strong>충돌!</strong> -> 또 저장. 덩어리 더 커짐 -> 충돌 발생 확률 증가 -> <strong>충돌</strong>…</p>\n</blockquote>\n<p>이런 식으로 눈물나는 무한 반복 사이클이 발생한다. 이것이 일차 군집화 문제이다. 이제 이 눈물나는 문제점을 그나마 보완한 다른 방법을 알아보자.</p>\n<h5 id=\"2-제곱-탐사법quadratic-probing\" style=\"position:relative;\">2. 제곱 탐사법(Quadratic Probing)<a href=\"#2-%EC%A0%9C%EA%B3%B1-%ED%83%90%EC%82%AC%EB%B2%95quadratic-probing\" aria-label=\"2 제곱 탐사법quadratic probing permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>제곱 탐사법(Quadratic Probing)은 선형 탐사법과 동일하지만 탐사하는 폭이 고정폭이 아닌 제곱으로 늘어난다는 것이 다르다.</p>\n<p>첫번째 충돌이 발생했을 때는 충돌난 지점으로 부터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>1</mn><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">1^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>만큼, 두번째 충돌이 발생했을 때는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>, 세번째는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>3</mn><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">3^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>과 같은 식으로 탐사하는 스텝이 빠르게 커진다. 앞서 보았던 선형 탐사법에서의 예시와 동일한 상황에서 제곱 탐사법을 사용하면 해시 테이블은 아래와 같은 모양이 된다.</p>\n<br />\n<ul class=\"hash-table-dummy\">\n  <li><dt>0</dt><dd></dd></li>\n  <li><dt>1</dt><dd>1991</dd></li>\n  <li><dt>2</dt><dd>6</dd></li>\n  <li><dt>3</dt><dd></dd></li>\n  <li><dt>4</dt><dd></dd></li>\n  <li><dt>5</dt><dd>13</dd></li>\n  <li><dt>6</dt><dd></dd></li>\n  <li><dt>...</dt><dd></dd></li>\n  <li><dt>10</dt><dd>21</dd></li>\n</ul>\n<br />\n<blockquote>\n<p>첫번째 충돌이 났을 때 <code class=\"language-text\">6</code>은 충돌이 난 <code class=\"language-text\">1</code>번 인덱스로부터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>1</mn><mn>2</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1^2 = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>만큼의 옆 방에 들어간다.</p>\n<p>두번째 충돌이 났을 때 <code class=\"language-text\">13</code>은 충돌이 난 <code class=\"language-text\">1</code>번 인덱스로부터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">2^2 = 4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span></span>만큼의 옆 방에 들어간다.</p>\n<p>세번째 충돌이 났을 때 <code class=\"language-text\">21</code>은 충돌이 난 <code class=\"language-text\">1</code>번 인덱스로부터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>3</mn><mn>3</mn></msup><mo>=</mo><mn>9</mn></mrow><annotation encoding=\"application/x-tex\">3^3 = 9</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">9</span></span></span></span></span>만큼의 옆 방에 들어간다.</p>\n</blockquote>\n<p>이렇게 제곱 탐사법을 사용하면 충돌이 발생하더라도 데이터의 밀집도가 선형 탐사법보다 많이 낮기 때문에 다른 해시값까지 영향을 받아서 연쇄적으로 충돌이 발생할 확률이 많이 줄어든다.</p>\n<p>그래도 결국 해시로 <code class=\"language-text\">1</code>이 여러번 나오면 계속 충돌이 나는 것은 피할 수 없다. 결국 데이터의 군집은 피할 수 없는 숙명이므로 이 현상을 이차 군집화(Secondary Clustering) 문제라고 부른다.</p>\n<p>그럼 여기서 더 개선할 수는 없을까?</p>\n<h5 id=\"3-이중해싱double-hashing\" style=\"position:relative;\">3. 이중해싱(Double Hashing)<a href=\"#3-%EC%9D%B4%EC%A4%91%ED%95%B4%EC%8B%B1double-hashing\" aria-label=\"3 이중해싱double hashing permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>그래서 나온 방법이 바로 이중해싱이다. 말 그대로 해시 함수를 이중으로 사용하는 것이다.</p>\n<p>하나는 기존과 마찬가지로 최초 해시를 얻을 때 사용하고, 다른 하나는 충돌이 났을 경우 탐사 이동폭을 얻기 위해 사용한다. 이렇게 하면 최초 해시로 같은 값이 나오더라도 다시 다른 해시 함수를 거치면서 다른 탐사 이동폭이 나올 확률이 높기 때문에 매번 다른 공간에 값이 골고루 저장될 확률도 높아진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> myTableSize <span class=\"token operator\">=</span> <span class=\"token number\">23</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 테이블 사이즈가 소수여야 효과가 좋다</span>\n<span class=\"token keyword\">const</span> myHashTable <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getSaveHash</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">value</span> <span class=\"token operator\">=></span> value <span class=\"token operator\">%</span> myTableSize<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 스텝 해시에 사용되는 수는 테이블 사이즈보다 약간 작은 소수를 사용한다.</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getStepHash</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">value</span> <span class=\"token operator\">=></span> <span class=\"token number\">17</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">%</span> <span class=\"token number\">17</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">setValue</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">value</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token function\">getSaveHash</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> targetValue <span class=\"token operator\">=</span> myHashTable<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>targetValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      myHashTable<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>index<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">번 인덱스에 </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>value<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> 저장! </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>myHashTable<span class=\"token punctuation\">.</span>length <span class=\"token operator\">>=</span> myTableSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'풀방입니다'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>index<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">번 인덱스에 </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>value<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> 저장하려다 충돌 발생!ㅜㅜ</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      index <span class=\"token operator\">+=</span> <span class=\"token function\">getStepHash</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      index <span class=\"token operator\">=</span> index <span class=\"token operator\">></span> myTableSize <span class=\"token operator\">?</span> index <span class=\"token operator\">-</span> myTableSize <span class=\"token operator\">:</span> index<span class=\"token punctuation\">;</span>\n      targetValue <span class=\"token operator\">=</span> myHashTable<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이때 테이블 사이즈와 두번째 해시함수에 사용될 수는 둘 다 소수를 사용하는 것이 좋다. 둘 중에 하나가 소수가 아니라면 결국 언젠가 같은 해싱이 반복되기 때문이다. 딱 보기에 뭔가 좀 복잡해보이지만 하나하나 뜯어보면 별 거 없다. 한번 순서대로 살펴보자.</p>\n<hr>\n<ol>\n  <li>저장할 인덱스를 <code class=\"language-text\">getSaveHash</code> 해시 함수로 얻는다.</li>\n  <li>반복문 시작</li>\n  <li>거기 비었니?</li>\n  <ol style=\"list-style: lower-alpha;\">\n    <li>비었어? 오케이 저장!</li>\n    <li>사람 있어? 다음 인덱스 내놔! 다시 3으로...</li>\n    <li>풀방이야? 종료합시다.</li>\n  </ol>\n</ol>\n<hr>\n<p>위 코드를 브라우저 콘솔이나 NodeJS로 실행시켜보면 출력되는 문자열을 통해 이 과정이 어떤 방식으로 흘러가는 지 대략적으로 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token number\">1991</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token number\">13</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token number\">21</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 13번 인덱스에 1991 저장!</span>\n<span class=\"token comment\">// 6번 인덱스에 6 저장!</span>\n<span class=\"token comment\">// 13번 인덱스에 13 저장하려다 충돌 발생!ㅜㅜ</span>\n<span class=\"token comment\">// 17번 인덱스에 13 저장!</span>\n<span class=\"token comment\">// 21번 인덱스에 21 저장!</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>아까 선형 탐사법과 제곱 탐사법을 사용했다면 모두 해시의 결과가 <code class=\"language-text\">1</code>이어서 연쇄적으로 충돌이 발생해야 할 값들이지만 이중 해싱을 사용함으로써 한번의 충돌만으로 모든 값을 저장할 수 있게 되었다.</p>\n<p>위에 코드를 복붙해서 함수를 선언해놨다면 저 콘솔을 여러 번 돌려보고 저장할 값도 바꿔보면서 어떤 식으로 해쉬테이블에 값들이 저장되는지 살펴볼 수 있다. 테이블이 꽉 차면 <code class=\"language-text\">풀방입니다</code>가 출력되니까 그때까진 신나게 돌려봐도 된다.</p>\n<h4 id=\"분리-연결법separate-chaining\" style=\"position:relative;\">분리 연결법(Separate Chaining)<a href=\"#%EB%B6%84%EB%A6%AC-%EC%97%B0%EA%B2%B0%EB%B2%95separate-chaining\" aria-label=\"분리 연결법separate chaining permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>분리 연결법은 개방 주소법과는 다른 개념으로 접근하는 충돌 우회 방법이다. 분리 연결법은 해쉬 테이블의 버킷에 하나의 값이 아니라 링크드 리스트(Linked List)나 트리(Tree)를 사용한다.\n사실 트리를 쓰던 링크드 리스트를 쓰던 개념은 동일하니 링크드 리스트로 설명을 진행하겠다.</p>\n<p>위에서 계속 사용했던 예시를 또 가져와보자. 테이블 크기가 <code class=\"language-text\">5</code>일때 해시로 <code class=\"language-text\">1</code>을 반환하는 <code class=\"language-text\">1991</code>, <code class=\"language-text\">6</code>, <code class=\"language-text\">13</code>, <code class=\"language-text\">21</code>을 저장할 때 분리 연결법을 사용하면 이렇게 된다.</p>\n<br />\n<ul class=\"hash-table-dummy\">\n  <li><dt>0</dt><dd></dd></li>\n  <li><dt>1</dt><dd>[21, 13, 6, 1991]</dd></li>\n  <li><dt>2</dt><dd></dd></li>\n  <li><dt>3</dt><dd></dd></li>\n  <li><dt>4</dt><dd></dd></li>\n</ul>\n<br />\n<p>간단하다. 근데 자세히 보면 <code class=\"language-text\">[1991, 6, 13, 21]</code>의 순서가 아니라 <code class=\"language-text\">[21, 13, 6, 1991]</code>의 순서로 뒤집혀 있다.</p>\n<p>이는 데이터를 삽입할 때 조금이라도 수행 시간을 줄이기 위해서 사용하는 방법이다. 왜 데이터를 뒤집으면 삽입 수행 시간이 줄어드는지 이해하기 위해서 우리 테이블의 <code class=\"language-text\">1</code>번 인덱스에 저장된 링크드 리스트가 <code class=\"language-text\">[1991, 6, 13, 21]</code> 순서일 때 새로운 데이터를 삽입하는 과정을 살펴보자.</p>\n<br />\n<ul class=\"hash-table-dummy\">\n  <li><dt>1</dt><dd>{ 값: 1991, 다음 노드: 2 }</dd></li>\n  <li><dt>2</dt><dd>{ 값: 6, 다음 노드: 3 }</dd></li>\n  <li><dt>3</dt><dd>{ 값: 13, 다음 노드: 4 }</dd></li>\n  <li><dt>4</dt><dd>{ 값: 21, 다음 노드: null }</dd></li>\n</ul>\n<center><small>왠지 해쉬테이블이랑 비슷하게 생겼지만 이번엔 링크드 리스트다</small></center>\n<br />\n<p>만약 이번에 추가할 값이 <code class=\"language-text\">11</code>이라고 해보자. 일단 메모리 주소가 <code class=\"language-text\">99</code>인 곳이 남길래 여기에 <code class=\"language-text\">{ 값: 11, 다음 노드: null }</code>을 저장했다. 그 후 이 새로운 노드를 리스트에 붙혀야 하니까 해당 리스트의 마지막 노드인 메모리 <code class=\"language-text\">4</code>에 저장된 노드까지 찾아가야 한다.</p>\n<p>그 다음에 메모리 <code class=\"language-text\">4</code>에 저장된 값을 <code class=\"language-text\">{ 값: 21, 다음 노드: 99 }</code>로 바꿔주면 끝이다.</p>\n<br />\n<ul class=\"hash-table-dummy\">\n  <li><dt>1</dt><dd>{ 값: 1991, 다음 노드: 2 }</dd></li>\n  <li><dt>2</dt><dd>{ 값: 6, 다음 노드: 3 }</dd></li>\n  <li><dt>3</dt><dd>{ 값: 13, 다음 노드: 4 }</dd></li>\n  <li><dt>4</dt><dd>{ 값: 21, 다음 노드: 99 }</dd></li>\n  <li><dt>99</dt><dd>{ 값: 11, 다음 노드: null }</dd></li>\n</ul>\n<br />\n<p>문제는 새 노드를 리스트에 붙히기 위해서 메모리 <code class=\"language-text\">4</code>에 저장된 노드를 찾는 과정이다. 링크드 리스트의 특성 상 메모리 <code class=\"language-text\">4</code>의 데이터를 확인하려면 머리부터 순차적으로 다음 노드를 탐색해나가야 한다.</p>\n<p>결국 데이터를 삽입하려면 먼저 리스트의 머리인 메모리 <code class=\"language-text\">1</code>부터 찾은 다음에 다음 메모리 주소 값을 확인하고 <code class=\"language-text\">2</code>로 이동해서 또 다음 메모리 주소를 확인하는 과정을 거쳐야한다는 것이다.</p>\n<p>링크드 리스트의 크기가 작을 때는 할만 한 작업이지만, 리스트의 크기가 커질수록 수행 시간도 비례해서 늘어나기 때문에 확실히 좋은 방법은 아니다. 하지만 순서를 반대로 뒤집으면 데이터 삽입이 한결 쉬워진다.</p>\n<br />\n<ul class=\"hash-table-dummy\">\n  <li><dt>99</dt><dd>{ 값: 11, 다음 노드: 1 }</dd></li>\n  <li><dt>1</dt><dd>{ 값: 1991, 다음 노드: 2 }</dd></li>\n  <li><dt>2</dt><dd>{ 값: 6, 다음 노드: 3 }</dd></li>\n  <li><dt>3</dt><dd>{ 값: 13, 다음 노드: 4 }</dd></li>\n  <li><dt>4</dt><dd>{ 값: 21, 다음 노드: null }</dd></li>\n</ul>\n<br />\n<p>맨 앞에 노드를 추가하는 것이기 때문에 다른 노드를 탐색할 필요없이 그냥 메모리에 밀어넣고 <code class=\"language-text\">{ 값: 11, 다음 노드: 1 }</code>이라고 저장해주면 되기 때문이다. 그래서 해시 테이블에 저장할 때도 리스트의 꼬리로 데이터를 붙히기보다는 머리에 붙히는 방법을 보통 많이 사용한다.</p>\n<p>대신 이렇게 분리 연결법을 사용하려면 해시 함수의 역할이 굉장히 중요하다. 결국 균일하지 못한 해시를 사용해서 특정 인덱스에 데이터가 몰리게 된다면 다른 곳은 텅텅 비어있는데 한 버킷에 저장된 리스트의 길이만 계속 길어지기 때문이다.</p>\n<br />\n<ul class=\"hash-table-dummy\">\n  <li><dt>0</dt><dd></dd></li>\n  <li><dt>1</dt><dd>[21, 13, 6, 1991, 7, 11, 25, ...]</dd></li>\n  <li><dt>2</dt><dd></dd></li>\n  <li><dt>3</dt><dd></dd></li>\n  <li><dt>4</dt><dd></dd></li>\n</ul>\n<center><small>극단적인 예시긴 하지만... 이건 그냥 링크드 리스트를 쓰는 것과 다를 게 없다</small></center>\n<br />\n<p>결국 내가 찾고자 하는 값이 리스트의 맨 마지막에 위치하고 있다면 링크드 리스트를 처음부터 끝까지 다 탐색해야하기 때문에 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>의 시간복잡도를 가지게 된다. 그렇기 때문에 최대한 저장하고 하는 데이터를 균일하게 퍼트려서 리스트의 길이를 어느 정도로 유지해주는 해시 함수의 역할이 중요한 것이다.</p>\n<h2 id=\"테이블-크기-재할당resizing\" style=\"position:relative;\">테이블 크기 재할당(Resizing)<a href=\"#%ED%85%8C%EC%9D%B4%EB%B8%94-%ED%81%AC%EA%B8%B0-%EC%9E%AC%ED%95%A0%EB%8B%B9resizing\" aria-label=\"테이블 크기 재할당resizing permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>해시 테이블은 고정적인 공간을 할당해서 많은 데이터를 담기 위한 자료구조인 만큼 언젠가 데이터가 넘치기 마련이다.</p>\n<p>개방 주소법을 사용하는 경우에는 위에서 예시로 작성했던 코드에서 <code class=\"language-text\">풀방입니다</code>가 출력되는 상황, 즉 테이블이 실제로 꽉 차서 더이상 저장을 못하는 상황이 발생할 것이고, 분리 연결법을 사용하는 경우에는 테이블에 빈 공간이 적어지면서 충돌이 발생할 수록 각각의 버킷에 저장된 리스트가 점점 더 길어져서 리스트를 탐색하는 리소스가 너무 늘어난 상황이 발생할 것이다.</p>\n<p>그렇기 때문에 해시 테이블은 꽉꽉 아낌없이 채우기보다는 어느 정도 비워져 있는 것이 성능 상 더 좋으며, 해시 테이블을 운용할 때는 어느 정도 데이터가 차면 테이블의 크기를 늘려줘야한다.</p>\n<p>이건 특별한 알고리즘이라기보다는 그냥 기존 크기의 두 배정도로 새로운 테이블을 선언해서 기존 테이블의 데이터를 그대로 옮겨 담는 방법을 사용한다. 분리 연결법을 사용한 해시 테이블의 경우 재해싱(Rehashing)을 통해 너무 길어진 리스트의 길이를 나누어서 다시 저장하는 방법을 사용하기도 한다.</p>\n<p>이상으로 JavaScript와 함께 해시테이블을 파헤쳐보자 포스팅을 마친다.</p>\n<style>\nul.hash-table-dummy {\n  width: 100%;\n  margin: 0 auto;\n  display: flex;\n  border: 1px solid #ddd;\n  padding: 0;\n}\nul.hash-table-dummy > li {\n  flex-grow: 1;\n  list-style: none;\n  border-right: 1px solid #ddd;\n  margin: 0;\n  text-align: center;\n  font-size: 14px;\n}\nul.hash-table-dummy dt {\n  border-bottom: 1px solid #ddd;\n  background-color: #f0f0f0;\n}\nul.hash-table-dummy dd {\n  margin: 0;\n}\n</style>","fields":{"slug":"20190625-hashtable-with-js","path":"/2019/06/25/hashtable-with-js/","lang":"ko"},"frontmatter":{"title":"JavaScript와 함께 해시테이블을 파헤쳐보자","subTitle":"해시 함수, 충돌 해결, 테이블 크기 조정까지 깊이 알아보기","date":"Jun 25, 2019","categories":["프로그래밍","알고리즘"],"tags":["자료구조","해시테이블","Hash Table","Data structure","자바스크립트","JavaScript","기술면접","해시 충돌","Hash collision"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/5976bcb3d5c35dab87987842997a2aef/3a812/thumbnail.jpg","srcSet":"/static/5976bcb3d5c35dab87987842997a2aef/3a812/thumbnail.jpg 320w,\n/static/5976bcb3d5c35dab87987842997a2aef/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/5976bcb3d5c35dab87987842997a2aef/fc5c5/thumbnail.webp 320w,\n/static/5976bcb3d5c35dab87987842997a2aef/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/5976bcb3d5c35dab87987842997a2aef/2d839/thumbnail.jpg","srcSet":"/static/5976bcb3d5c35dab87987842997a2aef/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/5976bcb3d5c35dab87987842997a2aef/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"4faccd6f-d623-5f88-9c39-867a4a91e236","tableOfContents":"<ul>\n<li>\n<p><a href=\"#javascript%EC%9D%98-%EB%B0%B0%EC%97%B4%EC%9D%B4-%EC%8B%A4%EC%A0%9C%EB%A1%9C%EB%8A%94-%EB%B0%B0%EC%97%B4%EC%9D%B4-%EC%95%84%EB%8B%8C-%EC%9D%B4%EC%9C%A0\">JavaScript의 배열이 실제로는 배열이 아닌 이유</a></p>\n</li>\n<li>\n<p><a href=\"#javasciprt-%EB%B0%B0%EC%97%B4%EC%9D%98-%EB%B0%9C%EC%A0%84\">JavaSciprt 배열의 발전</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%BC%EB%B0%98-%EB%B0%B0%EC%97%B4-vs-%ED%83%80%EC%9D%B4%ED%95%91%EB%90%9C-%EB%B0%B0%EC%97%B4---%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90\">일반 배열 vs 타이핑된 배열 - 성능 비교</a></p>\n<ul>\n<li><a href=\"#%EC%9D%BC%EB%B0%98-%EB%B0%B0%EC%97%B4--%EC%82%BD%EC%9E%85\">일반 배열 – 삽입</a></li>\n<li><a href=\"#%ED%83%80%EC%9D%B4%ED%95%91%EB%90%9C-%EB%B0%B0%EC%97%B4--%EC%82%BD%EC%9E%85\">타이핑된 배열 – 삽입</a></li>\n<li><a href=\"#%EC%9D%BC%EB%B0%98-%EB%B0%B0%EC%97%B4--%EC%82%BD%EC%9E%85-%EB%8F%99%EC%9D%BC%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%9E%90%EB%A3%8C%ED%98%95\">일반 배열 – 삽입 (동일하지 않은 자료형)</a></li>\n<li><a href=\"#%EC%9D%BC%EB%B0%98-%EB%B0%B0%EC%97%B4---%EC%9D%BD%EA%B8%B0\">일반 배열 - 읽기</a></li>\n<li><a href=\"#typed-array---read\">Typed Array - read</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></p>\n</li>\n</ul>","excerpt":"이 포스팅은 2017년 9월 2일에 Paul Shan이 작성한 Diving deep into JavaScript array - evolution & performance를 번역한 글입니다. 포스팅을 시작하기 전에 이 포스팅은 JavaScript 배열의 구문에 관한 것을 알려주거나 예제를 보여주는 등의 기본적인 내용은 아니라고 먼저 얘기해두고 싶다. 이 포스팅에서는 메모리 표현, 최적화, 구문에 따라 달라지는 동작의 차이, 성능 및 최근의 JavaScript 배열이 어떻게 발전했는지에 관해서만 설명할 것이다.","html":"<blockquote>\n<p>이 포스팅은 2017년 9월 2일에 Paul Shan이 작성한 <a href=\"http://voidcanvas.com/javascript-array-evolution-performance/\" target=\"_blank\" rel=\"nofollow\">Diving deep into JavaScript array - evolution &#x26; performance</a>를 번역한 글입니다.</p>\n</blockquote>\n<p>포스팅을 시작하기 전에 이 포스팅은 JavaScript 배열의 구문에 관한 것을 알려주거나 예제를 보여주는 등의 기본적인 내용은 아니라고 먼저 얘기해두고 싶다. 이 포스팅에서는 메모리 표현, 최적화, 구문에 따라 달라지는 동작의 차이, 성능 및 최근의 JavaScript 배열이 어떻게 발전했는지에 관해서만 설명할 것이다.</p>\n<!-- more -->\n<p>필자가 JavaScript를 처음 시작했을 때 필자는 이미 C, C++, C# 등의 언어에 익숙한 상태였다. 그래서 다른 C/C++ 개발자들처럼 JavaScript와의 첫 만남이 그리 좋지는 못했다.</p>\n<p>그 중 필자가 JavaScript를 좋아하지 않았던 가장 큰 이유는, 바로 배열이다. JavaScript의 배열은 Hash Map이나 Dictionary로 구현되었고 연속적이지 않기 때문에 필자는 이 언어가 배열을 제대로 구현할수도 없는 B급 언어라고 생각했다. 그러나 그 이후 JavaScript에 대한 필자의 이해도는 많이 달라졌다.</p>\n<blockquote>\n<p>(역주) 기존 언어에서 구현했던 배열은 생성 시에 특정 범위의 메모리를 할당하고 연속적으로 데이터를 저장했지만 JavaScript는 메모리를 미리 할당해놓지 않고 동적 할당하므로 연속적으로 원소가 저장되지 않는다. 리스트와 동일한 방식.</p>\n</blockquote>\n<h2 id=\"javascript의-배열이-실제로는-배열이-아닌-이유\" style=\"position:relative;\">JavaScript의 배열이 실제로는 배열이 아닌 이유<a href=\"#javascript%EC%9D%98-%EB%B0%B0%EC%97%B4%EC%9D%B4-%EC%8B%A4%EC%A0%9C%EB%A1%9C%EB%8A%94-%EB%B0%B0%EC%97%B4%EC%9D%B4-%EC%95%84%EB%8B%8C-%EC%9D%B4%EC%9C%A0\" aria-label=\"javascript의 배열이 실제로는 배열이 아닌 이유 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자바스크립트에 관한 설명들을 시작하기 전에 배열이 무엇인지부터 설명을 먼저 해야할 것 같다. 배열은 연속적인 메모리 로케이션들의 묶음을 사용하여 값을 저장하는 데 사용된다. 여기서 중요한 포인트는 연속성(continuous)과 인접성(contiguous)이라는 단어이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c7e180c48ce9b399c40a3fbf9f1333a7/0a47e/actual-array-js.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 36.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQklEQVR42iVQa2+CMBTl/yfLFo1ErMirUFqgtDzKQ1CnLttc9vhJO27J+XDvzXm11nGsT2MztuX1OHy+nU9DPXf653b5er+8nvc6izHg/n1fp76RH9fD7eUwGPU8G0sXCbGf4oBAf56NiHe1TM9zB8e+ypSgU6cno7CqjHY6A+fQ66pgp8lYLCSxv8kSrxRRnngyDUse5iyoJe/rAkYNUIqhlbVkpaBS0Jz5yJj6ykojFwunO049zIlP0nALQB97ThqSuyOPssTfOYt/sRQRp25X5Za7XlBvDarKmE9W6+XDaNTYqqGRZPUI9txXQM5Cb7M0Shz3bV/nkBid35PRvCqSggUs2EpOcWlKjiOUaITnIRbYtyUaYY19B13AscBg4dYndujaOo/hjfdghgXyQA1cOwlIq4TRGTTUc/5+JC0F/QWWyhqMik1vZQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Actual Array in JavaScript\" title=\"\" src=\"/static/c7e180c48ce9b399c40a3fbf9f1333a7/0a47e/actual-array-js.png\" srcset=\"/static/c7e180c48ce9b399c40a3fbf9f1333a7/69538/actual-array-js.png 160w,\n/static/c7e180c48ce9b399c40a3fbf9f1333a7/72799/actual-array-js.png 320w,\n/static/c7e180c48ce9b399c40a3fbf9f1333a7/0a47e/actual-array-js.png 600w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>위 그림은 배열의 메모리 상태의 예시를 표현한 것이다. 이 배열은 4 bit로 이루어진 4개의 블록을 가지고 있고 총 16 bit의 메모리 블록을 사용하고 있다.</p>\n<p>이제 필자가 <code class=\"language-text\">tinyInt arr[4];</code>를 선언했고 <code class=\"language-text\">1201</code>부터 시작해서 이 메모리 블록들을 포착했다고 가정해보자. 이제 필자가 어떤 포인트로부터 <code class=\"language-text\">a[2]</code>를 읽으려고 한다면 <code class=\"language-text\">a[2]</code>의 메모리 주소를 찾기 위한 간단한 수학 계산이 이루어진다. <code class=\"language-text\">1201 + (2 x 4)</code>와 같은 식으로 <code class=\"language-text\">1209</code>의 주소를 바로 참조할 수 있다.</p>\n<blockquote>\n<p>역주: 메모리 시작 주소 + (찾고자 하는 인덱스 x 한 블록에 할당된 메모리 블록 개수)로 계산한 것이다. 배열은 이렇게 원하는 원소에 바로 접근할 수 있다.</p>\n</blockquote>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/63222325472ecc8c4fad266fed47e953/0a47e/old-array-js.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACEUlEQVR42i2S6W7aUBCF/cz9U6mKlLZCSVNCQ9gLNt534x3vK97AhhDaF+o4qjQajTR35pz5dJHmELVl2jX526m4nsrrqbp19bUt/1yOCkcknvl2Km9ddWur97b6eFO8t+W5Ofy9nJAqC+s8aoqkq9Lz/8gusNI1ZZawVVGXuSL2LsdDW6VdnXVVVsRuWybnpkDyyC0Tv8mjIvbrLKhSv0j9Y5FoMmfInCrQPIXFnlUfwjoLq8QXGFyksdgxksBGoJEGFrP9DQp1Hqa+DVGnQbDXZy9PIL/jqSIJ8sgpE881FHw9920NW000iUH8va7J7GbxCsMChXLEmiU2lirIHAljArOVOSILndA1E9/yrR2DrylsqfBk5BhIYIM1DNjErinQW5HB0eWEpzGeQnfQWE1Dx3BNBdTCvZEHe57aDh++etbOszTEMRSO3KgirYk0hS6fH7/T2xX0ANji9VniCGgBNlvrQ2b71WAY/FuqiBiKwBLoej6msSU41CUGOMEJmsQ+fLubjh4X4+Fk9IPYzPH1DDLY2esSKOoyi+x4EnyrIqPLPKzURAbaML+ajjhiA/XT4B4s9BslFsRNhYcCNIAIItG4zOASS/aEOMgUnK0CuuVk9vLz7vOn+XgIGxWe6jUECq6AAiYllkB4EhUoTOxRfQSNAyYABj/k19NgcP9FYnGoJQYyDniUXoAEAYHC/gEAE71eBuizGwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Old Array in JavaScript\" title=\"\" src=\"/static/63222325472ecc8c4fad266fed47e953/0a47e/old-array-js.png\" srcset=\"/static/63222325472ecc8c4fad266fed47e953/69538/old-array-js.png 160w,\n/static/63222325472ecc8c4fad266fed47e953/72799/old-array-js.png 320w,\n/static/63222325472ecc8c4fad266fed47e953/0a47e/old-array-js.png 600w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>JavaScript에서의 배열은 Hash Map이다. 이것은 다양한 자료 구조를 사용해서 구현될 수 있고, 그 중 하나가 바로 Linked List이다. 만약 JavaScript 내에서 우리가 <code class=\"language-text\">var arr = new Array(4);</code>로 배열을 선언하면 이 배열은 상단의 그림과 같은 구조를 생성한다. 따라서 만약 우리가 <code class=\"language-text\">a[2]</code>를 읽고 싶다면 무조건 <code class=\"language-text\">1201</code>부터 탐색해나가면서 <code class=\"language-text\">a[2]</code>를 찾아나가야 한다는 것이다.</p>\n<p>이것이 바로 JavaScript의 배열과 진짜 배열이 다른 점이다. 분명히 JavaScript의 배열을 탐색하는 것은 원래의 Linked List 탐색보다는 계산이 적다. 그러나 배열의 길이가 길어질수록 인생이 고달파지는 건 똑같다.</p>\n<h2 id=\"javasciprt-배열의-발전\" style=\"position:relative;\">JavaSciprt 배열의 발전<a href=\"#javasciprt-%EB%B0%B0%EC%97%B4%EC%9D%98-%EB%B0%9C%EC%A0%84\" aria-label=\"javasciprt 배열의 발전 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>예전에는 친구가 컴퓨터에 256MB 짜리 램을 사용한다고 하면 부러움을 느끼던 시절도 있었지만 요즘엔 보통 8GB 정도의 램을 사용한다.</p>\n<p>이와 비슷하게 JavaScript 또한 많은 발전을 이루었다. V8, SpiderMonkey, TC39, 증가하고 있는 웹 사용자들의 피나는 노력으로 인해 JavaScript는 전 세계의 필수 요소가 되었다. 이렇게 거대한 유저 베이스를 가지고 있다면 분명히 성능 향상 또한 필요하다.</p>\n<p>최근의 JavaScript 엔진은 모든 요소가 동일한 타입을 가지고 있는 배열인 경우 연속적으로 메모리를 할당한다. 훌륭한 프로그래머는 항상 배열을 동일한 타입으로 사용하며 <a href=\"https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC\" target=\"_blank\" rel=\"nofollow\">JIT(Just in Time)</a> 컴파일러는 이런 배열에 대해서 C 컴파일러와 같은 배열 계산을 수행한다.</p>\n<p>그러나 이런 동일한 타입 배열에 다른 타입의 원소를 삽입하려고 할 때 JIT는 전체 배열의 구조를 해제하고 다시 예전의 배열처럼 비연속적인 메모리를 할당한다. 즉, 만약 우리가 코드를 제대로 작성한다면 JavaScript의 <code class=\"language-text\">Array</code> 객체는 실제 배열처럼 작동한다는 것이다. 이는 모던 JS 개발자들에게는 정말 좋은 일이다.</p>\n<p>이에 더해서 배열은 ES2015 또는 ES6를 통해서 더욱 발전했다. TC39 위원회는 JavaScript에 타이핑된 배열을 추가하기로 결정했고 그래서 우리는 <code class=\"language-text\">ArrayBuffer</code>를 사용할 수 있게 되었다.\n<code class=\"language-text\">ArrayBuffer</code>는 인접한 메모리 블록을 제공하고 우리가 그것을 마음대로 다룰 수 있게 해준다. 그러나 메모리를 직접 다루는 것은 매우 Low Level이고 또 너무 복잡하기 때문에 우리는 View라는 것을 통해서 ArrayBuffer를 다루게 된다. 이미 몇가지 View를 사용할 수 있고 나중에는 더 추가될 예정이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> buffer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> view   <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Int32Array</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nview<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>만약 당신이 <code class=\"language-text\">Int32Array</code>와 같은 <em>Typed Array</em>에 대해서 더 알고 싶다면 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\" target=\"_blank\" rel=\"nofollow\">MDN Documentation</a>를 참고하기 바란다.</p>\n<p>타이핑된 배열은 굉장히 효율적이다. 타이핑된 배열은 WebGL을 사용하는 사람들이 일반 배열로는 바이너리 데이터를 효과적으로 처리할 수 없는 엄청난 성능 문제에 직면했기 때문에 요청해서 도입된 객체이다.<small>(역주: ThreeJS도 내부적으로는 전부 Typed Array를 사용 중이고, 성능 차이 또한 몸으로 느껴질 정도로 확연하다.)</small> 또한 우리는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\" target=\"_blank\" rel=\"nofollow\">SharedArrayBuffer</a>를 사용하여 여러 개의 Web Worker간 메모리를 공유하여 성능을 끌어올릴 수도 있다.</p>\n<p>놀랍지 않은가? JavaScript의 배열은 간단한 Hash Map에서 시작해서 이제는 <code class=\"language-text\">SharedArrayBuffer</code>까지 다루고 있다.</p>\n<h2 id=\"일반-배열-vs-타이핑된-배열---성능-비교\" style=\"position:relative;\">일반 배열 vs 타이핑된 배열 - 성능 비교<a href=\"#%EC%9D%BC%EB%B0%98-%EB%B0%B0%EC%97%B4-vs-%ED%83%80%EC%9D%B4%ED%95%91%EB%90%9C-%EB%B0%B0%EC%97%B4---%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90\" aria-label=\"일반 배열 vs 타이핑된 배열   성능 비교 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리는 JavaScript 배열의 발전에 대해서 이야기 했다. 이제 최근의 배열이 얼마나 좋은지 확인해보자. 필자는 Mac과 <code class=\"language-text\">Node.js 8.4.0</code> 환경에서 몇 개의 작은 테스트를 해보았다.</p>\n<h3 id=\"일반-배열--삽입\" style=\"position:relative;\">일반 배열 – 삽입<a href=\"#%EC%9D%BC%EB%B0%98-%EB%B0%B0%EC%97%B4--%EC%82%BD%EC%9E%85\" aria-label=\"일반 배열  삽입 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token constant\">LIMIT</span> <span class=\"token operator\">=</span> <span class=\"token number\">10000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LIMIT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Array insertion time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">LIMIT</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Array insertion time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>수행 시간:</strong> <em>55ms</em></p>\n<h3 id=\"타이핑된-배열--삽입\" style=\"position:relative;\">타이핑된 배열 – 삽입<a href=\"#%ED%83%80%EC%9D%B4%ED%95%91%EB%90%9C-%EB%B0%B0%EC%97%B4--%EC%82%BD%EC%9E%85\" aria-label=\"타이핑된 배열  삽입 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token constant\">LIMIT</span> <span class=\"token operator\">=</span> <span class=\"token number\">10000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> buffer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LIMIT</span> <span class=\"token operator\">*</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Int32Array</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ArrayBuffer insertion time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">LIMIT</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ArrayBuffer insertion time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>수행 시간:</strong> <em>52ms</em></p>\n<blockquote>\n<p>앗…? 예전의 전통적인 배열과 최근 배열의 성능이 비슷한데요…?</p>\n</blockquote>\n<p>Nope. 필자는 요즘의 컴파일러는 똑똑하기때문에 같은 타입을 가진 배열은 내부적으로 연속적인 메모리를 가진 배열로 변환한다는 것을 설명했다. 이게 바로 첫번째 예시에서 발생한 일이다. 필자는 <code class=\"language-text\">new Array(LIMIT)</code>을 사용했지만 내부적으로는 연속적인 메모리 할당을 가진 현대적인 배열을 유지하고 있던 것이다.</p>\n<p>이제 첫번째 예시를 수정하여 동일한 자료형을 가지고 있지 않은 배열로 만들고 성능 차이가 있는지 살펴보도록 하자.</p>\n<h3 id=\"일반-배열--삽입-동일하지-않은-자료형\" style=\"position:relative;\">일반 배열 – 삽입 (동일하지 않은 자료형)<a href=\"#%EC%9D%BC%EB%B0%98-%EB%B0%B0%EC%97%B4--%EC%82%BD%EC%9E%85-%EB%8F%99%EC%9D%BC%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%9E%90%EB%A3%8C%ED%98%95\" aria-label=\"일반 배열  삽입 동일하지 않은 자료형 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token constant\">LIMIT</span> <span class=\"token operator\">=</span> <span class=\"token number\">10000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LIMIT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span> <span class=\"token number\">22</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Array insertion time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">LIMIT</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Array insertion time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>수행 시간:</strong> <em>1207ms</em></p>\n<p>여기서 필자는 3번 라인에 새로운 표현을 추가했을 뿐 나머지는 이전과 전부 동일하지만 성능은 차이가 나기 시작했다. 무려 <code class=\"language-text\">22배</code> 느려진 것을 확인할 수 있다.</p>\n<h3 id=\"일반-배열---읽기\" style=\"position:relative;\">일반 배열 - 읽기<a href=\"#%EC%9D%BC%EB%B0%98-%EB%B0%B0%EC%97%B4---%EC%9D%BD%EA%B8%B0\" aria-label=\"일반 배열   읽기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token constant\">LIMIT</span> <span class=\"token operator\">=</span> <span class=\"token number\">10000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LIMIT</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span> <span class=\"token number\">22</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">LIMIT</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> p<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Array read time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">LIMIT</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//arr[i] = i;</span>\n  p <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Array read time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>수행 시간:</strong> <em>196ms</em></p>\n<h3 id=\"typed-array---read\" style=\"position:relative;\">Typed Array - read<a href=\"#typed-array---read\" aria-label=\"typed array   read permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token constant\">LIMIT</span> <span class=\"token operator\">=</span> <span class=\"token number\">10000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> buffer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBuffer</span><span class=\"token punctuation\">(</span><span class=\"token constant\">LIMIT</span> <span class=\"token operator\">*</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Int32Array</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ArrayBuffer insertion time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">LIMIT</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ArrayBuffer read time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token constant\">LIMIT</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ArrayBuffer read time\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>수행 시간:</strong> <em>27ms</em></p>\n<h2 id=\"결론\" style=\"position:relative;\">결론<a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>JavaScript에 타이핑된 배열이 추가된 것은 위대한 첫 발걸음이다. <code class=\"language-text\">Int8Array</code>, <code class=\"language-text\">Uint8Array</code>, <code class=\"language-text\">Uint8ClampedArray</code>, <code class=\"language-text\">Int16Array</code>, <code class=\"language-text\">Uint16Array</code>, <code class=\"language-text\">Int32Array</code>, <code class=\"language-text\">Uint32Array</code>, <code class=\"language-text\">Float32Array</code>, <code class=\"language-text\">Float64Array</code> 등은 네이티브 바이트 순서로 이루어진 뷰를 제공하고, 또 여러분이 직접 <code class=\"language-text\">DataView</code>를 사용하여 커스텀 뷰를 만들 수도 있다. 앞으로 ArrayBuffer를 사용하기 위해 더 많은 DataView 라이브러리들이 활성화되기를 바란다.</p>\n<p>JavaScript의 배열이 이렇게 개선된 것은 좋은 일이다. 이제 JavaScript의 배열은 빠르고 효율적이며 강력하고 똑똑하게 메모리를 할당할 수 있게 된 것이다.</p>","fields":{"slug":"20190615-diving-into-js-array","path":"/2019/06/15/diving-into-js-array/","lang":"ko"},"frontmatter":{"title":"[번역] JavaScript 배열(Array)의 발전과 성능에 대해서 자세히 알아보기","subTitle":null,"date":"Jun 15, 2019","categories":["프로그래밍","자바스크립트"],"tags":["JavaScript","자바스크립트","성능 최적화","배열","Array","연속할당","비연속할당","자료구조","기술면접","포인터","메모리구조"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/c7e180c48ce9b399c40a3fbf9f1333a7/d803c/actual-array-js.png","srcSet":"/static/c7e180c48ce9b399c40a3fbf9f1333a7/d803c/actual-array-js.png 320w,\n/static/c7e180c48ce9b399c40a3fbf9f1333a7/4b994/actual-array-js.png 600w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/c7e180c48ce9b399c40a3fbf9f1333a7/fc5c5/actual-array-js.webp 320w,\n/static/c7e180c48ce9b399c40a3fbf9f1333a7/642e3/actual-array-js.webp 600w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/c7e180c48ce9b399c40a3fbf9f1333a7/a6173/actual-array-js.png","srcSet":"/static/c7e180c48ce9b399c40a3fbf9f1333a7/a6173/actual-array-js.png 600w","sizes":"100vw"},"sources":[{"srcSet":"/static/c7e180c48ce9b399c40a3fbf9f1333a7/53e83/actual-array-js.webp 600w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"자료구조","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}