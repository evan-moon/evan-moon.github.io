{"componentChunkName":"component---src-templates-post-page-template-index-tsx","path":"/2024/04/02/category-theory-for-programmers-8-functoriality/","result":{"data":{"markdownRemark":{"id":"ee3fcb22-5cce-5033-9187-c2ea953b6f10","tableOfContents":"<ul>\n<li><a href=\"#81-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0bifunctors\">8.1 이항 펑터(Bifunctors)</a></li>\n<li><a href=\"#82-%EA%B3%B1%EA%B3%BC-%ED%95%A9-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0product-and-coproduct-bifunctors\">8.2 곱과 합 이항 펑터(Product and Coproduct Bifunctors)</a></li>\n<li><a href=\"#83-%ED%8E%91%ED%84%B0%EC%A0%81%EC%9D%B8-%EB%8C%80%EC%88%98%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%90%EB%A3%8C%ED%98%95functorial-algebraic-data-types\">8.3 펑터적인 대수적 데이터 자료형(Functorial Algebraic Data Types)</a></li>\n<li><a href=\"#84-c%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0functors-in-c\">8.4 C++에서의 펑터(Functors in C++)</a></li>\n<li><a href=\"#85-writer-%ED%8E%91%ED%84%B0\">8.5 Writer 펑터</a></li>\n<li><a href=\"#86-%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0%EC%99%80-%EB%B0%98%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0covariant-and-contravariant-functors\">8.6 공변적 펑터와 반공변적 펑터(Covariant and Contravariant Functors)</a></li>\n<li><a href=\"#87-%ED%94%84%EB%A1%9C%ED%8E%91%ED%84%B0profunctors\">8.7 프로펑터(Profunctors)</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"이제 펑터가 무엇인지 알았으니, 작은 펑터로부터 큰 펑터를 구축해나가는 방법에 대해서 살펴보도록 하겠다. 여기서 특히 흥미로운 부분은 카테고리 내 대상 간의 매핑에 대당하는 타입의 생성자가 확장되어 사상 간의 매핑을 포함하는 펑터가 되는 과정을 볼 수 있다는 것이다. 8.1 이항 펑터(Bifunctors) 펑터는 카테고리들의 카테고리인 Cat에서의 사상이기 때문에 사상에 대한 많은 직관들 특히 함수에 대한 직관들은 펑터에도 그대로 작용한다고 할 수 있다. 예를 들어 두 개의 인수를 가지는 함수가 있듯이, 두 개의 인수를 가지는 펑…","html":"<p>이제 펑터가 무엇인지 알았으니, 작은 펑터로부터 큰 펑터를 구축해나가는 방법에 대해서 살펴보도록 하겠다.</p>\n<p>여기서 특히 흥미로운 부분은 카테고리 내 대상 간의 매핑에 대당하는 타입의 생성자가 확장되어 사상 간의 매핑을 포함하는 펑터가 되는 과정을 볼 수 있다는 것이다.</p>\n<h2 id=\"81-이항-펑터bifunctors\" style=\"position:relative;\">8.1 이항 펑터(Bifunctors)<a href=\"#81-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0bifunctors\" aria-label=\"81 이항 펑터bifunctors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>펑터는 카테고리들의 카테고리인 <em>Cat</em>에서의 사상이기 때문에 사상에 대한 많은 직관들 특히 함수에 대한 직관들은 펑터에도 그대로 작용한다고 할 수 있다.</p>\n<p>예를 들어 두 개의 인수를 가지는 함수가 있듯이, 두 개의 인수를 가지는 펑터인 이항 펑터(Bifunctors)도 존재할 수 있다. 먼저 대상에 대해서만 생각해보자면 이항 펑터는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>, 그리고 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 각각의 대상으로 이루어진 모든 쌍을 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>의 대상으로 매핑하는 펑터이다. 즉, 이항 헝터는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C×D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 표현되는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 데카르트 곱에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로의 매핑이라고 볼 수 있는 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 313px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 95%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQCAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9qSmO25pJriHcH//xAAbEAACAgMBAAAAAAAAAAAAAAABAhESAAMiIf/aAAgBAQABBQK/R2myGwK+8h1EKROBFnP/xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPwEj/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgIDAAAAAAAAAAAAAAAAARARMQAgIf/aAAgBAQAGPwKMtSa0PF//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhMWFBEP/aAAgBAQABPyGm2apHKjWu5l0eoCAxftQgBvsDByTij8//2gAMAwEAAgADAAAAEMPAfP/EABcRAQEBAQAAAAAAAAAAAAAAAAEQMUH/2gAIAQMBAT8QK8gpk//EABYRAQEBAAAAAAAAAAAAAAAAAAEgMf/aAAgBAgEBPxAQ2P/EABwQAQEAAwEAAwAAAAAAAAAAAAERACExQWFxgf/aAAgBAQABPxArQUr9GVYl0LA8Odyl0qJ5+YboVU+zFxsGnZXcHJOkvyu8CjSiONoXhtw0Z//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" srcset=\"/static/6f3400dcb00c047b27d284f6c7f27034/0913d/1.jpg 160w,\n/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg 313w\" sizes=\"(max-width: 313px) 100vw, 313px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>사실 여기까지는 매우 간단하게 이해할 수 있다. 그러나 펑터의 특성상 이항 펑터는 대상 뿐만 아니라 사상 또한 매핑할 수 있어야 한다. 즉, 하나는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 다른 하나는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 가져온 사상의 쌍을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>의 사상으로 매핑해야 한다는 것이다.</p>\n<p>한번 더 이야기하자면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>가 가진 사상의 쌍은 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C×D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 단일한 사상이다. 우리는 데카르트 곱 카테고리에서의 사상을 어떤 대상의 쌍에서 다른 대상의 쌍으로 이동하는 사상의 쌍으로 정의할 수 있다. 이러한 사상의 쌍들은 아래와 같은 방식으로 합성도 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">)</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f'</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> ◦ <span class=\"token hvariable\">f'</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span> ◦ <span class=\"token hvariable\">g'</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>합성은 결합법칙을 만족하며, <code class=\"language-text\">(id, id)</code>와 같은 항등원 또한 존재한다. 이처럼 데카르트 곱 카테고리는 카테고리의 기본적인 법칙을 모두 만족하기 때문에 실제로 하나의 카테고리가 될 수 있는 것이다.</p>\n<p>이항 펑터에 대해서 더 쉽게 이해하려면 이 펑터가 두 인자 모두에 대한 펑터라는 점을 이해하는 것에서부터 출발해야한다. 즉, 펑터 법칙인 결합성과 항등 보존에 대한 개념을 곧바로 이항 펑터와 연결하고 확인해보려고 시도하는 것보다는, 이항 펑터가 가진 각 인자에 대해 하나씩 확인해보는 것이 더 이해하기 쉽다는 것이다.</p>\n<p>만약 한 쌍의 카테고리로부터 세 번째 카테고리로의 매핑이 있고, 그 매핑이 각 인자에 대해 펑터적(Functorial)이라는 사실을 만족한다는 사실을 증명한다면, 해당 매핑은 자동으로 이항 펑터가 된다. 여기서 펑터적이라는 의미는 이 펑터가 사상에 대해서 제대로 된 펑터처럼 작동한다는 것을 의미한다.</p>\n<p>Haskell에서 이항 펑터를 한번 정의해보자. 이 경우에는 세 개의 카테고리가 모두 Haskell 타입의 카테고리이기 때문에 사실상 같은 카테고리라고 볼 수 있다. 이항 펑터는 두 개의 타입 인자를 가지는 타입 생성자로 표현된다. 아래는 라이브러리 <code class=\"language-text\">Control.Bifunctor</code>에서 직접 가져온 <code class=\"language-text\">Bifunctor</code> 타입 클래스의 정의이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token hvariable\">f</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">d</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">g</span> <span class=\"token hvariable\">h</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">first</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">second</span> <span class=\"token hvariable\">h</span>\n  \t<span class=\"token hvariable\">first</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">b</span>\n  \t<span class=\"token hvariable\">first</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">g</span> <span class=\"token builtin\">id</span>\n  \t<span class=\"token hvariable\">second</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">d</span>\n  \t<span class=\"token hvariable\">second</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">bimap</span> <span class=\"token builtin\">id</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>타입 변수 <code class=\"language-text\">f</code>는 이항 펑터를 나타내며, 아래 정의된 모든 타입 시그니처에서 이 타입 변수가 항상 두 개의 타입 인자에 적용되는 것을 볼 수 있다.</p>\n<p>첫 번째 타입 시그니처는 <code class=\"language-text\">bimap</code>을 정의하는데, 이것은 두 함수의 매핑을 한 번에 나타낸다. 결과는 이항 펑터의 타입 생성자에 의해 생성된 타입들에서 동작하는 함수 <code class=\"language-text\">(f a b -> f c d)</code>이다. <code class=\"language-text\">bimap</code>은 <code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>를 사용하여 구현되어 있는데, 이는 이항 펑터가 각각의 인자에 대해 펑터적으로 작동한다는 사실을 정의하는 것만으로도 이항 펑터를 정의할 수 있다는 사실을 보여준다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 313px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 95%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQCAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9qSmO25pJriHcH//xAAbEAACAgMBAAAAAAAAAAAAAAABAhESAAMiIf/aAAgBAQABBQK/R2myGwK+8h1EKROBFnP/xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPwEj/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgIDAAAAAAAAAAAAAAAAARARMQAgIf/aAAgBAQAGPwKMtSa0PF//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhMWFBEP/aAAgBAQABPyGm2apHKjWu5l0eoCAxftQgBvsDByTij8//2gAMAwEAAgADAAAAEMPAfP/EABcRAQEBAQAAAAAAAAAAAAAAAAEQMUH/2gAIAQMBAT8QK8gpk//EABYRAQEBAAAAAAAAAAAAAAAAAAEgMf/aAAgBAgEBPxAQ2P/EABwQAQEAAwEAAwAAAAAAAAAAAAERACExQWFxgf/aAAgBAQABPxArQUr9GVYl0LA8Odyl0qJ5+YboVU+zFxsGnZXcHJOkvyu8CjSiONoXhtw0Z//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" srcset=\"/static/6f3400dcb00c047b27d284f6c7f27034/0913d/1.jpg 160w,\n/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg 313w\" sizes=\"(max-width: 313px) 100vw, 313px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>bimap</small>\n</center>\n<p><code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>는 각각 첫 번째와 두 번째 인자에 대한 <code class=\"language-text\">f</code>의 펑터적인 성질을 증명하는 두 개의 <code class=\"language-text\">fmap</code>이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 388px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/351da696e6a37d5df6740dce2c23f8d6/c3c84/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 82.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAEEBQL/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB1613PXQdkkEg/8QAHRAAAgEEAwAAAAAAAAAAAAAAAQIAAxAREhMhMf/aAAgBAQABBQJqms5ThO1YYg2g8v8A/8QAFREBAQAAAAAAAAAAAAAAAAAAASD/2gAIAQMBAT8BCP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABoQAQEAAgMAAAAAAAAAAAAAAAEAESEgIkH/2gAIAQEABj8Cb3LblDcdeP8A/8QAHBAAAgEFAQAAAAAAAAAAAAAAAAERICExQVFh/9oACAEBAAE/IfY4JqX0B3JkISQbQzOEr8MFoo//2gAMAwEAAgADAAAAEB/PAP/EABURAQEAAAAAAAAAAAAAAAAAAAEg/9oACAEDAQE/EGY//8QAFhEBAQEAAAAAAAAAAAAAAAAAAREg/9oACAECAQE/EKGP/8QAHRABAAICAgMAAAAAAAAAAAAAAQARITFBgRBRkf/aAAgBAQABPxBUQwHAVPUdSwoLj7UGbi3mzqERNwu+oYWLGXTviBAQqyGiPENeP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/351da696e6a37d5df6740dce2c23f8d6/c3c84/3.jpg\" srcset=\"/static/351da696e6a37d5df6740dce2c23f8d6/0913d/3.jpg 160w,\n/static/351da696e6a37d5df6740dce2c23f8d6/cb69c/3.jpg 320w,\n/static/351da696e6a37d5df6740dce2c23f8d6/c3c84/3.jpg 388w\" sizes=\"(max-width: 388px) 100vw, 388px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>first</small>\n</center>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 423px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f7734853d3675663d3f814199fd26135/b7bea/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 92.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGQABAQADAQAAAAAAAAAAAAAAAAQBAgMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAfXlqkq9sjPMOoP/xAAbEAACAgMBAAAAAAAAAAAAAAABAhEhAAMSE//aAAgBAQABBQL0g9uShlTrsKJWgbzhZz//xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPwEj/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgMBAQAAAAAAAAAAAAAAEBEAASExMv/aAAgBAQAGPwJKYLt5PR4P/8QAGhABAQEBAQEBAAAAAAAAAAAAAREAITEQcf/aAAgBAQABPyFt6Qz2DzNZ9wUTlHpn7gCDcARKYPx+f//aAAwDAQACAAMAAAAQ9898/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EBs1J//EABURAQEAAAAAAAAAAAAAAAAAAAEg/9oACAECAQE/EBCP/8QAHRABAQACAwADAAAAAAAAAAAAAREAMSFBUWGx0f/aAAgBAQABPxCxKhH2X8xw1bCgF89wyOyOAVINjq2/eJoBUQ8dmRNJv35yISbHvHCUJvnDg4z/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/f7734853d3675663d3f814199fd26135/b7bea/4.jpg\" srcset=\"/static/f7734853d3675663d3f814199fd26135/0913d/4.jpg 160w,\n/static/f7734853d3675663d3f814199fd26135/cb69c/4.jpg 320w,\n/static/f7734853d3675663d3f814199fd26135/b7bea/4.jpg 423w\" sizes=\"(max-width: 423px) 100vw, 423px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>second</small>\n</center>\n<p>타입 클래스 정의는 <code class=\"language-text\">bimap</code>을 기반으로 두 개의 함수에 대한 기본 구현을 제공한다.</p>\n<p><code class=\"language-text\">Bifunctor</code>의 인스턴스를 선언할 때는 <code class=\"language-text\">bimap</code>을 구현하고, <code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>의 기본 값을 사용하거나, 반대로 <code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>를 모두 구현하고 <code class=\"language-text\">bimap</code>의 기본 값을 사용하는 선택권을 가질 수 있다. (물론 세 가지 모두를 구현할 수는 있겠지만, 그러면 이들이 위와 같은 성질을 가질 수 있도록 보장해줘야 한다.)</p>\n<h2 id=\"82-곱과-합-이항-펑터product-and-coproduct-bifunctors\" style=\"position:relative;\">8.2 곱과 합 이항 펑터(Product and Coproduct Bifunctors)<a href=\"#82-%EA%B3%B1%EA%B3%BC-%ED%95%A9-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0product-and-coproduct-bifunctors\" aria-label=\"82 곱과 합 이항 펑터product and coproduct bifunctors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이항 펑터의 예시 중 특히 중요한 것은 카테고리적 곱(Categorical Product)이다. 이는 두 대상의 곱으로, <a href=\"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts\">보편적 구성(Universial Construction)</a>에 의해 정의된다. 만약 어떤 두 대상에 대한 곱이 존재한다면, 해당 대상들에서 곱으로의 매핑은 이항 펑터적(Bifunctorial)이다. 이것은 일반적으로 참이며, 특히 Haskell에서도 마찬가지이다.</p>\n<p>아래는 가장 간단한 곱 타입인 쌍 생성자에 대한 <code class=\"language-text\">Bifunctor</code> 인스턴스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">bimap</code>은 단순히 쌍의 첫 번째 구성 요소에 첫 번째 함수를 적용하고, 두 번째 구성 요소에는 두 번째 함수를 적용하고 있기 때문에, 딱히 고민할만한 부분이 없다. 이렇게 명확하고 간단한 동작이 요구사항으로 주어진다면 코드 작성 자체는 간단하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">bimap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 이항 펑터의 작용은 타입들의 쌍을 만드는 것이다. 예를 들면 이런 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>쌍대성에 의해 이 정의가 카테고리 내의 모든 대상 쌍에 대해서 정의된다면, 합(Coproduct) 또한 이항 펑터라고 할 수 있다. Haskell에서는 <code class=\"language-text\">Either</code> 타입 생성자를 <code class=\"language-text\">Bifunctor</code>의 인스턴스인 것으로 나타낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token constant\">Either</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">_</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Left</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Right</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>워낙 동작이 간단하고 요구사항이 명확하니 코드 작성은 어렵지 않다.</p>\n<p>혹시 모노이드 카테고리(Monoidal Category)에 대해 이야기했던 것을 기억하는가? 모노이드 카테고리는 단위 대상과 함께 대상에 작용하는 이항 연산자인 모노이드 곱(Monoidal Product)을 정의한다.</p>\n<p>예전에 이야기했듯이 <em>Set</em>(집합의 카테고리)은 데카르트 곱 연산을 이항 연산으로 사용하여 대상 간의 결합을 정의하는 모노이드 카테고리이며, 이때 단위 대상은 단일 원소 집합이다. 또한 서로소 합집합 연산에 대해서도 모노이드 카테고리라고 볼 수 있으며, 이때의 단위 대상은 공집합이 된다.</p>\n<p>당시 필자가 언급하지 않은 것이 하나가 있다. 바로 모노이드 카테고리의 요구 사항 중 하나는 이항 연산자가 이항 펑터여야 한다는 것이다.</p>\n<p>우리는 모노이드 곱의 연산 구조가 사상에 의해 정의된 카테고리의 구조와 호환되도록 만들어야 하며, 이것은 매우 중요한 요구 사항이다. 물론 완전한 이해를 하기에는 아직 자연성(Naturality)이라는 큰 산이 하나 남아 있기는 하지만, 그래도 모노이드 카테고리의 전체 정의에 한 발짝 더 가까워졌다.</p>\n<h2 id=\"83-펑터적인-대수적-데이터-자료형functorial-algebraic-data-types\" style=\"position:relative;\">8.3 펑터적인 대수적 데이터 자료형(Functorial Algebraic Data Types)<a href=\"#83-%ED%8E%91%ED%84%B0%EC%A0%81%EC%9D%B8-%EB%8C%80%EC%88%98%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%90%EB%A3%8C%ED%98%95functorial-algebraic-data-types\" aria-label=\"83 펑터적인 대수적 데이터 자료형functorial algebraic data types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 펑터가 될 수 있는 몇 가지 파라미터화된 데이터 타입을 살펴봤다. 우리는 이러한 타입들에 대한 <code class=\"language-text\">fmap</code>을 정의할 수 있었다. 복잡한 데이터 타입은 더 간단한 데이터 타입을 기반으로 하여 구성되는데, 합과 곱의 개념을 사용하여 대수적 데이터 타입(ADT)을 생성하는 것이 바로 그 예이다.</p>\n<p>앞선 섹션에서 우리는 이미 합과 곱이 펑터적이라는 사실을 확인했고, 펑터가 합성 가능하다는 사실도 알게 되었다. 결국 우리가 대수적 데이터 타입의 기본 구성 요소가 펑터라는 사실을 보일 수만 있다면, 파라미터화된 대수적 데이터 타입도 결국 펑터라는 사실로 이어질 수 있다는 것이다.</p>\n<p>파라미터화된 대수적 데이터 타입이라는 것이 무엇을 의미하는걸까? 먼저 <code class=\"language-text\">Maybe</code>의 <code class=\"language-text\">Nothing</code>이나 <code class=\"language-text\">List</code>의 <code class=\"language-text\">Nil</code>처럼 펑터의 타입 파라미터에 의존하지 않는 녀석들이 있으며, 이들은 <code class=\"language-text\">Const</code> 펑터와 동등하다. <code class=\"language-text\">Const</code> 펑터는 자신이 받는 타입 파라미터를 무시한다는 사실을 기억해보자. (정확히 말하면 첫 번째 타입 파라미터는 고정이며, 두 번째 파라미터를 무시하는 것이다.)</p>\n<p>또한 <code class=\"language-text\">Maybe</code>의 <code class=\"language-text\">Just</code>처럼 단순히 타입 파라미터 자체를 캡슐화하는 녀석들도 있다. 이들은 항등 펑터와 동등하다. 이전에 <em>Cat</em>에서의 항등 사상에 대한 이야기를 하면서 항등 펑터를 언급한 적이 있었지만, Haskell에서의 정의는 보여주지 않았었다. 이것이 바로 항등 펑터의 정의다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span>\n\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Identity</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Identity</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">Identity</code>는 항상 타입이 <code class=\"language-text\">a</code>인 하나의 불변 값만을 가지는 간단한 컨테이너라고 생각해볼 수 있다. 대수적 데이터 구조에서 이 개념을 제외한 나머지 것들은 모두 두 가지 원시적 요소를 합하거나 곱하여 생성된다.</p>\n<p>이 새로운 지식을 토대로 <code class=\"language-text\">Maybe</code> 타입 생성자를 다시 한번 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이건 결국 <code class=\"language-text\">Nothing</code>과 <code class=\"language-text\">Just</code> 두 타입의 합이며, 합은 펑터적이다. 첫 번째 부분인 <code class=\"language-text\">Nothing</code>은 <code class=\"language-text\">Const ()</code>가 <code class=\"language-text\">a</code>에 작용하는 것이라고 볼 수 있다. (여기서 <code class=\"language-text\">Const</code>의 첫 번째 타입 파라미터는 유닛으로 설정한다.) 그리고 두 번째 부분인 <code class=\"language-text\">Just</code>는 그저 항등 펑터의 다른 이름일 뿐이다. 그럼 이제 우리는 <code class=\"language-text\">Maybe</code>를 동형적으로 아래와 같이 다시 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>결국 <code class=\"language-text\">Maybe</code>는 이항 펑터 <code class=\"language-text\">Either</code>를 사용하여 <code class=\"language-text\">Const ()</code>, <code class=\"language-text\">Identify</code>라는 두 개의 펑터를 조합한 것이다. (실제로는 <code class=\"language-text\">Const</code> 또한 이항 펑터이지만, 여기서는 항상 부분적용된 상태로만 사용한다.)</p>\n<p>우리는 이미 펑터의 합성 또한 펑터라는 것을 알고 있으며, 이항 펑터 또한 이와 마찬가지로 동일한 원칙이 적용될 것이라는 점을 쉽게 예상해볼 수 있다. 한번 이항 펑터와 두 펑터의 합성이 사상에 어떤 식으로 작용하는지 알아보도록 하자. 먼저 두 개의 사상 중 하나를 한 펑터로 리프팅한 후, 다른 하나를 또 하나의 다른 펑터로 리프팅할 것이다. 그 다음 여기서 얻어진 두 사상의 쌍을 이항 펑터로 리프팅하는 순서로 진행하면 된다.</p>\n<p>이 과정을 Haskell로 한번 표현해보자. 이 데이터 타입의 매개변수는 다음과 같다. 두 개의 타입을 인자로 받는 타입 생성자를 의미하는 이항 펑터 <code class=\"language-text\">bf</code>, 각각 하나의 타입 변수를 받는 타입 생성자인 두 개의 펑터 <code class=\"language-text\">fu</code>와 <code class=\"language-text\">gu</code>와 두 개의 일반적인 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>이다. 이제 펑터 <code class=\"language-text\">fu</code>를 <code class=\"language-text\">a</code>에 적용하고, 펑터 <code class=\"language-text\">gu</code>는 <code class=\"language-text\">b</code>에 적용한 다음, 이 결과로 나온 타입 두 개에 이항 펑터 <code class=\"language-text\">bf</code>를 적용할 것이라는 것을 표현하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">bf</span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것은 객체 또는 타입에 대한 합성이다. Haskell에서는 타입 생성자를 타입에 적용하는 것이 마치 함수를 인수에 적용하는 것과 동일한 방식으로 이루어지며, 심지어 구문 또한 동일하다.</p>\n<p>조금 헷갈린다면, <code class=\"language-text\">BiComp</code>의 매개변수로 <code class=\"language-text\">Either</code>, <code class=\"language-text\">Const ()</code>, <code class=\"language-text\">Identity</code>, <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code>가 들어온다고 생각해보자. 결과적으로 <code class=\"language-text\">Maybe b</code>를 얻을 수 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>왜 <code class=\"language-text\">BiComp Either Const () Identity a b</code>가 <code class=\"language-text\">Maybe b</code>인지는 의사코드로 작성해보면 단번에 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">bf</span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token constant\">BiComp</span> <span class=\"token constant\">Either</span> <span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span>\n<span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span>\n</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</blockquote>\n<p>새로운 타입인 <code class=\"language-text\">Bicomp</code>는 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>에 대한 이항 펑터라고 할 수 있지만, 이 정의는 매개변수인 <code class=\"language-text\">bf</code>가 이항 펑터이고 <code class=\"language-text\">fu</code>와 <code class=\"language-text\">gu</code>가 펑터일 경우에만 성립할 수 있다. 즉, 컴파일러가 이 매개변수들을 추론했을때, <code class=\"language-text\">bf</code>에 대한 <code class=\"language-text\">bimap</code> 정의와 <code class=\"language-text\">fu</code> 및 <code class=\"language-text\">gu</code>에 대한 <code class=\"language-text\">fmap</code> 정의가 있다는 사실이 보장되어야 한다는 것이다.</p>\n<p>Haskell에서는 인스턴스 선언 시 클래스 제약 조건 집합 다음에 위치하는 이중 화살표(<code class=\"language-text\">=></code>)로 이러한 전제조건을 표현해줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Bifunctor</span> <span class=\"token hvariable\">bf</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Functor</span> <span class=\"token hvariable\">fu</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Functor</span> <span class=\"token hvariable\">gu</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token constant\">Bifunctor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">bf</span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">gu</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n        <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f1</span> <span class=\"token hvariable\">f2</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">bimap</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">BiComp</code>의 <code class=\"language-text\">bimap</code> 구현은 <code class=\"language-text\">bf</code>의 <code class=\"language-text\">bimap</code>과 <code class=\"language-text\">fu</code>, <code class=\"language-text\">gu</code>의 <code class=\"language-text\">fmap</code>을 사용하여 정의한다. 컴파일러는 <code class=\"language-text\">BiComp</code>가 사용될 때 이 타입들을 자동으로 추론하고 오버로드된 함수를 선택할 것이다.</p>\n<p>위의 <code class=\"language-text\">bimap</code> 정의에서 <code class=\"language-text\">x</code>의 타입은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것은 꽤나 복잡한 정의처럼 보인다. 외부 <code class=\"language-text\">bimap</code>은 외부 <code class=\"language-text\">bf</code> 레이어를 통과하며, 두 개의 <code class=\"language-text\">fmap</code>들은 각각 <code class=\"language-text\">fu</code>와 <code class=\"language-text\">gu</code> 아래로 파고들게 된다.</p>\n<p>만약 <code class=\"language-text\">f1</code>와 <code class=\"language-text\">f2</code>의 타입이 아래와 같은 상황이라고 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f1</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a'</span>\n<span class=\"token hvariable\">f2</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러면 최종 결과는 <code class=\"language-text\">bf (fu a') (gu b')</code> 타입이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">bimap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b'</span><span class=\"token punctuation\">)</span>\n  \t<span class=\"token operator\">-></span> <span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b'</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>만약 여러분이 직소 퍼즐을 좋아한다면, 이런 종류의 타입 조작에서 꽤나 큰 즐거움을 느낄 수 있을 것이다.</p>\n<p>결론적으로 <code class=\"language-text\">Maybe</code>는 두 펑터적인 요소의 합으로 구성되었기 때문에, 굳이 <code class=\"language-text\">Maybe</code>가 펑터라는 것을 증명하지 않아도 당연히 펑터라는 사실이 성립하는 것이다.</p>\n<p>만약 예리한 독자들은 대수적 데이터 타입에 대한 펑터 인스턴스의 유도가 이렇게 논리적으로 명확하게 정의될 수 있다면, 그냥 컴파일러에서 자동화해서 처리할 수는 없냐고 질문할 수도 있다.</p>\n<p>물론 가능하다. 이는 Haskell의 확장기능(Extensions)를 사용하면 되는데, 특정 확장기능을 사용하려면 소스 파일의 맨 위에 아래와 같은 라인을 추가하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token comment\">{-# LANGUAGE DeriveFunctor #-}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그 이후 데이터 구조에 <code class=\"language-text\">deriving Functor</code>를 추가하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span> <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Functor</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이처럼 <code class=\"language-text\">DeriveFunctor</code> 확장 기능을 사용하면 특정 데이터 구조에 대한 <code class=\"language-text\">fmap</code>이 자동으로 구현되도록 할 수 있다.</p>\n<p>이런 기능이 제공될 수 있는 이유는 대수적 데이터 구조의 규칙성으로 인해 <code class=\"language-text\">Functor</code>뿐 아니라 앞서 언급했던 <code class=\"language-text\">Eq</code>와 같은 여러 다른 타입 클래스 인스턴스를 논리적으로 유도하는 것이 가능하기 때문이다.</p>\n<p>이와 더불어 컴퍼일러에게 사용자 정의 타입 클래스의 인스턴스를 유도하는 것도 가능하지만 이것은 조금 더 고급 기능이다. 하지만 결국 사용자 정의 타입 클래스라고 해도 기본적인 구성 요소, 그리고 합과 곱의 동작을 제공하는 것 뿐이므로 근본적인 원리는 동일하다.</p>\n<h2 id=\"84-c에서의-펑터functors-in-c\" style=\"position:relative;\">8.4 C++에서의 펑터(Functors in C++)<a href=\"#84-c%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0functors-in-c\" aria-label=\"84 c에서의 펑터functors in c permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>만약 여러분이 C++ 프로그래머라면 펑터를 처음부터 끝까지 오롯이 혼자서 구현해야할 것이다. 그러나 이를 위해서는 C++이 가진 대수적 데이터 구조의 몇 가지 타입을 이해할 수 있어야하며, 이런 데이터 구조를 일반적인 템플릿으로 구현하고 이 구조에 대한 <code class=\"language-text\">fmap</code> 또한 직접 구현할 수 있어야한다.</p>\n<p>먼저 Haskell에서 재귀적인 합 타입으로 정의된 트리 데이터 구조를 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Tree</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Leaf</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Node</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Tree</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Tree</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Functor</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>앞서 언급한 대로, C++에서 합 타입을 구현하는 방법 중 하나는 바로 클래스 계층 구조를 이용하는 것이다. 객체지향 언어에서는 기본 클래스 <code class=\"language-text\">Functor</code>의 가상 함수(Virtual functions)로 <code class=\"language-text\">fmap</code>을 구현한 뒤 모든 하위 클래스에서 이를 재정의하는 방향이 자연스러울 것이다.</p>\n<p>하지만 아쉽게도 이런 방법을 사용하는 것은 불가능하다. 왜냐하면 결국 <code class=\"language-text\">fmap</code>은 템플릿이며, 이는 <code class=\"language-text\">this</code> 포인터로 전달되는 객체의 타입 뿐 아니라 적용된 함수의 반환 타입이 매개변수화되어야 한다는 것을 의미한다. 하지만 C++에서는 가상 함수를 템플릿화 할 수 없다. 대신 우리는 <code class=\"language-text\">dynamic_cast</code>를 사용하여 패턴 매칭을 대체하고 <code class=\"language-text\">fmap</code>을 일반적인 자유 함수로 구현할 것이다.</p>\n<p>기본 클래스는 동적 캐스팅을 지원하기 위해 최소 하나의 가상 함수를 정의해야하며, 이 경우 우리는 소멸자(Destructor)를 가상 함수로 정의할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Tree</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">virtual</span> <span class=\"token operator\">~</span><span class=\"token function\">Tree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>숨겨진 <code class=\"language-text\">Identity</code> 펑터인 <code class=\"language-text\">Leaf</code>를 정의하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Leaf</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Tree</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n    T _label<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Leaf</span><span class=\"token punctuation\">(</span>T l<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_label</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">Node</code>는 곱 타입으로 정의할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Tree</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n    Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> _left<span class=\"token punctuation\">;</span>\n    Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> _right<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> l<span class=\"token punctuation\">,</span> Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_left</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">_right</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">fmap</code>을 구현할 때는 <code class=\"language-text\">Tree</code>의 타입에 따른 동적 디스패치를 활용할 것이다. <code class=\"language-text\">Leaf</code>의 경우에는 <code class=\"language-text\">Identify</code> 버전의 <code class=\"language-text\">fmap</code>을 적용하고, <code class=\"language-text\">Node</code>의 경우에는 두 개의 <code class=\"language-text\">Tree</code> 펑터의 복사본과 결합된 이항 펑터처럼 처리할 것이다. 물론 C++ 프로그래머들은 이런 사고 방식과 용어로 코드를 분석하는 것에 익숙하지 않을 수 있지만, 이 모든 과정이 결국 카테고리론적 사고를 연습하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nTree<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token operator\">*</span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> Tree<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Leaf<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> pl <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">dynamic_cast</span> <span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Leaf<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token operator\">*</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pl<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token generic-function\"><span class=\"token function\">Leaf</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span> <span class=\"token punctuation\">(</span>pl<span class=\"token operator\">-></span>_label<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> pn <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">dynamic_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Node<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token operator\">*</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pn<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token generic-function\"><span class=\"token function\">Node</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> pn<span class=\"token operator\">-></span>_left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> pn<span class=\"token operator\">-></span>_right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서는 간결함을 위해 메모리나 리소스 관리 문제를 무시하고 있지만, 실제 코드에서는 정책에 따라 <code class=\"language-text\">unique</code>나 <code class=\"language-text\">shared</code> 같은 스마트 포인트를 사용할 것이다.</p>\n<p>이렇게 C++로 작성한 <code class=\"language-text\">Tree</code>의 <code class=\"language-text\">fmap</code>을 Haskell에서 작성한 버전으로 바꿔보자면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Tree</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Leaf</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Leaf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Node</span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">t'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Node</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t'</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그리고 이 역시 <code class=\"language-text\">DeriveFunctor</code> 확장 기능을 사용하면 컴파일러에 의해 자동으로 구현될 수 있다.</p>\n<h2 id=\"85-writer-펑터\" style=\"position:relative;\">8.5 Writer 펑터<a href=\"#85-writer-%ED%8E%91%ED%84%B0\" aria-label=\"85 writer 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이전에 설명했던 <a href=\"/2024/02/20/category-theory-for-programmers-4-kleisli-category\">크라이슬리 카테고리(Kleisli Category)</a> 섹션에서 <code class=\"language-text\">Writer</code> 펑터에 대해서 다시 설명하겠다고 했던 것을 기억하는가? 해당 카테고리에서의 사상들은 꾸며진(embellished) 함수로 표현되어 <code class=\"language-text\">Writer</code> 데이터 구조를 반환했었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>필자는 이렇게 꾸며진 기능이 어떤 방식으로든 엔도 펑터와 관련이 있다고 말했다. 그리고 실제로 <code class=\"language-text\">Writer</code> 타입 생성자는 <code class=\"language-text\">a</code>에 대해 펑터적이다. 심지어 이를 위해 <code class=\"language-text\">fmap</code>을 구현할 필요도 없다. 왜냐하면 반환된 타입은 단순한 곱 타입이기 떄문이다.</p>\n<p>일반적으로 크라이슬리 카테고리와 펑터 간의 관계는 다음과 같다. 크라이슬리 카테고리는 카테고리이기 때문에 합성과 항등성을 정의해야한다. 그리고 합성은 fish(<code class=\"language-text\">>=></code>) 연산자에 의해 제공된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">>=></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">m1</span> <span class=\"token operator\">>=></span> <span class=\"token hvariable\">m2</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m1</span> <span class=\"token hvariable\">x</span>\n        <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m2</span> <span class=\"token hvariable\">y</span>\n    <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 항등 사상은 <code class=\"language-text\">return</code>이라고 불리는 함수를 통해 제공했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">return</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span> <span class=\"token builtin\">return</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 이 두 함수들의 타입을 오랜 시간 들여다 보다보면, <code class=\"language-text\">fmap</code>으로 사용할 수 있는 올바른 타입의 함수를 생성하는 방법을 찾을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">id</span> <span class=\"token operator\">>=></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token builtin\">return</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 예시에서 fish 연산자는 우리에게 익숙한 <code class=\"language-text\">id</code>, 그리고 인수에 <code class=\"language-text\">f</code>를 적용한 결과에 다시 <code class=\"language-text\">return</code>을 적용한 람다, 두 함수를 합성한다.</p>\n<p>아마 여기서 가장 이해하기 어려운 부분은 <code class=\"language-text\">id</code>의 사용법일 것이다. fish 연산자의 인수는 <code class=\"language-text\">Int</code>, <code class=\"language-text\">Bool</code>과 같은 일반 타입을 가져와서 꾸며진(embellished) 타입을 반환하는 함수여야 한다고 생각할 수 있겠지만 사실은 아니다. 아무도 <code class=\"language-text\">a -> Writer b</code>에서의 <code class=\"language-text\">a</code>가 일반 타입이어야 한다고 한 적은 없다. 이것은 그저 타입 변수일뿐이므로 어떤 것이든 될 수 있으며, 심지어 <code class=\"language-text\">Writer b</code>와 같이 이미 꾸며진 타입이 될 수도 있다.</p>\n<p>그래서 <code class=\"language-text\">id</code>는 <code class=\"language-text\">Writer a</code>를 받아서 그대로 <code class=\"language-text\">Writer a</code>를 반환할 것이다. fish 연산자는 <code class=\"language-text\">a</code>의 값을 꺼내어 람다의 <code class=\"language-text\">x</code> 인자로 전달할 것이다. 이후 <code class=\"language-text\">f</code>는 그것을 <code class=\"language-text\">b</code>로 변환하고, <code class=\"language-text\">return</code>은 이 결과를 꾸며 최종적으로 <code class=\"language-text\">Writer b</code>로 만들 것이다. 이 모든 것을 조합한다면 우리는 <code class=\"language-text\">Writer a</code>를 가져와 <code class=\"language-text\">Writer b</code>를 반환하는 함수를 얻게된다. 즉, <code class=\"language-text\">Writer</code>의 <code class=\"language-text\">fmap</code>이 해야하는 것과 정확히 같은 일을 하는 것이다.</p>\n<p>이 정의에서 <code class=\"language-text\">Writer</code>는 다른 임의의 타입 생성자로 변경될 수 있기 때문에 이 인자는 매우 일반적이라고 할 수 있다. 뭐가 되었던 fish 연산자와 <code class=\"language-text\">return</code>을 지원한다면 이를 활용하여 <code class=\"language-text\">fmap</code>을 정의할 수 있다는 것이다. 따라서 크라이슬리 카테고리에서의 장식(embellishment)은 항상 펑터라고 할 수 있다.</p>\n<p>사실 우리가 방금 정의했던 <code class=\"language-text\">fmap</code>과 <strong><code class=\"language-text\">deriving Functor</code></strong> 확장 기능을 통해 컴파일러가 생성해주는 <code class=\"language-text\">fmap</code>은 동일하다. 이는 Haskell이 다형성 함수를 구현하는 방식 때문인데, 이를 매개변수 다형성(Parametric polymorphism)이라고 하며, 공짜 정리(Theorems for free)라고 불리는 정리의 원천이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>매개변수 다형성(Parametric polymorphism)은 함수나 데이터 유형이 여러 타입에 대해 동작할 수 있도록 하는 기능이며, 타입스크립트의 Generic Type도 매개변수 다형성의 구현 중 하나이다.</p>\n<p>공짜 정리(Theorems for free)는 어떤 하나의 정리를 통해 다른 정리가 추가적인 증명없이도 자동으로 성립하는 것을 의미하므로, 매개변수 다형성 또한 공짜 정리의 한 측면이라고 볼 수 있는 것이다. 타입스크립트로 예를 들자면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">nonEmptyArray</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>arr<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">nonEmptyArray</code> 함수는 인자가 <code class=\"language-text\">number[]</code> 타입이든 <code class=\"language-text\">string[]</code> 타입이든 상관없이 일관된 동작을 제공한다. 즉, 다형적인 동작이 제대로 정의되었다면, <code class=\"language-text\">number[]</code> 타입에 대해 제대로 작동한다는 사실이 증명됨과 함께 <code class=\"language-text\">string[]</code> 타입에 대한 동작이 제대로 작동한다는 보장도 함께 공짜로 성립되는 것이다.</p>\n</blockquote>\n<p>이러한 정리가 의미하는 것 중 하나는 특정 타입 생성자에 대한 <code class=\"language-text\">fmap</code>이 존재하고 이 함수가 항등성을 보존하고 있다면, 그 구현 방법은 유일해야 한다는 것이다.</p>\n<h2 id=\"86-공변적-펑터와-반공변적-펑터covariant-and-contravariant-functors\" style=\"position:relative;\">8.6 공변적 펑터와 반공변적 펑터(Covariant and Contravariant Functors)<a href=\"#86-%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0%EC%99%80-%EB%B0%98%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0covariant-and-contravariant-functors\" aria-label=\"86 공변적 펑터와 반공변적 펑터covariant and contravariant functors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">Writer</code> 펑터에 대해서 살펴보았으니, <code class=\"language-text\">Reader</code> 펑터도 다시 한번 살펴보자. 다시 한번 이야기하지만 <code class=\"language-text\">Reader</code> 펑터는 부분적용된 함수 화살표 타입 생성자를 기반으로 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">r</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 정의를 타입 동의어를 사용하여 다시 작성해보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Reader</span> <span class=\"token hvariable\">r</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">r</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 <code class=\"language-text\">Reader</code>의 <code class=\"language-text\">Functor</code> 인스턴스는 아래와 같이 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">g</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>쌍 타입 생성자나 <code class=\"language-text\">Either</code> 타입 생성자와 마찬가지로 함수 타입 생성자 또한 두 개의 타입 인자를 받는다. 기억을 되짚어보면 쌍과 <code class=\"language-text\">Either</code>는 자신들이 받는 각각의 인자에 대해 펑터적이었고, 이를 이항 펑터(bifunctor)라고 한다고 했다. 그렇다면 함수 생성자도 두 개의 타입 인자를 받고 있으니 이들과 동일하게 이항 펑터일까?</p>\n<p>백문이불여일견이니 직접 확인해보자. 우선 첫 번째 인자에 대해 펑터적인지 확인해보겠다. 우선 타입 동의어에서부터 시작해볼 것이다. 아래 정의는 <code class=\"language-text\">Reader</code>에서 단지 인수의 순서만 뒤바뀐 형태이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Op</span> <span class=\"token hvariable\">r</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 반환 타입인 <code class=\"language-text\">r</code>을 고정하고 인수 타입인 <code class=\"language-text\">a</code>에 변형을 가할 것이다. 그리고 <code class=\"language-text\">a</code>를 변형하는 <code class=\"language-text\">fmap</code>을 구현하기 위한 타입 시그니처는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>인수로 <code class=\"language-text\">a</code>를 받고 각각 <code class=\"language-text\">b</code>와 <code class=\"language-text\">r</code>을 반환하는 두 개의 함수만 있는 경우, 이들을 사용하여 <code class=\"language-text\">b</code>를 받아 <code class=\"language-text\">r</code>을 반환하는 함수를 만들 수 있는 방법은 존재하지 않는다.</p>\n<p>하지만 첫 번째 함수를 반대로 뒤집을 수 있다면 상황은 달라진다. 즉, 첫 번째 함수가 <code class=\"language-text\">b</code>를 받아 <code class=\"language-text\">a</code>를 반환하는 함수가 되도록 만들어주면 되는 것이다. 우리는 임의의 함수를 막 뒤집을 수는 없지만, 반대 카테고리로 이동해볼 수는 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>필자가 <code class=\"language-text\">Reader</code>에 대한 설명을 하다가 갑자기 반대 카테고리에 대한 이야기를 하고 있어서 설명의 흐름이 어색하다. 결과적으로 말하자면 <code class=\"language-text\">Reader r a</code>는 두 인자를 받아 <code class=\"language-text\">r</code>을 <code class=\"language-text\">a</code>로 변형하는 매핑을 의미하기 때문에 이항 펑터가 아니다.</p>\n<p>앞서 보았던 쌍이나 <code class=\"language-text\">Either</code>의 경우 자신들이 받는 인수의 순서를 변경하더라도 연산의 결과는 동일하게 보장된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 패턴 매칭을 통해 연산을 적용하기 때문에</span>\n<span class=\"token comment\">-- 인자의 순서가 g f (x, y)가 되어도 f는 x에, g는 y에 적용된다.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그러나 <code class=\"language-text\">Reader</code> 펑터의 <code class=\"language-text\">fmap</code>은 함수의 합성이기 때문에 첫 번째 인자의 결과가 두 번째 인자에 의존하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n\t  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">g</span>\n<span class=\"token comment\">-- 만약 합성의 순서가 g . f가 된다면 연산 결과가 달라지거나</span>\n<span class=\"token comment\">-- 혹은 합성 자체가 불가능한 상황이 발생할 수도 있다.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>필자는 이러한 <code class=\"language-text\">Reader</code> 펑터의 특성을 보이기 위해, 인수의 순서를 반대로 뒤집은 <code class=\"language-text\">Op</code>라는 타입을 예로 들어 설명하고 있는 것이다.</p>\n</blockquote>\n<p>반대 카테고리가 기억나지 않을 수 있으니 간단하게 복습해보자. 모든 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에 대한 반대 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 같은 대상들을 가지고 있지만 모든 화살표(사상)의 방향이 반대로 뒤집어진 카테고리이다.</p>\n<p>그럼 이제 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>와 다른 임의의 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 사이를 이동하는 펑터를 떠올려보자.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo>:</mo><mo>:</mo><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">F::C^{op} → D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span></div>\n<p>이런 펑터는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>의 어떤 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f^{op} :: a → b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">F f^{op} :: F a → F b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>로 매핑한다. 그러나 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">f^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>는 원래 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서의 어떤 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mo>:</mo><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">f :: b → a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>에 해당한다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>가 서로 반전되어있음에 주목하자.</p>\n<p>이렇게 반대 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>에서 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 나아가는 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>를 정의했다. 그렇다면 이제 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>를 사용하여 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 바로 나아가는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>라는 매핑도 생각해볼 수 있다. 즉, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로의 매핑이다. 하지만 사실 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>는 펑터가 아니다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 마찬가지로 대상들을 동일하게 매핑하지만, 사상을 매핑할 때는 반대로 뒤집어서 매핑하기 때문이다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mo>:</mo><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">f :: b → a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>를 반대 사상인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f^{op} :: a → b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>로 매핑한 다음, 이를 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에 적용하여 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">F f^{op} :: F a→F b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 얻어야 한다.</p>\n<p>주어진 조건에 따라 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">Fa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">Ga</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 동일하고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">Fb</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">Gb</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">b</span></span></span></span></span>와 동일하다고 가정할 때, 전체적인 흐름은 아래와 같이 나타내볼 수 있다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>G</mi><mi>f</mi><mo>:</mo><mo>:</mo><mo stretchy=\"false\">(</mo><mi>b</mi><mo>→</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><mi>G</mi><mi>a</mi><mo>→</mo><mi>G</mi><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G f :: (b → a) → (G a → G b) \t\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span></div>\n<p>이렇게 사상의 방향을 반전하는 카테고리 간의 매핑을 반공변적 펑터(Contravariant Functor)라고 한다. 반공변적 펑터는 반대 카테고리에서의 일반적인 펑터일 뿐이다. 그리고 우리가 지금까지 공부해왔던 일반적인 펑터는 공변적 펑터(Covariant Functor)라고 한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 530px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2675b6c5c6369f38ae301b55685cd3b0/d0861/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 98.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAQEAAwAAAAAAAAAAAAAAAAIBAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQD/2gAMAwEAAhADEAAAAfTrYbuIFOA8oT//xAAbEAACAwADAAAAAAAAAAAAAAABAgADEhEhMv/aAAgBAQABBQKx3BqZiY/OjrKeGUGFBkdD/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQESEx/9oACAEBAAY/AqQ75GMeiLn/xAAbEAACAgMBAAAAAAAAAAAAAAAAARFBITFREP/aAAgBAQABPyGplMqy742MHZDRa3g7JxslGmR9l0SBKj//2gAMAwEAAgADAAAAEMMIvP/EABYRAAMAAAAAAAAAAAAAAAAAABARQf/aAAgBAwEBPxBxCD//xAAWEQADAAAAAAAAAAAAAAAAAAARICH/2gAIAQIBAT8QgT//xAAcEAEBAQEAAgMAAAAAAAAAAAABESEAUWEQMZH/2gAIAQEAAT8QZnGXyeeLLQNEV9evjYwTJsXzxm5dOP3lb5xq3ldAT75DDobmcddABe//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/2675b6c5c6369f38ae301b55685cd3b0/d0861/5.jpg\" srcset=\"/static/2675b6c5c6369f38ae301b55685cd3b0/0913d/5.jpg 160w,\n/static/2675b6c5c6369f38ae301b55685cd3b0/cb69c/5.jpg 320w,\n/static/2675b6c5c6369f38ae301b55685cd3b0/d0861/5.jpg 530w\" sizes=\"(max-width: 530px) 100vw, 530px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>아래는 Haskell에서 반공변적인 (엔도)펑터를 정의하는 타입 클래스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Contravariant</span> <span class=\"token hvariable\">f</span> <span class=\"token keyword\">where</span>\n  \t<span class=\"token hvariable\">contramap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, 아까 정의했던 타입 생성자 <code class=\"language-text\">Op</code>의 인스턴스는 아래와 같이 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Contravariant</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n  \t<span class=\"token comment\">-- (b -> a) -> Op r a -> Op r b</span>\n  \t<span class=\"token hvariable\">contramap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>함수 <code class=\"language-text\">f</code>가 <code class=\"language-text\">Op</code>의 내용인 함수 <code class=\"language-text\">g</code>의 앞에 자신을 삽입한다는 것에 주목하자. (함수 합성의 연산 순서는 오른쪽에서 왼쪽이다.)</p>\n<p>여기서 <code class=\"language-text\">Op</code>의 <code class=\"language-text\">contramap</code>의 정의는 단지 인자를 뒤집은 함수 합성 연산자일 뿐이라는 것을 알 수 있으며, 이 사실을 알았다면 이제 더 간결하게 만들어 볼 수도 있다.</p>\n<p>여기 인자를 뒤집는데 사용되는 특수한 함수인 <code class=\"language-text\">flip</code>이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">flip</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">flip</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">y</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러면 이제 <code class=\"language-text\">contramap</code>의 정의를 이렇게 간단하게 바꿔볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">contramap</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">flip</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2 id=\"87-프로펑터profunctors\" style=\"position:relative;\">8.7 프로펑터(Profunctors)<a href=\"#87-%ED%94%84%EB%A1%9C%ED%8E%91%ED%84%B0profunctors\" aria-label=\"87 프로펑터profunctors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리는 함수 화살표 연산자가 첫 번째 인자에서 반공변 변형이 되고, 두 번째 인자에서 공변 변형이 되는 상황을 보았다. 이런 개념에 대한 명칭도 있을까?</p>\n<p>만약 대상 카테고리가 <em>Set</em>이라면 이 개념을 프로펑터(Profunctor)라고 부른다. 반공변적 펑터는 반대 카테고리에서의 공변적 펑터와 동일하기 때문에, 프로펑터는 아래와 같이 정의된다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>×</mo><mi>D</mi><mo>→</mo><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">C^{op} × D → Set \t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7977em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span></span></span></span></span></div>\n<p>일단 Haskell 타입을 집합이라고 가정해보면, 우리는 첫 번째 인자에 대해 반공변적 펑터적이고 두 번째 인자에 대해서는 펑터적인 두 개의 인자를 받는 타입 생성자 <code class=\"language-text\">p</code>에 <code class=\"language-text\">Profuctor</code>라는 이름을 부여할 수 있다. 아래는 <code class=\"language-text\">Data.Profuctor</code> 라이브러리에서 가져온 타입 클래스의 모습이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Profunctor</span> <span class=\"token hvariable\">p</span> <span class=\"token keyword\">where</span>\n  \t<span class=\"token hvariable\">dimap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">d</span>\n  \t<span class=\"token hvariable\">dimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">lmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">rmap</span> <span class=\"token hvariable\">g</span>\n  \t<span class=\"token hvariable\">lmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">c</span>\n  \t<span class=\"token hvariable\">lmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">dimap</span> <span class=\"token hvariable\">f</span> <span class=\"token builtin\">id</span>\n  \t<span class=\"token hvariable\">rmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">c</span>\n    <span class=\"token hvariable\">rmap</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">dimap</span> <span class=\"token builtin\">id</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>세 함수 모두 기본 구현이 제공된다. <code class=\"language-text\">Bifunctor</code>와 마찬가지로 <code class=\"language-text\">Profuctor</code>의 인스턴스를 선언할 때는 <code class=\"language-text\">dimap</code>을 구현하고 <code class=\"language-text\">lmap</code>과 <code class=\"language-text\">rmap</code>에 대한 기본값을 사용하거나, 혹은 <code class=\"language-text\">lmap</code>과 <code class=\"language-text\">rmap</code>을 모두 구현하고 <code class=\"language-text\">dimap</code>에 대한 기본값을 사용할 수 있는 선택권이 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 497px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8c3e7c302a315abaa1d56875acd0c0f8/fce5f/6.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 81.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHXTVAto0T/xAAaEAEAAgMBAAAAAAAAAAAAAAABAAIDERIx/9oACAEBAAEFAu0u5LTHvlqQGHn/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwEJ/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAwADAAAAAAAAAAAAAAAAABARITJB/9oACAEBAAY/ApxZLKaL/8QAGxABAAICAwAAAAAAAAAAAAAAAQARITFRgZH/2gAIAQEAAT8hdKZU4rp1PYl1dnEKtMzBQxU//9oADAMBAAIAAwAAABAbz//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/EGZ//8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/ENCf/8QAHBABAAMBAQADAAAAAAAAAAAAAQARITFRQWFx/9oACAEBAAE/EEiAW29I9Djvo5+zSoVenzHWlK+2QAU1W3V3WQhFAc8n/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"\" src=\"/static/8c3e7c302a315abaa1d56875acd0c0f8/fce5f/6.jpg\" srcset=\"/static/8c3e7c302a315abaa1d56875acd0c0f8/0913d/6.jpg 160w,\n/static/8c3e7c302a315abaa1d56875acd0c0f8/cb69c/6.jpg 320w,\n/static/8c3e7c302a315abaa1d56875acd0c0f8/fce5f/6.jpg 497w\" sizes=\"(max-width: 497px) 100vw, 497px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>여기까지 왔으면 이제 함수 화살표 연산자가 <code class=\"language-text\">Profuctor</code>의 인스턴스라는 것을 단언할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Profunctor</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">dimap</span> <span class=\"token hvariable\">ab</span> <span class=\"token hvariable\">cd</span> <span class=\"token hvariable\">bc</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">cd</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">bc</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">ab</span>\n    <span class=\"token hvariable\">lmap</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">flip</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n    <span class=\"token hvariable\">rmap</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>프로펑터는 Haskell 렌즈 라이브러리에서 응용되고 있으며, 추후 ends와 coends에 대해 이야기할 때 다시 한번 자세히 설명할 것이다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240402-category-theory-for-programmers-8-functoriality","path":"/2024/04/02/category-theory-for-programmers-8-functoriality/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 8. 펑터의 특성","date":"2024-04-02","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}},"allMarkdownRemark":{"edges":[]}},"pageContext":{"slug":"20240402-category-theory-for-programmers-8-functoriality","previous":{"fields":{"slug":"20240315-category-theory-for-programmers-7-functors","path":"/2024/03/15/category-theory-for-programmers-7-functors/","lang":"ko","postGroup":"20240315-category-theory-for-programmers-7-functors"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 7. 펑터"}},"next":{"fields":{"slug":"20240418-category-theory-for-programmers-9-function-types","path":"/2024/04/18/category-theory-for-programmers-9-function-types/","lang":"ko","postGroup":"20240418-category-theory-for-programmers-9-function-types"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 9. 함수 타입"}},"lang":"ko","postGroup":"20240402-category-theory-for-programmers-8-functoriality"}},"staticQueryHashes":["3129619726","3523904809","376081736","650499039"],"slicesMap":{}}