{"componentChunkName":"component---src-templates-post-page-template-index-tsx","path":"/2020/07/24/about-regular-expression/en/","result":{"data":{"markdownRemark":{"id":"5378ff90-1b70-5262-9faf-4d5f6558180f","tableOfContents":"<ul>\n<li>\n<p><a href=\"#what-even-is-regex\">What Even Is Regex?</a></p>\n</li>\n<li>\n<p><a href=\"#basic-regex-features\">Basic Regex Features</a></p>\n<ul>\n<li><a href=\"#character-classes-catching-groups-of-characters\">Character Classes: Catching Groups of Characters</a></li>\n<li><a href=\"#anchors-catching-boundaries-not-characters\">Anchors: Catching Boundaries, Not Characters</a></li>\n<li><a href=\"#flags-regex-options\">Flags: Regex Options</a></li>\n<li><a href=\"#quantifiers-how-many-times-a-pattern-appears\">Quantifiers: How Many Times a Pattern Appears</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#nice-to-know-advanced-features\">Nice-to-Know Advanced Features</a></p>\n<ul>\n<li><a href=\"#capturing-remembering-patterns\">Capturing: Remembering Patterns</a></li>\n<li><a href=\"#greedy-vs-lazy\">Greedy vs. Lazy</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#wrapping-up\">Wrapping Up</a></p>\n</li>\n</ul>","excerpt":"Developers are people who analyze problems described in natural language, then design and write programs to solve them. This work often involves filtering out the useful bits from a flood of unstructured information, or abstracting haphazardly declared classes and variables into clean structures.","html":"<p>Developers are people who analyze problems described in natural language, then design and write programs to solve them. This work often involves filtering out the useful bits from a flood of unstructured information, or abstracting haphazardly declared classes and variables into clean structures.</p>\n<!-- more -->\n<p>Many skills contribute to doing this well, but one especially important one is the ability to find regularity — patterns — within seemingly irregular information.</p>\n<p>Among the most common problems in everyday business contexts are things like parsing files or validating user input: extracting desired information by finding patterns in irregular strings. But the sheer number of edge cases means that trying to solve these with plain programming alone can leave you drowning in a spectacular nest of <code class=\"language-text\">if</code> statements.</p>\n<p>This is exactly the kind of problem that regular expressions — regex — make easy to solve.</p>\n<h2 id=\"what-even-is-regex\" style=\"position:relative;\">What Even Is Regex?<a href=\"#what-even-is-regex\" aria-label=\"what even is regex permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>The full name is “regular expression,” but in practice it goes by regex, regexp, or various affectionate nicknames in different developer communities.</p>\n<p>Regex is a type of expression that can represent patterns, and by applying these expressions to strings, you can pluck out exactly the parts you want — an incredibly convenient tool. But thanks to its notoriously hostile readability, regex tends to be met with a certain… reluctance.</p>\n<p>I use regex fairly often myself, but unless it’s a pattern I write frequently, I always Google the expression and verify it on <a href=\"https://regexr.com/\" target=\"_blank\" rel=\"nofollow\">RegExr</a> before using it.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cf1e76c74723af6eb45ee626ca4269a9/e5166/regex_meme.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB32UTM6UU0wG1Av/EABoQAQEBAQADAAAAAAAAAAAAAAECAxEAEiH/2gAIAQEAAQUCvXlNEnfLZ96iED5pAumJZJw//8QAFREBAQAAAAAAAAAAAAAAAAAAEAH/2gAIAQMBAT8BIf/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABsQAAICAwEAAAAAAAAAAAAAAAERABACITFB/9oACAEBAAY/Al5GclSLm+WiShX/xAAcEAEAAgMBAQEAAAAAAAAAAAABABEhMUFRgaH/2gAIAQEAAT8hW+aewNVPZdBHDLg9NkzifghA79iJfIG5pUpS2jE//9oADAMBAAIAAwAAABBsPwP/xAAaEQEAAQUAAAAAAAAAAAAAAAABEBEhQWHB/9oACAEDAQE/EBat4OdvI//EABcRAQEBAQAAAAAAAAAAAAAAAAABMUH/2gAIAQIBAT8Qmq6r/8QAGxABAAMBAQEBAAAAAAAAAAAAAQARIUExUYH/2gAIAQEAAT8QaOoLcX3IcLIJ/YXBgInSPUmgph2AgAcL0SHQoDG3nJZzdCys2e0w2Fr9chA0ILrwJ//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"regex meme\" title=\"\" src=\"/static/cf1e76c74723af6eb45ee626ca4269a9/c08c5/regex_meme.jpg\" srcset=\"/static/cf1e76c74723af6eb45ee626ca4269a9/0913d/regex_meme.jpg 160w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/cb69c/regex_meme.jpg 320w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/c08c5/regex_meme.jpg 640w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/6a068/regex_meme.jpg 960w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/e5166/regex_meme.jpg 1200w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Memes like this exist because regex genuinely looks like gibberish at first glance</small>\n</center>\n<p>But since regex’s primary use case is finding patterns in strings — a situation developers encounter constantly — you’ll inevitably cross paths with regex sooner or later. There’s no escaping it. <del>(Just accept your fate and it gets easier.)</del></p>\n<p>Of course, staring at regex cold makes you think “what on earth does this mean?” But even the longest regular expression is just small expressions combined together, so when you break them apart, they’re often simpler than you’d expect.</p>\n<h2 id=\"basic-regex-features\" style=\"position:relative;\">Basic Regex Features<a href=\"#basic-regex-features\" aria-label=\"basic regex features permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Regex has a wide variety of keywords, and the entirety of using regex comes down to combining these keywords to build expressions that capture the patterns you want. In other words, the most fundamental way to get started with regex is to memorize these keywords.</p>\n<p>You don’t need to know every keyword — just searching “regex” on Google yields an avalanche of references. But memorizing at least the basics means you can solve simple pattern matching problems without consulting Google, which is a win for productivity. <del>(Memorizing all of them is impossible anyway.)</del></p>\n<p>Combining these features appropriately for each situation is what determines how well you use regex. So in this post, I’ll give a quick taste of the features regex provides, and in the next post, I’ll go deeper with practical, real-world examples.</p>\n<h3 id=\"character-classes-catching-groups-of-characters\" style=\"position:relative;\">Character Classes: Catching Groups of Characters<a href=\"#character-classes-catching-groups-of-characters\" aria-label=\"character classes catching groups of characters permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Regex has various keywords that represent specific characters or groups of characters. These are called “character classes.”</p>\n<p>Since the core function of regex is finding the characters you want, knowing the types and roles of character classes lets you roughly decipher simple regex patterns without Googling.</p>\n<h4 id=\"lets-start-by-finding-specific-characters\" style=\"position:relative;\">Let’s Start by Finding Specific Characters<a href=\"#lets-start-by-finding-specific-characters\" aria-label=\"lets start by finding specific characters permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Regex is packed with character classes like <code class=\"language-text\">\\d</code> and <code class=\"language-text\">\\w</code> whose meanings aren’t obvious at a glance. But these cryptic keywords aren’t the only option. For example, to extract a specific word from a long sentence, you can just write:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'hello, world'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">hello</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"hello, world\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Since regular characters work freely in regex, keywords like <code class=\"language-text\">\\w</code> and <code class=\"language-text\">\\s</code> that represent character groups must be escaped with <code class=\"language-text\">\\</code> in front. In other words, <code class=\"language-text\">\\s</code> is a keyword, but <code class=\"language-text\">s</code> is just the letter s.</p>\n<p>Because of this escaping, people unfamiliar with regex often get confused about whether something is <code class=\"language-text\">s</code> or the whitespace keyword <code class=\"language-text\">\\s</code>. There’s no magic tip here — when you see something like <code class=\"language-text\">/\\/s\\.s.{1,2}/</code>, just read it by slicing from left to right, one token at a time.</p>\n<p>Using specific characters like <code class=\"language-text\">hello</code> in a regex can find exact patterns in strings, but if all you need is to find a specific string, you don’t need regex at all — <code class=\"language-text\">String.prototype</code> methods like <code class=\"language-text\">includes</code>, <code class=\"language-text\">indexOf</code>, or <code class=\"language-text\">search</code> with a plain string argument work just fine.</p>\n<p>The real power of regex lies not in finding specific strings, but in finding <em>groups</em> of strings matching a pattern.</p>\n<h4 id=\"lets-build-custom-character-groups\" style=\"position:relative;\">Let’s Build Custom Character Groups<a href=\"#lets-build-custom-character-groups\" aria-label=\"lets build custom character groups permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Imagine you need to validate that user input contains only English letters. English has 48 characters counting both upper and lowercase, so you could build a map or array of the alphabet and check each character, or in the worst case, chain 48 conditions with <code class=\"language-text\">||</code>. <del>(49 including exception handling…)</del></p>\n<p>We can all agree that’s not the coolest approach. And as conditions pile up — checking for numbers too, or verifying that letters repeat n times — the code just keeps getting more complex.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> alphabet <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'B'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'C'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'d'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Z'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">isAlphabet</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token builtin\">string</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">every</span><span class=\"token punctuation\">(</span>char <span class=\"token operator\">=></span> alphabet<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<center>\n  <small>For simple English-only validation, you could handle it like this</small>\n  <br />\n  <br />\n</center>\n<p>So regex also lets you create custom groups to catch the characters you want. The syntax is simple: just put the characters you want to group inside square brackets (<code class=\"language-text\">[]</code>).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Match x or y or z!</span>\n<span class=\"token operator\">/</span><span class=\"token punctuation\">[</span>xyz<span class=\"token punctuation\">]</span><span class=\"token operator\">/</span>\n\n<span class=\"token comment\">// Match anything that's NOT x, y, or z!</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^xyz]</span><span class=\"token regex-delimiter\">/</span></span>\n\n<span class=\"token comment\">// Match a through z!</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[a-z]</span><span class=\"token regex-delimiter\">/</span></span>\n\n<span class=\"token comment\">// Match a-z and A-Z!</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[a-zA-Z]</span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Inside the brackets, you’re not limited to individual characters — you can use <code class=\"language-text\">-</code> to express character ranges, and adding <code class=\"language-text\">^</code> at the start means “NOT.”</p>\n<p>The range syntax like <code class=\"language-text\">a-z</code> refers to ranges in the <a href=\"http://www.asciitable.com/\" target=\"_blank\" rel=\"nofollow\">ASCII Table</a>.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 349px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/55b14704e00c60b3167cd812dcd52258/e9bf8/ascii-table.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 121.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9ElEQVR42pWVW2/TQBCFF9GQxLk5iR2HYGgFlNhJCIUWIR6QEIgXxP//PcyKb6PTiVFhpSN5x+szZ27rEEL4ZfhsaAw/DS8N3wxbwx3Pe8MP9jfy/rvhleGL4athZQifeJjzsm94z/7KMDZUEC0MteG5YWI4GqY8x3NPIuEthsywCX/WwTAwrNnPDK2hB/mcjxvOTYOsD7CP8BzwHG2FEB5FbQlhTMVQCB8F8jJDYc2LPQ5K9jGCHakpcdTDNuT707rBQyR8IbYRoSXCPepWoEdqhig/reQlEjyTHEYHS6dwjcIlIe9cyGeESeEWW/4XwgqF266ipHxFXAphBjTkjSNsUDpQwoNU+UoIxy6HO8nhGsKWSCZeYQZBUtjgIOVwzLkaWyVV7v9LyC37p6KwJdxU5QsIz3L4DoNWuSGUQggb+q2QKrcQ3gv5VhTWrvKlU1jgfO4mZe5Hb+QUtv9B2JduOCn0s9xim7kql9gWEL4l5JES3vGBNvaBvW/sBbYlVe4kVIW1KMxoDw15Rche4b0qf8SgfZhmuXSTspZKa5XPCHM3KanZc9c2BYQlIb/uum1Slcf8T7Sxpx2NncukXD9EeCl9OOGwElY4SQrfcCbrqrIqPHYQag4ruRwGcu50O6cqb9zl8FgIt9LYueTwIv1L4voNxWskW8umJHYAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ascii table\" title=\"\" src=\"/static/55b14704e00c60b3167cd812dcd52258/e9bf8/ascii-table.png\" srcset=\"/static/55b14704e00c60b3167cd812dcd52258/69538/ascii-table.png 160w,\n/static/55b14704e00c60b3167cd812dcd52258/72799/ascii-table.png 320w,\n/static/55b14704e00c60b3167cd812dcd52258/e9bf8/ascii-table.png 349w\" sizes=\"(max-width: 349px) 100vw, 349px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>Looking at the table, you can see special characters like <code class=\"language-text\">[</code> and <code class=\"language-text\">^</code> sitting between the uppercase group (65–90) and lowercase group (97–122). Since regex operates based on ASCII codes, if you try to catch only English letters with a range like <code class=\"language-text\">a-Z</code>, those special characters in between get included too.</p>\n<p>That’s why I separate the ranges into <code class=\"language-text\">a-z</code> and <code class=\"language-text\">A-Z</code> to filter English letters properly.</p>\n<p>With some ASCII knowledge, you can easily build custom character groups using the <code class=\"language-text\">-</code> range keyword. Even without memorizing the table, just Google “ASCII Table” and reference it.</p>\n<p>But manually defining groups every time is also tedious. <del>(Lazier developers make better developers…)</del> So regex helpfully provides several predefined groups.</p>\n<h4 id=\"code-classlanguage-textcode\" style=\"position:relative;\"><code class=\"language-text\">.</code><a href=\"#code-classlanguage-textcode\" aria-label=\"code classlanguage textcode permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Matches any single character except the newline escape <code class=\"language-text\">\\n</code>. Regardless of what the character is, if it’s a character, it matches. This includes spaces — applying the <code class=\"language-text\">.</code> class to <code class=\"language-text\">I am Evan</code> will match spaces too.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Match the first 4 characters from the start!</span>\n<span class=\"token string\">'I am Evan'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^....</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"I am\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>To express this character class as a custom group, you’d need to put every character in the ASCII table except <code class=\"language-text\">\\n</code> inside brackets — which is obviously impossible. That’s why knowing these character classes is the first step to writing regex comfortably.</p>\n<h4 id=\"the-code-classlanguage-textdcode-and-code-classlanguage-textdcode-classes\" style=\"position:relative;\">The <code class=\"language-text\">\\d</code> and <code class=\"language-text\">\\D</code> Classes<a href=\"#the-code-classlanguage-textdcode-and-code-classlanguage-textdcode-classes\" aria-label=\"the code classlanguage textdcode and code classlanguage textdcode classes permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">d</code> keyword stands for Digit — characters representing numbers. In ASCII terms, this means characters <code class=\"language-text\">0</code>–<code class=\"language-text\">9</code> (codes 48–57), so characters like Roman numerals (II) or Chinese numerals (五) are not recognized as digits.</p>\n<p>Lowercase <code class=\"language-text\">\\d</code> matches digit characters; uppercase <code class=\"language-text\">\\D</code> matches non-digit characters.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'010-1111-1111'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\d</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Characters 0-9 are matched, excluding -</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h4 id=\"the-code-classlanguage-textwcode-and-code-classlanguage-textwcode-classes\" style=\"position:relative;\">The <code class=\"language-text\">\\w</code> and <code class=\"language-text\">\\W</code> Classes<a href=\"#the-code-classlanguage-textwcode-and-code-classlanguage-textwcode-classes\" aria-label=\"the code classlanguage textwcode and code classlanguage textwcode classes permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">w</code> class stands for Word. In regex, “Word” characters are ASCII <code class=\"language-text\">A</code>–<code class=\"language-text\">Z</code> (65–90), <code class=\"language-text\">a</code>–<code class=\"language-text\">z</code> (97–122), and the <code class=\"language-text\">\\d</code> (digit) group.</p>\n<p>Characters outside this ASCII range — like Korean, Cyrillic, etc. — are not considered “Word” and can’t be caught with <code class=\"language-text\">\\w</code>. Like the <code class=\"language-text\">d</code> class, lowercase <code class=\"language-text\">\\w</code> matches Word characters and uppercase <code class=\"language-text\">\\W</code> matches non-Word characters.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'Phone: 010-0000-1111'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\w</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// : and - are not Word characters, so only English and digits match</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"P\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"o\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"n\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"e\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h4 id=\"the-code-classlanguage-textscode-and-code-classlanguage-textscode-classes\" style=\"position:relative;\">The <code class=\"language-text\">\\s</code> and <code class=\"language-text\">\\S</code> Classes<a href=\"#the-code-classlanguage-textscode-and-code-classlanguage-textscode-classes\" aria-label=\"the code classlanguage textscode and code classlanguage textscode classes permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">s</code> keyword stands for Space — whitespace characters. Lowercase <code class=\"language-text\">\\s</code> matches whitespace; uppercase <code class=\"language-text\">\\S</code> matches non-whitespace.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'Hi, my name is Evan'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\s</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// The 4 spaces in the string are matched</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"anchors-catching-boundaries-not-characters\" style=\"position:relative;\">Anchors: Catching Boundaries, Not Characters<a href=\"#anchors-catching-boundaries-not-characters\" aria-label=\"anchors catching boundaries not characters permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>The keywords we’ve looked at so far all represent individual characters. But regex also provides the ability to match boundaries between characters, not the characters themselves.</p>\n<p>Keywords that catch boundaries are called “anchors.” Since anchors only represent boundaries, they’re typically used in combination with character classes to catch characters positioned before or after a specific boundary.</p>\n<p>Since anchors catch the “boundary” itself, using an anchor alone returns a zero-length string.</p>\n<h4 id=\"the-code-classlanguage-textcode-and-code-classlanguage-textcode-anchors\" style=\"position:relative;\">The <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code> Anchors<a href=\"#the-code-classlanguage-textcode-and-code-classlanguage-textcode-anchors\" aria-label=\"the code classlanguage textcode and code classlanguage textcode anchors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">^</code> anchor represents the start-of-string boundary; <code class=\"language-text\">$</code> represents the end-of-string boundary.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Match only the character right after ^(start boundary)</span>\n<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Evans Library</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^.</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"E\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Evans Library\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Match only the character right before $(end boundary)</span>\n<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Evans Library</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"y\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Evans Library\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>It goes without saying that a character before <code class=\"language-text\">^</code> or after <code class=\"language-text\">$</code> can’t exist, so expressions like <code class=\"language-text\">.^</code> or <code class=\"language-text\">$.</code> can’t match anything.</p>\n<h4 id=\"the-code-classlanguage-textbcode-and-code-classlanguage-textbcode-anchors\" style=\"position:relative;\">The <code class=\"language-text\">\\b</code> and <code class=\"language-text\">\\B</code> Anchors<a href=\"#the-code-classlanguage-textbcode-and-code-classlanguage-textbcode-anchors\" aria-label=\"the code classlanguage textbcode and code classlanguage textbcode anchors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">b</code> keyword stands for Boundary — specifically, all boundaries between words composed of the Word group. In simple terms, it’s a superset of the <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code> anchors, which only match the start and end of the entire string.</p>\n<p>An important caveat: since it’s about “words composed of the Word group,” this only applies to English letters and digits included in the <code class=\"language-text\">\\w</code> group.</p>\n<p>The vague definition of “boundaries between words” might be confusing, but examples make it clear:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'abc def'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Here I used <code class=\"language-text\">\\b</code> to catch all word boundaries in <code class=\"language-text\">abc def</code>. The results are all zero-length strings, because as I mentioned, a boundary isn’t a character and has no length.</p>\n<p>The word boundaries in <code class=\"language-text\">abc def</code> are:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6d1779cbaba0a0243ed42fc5d27d3228/d56e1/boundaries.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 41.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABfUlEQVR42l2STU/bQBCG+cP0wC0SIHEoKkINCIEg6qlqqoo4uXDhBodElIiI8Bc4cIjrxHYcf+56H2btJKS80uyu57HfGY+9hSiYpcy8BG8Sk8aFTWFMtRFHBaGfMQ+yNVvJMpsP/ZRkUbMtu+SpJgpzFvOcoig/GeZM3RhfCtrzptJEVY3UbMPQqshLTFm7lEphJKqz5LQqURK2iJHFMqN1zXXNV1obqlwLtKYSYYj2PHlIoSWnpGvLjeVipF0XPZvZamv+Ybh8NZUW/HscMh0OGToOb4MB8/GY17t7ijCiFP7WH/DY6eDKPYuXF0a9Ln+dHiZbzla6rwwrz0Lz1HG42N3lx8EBPw8PcU6aPF93IIoJJh7d702u9ve53Nvj5vyCr1+26f9qyzCzDUM7h2W7vbMzvu3scN1sitkJf46PGUlH5DmhjOD30RFtidNGg367zW2rhfvwUPH/DFfKZHZZEJD6PrFEKtfBZLL+5NF0WnMJuxPHmCT5+CWAd1F4UjIJMUWSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"boundaries\" title=\"\" src=\"/static/6d1779cbaba0a0243ed42fc5d27d3228/6af66/boundaries.png\" srcset=\"/static/6d1779cbaba0a0243ed42fc5d27d3228/69538/boundaries.png 160w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/72799/boundaries.png 320w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/6af66/boundaries.png 640w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/d9199/boundaries.png 960w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/d56e1/boundaries.png 1130w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Don't overthink it — just consider where each word's boundaries are</small>\n</center>\n<p>The uppercase <code class=\"language-text\">\\B</code> catches positions that are NOT word boundaries — in other words, positions where a word hasn’t ended.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'abc def'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\B</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Again 4 boundaries, but their meaning is completely different: these are “boundaries where the word hasn’t ended.”</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/97a4fb713d83f95c04382b7fb6b20106/748b0/boundaries2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACMklEQVR42m2S208TURDG96/knQfriwkQCbEl4QHCTYWIwUQESV8AjZBwMUYNofhgBRoCGKFSWygUaekFCnS3ezv9OdsCyUYm2d05+818852Z0RBTbo3c32tKZzq5k2sKZxX0is19Zug2F0WDy/Mq5wUD/cpCqdodrnmvmpw9sFyqcnlhUhLfrDp+ppsc/doim7miKMXPPBF5A9dRfkLPHFvdAZbp1ovcZ54ay2wUcyTetpQP124zPULbdv8nvHVuvq6r6vgtoSM5SjClGsRaTQ6u62DJFb0AJb5p2KJWAl3Xr07Ojvz3FCrlijoH2/S3RrNSKUj+wdj7TTLyDZVKcvVzDzeZRCUS2Pl8Q025DIKdrm9w+iMGhweY8f36s7m4yH4k4vUDrbi2xvL4G+JLn3jW3sH04CCl7xtEp6ZZHhvDOT5uqCsU2F+YJ/ggwMb7WdZnpvk1v0js3Qc6mpvZmZuTXllo6dVVeltaGHjcznhPD+G+Pp53PGGit5f01y9U0+k6YV5u8ioUItw/wItgJ6GHAUZCncwMDRMMBMisrIBpon2emOBRUxOjwSBvu7t53dXFwssRRiU5Gg5jHx3VCS+EeLi1ladtbUz199MpJJHJSRIfl5gdGkLt7ODoOlo1l+Nwa4vLgwOy29skolFq2Swnu7ukNjdlk42bvXI4jcc5lBg7k+E4FiMrJIYUKku/LeGp9/Bub2XatVIJVSziVir+lcG/QkqKKBmWkkHVHP+U/wHruB77k5EMYwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"boundaries2\" title=\"\" src=\"/static/97a4fb713d83f95c04382b7fb6b20106/6af66/boundaries2.png\" srcset=\"/static/97a4fb713d83f95c04382b7fb6b20106/69538/boundaries2.png 160w,\n/static/97a4fb713d83f95c04382b7fb6b20106/72799/boundaries2.png 320w,\n/static/97a4fb713d83f95c04382b7fb6b20106/6af66/boundaries2.png 640w,\n/static/97a4fb713d83f95c04382b7fb6b20106/748b0/boundaries2.png 868w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Boundaries at positions where the word hasn't ended</small>\n</center>\n<p>The <code class=\"language-text\">b</code> keyword doesn’t match a character — it matches a boundary. Keep this distinction in mind and you’ll find it surprisingly useful in various situations.</p>\n<h3 id=\"flags-regex-options\" style=\"position:relative;\">Flags: Regex Options<a href=\"#flags-regex-options\" aria-label=\"flags regex options permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>You’ll often see characters like <code class=\"language-text\">g</code>, <code class=\"language-text\">i</code>, or <code class=\"language-text\">m</code> appended after a regex: <code class=\"language-text\">/regex/g</code>. These are “flags” that serve as option settings.</p>\n<p>When using the <code class=\"language-text\">new RegExp()</code> constructor instead of literal <code class=\"language-text\">/</code> syntax, pass flags as the second argument.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">pattern</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gi</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regex2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">pattern</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'gi'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// These two have the same pattern</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">===</span> regex2<span class=\"token punctuation\">.</span>flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Regex provides 6 flags: <code class=\"language-text\">g</code>, <code class=\"language-text\">i</code>, <code class=\"language-text\">m</code>, <code class=\"language-text\">s</code>, <code class=\"language-text\">u</code>, <code class=\"language-text\">y</code>. I’ll only cover the three most commonly used — <code class=\"language-text\">g</code>, <code class=\"language-text\">i</code>, and <code class=\"language-text\">m</code> — so Google the rest if you’re curious.</p>\n<h4 id=\"the-code-classlanguage-textgcode-flag\" style=\"position:relative;\">The <code class=\"language-text\">g</code> Flag<a href=\"#the-code-classlanguage-textgcode-flag\" aria-label=\"the code classlanguage textgcode flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">g</code> flag stands for <code class=\"language-text\">global</code>. A regex with this flag finds all parts of the string that match the pattern. Without <code class=\"language-text\">g</code>, the regex only finds the first match.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'hello, world'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'hello, world'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"hello, world\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"e\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"l\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"l\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"o\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\",\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"w\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"o\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"r\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"l\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"d\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Without the <code class=\"language-text\">g</code> flag, regex matches only one character; with it, all matching characters are found. This is intuitive enough that playing with it in the console a few times will make it click.</p>\n<h4 id=\"the-code-classlanguage-texticode-flag\" style=\"position:relative;\">The <code class=\"language-text\">i</code> Flag<a href=\"#the-code-classlanguage-texticode-flag\" aria-label=\"the code classlanguage texticode flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">i</code> flag stands for <code class=\"language-text\">ignoreCase</code> — matching without distinguishing uppercase from lowercase.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">abcd</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">i</span></span><span class=\"token punctuation\">;</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abcd'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ABCD'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>User-generated strings often vary in capitalization — <code class=\"language-text\">My name is Evan</code>, <code class=\"language-text\">my name is evan</code>, etc. The <code class=\"language-text\">i</code> flag lets you find the string you want without worrying about case.</p>\n<h4 id=\"the-code-classlanguage-textmcode-flag\" style=\"position:relative;\">The <code class=\"language-text\">m</code> Flag<a href=\"#the-code-classlanguage-textmcode-flag\" aria-label=\"the code classlanguage textmcode flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">m</code> flag stands for <code class=\"language-text\">multiline</code>, meaning the regex will evaluate a multi-line string. But oddly, regex matches multi-line strings just fine without this flag.</p>\n<p>Let’s create a multi-line string and try a simple pattern match:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> string <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">abcd\\nefgh\\nijkl</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\nstring<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\w{2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cd\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ef\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"gh\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ij\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"kl\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Regex just finds matching patterns in whatever string it’s given, so multi-line strings work fine without the <code class=\"language-text\">m</code> flag.</p>\n<p>So why does the <code class=\"language-text\">m</code> flag exist? Because it changes how regex treats the <code class=\"language-text\">\\n</code> newline escape.</p>\n<p>Let’s add the <code class=\"language-text\">^</code> anchor to find two characters at the start of the string, not just any two <code class=\"language-text\">\\w</code> characters:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">string<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\w{2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Only <code class=\"language-text\">ab</code> is returned. Even though lines are separated by <code class=\"language-text\">\\n</code>, the regex sees the whole thing as a single string, so only the <code class=\"language-text\">a</code> at the very beginning counts as the start (<code class=\"language-text\">^</code>).</p>\n<p>Now with the <code class=\"language-text\">m</code> flag:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">string<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\w{2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gm</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ef\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ij\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Now each line separated by <code class=\"language-text\">\\n</code> is treated as a separate string. The <code class=\"language-text\">m</code> flag doesn’t simply mean “search multi-line strings” — it means “split on <code class=\"language-text\">\\n</code> and treat each line as its own search target.”</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/69dd01cadc54feeecd2154af66259484/35751/multiline.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACVUlEQVR42m1Ta08aQRTdf84fwU8mtSQWaCMULfUBRogCAkKoqAhqdBeFfTA7uzszcHpnfETSTkLYnTn3zDnn3rUSKRHHMYRSUPRLkgRRFEGIBMvlEp+XovfkDaPx+lwIgTiJzZ6ut17abbgnJ7g+O0OTngs7Oziu1hCGkblIr9VqZf7jMMRLpwOvXsdVs4n2xQW+5/PodC4Iz40Qy97dRdBoYFCpoFQuI5/PonrYwPXAgZRindB14RSLBt/e30eRajOZr6hVu7j5Q3glYAmyzBiD7/vgnGOxWIBHHEEQGDuflyRLnPY4KY0Iqx3oGq2MsfDV8tHREba2tlCkm0ulEj1/wehmgkXATC5rCumS+WBgLE/Oz/GjUEA2m8XTo01CXvFWOp3G6empIUulUjg4+I3acRtXA/sfy9F0CodiiUYj/KSsNb5c/oX6cZci0ngi9DzPME8mE3S7Xbju3NjWEfzPckjx6MkY396i1+sZbEgRaIVKSVgVasbl5SU2NzfRarWwt7dHpK4BfhC+KUxozx0Owe/vcU5NOSO8jiyk/BidGcu5XA79fh8bGxsoUCZ6bB6oQDfqnfDDMqmeUjyc3BxubyPzLWtqHNs2AnSTrJgG+O5ubCzqLoXU4YT25FJ9EL2vJb0LPdTPU0jqrqCMtV0dgcbrc0u6HnhMXwCXCJgA8wjoh5BzD0up1iyv9Kj4NGJMIY4UXD+GZPSVzTwIL4CKKcPYdvA4DWHfeXh0GJyHOfjTM4LhmIrDNctqNgMnwvHEx8xmGI3niGYLsNsHzPsj8FmAv+izel8PUmvHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"multiline\" title=\"\" src=\"/static/69dd01cadc54feeecd2154af66259484/6af66/multiline.png\" srcset=\"/static/69dd01cadc54feeecd2154af66259484/69538/multiline.png 160w,\n/static/69dd01cadc54feeecd2154af66259484/72799/multiline.png 320w,\n/static/69dd01cadc54feeecd2154af66259484/6af66/multiline.png 640w,\n/static/69dd01cadc54feeecd2154af66259484/35751/multiline.png 873w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Whether the m flag is present determines if lines are treated<br>as one combined string or as individual strings.</small>\n</center>\n<p>The <code class=\"language-text\">m</code> flag is more useful when dealing with long strings containing line breaks than short strings. I’ve used it for things like checking that English text capitalizes the first letter of each line, or parsing uncompressed files.</p>\n<h3 id=\"quantifiers-how-many-times-a-pattern-appears\" style=\"position:relative;\">Quantifiers: How Many Times a Pattern Appears<a href=\"#quantifiers-how-many-times-a-pattern-appears\" aria-label=\"quantifiers how many times a pattern appears permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>In the previous example, I used <code class=\"language-text\">{2}</code> to find two <code class=\"language-text\">\\w</code> characters. This expression specifies the repetition count for the preceding expression. You can also use <code class=\"language-text\">{0,2}</code> to specify a min/max range.</p>\n<p>Expressions that capture how many times a preceding pattern matches are called quantifiers.</p>\n<h4 id=\"specifying-exact-repetition-counts\" style=\"position:relative;\">Specifying Exact Repetition Counts<a href=\"#specifying-exact-repetition-counts\" aria-label=\"specifying exact repetition counts permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'aaaabbbcc'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\w{3}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"abb\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bcc\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The expression <code class=\"language-text\">\\w{3}</code> simply says “find where the Word group repeats 3 times,” so regex pulls out every 3-character chunk of Word characters.</p>\n<p>Repetition patterns are applicable in many situations. A classic example is phone numbers or ID numbers, where character groups repeat a fixed number of times.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'010-0101-0101'</span>  <span class=\"token comment\">// Mobile</span>\n<span class=\"token string\">'02-0101-0101'</span>   <span class=\"token comment\">// Landline (Seoul area code)</span>\n<span class=\"token string\">'031-010-0101'</span>   <span class=\"token comment\">// Landline (regional area code)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Phone numbers in many countries follow predictable formats. Mobile numbers typically start with a carrier prefix followed by fixed-length digit groups. Using quantifiers makes it easy to capture these patterns:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Pattern for catching mobile numbers (Korean format)</span>\n<span class=\"token operator\">/</span><span class=\"token number\">01</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">|</span><span class=\"token number\">1</span><span class=\"token operator\">|</span><span class=\"token number\">6</span><span class=\"token operator\">|</span><span class=\"token number\">8</span><span class=\"token operator\">|</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>You might wonder why we don’t just match <code class=\"language-text\">010</code> — but mobile carrier prefixes weren’t always <code class=\"language-text\">010</code>. Older prefixes like <code class=\"language-text\">011</code>, <code class=\"language-text\">016</code>, <code class=\"language-text\">018</code> existed before being unified, and some people still use them. Keep edge cases like these in mind when writing validation logic.</p>\n<h4 id=\"checking-if-a-pattern-appears-one-or-more-times\" style=\"position:relative;\">Checking If a Pattern Appears One or More Times<a href=\"#checking-if-a-pattern-appears-one-or-more-times\" aria-label=\"checking if a pattern appears one or more times permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Exact repetition counts are great, but they’re too rigid for abstract patterns like “may or may not exist” or “appears n or more times.” So regex provides more flexible quantifiers.</p>\n<h5 id=\"the-code-classlanguage-textcode-quantifier\" style=\"position:relative;\">The <code class=\"language-text\">*</code> Quantifier<a href=\"#the-code-classlanguage-textcode-quantifier\" aria-label=\"the code classlanguage textcode quantifier permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>The <code class=\"language-text\">*</code> quantifier matches when the preceding pattern appears 0 or more times. “0 or more” means the pattern before it may not appear at all, or may repeat many times.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// The a before b can be absent or appear many times — match them all!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">a*b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">'b'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'ab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'aab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'aab'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Since patterns before <code class=\"language-text\">*</code> are matched no matter how many times they appear, any number of <code class=\"language-text\">a</code>s will be caught.</p>\n<h5 id=\"the-code-classlanguage-textcode-quantifier-1\" style=\"position:relative;\">The <code class=\"language-text\">?</code> Quantifier<a href=\"#the-code-classlanguage-textcode-quantifier-1\" aria-label=\"the code classlanguage textcode quantifier 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>The <code class=\"language-text\">?</code> quantifier matches when the preceding pattern appears 0 or 1 times. Unlike <code class=\"language-text\">*</code>, even if the pattern appears many times, <code class=\"language-text\">?</code> only captures one.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// The a before b can be absent or appear many times — only match 1!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">a?b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">'b'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'ab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'aab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h5 id=\"the-code-classlanguage-textcode-quantifier-2\" style=\"position:relative;\">The <code class=\"language-text\">+</code> Quantifier<a href=\"#the-code-classlanguage-textcode-quantifier-2\" aria-label=\"the code classlanguage textcode quantifier 2 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>The <code class=\"language-text\">+</code> quantifier means the preceding pattern must appear at least once. If it doesn’t appear, the match fails.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// The a before b must exist, and match all of them!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">a+b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">'b'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'ab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'aab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'aab'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Put simply, <code class=\"language-text\">+</code> means “I don’t care how many times, just be there” — useful for catching characters that must be present.</p>\n<h2 id=\"nice-to-know-advanced-features\" style=\"position:relative;\">Nice-to-Know Advanced Features<a href=\"#nice-to-know-advanced-features\" aria-label=\"nice to know advanced features permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>So far we’ve covered the basics: character classes, anchors, flags, and quantifiers. This is enough for most business situations, but occasionally you’ll hit cases where these alone become unwieldy.</p>\n<p>Let’s look at some features that make regex more convenient to work with.</p>\n<h3 id=\"capturing-remembering-patterns\" style=\"position:relative;\">Capturing: Remembering Patterns<a href=\"#capturing-remembering-patterns\" aria-label=\"capturing remembering patterns permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Regex doesn’t just match patterns — it can also remember matched patterns. This capturing ability is useful for string replacement (distinguishing parts that should change from parts that shouldn’t), finding duplicates, and more.</p>\n<p>For example, consider a string representing a dollar amount: <code class=\"language-text\">$10000</code>. What pattern captures this?</p>\n<p>A dollar amount means <code class=\"language-text\">$</code> followed by at least one digit to be meaningful. A simple expression matching <code class=\"language-text\">$</code> followed by one or more digits does the trick. (Remember that bare <code class=\"language-text\">$</code> is the end-of-string anchor, so escape it with <code class=\"language-text\">\\</code>.)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'$10000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\$\\d+</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"$10000\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Now, what if we want to change <code class=\"language-text\">$10000</code> to <code class=\"language-text\">10000 dollars</code>?</p>\n<p>You might think of <code class=\"language-text\">String.prototype.replace</code>, but the pattern above captures <code class=\"language-text\">$10000</code> as a whole — there’s no way to keep <code class=\"language-text\">10000</code> while replacing just the <code class=\"language-text\">$</code>.</p>\n<p>We need a way to remember a specific part of the match. This is where capturing comes in.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Wrap the part you want to remember in parentheses!</span>\n<span class=\"token operator\">/</span>\\<span class=\"token function\">$</span><span class=\"token punctuation\">(</span>\\d<span class=\"token operator\">+</span><span class=\"token punctuation\">)</span><span class=\"token operator\">/</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>The only difference from before is wrapping <code class=\"language-text\">\\d+</code> in parentheses. This tells regex to capture that part.</p>\n<p>The second argument of <code class=\"language-text\">String.prototype.replace</code> is the replacement string. Captured patterns can be referenced there using the special <code class=\"language-text\">$n</code> syntax.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'$10000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\$(\\d+)</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'$1 dollars'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">\"10000 dollars\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">$1</code> refers to the first captured group. With multiple capture groups, you can use <code class=\"language-text\">$2</code>, <code class=\"language-text\">$3</code>, and so on.</p>\n<p>Capturing is also useful for finding repeated characters, since repetition means a previously seen character appears again consecutively:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(\\w)\\1</span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Here I captured a Word character with <code class=\"language-text\">(\\w)</code>, then referenced it with <code class=\"language-text\">\\1</code> — expressing the pattern of repetition.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'aabccdeef'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(\\w)\\1</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cc\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ee\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Expressions like <code class=\"language-text\">(.)\\1{2}</code> (combined with quantifiers) are useful for password validation rules like “the same character must not repeat 3 or more times.”</p>\n<h3 id=\"greedy-vs-lazy\" style=\"position:relative;\">Greedy vs. Lazy<a href=\"#greedy-vs-lazy\" aria-label=\"greedy vs lazy permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Earlier we learned about the <code class=\"language-text\">+</code> (1 or more) and <code class=\"language-text\">*</code> (0 or more) quantifiers. Using “n or more” quantifiers creates an ambiguity in pattern matching:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Find all strings wrapped in &lt; and >!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.*></span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">\"&lt;p>This is p tag&lt;/p>\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"&lt;p>This is p tag&lt;/p>\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>My regex just says “find anything wrapped in <code class=\"language-text\">&lt;</code> and <code class=\"language-text\">></code>,” so it might seem natural that it captures the entire <code class=\"language-text\">&lt;p>This is p tag&lt;/p></code>. But <code class=\"language-text\">&lt;p></code> and <code class=\"language-text\">&lt;/p></code> individually also match this pattern.</p>\n<p>Regex defaults to matching the longest possible pattern — this is called <strong>greedy</strong> matching. It greedily gobbles up the longest match it can find. <del>(This is unrelated to the Greedy algorithm concept, despite sharing the name.)</del></p>\n<p>So how do you capture the smaller matches like <code class=\"language-text\">&lt;p></code> and <code class=\"language-text\">&lt;/p></code>?</p>\n<blockquote>\n<p>Make the regex <strong>lazy</strong>.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Find all strings wrapped in &lt; and > — lazily!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.*?></span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">\"&lt;p>This is p tag&lt;/p>\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"&lt;p>\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"&lt;/p>\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The only change is adding <code class=\"language-text\">?</code> after the <code class=\"language-text\">*</code> quantifier. Lazy matching finds the shortest possible matches. Given the same expression, it finds the minimal match and calls it a day — hence “lazy.”</p>\n<p>In summary: quantifiers like <code class=\"language-text\">*</code> and <code class=\"language-text\">+</code> default to greedy matching (longest possible). Adding <code class=\"language-text\">?</code> after them switches to lazy matching (shortest possible).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Greedy</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token operator\">/</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.+></span><span class=\"token regex-delimiter\">/</span></span>\n\n<span class=\"token comment\">// Lazy</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token operator\">?</span><span class=\"token operator\">></span><span class=\"token operator\">/</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.+?></span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Without understanding the difference between greedy and lazy matching, you’ll fail to capture the patterns you want when multiple valid matches exist. Keep this distinction in mind.</p>\n<h2 id=\"wrapping-up\" style=\"position:relative;\">Wrapping Up<a href=\"#wrapping-up\" aria-label=\"wrapping up permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>I first encountered regex as a college student, building a parser that converted OBJ files into <a href=\"https://threejs.org/\" target=\"_blank\" rel=\"nofollow\">ThreeJS</a> objects. That required seriously heavy regex usage. <del>(The OBJ Loader that ThreeJS provided at the time had a bug 😢)</del></p>\n<p>OBJ files represent vertex coordinates, texture UV mapping coordinates, vertex normals, and more:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\"># Vertex coordinates\nv -1.692615 -0.021714 -1.219301\nv 7.334266 -0.021714 -1.219302\nv 7.334265 0.021714 -1.219302\n...\n\n# Texture UV values\nvt 0.0000 0.0000\nvt 1.0000 0.0000\n...\n\n# Vertex normals\nvn -0.0000 -0.0000 -1.0000\nvn 0.0000 -1.0000 -0.0000\n\nusemtl Material.001\n\n# Vertex indices for each face\nf 1/1/1 4/2/1 3/3/1 2/4/1\nf 8/5/2 5/6/2 6/7/2 7/8/2</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>I used the <code class=\"language-text\">m</code> flag to split the file line by line, then parsed lines starting with <code class=\"language-text\">v</code> as vertex coordinates, <code class=\"language-text\">vt</code> as texture UVs, <code class=\"language-text\">vn</code> as normals, and so on. It was challenging and complex, but fun.</p>\n<p>It was eye-opening to realize that computer-generated files are really just sequences of meaningful strings — and even more fun that regex could transform those strings into meaningful information.</p>\n<p>But as I mentioned, regex is used far more often in everyday business logic than in building parsers. For validating user input like passwords or email addresses, regex is practically a cheat code.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 399px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f8ab432328c5d8bafe5aa95518ad4df2/a307d/password_rule.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZ0lEQVR42p1T2Y7CMBDr///c8sA+8oSABnoftMmk8XpSjiJYCYjkJk0ztjMzTfqmwe96jZ/VClVdw3sPay2ccx9BRKAjKcsKTd2gbduv0XUd8jyPxElVVVDUdPctGt5SCdVlInK17OHkbn+Jec897WlqlgghINGcqUJRFDGHTUv7XBdFieyUoeQcHWQZjDHI6ETdDMMQc6YkOpRnmqaZ0DmLkXkYux6WGEigihqkszqydozv4zhGaNxy3An5CAzwVPV0JCaFbLe4yOPd8eAwEJ6FkdMpwpcF7GZzu84XhHTY1JDjkU4LSMYW2O+iyLtOnx2yEHI0dFdCtKfSAyRN59M8+ED6QuCRkAuJ+TPz1VnZmMsr4ccOL0WR/Z7XzeguhdN8ktweDnAUmvoenlV2ux2FzJPQjTD+g/wQ2B5Tf55nBk5sjTDamFvPlgpsZBUO/BbO5/8dKqG+aPu8BMVe7mvMAsqjf8of4zBFjqIV43cAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"password rule\" title=\"\" src=\"/static/f8ab432328c5d8bafe5aa95518ad4df2/a307d/password_rule.png\" srcset=\"/static/f8ab432328c5d8bafe5aa95518ad4df2/69538/password_rule.png 160w,\n/static/f8ab432328c5d8bafe5aa95518ad4df2/72799/password_rule.png 320w,\n/static/f8ab432328c5d8bafe5aa95518ad4df2/a307d/password_rule.png 399w\" sizes=\"(max-width: 399px) 100vw, 399px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>You can validate with built-in methods alone, but regex makes it far simpler</small>\n</center>\n<p>Without regex, validating something as simple as an email address requires combining multiple built-in methods — quite inefficient. And personally, as hard as regex is to read, I think it’s still more readable than a complex chain of method calls.</p>\n<p>Regex doesn’t have lines or indentation like code, so it looks like a meaningless jumble of characters. But the number of expressions regex provides isn’t that large, and with a bit of practice, anyone can understand short regex patterns quickly.</p>\n<p>That’s all for this post on finding patterns in irregularity. In the next post, I’ll walk through real-world examples of how I’ve used regex as a working developer.</p>","fields":{"slug":"20200724-about-regular-expression-en","path":"/2020/07/24/about-regular-expression/en/","lang":"en"},"frontmatter":{"title":"Finding Patterns in Irregularity: A Guide to Regular Expressions","subTitle":"The art of defining patterns in infinite possibility","date":"Aug 10, 2020","categories":["Programming","Tutorial"],"tags":["Regex","Regular Expression","Character Class","Anchor","Capturing Group","Greedy","Lazy"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/fc5c5/thumbnail.webp 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}},"allMarkdownRemark":{"edges":[{"node":{"id":"a24d87ce-d247-51be-a7c7-279b2b311348","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EA%B7%9C%EC%8B%9D%EC%9D%B4%ED%98%95-%EB%84%8C-%EB%88%84%EA%B5%AC%EB%83%90\">규식이형, 넌 누구냐?</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%A0%95%EA%B7%9C%EC%8B%9D%EC%9D%98-%EA%B8%B0%EB%8A%A5%EB%93%A4\">기본적인 정규식의 기능들</a></p>\n<ul>\n<li><a href=\"#%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90%EC%9D%98-%EA%B7%B8%EB%A3%B9%EC%9D%84-%EC%9E%A1%EC%95%84%EB%82%B4%EB%8A%94-%EC%BA%90%EB%A6%AD%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4\">특정 문자의 그룹을 잡아내는 캐릭터 클래스</a></li>\n<li><a href=\"#%EB%AC%B8%EC%9E%90%EA%B0%80-%EC%95%84%EB%8B%8C-%EA%B2%BD%EA%B3%84%EB%A5%BC-%EC%9E%A1%EC%95%84%EB%82%B4%EB%8A%94-%EC%95%B5%EC%BB%A4\">문자가 아닌 경계를 잡아내는 앵커</a></li>\n<li><a href=\"#%EC%A0%95%EA%B7%9C%EC%8B%9D%EC%9D%98-%EC%98%B5%EC%85%98-%EA%B8%B0%EB%8A%A5-%ED%94%8C%EB%9E%98%EA%B7%B8\">정규식의 옵션 기능, 플래그</a></li>\n<li><a href=\"#%ED%8C%A8%ED%84%B4%EC%9D%B4-%EB%AA%87-%EB%B2%88%EC%9D%B4%EB%82%98-%EB%82%98%EC%99%94%EB%8A%94%EC%A7%80-%EC%B0%BE%EC%95%84%EC%A3%BC%EB%8A%94-%EC%88%98%EB%9F%89%EC%9E%90\">패턴이 몇 번이나 나왔는지 찾아주는 수량자</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%95%8C%EB%A9%B4-%EB%8D%94-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EA%B8%B0%EB%8A%A5%EB%93%A4\">알면 더 효율적인 기능들</a></p>\n<ul>\n<li><a href=\"#%ED%8C%A8%ED%84%B4%EC%9D%84-%EA%B8%B0%EC%96%B5%ED%95%98%EB%8A%94-%EC%BA%A1%EC%B2%98%EB%A7%81\">패턴을 기억하는 캡처링</a></li>\n<li><a href=\"#greedy-vs-lazy\">Greedy vs Lazy</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"개발자들은 자연어로 주어지는 문제 상황을 파악하고 프로그램을 설계하고 작성하는 사람들이다. 이런 업무를 수행하기 위해 개발자들은 불규칙하게 쏟아지는 정보들 속에서 필요한 부분들을 걸러내거나 무분별하게 선언된 클래스나 변수들을 추상화하는 등의 업무를 수행하게 된다.","html":"<p>개발자들은 자연어로 주어지는 문제 상황을 파악하고 프로그램을 설계하고 작성하는 사람들이다. 이런 업무를 수행하기 위해 개발자들은 불규칙하게 쏟아지는 정보들 속에서 필요한 부분들을 걸러내거나 무분별하게 선언된 클래스나 변수들을 추상화하는 등의 업무를 수행하게 된다.</p>\n<!-- more -->\n<p>이러한 일들을 해내기 위해 필요한 역량은 여러가지가 있겠지만 그 중에서도 특히 중요한 한 가지 역량은 바로 불규칙해 보이는 정보들 속에서 규칙성, 즉 패턴을 찾아내는 능력이다.</p>\n<p>그 중에서도 일반적인 비즈니스 상황에서 접할 수 있는 가장 흔한 문제는 파일을 파싱하거나 사용자의 입력을 검증하거나 하는 경우처럼 불규칙한 문자열 속에서 패턴을 찾아내어 원하는 정보를 취득하는 경우가 많다. 그러나 이런 문제는 경우의 수가 워낙 많기 때문에 일반적인 프로그래밍만으로 문제를 해결하려고 하면 화려한 <code class=\"language-text\">if</code> 문이 나를 감싸는 상황을 만날 수도 있다.</p>\n<p>바로 이런 문제를 쉽게 해결할 수 있도록 도와주는 도구가 정규식이다.</p>\n<h2 id=\"규식이형-넌-누구냐\" style=\"position:relative;\">규식이형, 넌 누구냐?<a href=\"#%EA%B7%9C%EC%8B%9D%EC%9D%B4%ED%98%95-%EB%84%8C-%EB%88%84%EA%B5%AC%EB%83%90\" aria-label=\"규식이형 넌 누구냐 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>정규식의 정식 풀네임은 정규 표현식(Regular Expression)이지만, 사실 정규 표현식이라는 풀네임보다는 정규식, Regex, <del>규식이형</del> 등으로 더 자주 불리고는 한다.</p>\n<p>정규식은 패턴을 표현할 수 있는 일종의 표현식이고 이 표현식을 문자열에 적용하여 원하는 부분을 쏙쏙 끄집어 낼 수 있는 굉장히 편리한 도구이지만, 그 특유의 악랄한 가독성 덕분에 왠지 모를 기피의 대상이 되고는 한다.</p>\n<p>사실 필자도 정규식을 꽤나 자주 사용하는 편이지만, 왠만큼 자주 사용하는 표현이 아니라면 무조건 구글링을 해서 표현을 찾아보고 <a href=\"https://regexr.com/\" target=\"_blank\" rel=\"nofollow\">RegExr</a> 사이트에서 검수를 돌려보고는 한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cf1e76c74723af6eb45ee626ca4269a9/e5166/regex_meme.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB32UTM6UU0wG1Av/EABoQAQEBAQADAAAAAAAAAAAAAAECAxEAEiH/2gAIAQEAAQUCvXlNEnfLZ96iED5pAumJZJw//8QAFREBAQAAAAAAAAAAAAAAAAAAEAH/2gAIAQMBAT8BIf/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABsQAAICAwEAAAAAAAAAAAAAAAERABACITFB/9oACAEBAAY/Al5GclSLm+WiShX/xAAcEAEAAgMBAQEAAAAAAAAAAAABABEhMUFRgaH/2gAIAQEAAT8hW+aewNVPZdBHDLg9NkzifghA79iJfIG5pUpS2jE//9oADAMBAAIAAwAAABBsPwP/xAAaEQEAAQUAAAAAAAAAAAAAAAABEBEhQWHB/9oACAEDAQE/EBat4OdvI//EABcRAQEBAQAAAAAAAAAAAAAAAAABMUH/2gAIAQIBAT8Qmq6r/8QAGxABAAMBAQEBAAAAAAAAAAAAAQARIUExUYH/2gAIAQEAAT8QaOoLcX3IcLIJ/YXBgInSPUmgph2AgAcL0SHQoDG3nJZzdCys2e0w2Fr9chA0ILrwJ//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"regex meme\" title=\"\" src=\"/static/cf1e76c74723af6eb45ee626ca4269a9/c08c5/regex_meme.jpg\" srcset=\"/static/cf1e76c74723af6eb45ee626ca4269a9/0913d/regex_meme.jpg 160w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/cb69c/regex_meme.jpg 320w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/c08c5/regex_meme.jpg 640w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/6a068/regex_meme.jpg 960w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/e5166/regex_meme.jpg 1200w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이런 짤이 있을 정도로 정규식을 처음 보면 이게 뭔가 싶다</small>\n</center>\n<p>하지만 정규식의 주 사용처가 문자열 내에서 패턴을 찾아내는 것이고, 이런 상황은 개발자로 일을 하다보면 자주 마주치는 상황 중 하나이기 때문에 언젠가는 반드시 정규식과 마주하게 될 일이 생기게 된다. 즉, 정규식을 무작정 피할 수도 없다는 뜻이다. <small><del>(그냥 도망치는 걸 포기하면 편하다)</del></small></p>\n<p>물론 아무 생각없이 정규식을 보았을 때는 “이게 뭔 말이야…?” 싶겠지만, 결국 아무리 긴 정규 표현식도 작은 표현들이 합쳐져서 만들어진 것이므로 막상 뜯어보면 생각보다 간단한 표현인 경우가 많다.</p>\n<h2 id=\"기본적인-정규식의-기능들\" style=\"position:relative;\">기본적인 정규식의 기능들<a href=\"#%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%A0%95%EA%B7%9C%EC%8B%9D%EC%9D%98-%EA%B8%B0%EB%8A%A5%EB%93%A4\" aria-label=\"기본적인 정규식의 기능들 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>정규식에는 굉장히 다양한 키워드들이 있으며, 결국 이런 키워드들을 잘 조합하여 원하는 패턴을 잡아낼 수 있는 표현식을 만드는 것이 정규식 사용법의 전부이다. 한 마디로 이야기하자면 정규식을 시작하는 가장 기본적인 방법은 이 키워드들을 암기하는 것이다.</p>\n<p>물론 구글에 “정규식”이라고만 검색해도 방대한 양의 자료들이 쏟아져나오기 때문에 굳이 수 많은 키워드들을 다 알아야할 필요는 없지만, 기본적인 것들이라도 암기하고 있다면 간단한 패턴 매칭 문제 정도는 딱히 구글신께 물어보지 않아도 해결할 수 있기 때문에 생산성 측면에서 이득이다. <small>(어차피 다 외우는 건 불가능하다)</small></p>\n<p>결국 이 기능을 상황에 따라 적절하게 조합하며 사용하는 것이 결국 정규식을 얼마나 잘 사용하냐는 것의 척도이므로 이번 포스팅에서는 정규식이 제공하는 기능을 간단하게 핥아만 보고, 다음 포스팅에서 실무에서 발생할 법한 예제들을 통해 설명을 더 자세히 풀어가고자 한다.</p>\n<h3 id=\"특정-문자의-그룹을-잡아내는-캐릭터-클래스\" style=\"position:relative;\">특정 문자의 그룹을 잡아내는 캐릭터 클래스<a href=\"#%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90%EC%9D%98-%EA%B7%B8%EB%A3%B9%EC%9D%84-%EC%9E%A1%EC%95%84%EB%82%B4%EB%8A%94-%EC%BA%90%EB%A6%AD%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"특정 문자의 그룹을 잡아내는 캐릭터 클래스 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>정규식에는 특정한 문자 혹은 특정한 문자들의 그룹을 의미하는 다양한 키워드들이 있다. 이렇게 특정한 문자를 찾는 녀석들을 “캐릭터 클래스(Character Class)“라고 부른다.</p>\n<p>정규식의 핵심 기능이 내가 원하는 문자를 찾는 것이니 만큼, 캐릭터 클래스의 종류와 역할을 어느 정도 알고 있다면 간단한 정규식 정도는 구글링 없이도 대충 파악할 수 있다.</p>\n<h4 id=\"특정한-문자부터-찾아내보자\" style=\"position:relative;\">특정한 문자부터 찾아내보자<a href=\"#%ED%8A%B9%EC%A0%95%ED%95%9C-%EB%AC%B8%EC%9E%90%EB%B6%80%ED%84%B0-%EC%B0%BE%EC%95%84%EB%82%B4%EB%B3%B4%EC%9E%90\" aria-label=\"특정한 문자부터 찾아내보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>정규식에는 <code class=\"language-text\">\\d</code>, <code class=\"language-text\">\\w</code> 등 한 눈에 봐서는 의미를 알기 힘든 캐릭터 클래스들이 수두룩하게 포함되어 있지만, 사실 이런 요상한 키워드들만 사용되는 것은 아니다. 예를 들면 엄청 긴 문장 속에서 특정한 단어만 뽑아내고 싶다면 그냥 이렇게 작성해도 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'hello, world'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">hello</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"hello, world\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이처럼 정규식에는 일반 문자도 자유롭게 사용할 수 있기 때문에 특정 문자의 그룹을 의미하는 키워드인 <code class=\"language-text\">\\w</code>, <code class=\"language-text\">\\s</code> 등을 사용할 때 반드시 키워드의 앞에 <code class=\"language-text\">\\</code>를 사용하여 이스케이핑을 해주는 것이다. 즉, <code class=\"language-text\">\\s</code>는 키워드 문자이지만 <code class=\"language-text\">s</code>는 그냥 s다.</p>\n<p>이러한 이스케이핑 처리 때문에 정규식에 익숙하지 않은 사람은 이게 <code class=\"language-text\">s</code>인지, 공백을 의미하는 <code class=\"language-text\">\\s</code> 키워드인지 헷갈리는 경우가 많은데, 이건 사실 팁이라고 할만한 게 없다. 그냥 <code class=\"language-text\">/\\/s\\.s.{1,2}/</code> 이런 모양을 보면 앞에서부터 하나씩 잘라가면서 읽어보도록 하자.</p>\n<p>그리고 이렇게 정규식에 <code class=\"language-text\">hello</code>와 같이 특정한 문자를 사용하여 문자열 속에서 자신이 원하는 정확한 패턴을 찾아낼 수는 있지만, 이런 방식으로 특정 패턴을 찾는 것 뿐이라면 굳이 정규식을 사용하지 않더라도 <code class=\"language-text\">include</code>나 <code class=\"language-text\">indexOf</code>, <code class=\"language-text\">search</code> 같은 <code class=\"language-text\">String.prototype</code> 메소드들에 일반 문자열을 인자로 사용하는 것만으로도 충분하기 때문에 큰 의미가 없다.</p>\n<p>정규식의 진짜 힘은 이런 특정 문자열을 찾는 것이 아니라 내가 원하는 문자열의 그룹을 찾아내는 것에 있다.</p>\n<h4 id=\"원하는-문자의-그룹을-만들어보자\" style=\"position:relative;\">원하는 문자의 그룹을 만들어보자<a href=\"#%EC%9B%90%ED%95%98%EB%8A%94-%EB%AC%B8%EC%9E%90%EC%9D%98-%EA%B7%B8%EB%A3%B9%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90\" aria-label=\"원하는 문자의 그룹을 만들어보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>만약 우리가 유저의 입력이 오직 영어로만 이루어져있는지 검증을 해야하는 상황이라고 생각해보자. 물론 영어는 대소문자를 모두 합쳐 총 48개의 문자로 이루어져 있기 때문에 알파벳으로 이루어진 맵이나 배열을 만들어서 일일히 검증하거나, 최악의 경우에는 논리 조건 48개를 <code class=\"language-text\">||</code> 연산자로 묶어서 써도 된다. <small><del>(예외 처리까지 합치면 논리 조건 49개…)</del></small></p>\n<p>하지만 이 방법이 그다지 쿨한 방법이 아니라는 것에는 다들 어느 정도 동의할 것이라고 생각한다. 게다가 영어만 검사하는 것이 아니라 숫자까지 포함되었는지를 검사한다던가, 영어가 n번 반복하는 것을 검사한다던가 하는 식으로 조건이 추가되면 추가될수록 필요한 논리도 늘어나기 때문에 코드는 점점 더 복잡해진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> alphabet <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'B'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'C'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'d'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Z'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">isAlphabet</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token builtin\">string</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">every</span><span class=\"token punctuation\">(</span>char <span class=\"token operator\">=></span> alphabet<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<center>\n  <small>사실 간단하게 영어만 검사하는 것이라면 이런 식으로 처리할 수 있기는 하다</small>\n  <br />\n  <br />\n</center>\n<p>그래서 정규식은 사용자가 커스텀한 그룹을 만들어서 원하는 문자를 잡아낼 수 있는 기능 또한 제공해준다. 사용하는 방법 또한 심플한데, 단순히 대괄호(<code class=\"language-text\">[]</code>) 안에 그룹핑하고 싶은 문자들을 넣어주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// x 또는 y 또는 z를 잡아내라!</span>\n<span class=\"token operator\">/</span><span class=\"token punctuation\">[</span>xyz<span class=\"token punctuation\">]</span><span class=\"token operator\">/</span>\n\n<span class=\"token comment\">// x 또는 y 또는 z가 아닌 것을 잡아내라!</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^xyz]</span><span class=\"token regex-delimiter\">/</span></span>\n\n<span class=\"token comment\">// a~z까지 잡아내라!</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[a-z]</span><span class=\"token regex-delimiter\">/</span></span>\n\n<span class=\"token comment\">// a~z, A~Z까지 잡아내라!</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[a-zA-Z]</span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>물론 대괄호 안에는 일반 문자만 들어갈 수 있는 것은 아니고, <code class=\"language-text\">-</code> 키워드를 사용하여 문자의 범위를 표현할 수도 있고, 맨 앞에 <code class=\"language-text\">^</code> 문자를 붙힘으로써 “Not” 또한 표현할 수 있다.</p>\n<p>그리고 위 표현 중 <code class=\"language-text\">a-z</code>와 같이 문자의 범위로 그룹을 설정하는 문법도 등장하는데, 이 범위는 <a href=\"http://www.asciitable.com/\" target=\"_blank\" rel=\"nofollow\">Ascii Table</a>에서의 범위를 의미한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 349px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/55b14704e00c60b3167cd812dcd52258/e9bf8/ascii-table.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 121.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9ElEQVR42pWVW2/TQBCFF9GQxLk5iR2HYGgFlNhJCIUWIR6QEIgXxP//PcyKb6PTiVFhpSN5x+szZ27rEEL4ZfhsaAw/DS8N3wxbwx3Pe8MP9jfy/rvhleGL4athZQifeJjzsm94z/7KMDZUEC0MteG5YWI4GqY8x3NPIuEthsywCX/WwTAwrNnPDK2hB/mcjxvOTYOsD7CP8BzwHG2FEB5FbQlhTMVQCB8F8jJDYc2LPQ5K9jGCHakpcdTDNuT707rBQyR8IbYRoSXCPepWoEdqhig/reQlEjyTHEYHS6dwjcIlIe9cyGeESeEWW/4XwgqF266ipHxFXAphBjTkjSNsUDpQwoNU+UoIxy6HO8nhGsKWSCZeYQZBUtjgIOVwzLkaWyVV7v9LyC37p6KwJdxU5QsIz3L4DoNWuSGUQggb+q2QKrcQ3gv5VhTWrvKlU1jgfO4mZe5Hb+QUtv9B2JduOCn0s9xim7kql9gWEL4l5JES3vGBNvaBvW/sBbYlVe4kVIW1KMxoDw15Rche4b0qf8SgfZhmuXSTspZKa5XPCHM3KanZc9c2BYQlIb/uum1Slcf8T7Sxpx2NncukXD9EeCl9OOGwElY4SQrfcCbrqrIqPHYQag4ruRwGcu50O6cqb9zl8FgIt9LYueTwIv1L4voNxWskW8umJHYAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ascii table\" title=\"\" src=\"/static/55b14704e00c60b3167cd812dcd52258/e9bf8/ascii-table.png\" srcset=\"/static/55b14704e00c60b3167cd812dcd52258/69538/ascii-table.png 160w,\n/static/55b14704e00c60b3167cd812dcd52258/72799/ascii-table.png 320w,\n/static/55b14704e00c60b3167cd812dcd52258/e9bf8/ascii-table.png 349w\" sizes=\"(max-width: 349px) 100vw, 349px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>위 테이블을 보면 영어 대문자 그룹(65 ~ 90)과 소문자 그룹(97 ~ 122) 사이에 <code class=\"language-text\">[</code>나 <code class=\"language-text\">^</code>과 같은 특수 문자들이 포함되어 있는 것을 볼 수 있는데, 정규식은 이 아스키 코드를 기반으로 작동하기 때문에 영어만 잡아내고 싶다고 <code class=\"language-text\">a-Z</code>와 같은 범위로 문자열 그룹을 잡아버리면 저 사이에 있는 특수문자들까지도 그룹에 포함되어버린다.</p>\n<p>그래서 필자는 영어만 따로 걸러내기 위해 <code class=\"language-text\">a-z</code>와 <code class=\"language-text\">A-Z</code> 범위를 구분해서 정규식에 표현해준 것이다.</p>\n<p>이런 식으로 아스키 코드에 대한 지식이 있다면 <code class=\"language-text\">-</code> 문자 범위 키워드를 사용하여 손 쉽게 원하는 문자열의 그룹을 만들어 낼 수 있고, 사실 아스키 코드에 대해 잘 모르더라도 구글에 “Ascii Table”이라고 검색하면 저런 코드표가 쏟아져 나오기 때문에 그냥 저 테이블을 보면서 정의해도 된다.</p>\n<p>하지만 매번 이렇게 그룹을 직접 설정하는 것 또한 어찌보면 귀찮은 일이다. <small><del>(개발자는 게으를수록 일을 잘 하…)</del></small> 그래서 정규식은 친절하게도 사용자가 매번 이렇게 직접 그룹을 정의하지 않아도 되도록 미리 정의된 몇 가지 그룹을 지원한다.</p>\n<h4 id=\"code-classlanguage-textcode\" style=\"position:relative;\"><code class=\"language-text\">.</code><a href=\"#code-classlanguage-textcode\" aria-label=\"code classlanguage textcode permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>새로운 라인을 의미하는 <code class=\"language-text\">\\n</code> 이스케이프를 제외한 모든 문자 하나를 의미한다. 즉, 그 문자가 무엇이든 상관없이 그냥 문자라면 모두 매칭한다. 당연히 이 문자라는 것의 정의에는 공백도 포함하기 때문에 <code class=\"language-text\">I am Evan</code>과 같이 공백을 포함한 문자열에 <code class=\"language-text\">.</code> 캐릭터 클래스를 사용한다면 공백도 포함하여 검색된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 문자열의 시작부터 4글자 매칭해!</span>\n<span class=\"token string\">'I am Evan'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^....</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"I am\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>만약 이 캐릭터 클래스를 앞서 말한 커스텀 그룹으로 표현하려면 아스키 코드에서 <code class=\"language-text\">\\n</code>를 제외한 모든 문자를 대괄호 안에 넣어야한다는 이야기인데, 이건 당연히 불가능하다. 그래서 이런 캐릭터 클래스를 잘 사용하는 것이 정규식을 편하게 작성할 수 있는 첫 걸음이라고 하는 것이다.</p>\n<h4 id=\"code-classlanguage-textdcode-code-classlanguage-textdcode-클래스\" style=\"position:relative;\"><code class=\"language-text\">\\d</code>, <code class=\"language-text\">\\D</code> 클래스<a href=\"#code-classlanguage-textdcode-code-classlanguage-textdcode-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"code classlanguage textdcode code classlanguage textdcode 클래스 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">d</code> 키워드는 Digit, 즉 숫자를 표현하는 문자를 의미한다. 이 숫자 또한 아스키 코드 상으로는 <code class=\"language-text\">0</code> ~ <code class=\"language-text\">9</code>(33 ~ 52)인 문자를 의미하기 때문에, II나 五와 같은 문자는 숫자로 판단되지 않는다.</p>\n<p>소문자인 <code class=\"language-text\">\\d</code> 키워드는 숫자에 해당하는 문자를, 대문자인 <code class=\"language-text\">\\D</code>는 숫자가 아닌 문자를 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'010-1111-1111'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\d</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// -를 제외한 0-9까지의 문자가 매칭된다</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h4 id=\"code-classlanguage-textwcode-code-classlanguage-textwcode-클래스\" style=\"position:relative;\"><code class=\"language-text\">\\w</code>, <code class=\"language-text\">\\W</code> 클래스<a href=\"#code-classlanguage-textwcode-code-classlanguage-textwcode-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"code classlanguage textwcode code classlanguage textwcode 클래스 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">w</code> 캐릭터 클래스는 Word를 의미한다. 이때 정규식에서 정의하는 Word라는 녀석들은 아스키 코드 상으로 <code class=\"language-text\">A</code> ~ <code class=\"language-text\">Z</code>(65 ~ 90), <code class=\"language-text\">a</code> ~ <code class=\"language-text\">z</code>(97 ~ 122), 그리고 앞서 설명한 <code class=\"language-text\">\\d</code>(숫자) 그룹에 해당하는 녀석들이다.</p>\n<p>즉, 저 아스키 코드 범위에 포함되지 않는 한글, 키릴 문자 등은 Word가 아니므로 <code class=\"language-text\">\\w</code> 키워드로는 잡아낼 수 없다는 점을 주의해야한다. 이 녀석도 <code class=\"language-text\">d</code> 클래스와 마찬가지로 소문자인 <code class=\"language-text\">\\w</code>는 Word인 문자를 의미하고, 대문자인 <code class=\"language-text\">\\W</code>는 Word가 아닌 문자를 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'Phone(전화): 010-0000-1111'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\w</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// :과 -, 그리고 한글은 Word에 포함되지 않으므로 영어와 숫자만 매칭된다 </span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"P\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"o\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"n\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"e\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h4 id=\"code-classlanguage-textscode-code-classlanguage-textscode-클래스\" style=\"position:relative;\"><code class=\"language-text\">\\s</code>, <code class=\"language-text\">\\S</code> 클래스<a href=\"#code-classlanguage-textscode-code-classlanguage-textscode-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"code classlanguage textscode code classlanguage textscode 클래스 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">s</code> 키워드는 Space라는 의미이며, 말 그대로 공백 문자를 의미한다. <code class=\"language-text\">s</code> 키워드도 다른 녀석들과 마찬가지로 소문자인 <code class=\"language-text\">\\s</code>는 공백인 문자, 대문자인 <code class=\"language-text\">\\S</code>는 공백이 아닌 문자를 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'Hi, my name is Evan'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\s</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 위 문자열에 존재하는 4개의 공백이 매칭된다</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"문자가-아닌-경계를-잡아내는-앵커\" style=\"position:relative;\">문자가 아닌 경계를 잡아내는 앵커<a href=\"#%EB%AC%B8%EC%9E%90%EA%B0%80-%EC%95%84%EB%8B%8C-%EA%B2%BD%EA%B3%84%EB%A5%BC-%EC%9E%A1%EC%95%84%EB%82%B4%EB%8A%94-%EC%95%B5%EC%BB%A4\" aria-label=\"문자가 아닌 경계를 잡아내는 앵커 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>앞서 우리가 살펴보았던 키워드들은 모두 하나의 문자를 의미하는 키워드들이었지만, 정규식은 특정 문자가 아닌, 문자와 문자 간의 경계를 매칭할 수 있는 기능 또한 제공한다.</p>\n<p>이렇게 경계를 잡아내는 키워드들을 “앵커”라고 부른다. 앵커는 단지 경계만을 의미하기 때문에 보통 단독으로 쓰이기 보다는 캐릭터 클래스와 함께 조합하여 특정 경계 뒤나 앞에 위치하는 문자를 잡아내는 방식으로 사용된다.</p>\n<p>앵커는 말 그대로 “경계” 그 자체를 잡아내는 것이기 때문에 앵커만 단독으로 사용하게 된다면 매칭 결과로 길이가 <code class=\"language-text\">0</code>인 문자열이 반환된다.</p>\n<h4 id=\"code-classlanguage-textcode-code-classlanguage-textcode-앵커\" style=\"position:relative;\"><code class=\"language-text\">^</code>, <code class=\"language-text\">$</code> 앵커<a href=\"#code-classlanguage-textcode-code-classlanguage-textcode-%EC%95%B5%EC%BB%A4\" aria-label=\"code classlanguage textcode code classlanguage textcode 앵커 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">^</code> 앵커는 문자열이 시작하는 경계, <code class=\"language-text\">$</code>는 문자열이 끝나는 경계를 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// ^(문자열 시작 경계) 바로 뒤에 위치한 문자만 매칭해라</span>\n<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Evans Library</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^.</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"E\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Evans Library\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// $(문자열 끝 경계) 바로 앞에 위치한 문자만 매칭해라</span>\n<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Evans Library</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"y\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Evans Library\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>당연한 이야기겠지만 문자열의 시작 경계인 <code class=\"language-text\">^</code> 앞에 위치하는 문자나, 문자열의 끝 경계인 <code class=\"language-text\">$</code> 뒤에 위치하는 문자라는 것은 존재할 수 없기 때문에 <code class=\"language-text\">.^</code>이나 <code class=\"language-text\">$.</code>과 같은 표현식은 아무것도 매칭할 수가 없다.</p>\n<h4 id=\"code-classlanguage-textbcode-code-classlanguage-textbcode-앵커\" style=\"position:relative;\"><code class=\"language-text\">\\b</code>, <code class=\"language-text\">\\B</code> 앵커<a href=\"#code-classlanguage-textbcode-code-classlanguage-textbcode-%EC%95%B5%EC%BB%A4\" aria-label=\"code classlanguage textbcode code classlanguage textbcode 앵커 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">b</code> 키워드는 Boundary를 의미하며, 이 바운더리라는 녀석은 Word 그룹으로 이루어진 단어 간의 모든 경계를 의미한다. 즉, 쉽게 말하자면 문자열의 시작과 끝 경계를 의미하는 <code class=\"language-text\">^</code>이나 <code class=\"language-text\">$</code> 앵커의 상위호환이라고 볼 수 있다.</p>\n<p>이 앵커를 사용할 때 주의해야할 점은 “Word 그룹으로 이루어진 단어”이기 때문에 <code class=\"language-text\">\\w</code> 그룹에 포함되는 영어나 숫자에만 한정되는 이야기라는 것이다.</p>\n<p>문자열의 시작과 끝이라는 명확한 정의와는 다르게 막연하게 단어 간의 경계라고만 이야기하면 조금 이해가 안될 수도 있는데, 직접 예시를 보면 생각보다 그렇게 어렵지 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'abc def'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 예시에서 필자는 <code class=\"language-text\">\\b</code> 키워드를 사용하여 <code class=\"language-text\">abc def</code>라는 문자열 내의 모든 단어 경계를 잡아냈다. 그리고 그 결과물을 보면 모두 길이가 <code class=\"language-text\">0</code>인 문자열이 나온 것을 알 수 있다. 앞서 이야기했듯이 경계라는 것은 어떤 문자가 아니기 때문에 길이가 없다고 보는 것이다.</p>\n<p>방금 필자가 예시로 사용한 <code class=\"language-text\">abc def</code>라는 문자열 내의 단어들 간의 경계는 다음과 같다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6d1779cbaba0a0243ed42fc5d27d3228/d56e1/boundaries.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 41.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABfUlEQVR42l2STU/bQBCG+cP0wC0SIHEoKkINCIEg6qlqqoo4uXDhBodElIiI8Bc4cIjrxHYcf+56H2btJKS80uyu57HfGY+9hSiYpcy8BG8Sk8aFTWFMtRFHBaGfMQ+yNVvJMpsP/ZRkUbMtu+SpJgpzFvOcoig/GeZM3RhfCtrzptJEVY3UbMPQqshLTFm7lEphJKqz5LQqURK2iJHFMqN1zXXNV1obqlwLtKYSYYj2PHlIoSWnpGvLjeVipF0XPZvZamv+Ybh8NZUW/HscMh0OGToOb4MB8/GY17t7ijCiFP7WH/DY6eDKPYuXF0a9Ln+dHiZbzla6rwwrz0Lz1HG42N3lx8EBPw8PcU6aPF93IIoJJh7d702u9ve53Nvj5vyCr1+26f9qyzCzDUM7h2W7vbMzvu3scN1sitkJf46PGUlH5DmhjOD30RFtidNGg367zW2rhfvwUPH/DFfKZHZZEJD6PrFEKtfBZLL+5NF0WnMJuxPHmCT5+CWAd1F4UjIJMUWSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"boundaries\" title=\"\" src=\"/static/6d1779cbaba0a0243ed42fc5d27d3228/6af66/boundaries.png\" srcset=\"/static/6d1779cbaba0a0243ed42fc5d27d3228/69538/boundaries.png 160w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/72799/boundaries.png 320w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/6af66/boundaries.png 640w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/d9199/boundaries.png 960w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/d56e1/boundaries.png 1130w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>복잡하게 생각할 것 없이 각 단어의 경계가 어디인지 생각해보면 된다</small>\n</center>\n<p>이에 반해 대문자인 <code class=\"language-text\">\\B</code> 키워드는 단어 간의 경계가 아닌 부분을 잡아낸다. 쉽게 이야기하면 단어가 끝나지 않는 경계 부분을 잡아낸다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'abc def'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\B</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이번에도 이전과 같이 4개의 경계가 뽑혀져 나왔지만 이번에는 이 경계들의 의미하는 바가 전혀 다르다. 이번에 뽑혀져 나온 경계는 “단어가 끝나지 않은 부분의 경계”이기 때문이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/97a4fb713d83f95c04382b7fb6b20106/748b0/boundaries2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACMklEQVR42m2S208TURDG96/knQfriwkQCbEl4QHCTYWIwUQESV8AjZBwMUYNofhgBRoCGKFSWygUaekFCnS3ezv9OdsCyUYm2d05+818852Z0RBTbo3c32tKZzq5k2sKZxX0is19Zug2F0WDy/Mq5wUD/cpCqdodrnmvmpw9sFyqcnlhUhLfrDp+ppsc/doim7miKMXPPBF5A9dRfkLPHFvdAZbp1ovcZ54ay2wUcyTetpQP124zPULbdv8nvHVuvq6r6vgtoSM5SjClGsRaTQ6u62DJFb0AJb5p2KJWAl3Xr07Ojvz3FCrlijoH2/S3RrNSKUj+wdj7TTLyDZVKcvVzDzeZRCUS2Pl8Q025DIKdrm9w+iMGhweY8f36s7m4yH4k4vUDrbi2xvL4G+JLn3jW3sH04CCl7xtEp6ZZHhvDOT5uqCsU2F+YJ/ggwMb7WdZnpvk1v0js3Qc6mpvZmZuTXllo6dVVeltaGHjcznhPD+G+Pp53PGGit5f01y9U0+k6YV5u8ioUItw/wItgJ6GHAUZCncwMDRMMBMisrIBpon2emOBRUxOjwSBvu7t53dXFwssRRiU5Gg5jHx3VCS+EeLi1ladtbUz199MpJJHJSRIfl5gdGkLt7ODoOlo1l+Nwa4vLgwOy29skolFq2Swnu7ukNjdlk42bvXI4jcc5lBg7k+E4FiMrJIYUKku/LeGp9/Bub2XatVIJVSziVir+lcG/QkqKKBmWkkHVHP+U/wHruB77k5EMYwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"boundaries2\" title=\"\" src=\"/static/97a4fb713d83f95c04382b7fb6b20106/6af66/boundaries2.png\" srcset=\"/static/97a4fb713d83f95c04382b7fb6b20106/69538/boundaries2.png 160w,\n/static/97a4fb713d83f95c04382b7fb6b20106/72799/boundaries2.png 320w,\n/static/97a4fb713d83f95c04382b7fb6b20106/6af66/boundaries2.png 640w,\n/static/97a4fb713d83f95c04382b7fb6b20106/748b0/boundaries2.png 868w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>단어가 끝나지 않은 부분의 경계</small>\n</center>\n<p>즉, <code class=\"language-text\">b</code> 키워드는 다른 키워드들과 다르게 어떤 하나의 문자를 매칭하는 것이 아니라 경계를 잡아내는 것이기 때문에, 이 특징만 잘 기억하고 있으면 은근히 여기저기 잘 써먹을 수 있다.</p>\n<h3 id=\"정규식의-옵션-기능-플래그\" style=\"position:relative;\">정규식의 옵션 기능, 플래그<a href=\"#%EC%A0%95%EA%B7%9C%EC%8B%9D%EC%9D%98-%EC%98%B5%EC%85%98-%EA%B8%B0%EB%8A%A5-%ED%94%8C%EB%9E%98%EA%B7%B8\" aria-label=\"정규식의 옵션 기능 플래그 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>정규식을 보다보면 종종 정규식의 맨 뒤에 <code class=\"language-text\">/정규식/g</code>와 같이 <code class=\"language-text\">g</code>, <code class=\"language-text\">i</code>, <code class=\"language-text\">m</code> 등의 문자가 추가로 붙는 것을 발견할 수 있는데, 이 친구들은 일종의 옵션 기능 역할을 가지고 있는 “플래그”이다.</p>\n<p><code class=\"language-text\">/</code>를 사용하여 정규식을 리터럴 선언하는 하는 경우가 아니라 <code class=\"language-text\">new RegExp()</code> 생성자를 호출하여 정규식을 사용하는 경우에는 생성자 함수의 두번째 인자로 플래그를 살포시 넣어주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">정규식</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gi</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regex2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">정규식</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'gi'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 이 두 개는 같은 패턴을 가진 정규식이다</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">===</span> regex2<span class=\"token punctuation\">.</span>flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>정규식은 <code class=\"language-text\">g</code>, <code class=\"language-text\">i</code>, <code class=\"language-text\">m</code>, <code class=\"language-text\">s</code>, <code class=\"language-text\">u</code>, <code class=\"language-text\">y</code> 총 6개의 플래그를 제공하고 있지만, 이 포스팅에서는 이 중 가장 많이 사용되는 <code class=\"language-text\">g</code>와 <code class=\"language-text\">i</code>, 그리고 <code class=\"language-text\">m</code> 플래그에 대해서만 간단하게 설명할 예정이니, 나머지 플래그가 궁금하다면 구글링을 해보도록 하자.</p>\n<h4 id=\"code-classlanguage-textgcode-플래그\" style=\"position:relative;\"><code class=\"language-text\">g</code> 플래그<a href=\"#code-classlanguage-textgcode-%ED%94%8C%EB%9E%98%EA%B7%B8\" aria-label=\"code classlanguage textgcode 플래그 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">g</code> 플래그는 <code class=\"language-text\">global</code>의 약자로, 이 플래그를 가지고 있는 정규식은 주어진 문자열 내에서 패턴과 매칭되는 모든 부분을 찾아낸다. 만약 <code class=\"language-text\">g</code> 플래그가 없다면 정규식은 문자열 내에서 가장 처음 매칭되는 한 부분만을 찾아낼 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'hello, world'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'hello, world'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"hello, world\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"e\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"l\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"l\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"o\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\",\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"w\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"o\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"r\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"l\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"d\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>기본적으로 글로벌 매칭을 의미하는 플래그인 <code class=\"language-text\">g</code> 플래그가 없다면 정규식은 단 하나의 문자만을 매칭하지만, <code class=\"language-text\">g</code> 플래그를 사용하면 문자열 내에서 해당 정규식에 매칭되는 모든 문자를 찾아낸다. 글로벌 플래그에 관한 것은 필자가 굳이 설명하지 않아도 콘솔에서 몇 번 해보다보면 감이 올테니 자세히 설명하지는 않겠다.</p>\n<h4 id=\"code-classlanguage-texticode-플래그\" style=\"position:relative;\"><code class=\"language-text\">i</code> 플래그<a href=\"#code-classlanguage-texticode-%ED%94%8C%EB%9E%98%EA%B7%B8\" aria-label=\"code classlanguage texticode 플래그 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">i</code> 플래그는 <code class=\"language-text\">ignoreCase</code>의 약자로, 정규식 내에 사용된 문자열의 대소문자를 구분하지 않고 모두 매칭하겠다는 의미를 가진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">abcd</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">i</span></span><span class=\"token punctuation\">;</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abcd'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ABCD'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>일반적으로 유저의 입력을 통해 생성된 문자열은 <code class=\"language-text\">My name is Evan</code>, <code class=\"language-text\">my name is evan</code> 등과 같이 사람에 따라 대소문자의 사용 방법이 조금씩 다를 수 있지만, <code class=\"language-text\">i</code> 플래그를 사용하면 이런 걱정없이 맘 편하게 원하는 문자열을 찾아낼 수 있다.</p>\n<h4 id=\"code-classlanguage-textmcode-플래그\" style=\"position:relative;\"><code class=\"language-text\">m</code> 플래그<a href=\"#code-classlanguage-textmcode-%ED%94%8C%EB%9E%98%EA%B7%B8\" aria-label=\"code classlanguage textmcode 플래그 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p><code class=\"language-text\">m</code> 플래그는 <code class=\"language-text\">multiline</code>의 약자로, 말 그대로 여러 라인으로 구성된 문자열을 검사하겠다는 것을 의미한다. 하지만 한 가지 이상한 점은 딱히 이 플래그가 없어도 정규식은 여러 줄로 된 문자열을 잘 매칭한다는 것이다.</p>\n<p>한번 템플릿 스트링을 사용하여 여러 라인으로 구성된 문자열을 만들어보고 정규식을 사용하여 간단한 패턴을 잡아내보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> string <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">abcd\\nefgh\\nijkl</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\nstring<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\w{2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cd\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ef\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"gh\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ij\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"kl\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사실 정규식은 그냥 주어진 문자열 중에서 매칭되는 패턴을 찾아내는 녀석이기 때문에 굳이 <code class=\"language-text\">m</code> 플래그를 사용하지 않아도 여러 줄의 문자열도 잘 매칭한다.</p>\n<p>그렇다면 굳이 <code class=\"language-text\">m</code> 플래그가 필요한 이유가 무엇일까? 그 이유는 정규식이 바로 새로운 라인을 표현하는 <code class=\"language-text\">\\n</code> 이스케이프를 어떻게 바라보게 할 지 정할 수 있기 때문이다.</p>\n<p>이번에는 방금 작성했던 정규식에 문자열의 시작을 의미하는 <code class=\"language-text\">^</code> 앵커를 추가해서 단순히 <code class=\"language-text\">\\w</code> 그룹의 두 글자가 아닌 문자열의 시작 부분의 두 글자를 잡아보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">string<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\w{2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>단순히 <code class=\"language-text\">\\w</code> 그룹의 두 글자를 잡아낼 때와는 다르게 이번에는 <code class=\"language-text\">ab</code>만 뽑혀나오는 것을 확인할 수 있는데, 이는 문자열 내에서 <code class=\"language-text\">\\n</code> 이스케이프로 라인이 나누어져있더라도 정규식에게는 그저 하나의 문자열이라고 인식되기 때문이다.</p>\n<p>기본적으로 정규식은 하나의 문자열 객체를 기준으로 패턴을 매칭하기 때문에 전체 문자열의 첫 글자인 <code class=\"language-text\">a</code> 앞에 있는 경계만 문자열의 시작(<code class=\"language-text\">^</code>)이라고 판단한 것이다.</p>\n<p>바로 이런 상황일 때 <code class=\"language-text\">m</code> 플래그를 사용하면 이전과는 다른 결과를 만들어낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">string<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\w{2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gm</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ef\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ij\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>쨘, 이번에는 하나의 문자열이 아니라 <code class=\"language-text\">\\n</code> 이스케이프를 기준으로 각각 별도의 문자열로 평가되어 정규식이 적용되는 것을 볼 수 있다. 즉, <code class=\"language-text\">m</code> 플래그는 단순히 여러 줄의 문자열을 검사한다는 의미가 아니라 <code class=\"language-text\">\\n</code> 이스케이프 문자를 기준으로 라인을 나누어 각각의 문자열을 하나의 검사 대상으로 보겠다는 의미인 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/69dd01cadc54feeecd2154af66259484/35751/multiline.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACVUlEQVR42m1Ta08aQRTdf84fwU8mtSQWaCMULfUBRogCAkKoqAhqdBeFfTA7uzszcHpnfETSTkLYnTn3zDnn3rUSKRHHMYRSUPRLkgRRFEGIBMvlEp+XovfkDaPx+lwIgTiJzZ6ut17abbgnJ7g+O0OTngs7Oziu1hCGkblIr9VqZf7jMMRLpwOvXsdVs4n2xQW+5/PodC4Iz40Qy97dRdBoYFCpoFQuI5/PonrYwPXAgZRindB14RSLBt/e30eRajOZr6hVu7j5Q3glYAmyzBiD7/vgnGOxWIBHHEEQGDuflyRLnPY4KY0Iqx3oGq2MsfDV8tHREba2tlCkm0ulEj1/wehmgkXATC5rCumS+WBgLE/Oz/GjUEA2m8XTo01CXvFWOp3G6empIUulUjg4+I3acRtXA/sfy9F0CodiiUYj/KSsNb5c/oX6cZci0ngi9DzPME8mE3S7Xbju3NjWEfzPckjx6MkY396i1+sZbEgRaIVKSVgVasbl5SU2NzfRarWwt7dHpK4BfhC+KUxozx0Owe/vcU5NOSO8jiyk/BidGcu5XA79fh8bGxsoUCZ6bB6oQDfqnfDDMqmeUjyc3BxubyPzLWtqHNs2AnSTrJgG+O5ubCzqLoXU4YT25FJ9EL2vJb0LPdTPU0jqrqCMtV0dgcbrc0u6HnhMXwCXCJgA8wjoh5BzD0up1iyv9Kj4NGJMIY4UXD+GZPSVzTwIL4CKKcPYdvA4DWHfeXh0GJyHOfjTM4LhmIrDNctqNgMnwvHEx8xmGI3niGYLsNsHzPsj8FmAv+izel8PUmvHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"multiline\" title=\"\" src=\"/static/69dd01cadc54feeecd2154af66259484/6af66/multiline.png\" srcset=\"/static/69dd01cadc54feeecd2154af66259484/69538/multiline.png 160w,\n/static/69dd01cadc54feeecd2154af66259484/72799/multiline.png 320w,\n/static/69dd01cadc54feeecd2154af66259484/6af66/multiline.png 640w,\n/static/69dd01cadc54feeecd2154af66259484/35751/multiline.png 873w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>m 플래그가 있냐 없냐에 따라 각각의 라인을 통합하여<br>하나의 문자열로 볼 것인지, 각각의 문자열로 볼 것인지가 결정된다.</small>\n</center>\n<p><code class=\"language-text\">m</code> 플래그 같은 경우는 짧은 문자열을 다루는 상황보다는 개행이 포함된 긴 문자열을 다루는 상황일 때 사용하게 되는데, 필자 또한 비즈니스 내에서 유저의 간단한 입력을 검사하는 경우보다는 행이 변경될 때마다 가장 첫 글자를 대문자로 적어야하는 영문법을 검사한다던가, 비압축 파일을 파싱한다던가 하는 경우에 주로 사용했었던 것 같다.</p>\n<h3 id=\"패턴이-몇-번이나-나왔는지-찾아주는-수량자\" style=\"position:relative;\">패턴이 몇 번이나 나왔는지 찾아주는 수량자<a href=\"#%ED%8C%A8%ED%84%B4%EC%9D%B4-%EB%AA%87-%EB%B2%88%EC%9D%B4%EB%82%98-%EB%82%98%EC%99%94%EB%8A%94%EC%A7%80-%EC%B0%BE%EC%95%84%EC%A3%BC%EB%8A%94-%EC%88%98%EB%9F%89%EC%9E%90\" aria-label=\"패턴이 몇 번이나 나왔는지 찾아주는 수량자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>방금 전 예시에서 필자는 <code class=\"language-text\">\\w</code> 그룹의 두 글자를 찾아내기 위해 <code class=\"language-text\">{2}</code>라는 표현을 사용했었다. 이 표현은 바로 앞에 오는 표현의 반복 횟수를 의미하는데, <code class=\"language-text\">{0,2}</code>처럼 최소, 최대 반복 횟수를 사용하여 반복되는 범위를 표현해줄 수도 있다.</p>\n<p>이렇게 앞에 위치한 패턴이 몇 번이나 일치하는지를 잡아낼 수 있는 표현을 수량자라고 한다.</p>\n<h4 id=\"반복되는-횟수를-명시해보자\" style=\"position:relative;\">반복되는 횟수를 명시해보자<a href=\"#%EB%B0%98%EB%B3%B5%EB%90%98%EB%8A%94-%ED%9A%9F%EC%88%98%EB%A5%BC-%EB%AA%85%EC%8B%9C%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"반복되는 횟수를 명시해보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'aaaabbbcc'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\w{3}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"abb\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bcc\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>필자가 사용한 <code class=\"language-text\">\\w{3}</code>이라는 표현은 단순히 Word 그룹이 3번 반복되는 패턴을 찾으라는 표현이기 때문에, 정규식은 문자열 전체에서 Word 그룹이 3번 반복되고 있는 케이스를 뽑아내고 있는 것을 볼 수 있다.</p>\n<p>사실 반복이라는 패턴은 굉장히 여러 곳에 응용될 수 있는데, 그 중 대표적인 예가 바로 전화번호나 주민등록번호처럼 같은 그룹의 문자가 일정 횟수 이상 반복되는 것이 정해져있는 정보이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'010-0101-0101'</span>\n<span class=\"token string\">'02-0101-0101'</span>\n<span class=\"token string\">'031-010-0101'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>대한민국의 전화번호는 대부분 이 3가지 패턴 안에서 결정되는데, 휴대폰 번호같은 경우 반드시 맨 앞에는 3자리의 통신사 식별번호가 위치하고 그 뒤에는 4자리의 전화번호 필드가 두 번 반복되는 형태를 가지며, 그 외 유선전화는 2-3자리의 지역번호 뒤로 3-4 자리의 필드와 4자리의 필드가 반복되는 형태를 가진다.</p>\n<p>이런 경우 수량자를 사용하면 간단하게 원하는 패턴을 잡아낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 휴대폰 번호를 잡아내는 패턴</span>\n<span class=\"token operator\">/</span><span class=\"token number\">01</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">|</span><span class=\"token number\">1</span><span class=\"token operator\">|</span><span class=\"token number\">6</span><span class=\"token operator\">|</span><span class=\"token number\">8</span><span class=\"token operator\">|</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 패턴을 보고 나이가 어리신 분들은 “왜 <code class=\"language-text\">010</code>으로 안 잡고 굳이 저런 숫자들을 넣어주는거지?”라는 의문을 가지실 수도 있는데…</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b89f9481679525d129c49f370f62a88d/41099/old_phone.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQDBQL/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABroz5g9t7JJoTVAqf/8QAGhAAAwEAAwAAAAAAAAAAAAAAAQIDABESIv/aAAgBAQABBQK1erTcUGunOmXlVSHFD6M1eYAUf//EABcRAQADAAAAAAAAAAAAAAAAABABETH/2gAIAQMBAT8BonD/xAAXEQEAAwAAAAAAAAAAAAAAAAAQAREx/9oACAECAQE/AbI0/8QAHBAAAgICAwAAAAAAAAAAAAAAAAEQESFRAhLB/9oACAEBAAY/AlsxFbFhv0vi7UdWUlSP/8QAHBABAAIDAAMAAAAAAAAAAAAAAQARITFBYXGh/9oACAEBAAE/IcEGn2LnnYyoRs1x7iE2NhAW4RleJwDvG4QEHCf/2gAMAwEAAgADAAAAEOMIAP/EABgRAAIDAAAAAAAAAAAAAAAAAAEQESEx/9oACAEDAQE/EDSVgv/EABgRAAIDAAAAAAAAAAAAAAAAAAEQESEx/9oACAECAQE/EBaFov/EAB0QAQACAgMBAQAAAAAAAAAAAAEAESFBMVFhcaH/2gAIAQEAAT8QAt9zTgOuq91La8qBkjlxMMA2jpLOI6I3Xu/IRTgJARcVCEwb1ZUHefz5DLBQNBP/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"old phone\" title=\"\" src=\"/static/b89f9481679525d129c49f370f62a88d/41099/old_phone.jpg\" srcset=\"/static/b89f9481679525d129c49f370f62a88d/0913d/old_phone.jpg 160w,\n/static/b89f9481679525d129c49f370f62a88d/cb69c/old_phone.jpg 320w,\n/static/b89f9481679525d129c49f370f62a88d/41099/old_phone.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>한국인의 통신채널, 스피드 011...</small>\n</center>\n<p>사실 휴대폰 통신사 식별번호는 <code class=\"language-text\">010</code>만 있는 것이 아니다. 예전에는 <code class=\"language-text\">011</code>, <code class=\"language-text\">016</code>, <code class=\"language-text\">018</code> 등 다양한 통신사 식별번호가 있었다가 나중에 <code class=\"language-text\">010</code>으로 통합된 것이라 아직도 이런 구 식별번호를 사용하시는 분들이 있을 수도 있기 때문에 이런 로직을 작성할 때는 주의하도록 하자. <small><del>(이제 이거 알면 빼박 늙었다는 증거…)</del></small></p>\n<h4 id=\"원하는-패턴이-한번-이상-출현했는지-알아보자\" style=\"position:relative;\">원하는 패턴이 한번 이상 출현했는지 알아보자<a href=\"#%EC%9B%90%ED%95%98%EB%8A%94-%ED%8C%A8%ED%84%B4%EC%9D%B4-%ED%95%9C%EB%B2%88-%EC%9D%B4%EC%83%81-%EC%B6%9C%ED%98%84%ED%96%88%EB%8A%94%EC%A7%80-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\" aria-label=\"원하는 패턴이 한번 이상 출현했는지 알아보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>이렇게 정규식은 간단하게 반복되는 횟수를 명시하여 수량자 앞에 위치한 패턴이 얼마나 반복되었는지를 표현할 수 있지만, 이 수량자는 너무 명확한 표현이라서 “있거나 없을 수도 있다”라던가 “n개 이상 등장”과 같은 추상적인 패턴을 표현하기에는 적합하지않다.</p>\n<p>그렇기 때문에 정규식은 n개 이상과 같이 조금 더 추상적인 패턴의 등장 횟수를 매칭할 수 있는 수량자들 또한 제공해주고 있다.</p>\n<h5 id=\"code-classlanguage-textcode-수량자\" style=\"position:relative;\"><code class=\"language-text\">*</code> 수량자<a href=\"#code-classlanguage-textcode-%EC%88%98%EB%9F%89%EC%9E%90\" aria-label=\"code classlanguage textcode 수량자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p><code class=\"language-text\">*</code> 수량자는 이전에 등장한 패턴이 0회 이상 등장하는지 여부를 나타내는 수량자이다. 0회 이상이란 표현이 조금 애매할 수 있는데, 조금 더 풀어서 이야기하면 이 수량자 앞에 위치한 패턴은 등장하지 않을 수도 있고 여러 번 반복될 수도 있다는 뜻이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// b 앞에 위치한 a는</span>\n<span class=\"token comment\">// 없어도 되고 여러 번 나와도 다 잡아라!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">a*b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">'b'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'ab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'aab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'aab'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">*</code> 수량자 앞에 위치한 패턴은 아무리 많이 등장해도 전부 잡히기 때문에 <code class=\"language-text\">a</code>의 갯수가 아무리 늘어난다하더라도 모두 잡아낼 수 있게된다.</p>\n<h5 id=\"code-classlanguage-textcode-수량자-1\" style=\"position:relative;\"><code class=\"language-text\">?</code> 수량자<a href=\"#code-classlanguage-textcode-%EC%88%98%EB%9F%89%EC%9E%90-1\" aria-label=\"code classlanguage textcode 수량자 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p><code class=\"language-text\">?</code> 수량자는 이전에 등장한 패턴이 0 또는 1회 등장하는지 여부를 나타내는 수량자이다. <code class=\"language-text\">*</code> 수량자와는 다르게, <code class=\"language-text\">?</code> 수량자 앞에 위치한 패턴은 아무리 많이 등장하더라도 단 한 개만 잡아낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// b 앞에 위치한 a는</span>\n<span class=\"token comment\">// 없어도 되고 여러 번 나와도 1개만 잡아라!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">a?b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">'b'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'ab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'aab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h5 id=\"code-classlanguage-textcode-수량자-2\" style=\"position:relative;\"><code class=\"language-text\">+</code> 수량자<a href=\"#code-classlanguage-textcode-%EC%88%98%EB%9F%89%EC%9E%90-2\" aria-label=\"code classlanguage textcode 수량자 2 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p><code class=\"language-text\">+</code> 수량자는 이전에 등장한 패턴이 반드시 한 번 이상 등장해야한다는 것을 의미한다. 즉 <code class=\"language-text\">+</code> 수량자 앞에 위치한 패턴이 등장하지 않는다면 매칭에 실패하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// b앞에 위치한 a는</span>\n<span class=\"token comment\">// 반드시 존재해야하고 여러 번 나와도 다 잡아라!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">a+b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">'b'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'ab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'aab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'aab'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">+</code> 수량자의 의미를 조금 더 쉽게 설명해보자면 “몇 번이든 좋으니까 있기만 하면 된다”라는 의미이기 때문에 문자열 중에서 반드시 존재해야하는 문자를 잡아낼 때 유용하게 사용할 수 있다.</p>\n<h2 id=\"알면-더-효율적인-기능들\" style=\"position:relative;\">알면 더 효율적인 기능들<a href=\"#%EC%95%8C%EB%A9%B4-%EB%8D%94-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EA%B8%B0%EB%8A%A5%EB%93%A4\" aria-label=\"알면 더 효율적인 기능들 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 정규식이 제공하는 기본적인 기능인 캐릭터 클래스, 앵커, 플래그 그리고 수량자에 대해 알아보았다. 사실 이 정도만 알고 있어도 일반적인 비즈니스 상황에서 정규식을 사용하는데에는 큰 무리가 없지만, 간혹 이 기능만으로는 처리가 귀찮은 상황들이 터지게 된다.</p>\n<p>지금부터는 조금 더 편하게 정규식을 사용하기 위해서 알고 있으면 좋은 기능들에 대한 이야기를 해보도록 하겠다.</p>\n<h3 id=\"패턴을-기억하는-캡처링\" style=\"position:relative;\">패턴을 기억하는 캡처링<a href=\"#%ED%8C%A8%ED%84%B4%EC%9D%84-%EA%B8%B0%EC%96%B5%ED%95%98%EB%8A%94-%EC%BA%A1%EC%B2%98%EB%A7%81\" aria-label=\"패턴을 기억하는 캡처링 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>정규식은 단순히 문자열 내에서 패턴을 매칭하기만 하는 것이 아니라, 매칭된 패턴을 기억하고 있을 수 있는 기능도 제공한다. 이렇게 패턴을 기억할 수 있는 기능은 문자열을 치환하는 작업을 진행할 때 변경되면 안 되는 부분과 변경되어야 하는 부분을 구분하여 원하는 부분만 바꿔치거나, 중복 입력된 부분을 찾는 등의 작업에서 꽤나 유용하게 사용된다.</p>\n<p>예를 들어 <code class=\"language-text\">$10000</code>과 같이 달러 단위를 의미하는 문자열이 있다고 생각해보자. 이 문자열을 잡아낼 수 있는 패턴은 무엇일까?</p>\n<p>길게 생각할 것도 없이 달러 단위를 의미하는 문자열은 <code class=\"language-text\">$</code> 뒤에 반드시 한 개 이상의 숫자가 위치하여야 정보성이 있다고 판단할 수 있기 때문에 간단하게 <code class=\"language-text\">$</code>문자와 그 뒤에 오는 1개 이상의 숫자를 잡아낼 수 있는 표현을 사용하면 우리는 원하는 패턴을 잡아낼 수 있다. <small>(그냥 <code class=\"language-text\">$</code>는 문자열의 끝을 나타내는 앵커이기 때문에 반드시 앞에 <code class=\"language-text\">\\</code>를 붙혀 이스케이핑해주는 것을 잊지말자)</small></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'$10000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\$\\d+</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"$10000\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>자, 이렇게 정규식을 통해 잡아낸 <code class=\"language-text\">$10000</code>라는 문자열을 <code class=\"language-text\">10000 달러</code>라는 문자열로 변경하고 싶다면 어떻게 할 수 있을까?</p>\n<p>간단하게 생각하면 <code class=\"language-text\">String.prototype.replace</code> 메소드를 사용하면 될 것 같지만, 위 정규식을 사용하여 잡아낸 패턴은 <code class=\"language-text\">$10000</code> 전체이기 때문에 <code class=\"language-text\">10000</code>이라는 문자만 그대로 유지하며 <code class=\"language-text\">$</code> 부분만 치환하는 것은 불가능하다.</p>\n<p>즉, 이 문제를 해결하기 위해서는 패턴을 매칭된 부분 중 특정 부분을 기억하는 기능이 필요한 것이다. 바로 이런 상황일 때 캡쳐링을 사용하면 문제를 쉽게 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 기억하고자 하는 부분을 괄호로 감싸자!</span>\n<span class=\"token operator\">/</span>\\<span class=\"token function\">$</span><span class=\"token punctuation\">(</span>\\d<span class=\"token operator\">+</span><span class=\"token punctuation\">)</span><span class=\"token operator\">/</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 표현이 이전 표현과 다른 점은 단지 <code class=\"language-text\">\\d+</code> 부분을 괄호로 감싼 것 뿐이지만, 이렇게 특정 표현을 괄호로 감싸게 되면 정규식은 이 부분을 캡쳐링하게 된다.</p>\n<p><code class=\"language-text\">String.prototype.replace</code> 메소드의 두 번째 인자는 치환될 문자열을 의미하는데, 이렇게 캡쳐링된 패턴은 치환될 문자열 내에서 <code class=\"language-text\">$n</code>이라는 특수한 표현으로 다시 불러올 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'$10000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\$(\\d+)</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'$1 달러'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">\"10000 달러\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">$1</code>은 단지 정규식 패턴 내에서 캡처링된 첫 번째 그룹을 의미하는 것이기 때문에 캡처링된 패턴이 늘어나면 <code class=\"language-text\">$2</code>나 <code class=\"language-text\">$3</code>처럼 두 번째, 세 번째 패턴을 계속 불러올 수도 있다.</p>\n<p>그리고 이렇게 특정한 패턴을 캡처하여 기억할 수 있는 기능은 반복되는 문자를 찾아내는 데에도 유용하게 사용될 수 있는데,  반복되는 문자라는 것 자체가 이전에 나타난 문자가 그 다음에 연속해서 다시 나타나는 것을 의미하기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(\\w)\\1</span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 정규식에서 필자는 <code class=\"language-text\">(\\w)</code> 표현을 사용하여 문자열 내의 Word 그룹에 속한 글자를 캡처링하였고, 이후 <code class=\"language-text\">\\1</code>이라는 표현을 사용하여 캡처링한 패턴을 다시 불러왔다.</p>\n<p>즉, <code class=\"language-text\">\\w</code>에 매칭된 패턴을 <code class=\"language-text\">\\1</code>을 통해 불러옴으로써 반복이라는 패턴을 표현할 수 있는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'aabccdeef'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(\\w)\\1</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cc\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ee\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이렇게 문자열 내에 동일한 문자가 반복되는 패턴을 찾아내는 표현은 <code class=\"language-text\">(.)\\1{2}</code>와 같이 수량자와 조합되어 “동일한 글자가 3번 이상 반복되면 안 됨”과 같은 비밀번호 검증 로직에 유용하게 사용되기도 한다.</p>\n<h3 id=\"greedy-vs-lazy\" style=\"position:relative;\">Greedy vs Lazy<a href=\"#greedy-vs-lazy\" aria-label=\"greedy vs lazy permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>앞서 우리는 1개 이상 존재하는 패턴을 매칭하는 <code class=\"language-text\">+</code> 수량자와 0개 이상 존재하는 패턴을 매칭하는 <code class=\"language-text\">*</code> 수량자에 대해 알아보았었다. 이렇게 n개 이상이라는 수량자를 사용하게 되면 패턴을 매칭할 때 약간은 애매한 부분이 생기게 되는데, 바로 이런 케이스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// &lt;, >으로 감싸진 모든 문자열을 찾아라!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.*></span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">\"&lt;p>This is p tag&lt;/p>\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"&lt;p>This is p tag&lt;/p>\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>필자가 사용한 정규식은 단지 <code class=\"language-text\">&lt;</code>, <code class=\"language-text\">></code>으로 감싸진 모든 문자열을 찾으라는 표현이기 때문에 <code class=\"language-text\">&lt;</code>과 <code class=\"language-text\">></code>으로 감싸진 <code class=\"language-text\">&lt;p>This is p tag&lt;/p></code> 전체를 잡아내는 게 당연한 것이 아닌가하고 생각할 수도 있지만, 사실 <code class=\"language-text\">&lt;</code>과 <code class=\"language-text\">></code>으로 감싸진 패턴은 저 하나만 존재하는 것이 아니다.</p>\n<p>바로 <code class=\"language-text\">&lt;p></code>와 <code class=\"language-text\">&lt;/p></code>도 위 정규식이 잡아낼 수 있는 범주에 들어가는 패턴이기 때문이다. 하지만 정규식은 기본적으로 <code class=\"language-text\">&lt;p>This is p tag&lt;/p></code>와 같이 최대한 길게 매칭되는 패턴을 잡도록 세팅되어있기 때문에, 결과가 이렇게 나오는 것이다.</p>\n<p>이때 이렇게 최대한 길게 매칭되는 패턴을 잡으려는 매칭 방법을 탐욕(Greedy) 매칭이라고 한다. 말 그대로 탐욕스럽게 최대한 길게 매칭되는 부분을 먹어버리는 것이다. <small>(매 순간 항상 최적의 선택을 하는 의미의 Greedy 알고리즘이랑은 용어만 같고, 사실 상 다른 개념이다)</small></p>\n<p>그렇다면 위 패턴을 사용하여 작은 매칭 단위인 <code class=\"language-text\">&lt;p></code>와 <code class=\"language-text\">&lt;/p></code>를 잡아내고 싶다면 어떻게 하면 될까?</p>\n<blockquote>\n<p>바로 정규식을 <strong>게으르게(Lazy)</strong> 만들면 된다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// &lt;, >으로 감싸진 모든 문자열을 게으르게 찾아라!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.*?></span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">\"&lt;p>This is p tag&lt;/p>\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"&lt;p>\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"&lt;/p>\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이전 표현과 비교했을 때 달라진 부분은 “0개 이상의 패턴”을 의미하는 <code class=\"language-text\">*</code> 수량자의 뒤 쪽에 <code class=\"language-text\">?</code>를 붙혔다는 것이다. 이렇게 게으른 매칭을 사용하게 되면 정규식은 매칭할 수 있는 패턴들 중 가능한 가장 짧은 패턴들을 찾게된다. 같은 표현을 가지고 패턴을 찾으라고 일을 시켰을 때, 최대한 짧은 패턴만 찾고 일을 마치려고 하니 게으르다고 표현하는 것이다.</p>\n<p>정리하자면 <code class=\"language-text\">*</code>나 <code class=\"language-text\">+</code>과 같이 n개 이상을 나타내는 수량자는 기본적으로 매칭할 수 있는 패턴 중 가장 긴 것을 탐욕(Greedy)스럽게 매칭하고, 이 수량자 뒤 쪽에 <code class=\"language-text\">?</code>를 붙히게 되면 게으르게(Lazy) 매칭할 수 있는 패턴 중 가장 짧은 것을 매칭하게 되는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Greedy</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token operator\">/</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.+></span><span class=\"token regex-delimiter\">/</span></span>\n\n<span class=\"token comment\">// Lazy</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token operator\">?</span><span class=\"token operator\">></span><span class=\"token operator\">/</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.+?></span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 Greedy, Lazy 매칭의 차이를 모르고 있다면 방금 전 예시의 <code class=\"language-text\">&lt;p>This is p tag&lt;/p></code> 처럼 매칭할 수 있는 패턴의 종류가 여러 개인 경우 원하는 패턴을 잡아낼 수 없으니, 이 차이를 잘 기억해두도록 하자.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 대학생 때 정규식을 처음 접하게 되었었는데, 당시 OBJ 파일을 <a href=\"https://threejs.org/\" target=\"_blank\" rel=\"nofollow\">ThreeJS</a> 객체로 표현하는 일종의 파서를 만들고 있었기 때문에 정규식을 상당히 하드하게 사용해야 했었던 기억이 난다. <small>(당시 ThreeJS에서 제공하는 OBJ Loader에 버그가 있었다 😢)</small></p>\n<p>OBJ 파일은 각 버텍스의 좌표와 텍스쳐의 UV 매핑 좌표, 그리고 각 버텍스들의 방향을 나타내는 노말 등을 다음과 같이 나타내는 파일이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"*.obj\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-*.obj line-numbers\"><code class=\"language-*.obj\"># 버텍스 좌표\nv -1.692615 -0.021714 -1.219301\nv 7.334266 -0.021714 -1.219302\nv 7.334265 0.021714 -1.219302\nv -1.692616 0.021714 -1.219301\nv -1.692616 -0.000000 -1.241016\nv 7.334265 0.000000 -1.241017\nv 7.334266 0.000000 -1.197588\nv -1.692615 -0.000000 -1.197587\n\n# 텍스처 UV 값\nvt 0.0000 0.0000\nvt 1.0000 0.0000\nvt 1.0000 1.0000\nvt 0.0000 1.0000\nvt 0.0000 0.0000\nvt 1.0000 0.0000\nvt 1.0000 1.0000\nvt 0.0000 1.0000\n\n# 버텍스의 노말 값\nvn -0.0000 -0.0000 -1.0000\nvn 0.0000 -1.0000 -0.0000\n\nusemtl Material.001\n\n# 각 페이스를 구성하는 버텍스의 인덱스들\nf 1/1/1 4/2/1 3/3/1 2/4/1\nf 8/5/2 5/6/2 6/7/2 7/8/2</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이때 필자는 이 파일을 읽어와 앞서 설명한 정규식의 <code class=\"language-text\">m</code> 플래그를 사용하여 각각의 라인 별로 나눈 후, <code class=\"language-text\">v</code>로 시작하면 버텍스 좌표, <code class=\"language-text\">vt</code>로 시작하면 텍스쳐의 uv, <code class=\"language-text\">vn</code>으로 시작하면 버텍스의 노말값 등으로 파싱을 해야했었는데, 물론 어렵고 복잡한 과정이기는 했지만 재미있기도 했던 기억이 있다.</p>\n<p>컴퓨터가 만든 파일이라는 것이 사실은 어떤 의미를 가진 문자열의 연속이라는 사실도 새로웠지만, 정규식을 사용하여 이 문자열을 의미있는 정보로 가공할 수 있다는 게 더 재밌었다.</p>\n<p>하지만 앞서 이야기했듯이 정규식은 이런 파서를 만들 때보다 일반적인 비즈니스 로직 상에서 더 자주 사용된다. 비밀번호나 이메일 주소 등 사용자가 틀릴 가능성이 높은 입력을 검사할 때 정규식은 말 그대로 치트키처럼 사용될 수 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 399px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f8ab432328c5d8bafe5aa95518ad4df2/a307d/password_rule.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZ0lEQVR42p1T2Y7CMBDr///c8sA+8oSABnoftMmk8XpSjiJYCYjkJk0ztjMzTfqmwe96jZ/VClVdw3sPay2ccx9BRKAjKcsKTd2gbduv0XUd8jyPxElVVVDUdPctGt5SCdVlInK17OHkbn+Jec897WlqlgghINGcqUJRFDGHTUv7XBdFieyUoeQcHWQZjDHI6ETdDMMQc6YkOpRnmqaZ0DmLkXkYux6WGEigihqkszqydozv4zhGaNxy3An5CAzwVPV0JCaFbLe4yOPd8eAwEJ6FkdMpwpcF7GZzu84XhHTY1JDjkU4LSMYW2O+iyLtOnx2yEHI0dFdCtKfSAyRN59M8+ED6QuCRkAuJ+TPz1VnZmMsr4ccOL0WR/Z7XzeguhdN8ktweDnAUmvoenlV2ux2FzJPQjTD+g/wQ2B5Tf55nBk5sjTDamFvPlgpsZBUO/BbO5/8dKqG+aPu8BMVe7mvMAsqjf8of4zBFjqIV43cAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"password rule\" title=\"\" src=\"/static/f8ab432328c5d8bafe5aa95518ad4df2/a307d/password_rule.png\" srcset=\"/static/f8ab432328c5d8bafe5aa95518ad4df2/69538/password_rule.png 160w,\n/static/f8ab432328c5d8bafe5aa95518ad4df2/72799/password_rule.png 320w,\n/static/f8ab432328c5d8bafe5aa95518ad4df2/a307d/password_rule.png 399w\" sizes=\"(max-width: 399px) 100vw, 399px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>물론 기본적으로 제공되는 메소드들을 잘 사용해도 검사는 할 수 있지만, 정규식으로 훨씬 간단하게 해결할 수 있다</small>\n</center>\n<p>만약 정규식을 모른다면 이메일 주소와 같은 간단한 문자열의 유효성을 검증하기 위해서 여러 개의 빌트인 메소드들을 조합하여 검사해야하기 때문에 꽤나 비효율적이다. 게다가 개인적으로는 아무리 정규식이 읽기가 어렵다지만 이렇게 복잡한 메소드들의 조합보다는 차라리 정규식이 가독성이 더 좋은 것이 아닌가하는 생각도 있다.</p>\n<p>물론 정규식은 코드처럼 라인이나 인덴트가 나누어져 있지도 않기 때문에 마치 무의미한 문자들의 나열처럼 보인다. 하지만 어차피 정규식이 제공하는 표현은 그렇게 많은 편이 아니기 때문에 조금만 사용하다보면 짧은 정규식 정도는 누구나 금방 이해할 수 있을 정도라고 생각한다.</p>\n<p>이상으로 불규칙 속에서 규칙을 찾아내자 포스팅을 마치며, 다음 포스팅에서는 필자가 지금까지 개발자로 일을 하면서 정규식을 실제로 사용했던 사례들을 토대로 정규식을 설명하는 내용을 풀어볼 예정이다.</p>","fields":{"slug":"20200724-about-regular-expression","path":"/2020/07/24/about-regular-expression/","lang":"ko"},"frontmatter":{"title":"불규칙 속에서 규칙을 찾아내는 정규 표현식","subTitle":"무한한 가능성 속에서 패턴을 정의하는 기술","date":"Aug 10, 2020","categories":["프로그래밍","튜토리얼"],"tags":["정규식","정규표현식","Regexp","Regular Expression","캐릭터 클래스","Character Class","Anchor","앵커","캡쳐링","Capturing Group","Greedy","Lazy"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/fc5c5/thumbnail.webp 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"slug":"20200724-about-regular-expression-en","previous":{"fields":{"slug":"20200509-gatsby-migration-retrospective-en","path":"/2020/05/09/gatsby-migration-retrospective/en/","lang":"en","postGroup":"20200509-gatsby-migration-retrospective"},"frontmatter":{"title":"Migrating from Hexo to Gatsby"}},"next":{"fields":{"slug":"20200815-regex-example-en","path":"/2020/08/15/regex-example/en/","lang":"en","postGroup":"20200815-regex-example"},"frontmatter":{"title":"How Do You Actually Use Regex?"}},"lang":"en","postGroup":"20200724-about-regular-expression"}},"staticQueryHashes":["3129619726","3523904809","376081736","650499039"],"slicesMap":{}}