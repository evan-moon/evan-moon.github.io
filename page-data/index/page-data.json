{"componentChunkName":"component---src-templates-posts-page-template-tsx","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"6fc49a6a-7d29-518a-a332-e007a6c917c2","tableOfContents":"<ul>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"필자는 이 책의 첫 번째 파트에서 카테고리 이론과 프로그래밍이 모두 합성 가능성(Composability)에 대한 것이라는 주장을 하였다. 프로그래밍에서는 문제를 조금씩 세분화해나가며 다룰 수 있는 세부 수준으로 분해한 다음, 각 하위 문제를 해결하고, 하위 문제의 해결책들을 다시 합성하여 전체 문제를 해결하는 방식을 사용한다.","html":"<p>필자는 이 책의 첫 번째 파트에서 카테고리 이론과 프로그래밍이 모두 합성 가능성(Composability)에 대한 것이라는 주장을 하였다.</p>\n<p>프로그래밍에서는 문제를 조금씩 세분화해나가며 다룰 수 있는 세부 수준으로 분해한 다음, 각 하위 문제를 해결하고, 하위 문제의 해결책들을 다시 합성하여 전체 문제를 해결하는 방식을 사용한다.</p>\n<!-- more -->\n<p>이를 수행하는 방법에는 크게두 가지 정도가 있다. 하나는 컴퓨터에게 무엇을 해야 하는지 알려주는 방법, 그리고 다른 하나는 어떻게 해야 하는 지를 알려주는 방법이다. 이때 전자는 선언형(Declarative), 후자는 명령형(Imperative)이라고 한다.</p>\n<p>이 두 가지 방법의 차이는 가장 기본적인 수준에서도 확인이 가능하다. 먼저 선언적으로 <code class=\"language-text\">h</code>를 함수 <code class=\"language-text\">f</code>가 실행된 이후 <code class=\"language-text\">g</code>를 적용한 합성이라고 정의해보면 이렇게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">h</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>혹은 명령적으로 정의해볼 수도 있다. 즉, 먼저 <code class=\"language-text\">f</code>를 호출하고 그 호출의 결과를 기억한 뒤, 그 결과를 사용해서 다시 <code class=\"language-text\">g</code>를 호출하는 것이다.</p>\n<p>명령형 방식의 프로그램은 일반적으로 시간 순서대로 정렬된 일련의 작업들로 표현된다. 특히 이 방식에서는 명시적으로 <code class=\"language-text\">g</code>의 호출이 <code class=\"language-text\">f</code>의 실행이 완료되기 전에는 절대 발생할 수 없음이 표현된다. 그러나 지연 평가(lazy evaluation)와 call-by-need 방식의 인수 전달을 사용하는 언어에서는 실제 실행 순서가 다를 수 있다.</p>\n<p>사실, 컴파일러의 최적화 수준에 따라 선언적 코드와 명령적 코드의 실행 방식에는 거의 차이가 없을 수도 있다. 하지만 이 두 가지 방법론은 때로 문제 해결 접근 방식과 결과 코드의 유지보수성 및 테스트 가능성에서 극명하게 다르다.</p>\n<p>여기서 중요한 질문은 “우리가 문제를 풀 때 항상 선언적인 접근 방식과 명령적인 접근 방식 중 하나를 선택할 수 있는가? 그리고 만약 선언적인 해결책이 있다면 항상 컴퓨터 코드로 변환할 수 있는 것인가?”이다. 사실 이 질문에 대한 답은 아직 명확하게 나오지 않았으며, 만약 그 답을 찾을 수 있다면 아마 우리 우주에 대한 이해를 혁신적으로 바꿀 수 있을 것이다.</p>\n<p>설명을 덧붙이자면, 물리학에서도 이와 유사한 이중성이 존재한다. 이는 심오한 근본 원칙을 가리키거나, 우리의 사고방식에 대해 무언가를 말해주는 것일 수 있다. 리처드 파인만은 자신의 양자 전기역학 연구에서 이 이중성이 영감의 원천이 되었다고 언급한 바 있다.</p>\n<p>물리 법칙을 표현하는 데에는 두 가지 방식이 있다. 하나는 국소적(local) 또는 미소적(infinitesimal) 접근 방식을 사용하는 것이다. 이 접근 방식은 먼저 시스템의 작은 근방에서의 상태를 관찰하고, 다음 순간에 그것이 어떻게 변화할 지를 예측한다. 이러한 변화는 보통 미분 방정식을 사용하여 표현되며, 이를 일정 시간 동안 적분하거나 합산하여 최종 결과를 표현한다.</p>\n<p>이는 이전 단계의 결과에 의존하는 각각의 작은 단계들을 거쳐 최종 해결책에 도달하는 명령형 사고방식과 유사하다.</p>\n<p>실제로 물리적 시스템의 컴퓨터 시뮬레이션은 미분 방정식을 차분 방정식으로 변환하고 이를 반복 실행하는 방식으로 구현하는 경우가 많다. <a href=\"https://ko.wikipedia.org/wiki/%EC%95%84%EC%8A%A4%ED%85%8C%EB%A1%9C%EC%9D%B4%EC%A6%88_(%EB%B9%84%EB%94%94%EC%98%A4_%EA%B2%8C%EC%9E%84)\" target=\"_blank\" rel=\"nofollow\">Asteroids 게임</a>에서 우주선이 애니메이션화 되는 방식도 이와 동일하다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 320px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/07e05bace0a500d1b2cd29c78efa839e/72799/1.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVR42oVTXQuDMAxMFT8q0spQdCD4KgiOuUf////abcEauzrzIKm95JJLSstr6e4dESml+MsGv6qqKIqMMUmS0GZ8NQzDuq40TVOe5wAVRYG/WZbBYQQca21d13Ec09HGcZwfMyEMB4C67sNvrHkuzzRNGQRO50tmRLFDfODa4OhCg3+/OzEf4Lo9JBaG+pumkRL4wRzpgqWvtW7b9lcCCvKgYVkCC/S3+s0g4e1rILwE+3eQDeQYmNekbCScMsighF3ggqVx25eDJKiFbiUOu4jF9NZmZ3N6wsfalWWJ3Xbx6L/ve6Q4nbMrDw8DaATLjIFpnc2Z38yZ1G+umgueGdC4iAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/07e05bace0a500d1b2cd29c78efa839e/72799/1.png\" srcset=\"/static/07e05bace0a500d1b2cd29c78efa839e/69538/1.png 160w,\n/static/07e05bace0a500d1b2cd29c78efa839e/72799/1.png 320w\" sizes=\"(max-width: 320px) 100vw, 320px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>각 시간 단계마다 우주선의 위치는 속도와 시간 델타를 곱하여 계산된 작은 증분을 더해가면서 변경된다. 속도는 다시 가속도에 비례하는 작은 증분을 더해 변경되며, 가속도는 힘을 질량으로 나눈 값이다.</p>\n<p>이것은 사실 뉴턴의 운동 법칙에 해당하는 미분 방정식을 직접적으로 구현한 것이다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo>=</mo><mi>m</mi><mfrac><mrow><mi>d</mi><mi>v</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mspace linebreak=\"newline\"></mspace><mi>v</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">F=m\\frac{dv}{dt}\\\\\nv=\\frac{dx}{dt}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0574em;vertical-align:-0.686em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">t</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.0574em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">t</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></div>\n<p>이외에도 맥스웰 방정식을 사용하여 전자기장의 전파를 분석하거나, 격자 양자색역학(lattice QCD)을 사용하여 양성자 내부에서 쿼크와 글루온의 행동을 설명하는 등 더 복잡한 문제에도 국소적 사고방식이 적용될 수 있다.</p>\n<p>이러한 국소적 사고방식은 디지털 컴퓨터를 사용하여 공간과 시간을 이산화(discretization)하는 시도와 결합되어, 우주의 모든 복잡성을 간단한 셀룰러 오토마타 시스템으로 축소하려는 스티븐 울프람(Stephen Wolfram)과 같은 영웅이 등장하기도 했다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>셀룰러 오토마타는 격자 내부에 위치한 여러 개의 셀들이 간단한 규칙에 따라 유한 개의 상태로 변화할 수 있는 시스템이다. 대표적인 셀룰러 오토마타 중 하나로는 <a href=\"https://namu.wiki/w/%EC%BD%98%EC%9B%A8%EC%9D%B4%EC%9D%98%20%EC%83%9D%EB%AA%85%20%EA%B2%8C%EC%9E%84\" target=\"_blank\" rel=\"nofollow\">콘웨이의 생명 게임</a>이 있으며, 이러한 시스템은 간단한 규칙이 생명과 같은 복잡한 패턴을 표현할 수 있음을 보여준다.</p>\n</blockquote>\n<p>다른 접근법은 전역적(global) 접근 방법이다. 시스템의 초기 상태와 최종 상태를 확인한 뒤, 에너지, 시간, 거리와 같은 물리량을 최소한으로 사용하여 이 상태들을 연결할 수 있는 최적의 경로를 계산한다. 가장 간단한 예는 <strong>페르마의 최소 시간 원리</strong>이다.</p>\n<p>이 원리는 빛이 비행 시간을 최소화하는 경로를 따라 전파된다는 것을 나타낸다. 그래서 반사나 굴절이 없는 경우, A 지점에서 B 지점으로 가는 빛은 가장 짧은 경로인 A와 B 사이의 직선 경로를 선택한다.</p>\n<p>그러나 빛은 물이나 유리와 같은 밀도가 높은 투명 물질에서는 속도가 느려진다. 따라서 빛의 시작 지점이 공기 중에 있고 도착 지점이 물속에 있을 경우, 빛이 공기 중에서 이동하는 거리보다 물 속에서 이동하는 거리가 더 짧아져야 한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 477px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6eea0ab0c036ddfe049479e302fa185d/b18ba/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 134.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAIBAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAe1DUprFFnNqWEHK/8QAGxABAAIDAQEAAAAAAAAAAAAAAQIRABAhAzH/2gAIAQEAAQUCZVkVk5PpGxvUuehbpBw+f//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABoQAAICAwAAAAAAAAAAAAAAABEgACEQMVH/2gAIAQEABj8C1aCsmcT/xAAdEAEAAgICAwAAAAAAAAAAAAABABEhcRBRMUFh/9oACAEBAAE/IXsaI5XB6ODhKvceG0OpTslS+RgJWtX448gXBQCf/9oADAMBAAIAAwAAABCcwIz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAWEQEBAQAAAAAAAAAAAAAAAAAQASH/2gAIAQIBAT8QLp//xAAgEAEBAAEEAQUAAAAAAAAAAAABEQAhMUFREHGRscHx/9oACAEBAAE/EB7UajhO8sUJu/Pv4B7ONid4ZQXdIHY74z9bEWwvpiFr7BHTv6w39VgDQ8KUkCFwCEAgZ//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/6eea0ab0c036ddfe049479e302fa185d/b18ba/2.jpg\" srcset=\"/static/6eea0ab0c036ddfe049479e302fa185d/0913d/2.jpg 160w,\n/static/6eea0ab0c036ddfe049479e302fa185d/cb69c/2.jpg 320w,\n/static/6eea0ab0c036ddfe049479e302fa185d/b18ba/2.jpg 477w\" sizes=\"(max-width: 477px) 100vw, 477px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>최소 시간을 따르는 경로는 빛이 공기와 물의 경계에서 굴절되도록 하며, 이는 스넬의 굴절 법칙(Snell’s Law of Refraction)으로 이어진다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><msub><mi>θ</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mfrac><mo>=</mo><mfrac><msub><mi>v</mi><mn>1</mn></msub><msub><mi>v</mi><mn>2</mn></msub></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{\\sin(\\theta_1)}{\\sin(\\theta_2)} = \\frac{v_1}{v_2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.363em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mop\">sin</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mop\">sin</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">θ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.9436em;vertical-align:-0.836em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1076em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.836em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></div>\n<p>여기서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>은 공기 중에서의 빛의 속도이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>는 물속에서의 빛의 속도이다.</p>\n<p>고전 역학의 모든 법칙은 최소 작용 원리로부터 도출될 수 있다. 작용은 라그랑지안(Lagrangian)을 경로에 따라 적분하여 계산할 수 있으며, 라그랑지안은 운동 에너지와 위치 에너지의 차이를 나타낸다 (참고로 합(sum)이 아니라 차이(difference)다. 합은 총 에너지를 나타낸다).</p>\n<p>우리가 특정 목표를 맞추기 위해 박격포를 발사하면, 포탄은 먼저 중력으로 인해 위치 에너지가 더 높은 곳으로 올라가고, 그 과정 속에서 점점 작용에 음의 기여를 축적한다. 그 후 포탄은 포물선의 꼭대기에서 속도를 줄여 운동 에너지를 최소화하고, 최종적으로는 위치 에너지가 낮은 구간을 빠르게 통과하기 위해 속도를 높인다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/3bcd91aec0bd17805bb6b69ae376b97c/c08c5/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe7OkFA//8QAGRABAAMBAQAAAAAAAAAAAAAAAQACERIx/9oACAEBAAEFAvZZ4B0lqloGT//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAIDAQAAAAAAAAAAAAAAAAABEBEhYf/aAAgBAQAGPwLhZajUYf/EABkQAQEBAAMAAAAAAAAAAAAAAAERABAxQf/aAAgBAQABPyE93BoqYC6Hg8LTAYIb/9oADAMBAAIAAwAAABBgz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEBAAMBAAAAAAAAAAAAAAERABAxUWH/2gAIAQEAAT8QcwvEZfuumkJ21z0UKPAQiqDp2eBv/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/3bcd91aec0bd17805bb6b69ae376b97c/c08c5/3.jpg\" srcset=\"/static/3bcd91aec0bd17805bb6b69ae376b97c/0913d/3.jpg 160w,\n/static/3bcd91aec0bd17805bb6b69ae376b97c/cb69c/3.jpg 320w,\n/static/3bcd91aec0bd17805bb6b69ae376b97c/c08c5/3.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>리처드 파인만의 주요 기여 중 한 가지는 최소 작용 원리가 양자역학으로 일반화될 수 있음을 보여준 것이다. 이 경우에도 문제는 초기 상태와 최종 상태로 구성되며, 두 상태 사이의 전이 확률을 계산하기 위해 파인만 경로 적분(Feynman path integral)이 사용된다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/58afbf9a618154e80664783c0512faf6/c08c5/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3JoWD//EABoQAAICAwAAAAAAAAAAAAAAAAABAhEQEiH/2gAIAQEAAQUCk6Nnhorh/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAQUAAAAAAAAAAAAAAAAAEAABIUGh/9oACAEBAAY/AlTmcH//xAAcEAEAAgIDAQAAAAAAAAAAAAABACERYTFBUXH/2gAIAQEAAT8hT4e3qbNRCi3MRc5NEvwHkHFz/9oADAMBAAIAAwAAABCwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB4QAQACAgIDAQAAAAAAAAAAAAEAESFBMWFRcdHw/9oACAEBAAE/EExE4NC8vUqeQtC5f32FEsbZX1ByGPb3BsBtsElqWF3U/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/58afbf9a618154e80664783c0512faf6/c08c5/4.jpg\" srcset=\"/static/58afbf9a618154e80664783c0512faf6/0913d/4.jpg 160w,\n/static/58afbf9a618154e80664783c0512faf6/cb69c/4.jpg 320w,\n/static/58afbf9a618154e80664783c0512faf6/c08c5/4.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>중요한 점은 물리 법칙을 설명하는 방식에 우열을 가리기 어려운 이중성이 존재한다는 것이다. 우리는 하나의 물리적 결과를 설명할 때 작은 일들이 순차적인 여러 단계로 나누어져 발생하는 국소적인 관점을 사용할 수도 있고, 초기 조건과 최종 조건을 선언한 뒤 그 사이에 무슨 일이 있었는지를 설명하는 전역적인 관점을 사용할 수도 있다.</p>\n<p>전역적 접근법은 프로그래밍에서도 사용될 수 있다. 예를 들어 레이 트레이싱(ray tracing)을 구현할 때, 우리는 눈의 위치와 광원의 위치를 선언하고, 이들을 연결하는 광선의 경로를 계산한다. 이때 우리가 각 광선의 비행 시간을 명시적으로 최소화하지 않더라도, 스넬의 법칙(Snell’s law)과 반사의 기하학을 이용하여 동일한 효과를 얻을 수 있다.</p>\n<p>국소적 접근법과 전역적 접근법의 가장 큰 차이점은 공간, 그리고 더 중요한 시간에 대한 처리 방식이다. 국소적 접근법은 “지금 이 순간”의 즉각적인 결과를 중시하지만, 전역적 접근법은 마치 미래가 이미 정해져 있는 것처럼 장기적이고 정적인 관점을 취하며, 우리가 영원한 우주의 속성을 분석하는 것과 같다.</p>\n<p>이 점이 가장 잘 드러나는 곳은 사용자 상호작용에 대한 함수형 반응형 프로그래밍(Functional Reactive Programming, FRP) 접근법이다. FRP는 모든 이벤트에 대해 개별 핸들러를 작성하고 이들이 공유되는 가변 상태에 접근하도록 만드는 대신, 이벤트를 무한 리스트로 간주하고 이 이벤트에 대해 반응하는 특정한 변환을 적용한다.</p>\n<p>이론적으로 미래에 발생할 모든 동작을 담은 무한 리스트는 프로그램의 입력 데이터로 사용할 수 있다. 사실 프로그램 관점에서는 𝜋의 숫자 리스트, 의사 난수(pseudo-random number) 리스트, 또는 컴퓨터 하드웨어를 통해 전달되는 마우스 위치 리스트나 큰 차이가 없다. 데이터의 출처가 뭐든 간에 결국 리스트의 n번째 항목을 가져오려면 먼저 𝑛 − 1개의 항목을 통과해야 한다는 사실은 동일하기 때문이다. 이러한 속성이 시간적 이벤트에 적용될 때 이를 인과성(causality)이라고 부른다.</p>\n<p>그렇다면 이것이 카테고리 이론과 어떤 관련이 있다는 것일까? 필자는 카테고리 이론이 전역적 접근법을 장려하고, 따라서 선언적 프로그래밍을 지원한다는 이야기를 하려고 한다.</p>\n<p>첫 번째로, 미적분학과 달리 카테고리 이론에는 거리(distance), 이웃(neighborhood), 시간(time)과 같은 개념이 없다. 우리가 다루는 것은 그저 추상적인 대상과 대상들 간의 추상적인 연결뿐이다. 만약 A에서 B로 여러 단계를 통해 이동할 수 있다면, 한 번에 도달할 수도 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 541px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7bf87462d30c7320a6e32b55dd90f97e/8af7b/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 81.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAIBAwQF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB71LIaCA//8QAGhABAAIDAQAAAAAAAAAAAAAAAQASAhEiMf/aAAgBAQABBQJdQy6jZaIHn//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAMAAwAAAAAAAAAAAAAAAAABEBJRof/aAAgBAQAGPwI5NIeM/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARIVExEP/aAAgBAQABPyEPU1WPtD4c9B3bY3Tru9iWyU8n/9oADAMBAAIAAwAAABBTz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQACAgMBAAAAAAAAAAAAAAERIQBBMVGBEP/aAAgBAQABPxA0ZWxRitcQLkYlk138hN1Rs0V175kT2jaRHE8UYSTuWs//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/7bf87462d30c7320a6e32b55dd90f97e/8af7b/5.jpg\" srcset=\"/static/7bf87462d30c7320a6e32b55dd90f97e/0913d/5.jpg 160w,\n/static/7bf87462d30c7320a6e32b55dd90f97e/cb69c/5.jpg 320w,\n/static/7bf87462d30c7320a6e32b55dd90f97e/8af7b/5.jpg 541w\" sizes=\"(max-width: 541px) 100vw, 541px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>게다가 카테고리 이론의 주요 도구인 보편적 구성(universal construction)은 전역적 접근법의 정수이다. 우리는 이를 카테고리적 곱(categorical product)의 정의에서 확인했다. 이는 그저 해당 대상의 속성을 명시함하는 것만으로도 충분히 정의할 수 있었으며, 이는 매우 선언적인 접근이다. 곱은 두 투영(projection)을 갖춘 대상이며, 다른 대상들의 투영을 인수분해하는 특성을 최적화하는 가장 적합한 대상이다.</p>\n<p>이런 특성을 페르마의 최소 시간 원리 또는 최소 작용 원리와 비교해보면 꽤 유사하다는 것을 알 수 있다.</p>\n<p>반대로 카테고리적 곱을 전통적인 데카르트 곱의 정의와 비교해보자. 데카르트 곱은 훨씬 더 명령적인 접근을 보여주고 있다. 이 방법은 하나의 집합에서 원소를 선태갛고 다른 집합에서 또 다른 원소를 선택하여 최종적으로 곱의 원소를 생성하는 방법을 보여주고 있다.</p>\n<p>Haskell과 같은 프로그래밍 언어에서 곱 타입, 합 타입, 그리고 함수 타입은 보편적 구성을 통해 정의되는 것이 아니라 이미 내장되어있는 경우가 대부분이다. (물론 카테고리적 프로그래밍 언어를 만드려는 시도는 있었으며, <a href=\"http://web.sfc.keio.ac.jp/~hagino/thesis.pdf\" target=\"_blank\" rel=\"nofollow\">타츠야 하기노의 논문</a>에 그 내용이 잘 나와있다.)</p>\n<p>하지만 프로그래밍 언어에 카테고리적인 정의가 직접적으로 사용되던 아니던, 결국 카테고리적 정의는 기존의 프로그래밍 구조를 정당화하고 새로운 구조를 만들어낼 수 있는 토대가 된다. 가장 중요한 점은 카테고리 이론이 컴퓨터 프로그램을 선언적인 수준에서 추론하기 위한 메타 언어를 제공한다는 것이다. 또한 문제를 코드로 구현하기 전에 명세에 대해 논리적으로 사고하는 것에도 많은 도움을 준다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20241225-category-theory-for-programmers-11-declarative-programming","path":"/2024/12/25/category-theory-for-programmers-11-declarative-programming/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 11. 선언적 프로그래밍","subTitle":null,"date":"Dec 25, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"9bdc4240-2cf3-5832-b560-82aaa4d6ca20","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%A0%95%EB%8B%B5%EC%9D%84-%EC%B0%BE%EC%9C%BC%EB%A0%A4%EB%8A%94-%EB%85%B8%EB%A0%A5\">정답을 찾으려는 노력</a></p>\n<ul>\n<li><a href=\"#%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%B4-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EC%9A%94\">좋은 코드란 무엇일까요? 가독성이 좋은 코드요.</a></li>\n<li><a href=\"#%EC%84%B1%EC%9E%A5%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C%EC%9A%94\">성장하려면 어떻게 해야할까요?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B3%A0%EC%A0%95%EB%90%9C-%EC%A7%84%EB%A6%AC%EA%B0%80-%EC%95%84%EB%8B%8C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A7%A5%EB%9D%BD-%EC%86%8D%EC%97%90%EC%84%9C-%EB%B3%80%ED%99%94%ED%95%98%EB%8A%94-%EC%A7%84%EB%A6%AC\">고정된 진리가 아닌 다양한 맥락 속에서 변화하는 진리</a></p>\n<ul>\n<li><a href=\"#%EB%82%98%EC%9D%98-%EC%84%A0%ED%83%9D%EC%9D%B8%EA%B0%80-%ED%83%80%EC%9D%B8%EC%9D%98-%EA%B8%B0%EB%8C%80%EC%9D%B8%EA%B0%80\">나의 선택인가, 타인의 기대인가?</a></li>\n<li><a href=\"#%EB%82%98%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%B2%AB%EA%B1%B8%EC%9D%8C%EC%9D%B4%EB%8B%A4\">나를 이해하는 것이 첫걸음이다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"우리는 인생을 살아가며 수없이 많은 문제들과 마주친다. 당장 현실적인 부분들만 보아도 입시, 취업, 이직, 재테크, 커리어, 성장 등 다양한 미션을 만나게 되는데, 종종 사람들과 이에 대해 이야기를 나누다보면 마치 정답이 정해져있다는 것과 같은 이야기 혹은 정답이 있기를 바라는 것과 같은 이야기를 듣고는 한다.","html":"<p>우리는 인생을 살아가며 수없이 많은 문제들과 마주친다. 당장 현실적인 부분들만 보아도 입시, 취업, 이직, 재테크, 커리어, 성장 등 다양한 미션을 만나게 되는데, 종종 사람들과 이에 대해 이야기를 나누다보면 마치 정답이 정해져있다는 것과 같은 이야기 혹은 정답이 있기를 바라는 것과 같은 이야기를 듣고는 한다.</p>\n<!-- more -->\n<p>때로는 사회가 정답을 강요한다는 생각이 들기도 한다. “좋은 대학에 입학하면 인생이 필거야”, “행복하게 살려면 서울에 집 한 채는 있어야지”, “월 수입이 얼마는 되어야 중산층이지”와 같은 여러가지 조건과 기준들을 듣고 있자면, 내가 결정하는 것들이 정말 내가 결정하는 것이 맞는지 아니면 단순히 사회가 정해놓은 기준에 따라가고 있는 것인지 의문이 들 때가 있다.</p>\n<p>학생들은 지식을 얻고 탐구하고자 학습하는 것이 아닌, 다수가 외치는 정답을 맞추기 위해 학습한다. 그리고 이런 폐단은 학교 뿐 아니라 사교육에서도 동일하게 나타나며, 개발자들을 가르치는 여러 조직들 또한 크게 다르지 않다. 결국 고객들이 정답을 원하고 있으니 정답을 가르치는 것이 비즈니스 임팩트이기 때문이다.</p>\n<p>이렇게 사회가 제공하는 성공의 공식은 우리를 길들여왔다. 그래서 우리가 접하는 대부분의 문제들은 비정형적이고 정답이 없는 것들인 경우가 대부분이지만, 종종 우리는 문제를 만났을 때 마치 정답이 있을 것이라고 착각하고는 한다.</p>\n<p>이런 사회적 강요는 우리의 사고방식에도 깊은 영향을 미치며, 필자와 같은 개발자들 역시 예외는 아니다. 그래서 이번 포스팅에서는 이에 대해 필자가 평소 느꼈던 문제 의식에 대해 한번 풀어보고자 한다.</p>\n<h2 id=\"정답을-찾으려는-노력\" style=\"position:relative;\">정답을 찾으려는 노력<a href=\"#%EC%A0%95%EB%8B%B5%EC%9D%84-%EC%B0%BE%EC%9C%BC%EB%A0%A4%EB%8A%94-%EB%85%B8%EB%A0%A5\" aria-label=\"정답을 찾으려는 노력 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 필자와 같은 개발자들은 정답을 찾기 위해 노력하는 것이 익숙한 부류이다. 아무래도 논리를 다루는 직업의 특성 상, 명확한 근거를 기반으로 논리적으로 오류가 없는 의사 결정을 내리는 것에 익숙하기 때문이다.</p>\n<p>보통 개발자들이 외치는 정답은 대부분 코드의 형상과 관계에 초점이 맞춰져 있는데, 간혹 명확한 이유 없이 모노레포를 도입한다거나 전역 상태 관리 라이브러리 또는 메모이제이션과 같은 특정 메소드를 맥락 없이 도입하는 경우도 흔하다.</p>\n<p>하지만 앞서 이야기 했듯 현실은 그렇게 단순하지 않으며 많은 경우 “최선”이라는 것은 맥락과 상황에 따라, 혹은 해석하는 사람에 따라 다르게 정의된다.</p>\n<h3 id=\"좋은-코드란-무엇일까요-가독성이-좋은-코드요\" style=\"position:relative;\">좋은 코드란 무엇일까요? 가독성이 좋은 코드요.<a href=\"#%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%B4-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EC%9A%94\" aria-label=\"좋은 코드란 무엇일까요 가독성이 좋은 코드요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자는 어쩌다 보니 경력 초반인 지난 2016년부터 현재까지 꾸준히 인터뷰어로서의 경험을 쌓고 있는데, 아무래도 오랫동안 이 일을 하다보니 개인적으로 사용하는 질문 템플릿이 몇 가지 있다.</p>\n<p>그 중 하나는 “좋은 코드란 무엇일까요?”라는 질문이다. 이는 개인적으로도 오랫동안 고민해온 주제라 인터뷰를 통해 다양한 개발자들의 의견을 듣고 싶은 마음도 있다. 하지만 이런 질문을 던지면 신기하게도 굉장히 많은 분들이 “가독성이 좋은 코드”라는 답변을 해주시는데, 과장을 조금 보태자면 100명 중 99명은 이 답변을 주시는 것 같다.</p>\n<p>필자는 이 답변을 들을 때마다 묘한 어색함을 느끼는데, 가독성은 본질적으로 주관적이고 추상적인 개념이기 때문이다. 같은 코드를 보아도 누군가는 가독성이 좋다고 말할 수 있고, 누군가는 나쁘다고 말할 수 있는 것이니 말이다.</p>\n<p>물론 코드를 이집트 상형 문자로 표현하는 것보다 나에게 익숙한 언어로 표현하는 것이 이해하기 쉬운 것처럼 많은 사람들이 가독성이 높다고 공감할 수 있는 요소들은 존재할 수 있겠지만, 사실 우리가 이야기하는 가독성이라는 것이 이런 수준의 이야기를 하는 것이 아니라는 건 다들 알고 있을 것이다.</p>\n<p>애초에 전 세계에 존재하는 약 2,600만 명의 소프트웨어 개발자들이 모두 공감할 수 있는 기술적 요소라는 것이 존재할 수나 있는 것일까? 모두가 공감할 수 없는 가치라면 애초에 가독성이 좋은 코드라는 것이 세상에 존재하기는 하는 것인지에 대한 의심을 해봐야 하지 않을까?</p>\n<p>이런 마음을 담아 지원자에게 “가독성이 좋은 코드는 무엇인가요?”라는 질문을 던지면 이제부터 답변이 다양해진다. 누군가는 응집이나 결합을 강조하고, 누군가는 명확하고 직관적인 네이밍, 누군가는 관심사에 대한 이야기를 한다. 즉, 가독성이라는 것의 본질 전체를 꿰뚫는 정의가 아닌, 현실의 특정 사례를 예시로 들며 “이렇게 했을 때 가독성이 좋아집니다”와 같은 답변을 하는 경우가 많았다.</p>\n<p>결국 개발자마다 좋은 가독성을 달성하기 위해 가장 필요하다고 생각하는 부분이 모두 다르다는 것이며, 이 답변들이 오히려 가독성이라는 것이 얼마나 주관적이고 추상적이며 맥락 의존적인 것인지 드러내는 사례이다. 마치 같은 그림을 보면서도 누군가는 아름답다고 여기고 누군가는 도대체 뭘 표현하려는 것인지 모르겠다고 하는 것처럼 말이다.</p>\n<p>하지만 분명 많은 사람들은 “좋은 코드가 무엇인가?”에 대한 질문에 “가독성이 좋은 코드”라는 답변을 하고 있다. 마치 정답이 정해져 있기라도 한 것처럼 말이다.</p>\n<h3 id=\"성장하려면-어떻게-해야할까요\" style=\"position:relative;\">성장하려면 어떻게 해야할까요?<a href=\"#%EC%84%B1%EC%9E%A5%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C%EC%9A%94\" aria-label=\"성장하려면 어떻게 해야할까요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 본능은 비단 개발자 뿐 아니라, 우리가 일상에서 내리는 크고 작은 결정에서도 자주 드러난다. 필자는 종종 1-on-1, 멘토링과 같이 다른 개발자들의 고민을 듣고 도움을 드릴 수 있는 자리를 가지고는 하는데, 사실 이런 자리에서도 정답을 찾으려는 노력을 많이 보아왔다.</p>\n<p>이런 자리에서 주로 듣는 질문과 고민은 대략 이런 느낌이다.</p>\n<hr>\n<ul>\n<li>좋은 개발자가 되려면 어떻게 해야 하나요?</li>\n<li>ㅇㅇ 회사에 들어가려면 어떤 점을 채워야 할까요?</li>\n<li>나중에 이런 경험을 하고 싶은데, 그러면 어떻게 해야 하나요?</li>\n</ul>\n<hr>\n<p>물론 이런 질문을 하는 마음은 충분히 공감이 간다. 무언가를 달성하고 싶은 마음은 크지만 무엇을 해야 하는지는 모르겠을 때, 그 답답한 마음은 누구나 한번 쯤은 느껴보았을 것이다.</p>\n<p>사실 이런 질문을 던지는 분들은 분명 성장을 갈망하며 진심으로 더 나아지고 싶어한다. 하지만 문제는 성공이나 성장이라는 목표를 지나치게 정형화된 방법으로 접근한다는 점이다.</p>\n<p>그 결과 자신의 환경, 목표, 역량과 맞지 않는 보편적인 정답을 따라가다가 오히려 잘못된 방향으로 노력을 쏟는 경우를 자주 목격했다. 마치 내 몸에 맞지 않는 옷을 억지로 입으려고 하는 것처럼 말이다.</p>\n<p>행간에는 1만 시간의 법칙과 같이 무조건 노력하면 언젠가 원하는 바를 달성할 수 있다는 이야기도 있지만, 필자는 절대 여기에 동의하지 않는다. 노력과 시간이라는 것은 매우 한정된 자원이기 때문에 어디에 투자할 것인지가 매우 중요하기 때문이다. <small>(기껏 1만 시간을 투자했더니 알고보니 내 성장에 전혀 도움이 되지 않았던 곳이었다고 해도 날려버린 1만 시간은 두번 다시 돌아오지 않는다.)</small></p>\n<p>결국 중요한 것은 시간과 에너지를 어디에 투자할 것인가에 대한 방향성인데, 문제는 우리는  이 방향성을 스스로 결정했다고 믿지만, 사실 그 선택은 타인이나 사회가 제시한 기준에 의존한 결과일 때가 많다는 것이다.</p>\n<h2 id=\"고정된-진리가-아닌-다양한-맥락-속에서-변화하는-진리\" style=\"position:relative;\">고정된 진리가 아닌 다양한 맥락 속에서 변화하는 진리<a href=\"#%EA%B3%A0%EC%A0%95%EB%90%9C-%EC%A7%84%EB%A6%AC%EA%B0%80-%EC%95%84%EB%8B%8C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A7%A5%EB%9D%BD-%EC%86%8D%EC%97%90%EC%84%9C-%EB%B3%80%ED%99%94%ED%95%98%EB%8A%94-%EC%A7%84%EB%A6%AC\" aria-label=\"고정된 진리가 아닌 다양한 맥락 속에서 변화하는 진리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 사람은 누구나 안정성과 확실성을 추구하고 불확실한 상황을 불편해하는 심리적 기제를 지니고 있기 때문에 이러한 사고가 부자연스러운 것은 아니다. 오히려 정답이 없다고 믿는 것이 인간의 본능을 거스르는 행위일 수도 있다.</p>\n<p>그래서 앞서 언급한 가독성과 성장의 사례 또한 훌륭한 개발자가 되기 위해 갈망하고 공부하던 많은 사람들이 어떤 블로그, 책, 혹은 주변에 있는 개발자 등을 통해 퍼진 정보들을 비판 없이 흡수했을 가능성이 높다. 하지만 가독성이나 성장과 같은 문제는 정해진 정답이라는 것이 없다는 점을 간과해서는 안된다.</p>\n<p>철학에서는 이러한 문제를 탐구하기 위해 상대주의(Relativism)와 맥락주의(Contextualism) 같은 개념을 사용한다.</p>\n<p>상대주의는 진리나 가치는 보편적이지 않고, 특정 문화, 관점, 상황에 따라 달라진다는 것이며, 이는 가독성의 기준도 개인의 기준 혹은 개인이 처한 상황에 따라 달라질 수 있다는 것을 의미한다.</p>\n<p>맥락주의는 어떤 명제가 참인지 여부는 그것이 사용되는 맥락에 달려 있다는 것을 의미한다.</p>\n<p>예를 들어 동일한 코드라 하더라도, 팀의 문화나 프로젝트의 성격, 그리고 비즈니스 상황에 따라 그에 대한 평가가 달라질 수 있는 것처럼 말이다.</p>\n<p>많은 이들이 좋은 코드란 무엇인가에 대해 가독성 좋은 코드라는 답을 정답처럼 외치고 있지만, 이것은 고정된 진리가 아니라 다양한 맥락 속에서 변화하는 상대적인 개념인 것이다.</p>\n<p>물론 인터뷰라는 자리를 마치 인터뷰어가 생각하는 정답을 맞춰야하는 게임이라고 착각하시는 경우가 많기 때문에 다소 편향이 발생했을 수도 있지만, 비단 인터뷰 뿐만 아니라 멘토링이나 1-on-1과 같은 자리에서도 많은 분들이 비슷한 반응을 보였기 때문에 편향이 크지는 않다고 생각한다. <small>(독자 여러분도 당장 주변에 있는 개발자 아무나 10명만 붙잡고 “좋은 코드란 뭐라고 생각하심?”이라는 질문을 한번 던져보면 아마 높은 확률로 가독성 이야기가 나올 것이다)</small></p>\n<p>물론 우리가 굳이 기계어가 아니라 인간에게 익숙한 기호들로 추상화된 프로그래밍 언어를 사용하는 것은 결국 인간이 컴퓨터의 동작을 쉽게 이해하기 위함이니, 가독성이 좋은 코드라는 가치를 달성할 수만 있다면 더할 나위 없이 좋은 코드라고 부를 수 있음에는 이견이 없다.</p>\n<p>하지만 상황이나 맥락에 따라 다르게 판단될 수 밖에 없는 이 가독성이 좋다는 것이 도대체 무엇인지, 근본적인 진리에 대한 의문과 고찰없이 이런 답을 섣불리 내는 것은 프로그래밍 전문가로써 해서는 안될 행동이다.</p>\n<p>그렇다면 우리는 과연 무엇을 기준으로 본질적인 가치를 찾아야 하는 것일까?</p>\n<h3 id=\"나의-선택인가-타인의-기대인가\" style=\"position:relative;\">나의 선택인가, 타인의 기대인가?<a href=\"#%EB%82%98%EC%9D%98-%EC%84%A0%ED%83%9D%EC%9D%B8%EA%B0%80-%ED%83%80%EC%9D%B8%EC%9D%98-%EA%B8%B0%EB%8C%80%EC%9D%B8%EA%B0%80\" aria-label=\"나의 선택인가 타인의 기대인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>가장 먼저 나의 의사결정 또는 내가 옳다고 생각하는 무언가가 정말 내가 결정한 것이 맞는지에 대해 성찰하는 과정이 필요하다.</p>\n<p>앞서 여러 번 언급했듯이 우리는 집단주의 성향이 강한 문화권에서 살아가고 있기 때문에, 내가 스스로 결정했다고 믿는 것이 사실은 타인이나 사회의 기준에 의해 결정된 경우가 많다.</p>\n<hr>\n<ul>\n<li>다들 개발자 초봉은 n천만원이라고 하니, 나도 그 정도는 받아야지.</li>\n<li>요즘 AI가 대세라고 하니까 나도 AI를 공부해야겠다.</li>\n<li>대기업은 알고리즘을 본다고 하네. 그럼 오늘부터 성실하게 1일 1알고리즘 풀이를 해야겠다.</li>\n<li>집은 무조건 서울에 사야지.</li>\n<li>기술의 선두 주자가 되려면 미국으로 건너가야겠다.</li>\n</ul>\n<hr>\n<p>물론 필자도 알게 모르게 이런 생각을 많이 한다. 가장 최근에 했던 생각은 “비싼 수입차를 타면 내 인생에 대한 만족도가 조금은 올라가지 않을까”였는데, 처음에는 좋았지만 결국 3개월 정도 지나니까 익숙해져서 돈은 돈대로 쓰고 원했던 만족도는 얻지 못 했다.</p>\n<p>결국 이것 또한 사회에서 일반적으로 통용되는 성공의 상징을 취득하면 삶의 질이 올라갈 것이라 판단한 것이니, 필자 스스로의 의사결정이라기보다는 사회나 타인의 시선에 영향을 받은 상황이라고 볼 수 있다.</p>\n<p>그래서 이렇게 “A를 하려면 B를 해야한다”와 같은 논리가 머릿속에 떠올랐다면 대부분 정답이 아닌 경우가 많다. 더 정확히 말하자면 누군가에게는 정답일 수 있어도 나에게는 아닐 수 있기 때문에 한번 멈추고 성찰하는 과정이 필요한 것이다.</p>\n<h3 id=\"나를-이해하는-것이-첫걸음이다\" style=\"position:relative;\">나를 이해하는 것이 첫걸음이다<a href=\"#%EB%82%98%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%B2%AB%EA%B1%B8%EC%9D%8C%EC%9D%B4%EB%8B%A4\" aria-label=\"나를 이해하는 것이 첫걸음이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>정답은 사실 멀리 있는 것이 아니다. 정답을 찾기 위해서는 일단 나 스스로에 대한 깊은 이해가 필요하다.</p>\n<p>내가 무엇을 좋아하고, 어떨 때 기쁨을 느끼며, 어떤 순간에 슬픔을 느끼는 지 알아야 한다. 무엇을 할 때 가슴이 뛰는지, 어떤 일을 할 때 가장 몰입하는지를 돌아보아야 한다. 이런 자기 성찰이 뒷받침되지 않는다면, 우리는 쉽게 타인이나 사회가 정해준 기준에 휘둘릴 수밖에 없다.</p>\n<p>필자는 이것이 굉장히 중요한 요소라고 생각하는데, 안타깝게도 바쁘게 현생을 살다보면 외부의 문제에는 있는 힘껏 머리를 쓰면서도 정작 나에 대해서 돌아보고 생각해볼 기회는 많이 없는 것 같다.</p>\n<p>성찰이라고 하면 고루하고 어려운 이야기처럼 느껴질 수는 있지만, 사실 스스로에게 던지는 작은 질문부터 시작해보면 그리 어려운 것은 아니다.</p>\n<hr>\n<ul>\n<li>나는 어떤 상황에서 행복함을 느꼈을까?</li>\n<li>나는 회사를 왜 다니고 있지?</li>\n<li>나는 왜 개발자로 일하고 있지?</li>\n</ul>\n<hr>\n<p>결국 중요한 것은 내가 내리는 모든 결정이 진정 나의 의지에서 비롯된 것인지 점검하고, 내가 생각하고 결정한 것이 정말 내 몸에 맞는 옷이 맞는지를 확인하는 것이다.</p>\n<p>필자는 비싼 값을 치루고 수입차를 샀지만 결국 3개월 만에 익숙해져버려 원했던 만족감을 얻지 못 했다. 하지만 누군가는 동일한 행위를 해도 충분히 만족하면서 살아갈 수도 있다. 애초에 이 행위는 필자에 맞는 옷이 아니었던 것이다. <small>(하지만 또 팔기는 아까워서 아직 잘 타고 있다)</small></p>\n<p>정답은 멀리 있는 것이 아니라, 내 안에 있다. 비록 우리는 집단주의적 성향이 강한 사회 속에서 살아가지만, 오히려 이런 곳에서 나만의 기준을 세워가는 것이야말로 진정한 만족과 성취를 얻는 길이라고 할 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>실존주의 철학자 장폴 사르트르는 “우리는 스스로를 정의하며, 우리 존재의 의미는 우리가 만드는 것”이라고 말하며 인간이 자유롭게 선택할 수 있는 존재임과 동시에, 그 선택에 대한 책임을 져야 한다는 점을 강조했다.</p>\n<p>이는 우리의 선택이 타인의 기대가 아니라 스스로의 가치와 기준에서 나올 때, 진정으로 만족스러운 삶을 살 수 있음을 시사한다.</p>\n<p>물론 현생을 살기 위해서는 사회나 타인이 요구하는 여러 조건들을 맞춰야 하는 경우도 있다. 하지만 중요한 것은 스스로가 그 조건을 왜 맞춰야 하는지 인지하고 결정한 것이 맞냐는 것이다.</p>\n<p>좋은 코드는 가독성이 높은 코드라는 말, 좋은 개발자가 되기 위해서는 이런 저런 일을 해야한다는 타인의 말은 그저 수많은 데이터 중 하나일 뿐이다. 우리의 역할은 저 데이터를 그대로 받아들이는 것이 아니라 내 기준에 맞춰 정제하여 취할 것은 취하고 버릴 것은 버리는 것이다.</p>\n<p>그러니 데이터 자체가 정답이라고 믿는 것이 아닌 데이터를 재료로 하여 나만의 가치관과 철학을 만드는 과정에 대해 더 깊은 고민을 해보는 것을 추천한다.</p>\n<p>이상으로 정답이 존재한다는 착각 포스팅을 마친다.</p>","fields":{"slug":"20241223-the-illusion-of-a-right-answer","path":"/2024/12/23/the-illusion-of-a-right-answer/","lang":"ko"},"frontmatter":{"title":"좋은 코드란 무엇일까? - 가독성이란 허상에 대하여","subTitle":"개발자의 판단력을 흐리는 정답 강박에서 벗어나기","date":"Dec 23, 2024","categories":["에세이"],"tags":["실존주의","가독성"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#d8c8b8","images":{"fallback":{"src":"/static/d8ae58549615ef582a117e086c2797bb/fc5c5/thumbnail.webp","srcSet":"/static/d8ae58549615ef582a117e086c2797bb/3e5ca/thumbnail.webp 80w,\n/static/d8ae58549615ef582a117e086c2797bb/b72f1/thumbnail.webp 160w,\n/static/d8ae58549615ef582a117e086c2797bb/fc5c5/thumbnail.webp 320w,\n/static/d8ae58549615ef582a117e086c2797bb/c5332/thumbnail.webp 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#d8c8b8","images":{"fallback":{"src":"/static/d8ae58549615ef582a117e086c2797bb/3b8a4/thumbnail.webp","srcSet":"/static/d8ae58549615ef582a117e086c2797bb/6858b/thumbnail.webp 750w,\n/static/d8ae58549615ef582a117e086c2797bb/f5547/thumbnail.webp 1080w,\n/static/d8ae58549615ef582a117e086c2797bb/29310/thumbnail.webp 1366w,\n/static/d8ae58549615ef582a117e086c2797bb/3b8a4/thumbnail.webp 1792w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5}}}}}},{"node":{"id":"f94c8754-7a93-51b8-a6d0-28e2b12cb24d","tableOfContents":"<ul>\n<li><a href=\"#chatgpt%EB%A5%BC-%EC%8D%BC%EB%8B%A4%EB%A9%B4-%EB%8D%94-%EC%9E%98%ED%95%A0-%EC%88%98-%EC%9E%88%EC%97%88%EC%9D%84-%EA%B2%83-%EA%B0%99%EC%95%84%EC%9A%94\">ChatGPT를 썼다면 더 잘할 수 있었을 것 같아요</a></li>\n<li><a href=\"#%EC%9D%B8%EA%B0%84-%EC%A1%B4%EC%9E%AC%EC%9D%98-%EB%B3%B8%EC%A7%88%EC%A0%81-%EC%9D%98%EC%9D%98%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">인간 존재의 본질적 의의는 무엇인가</a></li>\n<li><a href=\"#ai%EB%8A%94-%EC%9D%B8%EA%B0%84-%EC%A1%B4%EC%9E%AC%EC%9D%98-%EB%B3%B8%EC%A7%88%EC%9D%84-%EC%9C%84%ED%98%91%ED%95%98%EB%8A%94%EA%B0%80\">AI는 인간 존재의 본질을 위협하는가</a></li>\n<li><a href=\"#%EC%A7%80%EA%B8%88-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8B%B9%EC%8B%A0%EC%9D%80-%EB%88%84%EA%B5%AC%EC%9D%B8%EA%B0%80\">지금 프로그래밍을 하고 있는 당신은 누구인가</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","excerpt":"AI는 우리의 생활을 크게 변화시키고 있다. ChatGPT 모바일 앱을 사용하면서 음성으로 대화를 주고 받다보면 이제는 영화 아이언맨에 나오는 인공지능 비서 자비스가 현실화된 것이 아닌가 하는 착각마저도 일으킬 정도이다. ChatGPT와 같은 생성형 AI는 일상적인 대화부터 복잡한 문제 해결까지 다양한 용도로 사용되며, 우리의 삶을 더욱 윤택하게 만들고 있다. 그러나 필자는 이러한 기술의 발전이 선물해준 편리함 속에서 우리가 중요한 질문을 잊고 있는 것은 아닌지 돌아볼 필요가 있다고 생각한다. 바로 인간 존재의 본질적 의의에 대한…","html":"<p>AI는 우리의 생활을 크게 변화시키고 있다. ChatGPT 모바일 앱을 사용하면서 음성으로 대화를 주고 받다보면 이제는 영화 아이언맨에 나오는 인공지능 비서 자비스가 현실화된 것이 아닌가 하는 착각마저도 일으킬 정도이다.</p>\n<p>ChatGPT와 같은 생성형 AI는 일상적인 대화부터 복잡한 문제 해결까지 다양한 용도로 사용되며, 우리의 삶을 더욱 윤택하게 만들고 있다.</p>\n<p>그러나 필자는 이러한 기술의 발전이 선물해준 편리함 속에서 우리가 중요한 질문을 잊고 있는 것은 아닌지 돌아볼 필요가 있다고 생각한다. 바로 <strong>인간 존재의 본질적 의의</strong>에 대한 질문이다.</p>\n<p>지난 수천 년 동안 많은 철학자들은 인간이 자기 성찰, 비판적/이성적 사고, 자아 인식과 자기 성찰, 도덕적 판단과 같은 것들을 가지고 있기 때문에 인간일 수 있다고 이야기해왔다.</p>\n<p>하지만 최근 주변을 둘러보면 지금껏 우리가 인간으로 존재하기 위해 지녀야 한다고 이야기해왔던 많은 가치들을 ChatGPT와 같은 도구에게 위임하는 모습을 볼 수 있다.</p>\n<p>물론 지금의 생성형 AI는 아직 정확도가 높지 않기 때문에 많은 부분을 위임하지는 않겠지만, 그 위임이 이미 시작되고 있다는 것이 중요한 부분이며, AI의 발전속도를 생각해보면 앞으로 점점 더 빠른 속도로 위임이 이루어질 미래를 그리 어렵지 않게 그려볼 수 있다.</p>\n<p>하지만 AI가 발전하는 속도에 비해 이러한 윤리적/철학적 담론은 거의 배제되고 있다. 필자는 추후 AI가 더욱 발전했을 때 이러한 담론의 부재가 큰 사이드 이펙트로 돌아올 것이라고 생각하며, 특히 이 기술을 개발하고 있는 분들은 더더욱 이 아젠다에 관심을 가져야 한다고 생각한다.</p>\n<h2 id=\"chatgpt를-썼다면-더-잘할-수-있었을-것-같아요\" style=\"position:relative;\">ChatGPT를 썼다면 더 잘할 수 있었을 것 같아요<a href=\"#chatgpt%EB%A5%BC-%EC%8D%BC%EB%8B%A4%EB%A9%B4-%EB%8D%94-%EC%9E%98%ED%95%A0-%EC%88%98-%EC%9E%88%EC%97%88%EC%9D%84-%EA%B2%83-%EA%B0%99%EC%95%84%EC%9A%94\" aria-label=\"chatgpt를 썼다면 더 잘할 수 있었을 것 같아요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 지난 2016년부터 지금까지 수많은 개발자들의 인터뷰를 진행했었다. 만약 한 달에 4-6명씩 인터뷰를 진행했었다고 하면 대략 400-600명 정도 되는 인원을 만나본 셈이다.</p>\n<p>이러한 인터뷰를 통해 다양한 답변과 견해를 들을 수 있었지만, 최근에 들은 답변은 그동안의 경험에서 한 번도 듣지 못했던 것이었다.</p>\n<blockquote>\n<p>“ChatGPT를 썼다면 과제를 더 잘할 수 있었을 것 같아요”</p>\n</blockquote>\n<p>이는 필자에게 꽤나 독특하고 낯선 답변으로 다가왔다. 이것은 도구를 사용할 수 없었기 때문에 자신에게 주어진 문제를 온전히 풀어낼 수 없었다고 시인한 것이나 마찬가지이기 때문이다. 이 도구가 ChatGPT든, 구글링이든 상관없이 말이다.</p>\n<p>보통 인터뷰를 진행할 때 지원자들은 자신의 능력을 과소평가하는 말을 피하고, 오히려 도구가 없이도 펼칠 수 있는 자신 본연의 역량을 최대한 강조하려고 노력하기 마련이다. 이는 인터뷰라는 것이 도구가 없다면 문제를 해결할 수 없는 사람보다는 도구가 없어도 문제를 해결할 수 있되, 도구를 통해 자신의 역량을 부스팅할 수 있는 사람을 찾고자 하는 과정이라는 사실을 모두가 알고 있기 때문이기도 하다.</p>\n<p>혹시 이 글을 읽고 있는 누군가는 어차피 입사하면 ChatGPT를 사용할 것인데 역량 검증 과정에서 도구를 사용하는 것이 뭐가 문제냐고 할 수도 있다. 이 도구를 활용하는 역량을 검증하면 되는 것 아니냐고 말이다.</p>\n<p>물론 필자도 실무에서 ChatGPT를 사용한다. 그리고 필자는 ChatGPT를 업무에 잘 활용하면 생산성이 압도적으로 높아질 수 있다는 것을 부정하지도 않는다. 하지만 필자가 이 포스팅에서 이야기하고 싶은 주제는 “인터뷰에서 ChatGPT 활용 역량을 검증해야하냐”와 같은 지엽적인 주제는 아니다.</p>\n<p>한번 생각해보자. 지금이야 생성형 AI가 등장한지 2년 밖에 되지 않았으니 인간이 프롬프트를 잘 작성하기 위해 고민하는 과정이 필요하겠지만, 앞으로는 개떡같이 질문해도 찰떡같은 대답을 해주는 수준까지 금방 발전할 것이다.</p>\n<p>만약 이런 수준의 AI가 등장한다면 이 도구를 활용하는 역량을 검증한다는 것이 무슨 의미가 있을까? 아무런 지식이 없는 사람이 AI에게 대충 질문해도 찰떡같은 대답을 해주는 수준이 된다면 도구의 숙련도라는 개념도 어차피 무의미해진다.</p>\n<p>중요한 것은 생성형 AI인 ChatGPT가 세상에 소개된지 이제 겨우 2년 밖에 지나지 않았음에도 불구하고 AI라는 도구에 자신의 사고를 의존하는 사람들이 빠르게 늘어나고 있지만, 정작 “우리가 AI를 어떤 식으로 다뤄야 하는지”, “AI에게 사고를 의존한다는 것이 무슨 의미인지”와 같은 윤리적 담론에는 별로 주목하고 있지 않다는 것이다.</p>\n<p>서론에서 언급했듯이 물론 지금은 생성형 AI가 완전하지 않다는 사실에 대해 인간들도 알고 있으니 자신의 사고를 AI에게 온전히 위임하는 상황은 발생하지 않는다. 그러나 만약 인간이 보기에 AI가 자신보다 더 나은 답변을 내놓는다고 판단하기 시작한다면 그 위임의 정도는 빠르게 높아질 것이다.</p>\n<p>이는 단순히 도구를 활용하여 생산성을 증가시키는 것과는 완전히 다른 개념이다. 지금까지의 도구는 인간의 능력을 보조하는 역할을 하거나, 혹은 인간 스스로의 힘으로는 불가능한 일을 할 수 있도록 도와주는 역할이었다.</p>\n<p>하지만 AI는 인간과 거의 동등한 레벨의 사고와 의사결정을 할 수도 있는 존재이며, 이미 특정 분야에 대해서는 인간의 능력을 넘어선 경우도 있다. 즉, 지금까지의 도구와는 다르게 인간의 능력을 보조하는 정도를 넘어서서 인간의 사고 자체를 AI에게 위임하는 것도 가능하다는 것이다. 그리고 인간들이 이러한 가능성에 대해서 경계하는 움직임은 거의 보이지 않는다.</p>\n<p>생성형 AI가 세상에 본격적으로 등장한지 꼴랑 2년 밖에 되지 않은 지금도 사고의 일부를 AI에게 위임하는 상황들이 발생하고 있으니, 앞으로는 이런 상황들이 더더욱 많아질 것이라고 생각한다.</p>\n<h2 id=\"인간-존재의-본질적-의의는-무엇인가\" style=\"position:relative;\">인간 존재의 본질적 의의는 무엇인가<a href=\"#%EC%9D%B8%EA%B0%84-%EC%A1%B4%EC%9E%AC%EC%9D%98-%EB%B3%B8%EC%A7%88%EC%A0%81-%EC%9D%98%EC%9D%98%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"인간 존재의 본질적 의의는 무엇인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자가 가졌던 문제의식에 대해서 이야기하려면, 지금껏 우리가 무엇 때문에 인간으로 존재할 수 있다고 정의해왔는지부터 살펴봐야한다. “인간이란 무엇인가?”라는 질문은 지난 수천 년 동안 수 많은 철학자들이 탐구해온 주제이다.</p>\n<p>우리는 분명 다른 동물과 구분된 무언가를 가지고 있다는 사실을 알고 있지만, 그게 무엇인지에 대해서는 명확히 알려주는 이가 없었기에 수천 년 동안 스스로 탐구해온 것이다.</p>\n<p>플라톤은 이데아론을 통해 인간은 진리와 이상을 추구하는 존재라고 하였으며, 아리스토텔레스는 인간을 이성적 동물로 정의했다. 데카르트는 “나는 생각한다, 고로 존재한다”라는 명제를 통해 인간의 존재를 사유, 그리고 자아인식과 연결지었다. 칸트는 인간을 자율적이고 도덕적인 판단을 내리는 주체로 정의했으며, 사르트르는 인간이 스스로 자신의 본질을 창조하는 존재라 했다.</p>\n<p>이처럼 수많은 철학자들이 인간의 본질과 존재의 의의에 대해 다양한 정의를 내렸지만, 잘 살펴보면 공통적인 요소들이 몇 가지 있다.</p>\n<p>그 중에서도 가장 두드러지는 공통점은 바로 <strong>자기 성찰과 자아 인식</strong>이다. 이는 인간이 스스로를 이해하고, 자신의 생각과 행동을 분석하며, 자신의 존재에 대한 깊은 이해를 추구할 수 있는 능력을 뜻한다. 플라톤과 아리스토텔레스의 이성적 사고, 데카르트의 사유와 자아인식, 칸트의 도덕적 자율성, 사르트르의 본질 창조 모두 이러한 자기 성찰과 자아 인식을 중심으로 전개된다.</p>\n<p>즉 인간은 단순히 경험하고 반응하는 존재가 아니라, 자신의 경험을 분석하고 평가하며, 그로부터 새로운 의미와 방향을 찾아내는 존재라고 할 수 있는 것이다.</p>\n<p>지금까지의 철학자들이 강조한 인간의 본질적 특징, 자기 성찰과 자아 인식은 인간이 단순한 생물학적 존재를 넘어선 독특한 존재로서의 가치를 지니게 하는 핵심 요소이기 때문에 우리가 이 부분을 AI에게 위임할 가능성이 존재하는 한, 우리는 이 문제에 대해 깊은 고민과 성찰을 통해 들여다봐야 할 필요가 있다.</p>\n<h2 id=\"ai는-인간-존재의-본질을-위협하는가\" style=\"position:relative;\">AI는 인간 존재의 본질을 위협하는가<a href=\"#ai%EB%8A%94-%EC%9D%B8%EA%B0%84-%EC%A1%B4%EC%9E%AC%EC%9D%98-%EB%B3%B8%EC%A7%88%EC%9D%84-%EC%9C%84%ED%98%91%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"ai는 인간 존재의 본질을 위협하는가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>“ChatGPT를 썼다면 더 잘할 수 있었을 것 같아요”라는 지원자의 답변에서, 필자는 인간이 AI에게 사고를 점점 더 위임하게 됨으로써 발생할 수 있는 위험에 대해 이야기했다. 말 그대로 이 답변은 AI의 도움을 받지 못했기 때문에 과제를 제대로 수행할 수 없었다는 의미로, 인간의 사고 능력이 AI에 의존하게 되는 현상을 보여준다고 할 수 있다.</p>\n<p>인간이 스스로를 이해하고 자신의 생각과 행동을 분석하며, 자신의 존재에 대한 깊은 이해를 추구할 수 있는 능력, 즉 사고와 자기 성찰, 자아 인식이라는 것은 인간의 본질을 규정하는 중요한 요소이다. 이러한 능력들은 인간이 단순한 생물학적 존재를 넘어선 독특한 존재로서의 가치를 지니게 하는 핵심 요소라고 할 수 있다.</p>\n<p>이러한 근거를 토대로 필자는 AI가 인간 존재의 본질을 위협할 가능성에 대해 경계할 필요가 있다고 이야기하고 싶다.</p>\n<p>AI가 발전함에 따라 우리는 점점 더 많은 사고 과정을 AI에게 위임하고 있다. 우리가 어떠한 문제를 해결할 때 AI의 도움을 받는 것이 점점 일반화된다면, 스스로 깊이 생각하고 고민하는 과정을 생략하게 될 가능성이 높으며 이는 결국 자기 성찰의 기회를 잃게 만들고 우리의 사고 능력을 제한할 수 있다.</p>\n<p>더 나아가 AI가 인간의 의사결정까지도 점점 대신하게 된다면 인간은 자아 인식의 중요한 요소인 책임감과 자율성을 상실할 위험이 있다. 또한 AI가 내린 의사결정에 의존하게 될수록 우리는 그 결과에 대한 책임을 덜 느끼게 되고, 이는 우리의 도덕적 판단 능력을 약화시킬 수도 있다.</p>\n<p>이렇게 책임감과 도덕적 판단 능력에 대한 이야기는 이미 “자율주행차가 사고를 내면 누구의 책임인가?”와 같은 생활 속의 아젠다로 떠오른지 오래지만, 필자는 아직도 이런 아젠다에 대한 명쾌한 결론은 아무 것도 나오지 않았다는 점을 강조하고 싶다.</p>\n<p>우리는 AI의 발전과 그에 따른 의존도가 높아질수록 우리가 인간으로 정의될 수 있는 본질적인 능력을 잃어버릴 위험에 처하게 될 수도 있다는 사실을 경계해야하는 것이다. 그리고 이러한 경계심에서 비롯된 윤리적 담론은 이 기술을 선도하고 있는 사람들일수록 더더욱 신경써야 한다.</p>\n<h2 id=\"지금-프로그래밍을-하고-있는-당신은-누구인가\" style=\"position:relative;\">지금 프로그래밍을 하고 있는 당신은 누구인가<a href=\"#%EC%A7%80%EA%B8%88-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8B%B9%EC%8B%A0%EC%9D%80-%EB%88%84%EA%B5%AC%EC%9D%B8%EA%B0%80\" aria-label=\"지금 프로그래밍을 하고 있는 당신은 누구인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>다들 예상했겠지만 이 기술을 선도하고 있는 사람들은 바로 개발자와 학자들이다. 특히 그 중에서도 AI라는 도메인에 직접적인 기여를 하고 있는 분들일것이다.</p>\n<p>그러나 최근 들어 개발자들 사이에서도 ChatGPT나 Copilot 같은 AI 도구를 사용하며 AI가 제안한 코드를 비판 없이 수용하는 사례가 종종 보인다.</p>\n<p>물론 ChatGPT나 Copilot의 발전은 매우 빠르며, 예전보다 높은 퀄리티의 코드를 출력해내고 있다는 것은 사실이지만, 하지만 현재 시점에서 보았을 때 그것이 완벽하다고 말할 수 있을까?</p>\n<p>아니, 그렇지 않다. AI가 생성한 코드는 때때로 오류를 포함하고 있으며, 특정 상황에서는 완벽한 해결책을 제시하지 못할 때도 있다. 특히 여러 모듈의 맥락을 연결해가며 이해하고 아키텍쳐를 설계해야하는 부분은 아직 AI가 정복하지 못한 문제이다.</p>\n<p>만약 AI가 제안한 코드가 이미 완벽하다면 개발자라는 직업은 이미 사라져야 마땅하다. 그러나 개발자라는 직업이 여전히 존재한다는 사실이 아직 AI의 코드가 완전하지 않다는 사실을 역설하고있다. 앞으로 AI가 발전하면 점점 이 직업에 종사하는 인구가 줄어들지언정 현재로써는 아직 그렇지 않다는 이야기이다.</p>\n<p>그렇다면 이러한 기술에 전문성을 가지고 있는 우리는 어떤 역할을 해야 하는 것일까?</p>\n<p>개발자는 단순히 AI의 출력을 수용하는 것에서 그치지 않고, AI가 생성한 코드를 비판적으로 검토하고 수정해야 한다. 우리는 AI를 도구로써 바라보고 활용해야 하며, 그 도구를 통해 우리의 사고력과 창의성을 극대화해야 한다. AI의 도움을 받더라도, 최종적인 결정과 책임은 우리 자신에게 있다는 것이다.</p>\n<p>할루시네이션이 존재한다는 사실을 뻔히 알면서도 그 코드를 비판적인 검토없이 복붙하거나, AI의 답변이 진실된 것인 것처럼 믿는 것은 아직 시기상조이며, 혹여 AI가 완벽한 답변을 내놓는 순간이 온다고 해도 어디까지나 AI는 도구로써 전문가에게 컨트롤되어야 한다는 사실을 잊어서는 안된다. <small>(AI는 라이브러리이지, 프레임워크가 아니다)</small></p>\n<p>만약 AI의 출력을 비판없이 수용하고 마치 그것이 내 능력인 것처럼 착각하고 있다면, 스스로에게 한번 반문해보자.</p>\n<blockquote>\n<p>나는 AI라는 도구를 활용하는 인간인가? 아니면 AI가 내놓은 출력물을 IDE에 옮겨담고 있는 존재일 뿐인가?</p>\n</blockquote>\n<p>AI는 “내”가 될 수 없다. 우리는 AI의 도움을 받을 수 있지만, 그 도움을 받는 과정에서 스스로 생각하고 판단하는 능력을 잃지 않도록 경계해야한다.</p>\n<p>이러한 질문은 단순히 프로그래밍이라는 문제를 넘어, 인간의 본질에 대한 깊은 성찰을 요구한다. 인간이 본질적으로 자기 성찰과 자아 인식을 통해 스스로를 이해하고 자신의 존재 이유와 삶의 의미를 탐구하는 존재라면, 인간이 아닌 도구의 지시대로 행동하는 것만으로는 인간으로 존재할 수 없기 때문이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>혹자는 필자의 이런 생각이 시기적으로 너무 이른 생각이라고, 혹은 너무 비약적이라고 이야기할 수도 있다. 하지만 독자 여러분도 아시다시피 AI의 발전 속도는 생각보다 어마무시하며, 특정 분야에서는 10년도 되지 않은 시간 안에 AI가 인간을 넘어선 경우도 존재한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7800e68ab22994055e740f794b98ab78/4b190/graph.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3pRQf//EABYQAAMAAAAAAAAAAAAAAAAAABAgIf/aAAgBAQABBQJKP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABsQAAICAwEAAAAAAAAAAAAAAAABITERQWGB/9oACAEBAAE/IXfCnCwKSdHgR//aAAwDAQACAAMAAAAQAA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAEAAwADAQAAAAAAAAAAAAABABExIUFhgf/aAAgBAQABPxBLlcJUvQHYBzFS6YhXhXsBbT5M6NPRP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"graph\" title=\"\" src=\"/static/7800e68ab22994055e740f794b98ab78/c08c5/graph.jpg\" srcset=\"/static/7800e68ab22994055e740f794b98ab78/0913d/graph.jpg 160w,\n/static/7800e68ab22994055e740f794b98ab78/cb69c/graph.jpg 320w,\n/static/7800e68ab22994055e740f794b98ab78/c08c5/graph.jpg 640w,\n/static/7800e68ab22994055e740f794b98ab78/4b190/graph.jpg 800w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>수학은 그렇다치고 언어 이해력 부문의 무시무시한 기울기를 보자.</small>\n</center>\n<p>깃허브에 올라와 있는 AI 관련 프로젝트의 수는 2011년 기준 약 800개에 불과했었으나, 2023년에는 약 180만개로 증가했으며, 같은 기간동안 논문의 수도 약 3배 정도 증가했다.</p>\n<p>필자는 이처럼 기술이 빠르게 발전하는 속도에 비해 우리가 이 기술을 바라보는 시각, 이 기술로 인해 발생할 여러가지 사이드 이펙트에 대한 논의는 아직까지 그 속도에 맞게 발전하지는 않았다고 생각한다.</p>\n<p>AI는 근본적으로 지금까지의 도구와는 궤를 달리한다. 지금까지의 도구는 무슨 짓을 해도 결코 인간을 넘어설 수 없었으며, 그러한 태생적 한계로 인해 아무리 좋은 도구라고 해도 그저 인간을 보조하는 정도에 그쳤다.</p>\n<p>하지만 이미 위 차트에서 볼 수 있듯이 이미 AI는 인간을 넘어서고 있다. 물론 AGI가 등장하려면 시간이 조금 더 걸리겠지만, 적어도 특정 분야에서만큼은 이미 그러하다. 우리는 이 점에 주목해야한다.</p>\n<p>결국 필자가 이야기하고 싶은 것은 우리가 AI라는 편리하고 폭발적인 생산성을 가져다주는 도구를 사용하면서, 나도 모르게 인간으로서의 본질적 가치를 이 도구에게 위임하고 있는 것은 아닌지 돌아보자는 것이다.</p>\n<p>도구는 인간이 주도권을 가지고 활용되기 때문에 도구라고 할 수 있다. 만약 우리가 AI를 사용함으로써 인간으로서의 주체성과 본질적 의의를 잃는다면, 그것을 더 이상 도구라고 할 수 있을까?</p>\n<p>결국 우리가 AI와 함께 더 나은 미래를 만들어 가기 위해서는 이러한 윤리적/철학적 담론이 반드시 동반되어야 하며, 특히 이 기술을 선도하고 있는 사람들이라면 단지 기술의 발전에만 몰두하는 것이 아니라 이러한 논의에도 활발하게 참여하여 우리가 인간으로써 AI라는 좋은 도구를 제대로 활용할 수 있는 세상을 만드는 것에 관심을 가져한다는 사실을 강조하고 싶다.</p>\n<p>이상으로 지금 프로그래밍을 하고 있는 당신은 누구인가 포스팅을 마친다.</p>","fields":{"slug":"20240623-perspective-on-ai","path":"/2024/06/23/perspective-on-ai/","lang":"ko"},"frontmatter":{"title":"지금 프로그래밍을 하고 있는 당신은 누구인가","subTitle":"AI가 사고를 대신하는 시대, 우리는 무엇을 잃어가고 있는가","date":"Jun 23, 2024","categories":["에세이"],"tags":["ChatGPT","생성형 AI","Generative AI","철학"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/f3e7e95695f94e8513c768994ddcd10a/fc5c5/thumbnail.webp","srcSet":"/static/f3e7e95695f94e8513c768994ddcd10a/3e5ca/thumbnail.webp 80w,\n/static/f3e7e95695f94e8513c768994ddcd10a/b72f1/thumbnail.webp 160w,\n/static/f3e7e95695f94e8513c768994ddcd10a/fc5c5/thumbnail.webp 320w,\n/static/f3e7e95695f94e8513c768994ddcd10a/c5332/thumbnail.webp 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/f3e7e95695f94e8513c768994ddcd10a/3b8a4/thumbnail.webp","srcSet":"/static/f3e7e95695f94e8513c768994ddcd10a/6858b/thumbnail.webp 750w,\n/static/f3e7e95695f94e8513c768994ddcd10a/f5547/thumbnail.webp 1080w,\n/static/f3e7e95695f94e8513c768994ddcd10a/29310/thumbnail.webp 1366w,\n/static/f3e7e95695f94e8513c768994ddcd10a/3b8a4/thumbnail.webp 1792w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5}}}}}},{"node":{"id":"f07d2419-e407-55f5-9ab2-a0ef3e27bcb3","tableOfContents":"<ul>\n<li><a href=\"#101-%EB%8B%A4%ED%98%95%EC%84%B1-%ED%95%A8%EC%88%98polymorphic-functions\">10.1 다형성 함수(Polymorphic Functions)</a></li>\n<li><a href=\"#102-%EC%9E%90%EC%97%B0%EC%84%B1%EC%9D%84-%EB%84%98%EC%96%B4beyond-naturality\">10.2 자연성을 넘어(Beyond Naturality)</a></li>\n<li><a href=\"#103-%ED%8E%91%ED%84%B0-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACfunctor-category\">10.3 펑터 카테고리(Functor Category)</a></li>\n<li><a href=\"#104-2-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\">10.4 2-카테고리</a></li>\n<li><a href=\"#105-%EA%B2%B0%EB%A1%A0\">10.5 결론</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"필자는 지금까지 카테고리 사이의 구조를 보존하는 사상으로써의 펑터에 대해 이야기하였다. 펑터는 한 카테고리를 다른 카테고리에 포함(Embeds)한다. 이는 결국 펑터가 여러 대상을 하나로 합칠 수는 있지만, 절대 구조를 변형하지는 않는다는 것을 의미한다. 펑터에 대해 이해하는 방법 중 하나는 함자를 사용하여 하나의 카테고리를 다른 카테고리 내부에서 모델링해보는 것이다. 소스가 되는 카테고리는 대상이 될 카테고리의 일부인 구조적인 모델 또는 청사진 역할을 한다. 어떤 하나의 카테고리를 다른 카테고리에 포함시키는 방법에는 여러가지가 …","html":"<p>필자는 지금까지 카테고리 사이의 구조를 보존하는 사상으로써의 펑터에 대해 이야기하였다. 펑터는 한 카테고리를 다른 카테고리에 <a href=\"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts/#57-%EB%B9%84%EB%8C%80%EC%B9%AD%EC%84%B1asymmetry\">포함(Embeds)</a>한다. 이는 결국 펑터가 여러 대상을 하나로 합칠 수는 있지만, 절대 구조를 변형하지는 않는다는 것을 의미한다. 펑터에 대해 이해하는 방법 중 하나는 함자를 사용하여 하나의 카테고리를 다른 카테고리 내부에서 모델링해보는 것이다.</p>\n<p>소스가 되는 카테고리는 대상이 될 카테고리의 일부인 구조적인 모델 또는 청사진 역할을 한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c4214ca2fdd7dfbd1bc9f19c3c05ac86/c08c5/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 98.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvZ1EbCkBYP//EABkQAAMAAwAAAAAAAAAAAAAAAAABEQIQIP/aAAgBAQABBQKmTcJw1r//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAgEBPwFj/8QAFhAAAwAAAAAAAAAAAAAAAAAAACEw/9oACAEBAAY/AhQ//8QAGhABAQEAAwEAAAAAAAAAAAAAAQAREDFBUf/aAAgBAQABPyHEJJ2JfmT3719jgV2L/9oADAMBAAIAAwAAABAEDwD/xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPxAj/8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQIBAT8QRH//xAAeEAACAQQDAQAAAAAAAAAAAAABEQAhMUFxEFFhof/aAAgBAQABPxAjbNiBAgFWfZZECzajikA2IHxKnvghJ0x3AQn/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/c4214ca2fdd7dfbd1bc9f19c3c05ac86/c08c5/1.jpg\" srcset=\"/static/c4214ca2fdd7dfbd1bc9f19c3c05ac86/0913d/1.jpg 160w,\n/static/c4214ca2fdd7dfbd1bc9f19c3c05ac86/cb69c/1.jpg 320w,\n/static/c4214ca2fdd7dfbd1bc9f19c3c05ac86/c08c5/1.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>어떤 하나의 카테고리를 다른 카테고리에 포함시키는 방법에는 여러가지가 있을 수 있다. 대표적인 두 방법 중 하나의 방법은 소스 카테고리를 대상 카테고리가 가진 하나의 대상으로 축소시키는 방법, 그리고 다른 방법은 소스 카테고리의 각 대상을 대상 카테고리의 각 대상으로, 소스 카테고리의 각 사상을 대상 카테고리의 각 사상으로 매핑하는 방법이다. 즉, 같은 청사진이라고 해도 여러가지 방법으로 표현될 수 있다는 의미이다. 자연 변환은 이런 방법들을 비교하는 데 큰 도움이 된다. 자연 변환은 펑터들의 펑터적 성질을 보존해주는 특별한 사상이기 때문이다.</p>\n<p>카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 를 매핑하는 두 개의 펑터 <code class=\"language-text\">F</code>와 <code class=\"language-text\">G</code>를 한번 상상해보자. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>가 가진 하나의 대상인 <code class=\"language-text\">a</code>에 대해서 한번 생각해보자면, 이 펑터들은 두 개의 대상인 <code class=\"language-text\">F a</code>와 <code class=\"language-text\">G a</code>로 매핑될 것이다. 여기서 펑터들의 매핑이라는 말의 의미는 <code class=\"language-text\">F a</code>를 <code class=\"language-text\">G a</code>로 매핑하는 행위를 의미하는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f698739fc8d3c8896112a676ed3e29b5/c08c5/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 85%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGQABAQEAAwAAAAAAAAAAAAAAAAIDAQQF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB93OsjsuBUBYP/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAECEBFC/9oACAEBAAEFAtFLWOOiQq6P/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFxABAAMAAAAAAAAAAAAAAAAAIQAQIP/aAAgBAQAGPwKDbn//xAAbEAACAgMBAAAAAAAAAAAAAAABEQAxECFBwf/aAAgBAQABPyEiCXyNZAsObTozYjKFSuPGP//aAAwDAQACAAMAAAAQ8AcA/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAGhABAAMBAQEAAAAAAAAAAAAAAREhMQAQ4f/aAAgBAQABPxAQkELivnJjCqaInjIZxxKdCyuvIlZQh1sueCX1Vvxx4//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/f698739fc8d3c8896112a676ed3e29b5/c08c5/2.jpg\" srcset=\"/static/f698739fc8d3c8896112a676ed3e29b5/0913d/2.jpg 160w,\n/static/f698739fc8d3c8896112a676ed3e29b5/cb69c/2.jpg 320w,\n/static/f698739fc8d3c8896112a676ed3e29b5/c08c5/2.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>여기서 한 가지 유의해야할 점은 <code class=\"language-text\">F a</code>와 <code class=\"language-text\">G a</code> 모두 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상이라는 것이다. 동일한 카테고리 내의 대상들 사이의 매핑은 카테고리가 가진 특성을 위반해서는 안된다. 우리는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상들 사이에 인위적인 연결을 만들어내는 것이 아니라, 그저 사상이라는 개념을 <em>자연스럽게</em> 이용하면 되는 것이다.</p>\n<p>즉, 자연 변환은 <code class=\"language-text\">a</code>라는 대상으로 인해 발생할 수 있는 사상들 중 <code class=\"language-text\">F a → G a</code>와 같은 하나의 사상을 선택하는 것이라고 볼 수 있다. 이 자연 변환을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>(알파: a가 아니다.)라고 부른다면 이 사상은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>의 성분 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">α_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>(밑은 알파가 아닌 대상 a이다)라고 불린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 우리가 신경써야 하는 점은 대상 <code class=\"language-text\">a</code>는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 대상이고, 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">α_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 사상이라는 것이다.</p>\n<p>만약 어떠한 대상 <code class=\"language-text\">a</code>를 기반으로 한 매핑 결과 <code class=\"language-text\">F a</code>와 <code class=\"language-text\">G a</code> 사이에 사상이 존재하지 않는다면, 펑터 <code class=\"language-text\">F</code>와 펑터 <code class=\"language-text\">G</code> 간의 자연 변환 또한 존재할 수 없다는 의미이다.</p>\n<p>물론 이 이야기는 대상에 대한 이야기이므로 펑터가 만들어낼 수 있는 모든 케이스를 커버할 수 있는 것은 아니다. 왜냐하면 펑터들은 대상 뿐 아니라 사상 또한 매핑하기 때문이다. 그렇다면 사상들에 대해서는 자연 변환이 어떻게 작용하는 것일까?</p>\n<p>한번 임의의 사상을 <code class=\"language-text\">f</code>라고 해보자. 사상들이 표현하는 매핑 행위는 고정되어있으니, <code class=\"language-text\">F</code>와 <code class=\"language-text\">G</code> 사이의 어떤 자연 변환에서도 <code class=\"language-text\">F f</code>는 반드시 <code class=\"language-text\">G f</code>로 변환되어야 한다.</p>\n<p>이에 더해 펑터는 이 사상들의 매핑이 가진 특성을 보존해야한다는 제약을 가지고 있기 때문에 자연 변환의 정의 또한 이 제약에 얽매일 수 밖에 없다. 한번 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>가 가진 두 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 사이에 적용되는 사상 <code class=\"language-text\">f</code>를 생각해보자. 이 사상은 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>가 가진 두 개의 사상인 <code class=\"language-text\">F f</code>와 <code class=\"language-text\">G f</code>로 매핑될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">b</span>\n<span class=\"token constant\">G</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 내의 다이어그램을 완성할 수 있는 두 개의 사상을 추가적으로 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span>\nα<span class=\"token hvariable\">_b</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/baadfd22e8685308e55e728d5cb9234b/c08c5/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 82.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAIBBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7cJTYC1gJB//xAAZEAADAQEBAAAAAAAAAAAAAAAAAQIRMRD/2gAIAQEAAQUCdCoT0dG4lzyef//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABwQAAEDBQAAAAAAAAAAAAAAAAABESESIDFRkf/aAAgBAQAGPwKBNEDTwpMvZ//EABsQAQACAwEBAAAAAAAAAAAAAAEAERAhMXHR/9oACAEBAAE/IR4xZXsjxAFqyJsBXd21PIeNVPsYeYf/2gAMAwEAAgADAAAAEI8AAP/EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/EGP/xAAWEQEBAQAAAAAAAAAAAAAAAAABIDH/2gAIAQIBAT8QTI//xAAdEAEAAgEFAQAAAAAAAAAAAAABABFhECExQXGR/9oACAEBAAE/EEFgHK7HyJValJajmBwJ2SimNLALwYirjs0DV9rcdhpg05PJxez/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/baadfd22e8685308e55e728d5cb9234b/c08c5/3.jpg\" srcset=\"/static/baadfd22e8685308e55e728d5cb9234b/0913d/3.jpg 160w,\n/static/baadfd22e8685308e55e728d5cb9234b/cb69c/3.jpg 320w,\n/static/baadfd22e8685308e55e728d5cb9234b/c08c5/3.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>위 다이어그램을 보면 <code class=\"language-text\">F a</code>에서 <code class=\"language-text\">G b</code>로 가는 방법은 총 두 가지이다. 이 두 가지 방법이 동일한지 확인하려면 모든 f에 대해서 성립할 수 있는 <em>자연성</em> 조건을 부여해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G</span> <span class=\"token hvariable\">f</span> ◦ α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">=</span> α<span class=\"token hvariable\">_b</span> ◦ <span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이러한 자연성 조건은 매우 엄격한 제약이라고 볼 수 있다. 예를 들어 사상 <code class=\"language-text\">F f</code>가 가역적이라면 자연성 조건을 통해 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">α_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>만 사용해서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>b</mi></msub></mrow><annotation encoding=\"application/x-tex\">α_b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>를 결정해버릴 수 있다. 아래와 같이 말이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α<span class=\"token hvariable\">_b</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">G</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> ◦ α<span class=\"token hvariable\">_a</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span><span class=\"token operator\">^-</span><span class=\"token number\">1</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5c990e34263308dff03e8d7e9a68fc21/c08c5/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHaVqLAr//EABoQAAICAwAAAAAAAAAAAAAAAAERABIhIjH/2gAIAQEAAQUCeS6ji2RMDn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAaEAACAgMAAAAAAAAAAAAAAAAAERAhMWGh/9oACAEBAAY/AtDfJyWf/8QAGxABAAIDAQEAAAAAAAAAAAAAAQARIUFhcTH/2gAIAQEAAT8ha4N7LqIMXjsvsU2upRRp5MHxfJ//2gAMAwEAAgADAAAAEEjP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFREBAQAAAAAAAAAAAAAAAAAAEEH/2gAIAQIBAT8Qp//EAB8QAQACAQMFAAAAAAAAAAAAAAEAEUEhUWFxkaHB0f/aAAgBAQABPxBWTt7h8lONZq4cRiUBuKYMqAdb29xZdCYU+JUbrOmk/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/5c990e34263308dff03e8d7e9a68fc21/c08c5/4.jpg\" srcset=\"/static/5c990e34263308dff03e8d7e9a68fc21/0913d/4.jpg 160w,\n/static/5c990e34263308dff03e8d7e9a68fc21/cb69c/4.jpg 320w,\n/static/5c990e34263308dff03e8d7e9a68fc21/c08c5/4.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>만약 두 대상 사이에 여러 개의 가역적인 사상들이 존재한다면, 이 변환들은 모두 이 조건을 만족시켜야한다. 즉, 자연성 조건이 보장되는 상황이라면 어떤 경로를 따라가더라도 결국 동일한 결과에 다다라야 한다는 것이다. 그러나 일반적으로 사상들이 가역적인 경우는 별로 없기 때문에, 두 펑터 간의 자연 변환이 존재한다는 것이 항상 보장되는 것은 아니라고 이야기한 것이다.</p>\n<p>결과적으로는 이런 자연 변환을 통해 여러 펑터들이 작용하는 카테고리의 구조에 대한 많은 정보들을 표현해낼 수 있다. 추후 리미트와 요네다 보조정리에 대해 이야기할 때 이에 대한 몇 가지 예시를 다시 살펴볼 것이다.</p>\n<p>자연 변환을 각 요소 별로 뜯어서 살펴보면 결국 대상을 사상으로 매핑하는 것이라고 말할 수 있다. 자연성 조건으로 인해 사상을 교차하는 사각형 다이어그램으로 매핑한다고 볼 수도 있다는 것이다. 즉, 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>가 가진 각각의 사상에 대해서 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>는 이 사상들을 교차하는 자연성 사각형 다이어그램을 가지고 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7d47f98e7bebb1e14efececc63d81552/c08c5/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7mUnDDFf/8QAGBABAQADAAAAAAAAAAAAAAAAADEBAhH/2gAIAQEAAQUC6rEbI//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAAMAAAAAAAAAAAAAAAAAAAAgQf/aAAgBAQAGPwIq/wD/xAAaEAEBAQEAAwAAAAAAAAAAAAABEQAhMUFh/9oACAEBAAE/ITuRezdN4noc7gTHw/cAIE3/2gAMAwEAAgADAAAAEEsP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8QZ//EABwQAQEAAwADAQAAAAAAAAAAAAERACExUWFxkf/aAAgBAQABPxBq62oa+/ubDUeiDzmMNVRRrvuFUOtfbgkqKbFLkwh4M//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/7d47f98e7bebb1e14efececc63d81552/c08c5/5.jpg\" srcset=\"/static/7d47f98e7bebb1e14efececc63d81552/0913d/5.jpg 160w,\n/static/7d47f98e7bebb1e14efececc63d81552/cb69c/5.jpg 320w,\n/static/7d47f98e7bebb1e14efececc63d81552/c08c5/5.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>자연 변환이 가진 이러한 성질은 카테고리적인 구성을 할 때 매우 유용하다. 카테고리적인 구성을 할 때 종종 교차 다이어그램이 포함되는 경우가 많은데, 이때 적절한 펑터를 선택함으로써 이러한 교차성 조건을 자연성 조건으로 변환할 수 있다. 이는 추후 극한(limits), 쌍대극한(colimits), 수반(Adjunctions)에 대한 예시를 다룰 때 더 자세히 살펴보도록 하겠다.</p>\n<p>마지막으로 자연 변환은 펑터들의 동형사상을 정의하는 데에도 사용될 수 있다. 두 펑터가 자연적으로 동형이라고 말하는 것은 두 펑터가 거의 같다고 말하는 것과 동일한 말이다. <em>자연 동형성</em>은 모든 요소가 동형사상인 자연 변환으로 정의된다.</p>\n<h2 id=\"101-다형성-함수polymorphic-functions\" style=\"position:relative;\">10.1 다형성 함수(Polymorphic Functions)<a href=\"#101-%EB%8B%A4%ED%98%95%EC%84%B1-%ED%95%A8%EC%88%98polymorphic-functions\" aria-label=\"101 다형성 함수polymorphic functions permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 필자는 프로그래밍에서의 펑터(특히 엔도펑터)에 대해서 이야기해왔었다. 이 펑터는 타입을 다른 타입으로 매핑하는 타입 생성자에 해당한다. 또한 함수를 함수로 매핑하기도 하며, 이 매핑은 고계 함수 <code class=\"language-text\">fmap</code>에 의해 구현된다.</p>\n<p>자연 변환을 구성하기 위해서는 대상, 여기서는 타입 <code class=\"language-text\">a</code>부터 시작한다. 펑터 <code class=\"language-text\">F</code>는 이 타입을 타입 <code class=\"language-text\">F a</code>로 매핑할 것이다. 그리고 또 다른 펑터 <code class=\"language-text\">G</code>는 이 타입을 <code class=\"language-text\">G a</code>로 매핑한다. 이때 <code class=\"language-text\">alpha</code>라는 자연 변환의 성분은 타입 <code class=\"language-text\">a</code>이며, 이것은 결국 <code class=\"language-text\">F a</code>에서 <code class=\"language-text\">G a</code>로 매핑되는 함수를 의미한다. 이것을 Haskell 의사코드로 표현해보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>자연 변환은 모든 타입 <code class=\"language-text\">a</code>에 대해 정의되는 다형성 함수라고 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">forall</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">.</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서 <code class=\"language-text\">forall</code> 키워드는 선택적으로 사용할 수 있으며, 이 키워드를 사용하기 위해서는 <code class=\"language-text\">ExplicitForAll</code> 언어 확장을 활성화해야한다. 일반적으로는 아래와 같이 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 표현은 <code class=\"language-text\">a</code>에 의해 매개변수화된 함수라는 점에 주의하자. 이는 Haskell 구문의 간결함에 대한 또 다른 예시이기도 하다. 만약 C++에서 이와 유사한 구조를 표현하려면 약간 더 복잡해질 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span> G<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token function\">alpha</span><span class=\"token punctuation\">(</span>F<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서의 다형성 함수와 C++의 일반적인 함수 사이에는 더 깊은 차이가 있으며, 이 차이는 이러한 함수들이 구현되고 타입 검사되는 방식에도 그대로 적용된다. Haskell의 다형성 함수는 모든 타입에 적용될 수 있도록 일관되게 정의되어야한다. 즉, 하나의 공식이 모든 타입에 대해 작동해야한다는 것이다. 이를 *매개변수 다형성(Parametric polymorphism)*이라고 한다.</p>\n<p>C++은 기본적으로 특수 다형성(Ad hoc polymorphism)을 지원한다. 이는 어떤 하나의 템플릿이 반드시 모든 타입에 대해 적용될 수 있도록 정의될 필요는 없다는 것을 의미한다. 주어진 타입에 대해 템플릿이 적용될 수 있는지에 대한 여부는 인스턴스화 타임에 결정며, 이때 타입 매개변수가 구체적인 타입으로 대체된다. 이러한 과정 때문에 타입 검사가 느려지기도 하며, 가끔은 이해하기 어려운 에러 메시지를 만나기도 한다.</p>\n<p>C++에는 함수 오버로딩이나 템플릿 특수화 같은 매커니즘도 존재한다. 이를 통해 하나의 함수가 각기 다른 타입에 맞춰 다른 정의를 제공할 수도 있다. Haskell에서는 이런 기능이 타입 클래스와 타입 패밀리를 통해 제공된다.</p>\n<p>Haskell의 매개변수 다형성은 종종 예상치 못한 결과를 가져오기도 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">F</code>와 <code class=\"language-text\">G</code>는 펑터이며 자연성 조건을 자동으로 만족한다. 이를 카테고리적 표기법으로 나타내면 다음과 같다. (<code class=\"language-text\">f</code>는 함수 <code class=\"language-text\">f :: a -> b</code>이다)</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G</span> <span class=\"token hvariable\">f</span> ◦ α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">=</span> α<span class=\"token hvariable\">_b</span> ◦ <span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서 펑터 <code class=\"language-text\">G</code>의 사상 <code class=\"language-text\">f</code>에 대한 작용은 <code class=\"language-text\">fmap</code>을 사용하여 구현된다. 먼저 명시적인 타입 주석을 사용하여 Haskell 의사 코드로 작성해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">fmap_G</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">alpha_a</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">alpha_b</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">fmap_F</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사실 타입 추론 덕분에 이러한 주석들은 필요하지 않으며, 다음의 등식이 성립할 수 있게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">alpha</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">alpha</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이건 진짜 Haskell 문법이 아니라 의사 코드이다. 함수의 동등성은 코드로 표현할 수 없기 때문이다. 하지만 이런 항등식은 방정식 추론에 이용할 수 있으며, 컴파일러가 최적화를 구현하는 데에도 사용될 수 있다.</p>\n<p>Haskell에서 자연성 조건이 자동으로 성립하는 이유는 “공짜 정리(Theorems for free)와 관련이 있다. Haskell에서 자연 변환을 정의하는데 사용되는 매개변수 다형성은 모든 타입에 대해 작동할 수 있는 하나의 공식을 구현해야한다는 강력한 제한을 부과한다. 이러한 제한은 함수에 대해 방정식 정리를 사용할 수 있도록 만든다. 펑터를 변환하는 함수의 경우 공짜 정리는 자연성 조건을 의미한다.</p>\n<p>Haskell에서 펑터를 다루는 아이디어 중 하나는 바로 펑터를 일반화된 컨테이너로 간주하는 것이다. 비유를 해보자면 펑터는 자연 변환한 컨테이너의 내용을 다른 컨테이너로 다시 포장하는 일종의 레시피라고 볼 수 있다. 우리는 컨테이너 내부 요소 자체를 수정하거나 새로운 요소를 만드는 것과 같은 변화를 가하지 않는다. 단지 그 요소들을 복사하여 새로운 컨테이너에 담을 뿐이다.</p>\n<p>자연성 조건은 내부 요소를 <code class=\"language-text\">fmap</code>을 통해 먼저 수정하고 나중에 재포장하든, 재포장을 먼저 하고 새로운 컨테이너에서 내부 요소를 수정하든 상관없다는 것을 명시적으로 표현한다. 재포장과 <code class=\"language-text\">fmap</code>이라는 두 개의 동작은 마치 “계란을 옮긴다”, “계란을 끓인다”와 같이 직교적(서로 독립적)이라고 할 수 있다.</p>\n<p>한번 Haskell에서의 자연 변환을 보여주는 몇 가지 예시를 살펴보도록 하자. 첫 번째 예시는 <code class=\"language-text\">List</code> 펑터와 <code class=\"language-text\">Maybe</code> 펑터와의 자연 변환이다. 이 함수는 리스트의 첫 번째 요소를 반환하지만, 만약 리스트가 비어있다면 <code class=\"language-text\">Nothing</code>을 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">safeHead</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 <code class=\"language-text\">a</code>에 대해 다형적이다. <code class=\"language-text\">a</code>가 어떤 타입이든 함수는 제한없이 작동하기 때문에 매개변수 다형성을 갖추고 있다고 하는 것이다. 따라서 이 함수는 두 개의 펑터 사이의 자연 변환의 예시가 될 수 있다. 하지만 확실히 짚고 넘어가기 위해 자연성 조건을 한번 검증해보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">safeHead</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">safeHead</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 두 개의 경우를 고려해야한다. 먼저 빈 리스트에 대한 경우를 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n\n<span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그리고 비어있지 않은 리스트에 대해서도 대응해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">safeHead</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">:</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fx</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>List 펑터와 Maybe 펑터의 <code class=\"language-text\">fmap</code> 구현에 대해서도 한번 되짚어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token comment\">-- List</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">:</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">xs</span>\n\n<span class=\"token comment\">-- Maybe</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>더 흥미로운 예시는 펑터 중 하나가 단순한 <code class=\"language-text\">Const</code> 펑터인 경우이다. <code class=\"language-text\">Const</code> 펑터로부터 출발하거나 <code class=\"language-text\">Const</code> 펑터로 향하는 자연 변환은 반환 타입이나 인수 타입 중 하나에 다형성을 가진 함수와 동일하다.</p>\n<p>예를 들어 길이(length)는 <code class=\"language-text\">List</code> 펑터에서 <code class=\"language-text\">Const Int</code> 펑터로의 자연 변환으로 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">length</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Const</span> <span class=\"token constant\">Int</span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">length</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Const</span> <span class=\"token number\">0</span>\n<span class=\"token builtin\">length</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">unConst</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">length</span> <span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">unConst</code>는 <code class=\"language-text\">Const</code> 생성자를 제거하는데 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">unConst</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span>\n<span class=\"token hvariable\">unConst</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>물론 실제 <code class=\"language-text\">length</code>는 아래와 같이 단순하게 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">length</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 타입 시그니처는 <code class=\"language-text\">length</code>가 <code class=\"language-text\">List</code> 펑터에서 <code class=\"language-text\">Const</code> 펑터로의 자연 변환이라는 사실을 숨기고 있다.</p>\n<p>반면 <code class=\"language-text\">Const</code> 펑터에서 출발하는 매개변수 다형성 함수를 찾는 것은 조금 더 어려운 일이다. 왜냐하면 아무것도 없는 상태에서 값을 생성하기를 요구하기 때문이다. 따라서 우리가 할 수 있는 최선은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">scam</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Const</span> <span class=\"token constant\">Int</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">scam</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또 다른 펑터는 예전에 보았던 <code class=\"language-text\">Reader</code> 펑터이며, 이 펑터는 요네다 보조정리에서도 중요한 역할을 한다. <code class=\"language-text\">newtype</code> 키워드를 사용하여 <code class=\"language-text\">Reader</code> 펑터의 정의를 다시 작성해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">Reader</span> <span class=\"token hvariable\">e</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Reader</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">e</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것은 두 가지 타입으로 매개변수화되지만, 두 번째 유형에 대해서만 공변적으로 펑터적이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Reader</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>모든 타입 <code class=\"language-text\">e</code>에 대해서, <code class=\"language-text\">Reader e</code>에서 다른 펑터 <code class=\"language-text\">f</code>로의 자연 변환들을 정의할 수도 있다. 나중에 요네다 보조정리에 대한 이야기를 할 때 이 변환들의 구성원들이 항상 <code class=\"language-text\">f e</code>의 요소와 일대일 대응되는 것을 보게될 것이다.</p>\n<p>예를 들어 유닛 타입 <code class=\"language-text\">()</code>를 생각해보자. 이 타입은 단 하나의 원소인 <code class=\"language-text\">()</code>를 가진다. <code class=\"language-text\">Reader</code> 펑터는 임의의 타입 <code class=\"language-text\">a</code>를 가져와서 함수 타입 <code class=\"language-text\">() -> a</code>로 매핑한다. 그리고 이 함수는 집합 <code class=\"language-text\">a</code>에서 하나의 원소를 선택하는 모든 함수들을 의미한다. 즉, 이 함수들은 집합 <code class=\"language-text\">a</code>에 있는 원소들의 수만큼 존재하는 것이다.</p>\n<p>그럼 이제 이 펑터에서 <code class=\"language-text\">Maybe</code> 펑터로의 자연 변환을 생각해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Reader</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 자연 변환은 <code class=\"language-text\">dumb</code>와 <code class=\"language-text\">obvious</code> 두 가지 함수로 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">dumb</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n\n<span class=\"token hvariable\">obvious</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>(어차피 함수 <code class=\"language-text\">g</code>가 할 수 있는 유일한 행위는 값 <code class=\"language-text\">()</code>에 적용되는 것 뿐이다.)</p>\n<p>실제로 요네다 보조정리에서 예측된대로 이 두 함수들은 <code class=\"language-text\">Maybe ()</code> 타입의 두 요소들인 <code class=\"language-text\">Nothing</code>과 <code class=\"language-text\">Just ()</code>에 대응한다. 이에 대해서는 추후 요네다 보조정리를 이야기하며 더 자세히 살펴보도록 하겠다.</p>\n<h2 id=\"102-자연성을-넘어beyond-naturality\" style=\"position:relative;\">10.2 자연성을 넘어(Beyond Naturality)<a href=\"#102-%EC%9E%90%EC%97%B0%EC%84%B1%EC%9D%84-%EB%84%98%EC%96%B4beyond-naturality\" aria-label=\"102 자연성을 넘어beyond naturality permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>두 펑터 사이의 매개변수 다형성 함수는 항상 자연 변환이다. 즉, 모든 표준 대수적 데이터 타입은 펑터이니 이러한 타입들 사이의 모든 다형성 함수는 자연 변환이다.</p>\n<p>또한 우리는 함수 타입을 사용할 수 있으며, 함수 타입은 반환 타입에 대해 펑터적이다. 이를 사용하여 <code class=\"language-text\">Reader</code> 펑터와 같은 펑터를 만들고, 고차 함수인 자연 변환을 정의할 수도 있다.</p>\n<p>그러나 함수 타입은 인자 타입에 대해 공변적이지 않으며 반공변적으로 작동한다. 물론 반공변 펑터는 반대 카테고리에서의 공변 펑터와 동등하다. 두 반공변 펑터 사이의 다형성 함수를 카테고리적 의미에서 보았을때는 여전히 자연 변환이다. 단, 이것들은 반대 카테고리에서 Haskell 타입으로 가는 펑터에서 작동한다.</p>\n<p>이전에 보았던 반공변 펑터의 예시를 다시 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">Op</span> <span class=\"token hvariable\">r</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Op</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 펑터는 <code class=\"language-text\">a</code>에 대해 반공변적이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Contravariant</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">contramap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Op</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>우리는 이 펑터를 가지고 <code class=\"language-text\">Op Bool</code>에서 <code class=\"language-text\">Op String</code>으로 향하는 다형성 함수를 작성해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">predToStr</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Op</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token keyword\">then</span> <span class=\"token string\">\"T\"</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"F\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그러나 두 펑터가 모두 공변적이지 않기 때문에, 이것은 <strong>Hask</strong>에서의 자연 변환이 아니다. 그러나 두 펑터가 모두 반공변적이니, “반대” 자연성 조건을 만족할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">contramap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">predToStr</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">predToStr</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">contramap</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">contramap</code>의 시그니처 때문에 함수 <code class=\"language-text\">f</code>는 <code class=\"language-text\">fmap</code>을 사용할 때와는 반대 방향으로 가야한다는 점을 주목하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">contramap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token constant\">Bool</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Op</span> <span class=\"token constant\">Bool</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그렇다면 공변적이든 반공변적이든 펑터가 아닌 타입 생성자도 있을까? 여기 한 가지 예시가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것은 동일한 타입 <code class=\"language-text\">a</code>가 반공변 위치, 공변 위치 모두에서 사용되기 때문에 펑터가 아니며, 이 타입에 대한 <code class=\"language-text\">fmap</code>이나 <code class=\"language-text\">contramap</code>을 구현할 수도 없다. 따라서 아래와 같은 시그니처를 가진 함수는 자연 변환이 될 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>흥미롭게도 이러한 경우를 다루는 자연 변환의 일반화된 형태가 있으며, 이를 이자연 변환(Dinatural transformations)이라고 한다. 이에 대해서는 추후 끝(ends)에 대해 이야기할 때 다시 살펴볼 것이다.</p>\n<h2 id=\"103-펑터-카테고리functor-category\" style=\"position:relative;\">10.3 펑터 카테고리(Functor Category)<a href=\"#103-%ED%8E%91%ED%84%B0-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACfunctor-category\" aria-label=\"103 펑터 카테고리functor category permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이제 우리는 펑터 간의 사상인 자연 변환에 대해 알게 되었으므로, 펑터만으로 이루어진 카테고리도 존재하는지 대해서 이야기해볼 수 있게 되었다. 그리고 실제로 펑터로만 이루어진 카테고리는 존재한다. 각 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 향하는 펑터로만 이루어진 카테고리를 생각해보자. 이 카테고리의 대상은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 향하는 펑터이며, 사상은 이 펑터들 사이의 자연 변환일 것이다.</p>\n<p>또한 이미 우리는 사상을 어떻게 합성하는지 알고 있으니, 두 자연 변환의 합성의 정의 또한 쉽게 할 수 있다.</p>\n<p>한번 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>로 향하는 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>를 생각해보자. 이때 대상 <code class=\"language-text\">a</code>의 성분은 다음과 같은 사상이 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 이 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>를 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span></span>로 향하는 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>와 합성하려고 한다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 대상 <code class=\"language-text\">a</code>의 성분은 다음과 같은 사상이 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">β<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">H</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>당연히 이 사상들은 합성이 가능하며, 그 합성 결과는 또 다른 사상이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">β<span class=\"token hvariable\">_a</span> ◦ α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">H</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 두 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 합성인 이 사상을 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mo>⋅</mo><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">β ⋅ α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>의 성분으로 사용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span>β ⋅ α<span class=\"token punctuation\">)</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> β<span class=\"token hvariable\">_a</span> ◦ α<span class=\"token hvariable\">_a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/77760305bd4e45023763ece302c8b710/c08c5/6.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 67.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHbVqKGV//EABgQAQEBAQEAAAAAAAAAAAAAAAEAAhAR/9oACAEBAAEFAnUah9tQc//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAABAR/9oACAEBAAY/Amv/xAAaEAEAAwEBAQAAAAAAAAAAAAABACExERBB/9oACAEBAAE/ISwd+wgtyoAplDjSMa98/9oADAMBAAIAAwAAABAbz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EGf/xAAcEAEBAQACAwEAAAAAAAAAAAABEQAhQVFxgbH/2gAIAQEAAT8QUhII8mXOAUXas6fuTJIMfeH6Rw4yvyoaHjf/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"\" src=\"/static/77760305bd4e45023763ece302c8b710/c08c5/6.jpg\" srcset=\"/static/77760305bd4e45023763ece302c8b710/0913d/6.jpg 160w,\n/static/77760305bd4e45023763ece302c8b710/cb69c/6.jpg 320w,\n/static/77760305bd4e45023763ece302c8b710/c08c5/6.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>아래 다이어그램을 보면, 이 합성의 결과가 실제로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span></span>로 향하는 자연 변환임을 확인해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">H</span> <span class=\"token hvariable\">f</span> ◦ <span class=\"token punctuation\">(</span>β ⋅ α<span class=\"token punctuation\">)</span><span class=\"token hvariable\">_a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>β ⋅ α<span class=\"token punctuation\">)</span><span class=\"token hvariable\">_b</span> ◦ <span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/3ab8658c2500dadea960bfb7de8ab5c3/c08c5/7.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 96.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7lWcbpVALg//xAAbEAACAwADAAAAAAAAAAAAAAAAAQIRMRIyQf/aAAgBAQABBQLkWyOeJCVEuscP/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGRAAAgMBAAAAAAAAAAAAAAAAARAAESEx/9oACAEBAAY/AuMzKRf/xAAfEAABAwMFAAAAAAAAAAAAAAABABExIUFxEFFhscH/2gAIAQEAAT8hLCznRhE4W52jARzVEsdchMG9VeJQ40//2gAMAwEAAgADAAAAEDsHAP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABURAQEAAAAAAAAAAAAAAAAAAAEg/9oACAECAQE/EGP/xAAhEAEBAAIBAgcAAAAAAAAAAAABEQAhQRAxYXGBkbHB0f/aAAgBAQABPxC9VwDnyxRvT3YNeuVuEVu6ySKqivvGSM02QXn9wxFPCnABS7fGAFAFF9un/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"7\" title=\"\" src=\"/static/3ab8658c2500dadea960bfb7de8ab5c3/c08c5/7.jpg\" srcset=\"/static/3ab8658c2500dadea960bfb7de8ab5c3/0913d/7.jpg 160w,\n/static/3ab8658c2500dadea960bfb7de8ab5c3/cb69c/7.jpg 320w,\n/static/3ab8658c2500dadea960bfb7de8ab5c3/c08c5/7.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>자연 변환의 합성은 일반적인 사상과 동일하기 때문에 합성에 대한 결합법칙 또한 만족한다.</p>\n<p>마지막으로 각 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에 대해서는 성분이 항등 사상인 항등 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mn>1</mn><mi>F</mi></msub></mrow><annotation encoding=\"application/x-tex\">1_F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7944em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>도 존재할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">id_Fa</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>따라서 펑터로만 이루어진 카테고리도 존재한다고 말할 수 있는 것이다.</p>\n<p>참고로 이 책에서는 카테고리 이론의 공동 창시자인 사운더스 맥레인(Saunders Mac Lane)의 방식을 따라, 자연 변환의 합성을 점으로 표기하고 있다.</p>\n<p>문제는 자연 변환을 합성하는 방법이 하나가 아니라는 것이다. 이 방법들은 크게 수직 합성과 수평 합성으로 나누어진다. 그 중에서도 수직 합성은 일반적인 다이어그램에서 펑터와 자연 변환이 모두 수직으로 표기되기 때문에 불리는 명칭이며, 이는 펑터 카테고리를 이해할 때 중요한 개념이기도 하다. 또 다른 합성 방법인 수평 합성에 대해서는 다음 섹션에서 마저 설명하도록 하겠다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 623px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ea88c3814b829b2a248e93f9300f8566/50112/8.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdlaoUGD/8QAGxAAAgEFAAAAAAAAAAAAAAAAAAIBEBESEyH/2gAIAQEAAQUCdubDKCVuQlP/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAACAwEAAAAAAAAAAAAAAAAAEAERITH/2gAIAQEABj8CNXaNlf/EAB0QAQACAgIDAAAAAAAAAAAAAAEAMREhEGFBUXH/2gAIAQEAAT8h1MPmyCFsZx2/JZ1NTCR6lmwb4//aAAwDAQACAAMAAAAQo8//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPxCn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAQADAQADAAAAAAAAAAAAAREAITFhQVHx/9oACAEBAAE/EAAYIrcjz39yzAkAh6C7+8EQLVHTm+ZKPD4nyYzLsYna2d5vJM//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"8\" title=\"\" src=\"/static/ea88c3814b829b2a248e93f9300f8566/50112/8.jpg\" srcset=\"/static/ea88c3814b829b2a248e93f9300f8566/0913d/8.jpg 160w,\n/static/ea88c3814b829b2a248e93f9300f8566/cb69c/8.jpg 320w,\n/static/ea88c3814b829b2a248e93f9300f8566/50112/8.jpg 623w\" sizes=\"(max-width: 623px) 100vw, 623px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 간의 펑터 카테고리는 <code class=\"language-text\">Fun(C, D)</code> 또는 <code class=\"language-text\">[C, D]</code>로 표기되며, 때로는 지수 형태인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>로 표기되기도 한다. 특히 마지막 표기법이 흥미로운데, 이는 펑터 카테고리 자체가 다른 카테고리에서 함수 대상(지수 대상)으로 간주될 수 있음을 암시하고 있기 때문이다. 이에 대해서 한번 알아보자.</p>\n<p>지금까지 우리가 구축해온 추상화 계층들을 한번 살펴보자. 우리는 대상과 사상의 집합인 카테고리에서부터 시작해왔다. 카테고리 자체, 특히 집합의 카테고리인 작은 카테고리는 상위 레벨 카테고리인 <strong>Cat</strong>(카테고리의 카테고리)에서의 대상이 된다. 그리고 <strong>Cat</strong>의 사상은 결국 펑터이기 때문에 <strong>Cat</strong>의 Hom 집합은 펑터들의 집합이 될 것이다. 예를 들어 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mi>a</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Cat(C, D)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">)</span></span></span></span></span>는 두 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 간의 펑터들의 집합이다.</p>\n<p>펑터 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[C, D]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span></span></span></span></span> 역시 사상으로 자연 변환을 가지고 있다는 점만 제외하면 두 카테고리 간의 펑터들의 집합이라고 볼 수 있다. 이 카테고리의 대상은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mi>a</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Cat(C, D)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">)</span></span></span></span></span>의 원소와 동일하기 때문이다. 게다가 펑터 카테고리 또한 카테고리이기 때문에 <strong>Cat</strong>의 대상이 되어야 한다. 즉, 우리는 이 관계를 하나의 카테고리 내의 Hom 집합과 대상 간의 관계로 표현할 수 있다는 것이며, 이건 이전 섹션에서 보았던 지수 대상과 정확하게 같은 개념이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/4259939dc4841e14f984da03becbf3f3/c08c5/9.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 98.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAIBAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7aEb0qYIsV//xAAbEAACAgMBAAAAAAAAAAAAAAABAhARABIxIf/aAAgBAQABBQI9DRZoN6vCoOax/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFxAAAwEAAAAAAAAAAAAAAAAAASAxIf/aAAgBAQAGPwKxMK//xAAaEAADAQADAAAAAAAAAAAAAAAAATEREFFh/9oACAEBAAE/IXcNlGvpTClmkCGiJQQk7fH/2gAMAwEAAgADAAAAECsPvP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABURAQEAAAAAAAAAAAAAAAAAABEQ/9oACAECAQE/EFhP/8QAHhABAAICAgMBAAAAAAAAAAAAAREhADFBsRBRccH/2gAIAQEAAT8QRMlh4q4cOcaAsCIfuCARkck5EQbstxmZhMMutxzrDFCDYO4y5s7++8HUhqKOvH//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"9\" title=\"\" src=\"/static/4259939dc4841e14f984da03becbf3f3/c08c5/9.jpg\" srcset=\"/static/4259939dc4841e14f984da03becbf3f3/0913d/9.jpg 160w,\n/static/4259939dc4841e14f984da03becbf3f3/cb69c/9.jpg 320w,\n/static/4259939dc4841e14f984da03becbf3f3/c08c5/9.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>한번 <strong>Cat</strong>에서 이 개념을 어떻게 구성할 수 있는지 살펴보자.</p>\n<p>지수를 구성하기 위해서는 먼저 곱의 개념을 정의해야 한다는 것을 기억할 것이다. 다행히도 <strong>Cat</strong>에서는 곱을 정의하기가 비교적 쉽다. 각각의 작은 카테고리들은 대상들의 집합이므로, 곱이라는 개념을 집합의 곱으로 생각해도 무방할 것이다. 따라서 곱 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C × D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상은 그냥 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상들 중 하나씩 뽑아내어 구성된 대상들의 쌍 <code class=\"language-text\">(c, d)</code>이다.</p>\n<p>마찬가지로 두 개의 쌍 <code class=\"language-text\">(c, d)</code>와 <code class=\"language-text\">(c', d')</code> 간의 사상은 사상의 쌍 <code class=\"language-text\">(f, g)</code>으로, 이때 각 사상들은 <code class=\"language-text\">f :: c -> c'</code>와 <code class=\"language-text\">g :: d -> d'</code>가 될 것이다. 이러한 사상의 쌍은 성분 별로 합성되고, 항상 항등 사상의 쌍인 항등 쌍 또한 존재할 수 있다. 간단하게 말하자면 <strong>Cat</strong>은 완전한 데카르트 폐쇄 카테고리이기 때문에 모든 카테고리 쌍에 대한 지수 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>를 가진다는 의미이다. 이때 <strong>Cat</strong>의 대상이라는 것은 결국 카테고리를 의미하므로, 결론적으로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 간의 펑터 카테고리라고 말할 수 있다.</p>\n<h2 id=\"104-2-카테고리\" style=\"position:relative;\">10.4 2-카테고리<a href=\"#104-2-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\" aria-label=\"104 2 카테고리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><strong>Cat</strong>을 조금 더 자세히 들여다보자. 앞서 언급한 정의에 따라 <strong>Cat</strong>의 Hom 집합은 펑터들의 집합이다. 하지만 방금 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>C</mi><mo separator=\"true\">,</mo><mi>D</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[C, D]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mclose\">]</span></span></span></span></span>의 사례에서 보았듯이 두 대상 사이의 펑터는 단순한 집합 이상으로 더 풍부한 구조를 지니고 있다. 자연 변환을 사상으로 적용하여 카테고리를 형성할 수도 있기 때문이다. 펑터는 <strong>Cat</strong>에서 사상으로 간주되므로, 자연 변환은 사상 간의 사상이라고 할 수 있다.</p>\n<p>이처럼 더 풍부한 구조가 바로 2-카테고리의 예로, 2-카테고리에는 대상과 사상(또는 1-사상) 외에도 사상과 사상 간의 사상인 2-사상 또한 존재할 수 있다.</p>\n<p>즉, <strong>Cat</strong>를 2-카테고리라고 본다면</p>\n<hr>\n<ul>\n<li><strong>대상</strong>: 작은 카테고리들</li>\n<li><strong>1-사상</strong>: 카테고리 간의 펑터</li>\n<li><strong>2-사상</strong>: 펑터 간의 자연 변환</li>\n</ul>\n<hr>\n<p>으로 정의할 수 있다는 것이다.</p>\n<p>그렇다면 이제 우리는 두 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 간의 Hom 집합 대신에, Hom 카테고리인 펑터 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>를 가질 수 있게 된다. 그리고 이 펑터들은 합성될 수도 있다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>의 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mi>D</mi></msup></mrow><annotation encoding=\"application/x-tex\">E^D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span></span></span></span></span></span></span></span>의 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>가 합성되어 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">E^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>의 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>◦</mtext><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">G ◦ F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>를 얻을 수 있는 것처럼 말이다. 또한 각 Hom 카테고리 내에서 자연 변환 또는 2-사상이라고 부르는 수직 합성 또한 가질 수 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c46acab2023857c85a7f9ce461dc859f/c08c5/10.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAGQAAAQUAAAAAAAAAAAAAAAAAAAECAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdsSKLIwP//EABkQAAMAAwAAAAAAAAAAAAAAAAABAhESMf/aAAgBAQABBQJ92MlIUilH/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxAAAwEAAAAAAAAAAAAAAAAAACAx0f/aAAgBAQAGPwKphD//xAAaEAEAAwEBAQAAAAAAAAAAAAABABEhMXFh/9oACAEBAAE/IU6wHYaxH0qBTs9PiQbL2m+pS2P/2gAMAwEAAgADAAAAEJjv/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFhEBAQEAAAAAAAAAAAAAAAAAABEh/9oACAECAQE/EK1//8QAHRABAAEEAwEAAAAAAAAAAAAAAREAIUFRMWFxsf/aAAgBAQABPxAiPAhbfO6lBOMAkt33U0QOlo7qSWQKmYgoiMmkF04uxn2uBujRgr//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"10\" title=\"\" src=\"/static/c46acab2023857c85a7f9ce461dc859f/c08c5/10.jpg\" srcset=\"/static/c46acab2023857c85a7f9ce461dc859f/0913d/10.jpg 160w,\n/static/c46acab2023857c85a7f9ce461dc859f/cb69c/10.jpg 320w,\n/static/c46acab2023857c85a7f9ce461dc859f/c08c5/10.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>이제 이렇게 두 종류의 합성이 있는 2-카테고리에서 이 합성 체계들이 어떻게 상호작용하는지를 알아보도록 하자.</p>\n<p>우선 <strong>Cat</strong>에서 임의로 두 개의 펑터(1-사상)을 선택해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> <span class=\"token operator\">::</span> <span class=\"token constant\">C</span> <span class=\"token operator\">-></span> <span class=\"token constant\">D</span>\n<span class=\"token constant\">G</span> <span class=\"token operator\">::</span> <span class=\"token constant\">D</span> <span class=\"token operator\">-></span> <span class=\"token constant\">E</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그리고 이들의 합성은 아래와 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G</span> ◦ <span class=\"token constant\">F</span> <span class=\"token operator\">::</span> <span class=\"token constant\">C</span> <span class=\"token operator\">-></span> <span class=\"token constant\">E</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>에 작용하는 두 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>도 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token operator\">-></span> <span class=\"token constant\">F'</span>\nβ <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/26542db3b831313d7518b50db28363fd/c08c5/11.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 55.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHbS2AHD//EABoQAQACAwEAAAAAAAAAAAAAAAEAEQIQEiH/2gAIAQEAAQUCWdXBsfZlr//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAAMAAAAAAAAAAAAAAAAAAAEQIP/aAAgBAQAGPwKAv//EABsQAQADAQADAAAAAAAAAAAAAAEAEVEhEEGB/9oACAEBAAE/IWx+RWuPqdyoSl7ALffH/9oADAMBAAIAAwAAABBjz//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/EKf/xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8QTSf/xAAcEAEAAgMAAwAAAAAAAAAAAAABABEhMUEQYeH/2gAIAQEAAT8QxChEaFr8lRZYqO955iOfTpp9kpJsAwwA4+P/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"11\" title=\"\" src=\"/static/26542db3b831313d7518b50db28363fd/c08c5/11.jpg\" srcset=\"/static/26542db3b831313d7518b50db28363fd/0913d/11.jpg 160w,\n/static/26542db3b831313d7518b50db28363fd/cb69c/11.jpg 320w,\n/static/26542db3b831313d7518b50db28363fd/c08c5/11.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>이 쌍에는 수직 합성을 적용할 수가 없다. 왜냐하면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>를 통해 도달한 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 소스가 아니기 때문이다. 사실 이들은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>D</mi><mi>C</mi></msup></mrow><annotation encoding=\"application/x-tex\">D^C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span></span></span></span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mi>D</mi></msup></mrow><annotation encoding=\"application/x-tex\">E^D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span></span></span></span></span></span></span></span>라는 서로 다른 펑터 카테고리의 멤버이다. 하지만 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>를 통해 도달한 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">G’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">’</span></span></span></span></span>의 소스이기 때문에 이 두 펑터는 합성할 수 있다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>◦</mtext><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">G ◦ F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>’◦</mtext><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">G’◦ F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">’◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>는 무슨 관계일까? <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>를 가지고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>◦</mtext><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">G ◦ F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>’◦</mtext><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">G’◦ F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">’◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>로 향하는 자연 변환을 정의할 수는 있는 것일까? 다이어그램을 통해 전체적인 구조를 한번 살펴보자.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/dc97ff15d263e478db5b98e4123b69ec/c08c5/12.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 72.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMCBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHs4vKLCv/EABkQAQEBAAMAAAAAAAAAAAAAAAEAEQIhMf/aAAgBAQABBQJ9iTY494X/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAADAQAAAAAAAAAAAAAAAAAQICFh/9oACAEBAAY/AtSj/8QAGxABAAICAwAAAAAAAAAAAAAAAQARIWEQMcH/2gAIAQEAAT8hu6uqhbQ0+wAYKhyjk3XF/9oADAMBAAIAAwAAABAbD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAQADAQACAwAAAAAAAAAAAAEAESExQVGBkbH/2gAIAQEAAT8QWxoMKsTvusjDodBS1+bzYBBPaJSLiVT83GS6N6c/IFwftn//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"12\" title=\"\" src=\"/static/dc97ff15d263e478db5b98e4123b69ec/c08c5/12.jpg\" srcset=\"/static/dc97ff15d263e478db5b98e4123b69ec/0913d/12.jpg 160w,\n/static/dc97ff15d263e478db5b98e4123b69ec/cb69c/12.jpg 320w,\n/static/dc97ff15d263e478db5b98e4123b69ec/c08c5/12.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>가장 먼저 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 대상인 <code class=\"language-text\">a</code>에서 부터 출발해보자. 이 대상의 이미지는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 <code class=\"language-text\">F a</code>와 <code class=\"language-text\">F'a</code>라는 두 대상으로 나누어진다. 그리고 이때 이 두 대상을 연결하는 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>의 성분인 사상도 함께 생긴다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">F'</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로 갈 때, 이 두 개의 대상은 네 개의 대상으로 나누어진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 이 네 개의 대상을 서로 연결하는 정사각형, 즉 네 개의 사상 또한 생긴다. 그리고 이 사상들 중 두 개는 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 성분이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">β<span class=\"token hvariable\">_Fa</span>  <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\nβ<span class=\"token hvariable\">_F</span>’<span class=\"token hvariable\">a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그리고 다른 두 개의 사상은 두 펑터에 의한 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">α_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>의 이미지이다. (펑터는 사상 또한 매핑한다는 사실을 기억하자)</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G</span> α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n<span class=\"token constant\">G'</span>α<span class=\"token hvariable\">_a</span> <span class=\"token operator\">::</span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G'</span><span class=\"token punctuation\">(</span><span class=\"token constant\">F'</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>갑자기 사상이 너무 많아져서 조금 복잡해지긴 했지만, 결국 우리의 목표는 이 중 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>◦</mtext><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">G ◦ F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>’◦</mtext><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">G’◦ F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">’◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>를 연결하는 자연 변환의 성분이 될 수 있는 <code class=\"language-text\">G (F a)</code>에서 <code class=\"language-text\">G'(F'a)</code>로 향하는 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>β</mi><mtext>◦</mtext><mi>α</mi><msub><mo stretchy=\"false\">)</mo><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">(β◦α)_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>를 찾는 것이다.</p>\n<p>사실 위 다이어그램을 보면 <code class=\"language-text\">G (F a)</code>에서 <code class=\"language-text\">G'(F'a)</code>로 가는 경로는 총 두 가지이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">G'</span>α<span class=\"token hvariable\">_a</span> ◦ β<span class=\"token hvariable\">_Fa</span>\nβ<span class=\"token hvariable\">_F</span>’<span class=\"token hvariable\">a</span> ◦ <span class=\"token constant\">G</span> α<span class=\"token hvariable\">_a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>다행히도 이 두 경로는 같기 때문에 위 다이어그램의 정사각형은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 자연성 정사각형이된다.(다이어그램이 가환한다는 의미이다)</p>\n<p>이렇게 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>◦</mtext><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">G ◦ F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mtext>’◦</mtext><mi>F</mi><mtext>’</mtext></mrow><annotation encoding=\"application/x-tex\">G’◦ F’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">’◦</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\">’</span></span></span></span></span>로 향하는 자연 변환의 성분을 정의해보았다. 그리고 이 변환의 자연성을 증명하는 것은 귀찮은 과정이기는 하지만 꽤나 간단하게 해결이 가능한 부분이다.</p>\n<p>그리고 이 자연 변환을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi></mrow><annotation encoding=\"application/x-tex\">β</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span>의 수평 합성이라고 부르는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">β ◦ α <span class=\"token operator\">::</span> <span class=\"token constant\">G</span> ◦ <span class=\"token constant\">F</span> <span class=\"token operator\">-></span> <span class=\"token constant\">G'</span> ◦ <span class=\"token constant\">F'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>앞서 이야기했듯 이 책은 맥레인의 표기법을 따르고 있기 때문에, 수평 합성에는 작은 원(<code class=\"language-text\">◦</code>)을 사용한다. 참고로 다른 곳에서는 경우에 따라 별표(<code class=\"language-text\">*</code>)를 사용하는 경우도 있다.</p>\n<p>카테고리 이론을 공부할 때의 원칙 중 하나는 어떠한 합성이 있을 때마다 이 합성이 속한 카테고리도 찾아내야 한다는 것이다. 앞서 언급했던 자연 변환의 수직 합성은 펑터 카테고리의 일부였다. 그렇다면 수평 합성은 어떤 카테고리에 속하는 것일까?</p>\n<p>이것을 알아내는 방법은 <strong>Cat</strong>을 옆으로 보는 것이다. 자연 변환을 펑터 사이의 화살표가 아닌 카테고리 사이의 화살표로 본다. 그럼 이제 자연 변환은 자신이 변환하는 펑터가 연결하는 두 개의 카테고리 사이에 위치한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d1a5bd4e72d167a0a3646612dd7daa24/c08c5/13.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 28.750000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdu4SD//xAAWEAADAAAAAAAAAAAAAAAAAAAQEiH/2gAIAQEAAQUCrD//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAEDH/2gAIAQEABj8CKv/EABkQAQACAwAAAAAAAAAAAAAAAAEAQRExcf/aAAgBAQABPyHGhqIpSHZ//9oADAMBAAIAAwAAABAAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EEn/xAAbEAEAAgIDAAAAAAAAAAAAAAABABEhUWFxkf/aAAgBAQABPxBVUjRvi9eyuCWwIEMp7n//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"13\" title=\"\" src=\"/static/d1a5bd4e72d167a0a3646612dd7daa24/c08c5/13.jpg\" srcset=\"/static/d1a5bd4e72d167a0a3646612dd7daa24/0913d/13.jpg 160w,\n/static/d1a5bd4e72d167a0a3646612dd7daa24/cb69c/13.jpg 320w,\n/static/d1a5bd4e72d167a0a3646612dd7daa24/c08c5/13.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>이제 <strong>Cat</strong>의 두 대상인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 사이의 사상은 자신들을 연결해주던 펑터들을 연결하는 자연 변환이 되었다. 마찬가지로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로 향하는 펑터들을 연결하는 자연 변환도 있을테니, 이를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로 향하는 새로운 사상으로 간주할 수 있다. 결국 수평 합성은 이러한 관점에서 바라볼 때 사상들의 합성인 것이다.</p>\n<p>또한 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>로 향하는 항등 사상도 있을 것이다. 이때의 항등 사상은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 항등 펑터를 자기 자신으로 매핑하는 항등 자연 변환이다. 수직 합성에서의 항등 자연 변환은 모든 자연 변환의 수직 합성에 대해서 항등 역할을 할 수 있지만, 수평 합성에서는 항상 그렇지만은 않다는 것을 기억해두자.</p>\n<p>마지막으로 두 합성은 교환 법칙을 만족한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span>β' ⋅ α'<span class=\"token punctuation\">)</span> ◦ <span class=\"token punctuation\">(</span>β ⋅ α<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>β' ◦ β<span class=\"token punctuation\">)</span> ⋅ <span class=\"token punctuation\">(</span>α' ◦ α<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사운더스 맥레인(Saunders Mac Lane)의 말을 인용하자면 독자들은 이 사실을 증명하기 위해 명확한 다이어그램을 작성하는 것을 즐기게 될지도 모른다고 한다.</p>\n<p>나중에 유용하게 사용할 수 있는 표기법이 하나 더 있다. <strong>Cat</strong>을 옆에서 바라보겠다는 이 해석에서 어떤 대상에서 다른 대상으로 향하는 방법에는 펑터를 사용하는 방법과 자연 변환을 사용하는 두 가지 방법이 있었다. 이때 이 펑터 화살표를 펑터에 작용하는 특수한 종류의 자연 변환인 항등 자연 변환으로 재해석해볼 수도 있다. 그래서 종종 아래와 같은 표기법을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> ◦ α</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로 향하는 펑터이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 향하는 두 펑터 사이의 자연 변환이다. 펑터는 자연 변환과 합성할 수 없기 때문에, 이것은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>가 작용한 이후 항등 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mn>1</mn><mi>F</mi></msub></mrow><annotation encoding=\"application/x-tex\">1_F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7944em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>가 작용하는 수평 합성으로 해석하게된다.</p>\n<p>이와 마찬가지로 아래 표기는 항등 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mn>1</mn><mi>F</mi></msub></mrow><annotation encoding=\"application/x-tex\">1_F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7944em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>의 작용 이후 자연 변환 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">α</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span>가 작용하는 것으로 해석하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">α ◦ <span class=\"token constant\">F</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2 id=\"105-결론\" style=\"position:relative;\">10.5 결론<a href=\"#105-%EA%B2%B0%EB%A1%A0\" aria-label=\"105 결론 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇게 이 책의 첫 번째 파트를 마쳤다. 이제 우리는 카테고리 이론의 기본적인 용어들을 배웠으며, 대상과 카테고리를 명사로 생각하고 사상, 펑터 그리고 자연 변환을 동사로 생각할 수 있는 역량을 얻었다.</p>\n<p>사상은 대상을 연결하고 펑터는 카테고리를 연결하며 자연 변환은 펑터를 연결하는 것처럼 말이다.</p>\n<p>하지만 앞서 살펴보았듯이 한 수준의 추상화 단계에서는 동사로 보이는 것이 다음 수준에서는 대상이 되기도 한다. 마치 사상의 집합이 함수 대상이 되었던 것처럼 말이다. 그러면 이제 이 대상은 다시 다른 사상의 출발점이나 목표지점이 될 수 있게 된다. 이것이 우리가 알고있는 고차 함수(Higher Order Function)의 아이디어였다.</p>\n<p>펑터는 대상을 대상으로 매핑하기 때문에 이를 타입 생성자 또는 매개변수적 타입으로 사용할 수 있다. 또한 펑터는 사상도 매핑하는데, 이것이 바로 고차 함수인 <code class=\"language-text\">fmap</code>이다. <code class=\"language-text\">Const</code>, 곱, 쌍대곱과 같은 간단한 펑터들은 다양한 대수적 데이터 타입을 생성하는데 사용할 수도 있다. 함수 타입 또한 공변 펑터적인 성질과 반공변 펑터적인 성질을 모두 가지고 있으므로 대수적 데이터 타입을 확장하는데 사용할 수 있다.</p>\n<p>펑터는 펑터 카테고리에서 대상으로 간주될 수도 있다. 따라서 펑터는 자연 변환의 출발점과 목표가 되며, 자연 변환은 다형성 함수의 특별한 타입이라고 볼 수 있다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240601-category-theory-for-programmers-10-natural-transformations","path":"/2024/06/01/category-theory-for-programmers-10-natural-transformations/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 10. 자연 변환","subTitle":null,"date":"Jun 01, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"8c27f197-f80b-5745-8160-8b77ad6878d2","tableOfContents":"<ul>\n<li>\n<p><a href=\"#91-%EB%B3%B4%ED%8E%B8%EC%A0%81-%EA%B5%AC%EC%84%B1universal-construction\">9.1 보편적 구성(Universal Construction)</a></p>\n</li>\n<li>\n<p><a href=\"#92-%EC%BB%A4%EB%A7%81currying\">9.2 커링(Currying)</a></p>\n</li>\n<li>\n<p><a href=\"#93-%EC%A7%80%EC%88%98exponentials\">9.3 지수(Exponentials)</a></p>\n</li>\n<li>\n<p><a href=\"#94-%EB%8D%B0%EC%B9%B4%EB%A5%B4%ED%8A%B8-%EB%8B%AB%ED%9E%8C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACcartesian-closed-categories\">9.4 데카르트 닫힌 카테고리(Cartesian Closed Categories)</a></p>\n</li>\n<li>\n<p><a href=\"#95-%EC%A7%80%EC%88%98%EC%99%80-%EB%8C%80%EC%88%98%EC%A0%81-%EC%9E%90%EB%A3%8C%ED%98%95exponentials-and-algebraic-data-types\">9.5 지수와 대수적 자료형(Exponentials and Algebraic Data Types)</a></p>\n<ul>\n<li><a href=\"#951-0%EC%8A%B9\">9.5.1 0승</a></li>\n<li><a href=\"#952-1%EC%9D%98-%EC%A7%80%EC%88%98\">9.5.2 1의 지수</a></li>\n<li><a href=\"#953-1%EC%8A%B9\">9.5.3 1승</a></li>\n<li><a href=\"#954-%EC%A7%80%EC%88%98%EC%9D%98-%ED%95%A9\">9.5.4 지수의 합</a></li>\n<li><a href=\"#955-%EC%A7%80%EC%88%98%EC%9D%98-%EC%A7%80%EC%88%98\">9.5.5 지수의 지수</a></li>\n<li><a href=\"#956-%EA%B3%B1%EC%9D%98-%EC%A7%80%EC%88%98\">9.5.6 곱의 지수</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#96-%EC%BB%A4%EB%A6%AC-%ED%95%98%EC%9B%8C%EB%93%9C-%EB%8F%99%ED%98%95%EC%82%AC%EC%83%81curry-howard-isomorphism\">9.6 커리-하워드 동형사상(Curry-Howard Isomorphism)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></p>\n</li>\n</ul>","excerpt":"지금까지는 함수 타입의 의미를 간단하게만 설명해왔다. 하지만 조금 더 자세히 들여다보면 함수 타입은 다른 타입과는 약간 다른 특성을 가지고 있다. 예를 들어  타입은 그냥 정수들의 집합, 그리고  타입은 두 개의 원소로 이루어진 집합일 뿐이다. 그러나 함수 타입 은 대상 와  사이에 존재하는 모든 사상들의 집합이다. 어떤 카테고리에서 두 객체 사이의 존재하는 모든 사상들의 집합은 Hom 집합이라고 한다. 그리고 Hom 집합 또한 결국 집합이기 때문에 카테고리 Set(모든 집합의 카테고리)에서는 Hom 집합 또한 Set에 포함된 대…","html":"<p>지금까지는 함수 타입의 의미를 간단하게만 설명해왔다. 하지만 조금 더 자세히 들여다보면 함수 타입은 다른 타입과는 약간 다른 특성을 가지고 있다.</p>\n<p>예를 들어 <code class=\"language-text\">Integer</code> 타입은 그냥 정수들의 집합, 그리고 <code class=\"language-text\">Bool</code> 타입은 두 개의 원소로 이루어진 집합일 뿐이다. 그러나 함수 타입 <code class=\"language-text\">a -> b</code>은 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 사이에 존재하는 모든 사상들의 집합이다. 어떤 카테고리에서 두 객체 사이의 존재하는 모든 사상들의 집합은 Hom 집합이라고 한다. 그리고 Hom 집합 또한 결국 집합이기 때문에 카테고리 <strong>Set</strong>(모든 집합의 카테고리)에서는 Hom 집합 또한 <strong>Set</strong>에 포함된 대상이다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cb189cb187003cfbbbefe5161aefba06/bba1f/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 111.87500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAWABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAIDAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9rlzGiVVBGgr/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAERAhAS/9oACAEBAAEFAta8t6gmSijENCzOf//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CH//EABgQAQEBAQEAAAAAAAAAAAAAAAERAEEx/9oACAEBAAE/ISCujuBLoqg51nMLqeM3Bgm//9oADAMBAAIAAwAAABBkx7z/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAVEQEBAAAAAAAAAAAAAAAAAAAgIf/aAAgBAgEBPxCj/8QAHBABAAMBAAMBAAAAAAAAAAAAAQARITFBUWGB/9oACAEBAAE/EHBacrKPs2iv7AQSOpgvSC1FKvd/YJXxcQOh7DtgvtEAAcJ//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/cb189cb187003cfbbbefe5161aefba06/c08c5/1.jpg\" srcset=\"/static/cb189cb187003cfbbbefe5161aefba06/0913d/1.jpg 160w,\n/static/cb189cb187003cfbbbefe5161aefba06/cb69c/1.jpg 320w,\n/static/cb189cb187003cfbbbefe5161aefba06/c08c5/1.jpg 640w,\n/static/cb189cb187003cfbbbefe5161aefba06/bba1f/1.jpg 840w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>Hom 집합도 결국 집합이기 때문에 Set에 포함된 대상이다.</small>\n  <br>\n  <br>\n</center>\n<p><strong>Set</strong>이 아닌 다른 카테고리에서는 Hom 집합이 카테고리 외부에 있는 경우도 있다. 이런 경우 외부(External) Hom 집합이라고 한다.</p>\n<p>이것이 바로 함수 타입을 다른 타입보다 특별하게 만드는 카테고리 <strong>Set</strong>의 자기 참조적인 성격이다. 이런 카테고리에서는 Hom 집합을 나타내는 대상을 구성할 수 있는 방법이 존재하며, 이러한 대상을 내부(Internal) Hom 집합이라고 한다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/42654a7df0869c5e40df37dc0c04c694/232db/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 117.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAYABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHstILUJzI2Ff/EABoQAQACAwEAAAAAAAAAAAAAAAEAAhARIRL/2gAIAQEAAQUCtfyttQecgjhlaax//8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQAGPwIf/8QAHRAAAgIBBQAAAAAAAAAAAAAAAAERITEQQVFhof/aAAgBAQABPyGIVueBez0cw7dmJMCyibp//9oADAMBAAIAAwAAABCUyPz/xAAWEQEBAQAAAAAAAAAAAAAAAAAQEUH/2gAIAQMBAT8Qwp//xAAWEQEBAQAAAAAAAAAAAAAAAAAREAH/2gAIAQIBAT8Qhiz/xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhMRBRcYH/2gAIAQEAAT8QBQJ/EEbTi8QTUbht34I0jSmnBuACjUWo6SXKG6zx/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/42654a7df0869c5e40df37dc0c04c694/c08c5/2.jpg\" srcset=\"/static/42654a7df0869c5e40df37dc0c04c694/0913d/2.jpg 160w,\n/static/42654a7df0869c5e40df37dc0c04c694/cb69c/2.jpg 320w,\n/static/42654a7df0869c5e40df37dc0c04c694/c08c5/2.jpg 640w,\n/static/42654a7df0869c5e40df37dc0c04c694/232db/2.jpg 819w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>카테고리 C의 Hom 집합은 외부 Hom 집합이다.</small>\n  <br>\n  <br>\n</center>\n<h2 id=\"91-보편적-구성universal-construction\" style=\"position:relative;\">9.1 보편적 구성(Universal Construction)<a href=\"#91-%EB%B3%B4%ED%8E%B8%EC%A0%81-%EA%B5%AC%EC%84%B1universal-construction\" aria-label=\"91 보편적 구성universal construction permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 이제 함수 타입이 집합이라는 사실은 잠시 잊고, 함수 타입을 일반화하여 내부 Hom 집합이라고 생각해서 처음부터 구성해보도록 하자. 일반적으로는 <code class=\"language-text\">Set</code> 카테고리가 이 구성에 대한 단서를 주겠지만, 여기서는 집합의 특성에 의존하지 않고 생각해볼 것이다. 이런 과정을 통해 하나의 구성이 다른 카테고리에 자동으로 적용될 수 있도록 일반화해볼 수 있다.</p>\n<p>함수 타입은 인수 타입과 결과 타입과의 관계로 인해 복합적인 타입으로 간주된다. 이미 우리는 <a href=\"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts/\">곱 타입과 합 타입</a>이라는 대상 간의 관계를 포함하는 복합적인 타입들을 정의하기 위한 보편적 구성(Universal Construction)에 대해서 배웠던 적이 있다. 함수 타입을 정의하는 데도 동일한 방법을 사용해볼 수 있다.</p>\n<p>함수 타입을 정의하기 위해서는 구성하려는 함수 타입, 인수 타입, 결과 타입을 모두 포함하는 패턴이 필요하다.</p>\n<p>이 세 가지 타입을 연결하는 명확한 패턴은 함수 적용(Function application) 또는 평가(Evaluation)이라고 불린다. 만약 함수 타입의 후보인 대상을 <code class=\"language-text\">z</code>라고 하고 인수 타입인 대상을 <code class=\"language-text\">a</code>라고 할 때, 적용(Application)은 이 쌍을 결과 타입인 대상 <code class=\"language-text\">b</code>로 매핑하는 행위이다. 즉, 우리에게는 총 세 가지 대상이 있으며, 이 중 인수 타입과 결과 타입 두 가지는 고정되어있는 것이다.</p>\n<p>우리는 매핑인 적용도 가지고 있다. 어떻게 하면 이 매핑을 이 패턴에 통합할 수 있을까? 만약 우리가 대상 내부를 들여다볼 수 있다면, 집합 <code class=\"language-text\">z</code>의 원소인 함수 <code class=\"language-text\">f</code>와 집합 <code class=\"language-text\">a</code>의 원소인 인수 <code class=\"language-text\">x</code>를 짝지어 집합 <code class=\"language-text\">b</code>의 원소인 <code class=\"language-text\">f x</code>로 매핑할 수 있게 된다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8d0e9053a062a17fd43fa807d4d4d315/a847c/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAMBAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7NJoswoDYH//xAAYEAEAAwEAAAAAAAAAAAAAAAABAAIQIv/aAAgBAQABBQJt1lll1hHf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGBAAAgMAAAAAAAAAAAAAAAAAABAgISL/2gAIAQEABj8CdGY//8QAGRABAQEBAQEAAAAAAAAAAAAAAREAECEx/9oACAEBAAE/IWATzSYbgwGhI93xwHP/2gAMAwEAAgADAAAAEHQPAP/EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/ECP/xAAVEQEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAgEBPxBGP//EABwQAQACAgMBAAAAAAAAAAAAAAEAESExEEFhUf/aAAgBAQABPxC2pRkPdMtosqe9xVJ+p50wLo7JYQuaUuagEyECtHH/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/8d0e9053a062a17fd43fa807d4d4d315/c08c5/3.jpg\" srcset=\"/static/8d0e9053a062a17fd43fa807d4d4d315/0913d/3.jpg 160w,\n/static/8d0e9053a062a17fd43fa807d4d4d315/cb69c/3.jpg 320w,\n/static/8d0e9053a062a17fd43fa807d4d4d315/c08c5/3.jpg 640w,\n/static/8d0e9053a062a17fd43fa807d4d4d315/a847c/3.jpg 846w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>함수 집합 z에서 함수 f를 선택하고, 인수 타입 a의 집합에서 하나의 인수 x를 선택한다.<br>그러면 이제 집합 b에서 원소 f x를 얻을 수 있게된다.</small>\n  <br>\n  <br>\n</center>\n<p>그러나 이렇게 하나의 쌍인 <code class=\"language-text\">(f, x)</code>를 다루는 것보다는 함수 타입 <code class=\"language-text\">z</code>와 인수 타입 <code class=\"language-text\">a</code>의 전체적인 곱에 대해서 이야기하는 것이 더 일반화된 개념일 것이다. 곱 <code class=\"language-text\">z×a</code> 또한 하나의 대상이며, 이 대상에서 <code class=\"language-text\">b</code>로의 화살표인 우리의 적용 변형으로 <code class=\"language-text\">g</code>를 선택할 수 있다. <strong>Set</strong>에서는 <code class=\"language-text\">g</code>가 모든 쌍 <code class=\"language-text\">(f, x)</code>를 <code class=\"language-text\">f x</code>로 매핑하는 함수가 될 것이다.</p>\n<p>두 대상 <code class=\"language-text\">z</code>와 <code class=\"language-text\">a</code>의 곱이 사상 <code class=\"language-text\">g</code>에 의해 다른 대상 <code class=\"language-text\">b</code>로 연결되는, 이것이 바로 패턴이다.</p>\n<p>정말 이 패턴이 보편적 구성을 통해 함수 타입을 명확하게 정의할 수 있는 것일까? 사실 모든 카테고리에 대해서 생각해본다면 그렇지 않을 수도 있다. 하지만 우리가 지금 다루고자 하는 카테고리에 대해서는 충분하다.</p>\n<p>그렇다면 또 다른 질문을 해보자. 과연 우리는 곱을 먼저 정의하지 않고도 함수 대상을 정의할 수 있을까? 모든 쌍의 대상에 대해 곱이 없는 카테고리나 모든 쌍의 곱이 존재하지 않는 카테고리도 있지 않은가? 정답은 “아니다”이다. 곱 타입이 없다면 함수 타입도 존재할 수 없다. 이에 대한 내용은 추후 지수(Exponentials)에 대해 설명하며 다시 다루도록 하겠다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/4848023ae6caa38a3db6fb74b2138af9/c222a/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 57.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAexqolQ//8QAGhAAAgIDAAAAAAAAAAAAAAAAAAECERASIf/aAAgBAQABBQLZnSLtON5//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAHRAAAgIBBQAAAAAAAAAAAAAAAAERITEQQVFhkf/aAAgBAQABPyFsnpwco2wMsTQjOfRUtP/aAAwDAQACAAMAAAAQ08//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEBAAICAwAAAAAAAAAAAAABEQAhEDFRgbH/2gAIAQEAAT8QChg6Q7mWCE9lyiUGbJca3nwR8wAB0a4//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/4848023ae6caa38a3db6fb74b2138af9/c08c5/4.jpg\" srcset=\"/static/4848023ae6caa38a3db6fb74b2138af9/0913d/4.jpg 160w,\n/static/4848023ae6caa38a3db6fb74b2138af9/cb69c/4.jpg 320w,\n/static/4848023ae6caa38a3db6fb74b2138af9/c08c5/4.jpg 640w,\n/static/4848023ae6caa38a3db6fb74b2138af9/c222a/4.jpg 794w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이 그림이 바로 보편적 구성의 시작점인 대상과 사상의 패턴이다.</small>\n</center>\n<p>한번 보편적 구성에 대해 검토해보자. 우선 대상과 사상의 패턴에서부터 시작할 것이다. 물론 그저 대상과 사상의 패턴이라고만 하면 굉장히 많은 결과가 매칭될 것이기 때문에 이대로는 상당히 부정확한 쿼리라고 할 수 있다.</p>\n<p><strong>Set</strong>에서는 거의 모든 것이 서로 연결되어있다. 어떤 대상 <code class=\"language-text\">z</code>와 대상 <code class=\"language-text\">a</code>의 곱을 형성할 수도 있으며, 이 곱에서 <code class=\"language-text\">b</code>로의 함수도 존재할 수 있다. (단, <code class=\"language-text\">b</code>가 빈 집합일 경우는 제외한다.)</p>\n<p>이제 이 패턴의 결과들에 대한 순위를 매긴다는 비밀무기를 꺼내볼 차례이다. 일반적으로 후보 대상들 사이에는 이 구성을 어떤 방식이로든 분해할 수 있는 고유한 매핑이 있어야 한다.</p>\n<p>필자는 <code class=\"language-text\">z</code>와 <code class=\"language-text\">z×a</code>에서 <code class=\"language-text\">b</code>로 향하는 사상 <code class=\"language-text\">g</code>가 <code class=\"language-text\">z'</code>와 이에 적용되는 사상 <code class=\"language-text\">g’</code>보다 우수하다고 결정할 것이다. 그리고 만약 이 결정이 참이라면 <code class=\"language-text\">z'</code>에서 <code class=\"language-text\">z</code>로 향하는 유일한 사상 <code class=\"language-text\">h</code>이 존재해야 할 것이다. 그리고 이 사상은 <code class=\"language-text\">g'</code>를 적용한 결과와 <code class=\"language-text\">g</code>를 적용한 결과가 동일하다는 것 또한 보장해야한다. (잘 이해되지 않는다면 아래 그림을 보면서 이 문장을 읽어보자.)</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d7e642209529d3ac993be63af211510a/d4b53/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdqkqDCh/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAERAhD/2gAIAQEAAQUCd7oQlD//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAIDH/2gAIAQEABj8CWn//xAAcEAEAAgEFAAAAAAAAAAAAAAABABFBECFRYYH/2gAIAQEAAT8hVniDsaF78gaLcRBlP//aAAwDAQACAAMAAAAQs8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAWEQADAAAAAAAAAAAAAAAAAAABEDH/2gAIAQIBAT8QEX//xAAaEAEBAAMBAQAAAAAAAAAAAAABEQAhMRCh/9oACAEBAAE/EGiUKRHuLsOnb45ey0LvzFWONTdxwK2prmf/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/d7e642209529d3ac993be63af211510a/c08c5/5.jpg\" srcset=\"/static/d7e642209529d3ac993be63af211510a/0913d/5.jpg 160w,\n/static/d7e642209529d3ac993be63af211510a/cb69c/5.jpg 320w,\n/static/d7e642209529d3ac993be63af211510a/c08c5/5.jpg 640w,\n/static/d7e642209529d3ac993be63af211510a/d4b53/5.jpg 853w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>함수 대상에 대한 후보들 간의 순위를 결정한다.</small>\n</center>\n<p>여기가 조금 어려운 부분인데, 이게 바로 필자가 이 보편적 구성에 대한 정의를 계속 질질 끌고 있던 이유이다. 사상 <code class=\"language-text\">h :: z'-> z</code>가 주어졌을 때 우리는 <code class=\"language-text\">z’</code>와 <code class=\"language-text\">z</code>가 모두 <code class=\"language-text\">a</code>와 연결되어있는 다이어그램을 닫기를 원한다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>다이어그램을 닫는다는 이야기가 이해하기 어렵다면, 자료구조 그래프를 떠올려보면 된다. 여기서 <code class=\"language-text\">z’</code>와 <code class=\"language-text\">z</code>가 모두 연결되어있는 다이어그램을 닫고 싶다는 의미는, <code class=\"language-text\">z→a</code>, <code class=\"language-text\">z’→a</code>, <code class=\"language-text\">z’→z</code>처럼 연결되어있고 다른 대상들과는 이어지지 않은 그래프를 만들고 싶다는 의미이다.</p>\n</blockquote>\n<p>이를 위해 필요한 것은 <code class=\"language-text\">z’</code>에서 <code class=\"language-text\">z</code>로 향하는 매핑 <code class=\"language-text\">h</code>가 주어졌을 때, 이를 이용해서 <code class=\"language-text\">z'×a</code>에서 <code class=\"language-text\">z×a</code>로의 매핑을 얻어내는 것이다. 앞서 <a href=\"/2024/04/02/category-theory-for-programmers-8-functoriality/\">곱의 함수적인 특징</a>에 대해 논의했었으니, 이제 이 과정에 대해 이해할 수 있을 것이다.</p>\n<p>곱 자체는 펑터, 정확하게는 엔도 이항 펑터이기 때문에 쌍에 대한 사상을 리프팅할 수 있다. 다른 말로 하면 우리는 대상의 곱 뿐만 아니라 사상의 곱도 정의할 수 있다는 것이다.</p>\n<p>이를 리프팅하기 위해 곱 <code class=\"language-text\">z'×a</code>의 두 번째 구성 요소인 <code class=\"language-text\">a</code>에는 아무런 영향을 끼치지 않아야 하므로, <code class=\"language-text\">a</code>에 대한 항등사상인 <code class=\"language-text\">id</code>를 사용하여 사상의 쌍 <code class=\"language-text\">(h, id)</code>를 리프팅할 것이다.</p>\n<p><code class=\"language-text\">g’</code>를 <code class=\"language-text\">g</code>가 포함된 식으로 인수 분해하는 방법은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">h</span> × <span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서의 핵심은 곱이 사상에 대해서 어떻게 작용하고 있는지를 보는 것이다.</p>\n<p>보편적 구성의 세 번째 파트는 보편적으로 가장 좋은 대상을 선택하는 것이었다. 필자는 이 대상을 <code class=\"language-text\">a ⇒ b</code>라고 부를 것이다. (참고로 이건 어떤 대상에 대한 상징적인 이름이며, Haskell 타입 클래스 제약과는 관련없는 네이밍이다. 추후에 조금 더 다양한 방법으로 이름을 지을 수 있는 방법에 대해 논의해보겠다.)</p>\n<p><code class=\"language-text\">a ⇒ b</code>라는 대상은 <code class=\"language-text\">(a ⇒ b) × a</code> 에서 <code class=\"language-text\">b</code>로 향하는 사상인 <code class=\"language-text\">eval</code>이라는 적용을 가지고 있다. 만약 다른 함수 대상 후보로부터 출발하는 사상 <code class=\"language-text\">g</code>가 <code class=\"language-text\">eval</code>을 포함한 식으로 분해되어 이 대상에 유일하게 매핑될 수 있다면, 대상 <code class=\"language-text\">a ⇒ b</code>가 가장 적합한 후보라고 할 수 있을 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/36c0f5325a8dadf4bf7dcae580413720/edf8d/6.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 76.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHt1CNUq//EABkQAAIDAQAAAAAAAAAAAAAAAAABAhExIf/aAAgBAQABBQJ6sJIUeUf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAQICH/2gAIAQEABj8CSj//xAAcEAACAgIDAAAAAAAAAAAAAAABEQAhUZEQMUH/2gAIAQEAAT8hZrqMOBSznE6j7gEenc//2gAMAwEAAgADAAAAEBsP/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQMBAT8Qh//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ECf/xAAcEAEBAAMAAwEAAAAAAAAAAAABEQAhMUFRscH/2gAIAQEAAT8QDr4QDtxEsS++GDeZuhNAI/cdQVdcfMuza3H/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"\" src=\"/static/36c0f5325a8dadf4bf7dcae580413720/c08c5/6.jpg\" srcset=\"/static/36c0f5325a8dadf4bf7dcae580413720/0913d/6.jpg 160w,\n/static/36c0f5325a8dadf4bf7dcae580413720/cb69c/6.jpg 320w,\n/static/36c0f5325a8dadf4bf7dcae580413720/c08c5/6.jpg 640w,\n/static/36c0f5325a8dadf4bf7dcae580413720/edf8d/6.jpg 929w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이것이 보편적 구성을 통한 함수 대상의 정의이다. 위 그림과 동일한 다이어그램이지만 이제 대상 a ⇒ b가 가장 보편적이게 되었다.</small>\n</center>\n<p>한번 정리해보자.</p>\n<p><code class=\"language-text\">a</code>에서 <code class=\"language-text\">b</code>로 향하는 <strong>함수 대상</strong>은 대상 <code class=\"language-text\">a ⇒ b</code>와 사상 <code class=\"language-text\">eval :: ((a ⇒ b) × a) -> b</code> 으로 정의된다. 만약 임의의 다른 대상 <code class=\"language-text\">z × a</code>에서 <code class=\"language-text\">b</code>로 향하는 사상 <code class=\"language-text\">g :: z × a -> b</code>가 주어진다면, <code class=\"language-text\">z</code>에서 <code class=\"language-text\">a ⇒ b</code>로 향하는 유일한 사상 <code class=\"language-text\">h :: z -> (a ⇒ b)</code>이 존재해야하고, 최종적으로 <code class=\"language-text\">g</code>는 <code class=\"language-text\">eval</code>을 포함한 식으로 분해될 수 있어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">eval</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">h</span> × <span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>물론 모든 카테고리에서 반드시 임의의 대상의 쌍 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>에 대해 대상 <code class=\"language-text\">a ⇒ b</code>가 반드시 존재할 것이라는 보장은 없다. 하지만 최소한 <strong>Set</strong>에서만큼은 항상 존재한다. 게다가 이 대상은 Set의 Hom 집합인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Set(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>와도 동형이다.</p>\n<h2 id=\"92-커링currying\" style=\"position:relative;\">9.2 커링(Currying)<a href=\"#92-%EC%BB%A4%EB%A7%81currying\" aria-label=\"92 커링currying permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수 대상에 대한 후보를 다시 한번 살펴보자. 그러나 이번에는 사상 <code class=\"language-text\">g</code>를 두 변수 <code class=\"language-text\">z</code>와 <code class=\"language-text\">a</code>에 대한 함수로 생각해볼 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">z</span> × <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>대상의 곱으로부터 출발한 사상은 두 개의 변수를 가진 함수와 유사한 형태를 가지고 있다. <strong>Set</strong>에서 <code class=\"language-text\">g</code>는 집합 <code class=\"language-text\">z</code>과 집합 <code class=\"language-text\">a</code>에서 값을 하나씩 가져와 구성한 쌍에서 출발하게 될 것이다.</p>\n<p>그리고 함수 <code class=\"language-text\">g</code>가 가진 보편적인 속성에 따라 각각의 <code class=\"language-text\">g</code>에 대해 <code class=\"language-text\">z</code>를 함수 대상 <code class=\"language-text\">a ⇒ b</code>로 매핑하는 유일한 사상 <code class=\"language-text\">h</code> 또한 존재한다는 것을 떠올려볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">h</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">z</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><strong>Set</strong>에서는 단순히 <code class=\"language-text\">h</code>가 타입이 <code class=\"language-text\">z</code>인 변수를 하나 받아 <code class=\"language-text\">a</code>에서 <code class=\"language-text\">b</code>로 향하는 함수를 반환하는 함수임을 의미한다. 이러한 정의는 <code class=\"language-text\">h</code>를 고차함수(Higher ordered function)로 만든다.</p>\n<p>따라서 보편적 구성은 이변수 함수와 함수를 반환하는 일변수 함수 간의 일대일 대응을 설정한다. 이 대응은 커링(Currying)이라고 불리며, <code class=\"language-text\">h</code>는 <code class=\"language-text\">g</code>의 커링된(Curried) 버전이라고 한다.</p>\n<p>이처럼 어떤 <code class=\"language-text\">g</code>가 주어졌을때 유일한 <code class=\"language-text\">h</code>가 존재하고, 어떤 <code class=\"language-text\">h</code>가 주어질 때도 아래의 공식을 이용하여 이변수 함수인 <code class=\"language-text\">g</code>를 다시 생성할 수 있기 때문에 일대일 대응이라고 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">eval</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">h</span> × <span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 함수 <code class=\"language-text\">g</code>는 <code class=\"language-text\">h</code>의 커링되지 않은(Uncurried) 버전이라고 할 수 있다. 사실 커링은 함수가 함수를 반환하는 Haskell의 구문만으로도 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이런 문법은 보통 아래와 같이 괄호가 제거된 시그너치를 통해 이변수 함수로 해석된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이러한 해석은 다인수 함수를 정의할 때 명확하게 확인해볼 수 있다. 예를 들어 아래와 같은 함수처럼 말이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">catstr</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">catstr</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">s'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 함수는 하나의 인수를 받아 다시 함수를 반환하는 형태로도 작성할 수 있다. 만약 람다로 표현하면 다음과 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">catstr'</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">s'</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 두 정의는 동등하며, 두 정의 중 어떤 것을 사용하든 하나의 인수에 대해 부분 적용되어 아래와 같이 하나의 인수를 받은 함수를 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">greet</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">greet</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">catstr</span> <span class=\"token string\">\"Hello \"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>엄밀히 말하자면 이변수 함수는 곱 타입인 쌍을 받는 함수이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 두 개의 표현 간의 변환은 간단하다. 이미 예상했겠지만 이러한 변환을 수행하는 두 개의 고차함수는 <code class=\"language-text\">curry</code>와 <code class=\"language-text\">uncurry</code>로 불린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">curry</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">curry</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">uncurry</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">uncurry</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">curry</code>가 함수 대상의 보편적 구성을 위한 인수분해(factorization)라는 점에 주목하자. 이 점은 아래와 같은 형태로 다시 작성해보면 더 명확하게 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorizer</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">factorizer</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>다시 한번 짚고 넘어가자면 <code class=\"language-text\">factorizer</code>라는 인수분해 행위는 후보로부터 분해 함수를 생성한다.</p>\n<p>C++과 같이 함수형 언어가 아닌 언어에서도 커링이 가능하기는 하지만 일이 조금 복잡해진다. C++에서의 다인수 함수는 Haskell에서 튜플을 받는 함수에 해당한다고 볼 수 있다. (여기서 더 혼란스러운 점은 C++에서 명시적으로 <code class=\"language-text\">std::tuple</code>을 받는 함수, 가변 인수 함수, 초기화 리스트를 받는 함수를 정의할 수 있다는 점이다.)</p>\n<p>C++ 함수를 부분 적용하려면 템플릿 <code class=\"language-text\">std::bind</code>를 사용하면 된다. 예를 들어 아래와 같이 두 개의 문자열을 받는 함수가 있다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>string <span class=\"token function\">catstr</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>string s1<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>string s2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> s1 <span class=\"token operator\">+</span> s2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그럼 이 함수와 <code class=\"language-text\">std::bind</code>를 사용하여 하나의 문자열을 받는 함수를 정의해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token double-colon punctuation\">::</span>placeholders<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">auto</span> greet <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>catstr<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Hello \"</span><span class=\"token punctuation\">,</span> _1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Haskell Curry\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Scala는 C++이나 Java에 비하면 함수형 프로그래밍에 더 가깝긴 하지만, 사실은 애매한 어딘가에 위치하고 있다. 만약 함수가 부분 적용되도록 작성하려면 아래처럼 여러 인수의 목록으로 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> catstr<span class=\"token punctuation\">(</span>s1<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>s2<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> s2</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>물론 이 코드는 이 함수가 확실히 부분 적용될 것이라는 것을 가정하기 때문에 프로그래머의 예지력에 의존하고 있지만 말이다.</p>\n<h2 id=\"93-지수exponentials\" style=\"position:relative;\">9.3 지수(Exponentials)<a href=\"#93-%EC%A7%80%EC%88%98exponentials\" aria-label=\"93 지수exponentials permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>수학 논문에서 함수 대상 또는 두 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 사이의 내부 Hom 대상은 종종 지수(Exponential)로 불리며 <code class=\"language-text\">ba</code>라고 표기된다. 처음에는 이 표기법이 조금 어색해보일 수 있지만, 함수와 곱의 관계를 생각해보면 그렇게 이상한 것도 아니다. 이미 내부 Hom 대상의 보편적 구성에서 곱이 필요하다는 것을 한 차례 확인했지만, 사실 이 둘 간의 연결은 더 심오하다.</p>\n<p>이 연결은 <code class=\"language-text\">Bool</code>, <code class=\"language-text\">Char</code>, <code class=\"language-text\">Int</code>, <code class=\"language-text\">Double</code>과 같이 유한한 값을 가지는 집합 간의 함수를 고려해볼 때 제대로 확인해볼 수 있다. 이러한 함수들은 원론적으로 완전히 메모아이징(Memoizing)될 수 있거나 데이터 구조로 변환되어 조회될 수도 있다. 이것이 바로 사상으로써의 함수와 대상으로써의 함수 타입 간 동등성의 본질이다.</p>\n<p>예를 들어 <code class=\"language-text\">Bool</code>에서의 순수 함수는 <code class=\"language-text\">False</code>에 해당하는 값과 <code class=\"language-text\">True</code>에 해당하는 값의 쌍에 의해 완전히 특정화된다. <code class=\"language-text\">Bool</code>에서 <code class=\"language-text\">Int</code>로 향하는 모든 함수의 집합은 모든 <code class=\"language-text\">Int</code> 쌍들의 집합이다. 이것은 곱 <code class=\"language-text\">Int × Int</code>, 조금 더 창의적으로 표기해보자면 <code class=\"language-text\">Int2</code>와 동일하다.</p>\n<p>다른 예시로 C++의 타입인 <code class=\"language-text\">char</code>를 한번 살펴보자. 이 타입은 총 256개의 값을 포함하고 있다.</p>\n<p>C++ 표준 라이브러리의 <code class=\"language-text\">isupper</code>, <code class=\"language-text\">isspace</code>와 같은 일부 함수들은 테이블 조회를 사용하여 구현되며, 이 테이블은 256개의 부울 값들의 튜플과 동등하다. 튜플은 곱 타입이므로 우리는 <code class=\"language-text\">bool × bool × bool × ... × bool</code>과 같은 256개의 부울의 곱을 떠올려볼 수 있다.</p>\n<p>그리고 우리는 이렇게 반복적인 곱이 곧 지수(Exponential)을 정의한다는 사실을 알고 있다. 만약 <code class=\"language-text\">bool</code>을 <code class=\"language-text\">char</code> 타입이 가진 값의 개수인 256번만큼 곱한다면, <code class=\"language-text\">bool</code>을 <code class=\"language-text\">char</code>만큼 거듭제곱한 것, 즉, <code class=\"language-text\">boolchar</code>를 얻을 수 있다.</p>\n<p>그렇다면 <code class=\"language-text\">bool</code>의 256 튜플로 정의된 타입에는 얼마나 많은 값이 존재하는 것일까? 정확하게 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>256</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{256}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">256</span></span></span></span></span></span></span></span></span></span></span></span></span>개이다. 이는 <code class=\"language-text\">char</code>에서 <code class=\"language-text\">bool</code>로 향하는 서로 다른 함수들의 개수와도 동일하며, 각 함수는 고유한 256 튜플에 해당된다.</p>\n<p>비슷한 방식으로 <code class=\"language-text\">bool</code>에서 <code class=\"language-text\">char</code>로 향하는 함수의 개수도 계산해보면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>256</mn><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">256^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">25</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>개라는 사실을 알 수 있다. 함수 타입에 대한 지수 표기법은 이런 의미를 가지고 있는 것이다.</p>\n<p>아마 우리는 <code class=\"language-text\">int</code>나 <code class=\"language-text\">double</code>에서 출발하는 함수를 모두 메모아이즈하고 싶어하지는 않을 것이다. 하지만 비록 실용적이지 않더라도 함수와 데이터 타입 사이의 동등성은 명확히 존재한다.</p>\n<p>그리고 리스트, 트리, 문자열과 같은 무한한 타입도 있다. 이러한 타입에서 출발하는 함수를 메모아이즈하기 위해서는 무한한 저장 공간을 필요로 한다.</p>\n<p>그러나 Haskell은 게으른 언어이므로, 게으르게 평가되는 무한한 데이터 구조와 함수 사이의 경계는 모호하게 다가온다. 이러한 함수와 데이터 간의 쌍대성은 함수 타입을 카테고리론적 지수 대상과 동일시 할 수 있다는 것을 설명한다. 이러한 특성은 우리가 가진 데이터에 대한 개념과도 일치하기 때문에 Haskell에서는 함수를 데이터처럼 취급할 수 있다.</p>\n<h2 id=\"94-데카르트-닫힌-카테고리cartesian-closed-categories\" style=\"position:relative;\">9.4 데카르트 닫힌 카테고리(Cartesian Closed Categories)<a href=\"#94-%EB%8D%B0%EC%B9%B4%EB%A5%B4%ED%8A%B8-%EB%8B%AB%ED%9E%8C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACcartesian-closed-categories\" aria-label=\"94 데카르트 닫힌 카테고리cartesian closed categories permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>물론 필자는 계속 집합의 카테고리를 타입과 함수의 모델로 사용할 것이지만, 이런 목적으로 사용할 수 있는 더 큰 카테고리 패밀리가 있다는 것을 언급하는 것은 충분히 가치가 있을 것 같다. 이런 카테고리는 데카르트 닫힌 카테고리(Cartesian closed categories)라고 하며, <strong>Set</strong>은 그저 이 카테고리 중 하나의 예일 뿐이다.</p>\n<p>데카르트 닫힌 카테고리는 아래 세 가지를 반드시 포함하고 있어야 한다.</p>\n<ol>\n<li>종결 대상</li>\n<li>어떤 두 대상의 곱</li>\n<li>어떤 두 대상의 지수</li>\n</ol>\n<p>지수를 무한히 많은 횟수로 반복되는 곱이라고 간주한다면, 데카르트 닫힌 카테고리는 임의의 항수를 지원하는 것이라고 생각할 수 있다. 특히 종결 대상은 곱의 항등원(0)인 대상의 곱 또는 대상의 항등원(0) 승이라고 볼 수 있다.</p>\n<p>컴퓨터 과학의 관점에서 데카르트 닫힌 카테고리들이 흥미로운 이유는 이 카테고리들이 간단하게 타이핑된 람다 미적분법의 모델을 제공하고 있기 때문이다. 이 모델은 타입을 사용하는 모든 프로그래밍 언어의 기초를 형성한다.</p>\n<p>종결 대상과 곱 연산에는 각각 초기 대상과 합 연산이라는 쌍대(Dual)가 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">a × (b + c) = a × b + a × c\n(b + c) × a = b × a + c × a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 두 요소를 지원하고 곱이 합을 통해 분배될 수 있는 데카르트 닫힌 카테고리를 이중 데카르트 닫힌 카테고리(Bicartesian closed category)라고 한다. 다음 섹션에서 보겠지만 우리가 계속 다뤄온 <strong>Set</strong>이 대표적인 이중 데카르트 닫힌 카테고리이며, 이 카테고리는 몇 가지 흥미로운 특성을 가지고 있다.</p>\n<h2 id=\"95-지수와-대수적-자료형exponentials-and-algebraic-data-types\" style=\"position:relative;\">9.5 지수와 대수적 자료형(Exponentials and Algebraic Data Types)<a href=\"#95-%EC%A7%80%EC%88%98%EC%99%80-%EB%8C%80%EC%88%98%EC%A0%81-%EC%9E%90%EB%A3%8C%ED%98%95exponentials-and-algebraic-data-types\" aria-label=\"95 지수와 대수적 자료형exponentials and algebraic data types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수 타입을 지수로 해석하는 것은 대수적 자료형의 체계에 아주 잘 들어맞는다. 실제로 고등학교에서 배우는 대수학에서 나오는 숫자 0과 1, 합, 곱, 그리고 지수와 관련된 기본적인 항등식은 각각 초기 대상, 종결 대상, 합집합, 곱집합 그리고 지수에 대해 거의 그대로 적용된다는 것을 볼 수 있다.</p>\n<p>우리는 아직 이 성질을 제대로 증명할만한 수반(Adjunction)이나 요네다 보조정리같은 도구를 가지고 있지는 않지만, 그럼에도 불구하고 독자 여러분께 직관을 제공하기 위해 일단 쭉 설명해보겠다.</p>\n<h3 id=\"951-0승\" style=\"position:relative;\">9.5.1 0승<a href=\"#951-0%EC%8A%B9\" aria-label=\"951 0승 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>a</mi><mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">a^0 = 1 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8641em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></div>\n<p>카테고리적 해석에서 우리는 0을 초기 대상으로, 1을 종결 대상으로, 그리고 등식을 동형사상으로 대체한다. 여기서 지수는 내부 Hom 대상을 의미하기 때문에 결국 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">a^0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span>이라는 식은 초기 대상에서 임의의 대상 <code class=\"language-text\">a</code>로 향하는 사상의 집합을 나타낸다. 초기 대상의 정의에 따라 이런 사상은 정확히 하나만 존재할 수 있으므로 Hom 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C(0,a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span></span>는 단일 원소 집합이다.</p>\n<p>단일 원소 집합은 <strong>Set</strong>에서의 종결 대상이므로, 이 항등식은 <strong>Set</strong>에서 쉽게 성립할 수 있다. 여기서 중요한 것은 이 항등식이 이중 데카르트 닫힌 카테고리의 모든 경우에 대해서 성립한다는 것이다.</p>\n<p>Haskell에서는 0을 <code class=\"language-text\">Void</code>로, 1을 유닛 타입인 <code class=\"language-text\">()</code>으로 대체한다. 결국 필자가 앞에서 했던 주장은 <code class=\"language-text\">Void</code>에서 임의의 타입 <code class=\"language-text\">a</code>로 향하는 함수의 집합이 유닛 타입과 동등하다는 것이다. 다시 말하자면 <code class=\"language-text\">Void -> a</code> 함수는 하나뿐이라는 것이다. 그리고 우리는 이미 이 함수를 예전에 본 적이 있다. 바로 <code class=\"language-text\">absurd</code> 함수이다.</p>\n<p>그러나 이것을 현실에 구현하기는 약간 까다롭다. 이유는 크게 두 가지인데, 첫째로 Haskell에서는 실제로 어떤 값도 속하지 않는 타입이라는게 존재하지 않는다. 모든 타입은 “끝나지 않는 계산의 결과” 또는 Bottom(<code class=\"language-text\">_|_</code>)을 포함하기 때문이다.</p>\n<p>두번째 이유는 <code class=\"language-text\">absurd</code>에는 어떤 값도 전달할 수 없기 때문에 누가 무슨 짓을 하던 결국 아무도 실행시킬 수 없다는 점이다. 결국 이 함수의 구현은 근본적으로 모두 동등하다는 것이다. 그렇다고 해서 만약 영원히 끝나지 않는 계산을 전달한다면 이 함수는 결코 반환이라는 행위까지 도달하지 못할 것이다.</p>\n<h3 id=\"952-1의-지수\" style=\"position:relative;\">9.5.2 1의 지수<a href=\"#952-1%EC%9D%98-%EC%A7%80%EC%88%98\" aria-label=\"952 1의 지수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mn>1</mn><mi>a</mi></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1^a = 1\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span></div>\n<p>위 식은 <strong>Set</strong>에서 해석될 때 모든 대상에서 종결 대상으로 향하는 고유한 사상이 존재한다는 종결 대상에 대한 정의를 다시 한번 표현하고 있다. 일반적으로 <code class=\"language-text\">a</code>에서 종결 대상으로 향하는 내부 Hom 대상은 종결 대상과 동형이다.</p>\n<p>Haskell에서 임의의 타입 <code class=\"language-text\">a</code>에서 유닛으로 향하는 함수는 <code class=\"language-text\">a -> ()</code> 단 하나 뿐이다. 우리는 이 함수를 <code class=\"language-text\">unit</code>이라고 부른다는 것을 이미 알고 있다. 이 함수는 <code class=\"language-text\">()</code>에 부분 적용된 <code class=\"language-text\">const</code> 함수로 생각할 수도 있다.</p>\n<h3 id=\"953-1승\" style=\"position:relative;\">9.5.3 1승<a href=\"#953-1%EC%8A%B9\" aria-label=\"953 1승 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>a</mi><mn>1</mn></msup><mo>=</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a^1 = a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8641em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span></div>\n<p>위 식은 종결 대상으로부터 출발하는 사상은 대상 <code class=\"language-text\">a</code>의 원소를 선택하는데 사용될 수 있다는 것을 다시 표현한 것이다. 이러한 사상들의 집합은 대상 자체와 동형이다. <strong>Set</strong>, 그리고 Haskell에서는 집합 <code class=\"language-text\">a</code>의 원소들과 해당 원소들을 선택하는 함수들인 <code class=\"language-text\">() -> a</code>가 동형이라는 것이다.</p>\n<h3 id=\"954-지수의-합\" style=\"position:relative;\">9.5.4 지수의 합<a href=\"#954-%EC%A7%80%EC%88%98%EC%9D%98-%ED%95%A9\" aria-label=\"954 지수의 합 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>a</mi><mrow><mi>b</mi><mo>+</mo><mi>c</mi></mrow></msup><mo>=</mo><msup><mi>a</mi><mi>b</mi></msup><mo>×</mo><msup><mi>a</mi><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">a^{b+c} = a^b ×a^c\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8991em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9824em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>카테고리론적으로 위 식은 대상의 두 지수의 합이 각 지수를 가진 대상들의 곱과 동형이라는 것을 의미한다.</p>\n<p>이 대수적 동형성을 Haskell에서 다루게 되면 매우 실용적인 해석을 가져다준다. 이는 두 타입의 합으로부터 출발하는 함수가 각각의 타입으로부터 출발하는 함수의 쌍과 동등하다는 것을 의미하기 때문이다.</p>\n<p>이 개념이 바로 우리가 합에 대한 함수를 정의할 때 사용하는 문법의 근원이다. 우리는 합을 의미하는 <code class=\"language-text\">Either</code>를 정의할 때 <code class=\"language-text\">case</code> 문을 사용하여 함수를 정의하지 않고, 각각의 타입 생성자를 따로 처리하는 두 개, 혹은 그 이상의 함수로 나눈다.</p>\n<p>예를 들어 합 타입(<code class=\"language-text\">Either Int Double</code>)를 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Either</span> <span class=\"token constant\">Int</span> <span class=\"token constant\">Double</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 경우 <code class=\"language-text\">Either</code>는 각각 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Double</code>에 대한 함수의 쌍으로 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Left</span> <span class=\"token hvariable\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token keyword\">then</span> <span class=\"token string\">\"Negative int\"</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"Positive int\"</span>\n<span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Right</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.0</span> <span class=\"token keyword\">then</span> <span class=\"token string\">\"Negative double\"</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"Positive double\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"955-지수의-지수\" style=\"position:relative;\">9.5.5 지수의 지수<a href=\"#955-%EC%A7%80%EC%88%98%EC%9D%98-%EC%A7%80%EC%88%98\" aria-label=\"955 지수의 지수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>a</mi><mi>b</mi></msup><msup><mo stretchy=\"false\">)</mo><mi>c</mi></msup><mo>=</mo><msup><mi>a</mi><mrow><mi>b</mi><mo>×</mo><mi>c</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">(a^b)^c = a^{b×c}\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1491em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8991em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span><span class=\"mbin mtight\">×</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>위 식은 지수 대상들에 대한 커링(Currying)을 표현하고 있다. 함수가 함수를 반환하는 것은 곱에서 출발하는 함수, 즉 이변수 함수와 동등하다.</p>\n<h3 id=\"956-곱의-지수\" style=\"position:relative;\">9.5.6 곱의 지수<a href=\"#956-%EA%B3%B1%EC%9D%98-%EC%A7%80%EC%88%98\" aria-label=\"956 곱의 지수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><msup><mo stretchy=\"false\">)</mo><mi>c</mi></msup><mo>=</mo><msup><mi>a</mi><mi>c</mi></msup><mo>×</mo><msup><mi>b</mi><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">(a×b)^c =a^c × b^c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7977em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>Haskell에서 쌍을 반환하는 함수는 각 쌍의 요소 하나를 생성하는 두 함수의 쌍과 동등하다.</p>\n<p>이처럼 고등학교에서 배우는 대수학의 간단한 항등식들이 카테고리 이론으로 확장되어 함수형 프로그래밍에서 실용적으로 적용될 수 있다는 것은 굉장히 놀라운 일이다.</p>\n<h2 id=\"96-커리-하워드-동형사상curry-howard-isomorphism\" style=\"position:relative;\">9.6 커리-하워드 동형사상(Curry-Howard Isomorphism)<a href=\"#96-%EC%BB%A4%EB%A6%AC-%ED%95%98%EC%9B%8C%EB%93%9C-%EB%8F%99%ED%98%95%EC%82%AC%EC%83%81curry-howard-isomorphism\" aria-label=\"96 커리 하워드 동형사상curry howard isomorphism permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 이미 논리와 대수적 자료형 간의 대응 관계에 대해 언급한 적이 있다. <code class=\"language-text\">Void</code> 타입과 유닛 타입(<code class=\"language-text\">()</code>)은 각각 거짓과 참에 해당하며, 곱 타입과 합 타입은 논리곱(AND)과 논리합(OR)에 해당한다. 이 체계에서 함수 타입은 논리적 함의(<code class=\"language-text\">⇒</code>)에 해당한다. 다시 말해 타입 <code class=\"language-text\">a -> b</code>는 “만약 <code class=\"language-text\">a</code>라면 <code class=\"language-text\">b</code>이다”라고 읽을 수 있다.</p>\n<p>커리-하워드 동형사상에 따르면 모든 타입은 참 또는 거짓일 수 있는 명제, 즉 진술이나 판단으로 해석될 수 있다. 해당 타입이 존재하면 그 명제는 참으로 간주되고, 존재하지 않으면 거짓으로 간주된다. 특히 논리적 함의가 참이라는 것은 그에 해당하는 함수 타입이 존재한다는 것을 의미하며, 그 타입의 함수가 실제로 존재한다는 것을 의미한다.</p>\n<p>따라서 함수의 구현 자체가 정리의 증명이 되는 것이며, 우리가 프로그램을 작성하는 것은 정리를 증명하는 것과 동등하다. 한번 몇 가지 예시를 살펴보자.</p>\n<p>함수 대상의 정의에서 소개했던 <code class=\"language-text\">eval</code> 함수를 살펴보도록 하겠다. <code class=\"language-text\">eval</code>의 시그니처는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">eval</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 함수는 함수와 그 인자로 구성된 쌍을 받아 적절한 타입의 결과를 반환한다. 즉 위 코드는 사상에 대한 Haskell에서의 구현이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">eval</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> ⇒ <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> × <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 표현은 함수 타입 <code class=\"language-text\">a ⇒ b</code> (또는 지수 대상 <code class=\"language-text\">ba</code>)를 정의한다. 이 서명을 커리-하워드 동형사상을 사용하여 논리적 술어로 번역해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">((a ⇒ b) ∧ a) ⇒ b</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 명제는 만약 <code class=\"language-text\">b</code>가 <code class=\"language-text\">a</code>로부터 도출되는 것이 참이고, <code class=\"language-text\">a</code> 또한 참이라면, <code class=\"language-text\">b</code> 또한 반드시 참이어야 한다고 읽을 수 있다. 이는 직관적으로 완벽한 의미를 가지고 있으며 고대부터 전건 긍정(*modus ponens)*라고 불려왔다. 이제 다음 함수를 구현함으로써 이 정리를 증명할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">eval</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n<span class=\"token hvariable\">eval</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">a</code>를 받아서 <code class=\"language-text\">b</code>를 반환하는 함수 <code class=\"language-text\">f</code>와 타입 <code class=\"language-text\">a</code>의 구체적인 값 <code class=\"language-text\">x</code>로 구성된 쌍을 제공한다면, 함수 <code class=\"language-text\">f</code>를 <code class=\"language-text\">x</code>에 적용함으로써 타입 b의 구체적인 값을 생성할 수 있다.</p>\n<p>즉, 필자는 이 함수를 구현함으로써 타입 <code class=\"language-text\">((a -> b), a) -> b</code>가 실제로 존재한다는 것을 보였다. 따라서 우리의 논리에서 전건 긍정(modus ponens)는 참이다.</p>\n<p>그렇다면 명백하게 거짓인 술어는 어떨까? 예를 들어 “만약 <code class=\"language-text\">a</code> 또는 <code class=\"language-text\">b</code>가 참이면, <code class=\"language-text\">a</code>는 반드시 참이어야 한다”와 같은 명제가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">a ∨ b ⇒ a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이는 명백하게 잘못된 명제이다. 왜냐하면 이 명제대로라면 <code class=\"language-text\">a</code>가 거짓이고  <code class=\"language-text\">b</code>가 참인 상황도 존재할 수 있기 때문이다. 이 술어를 커리-하워드 동형사상을 사용하여 함수 시그니처로 매핑하면 다음과 같은 결과를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사실 아무리 시도를 하더라도 이 함수는 절대 구현할 수 없다. <code class=\"language-text\">Right</code> 값으로 호출되었을 때는 <code class=\"language-text\">a</code> 타입의 값을 생성할 수 없기 때문이다. (우리가 순수 함수에 대해서만 이야기하고 있다는 점을 기억하자)</p>\n<p>이제 드디어 <code class=\"language-text\">absurd</code> 함수의 진짜 의미에 대해 이야기할 때가 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">absurd</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Void</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>만약 <code class=\"language-text\">Void</code>가 “거짓”이라고 번역된다고 생각해보면 우리는 아래와 같은 술어를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">false ⇒ a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>거짓에서는 어떤 것이든 따라올 수 있다(<em>ex falso quodlibet</em>). 여기 Haskell에서 이 명제(함수)를 증명(구현)할 수 있는 한 가지 예시가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">absurd</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Void</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">absurd</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서 <code class=\"language-text\">Void</code>는 다음과 같이 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">Void</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Void</span> <span class=\"token constant\">Void</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Void</code> 타입은 까다로운 녀석이다. 이 정의는 <code class=\"language-text\">Void</code> 타입의 값을 생성하기 위해서는 <code class=\"language-text\">Void</code> 타입의 값이 필요하다는 의미를 가지고 있기 때문에 절대 값을 구성할 수 없게 만든다. 결국 <code class=\"language-text\">Void</code> 타입의 값이라는 것은 존재할 수가 없으므로 <code class=\"language-text\">absurd</code> 함수는 절대 호출될 수가 없는 것이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>“거짓에서는 어떤 것이든 따라올 수 있다”라는 뜻의 <em>ex falso quodlibet</em>는 거짓 명제로부터는 어떤 명제라도 유도될 수 있다는 것을 의미하며, 이는 논리학에서 매우 중요한 원칙 중 하나이다.</p>\n<p>쉽게 말하자면 거짓인 전제가 주어진다면, 그 전제로부터 나오는 어떠한 결론도 모두 정당화될 수 있다는 것이다.이와 마찬가지로 <code class=\"language-text\">absurd</code> 함수는 절대 생성될 수 없는 값의 타입인 <code class=\"language-text\">Void</code>를 인자로 받아 임의의 타입 <code class=\"language-text\">a</code>를 반환할 수 있다고 선언된다.</p>\n<p>즉, 거짓으로부터 출발했으니 어떤 타입을 반환하더라도 논리가 깨지지는 않는 것이다.참고로 <code class=\"language-text\">absurd</code> 함수는 절대 호출될 수가 없기 때문에 실제로 사용될 수는 없고, 순수하게 프로그래밍 언어의 타입 시스템의 원리를 설명하기 위한 이론적인 목적으로만 사용된다.</p>\n</blockquote>\n<p>물론 이 예시들이 모두 흥미롭기는 하지만, 도대체 커리-하워드 동형사상이 우리에게 어떤 실용적인 혜택을 가져다준다는 것일까? 아마도 일상적인 프로그래밍에서는 아니겠지만, Agda나 Coq와 같은 프로그래밍 언어들은 정리를 증명하기 위해 커리-하워드 동형사상을 활용한다.</p>\n<p>컴퓨터는 수학자들이 그들의 일을 하는데 도움을 주는 것뿐만 아니라, 수학의 근본을 혁신하고 있다. 이러한 분야에서 가장 최근에 뜨거운 감자로 떠오르는 연구는 호모토피 타입 이론이라고 하며, 타입 이론의 발전에 큰 기여를 하고있다. 이 이론은 Boolean, Integer, 곱과 쌍대곱, 함수 타입 등으로 가득 차 있다. 그리고 이러한 이론은 Coq와 Agda에서 공식적으로 도입되고 있다.</p>\n<p>이처럼 컴퓨터는 여러 방면에서 세상을 혁신하고 있다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240418-category-theory-for-programmers-9-function-types","path":"/2024/04/18/category-theory-for-programmers-9-function-types/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 9. 함수 타입","subTitle":null,"date":"Apr 18, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"ee3fcb22-5cce-5033-9187-c2ea953b6f10","tableOfContents":"<ul>\n<li><a href=\"#81-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0bifunctors\">8.1 이항 펑터(Bifunctors)</a></li>\n<li><a href=\"#82-%EA%B3%B1%EA%B3%BC-%ED%95%A9-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0product-and-coproduct-bifunctors\">8.2 곱과 합 이항 펑터(Product and Coproduct Bifunctors)</a></li>\n<li><a href=\"#83-%ED%8E%91%ED%84%B0%EC%A0%81%EC%9D%B8-%EB%8C%80%EC%88%98%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%90%EB%A3%8C%ED%98%95functorial-algebraic-data-types\">8.3 펑터적인 대수적 데이터 자료형(Functorial Algebraic Data Types)</a></li>\n<li><a href=\"#84-c%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0functors-in-c\">8.4 C++에서의 펑터(Functors in C++)</a></li>\n<li><a href=\"#85-writer-%ED%8E%91%ED%84%B0\">8.5 Writer 펑터</a></li>\n<li><a href=\"#86-%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0%EC%99%80-%EB%B0%98%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0covariant-and-contravariant-functors\">8.6 공변적 펑터와 반공변적 펑터(Covariant and Contravariant Functors)</a></li>\n<li><a href=\"#87-%ED%94%84%EB%A1%9C%ED%8E%91%ED%84%B0profunctors\">8.7 프로펑터(Profunctors)</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"이제 펑터가 무엇인지 알았으니, 작은 펑터로부터 큰 펑터를 구축해나가는 방법에 대해서 살펴보도록 하겠다. 여기서 특히 흥미로운 부분은 카테고리 내 대상 간의 매핑에 대당하는 타입의 생성자가 확장되어 사상 간의 매핑을 포함하는 펑터가 되는 과정을 볼 수 있다는 것이다. 8.1 이항 펑터(Bifunctors) 펑터는 카테고리들의 카테고리인 Cat에서의 사상이기 때문에 사상에 대한 많은 직관들 특히 함수에 대한 직관들은 펑터에도 그대로 작용한다고 할 수 있다. 예를 들어 두 개의 인수를 가지는 함수가 있듯이, 두 개의 인수를 가지는 펑…","html":"<p>이제 펑터가 무엇인지 알았으니, 작은 펑터로부터 큰 펑터를 구축해나가는 방법에 대해서 살펴보도록 하겠다.</p>\n<p>여기서 특히 흥미로운 부분은 카테고리 내 대상 간의 매핑에 대당하는 타입의 생성자가 확장되어 사상 간의 매핑을 포함하는 펑터가 되는 과정을 볼 수 있다는 것이다.</p>\n<h2 id=\"81-이항-펑터bifunctors\" style=\"position:relative;\">8.1 이항 펑터(Bifunctors)<a href=\"#81-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0bifunctors\" aria-label=\"81 이항 펑터bifunctors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>펑터는 카테고리들의 카테고리인 <em>Cat</em>에서의 사상이기 때문에 사상에 대한 많은 직관들 특히 함수에 대한 직관들은 펑터에도 그대로 작용한다고 할 수 있다.</p>\n<p>예를 들어 두 개의 인수를 가지는 함수가 있듯이, 두 개의 인수를 가지는 펑터인 이항 펑터(Bifunctors)도 존재할 수 있다. 먼저 대상에 대해서만 생각해보자면 이항 펑터는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>, 그리고 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 각각의 대상으로 이루어진 모든 쌍을 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>의 대상으로 매핑하는 펑터이다. 즉, 이항 헝터는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C×D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 표현되는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 데카르트 곱에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>로의 매핑이라고 볼 수 있는 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 313px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 95%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQCAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9qSmO25pJriHcH//xAAbEAACAgMBAAAAAAAAAAAAAAABAhESAAMiIf/aAAgBAQABBQK/R2myGwK+8h1EKROBFnP/xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPwEj/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgIDAAAAAAAAAAAAAAAAARARMQAgIf/aAAgBAQAGPwKMtSa0PF//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhMWFBEP/aAAgBAQABPyGm2apHKjWu5l0eoCAxftQgBvsDByTij8//2gAMAwEAAgADAAAAEMPAfP/EABcRAQEBAQAAAAAAAAAAAAAAAAEQMUH/2gAIAQMBAT8QK8gpk//EABYRAQEBAAAAAAAAAAAAAAAAAAEgMf/aAAgBAgEBPxAQ2P/EABwQAQEAAwEAAwAAAAAAAAAAAAERACExQWFxgf/aAAgBAQABPxArQUr9GVYl0LA8Odyl0qJ5+YboVU+zFxsGnZXcHJOkvyu8CjSiONoXhtw0Z//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" srcset=\"/static/6f3400dcb00c047b27d284f6c7f27034/0913d/1.jpg 160w,\n/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg 313w\" sizes=\"(max-width: 313px) 100vw, 313px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>사실 여기까지는 매우 간단하게 이해할 수 있다. 그러나 펑터의 특성상 이항 펑터는 대상 뿐만 아니라 사상 또한 매핑할 수 있어야 한다. 즉, 하나는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 다른 하나는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에서 가져온 사상의 쌍을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>의 사상으로 매핑해야 한다는 것이다.</p>\n<p>한번 더 이야기하자면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>가 가진 사상의 쌍은 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C×D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 단일한 사상이다. 우리는 데카르트 곱 카테고리에서의 사상을 어떤 대상의 쌍에서 다른 대상의 쌍으로 이동하는 사상의 쌍으로 정의할 수 있다. 이러한 사상의 쌍들은 아래와 같은 방식으로 합성도 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span><span class=\"token punctuation\">)</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f'</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> ◦ <span class=\"token hvariable\">f'</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span> ◦ <span class=\"token hvariable\">g'</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>합성은 결합법칙을 만족하며, <code class=\"language-text\">(id, id)</code>와 같은 항등원 또한 존재한다. 이처럼 데카르트 곱 카테고리는 카테고리의 기본적인 법칙을 모두 만족하기 때문에 실제로 하나의 카테고리가 될 수 있는 것이다.</p>\n<p>이항 펑터에 대해서 더 쉽게 이해하려면 이 펑터가 두 인자 모두에 대한 펑터라는 점을 이해하는 것에서부터 출발해야한다. 즉, 펑터 법칙인 결합성과 항등 보존에 대한 개념을 곧바로 이항 펑터와 연결하고 확인해보려고 시도하는 것보다는, 이항 펑터가 가진 각 인자에 대해 하나씩 확인해보는 것이 더 이해하기 쉽다는 것이다.</p>\n<p>만약 한 쌍의 카테고리로부터 세 번째 카테고리로의 매핑이 있고, 그 매핑이 각 인자에 대해 펑터적(Functorial)이라는 사실을 만족한다는 사실을 증명한다면, 해당 매핑은 자동으로 이항 펑터가 된다. 여기서 펑터적이라는 의미는 이 펑터가 사상에 대해서 제대로 된 펑터처럼 작동한다는 것을 의미한다.</p>\n<p>Haskell에서 이항 펑터를 한번 정의해보자. 이 경우에는 세 개의 카테고리가 모두 Haskell 타입의 카테고리이기 때문에 사실상 같은 카테고리라고 볼 수 있다. 이항 펑터는 두 개의 타입 인자를 가지는 타입 생성자로 표현된다. 아래는 라이브러리 <code class=\"language-text\">Control.Bifunctor</code>에서 직접 가져온 <code class=\"language-text\">Bifunctor</code> 타입 클래스의 정의이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token hvariable\">f</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">d</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">g</span> <span class=\"token hvariable\">h</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">first</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">second</span> <span class=\"token hvariable\">h</span>\n  \t<span class=\"token hvariable\">first</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">b</span>\n  \t<span class=\"token hvariable\">first</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">g</span> <span class=\"token builtin\">id</span>\n  \t<span class=\"token hvariable\">second</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">d</span>\n  \t<span class=\"token hvariable\">second</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">bimap</span> <span class=\"token builtin\">id</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>타입 변수 <code class=\"language-text\">f</code>는 이항 펑터를 나타내며, 아래 정의된 모든 타입 시그니처에서 이 타입 변수가 항상 두 개의 타입 인자에 적용되는 것을 볼 수 있다.</p>\n<p>첫 번째 타입 시그니처는 <code class=\"language-text\">bimap</code>을 정의하는데, 이것은 두 함수의 매핑을 한 번에 나타낸다. 결과는 이항 펑터의 타입 생성자에 의해 생성된 타입들에서 동작하는 함수 <code class=\"language-text\">(f a b -> f c d)</code>이다. <code class=\"language-text\">bimap</code>은 <code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>를 사용하여 구현되어 있는데, 이는 이항 펑터가 각각의 인자에 대해 펑터적으로 작동한다는 사실을 정의하는 것만으로도 이항 펑터를 정의할 수 있다는 사실을 보여준다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 313px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 95%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQCAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9qSmO25pJriHcH//xAAbEAACAgMBAAAAAAAAAAAAAAABAhESAAMiIf/aAAgBAQABBQK/R2myGwK+8h1EKROBFnP/xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPwEj/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgIDAAAAAAAAAAAAAAAAARARMQAgIf/aAAgBAQAGPwKMtSa0PF//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhMWFBEP/aAAgBAQABPyGm2apHKjWu5l0eoCAxftQgBvsDByTij8//2gAMAwEAAgADAAAAEMPAfP/EABcRAQEBAQAAAAAAAAAAAAAAAAEQMUH/2gAIAQMBAT8QK8gpk//EABYRAQEBAAAAAAAAAAAAAAAAAAEgMf/aAAgBAgEBPxAQ2P/EABwQAQEAAwEAAwAAAAAAAAAAAAERACExQWFxgf/aAAgBAQABPxArQUr9GVYl0LA8Odyl0qJ5+YboVU+zFxsGnZXcHJOkvyu8CjSiONoXhtw0Z//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg\" srcset=\"/static/6f3400dcb00c047b27d284f6c7f27034/0913d/1.jpg 160w,\n/static/6f3400dcb00c047b27d284f6c7f27034/aa65c/1.jpg 313w\" sizes=\"(max-width: 313px) 100vw, 313px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>bimap</small>\n</center>\n<p><code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>는 각각 첫 번째와 두 번째 인자에 대한 <code class=\"language-text\">f</code>의 펑터적인 성질을 증명하는 두 개의 <code class=\"language-text\">fmap</code>이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 388px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/351da696e6a37d5df6740dce2c23f8d6/c3c84/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 82.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAEEBQL/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB1613PXQdkkEg/8QAHRAAAgEEAwAAAAAAAAAAAAAAAQIAAxAREhMhMf/aAAgBAQABBQJqms5ThO1YYg2g8v8A/8QAFREBAQAAAAAAAAAAAAAAAAAAASD/2gAIAQMBAT8BCP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABoQAQEAAgMAAAAAAAAAAAAAAAEAESEgIkH/2gAIAQEABj8Cb3LblDcdeP8A/8QAHBAAAgEFAQAAAAAAAAAAAAAAAAERICExQVFh/9oACAEBAAE/IfY4JqX0B3JkISQbQzOEr8MFoo//2gAMAwEAAgADAAAAEB/PAP/EABURAQEAAAAAAAAAAAAAAAAAAAEg/9oACAEDAQE/EGY//8QAFhEBAQEAAAAAAAAAAAAAAAAAAREg/9oACAECAQE/EKGP/8QAHRABAAICAgMAAAAAAAAAAAAAAQARITFBgRBRkf/aAAgBAQABPxBUQwHAVPUdSwoLj7UGbi3mzqERNwu+oYWLGXTviBAQqyGiPENeP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/351da696e6a37d5df6740dce2c23f8d6/c3c84/3.jpg\" srcset=\"/static/351da696e6a37d5df6740dce2c23f8d6/0913d/3.jpg 160w,\n/static/351da696e6a37d5df6740dce2c23f8d6/cb69c/3.jpg 320w,\n/static/351da696e6a37d5df6740dce2c23f8d6/c3c84/3.jpg 388w\" sizes=\"(max-width: 388px) 100vw, 388px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>first</small>\n</center>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 423px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f7734853d3675663d3f814199fd26135/b7bea/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 92.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGQABAQADAQAAAAAAAAAAAAAAAAQBAgMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAfXlqkq9sjPMOoP/xAAbEAACAgMBAAAAAAAAAAAAAAABAhEhAAMSE//aAAgBAQABBQL0g9uShlTrsKJWgbzhZz//xAAVEQEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAwEBPwEj/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgMBAQAAAAAAAAAAAAAAEBEAASExMv/aAAgBAQAGPwJKYLt5PR4P/8QAGhABAQEBAQEBAAAAAAAAAAAAAREAITEQcf/aAAgBAQABPyFt6Qz2DzNZ9wUTlHpn7gCDcARKYPx+f//aAAwDAQACAAMAAAAQ9898/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EBs1J//EABURAQEAAAAAAAAAAAAAAAAAAAEg/9oACAECAQE/EBCP/8QAHRABAQACAwADAAAAAAAAAAAAAREAMSFBUWGx0f/aAAgBAQABPxCxKhH2X8xw1bCgF89wyOyOAVINjq2/eJoBUQ8dmRNJv35yISbHvHCUJvnDg4z/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/f7734853d3675663d3f814199fd26135/b7bea/4.jpg\" srcset=\"/static/f7734853d3675663d3f814199fd26135/0913d/4.jpg 160w,\n/static/f7734853d3675663d3f814199fd26135/cb69c/4.jpg 320w,\n/static/f7734853d3675663d3f814199fd26135/b7bea/4.jpg 423w\" sizes=\"(max-width: 423px) 100vw, 423px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>second</small>\n</center>\n<p>타입 클래스 정의는 <code class=\"language-text\">bimap</code>을 기반으로 두 개의 함수에 대한 기본 구현을 제공한다.</p>\n<p><code class=\"language-text\">Bifunctor</code>의 인스턴스를 선언할 때는 <code class=\"language-text\">bimap</code>을 구현하고, <code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>의 기본 값을 사용하거나, 반대로 <code class=\"language-text\">first</code>와 <code class=\"language-text\">second</code>를 모두 구현하고 <code class=\"language-text\">bimap</code>의 기본 값을 사용하는 선택권을 가질 수 있다. (물론 세 가지 모두를 구현할 수는 있겠지만, 그러면 이들이 위와 같은 성질을 가질 수 있도록 보장해줘야 한다.)</p>\n<h2 id=\"82-곱과-합-이항-펑터product-and-coproduct-bifunctors\" style=\"position:relative;\">8.2 곱과 합 이항 펑터(Product and Coproduct Bifunctors)<a href=\"#82-%EA%B3%B1%EA%B3%BC-%ED%95%A9-%EC%9D%B4%ED%95%AD-%ED%8E%91%ED%84%B0product-and-coproduct-bifunctors\" aria-label=\"82 곱과 합 이항 펑터product and coproduct bifunctors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이항 펑터의 예시 중 특히 중요한 것은 카테고리적 곱(Categorical Product)이다. 이는 두 대상의 곱으로, <a href=\"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts\">보편적 구성(Universial Construction)</a>에 의해 정의된다. 만약 어떤 두 대상에 대한 곱이 존재한다면, 해당 대상들에서 곱으로의 매핑은 이항 펑터적(Bifunctorial)이다. 이것은 일반적으로 참이며, 특히 Haskell에서도 마찬가지이다.</p>\n<p>아래는 가장 간단한 곱 타입인 쌍 생성자에 대한 <code class=\"language-text\">Bifunctor</code> 인스턴스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">bimap</code>은 단순히 쌍의 첫 번째 구성 요소에 첫 번째 함수를 적용하고, 두 번째 구성 요소에는 두 번째 함수를 적용하고 있기 때문에, 딱히 고민할만한 부분이 없다. 이렇게 명확하고 간단한 동작이 요구사항으로 주어진다면 코드 작성 자체는 간단하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">bimap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 이항 펑터의 작용은 타입들의 쌍을 만드는 것이다. 예를 들면 이런 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>쌍대성에 의해 이 정의가 카테고리 내의 모든 대상 쌍에 대해서 정의된다면, 합(Coproduct) 또한 이항 펑터라고 할 수 있다. Haskell에서는 <code class=\"language-text\">Either</code> 타입 생성자를 <code class=\"language-text\">Bifunctor</code>의 인스턴스인 것으로 나타낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token constant\">Either</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">_</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Left</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Right</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>워낙 동작이 간단하고 요구사항이 명확하니 코드 작성은 어렵지 않다.</p>\n<p>혹시 모노이드 카테고리(Monoidal Category)에 대해 이야기했던 것을 기억하는가? 모노이드 카테고리는 단위 대상과 함께 대상에 작용하는 이항 연산자인 모노이드 곱(Monoidal Product)을 정의한다.</p>\n<p>예전에 이야기했듯이 <em>Set</em>(집합의 카테고리)은 데카르트 곱 연산을 이항 연산으로 사용하여 대상 간의 결합을 정의하는 모노이드 카테고리이며, 이때 단위 대상은 단일 원소 집합이다. 또한 서로소 합집합 연산에 대해서도 모노이드 카테고리라고 볼 수 있으며, 이때의 단위 대상은 공집합이 된다.</p>\n<p>당시 필자가 언급하지 않은 것이 하나가 있다. 바로 모노이드 카테고리의 요구 사항 중 하나는 이항 연산자가 이항 펑터여야 한다는 것이다.</p>\n<p>우리는 모노이드 곱의 연산 구조가 사상에 의해 정의된 카테고리의 구조와 호환되도록 만들어야 하며, 이것은 매우 중요한 요구 사항이다. 물론 완전한 이해를 하기에는 아직 자연성(Naturality)이라는 큰 산이 하나 남아 있기는 하지만, 그래도 모노이드 카테고리의 전체 정의에 한 발짝 더 가까워졌다.</p>\n<h2 id=\"83-펑터적인-대수적-데이터-자료형functorial-algebraic-data-types\" style=\"position:relative;\">8.3 펑터적인 대수적 데이터 자료형(Functorial Algebraic Data Types)<a href=\"#83-%ED%8E%91%ED%84%B0%EC%A0%81%EC%9D%B8-%EB%8C%80%EC%88%98%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%90%EB%A3%8C%ED%98%95functorial-algebraic-data-types\" aria-label=\"83 펑터적인 대수적 데이터 자료형functorial algebraic data types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 펑터가 될 수 있는 몇 가지 파라미터화된 데이터 타입을 살펴봤다. 우리는 이러한 타입들에 대한 <code class=\"language-text\">fmap</code>을 정의할 수 있었다. 복잡한 데이터 타입은 더 간단한 데이터 타입을 기반으로 하여 구성되는데, 합과 곱의 개념을 사용하여 대수적 데이터 타입(ADT)을 생성하는 것이 바로 그 예이다.</p>\n<p>앞선 섹션에서 우리는 이미 합과 곱이 펑터적이라는 사실을 확인했고, 펑터가 합성 가능하다는 사실도 알게 되었다. 결국 우리가 대수적 데이터 타입의 기본 구성 요소가 펑터라는 사실을 보일 수만 있다면, 파라미터화된 대수적 데이터 타입도 결국 펑터라는 사실로 이어질 수 있다는 것이다.</p>\n<p>파라미터화된 대수적 데이터 타입이라는 것이 무엇을 의미하는걸까? 먼저 <code class=\"language-text\">Maybe</code>의 <code class=\"language-text\">Nothing</code>이나 <code class=\"language-text\">List</code>의 <code class=\"language-text\">Nil</code>처럼 펑터의 타입 파라미터에 의존하지 않는 녀석들이 있으며, 이들은 <code class=\"language-text\">Const</code> 펑터와 동등하다. <code class=\"language-text\">Const</code> 펑터는 자신이 받는 타입 파라미터를 무시한다는 사실을 기억해보자. (정확히 말하면 첫 번째 타입 파라미터는 고정이며, 두 번째 파라미터를 무시하는 것이다.)</p>\n<p>또한 <code class=\"language-text\">Maybe</code>의 <code class=\"language-text\">Just</code>처럼 단순히 타입 파라미터 자체를 캡슐화하는 녀석들도 있다. 이들은 항등 펑터와 동등하다. 이전에 <em>Cat</em>에서의 항등 사상에 대한 이야기를 하면서 항등 펑터를 언급한 적이 있었지만, Haskell에서의 정의는 보여주지 않았었다. 이것이 바로 항등 펑터의 정의다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span>\n\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Identity</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Identity</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">Identity</code>는 항상 타입이 <code class=\"language-text\">a</code>인 하나의 불변 값만을 가지는 간단한 컨테이너라고 생각해볼 수 있다. 대수적 데이터 구조에서 이 개념을 제외한 나머지 것들은 모두 두 가지 원시적 요소를 합하거나 곱하여 생성된다.</p>\n<p>이 새로운 지식을 토대로 <code class=\"language-text\">Maybe</code> 타입 생성자를 다시 한번 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이건 결국 <code class=\"language-text\">Nothing</code>과 <code class=\"language-text\">Just</code> 두 타입의 합이며, 합은 펑터적이다. 첫 번째 부분인 <code class=\"language-text\">Nothing</code>은 <code class=\"language-text\">Const ()</code>가 <code class=\"language-text\">a</code>에 작용하는 것이라고 볼 수 있다. (여기서 <code class=\"language-text\">Const</code>의 첫 번째 타입 파라미터는 유닛으로 설정한다.) 그리고 두 번째 부분인 <code class=\"language-text\">Just</code>는 그저 항등 펑터의 다른 이름일 뿐이다. 그럼 이제 우리는 <code class=\"language-text\">Maybe</code>를 동형적으로 아래와 같이 다시 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>결국 <code class=\"language-text\">Maybe</code>는 이항 펑터 <code class=\"language-text\">Either</code>를 사용하여 <code class=\"language-text\">Const ()</code>, <code class=\"language-text\">Identify</code>라는 두 개의 펑터를 조합한 것이다. (실제로는 <code class=\"language-text\">Const</code> 또한 이항 펑터이지만, 여기서는 항상 부분적용된 상태로만 사용한다.)</p>\n<p>우리는 이미 펑터의 합성 또한 펑터라는 것을 알고 있으며, 이항 펑터 또한 이와 마찬가지로 동일한 원칙이 적용될 것이라는 점을 쉽게 예상해볼 수 있다. 한번 이항 펑터와 두 펑터의 합성이 사상에 어떤 식으로 작용하는지 알아보도록 하자. 먼저 두 개의 사상 중 하나를 한 펑터로 리프팅한 후, 다른 하나를 또 하나의 다른 펑터로 리프팅할 것이다. 그 다음 여기서 얻어진 두 사상의 쌍을 이항 펑터로 리프팅하는 순서로 진행하면 된다.</p>\n<p>이 과정을 Haskell로 한번 표현해보자. 이 데이터 타입의 매개변수는 다음과 같다. 두 개의 타입을 인자로 받는 타입 생성자를 의미하는 이항 펑터 <code class=\"language-text\">bf</code>, 각각 하나의 타입 변수를 받는 타입 생성자인 두 개의 펑터 <code class=\"language-text\">fu</code>와 <code class=\"language-text\">gu</code>와 두 개의 일반적인 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>이다. 이제 펑터 <code class=\"language-text\">fu</code>를 <code class=\"language-text\">a</code>에 적용하고, 펑터 <code class=\"language-text\">gu</code>는 <code class=\"language-text\">b</code>에 적용한 다음, 이 결과로 나온 타입 두 개에 이항 펑터 <code class=\"language-text\">bf</code>를 적용할 것이라는 것을 표현하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">bf</span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것은 객체 또는 타입에 대한 합성이다. Haskell에서는 타입 생성자를 타입에 적용하는 것이 마치 함수를 인수에 적용하는 것과 동일한 방식으로 이루어지며, 심지어 구문 또한 동일하다.</p>\n<p>조금 헷갈린다면, <code class=\"language-text\">BiComp</code>의 매개변수로 <code class=\"language-text\">Either</code>, <code class=\"language-text\">Const ()</code>, <code class=\"language-text\">Identity</code>, <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code>가 들어온다고 생각해보자. 결과적으로 <code class=\"language-text\">Maybe b</code>를 얻을 수 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>왜 <code class=\"language-text\">BiComp Either Const () Identity a b</code>가 <code class=\"language-text\">Maybe b</code>인지는 의사코드로 작성해보면 단번에 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">bf</span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token constant\">BiComp</span> <span class=\"token constant\">Either</span> <span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">Identity</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span>\n<span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Identity</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span>\n</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</blockquote>\n<p>새로운 타입인 <code class=\"language-text\">Bicomp</code>는 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>에 대한 이항 펑터라고 할 수 있지만, 이 정의는 매개변수인 <code class=\"language-text\">bf</code>가 이항 펑터이고 <code class=\"language-text\">fu</code>와 <code class=\"language-text\">gu</code>가 펑터일 경우에만 성립할 수 있다. 즉, 컴파일러가 이 매개변수들을 추론했을때, <code class=\"language-text\">bf</code>에 대한 <code class=\"language-text\">bimap</code> 정의와 <code class=\"language-text\">fu</code> 및 <code class=\"language-text\">gu</code>에 대한 <code class=\"language-text\">fmap</code> 정의가 있다는 사실이 보장되어야 한다는 것이다.</p>\n<p>Haskell에서는 인스턴스 선언 시 클래스 제약 조건 집합 다음에 위치하는 이중 화살표(<code class=\"language-text\">=></code>)로 이러한 전제조건을 표현해줄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Bifunctor</span> <span class=\"token hvariable\">bf</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Functor</span> <span class=\"token hvariable\">fu</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Functor</span> <span class=\"token hvariable\">gu</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token constant\">Bifunctor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">bf</span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">gu</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n        <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f1</span> <span class=\"token hvariable\">f2</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">BiComp</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">BiComp</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">bimap</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">BiComp</code>의 <code class=\"language-text\">bimap</code> 구현은 <code class=\"language-text\">bf</code>의 <code class=\"language-text\">bimap</code>과 <code class=\"language-text\">fu</code>, <code class=\"language-text\">gu</code>의 <code class=\"language-text\">fmap</code>을 사용하여 정의한다. 컴파일러는 <code class=\"language-text\">BiComp</code>가 사용될 때 이 타입들을 자동으로 추론하고 오버로드된 함수를 선택할 것이다.</p>\n<p>위의 <code class=\"language-text\">bimap</code> 정의에서 <code class=\"language-text\">x</code>의 타입은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것은 꽤나 복잡한 정의처럼 보인다. 외부 <code class=\"language-text\">bimap</code>은 외부 <code class=\"language-text\">bf</code> 레이어를 통과하며, 두 개의 <code class=\"language-text\">fmap</code>들은 각각 <code class=\"language-text\">fu</code>와 <code class=\"language-text\">gu</code> 아래로 파고들게 된다.</p>\n<p>만약 <code class=\"language-text\">f1</code>와 <code class=\"language-text\">f2</code>의 타입이 아래와 같은 상황이라고 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f1</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a'</span>\n<span class=\"token hvariable\">f2</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러면 최종 결과는 <code class=\"language-text\">bf (fu a') (gu b')</code> 타입이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">bimap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b'</span><span class=\"token punctuation\">)</span>\n  \t<span class=\"token operator\">-></span> <span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">bf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">fu</span> <span class=\"token hvariable\">a'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gu</span> <span class=\"token hvariable\">b'</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>만약 여러분이 직소 퍼즐을 좋아한다면, 이런 종류의 타입 조작에서 꽤나 큰 즐거움을 느낄 수 있을 것이다.</p>\n<p>결론적으로 <code class=\"language-text\">Maybe</code>는 두 펑터적인 요소의 합으로 구성되었기 때문에, 굳이 <code class=\"language-text\">Maybe</code>가 펑터라는 것을 증명하지 않아도 당연히 펑터라는 사실이 성립하는 것이다.</p>\n<p>만약 예리한 독자들은 대수적 데이터 타입에 대한 펑터 인스턴스의 유도가 이렇게 논리적으로 명확하게 정의될 수 있다면, 그냥 컴파일러에서 자동화해서 처리할 수는 없냐고 질문할 수도 있다.</p>\n<p>물론 가능하다. 이는 Haskell의 확장기능(Extensions)를 사용하면 되는데, 특정 확장기능을 사용하려면 소스 파일의 맨 위에 아래와 같은 라인을 추가하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token comment\">{-# LANGUAGE DeriveFunctor #-}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그 이후 데이터 구조에 <code class=\"language-text\">deriving Functor</code>를 추가하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span> <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Functor</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이처럼 <code class=\"language-text\">DeriveFunctor</code> 확장 기능을 사용하면 특정 데이터 구조에 대한 <code class=\"language-text\">fmap</code>이 자동으로 구현되도록 할 수 있다.</p>\n<p>이런 기능이 제공될 수 있는 이유는 대수적 데이터 구조의 규칙성으로 인해 <code class=\"language-text\">Functor</code>뿐 아니라 앞서 언급했던 <code class=\"language-text\">Eq</code>와 같은 여러 다른 타입 클래스 인스턴스를 논리적으로 유도하는 것이 가능하기 때문이다.</p>\n<p>이와 더불어 컴퍼일러에게 사용자 정의 타입 클래스의 인스턴스를 유도하는 것도 가능하지만 이것은 조금 더 고급 기능이다. 하지만 결국 사용자 정의 타입 클래스라고 해도 기본적인 구성 요소, 그리고 합과 곱의 동작을 제공하는 것 뿐이므로 근본적인 원리는 동일하다.</p>\n<h2 id=\"84-c에서의-펑터functors-in-c\" style=\"position:relative;\">8.4 C++에서의 펑터(Functors in C++)<a href=\"#84-c%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0functors-in-c\" aria-label=\"84 c에서의 펑터functors in c permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>만약 여러분이 C++ 프로그래머라면 펑터를 처음부터 끝까지 오롯이 혼자서 구현해야할 것이다. 그러나 이를 위해서는 C++이 가진 대수적 데이터 구조의 몇 가지 타입을 이해할 수 있어야하며, 이런 데이터 구조를 일반적인 템플릿으로 구현하고 이 구조에 대한 <code class=\"language-text\">fmap</code> 또한 직접 구현할 수 있어야한다.</p>\n<p>먼저 Haskell에서 재귀적인 합 타입으로 정의된 트리 데이터 구조를 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Tree</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Leaf</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Node</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Tree</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Tree</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Functor</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>앞서 언급한 대로, C++에서 합 타입을 구현하는 방법 중 하나는 바로 클래스 계층 구조를 이용하는 것이다. 객체지향 언어에서는 기본 클래스 <code class=\"language-text\">Functor</code>의 가상 함수(Virtual functions)로 <code class=\"language-text\">fmap</code>을 구현한 뒤 모든 하위 클래스에서 이를 재정의하는 방향이 자연스러울 것이다.</p>\n<p>하지만 아쉽게도 이런 방법을 사용하는 것은 불가능하다. 왜냐하면 결국 <code class=\"language-text\">fmap</code>은 템플릿이며, 이는 <code class=\"language-text\">this</code> 포인터로 전달되는 객체의 타입 뿐 아니라 적용된 함수의 반환 타입이 매개변수화되어야 한다는 것을 의미한다. 하지만 C++에서는 가상 함수를 템플릿화 할 수 없다. 대신 우리는 <code class=\"language-text\">dynamic_cast</code>를 사용하여 패턴 매칭을 대체하고 <code class=\"language-text\">fmap</code>을 일반적인 자유 함수로 구현할 것이다.</p>\n<p>기본 클래스는 동적 캐스팅을 지원하기 위해 최소 하나의 가상 함수를 정의해야하며, 이 경우 우리는 소멸자(Destructor)를 가상 함수로 정의할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Tree</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">virtual</span> <span class=\"token operator\">~</span><span class=\"token function\">Tree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>숨겨진 <code class=\"language-text\">Identity</code> 펑터인 <code class=\"language-text\">Leaf</code>를 정의하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Leaf</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Tree</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n    T _label<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Leaf</span><span class=\"token punctuation\">(</span>T l<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_label</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">Node</code>는 곱 타입으로 정의할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Tree</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n    Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> _left<span class=\"token punctuation\">;</span>\n    Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> _right<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> l<span class=\"token punctuation\">,</span> Tree<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token operator\">*</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_left</span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">_right</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">fmap</code>을 구현할 때는 <code class=\"language-text\">Tree</code>의 타입에 따른 동적 디스패치를 활용할 것이다. <code class=\"language-text\">Leaf</code>의 경우에는 <code class=\"language-text\">Identify</code> 버전의 <code class=\"language-text\">fmap</code>을 적용하고, <code class=\"language-text\">Node</code>의 경우에는 두 개의 <code class=\"language-text\">Tree</code> 펑터의 복사본과 결합된 이항 펑터처럼 처리할 것이다. 물론 C++ 프로그래머들은 이런 사고 방식과 용어로 코드를 분석하는 것에 익숙하지 않을 수 있지만, 이 모든 과정이 결국 카테고리론적 사고를 연습하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nTree<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token operator\">*</span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> Tree<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Leaf<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> pl <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">dynamic_cast</span> <span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Leaf<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token operator\">*</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pl<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token generic-function\"><span class=\"token function\">Leaf</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span> <span class=\"token punctuation\">(</span>pl<span class=\"token operator\">-></span>_label<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> pn <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">dynamic_cast</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Node<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token operator\">*</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pn<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token generic-function\"><span class=\"token function\">Node</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> pn<span class=\"token operator\">-></span>_left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> pn<span class=\"token operator\">-></span>_right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서는 간결함을 위해 메모리나 리소스 관리 문제를 무시하고 있지만, 실제 코드에서는 정책에 따라 <code class=\"language-text\">unique</code>나 <code class=\"language-text\">shared</code> 같은 스마트 포인트를 사용할 것이다.</p>\n<p>이렇게 C++로 작성한 <code class=\"language-text\">Tree</code>의 <code class=\"language-text\">fmap</code>을 Haskell에서 작성한 버전으로 바꿔보자면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Tree</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Leaf</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Leaf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Node</span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">t'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Node</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t'</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그리고 이 역시 <code class=\"language-text\">DeriveFunctor</code> 확장 기능을 사용하면 컴파일러에 의해 자동으로 구현될 수 있다.</p>\n<h2 id=\"85-writer-펑터\" style=\"position:relative;\">8.5 Writer 펑터<a href=\"#85-writer-%ED%8E%91%ED%84%B0\" aria-label=\"85 writer 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이전에 설명했던 <a href=\"/2024/02/20/category-theory-for-programmers-4-kleisli-category\">크라이슬리 카테고리(Kleisli Category)</a> 섹션에서 <code class=\"language-text\">Writer</code> 펑터에 대해서 다시 설명하겠다고 했던 것을 기억하는가? 해당 카테고리에서의 사상들은 꾸며진(embellished) 함수로 표현되어 <code class=\"language-text\">Writer</code> 데이터 구조를 반환했었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>필자는 이렇게 꾸며진 기능이 어떤 방식으로든 엔도 펑터와 관련이 있다고 말했다. 그리고 실제로 <code class=\"language-text\">Writer</code> 타입 생성자는 <code class=\"language-text\">a</code>에 대해 펑터적이다. 심지어 이를 위해 <code class=\"language-text\">fmap</code>을 구현할 필요도 없다. 왜냐하면 반환된 타입은 단순한 곱 타입이기 떄문이다.</p>\n<p>일반적으로 크라이슬리 카테고리와 펑터 간의 관계는 다음과 같다. 크라이슬리 카테고리는 카테고리이기 때문에 합성과 항등성을 정의해야한다. 그리고 합성은 fish(<code class=\"language-text\">>=></code>) 연산자에 의해 제공된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">>=></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">m1</span> <span class=\"token operator\">>=></span> <span class=\"token hvariable\">m2</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m1</span> <span class=\"token hvariable\">x</span>\n        <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m2</span> <span class=\"token hvariable\">y</span>\n    <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 항등 사상은 <code class=\"language-text\">return</code>이라고 불리는 함수를 통해 제공했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">return</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span> <span class=\"token builtin\">return</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 이 두 함수들의 타입을 오랜 시간 들여다 보다보면, <code class=\"language-text\">fmap</code>으로 사용할 수 있는 올바른 타입의 함수를 생성하는 방법을 찾을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">id</span> <span class=\"token operator\">>=></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token builtin\">return</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 예시에서 fish 연산자는 우리에게 익숙한 <code class=\"language-text\">id</code>, 그리고 인수에 <code class=\"language-text\">f</code>를 적용한 결과에 다시 <code class=\"language-text\">return</code>을 적용한 람다, 두 함수를 합성한다.</p>\n<p>아마 여기서 가장 이해하기 어려운 부분은 <code class=\"language-text\">id</code>의 사용법일 것이다. fish 연산자의 인수는 <code class=\"language-text\">Int</code>, <code class=\"language-text\">Bool</code>과 같은 일반 타입을 가져와서 꾸며진(embellished) 타입을 반환하는 함수여야 한다고 생각할 수 있겠지만 사실은 아니다. 아무도 <code class=\"language-text\">a -> Writer b</code>에서의 <code class=\"language-text\">a</code>가 일반 타입이어야 한다고 한 적은 없다. 이것은 그저 타입 변수일뿐이므로 어떤 것이든 될 수 있으며, 심지어 <code class=\"language-text\">Writer b</code>와 같이 이미 꾸며진 타입이 될 수도 있다.</p>\n<p>그래서 <code class=\"language-text\">id</code>는 <code class=\"language-text\">Writer a</code>를 받아서 그대로 <code class=\"language-text\">Writer a</code>를 반환할 것이다. fish 연산자는 <code class=\"language-text\">a</code>의 값을 꺼내어 람다의 <code class=\"language-text\">x</code> 인자로 전달할 것이다. 이후 <code class=\"language-text\">f</code>는 그것을 <code class=\"language-text\">b</code>로 변환하고, <code class=\"language-text\">return</code>은 이 결과를 꾸며 최종적으로 <code class=\"language-text\">Writer b</code>로 만들 것이다. 이 모든 것을 조합한다면 우리는 <code class=\"language-text\">Writer a</code>를 가져와 <code class=\"language-text\">Writer b</code>를 반환하는 함수를 얻게된다. 즉, <code class=\"language-text\">Writer</code>의 <code class=\"language-text\">fmap</code>이 해야하는 것과 정확히 같은 일을 하는 것이다.</p>\n<p>이 정의에서 <code class=\"language-text\">Writer</code>는 다른 임의의 타입 생성자로 변경될 수 있기 때문에 이 인자는 매우 일반적이라고 할 수 있다. 뭐가 되었던 fish 연산자와 <code class=\"language-text\">return</code>을 지원한다면 이를 활용하여 <code class=\"language-text\">fmap</code>을 정의할 수 있다는 것이다. 따라서 크라이슬리 카테고리에서의 장식(embellishment)은 항상 펑터라고 할 수 있다.</p>\n<p>사실 우리가 방금 정의했던 <code class=\"language-text\">fmap</code>과 <strong><code class=\"language-text\">deriving Functor</code></strong> 확장 기능을 통해 컴파일러가 생성해주는 <code class=\"language-text\">fmap</code>은 동일하다. 이는 Haskell이 다형성 함수를 구현하는 방식 때문인데, 이를 매개변수 다형성(Parametric polymorphism)이라고 하며, 공짜 정리(Theorems for free)라고 불리는 정리의 원천이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>매개변수 다형성(Parametric polymorphism)은 함수나 데이터 유형이 여러 타입에 대해 동작할 수 있도록 하는 기능이며, 타입스크립트의 Generic Type도 매개변수 다형성의 구현 중 하나이다.</p>\n<p>공짜 정리(Theorems for free)는 어떤 하나의 정리를 통해 다른 정리가 추가적인 증명없이도 자동으로 성립하는 것을 의미하므로, 매개변수 다형성 또한 공짜 정리의 한 측면이라고 볼 수 있는 것이다. 타입스크립트로 예를 들자면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">nonEmptyArray</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>arr<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">nonEmptyArray</code> 함수는 인자가 <code class=\"language-text\">number[]</code> 타입이든 <code class=\"language-text\">string[]</code> 타입이든 상관없이 일관된 동작을 제공한다. 즉, 다형적인 동작이 제대로 정의되었다면, <code class=\"language-text\">number[]</code> 타입에 대해 제대로 작동한다는 사실이 증명됨과 함께 <code class=\"language-text\">string[]</code> 타입에 대한 동작이 제대로 작동한다는 보장도 함께 공짜로 성립되는 것이다.</p>\n</blockquote>\n<p>이러한 정리가 의미하는 것 중 하나는 특정 타입 생성자에 대한 <code class=\"language-text\">fmap</code>이 존재하고 이 함수가 항등성을 보존하고 있다면, 그 구현 방법은 유일해야 한다는 것이다.</p>\n<h2 id=\"86-공변적-펑터와-반공변적-펑터covariant-and-contravariant-functors\" style=\"position:relative;\">8.6 공변적 펑터와 반공변적 펑터(Covariant and Contravariant Functors)<a href=\"#86-%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0%EC%99%80-%EB%B0%98%EA%B3%B5%EB%B3%80%EC%A0%81-%ED%8E%91%ED%84%B0covariant-and-contravariant-functors\" aria-label=\"86 공변적 펑터와 반공변적 펑터covariant and contravariant functors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">Writer</code> 펑터에 대해서 살펴보았으니, <code class=\"language-text\">Reader</code> 펑터도 다시 한번 살펴보자. 다시 한번 이야기하지만 <code class=\"language-text\">Reader</code> 펑터는 부분적용된 함수 화살표 타입 생성자를 기반으로 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">r</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 정의를 타입 동의어를 사용하여 다시 작성해보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Reader</span> <span class=\"token hvariable\">r</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">r</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 <code class=\"language-text\">Reader</code>의 <code class=\"language-text\">Functor</code> 인스턴스는 아래와 같이 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">g</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>쌍 타입 생성자나 <code class=\"language-text\">Either</code> 타입 생성자와 마찬가지로 함수 타입 생성자 또한 두 개의 타입 인자를 받는다. 기억을 되짚어보면 쌍과 <code class=\"language-text\">Either</code>는 자신들이 받는 각각의 인자에 대해 펑터적이었고, 이를 이항 펑터(bifunctor)라고 한다고 했다. 그렇다면 함수 생성자도 두 개의 타입 인자를 받고 있으니 이들과 동일하게 이항 펑터일까?</p>\n<p>백문이불여일견이니 직접 확인해보자. 우선 첫 번째 인자에 대해 펑터적인지 확인해보겠다. 우선 타입 동의어에서부터 시작해볼 것이다. 아래 정의는 <code class=\"language-text\">Reader</code>에서 단지 인수의 순서만 뒤바뀐 형태이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Op</span> <span class=\"token hvariable\">r</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 반환 타입인 <code class=\"language-text\">r</code>을 고정하고 인수 타입인 <code class=\"language-text\">a</code>에 변형을 가할 것이다. 그리고 <code class=\"language-text\">a</code>를 변형하는 <code class=\"language-text\">fmap</code>을 구현하기 위한 타입 시그니처는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>인수로 <code class=\"language-text\">a</code>를 받고 각각 <code class=\"language-text\">b</code>와 <code class=\"language-text\">r</code>을 반환하는 두 개의 함수만 있는 경우, 이들을 사용하여 <code class=\"language-text\">b</code>를 받아 <code class=\"language-text\">r</code>을 반환하는 함수를 만들 수 있는 방법은 존재하지 않는다.</p>\n<p>하지만 첫 번째 함수를 반대로 뒤집을 수 있다면 상황은 달라진다. 즉, 첫 번째 함수가 <code class=\"language-text\">b</code>를 받아 <code class=\"language-text\">a</code>를 반환하는 함수가 되도록 만들어주면 되는 것이다. 우리는 임의의 함수를 막 뒤집을 수는 없지만, 반대 카테고리로 이동해볼 수는 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>필자가 <code class=\"language-text\">Reader</code>에 대한 설명을 하다가 갑자기 반대 카테고리에 대한 이야기를 하고 있어서 설명의 흐름이 어색하다. 결과적으로 말하자면 <code class=\"language-text\">Reader r a</code>는 두 인자를 받아 <code class=\"language-text\">r</code>을 <code class=\"language-text\">a</code>로 변형하는 매핑을 의미하기 때문에 이항 펑터가 아니다.</p>\n<p>앞서 보았던 쌍이나 <code class=\"language-text\">Either</code>의 경우 자신들이 받는 인수의 순서를 변경하더라도 연산의 결과는 동일하게 보장된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Bifunctor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">bimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">g</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 패턴 매칭을 통해 연산을 적용하기 때문에</span>\n<span class=\"token comment\">-- 인자의 순서가 g f (x, y)가 되어도 f는 x에, g는 y에 적용된다.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그러나 <code class=\"language-text\">Reader</code> 펑터의 <code class=\"language-text\">fmap</code>은 함수의 합성이기 때문에 첫 번째 인자의 결과가 두 번째 인자에 의존하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Reader</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n\t  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">g</span>\n<span class=\"token comment\">-- 만약 합성의 순서가 g . f가 된다면 연산 결과가 달라지거나</span>\n<span class=\"token comment\">-- 혹은 합성 자체가 불가능한 상황이 발생할 수도 있다.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>필자는 이러한 <code class=\"language-text\">Reader</code> 펑터의 특성을 보이기 위해, 인수의 순서를 반대로 뒤집은 <code class=\"language-text\">Op</code>라는 타입을 예로 들어 설명하고 있는 것이다.</p>\n</blockquote>\n<p>반대 카테고리가 기억나지 않을 수 있으니 간단하게 복습해보자. 모든 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에 대한 반대 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 같은 대상들을 가지고 있지만 모든 화살표(사상)의 방향이 반대로 뒤집어진 카테고리이다.</p>\n<p>그럼 이제 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>와 다른 임의의 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span> 사이를 이동하는 펑터를 떠올려보자.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo>:</mo><mo>:</mo><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">F::C^{op} → D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span></div>\n<p>이런 펑터는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>의 어떤 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f^{op} :: a → b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">F f^{op} :: F a → F b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>로 매핑한다. 그러나 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">f^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>는 원래 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서의 어떤 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mo>:</mo><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">f :: b → a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>에 해당한다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>가 서로 반전되어있음에 주목하자.</p>\n<p>이렇게 반대 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>에서 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 나아가는 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>를 정의했다. 그렇다면 이제 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>를 사용하여 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 바로 나아가는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>라는 매핑도 생각해볼 수 있다. 즉, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로의 매핑이다. 하지만 사실 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>는 펑터가 아니다. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>와 마찬가지로 대상들을 동일하게 매핑하지만, 사상을 매핑할 때는 반대로 뒤집어서 매핑하기 때문이다.</p>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mo>:</mo><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">f :: b → a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>를 반대 사상인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">f^{op} :: a → b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>로 매핑한 다음, 이를 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>에 적용하여 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><msup><mi>f</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><mo>:</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">F f^{op} :: F a→F b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 얻어야 한다.</p>\n<p>주어진 조건에 따라 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">Fa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">Ga</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 동일하고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">Fb</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">Gb</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">b</span></span></span></span></span>와 동일하다고 가정할 때, 전체적인 흐름은 아래와 같이 나타내볼 수 있다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>G</mi><mi>f</mi><mo>:</mo><mo>:</mo><mo stretchy=\"false\">(</mo><mi>b</mi><mo>→</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">(</mo><mi>G</mi><mi>a</mi><mo>→</mo><mi>G</mi><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G f :: (b → a) → (G a → G b) \t\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">::</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span></div>\n<p>이렇게 사상의 방향을 반전하는 카테고리 간의 매핑을 반공변적 펑터(Contravariant Functor)라고 한다. 반공변적 펑터는 반대 카테고리에서의 일반적인 펑터일 뿐이다. 그리고 우리가 지금까지 공부해왔던 일반적인 펑터는 공변적 펑터(Covariant Functor)라고 한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 530px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2675b6c5c6369f38ae301b55685cd3b0/d0861/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 98.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAQEAAwAAAAAAAAAAAAAAAAIBAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQD/2gAMAwEAAhADEAAAAfTrYbuIFOA8oT//xAAbEAACAwADAAAAAAAAAAAAAAABAgADEhEhMv/aAAgBAQABBQKx3BqZiY/OjrKeGUGFBkdD/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQESEx/9oACAEBAAY/AqQ75GMeiLn/xAAbEAACAgMBAAAAAAAAAAAAAAAAARFBITFREP/aAAgBAQABPyGplMqy742MHZDRa3g7JxslGmR9l0SBKj//2gAMAwEAAgADAAAAEMMIvP/EABYRAAMAAAAAAAAAAAAAAAAAABARQf/aAAgBAwEBPxBxCD//xAAWEQADAAAAAAAAAAAAAAAAAAARICH/2gAIAQIBAT8QgT//xAAcEAEBAQEAAgMAAAAAAAAAAAABESEAUWEQMZH/2gAIAQEAAT8QZnGXyeeLLQNEV9evjYwTJsXzxm5dOP3lb5xq3ldAT75DDobmcddABe//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/2675b6c5c6369f38ae301b55685cd3b0/d0861/5.jpg\" srcset=\"/static/2675b6c5c6369f38ae301b55685cd3b0/0913d/5.jpg 160w,\n/static/2675b6c5c6369f38ae301b55685cd3b0/cb69c/5.jpg 320w,\n/static/2675b6c5c6369f38ae301b55685cd3b0/d0861/5.jpg 530w\" sizes=\"(max-width: 530px) 100vw, 530px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>아래는 Haskell에서 반공변적인 (엔도)펑터를 정의하는 타입 클래스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Contravariant</span> <span class=\"token hvariable\">f</span> <span class=\"token keyword\">where</span>\n  \t<span class=\"token hvariable\">contramap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, 아까 정의했던 타입 생성자 <code class=\"language-text\">Op</code>의 인스턴스는 아래와 같이 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Contravariant</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Op</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n  \t<span class=\"token comment\">-- (b -> a) -> Op r a -> Op r b</span>\n  \t<span class=\"token hvariable\">contramap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>함수 <code class=\"language-text\">f</code>가 <code class=\"language-text\">Op</code>의 내용인 함수 <code class=\"language-text\">g</code>의 앞에 자신을 삽입한다는 것에 주목하자. (함수 합성의 연산 순서는 오른쪽에서 왼쪽이다.)</p>\n<p>여기서 <code class=\"language-text\">Op</code>의 <code class=\"language-text\">contramap</code>의 정의는 단지 인자를 뒤집은 함수 합성 연산자일 뿐이라는 것을 알 수 있으며, 이 사실을 알았다면 이제 더 간결하게 만들어 볼 수도 있다.</p>\n<p>여기 인자를 뒤집는데 사용되는 특수한 함수인 <code class=\"language-text\">flip</code>이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">flip</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">flip</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">y</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러면 이제 <code class=\"language-text\">contramap</code>의 정의를 이렇게 간단하게 바꿔볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">contramap</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">flip</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2 id=\"87-프로펑터profunctors\" style=\"position:relative;\">8.7 프로펑터(Profunctors)<a href=\"#87-%ED%94%84%EB%A1%9C%ED%8E%91%ED%84%B0profunctors\" aria-label=\"87 프로펑터profunctors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리는 함수 화살표 연산자가 첫 번째 인자에서 반공변 변형이 되고, 두 번째 인자에서 공변 변형이 되는 상황을 보았다. 이런 개념에 대한 명칭도 있을까?</p>\n<p>만약 대상 카테고리가 <em>Set</em>이라면 이 개념을 프로펑터(Profunctor)라고 부른다. 반공변적 펑터는 반대 카테고리에서의 공변적 펑터와 동일하기 때문에, 프로펑터는 아래와 같이 정의된다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>×</mo><mi>D</mi><mo>→</mo><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">C^{op} × D → Set \t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7977em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span></span></span></span></span></div>\n<p>일단 Haskell 타입을 집합이라고 가정해보면, 우리는 첫 번째 인자에 대해 반공변적 펑터적이고 두 번째 인자에 대해서는 펑터적인 두 개의 인자를 받는 타입 생성자 <code class=\"language-text\">p</code>에 <code class=\"language-text\">Profuctor</code>라는 이름을 부여할 수 있다. 아래는 <code class=\"language-text\">Data.Profuctor</code> 라이브러리에서 가져온 타입 클래스의 모습이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Profunctor</span> <span class=\"token hvariable\">p</span> <span class=\"token keyword\">where</span>\n  \t<span class=\"token hvariable\">dimap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">d</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">d</span>\n  \t<span class=\"token hvariable\">dimap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">lmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">rmap</span> <span class=\"token hvariable\">g</span>\n  \t<span class=\"token hvariable\">lmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">c</span>\n  \t<span class=\"token hvariable\">lmap</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">dimap</span> <span class=\"token hvariable\">f</span> <span class=\"token builtin\">id</span>\n  \t<span class=\"token hvariable\">rmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">c</span>\n    <span class=\"token hvariable\">rmap</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">dimap</span> <span class=\"token builtin\">id</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>세 함수 모두 기본 구현이 제공된다. <code class=\"language-text\">Bifunctor</code>와 마찬가지로 <code class=\"language-text\">Profuctor</code>의 인스턴스를 선언할 때는 <code class=\"language-text\">dimap</code>을 구현하고 <code class=\"language-text\">lmap</code>과 <code class=\"language-text\">rmap</code>에 대한 기본값을 사용하거나, 혹은 <code class=\"language-text\">lmap</code>과 <code class=\"language-text\">rmap</code>을 모두 구현하고 <code class=\"language-text\">dimap</code>에 대한 기본값을 사용할 수 있는 선택권이 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 497px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8c3e7c302a315abaa1d56875acd0c0f8/fce5f/6.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 81.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHXTVAto0T/xAAaEAEAAgMBAAAAAAAAAAAAAAABAAIDERIx/9oACAEBAAEFAu0u5LTHvlqQGHn/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwEJ/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAwADAAAAAAAAAAAAAAAAABARITJB/9oACAEBAAY/ApxZLKaL/8QAGxABAAICAwAAAAAAAAAAAAAAAQARITFRgZH/2gAIAQEAAT8hdKZU4rp1PYl1dnEKtMzBQxU//9oADAMBAAIAAwAAABAbz//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/EGZ//8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/ENCf/8QAHBABAAMBAQADAAAAAAAAAAAAAQARITFRQWFx/9oACAEBAAE/EEiAW29I9Djvo5+zSoVenzHWlK+2QAU1W3V3WQhFAc8n/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"\" src=\"/static/8c3e7c302a315abaa1d56875acd0c0f8/fce5f/6.jpg\" srcset=\"/static/8c3e7c302a315abaa1d56875acd0c0f8/0913d/6.jpg 160w,\n/static/8c3e7c302a315abaa1d56875acd0c0f8/cb69c/6.jpg 320w,\n/static/8c3e7c302a315abaa1d56875acd0c0f8/fce5f/6.jpg 497w\" sizes=\"(max-width: 497px) 100vw, 497px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>여기까지 왔으면 이제 함수 화살표 연산자가 <code class=\"language-text\">Profuctor</code>의 인스턴스라는 것을 단언할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Profunctor</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">dimap</span> <span class=\"token hvariable\">ab</span> <span class=\"token hvariable\">cd</span> <span class=\"token hvariable\">bc</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">cd</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">bc</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">ab</span>\n    <span class=\"token hvariable\">lmap</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">flip</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n    <span class=\"token hvariable\">rmap</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>프로펑터는 Haskell 렌즈 라이브러리에서 응용되고 있으며, 추후 ends와 coends에 대해 이야기할 때 다시 한번 자세히 설명할 것이다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240402-category-theory-for-programmers-8-functoriality","path":"/2024/04/02/category-theory-for-programmers-8-functoriality/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 8. 펑터의 특성","subTitle":null,"date":"Apr 02, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"229edda2-bbc2-5edd-b61a-9b3cededad81","tableOfContents":"<ul>\n<li>\n<p><a href=\"#71-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0\">7.1 프로그래밍에서의 펑터</a></p>\n<ul>\n<li><a href=\"#711-maybe-%ED%8E%91%ED%84%B0\">7.1.1 Maybe 펑터</a></li>\n<li><a href=\"#712-%EB%B0%A9%EC%A0%95%EC%8B%9D-%EC%B6%94%EB%A1%A0equational-reasoning\">7.1.2 방정식 추론(Equational Reasoning)</a></li>\n<li><a href=\"#713-optional\">7.1.3 Optional</a></li>\n<li><a href=\"#714-%ED%83%80%EC%9E%85-%ED%81%B4%EB%9E%98%EC%8A%A4typeclasses\">7.1.4 타입 클래스(Typeclasses)</a></li>\n<li><a href=\"#715-c%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0functor-in-c\">7.1.5 C++에서의 펑터(Functor in C++)</a></li>\n<li><a href=\"#716-list-%ED%8E%91%ED%84%B0\">7.1.6 List 펑터</a></li>\n<li><a href=\"#717-reader-%ED%8E%91%ED%84%B0\">7.1.7 Reader 펑터</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#72-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%A1%9C%EC%8D%A8%EC%9D%98-%ED%8E%91%ED%84%B0\">7.2 컨테이너로써의 펑터</a></p>\n</li>\n<li>\n<p><a href=\"#73-%ED%8E%91%ED%84%B0-%ED%95%A9%EC%84%B1functor-composition\">7.3 펑터 합성(Functor Composition)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></p>\n</li>\n</ul>","excerpt":"이번 챕터에서는 펑터(Functor)에 대해서 이야기를 해보려고 한다. 펑터는 간단하지만 매우 강력한 개념이며 카테고리 이론은 이처럼 간단하지만 강력한 아이디어로 가득 차있다. 펑터는 카테고리 간의 매핑이다. 즉, 두 카테고리 와 가 주어졌을 때, 펑터 는 카테고리 의 대상을 카테고리 의 대상으로 매핑하는 것이며, 결국 대상들에 대한 함수라고 볼 수 있다. 만약 카테고리 의 대상을 라고 한다면, 우리는 매핑된 카테고리 의 대상을 라고 표현할 수 있다. 하지만 카테고리는 대상으로만 구성되어있지 않으며 대상과 그들을 연결하는 사상까지…","html":"<p>이번 챕터에서는 펑터(Functor)에 대해서 이야기를 해보려고 한다. 펑터는 간단하지만 매우 강력한 개념이며 카테고리 이론은 이처럼 간단하지만 강력한 아이디어로 가득 차있다.</p>\n<p>펑터는 카테고리 간의 매핑이다. 즉, 두 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>가 주어졌을 때, 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 대상을 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상으로 매핑하는 것이며, 결국 대상들에 대한 함수라고 볼 수 있다.</p>\n<p>만약 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>의 대상을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>라고 한다면, 우리는 매핑된 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 대상을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">F a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span></span></span></span></span>라고 표현할 수 있다. 하지만 카테고리는 대상으로만 구성되어있지 않으며 대상과 그들을 연결하는 사상까지 모두 포함하는 개념이다. 즉, 펑터는 대상 뿐 아니라 사상 또한 매핑하며, 이런 경우에는 사상에 대한 함수라고 볼 수도 있다. 그렇다고 펑터가 마음대로 사상을 매핑하는 것은 아니고, 반드시 사상으로 연결된 대상들의 구조를 그대로 보존해야 한다.</p>\n<p>만약 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에 있는 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>가 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 연결하고 있다면,</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>펑터를 통해 매핑된 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>에 있는 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">F f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> 또한 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>와 동일한 구조로 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">F a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">F b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">b</span></span></span></span></span>를 연결해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 548px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/53ed4e9ec17829d825f87748ed6a6e02/a8866/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAMCBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9adM10MorISoX//EABoQAQACAwEAAAAAAAAAAAAAAAECEgARIjH/2gAIAQEAAQUCktpOiG6zenyCpgFs/8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQMBAT8BY//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABoQAAICAwAAAAAAAAAAAAAAAAAQAREhUcH/2gAIAQEABj8CNmVfXK//xAAbEAACAwEBAQAAAAAAAAAAAAABEQAhMUFREP/aAAgBAQABPyEVHT9hC0CfJQ7hlByUwfFaYknwwh7MmPn/2gAMAwEAAgADAAAAEODAvP/EABgRAAMBAQAAAAAAAAAAAAAAAAABMRAR/9oACAEDAQE/EOUUdWf/xAAWEQEBAQAAAAAAAAAAAAAAAAABEDH/2gAIAQIBAT8QCGT/xAAfEAEAAgICAgMAAAAAAAAAAAABETEAIUFREIGRwdH/2gAIAQEAAT8Q3IVVhAlz6yHKYJk/cvqubuOMAcKrQd85WGzaKH3iBSTs5MAQBOkw0XxeP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/53ed4e9ec17829d825f87748ed6a6e02/a8866/1.jpg\" srcset=\"/static/53ed4e9ec17829d825f87748ed6a6e02/0913d/1.jpg 160w,\n/static/53ed4e9ec17829d825f87748ed6a6e02/cb69c/1.jpg 320w,\n/static/53ed4e9ec17829d825f87748ed6a6e02/a8866/1.jpg 548w\" sizes=\"(max-width: 548px) 100vw, 548px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>여기서 알 수 있듯이 펑터는 카테고리의 구조를 그대로 보존한다. 한 카테고리 내에서 연결되어있는 것들은 펑터를 통해 매핑된 카테고리에서도 그대로 연결되어 있는 것이다. 이에 더해 카테고리에는 단순히 대상을 사상으로 연결하는 것 뿐 아니라 사상 간의 합성이라는 개념 또한 존재한다.</p>\n<p>사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\"application/x-tex\">h</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">h</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>의 합성사상인 상황을 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">h</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그렇다면 펑터 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span>를 통해 만들어진 카테고리의 사상들의 합성 관계도 이와 동일하게 유지된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> <span class=\"token hvariable\">h</span> <span class=\"token operator\">=</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token constant\">F</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 384px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6c626a002083ba1ab990172bf55de07e/4ecad/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 108.74999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAWABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMCBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe3msioEwqD/xAAaEAACAwEBAAAAAAAAAAAAAAAAAQIRIRAS/9oACAEBAAEFAnI9ULVaFURaUhR5/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAwADAQAAAAAAAAAAAAAAAAEhEDFRQf/aAAgBAQAGPwKJnct+ENFvMf/EABwQAQADAAIDAAAAAAAAAAAAAAEAESEQUWFxgf/aAAgBAQABPyGnFPqWvrm4qHuJNLvUYUUtiBasmy03xN3IH4OP/9oADAMBAAIAAwAAABBTxzz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAcEAEBAAMBAAMAAAAAAAAAAAABEQAhMUGBkcH/2gAIAQEAAT8QZINb4MQEg2zXeW5NRIsfMJBvlbfjFom723m8HkXiNHFUK9MbyEyDc6TX3+YAGgPdZ//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/6c626a002083ba1ab990172bf55de07e/4ecad/2.jpg\" srcset=\"/static/6c626a002083ba1ab990172bf55de07e/0913d/2.jpg 160w,\n/static/6c626a002083ba1ab990172bf55de07e/cb69c/2.jpg 320w,\n/static/6c626a002083ba1ab990172bf55de07e/4ecad/2.jpg 384w\" sizes=\"(max-width: 384px) 100vw, 384px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>마지막으로 우리는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span> 안의 모든 항등사상들이 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>의 항등사상들로 매핑되는 상황 또한 생각해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">F</span> <span class=\"token hvariable\">id_a</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">id_Fa</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><msub><mi>d</mi><mi>a</mi></msub></mrow><annotation encoding=\"application/x-tex\">id_a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>는 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>의 항등사상이며, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><msub><mi>d</mi><mi>F</mi></msub><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">id_Fa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span></span></span></span></span>는 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">F a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">a</span></span></span></span></span>의 항등사상이다. 이처럼 항상 카테고리의 구조를 보존해야한다는 조건들로 인해 펑터는 일반적인 함수보다 더 제한적인 개념이 된다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 302px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b3c6b68dbbf4939beb37c24ad5731725/7a297/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 133.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHuU0ErCuO4JH//xAAbEAACAgMBAAAAAAAAAAAAAAAAAQIRAyAiIf/aAAgBAQABBQKVnTFY1ZGKih+LH09P/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAQUBAAAAAAAAAAAAAAAAAQAQESAhMf/aAAgBAQAGPwLDC6taA5INf//EABwQAQACAgMBAAAAAAAAAAAAAAEAERAhMUFRYf/aAAgBAQABPyE1vSHq4fCnJU0cL+TX2leToZhWMQgJe/LwglJcAOMf/9oADAMBAAIAAwAAABBDCDD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAdEAEAAgIDAQEAAAAAAAAAAAABESEAQRAxUWGB/9oACAEBAAE/EHbOPb38vK5B42BPO+3NWPpWHfOzaJ+OEDYbWVfV28GghBti8E+IR7Qsvz5viBAeJOAUCWaOP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/b3c6b68dbbf4939beb37c24ad5731725/7a297/3.jpg\" srcset=\"/static/b3c6b68dbbf4939beb37c24ad5731725/0913d/3.jpg 160w,\n/static/b3c6b68dbbf4939beb37c24ad5731725/7a297/3.jpg 302w\" sizes=\"(max-width: 302px) 100vw, 302px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>만약 어떤 카테고리를 각 대상들이 사상으로 연결되어있는 일종의 네트워크라고 상상해보자. 펑터는 각 대상과 사상을 그저 매핑하는 개념일뿐이므로 네트워크의 요소들을 서로 분리해내는 것은 절대 불가능하다. 펑터로 대상들을 합칠 수도 있고 여러 사상들을 하나로 붙혀놓을 수도 있겠지만 분해하는 것은 불가능한 것이다.</p>\n<p>이와 같이 분해가 불가능하다는 제약은 미적분에서 볼 수 있는 연속성의 조건과 유사하다. 이런 의미에서 펑터는 “연속적”이라고 볼 수도 있다. 또한 마치 정의역과 공역의 관계를 축소나 포함이라는 시각으로 바라보는 것과 유사하게 펑터 또한 동일한 시각으로 바라볼 수 있다. 예를 들면 펑터의 소스가 되는 카테고리가 대상 카테고리보다 더 작을 때는 포함과 같은 개념으로 볼 수 있는 것이다.</p>\n<p>한번 극단적인 예시를 생각해보자. 펑터의 소스가 되는 카테고리는 단 하나의 대상과 하나의 항등사상만으로 이루어진 단일대상 카테고리가 될 수도 있다. 이처럼 단일대상 카테고리를 다른 카테고리로 매핑하는 펑터는 단순히 해당 카테고리에서 하나의 대상을 선택하는 것과 다를 게 없다. 이는 단일원소집합에서 하나의 원소를 선택하는 사상의 특성과 완전히 유사하다.</p>\n<p>소스 카테고리를 최대한 축소하는 펑터는 상수 펑터(Constant Functor), <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span><span class=\"mord mathnormal\">c</span></span></span></span></span>로 불린다. 이 펑터는 소스 카테고리의 모든 대상을 대상 카테고리에서 선택된 하나의 대상인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></span>로, 그리고 소스 카테고리의 모든 사상을 항등사상인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><msub><mi>d</mi><mi>c</mi></msub></mrow><annotation encoding=\"application/x-tex\">id_c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 매핑한다. 이 펑터는 마치 블랙홀처럼 작동하여 모든 것을 하나의 특이점으로 압축해버린다. 우리가 추후 한계(Limits)와 공한계(Colimits)에 대해 이야기할 때 이러한 펑터를 더 자세히 살펴볼 것이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>작가의 설명만 보면 마치 상수 펑터(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span><span class=\"mord mathnormal\">c</span></span></span></span></span>)가 어떤 카테고리를 다른 카테고리로 매핑하며 압축하는 녀석으로 보일 수 있지만, 사실 상수 펑터는 특정 카테고리를 자기 자신으로 매핑하는 엔도펑터(EndoFunctor)이다. (엔도펑터에 대한 설명은 바로 다음 섹션에 나온다.)</p>\n<p>즉, 상수 펑터는 어떤 카테고리의 모든 대상을 그 카테고리 내의 대상 하나로 매핑(압축)하는 개념이라고 보면 된다. 이 과정에서 카테고리의 대상들을 연결하던 임의의 사상들은 모두 선택된 대상의 항등 사상으로 매핑된다.</p>\n</blockquote>\n<h2 id=\"71-프로그래밍에서의-펑터\" style=\"position:relative;\">7.1 프로그래밍에서의 펑터<a href=\"#71-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0\" aria-label=\"71 프로그래밍에서의 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이제부터는 실질적인 프로그래밍에 대해서 이야기해보자. 이미 우리는 프로그래밍의 세계에서 타입과 함수로 이루어진 카테고리를 다루고 있다. 이번에는 이 카테고리를 자기 자신으로 매핑하는 펑터, 엔도펑터(EndoFunctor)에 대해서 생각해보려고 한다.</p>\n<p>자, 타입으로 이루어진 카테고리에서의 엔도펑터는 무엇일까? 이 펑터는 타입을 타입으로 매핑하는 펑터일 것이다. 사실 여러분은 이미 이러한 매핑의 예시를 숱하게 봐왔을테지만 단지 그것이 엔도펑터라는 것을 깨닿지 못 했을 뿐이다. 아래 몇 가지 예시를 한번 살펴보자.</p>\n<h3 id=\"711-maybe-펑터\" style=\"position:relative;\">7.1.1 Maybe 펑터<a href=\"#711-maybe-%ED%8E%91%ED%84%B0\" aria-label=\"711 maybe 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">Maybe</code>의 정의는 어떠한 타입 <code class=\"language-text\">a</code>를 <code class=\"language-text\">Maybe a</code>라는 타입으로 매핑하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 중요한 포인트가 하나 있다. <code class=\"language-text\">Maybe</code> 자체는 타입이 아니라 타입 생성자(Type Constructor)라는 것이다. 타입 생성자를 타입으로 변환하기 위해서는 <code class=\"language-text\">Int</code>나 <code class=\"language-text\">Bool</code>과 같은 타입 인자를 생성자에게 제공해야 한다. 즉, 아무 인자로 받지 않는 <code class=\"language-text\">Maybe</code>는 타입에 대한 함수를 나타내는 것이다.</p>\n<p>그렇다면 <code class=\"language-text\">Maybe</code>를 펑터로 변환해볼 수 있을까? (프로그래밍 맥락에서 펑터에 대해 이야기할 때는 거의 항상 엔도펑터를 이야기한다는 사실을 유념하자.) 펑터는 대상(타입)의 매핑 뿐만 아니라 사상(함수)의 매핑도 모두 포함하는 개념이다. 한번 <code class=\"language-text\">a</code>에서 <code class=\"language-text\">b</code>로 나아가는 임의의 함수 <code class=\"language-text\">f</code>가 있다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 <code class=\"language-text\">Maybe a</code>에서 <code class=\"language-text\">Maybe b</code>로 나아가는 함수를 생성하고 싶다. 이러한 함수를 제대로 정의하기 위해서는 <code class=\"language-text\">Maybe</code>를 구성하는 두 생성자인 <code class=\"language-text\">Nothing</code>과 <code class=\"language-text\">Just</code>에 대해 고려해야한다.</p>\n<p><code class=\"language-text\">Nothing</code>의 경우에는 그저 <code class=\"language-text\">Nothing</code>을 반환해주기만 하면 되니 간단하다. 그리고 인자가 <code class=\"language-text\">Just</code>인 경우에는 함수 <code class=\"language-text\">f</code>를 <code class=\"language-text\">Just</code>가 가지고 있는 값에 적용해주면 될 것이다.</p>\n<p>즉, <code class=\"language-text\">Maybe</code>라는 펑터를 거친 <code class=\"language-text\">f</code>의 모습은 아래와 같은 함수가 된다. (Haskell에서는 변수명에 아포스트로피(<code class=\"language-text\">’</code>)를 사용할 수 있으며, 이 기능은 아래와 같은 경우에 매우 편리하다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f'</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">b</span>\n<span class=\"token hvariable\">f'</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token hvariable\">f'</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Haskell에서는 펑터가 사상을 매핑하는 행위를 <code class=\"language-text\">fmap</code>이라는 고차함수로 구현하며, <code class=\"language-text\">Maybe</code>의 경우에는 아래와 같은 정의가 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 469px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b4a1919d61c677ca0dd43a79a5bfd207/a76eb/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 73.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHbS2BwD//EABoQAQABBQAAAAAAAAAAAAAAAAESABARITH/2gAIAQEAAQUCllWLT3Zb/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAwADAAAAAAAAAAAAAAAAAAEQEUFR/9oACAEBAAY/AsI24js//8QAHhABAAICAQUAAAAAAAAAAAAAAQARMUEQIWFxgZH/2gAIAQEAAT8hr9DtELroxBsuk8xIAZ3KIp9+P//aAAwDAQACAAMAAAAQQM//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAEAAgIDAQEAAAAAAAAAAAABABEhQTFRYXGB/9oACAEBAAE/EHMd7InjUDW2mS38OcblXkNCmCU530ryaYHJgv7BUFKep//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/b4a1919d61c677ca0dd43a79a5bfd207/a76eb/4.jpg\" srcset=\"/static/b4a1919d61c677ca0dd43a79a5bfd207/0913d/4.jpg 160w,\n/static/b4a1919d61c677ca0dd43a79a5bfd207/cb69c/4.jpg 320w,\n/static/b4a1919d61c677ca0dd43a79a5bfd207/a76eb/4.jpg 469w\" sizes=\"(max-width: 469px) 100vw, 469px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>우리는 종종 <code class=\"language-text\">fmap</code>이 함수를 리프트(lift)한다고 말한다. 이렇게 리프팅된 함수는 이제 <code class=\"language-text\">Maybe</code> 타입의 값에 작용하는 함수가 되었다.</p>\n<p>또한 커링(Currting)으로 인해 위 정의는 하나의 함수 <code class=\"language-text\">a → b</code>를 받아서 다른 함수 <code class=\"language-text\">Maybe a → Maybe b</code>를 반환하는 함수, 그리고 <code class=\"language-text\">a → b</code>와 <code class=\"language-text\">Maybe a</code>라는 두 개의 인자를 받아 <code class=\"language-text\">Maybe b</code>를 반환하는 함수, 총 두 가지 방식으로 해석될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이러한 특성들을 기반으로 <code class=\"language-text\">Maybe</code>에 대한 <code class=\"language-text\">fmap</code>을 구현해보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">_</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 적용할 함수 f와 Just x를 인자로 받아,</span>\n<span class=\"token comment\">-- Just가 가진 값에 함수 f가 적용된 꼴인 Just (f x)를 반환한다.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>우리가 <code class=\"language-text\">Maybe</code> 타입 생성자와 <code class=\"language-text\">fmap</code> 함수가 펑터를 형성한다는 것을 보이기 위해서는 <code class=\"language-text\">fmap</code> 함수가 항등과 합성의 개념을 보존한다는 것을 증명해야한다. 이러한 것들을 “펑터 법칙(The Functor Laws)”이라는 거창한 이름으로 부르긴 하지만 사실은 그저 펑터가 카테고리의 구조를 보존한다는 것을 보장해야한다는 의미이다.</p>\n<h3 id=\"712-방정식-추론equational-reasoning\" style=\"position:relative;\">7.1.2 방정식 추론(Equational Reasoning)<a href=\"#712-%EB%B0%A9%EC%A0%95%EC%8B%9D-%EC%B6%94%EB%A1%A0equational-reasoning\" aria-label=\"712 방정식 추론equational reasoning permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>펑터 법칙을 증명하기 위해 방정식 추론(Equational Reasoning)을 사용해보려고 한다. 이는 Haskell에서 흔하게 사용되는 증명 기법인데, Haskell 함수가 좌변이 우변과 같다는 동등성(Equality)으로 정의된다는 사실을 이용하는 기법이다. 어떤 코드를 동작이 동일한 다른 코드로 대체할 수도 있고 변수명의 충돌을 피하기 위해 변수명을 변경할 수도 있는데, 이는 함수를 인라인화하는 행위나 반대로 표현식을 함수로 리팩토링하는 행위로 생각할 수도 있다. 한번 항등함수를 예시로 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">id</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이러한 함수가 존재한다면 이제 우리는 어떤 표현식에서 <code class=\"language-text\">id y</code>를 보았을 때, 이 코드를 <code class=\"language-text\">y</code>로 바꿔볼 수 있다(인라인화). 더 나아가서 <code class=\"language-text\">id (y + 2)</code>와 같이 <code class=\"language-text\">id</code>가 표현식에 적용되어있다면 이를 표현식 그 자체인 <code class=\"language-text\">(y + 2)</code>로 바꿀 수도 있다. 또한 이 치환은 양방향으로 적용되기 때문에 표현식 <code class=\"language-text\">e</code>를 <code class=\"language-text\">id e</code>로 치환할 수도 있다.(리팩토링)</p>\n<p>함수가 패턴 매칭에 의해 정의된 경우, 각각의 하위 정의를 독립적으로 사용할 수도 있다. 예를 들어 위의 <code class=\"language-text\">fmap</code> 정의에서 <code class=\"language-text\">fmap f Nothing</code>을 <code class=\"language-text\">Nothing</code>으로 바꿀 수 있으며, 반대로도 가능하다. 이제 이 개념이 실제로 어떻게 작동하는지를 살펴보자. 먼저 항등 보존을 살펴보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token builtin\">id</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">id</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 <code class=\"language-text\">Nothing</code>과 <code class=\"language-text\">Just</code>라는 두 가지 케이스를 고려해야한다. 먼저 첫 번째 경우를 살펴보겠다. 왼쪽의 항을 오른쪽 항으로 변환하기 위해 Haskell 문법의 Pseudo Code를 사용하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">  <span class=\"token builtin\">fmap</span> <span class=\"token builtin\">id</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Nothing</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">id</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n<span class=\"token builtin\">id</span> <span class=\"token constant\">Nothing</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>가장 마지막 단계에서는 <code class=\"language-text\">id</code>의 정의를 활용하여 표현식 <code class=\"language-text\">Nothing</code>을 <code class=\"language-text\">id Nothing</code>으로 대체했다. 실제로는 양 끝에서 촛불을 태우는 방식과 유사하게 이러한 증명을 수행해나가며, 중간에서 동일한 표현식을 만날 때까지 진행하게 된다. 위 케이스에서는 세 번째 라인의 <code class=\"language-text\">Nothing</code>이 이에 해당한다.</p>\n<p>두 번째 경우도 어렵지 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">  <span class=\"token builtin\">fmap</span> <span class=\"token builtin\">id</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">id</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">id</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">id</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">id</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 항등 보존에 대한 증명이 끝났으니, <code class=\"language-text\">fmap</code>이 합성을 보존한다는 것도 표현해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>첫 번째 <code class=\"language-text\">Nothing</code>의 케이스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">  <span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Nothing</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token constant\">Nothing</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 두 번째 케이스인 <code class=\"language-text\">Just</code>에 대해서는 이렇게 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\">  <span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> 합성의 결합법칙에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">fmap</span>의 정의에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> 합성의 결합법칙에 의하면 <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>이러한 추론 방식이 조금 어색하게 느껴지는 독자 분들도 계실텐데, 사실 위 예시에 작성된 모든 코드들은 모두 같은 동작을 하는 코드이다.</p>\n<p>방정식 추론이라는 말이 어려워보여서 그렇지 결국은 <code class=\"language-text\">x</code>, <code class=\"language-text\">x + 0</code>이 동형(Isomorphic)임을 밝혀나가는 노가다와 유사하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">addZero</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> identify <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> v<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">   <span class=\"token function\">identify</span><span class=\"token punctuation\">(</span><span class=\"token function\">addZero</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> identify의 정의에 의하면 <span class=\"token punctuation\">}</span>\n   <span class=\"token function\">addZero</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> addZero의 정의에 의하면 <span class=\"token punctuation\">}</span>\n   x\n<span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> identify의 정의에 의하면 <span class=\"token punctuation\">}</span>\n   <span class=\"token function\">identify</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>함수가 참조 투명성을 보장하는 이상 함수를 함수의 본문으로 치환이 가능하기 때문에 이렇게 노가다로 정합성을 확인해나가는 행위가 가능한 것이다.</p>\n</blockquote>\n<p>이와 같은 방정식 추론을 사용할 때는 이 추론 방법이 사이드 이펙트를 가진 C++ 스타일의 함수에 대해서는 동작하지 않는다는 점을 잘 알아야 한다. 아래 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">square</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> x <span class=\"token operator\">*</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> c<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">double</span> y <span class=\"token operator\">=</span> <span class=\"token function\">square</span><span class=\"token punctuation\">(</span><span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>방정식 추론을 사용하면 <code class=\"language-text\">square</code>를 인라인화하여 아래와 같은 정의를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">double</span> y <span class=\"token operator\">=</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이는 확실히 유효한 변환이 아니며 매번 동일한 결과를 생성하지도 않을 것이다. 그럼에도 불구하고 매크로를 통해 <code class=\"language-text\">square</code>를 구현한 경우 C++ 컴파일러는 방정식 추론을 시도할 것이고, 그 결과는 참혹할 것이다.</p>\n<h3 id=\"713-optional\" style=\"position:relative;\">7.1.3 Optional<a href=\"#713-optional\" aria-label=\"713 optional permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>물론 Haskell을 사용하여 펑터를 쉽게 정의할 수 있기는 하지만, 사실 꼭 Haskell이 아니더라도 제네릭 프로그래밍과 고차함수를 지원하는 어떤 언어든 펑터를 정의할 수 있다. C++의 Maybe에 해당하는 템플릿 타입 <code class=\"language-text\">optional</code>을 생각해보자. 아래는 <code class=\"language-text\">optional</code> 구현에 대한 스케치이다. (실제 구현은 인수가 전달될 수 있는 여러가지 방법, Deep Copy/Shallow Copy와 같은 Copy Semantics, C++ 특유의 자원 관리 문제 등 을 고려해야하기 때문에 훨씬 더 복잡하다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">optional</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">bool</span> _isValid<span class=\"token punctuation\">;</span> <span class=\"token comment\">// the tag</span>\n\t\tT _v<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">optional</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">:</span> <span class=\"token function\">_isValid</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>        <span class=\"token comment\">// Nothing</span>\n    <span class=\"token function\">optional</span><span class=\"token punctuation\">(</span>T x<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_isValid</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">,</span> <span class=\"token function\">_v</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// Just</span>\n    <span class=\"token keyword\">bool</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> _isValid<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    T <span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> _v<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 템플릿은 타입 <code class=\"language-text\">T</code>를 새로운 타입 <code class=\"language-text\">optional&lt;T></code>로 매핑하여 펑터의 정의 중 하나인 타입에 대한 매핑을 제공한다. 이제 함수에 대한 동작을 정의해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nstd<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">optional</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>optional<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span>\n<span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>f<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>optional<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> opt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t\t\t\t\t<span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">else</span>\n\t\t\t\t\t\t<span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이것은 함수를 인자로 받고 다시 함수를 반환하는 고차함수이다. 커링되지 않는 버전은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\noptional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> optional<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> opt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이외에 <code class=\"language-text\">fmap</code>을 <code class=\"language-text\">optional</code>의 템플릿 메서드로 만드는 선택지도 있다. 이처럼 다양한 선택지들은 C++에서 펑터 패턴을 추상화하는 난이도를 더 높히는 주범이다. 펑터를 상속할 수 있는 인터페이스로 정의해야할까? 펑터는 커링된 함수인가 아니면 커링되지 않은 프리 템플릿 함수인가? C++ 컴퍼일러는 누락된 타입을 올바르게 추론할 수 있을까, 아니면 우리가 직접 명시적으로 지정해줘야 하는걸까?</p>\n<p>한번 입력 함수 <code class=\"language-text\">f</code>가 <code class=\"language-text\">int</code>를 받아 <code class=\"language-text\">bool</code>을 반환한다고 생각해보자. 이 경우에 컴파일러는 <code class=\"language-text\">g</code>의 타입을 어떻게 결정할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> g <span class=\"token operator\">=</span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>특히 <code class=\"language-text\">fmap</code>을 오버로딩하는 여러 가지 펑터가 있는 경우에는 어떻게 될까? (곧 우리는 더 많은 펑터들을 만나게 될 것이다)</p>\n<h3 id=\"714-타입-클래스typeclasses\" style=\"position:relative;\">7.1.4 타입 클래스(Typeclasses)<a href=\"#714-%ED%83%80%EC%9E%85-%ED%81%B4%EB%9E%98%EC%8A%A4typeclasses\" aria-label=\"714 타입 클래스typeclasses permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그렇다면 Haskell이 펑터를 추상화하는 방법은 무엇일까? 이를 위해서 Haskell은 타입 클래스 매커니즘을 사용한다. 타입 클래스는 공통 인터페이스를 지원하는 타입의 집합을 정의한다. 예를 들어, 동등성을 지원하는 객체들의 클래스는 아래와 같이 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Eq</span> <span class=\"token hvariable\">a</span> <span class=\"token keyword\">where</span>\n    <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 정의는 타입 <code class=\"language-text\">a</code>가 <code class=\"language-text\">Eq</code> 클래스의 멤버인 경우, 타입 <code class=\"language-text\">a</code>가 두 인자를 받아 <code class=\"language-text\">Bool</code>을 반환하는 <code class=\"language-text\">==</code> 연산자를 지원한다는 것을 나타낸다.</p>\n<p>만약 Haskell에게 특정 타입이 <code class=\"language-text\">Eq</code> 타입 클래스의 인스턴스라는 것을 알려주고 싶다면, 먼저 이 클래스의 인스턴스로 선언하고 <code class=\"language-text\">==</code>의 구현을 제공해줘야 한다. 예를 들어 두 개의 <code class=\"language-text\">Float</code>로 이루어진 곱 타입인 2D Point 타입의 정의가 주어졌다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Point</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Pt</span> <span class=\"token constant\">Float</span> <span class=\"token constant\">Float</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 각 점의 동등성을 이렇게 정의해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Eq</span> <span class=\"token constant\">Point</span> <span class=\"token keyword\">where</span>\n\t\t<span class=\"token punctuation\">(</span><span class=\"token constant\">Pt</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Pt</span> <span class=\"token hvariable\">x'</span> <span class=\"token hvariable\">y'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">x'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">y'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>여기서는 두 개의 패턴 <code class=\"language-text\">(Pt x y)</code>와 <code class=\"language-text\">(Pt x’ y’)</code>에게 중위 연산자 <code class=\"language-text\">==</code>를 사용해보았다. 함수의 본문은 단일 등호를 보면 이해가 쉽다. 이처럼 <code class=\"language-text\">Point</code>가 <code class=\"language-text\">Eq</code>의 인스턴스로 선언된다면 이제 직접적으로 연산자를 통해 각 점의 동등성을 비교할 수 있다.</p>\n<p>Haskell에서는 C++이나 Java와는 다르게 <code class=\"language-text\">Point</code>를 정의할 때, 이 타입이 직접 <code class=\"language-text\">Eq</code>클래스의 멤버라는 것을 명시할 필요는 없으며, 이는 추후 사용자가 직접 작성하는 클라이언트 코드에서 작성할 수 있다. 이러한 타입 클래스는 Haskell에서 함수나 연산자를 오버로딩할 수 있는 유일한 방법이다.</p>\n<p>다양한 펑터들에서 fmap의 동작을 오버로딩하여 활용하기 위해서는 이와 같은 타입 클래스 기법이 필요하다. 그러나 한 가지 복잡한 점이 있다. 펑터는 타입으로 정의되는 것이 아니라 타입들의 매핑인 타입 생성자로 정의된다. 즉, 펑터를 제대로 정의하기 위해서는 <code class=\"language-text\">Eq</code>의 경우처럼 타입들의 집합이 아닌 타입 생성자들의 집합으로 정의된 타입 클래스가 필요하다는 것이다. 다행히도 Haskell의 타입 클래스는 타입 뿐만 아니라 타입 생성자 또한 잘 지원해준다. 그럼 이제 <code class=\"language-text\">Functor</code> 클래스를 한번 정의해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Functor</span> <span class=\"token hvariable\">f</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 코드는 <code class=\"language-text\">f</code>가 <code class=\"language-text\">Functor</code>인 경우, 지정된 타입 시그니처를 가진 함수 <code class=\"language-text\">fmap</code>을 가지고 있다는 사실을 명시하고 있다. 여기서 소문자 <code class=\"language-text\">f</code>는 타입 변수이며, 타입 변수 <code class=\"language-text\">fmap</code>이 받고 있는 <code class=\"language-text\">a</code>나 <code class=\"language-text\">b</code>와 동일한 개념이다.</p>\n<p>컴파일러는 <code class=\"language-text\">f a</code>나 <code class=\"language-text\">f b</code>와 같이 이 타입 변수가 다른 타입을 처리하고 있다는 사실을 참고하여 <code class=\"language-text\">f</code>가 타입이 아닌 타입 생성자라는 사실을 추론할 수 있다. 따라서 <code class=\"language-text\">Functor</code>의 인스턴스를 선언할 때는 <code class=\"language-text\">Maybe</code>와 같은 타입 생성자를 지정해줘야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Maybe</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">_</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>사실 우리가 정의한 <code class=\"language-text\">Functor</code> 클래스, 그리고 <code class=\"language-text\">Maybe</code>와 같이 간단한 데이터 타입에 대한 인스턴스 정의들은 이미 표준 Prelude에 포함되어있다.</p>\n<h3 id=\"715-c에서의-펑터functor-in-c\" style=\"position:relative;\">7.1.5 C++에서의 펑터(Functor in C++)<a href=\"#715-c%EC%97%90%EC%84%9C%EC%9D%98-%ED%8E%91%ED%84%B0functor-in-c\" aria-label=\"715 c에서의 펑터functor in c permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그렇다면 C++에서도 이와 동일한 접근 방식을 시도해볼 수 있을까? 타입 생성자는 <code class=\"language-text\">optional</code>과 같은 템플릿 클래스에 해당하므로, <code class=\"language-text\">fmap</code>을 템플릿 템플릿 매개변수 <code class=\"language-text\">F</code>로 매개화해볼 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span><span class=\"token operator\">></span> F<span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nF<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> F<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이제 이 템플릿을 다른 펑터들에 대해서 특수화(Specialize)하면 좋을 것 같다. 하지만 슬프게도 C++에서는 템플릿 함수의 부분 특수화를 금지하고 있기 때문에 아래처럼 작성할 수가 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\noptional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>optional<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> optional<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> opt<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>대신 우리는 함수 오버로딩을 사용할 것이다. 이렇게 되면 우리는 다시 커링되지 않은 펑터의 원래 정의로 돌아가게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\noptional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> optional<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> opt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> optional<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>opt<span class=\"token punctuation\">.</span><span class=\"token function\">val</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 <code class=\"language-text\">fmap</code>의 두 번째 인자가 오버로드를 선택하기 때문에 이 정의 자체가 작동하기는 하지만, 이러한 방법은 <code class=\"language-text\">fmap</code>의 일반적인 정의에서는 많이 벗어나있다.</p>\n<h3 id=\"716-list-펑터\" style=\"position:relative;\">7.1.6 List 펑터<a href=\"#716-list-%ED%8E%91%ED%84%B0\" aria-label=\"716 list 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>프로그래밍에서 펑터가 어떤 역할을 하는지에 대해 감을 잡기 위해서는 조금 더 많은 예제를 살펴봐야할 것 같다. 다른 타입으로 매개화된 어떤 타입이든 모두 펑터의 후보라고 볼 수 있다. 제네릭 컨테니어는 저장된 요소의 타입에 의해 매개화되므로, 매우 간단한 컨테이너인 <code class=\"language-text\">List</code>를 한번 살펴보자.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>제네릭 컨테이너는 여러 타입의 데이터를 저장할 수 있는 데이터 컨테이너이다. 즉, 타입 파라미터를 받음으로써 동일한 구조를 유지하면서도 서로 다른 유형의 데이터를 저장할 수 있는 것이다. TypeScript에서는 <code class=\"language-text\">Array&lt;T></code>와 같은 타입이 일종의 제네릭 컨테이너라고 볼 수 있다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Cons</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기 <code class=\"language-text\">List</code>라는 타입 생성자가 있다. 이 타입 생성자는 임의의 타입 <code class=\"language-text\">a</code>를 타입 <code class=\"language-text\">List a</code>로 매핑한다. 이때 <code class=\"language-text\">List</code>가 펑터라는 것을 보이기 위해서는 함수 <code class=\"language-text\">a → b</code>가 주어졌을 때 함수 <code class=\"language-text\">List a → List b</code>로 나아가는 리프팅 함수를 정의해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">List</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">List a</code>에 작용하는 함수는 두 리스트 생성자인 <code class=\"language-text\">Nil</code>과 <code class=\"language-text\">Cons</code> 두 가지 경우를 고려해야한다. <code class=\"language-text\">Nil</code>의 경우에는 어차피 빈 리스트에 대해서 할 수 있는게 없으니, 그냥 <code class=\"language-text\">Nil</code>을 반환해주면 되므로 간단하게 처리가 가능하다.</p>\n<p>그러나 <code class=\"language-text\">Cons</code> 케이스의 경우에는 약간 까다롭다. 왜냐하면 재귀를 포함해야하기 때문이다. 일단 잠시 생각을 멈추고 우리가 정확히 어떤 것을 하려고 하는 것인지 다시 살펴보자. <code class=\"language-text\">fmap</code>의 인자로 <code class=\"language-text\">a</code>의 리스트, 그리고 <code class=\"language-text\">a</code>를 <code class=\"language-text\">b</code>로 변환하는 함수 <code class=\"language-text\">f</code>가 주어졌고, 이제 이것들을 가지고 <code class=\"language-text\">b</code>의 리스트를 생성해야한다.</p>\n<p>리스트의 각 요소를 <code class=\"language-text\">a</code>에서 <code class=\"language-text\">b</code>로 변환하는 것은 당연하게도 <code class=\"language-text\">f</code>를 사용하면 된다. 다만 비어있지 않은 리스트는 하나의 원소가 아닌 <code class=\"language-text\">Cons</code>로 표현되는 헤드(Head)와 나머지 꼬리(Tail)로 구성될텐데, 어떻게 모든 원소에 <code class=\"language-text\">f</code>를 적용해야 하는걸까?</p>\n<p>우리는 <code class=\"language-text\">f</code>를 헤드에 먼저 적용하고, 리프팅한(<code class=\"language-text\">fmap</code>한) <code class=\"language-text\">f</code>를 나머지 꼬리에 적용할 것이다. 이는 리프팅된 <code class=\"language-text\">f</code>를 또 다시 리프팅한 <code class=\"language-text\">f</code>로 정의하고 있기 때문에 재귀적인 정의가 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Cons</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Cons</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>Haksell에 익숙하지 않은 독자들을 위해 조금 더 읽기 쉬운 변수명으로 바꿔보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> 원소에적용할<span class=\"token hvariable\">fn</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Cons</span> 헤드원소 나머지테일<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Cons</span> <span class=\"token punctuation\">(</span>원소에적용할<span class=\"token hvariable\">fn</span> 헤드원소<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> 원소에적용할<span class=\"token hvariable\">fn</span> 나머지테일<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이를 TypeScript로 다시 작성해보자면 대략 이런 느낌이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// List 펑터 인터페이스</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">List<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">fn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Cons<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">List<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">public</span> head<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">public</span> tail<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token generic-function\"><span class=\"token function\">fmap</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">fn</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 헤드에 fn를 적용해서 T를 U로 변경</span>\n    <span class=\"token comment\">// 이후 꼬리(List)가 가진 fmap을 호출하여 같은 행위를 재귀적으로 반복한다.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Cons<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span></span><span class=\"token punctuation\">(</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">.</span><span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Haksell은 <code class=\"language-text\">Cons (f x)</code>나 <code class=\"language-text\">(fmap f t)</code>와 같은 패턴매칭을 통해 헤드에 적용할 동작과 꼬리에 적용할 동작을 구분하지만, TypeScript는 그런 패러다임을 가진 언어가 아니기 때문에 직접 <code class=\"language-text\">this</code>를 통해 원하는 동작을 호출하고 있다.</p>\n</blockquote>\n<p>우항의 <code class=\"language-text\">fmap f</code> 구문은 정의하려는 리스트보다 더 짧은 리스트, 즉, 꼬리에 적용된다. 결국 점점 더 짧은 리스트로 재귀하다가 결국 최종적으로는 빈 리스트인 <code class=\"language-text\">Nil</code>에 도달하게 될 것이다.</p>\n<p>앞서 정의한대로 <code class=\"language-text\">fmap f</code>가 <code class=\"language-text\">Nil</code>에 적용되면 재귀가 종료된다. 최종 결과를 얻으려면 새로운 헤드 <code class=\"language-text\">(f x)</code>와 새로운 꼬리 <code class=\"language-text\">(fmap f t)</code>를 <code class=\"language-text\">Cons</code> 생성자를 통해 결합한다. 지금까지 이야기한 모든 내용을 하나로 합쳐보면 아래와 같이 List 펑터의 인스턴스 선언이 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">List</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">_</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nil</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Cons</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Cons</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>만약 여러분이 C++에 익숙하다면, 일반적인 C++ 컨테이너인 <code class=\"language-text\">std::vector</code>를 한번 생각해보면 된다. <code class=\"language-text\">std::vector</code>에 대한 <code class=\"language-text\">fmap</code>의 구현은 단순히 <code class=\"language-text\">std::transform</code>의 얇은 캡슐화에 불과하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nstd<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span> w<span class=\"token punctuation\">;</span>\n    std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">transform</span><span class=\"token punctuation\">(</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">back_inserter</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span>\n                  <span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> w<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이를 사용하면 숫자 시퀀스인 원소를 제곱하는 등의 행위가 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> v<span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> w <span class=\"token operator\">=</span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> i<span class=\"token operator\">*</span>i<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">copy</span><span class=\"token punctuation\">(</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span>\n\t\t\t\t\t<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span>\n\t\t\t\t\t<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">ostream_iterator</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>cout<span class=\"token punctuation\">,</span> <span class=\"token string\">\", \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>대부분의 C++ 컨테이너는 <code class=\"language-text\">std::transform</code>에 전달할 수 있는 이터레이터를 구현함으로써 펑터가 되며, 이는 <code class=\"language-text\">fmap</code>의 원시적인 버전과도 같다. 그러나 안타깝게도 이터레이터와 임시 개체(Temporaries)의 혼란스러움으로 인해 펑터의 단순함이 상당 부분 사라져버린다(위의 <code class=\"language-text\">fmap</code> 구현을 참조해보자). 하지만 새롭게 제안된 <a href=\"https://learn.microsoft.com/ko-kr/cpp/standard-library/ranges?view=msvc-170\" target=\"_blank\" rel=\"nofollow\">range</a> 라이브러리는 특정한 범위 내에서 펑터적인 성질을 더 명확하게 표현해주고 있다.</p>\n<h3 id=\"717-reader-펑터\" style=\"position:relative;\">7.1.7 Reader 펑터<a href=\"#717-reader-%ED%8E%91%ED%84%B0\" aria-label=\"717 reader 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>여기까지 봤다면 이제 펑터가 어떤 컨테이너의 한 종류인 것 같다는 생각을 가지게 되었을 것이라 생각한다. 그렇다면 이제는 그 생각을 깨버리기 위해 지금까지와 매우 다른 것처럼 보이는 예제를 보여주려고 한다. 타입 <code class=\"language-text\">a</code>를 <code class=\"language-text\">a</code>를 반환하는 함수로 매핑하는 상황을 생각해보자.</p>\n<p>아직 함수 타입에 대한 깊이 있는 이야기를 나누지는 않았지만, 사실 프로그래머라면 함수에 대한 기본적인 이해 정도는 가지고 있다. Haskell에서 함수 타입은 두 개의 타입과 화살표 타입 생성자(<code class=\"language-text\">-></code>)를 사용하여 구성된다. 이 생성자는 인수 타입, 그리고 결과 타입이라는 두 가지 타입 사이의 중위 표현으로 등장한다. 기본적으로는 <code class=\"language-text\">a -> b</code>의 형태이지만 괄호를 사용하면 전위 표현으로도 사용이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>정규 함수와 마찬가지로 하나 이상의 인수를 가진 타입 함수는 부분적용이 가능하다. 따라서 아래 예시와 같이 화살표에 하나의 타입 인수만 제공한다면 결과 타입을 의미하는 다른 인수가 들어오는 것을 기다릴 수 있다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이것이 바로 위 표현이 타입 생성자인 이유이다. <code class=\"language-text\">a -> b</code> 를 완전한 타입으로 만들기 위해서는 타입 <code class=\"language-text\">b</code>까지 제공되어야 하기 때문이다. 즉, 위 예시는 타입 <code class=\"language-text\">a</code>를 매개변수로 사용하는 타입 생성자 집합을 정의하고 있다고 볼 수 있다.</p>\n<p>그렇다면 이제 이 케이스가 펑터가 맞는지 살펴보도록 하자. 두 개의 타입 매개변수를 다루는 것은 어려울 수 있으니 이름을 조금 변경해보겠다. 이전에 정의했던 펑터의 정의와 일치하도록 인수의 타입을 <code class=\"language-text\">r</code>로, 결과 타입을 <code class=\"language-text\">a</code>로 지정해보겠다.</p>\n<p>즉, 이 타입 생성자는 임의의 타입 <code class=\"language-text\">a</code>를 <code class=\"language-text\">r -> a</code> 타입으로 매핑하는 녀석이다. 이것이 펑터가 되려면 함수 <code class=\"language-text\">a -> b</code>, 함수 <code class=\"language-text\">r -> a</code>를 인자로 받고 함수 <code class=\"language-text\">r -> b</code>를 반환하는 함수로 리프팅해야 한다. 이들은 각각 타입 생성자(<code class=\"language-text\">-></code>) <code class=\"language-text\">r</code>이 작용하는 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>를 사용하여 형성된 타입이다.</p>\n<p>이제 이 케이스를 표현할 수 있는 <code class=\"language-text\">fmap</code>의 정의를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">r</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">r</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 함수 <code class=\"language-text\">f::a -> b</code>와 함수 <code class=\"language-text\">g::r -> a</code>가 주어졌을 때 함수 <code class=\"language-text\">r -> b</code>를 생성해야하는 퍼즐을 풀어야 한다. 두 함수를 합성할 수 있는 방법은 오직 하나 뿐이며, 결과 또한 우리가 원하는 방향과 정확히 일치한다. 따라서 <code class=\"language-text\">fmap</code>의 구현은 아래와 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">g</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p><code class=\"language-text\">g::r → a</code>, <code class=\"language-text\">f::a → b</code>가 합성됨으로써 <code class=\"language-text\">r → a → b</code>, 즉 <code class=\"language-text\">r → b</code>가 성립된다.</p>\n</blockquote>\n<p>굉장히 간결하지만 우리가 원하는 동작은 정확히 구현되었다. 만약 더 간결한 표기를 선호한다면, 함수 합성에 대한 표현을 전위 표기법으로 바꿔볼 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">g</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 인수를 생략해서 <code class=\"language-text\">fmap</code>과 함수 합성을 의미하는 <code class=\"language-text\">.</code> 연산자, 두 함수의 직접적인 동등성을 표현할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이처럼 <code class=\"language-text\">(->) r</code> 타입 생성자와 <code class=\"language-text\">fmap</code> 구현의 결합을 Reader 펑터라고 한다.</p>\n<h2 id=\"72-컨테이너로써의-펑터\" style=\"position:relative;\">7.2 컨테이너로써의 펑터<a href=\"#72-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%A1%9C%EC%8D%A8%EC%9D%98-%ED%8E%91%ED%84%B0\" aria-label=\"72 컨테이너로써의 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 프로그래밍 언어에서 일반적인 용도의 컨테이너를 정의하는 펑터의 몇 가지 예시를 살펴보았다.</p>\n<p>우리는 보통 함수를 일종의 데이터라고 생각하지않기 때문에 Reader 펑터같은 녀석들이 조금 어색해보이기도 한다. 그러나 순수함수는 메모이제이션될 수 있으며 함수의 실행은 일종의 테이블 조회 행위로 변환될 수도 있다. 그리고 테이블은 데이터이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>함수의 실행을 일종의 테이블 조회 행위로 변환할 수 있다는 말은 어떤 함수가 순수하고 불변적이며 입력에 따라 항상 같은 출력을 반환한다는 가정을 전제로 하는 설명이다.</p>\n<p>위와 같은 전제가 지켜진다면 함수의 실행 결과를 테이블에 저장하고 함수의 입력 값을 키로 사용하여 함수의 실행 결과를 “검색”할 수 있다.</p>\n<p>이러한 메모이제이션에 사용되는 자료구조가 꼭 테이블이어야만 하는 것은 아니지만, 작가는 순수한 함수의 이러한 특성으로 인해 순수함수의 실행이 일종의 데이터 조회 행위가 될 수 있다는 사실을 강조하고 있는 것이다.</p>\n</blockquote>\n<p>반대로 Haskell의 게으른 평가(지연평가) 때문에 전통적인 컨테이너인 리스트는 함수로 구현될 수도 있다. 예를 들어 자연수의 무한한 리스트는 아래와 같이 간결하게 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">nats</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Integer</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">nats</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>첫 번째 라인의 대괄호 쌍은 Haskell의 리스트에 대한 내장 타입 생성자이다. 두 번째 라인의 대괄호는 리스트 리터럴을 만드는 데 사용된다.</p>\n<p>당연하겠지만 이런 방식의 무한 리스트는 메모리에 저장할 수 없다. 그래서 필요할 때마다 <code class=\"language-text\">Integer</code>를 생성하는 함수로 이러한 동작을 구현하는 것이다. Haskell은 사실상 데이터와 코드 사이의 구분을 명확하게 하지 않는다. 리스트는 함수로 간주될 수도 있고, 함수는 인수를 결과에 매핑하는 테이블로 간주될 수도 있다. 특히 후자는 함수의 정의역이 유한하고 크기가 크지 않은 경우에는 꽤나 실용적인 개념이다.</p>\n<p>그러나 <code class=\"language-text\">strlen</code>을 테이블 조회로 구현하는 것은 현실적이지 않다. 왜냐하면 무한히 많은 서로 다른 문자열들이 존재하기 때문이다. 프로그래머로써 우리는 무한을 좋아하지 않겠지만, 카테고리 이론에서는 무한을 아침식사처럼 즐기는 방법을 배워볼 수 있다. 모든 문자열의 집합이나 우주의 과거, 현재, 미래의 상태 같이 무한한 것들도 다뤄볼 수 있다는 말이다.</p>\n<p>그래서 필자는 펑터 객체(엔도펑터에 의해 생성된 타입의 객체)를 어떤 타입을 가진 값 또는 값들을 추상적으로 가지고 있는 무언가로 생각하는 것을 추천한다. 물리적으로 그 값을 가지고 있지는 않지만 말이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>여기서 작가가 펑터가 특정 타입의 값을 직접 가지고 있는 것이 아니라 추상적으로 가지고 있다고 표현하는 의미는 다음과 같다. TypeScript의 Array를 예로 들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> numbers<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 숫자 타입의 배열</span>\n<span class=\"token keyword\">const</span> doubledNumbers <span class=\"token operator\">=</span> numbers<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [2, 4, 6]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">number[]</code> 타입의 배열은 사실 “모든 숫자를 가진 배열”으로 정의되었다고 봐야 한다. 하지만 현재 이 배열이 실제로 모든 숫자를 가지고 있는 것은 아니며, 단지 <code class=\"language-text\">map</code>과 같은 메소드를 사용하여 배열 내부의 값들을 간접적으로 다룰 수 있는 방법만을 제공하고 있다.</p>\n<p>이러한 방법들을 통해 이 배열은 이론상 모든 숫자를 가질 수 있겠지만, 실제로 이 배열이 모든 숫자를 가지고 있는 것은 아니기에 “추상적으로 가지고 있다”라는 표현을 사용한 것이다.</p>\n</blockquote>\n<p>C++에서의 예시를 보자면 <code class=\"language-text\">std::future</code>가 있다. 언젠가는 값을 가지게 될테지만 반드시 그렇다는 보장은 없으며, Future 내부의 값에 접근하려면 다른 스레드의 실행이 완료될 때까지 기다려야할 수도 있다.</p>\n<p>또 다른 예시로는 Haskell의 <code class=\"language-text\">IO</code> 객체가 있다. 이 객체는 사용자의 입력을 받거나 “Hello World!”가 모니터에 표시된 우주의 상태를 포함할 수도 있다.</p>\n<p>이러한 해석들에 따르면 펑터 객체는 매개변수화된 타입의 값을 포함하거나 그런 값을 생성하는 방법을 포함하고 있는 무언가로 바라볼 수 있다. 펑터 내부의 값에 접근하는 동작은 완전히 선택사항이며 펑터의 범위에 꼭 포함되어야 하는 동작도 아니다. 우리가 관심을 가져야하는 부분은 함수를 사용해서 그 값을 조작할 수 있다는 것 뿐이다.</p>\n<p>만약 그 값에 접근할 수 있다면 그 조작에 대한 결과를 볼 수 있어야 한다. 그러나 접근할 수 없다면 우리가 오직 신경써야하는 것은 그 조작들이 올바르게 합성되었는지, 그리고 항등 함수를 통한 조작은 아무것도 바꾸지 않는다는 사실 뿐이다. 펑터 객체 내부의 값에 접근하는 것이 그렇게 중요한 일이 아니라는 것을 보여주기 위해 한 가지 예시를 보여주겠다. 여기 인자 <code class=\"language-text\">a</code>를 완전히 무시하는 타입 생성자가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Const</code> 타입 생성자는 <code class=\"language-text\">c</code>와 <code class=\"language-text\">a</code> 두 개의 타입을 받는다. 화살표 생성자 때와 마찬가지로 이를 부분적으로 적용해서 펑터를 만들어볼 것이다. <code class=\"language-text\">Const</code>라고 하는 데이터 생성자는 <code class=\"language-text\">c</code> 타입의 값 하나만을 취하며, 이는 <code class=\"language-text\">a</code>에 대한 의존성이 없다는 것을 의미한다. 이 타입 생성자에 대한 <code class=\"language-text\">fmap</code>의 타입 정의는 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>펑터가 타입 인수를 무시하고 있기 때문에, <code class=\"language-text\">fmap</code>의 구현에서도 함수 인수를 무시할 수 있다. 함수에 적용할 대상 자체가 없기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">_</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Const</span> <span class=\"token hvariable\">v</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Const</span> <span class=\"token hvariable\">v</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>오히려 이런 부분은 컴파일 시간에 발생하는 타입 인자와 런타임에 발생하는 값 사이의 더 강한 구분이 있는 C++에서 더 명확하게 나타날 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">Const</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">Const</span><span class=\"token punctuation\">(</span>C v<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_v</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\t\tC _v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>C++으로 구현된 <code class=\"language-text\">fmap</code> 또한 함수의 인자를 무시하고 <code class=\"language-text\">Const</code> 인자를 본래 값과 함께 다시 캐스팅하는 역할을 수행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span>\nConst<span class=\"token operator\">&lt;</span>C<span class=\"token punctuation\">,</span> B<span class=\"token operator\">></span> <span class=\"token function\">fmap</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>function<span class=\"token operator\">&lt;</span><span class=\"token function\">B</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> f<span class=\"token punctuation\">,</span> Const<span class=\"token operator\">&lt;</span>C<span class=\"token punctuation\">,</span> A<span class=\"token operator\">></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Const<span class=\"token operator\">&lt;</span>C<span class=\"token punctuation\">,</span> B<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>c<span class=\"token punctuation\">.</span>_v<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>당장 이해하기는 어려울 수 있지만 사실 <code class=\"language-text\">Const</code> 펑터는 많은 구조들에서 굉장히 중요한 역할을 담당한다. 카테고리 이론에서 <code class=\"language-text\">Const</code> 펑터는 앞서 언급했던 블랙홀의 엔도펑터, 즉, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span><span class=\"mord mathnormal\">c</span></span></span></span></span> 펑터의 특수한 경우이다. 추후 이러한 개념에 대해서도 더 자세히 다뤄보도록 하겠다.</p>\n<h2 id=\"73-펑터-합성functor-composition\" style=\"position:relative;\">7.3 펑터 합성(Functor Composition)<a href=\"#73-%ED%8E%91%ED%84%B0-%ED%95%A9%EC%84%B1functor-composition\" aria-label=\"73 펑터 합성functor composition permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>펑터가 마치 함수와 같이 합성될 수 있다라는 것은 꽤 직관적인 이해가 가능한 사실이다. 결국 두 펑터의 합성이라는 것은 펑터가 특정 카테고리 내의 객체나 사상에 매핑되는 행위들의 합성이라고 볼 수 있다.</p>\n<p>합성된 두 개의 펑터를 거치더라도 항등 사상은 그대로 항등 사상으로 남게 되며, 사상들의 합성 규칙은 여전히 동일한 규칙을 가지게 된다. 이는 굉장히 단순하고 간단한 규칙이며, 특히 엔도펑터를 합성하는 것은 더더욱 쉽다. 혹시 <code class=\"language-text\">maybeTail</code> 함수를 기억하는가?</p>\n<p>이 함수를 Haskell의 내장 리스트 구현을 사용해서 다시 작성해보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">maybeTail</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">maybeTail</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token hvariable\">maybeTail</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">xs</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>지금까지 <code class=\"language-text\">Nil</code>로 호출하던 빈 리스트 생성자는 빈 대괄호 쌍인 <code class=\"language-text\">[]</code>으로 대체되었고, <code class=\"language-text\">Cons</code> 생성자는 중위 연산자 <code class=\"language-text\">:</code>으로 대체되었다.</p>\n<p><code class=\"language-text\">maybeTail</code>의 결과는 두 펑터 <code class=\"language-text\">Maybe</code>, <code class=\"language-text\">[]</code>가 <code class=\"language-text\">a</code>에 작용하는 형태를 지니고 있다. 만약 여기서 합성된 <code class=\"language-text\">Maybe</code> 리스트의 원소에 어떤 함수 <code class=\"language-text\">f</code>를 적용하려고 한다면 어떻게 접근해야할까?</p>\n<p>함수가 <code class=\"language-text\">Maybe</code> 리스트의 원소에 도달하기 위해서는 <code class=\"language-text\">Maybe</code>와 <code class=\"language-text\">[]</code>라는 두 겹의 펑터를 뚫어야 한다. 가장 먼저 외부의 <code class=\"language-text\">Maybe</code>를 뚫기 위해 <code class=\"language-text\">fmap</code>을 사용할 수 있다. 그러나 함수 <code class=\"language-text\">f</code>는 리스트에 대해서는 작동하지 않기 때문에 이대로 이 함수를 <code class=\"language-text\">Maybe</code>의 안쪽으로 보낼 수는 없다. 우리는 내부 리스트에서 작동할 <code class=\"language-text\">(fmap f)</code>를 보내야 한다. 한번 <code class=\"language-text\">Maybe</code> 리스트의 정수 원소들을 제곱하는 예시를 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">square</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token hvariable\">mis</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">mis</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token hvariable\">mis2</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">square</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">mis</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>먼저 컴파일러는 타입을 분석한 후, 외부의 <code class=\"language-text\">fmap</code>에 대해서는 <code class=\"language-text\">Maybe</code> 인스턴스의 구현을 사용하고, 내부의 <code class=\"language-text\">fmap</code>에 대해서는 리스트 펑터의 구현을 사용해야한다는 것을 추론해낼 것이다. 물론 지금 시점에서 위 코드가 아래와 같은 코드로 다시 작성될 수 있다는 사실이 바로 이해가 되지는 않을 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">mis2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token operator\">.</span> <span class=\"token builtin\">fmap</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">square</span> <span class=\"token hvariable\">mis</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그러나 <code class=\"language-text\">fmap</code>은 하나의 인수에 대한 함수로 간주될 수 있다는 것을 기억해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fmap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 경우 <code class=\"language-text\">(fmap . fmap)</code>안의 두 번째 <code class=\"language-text\">fmap</code>은 다음과 같은 타입의 인수를 취한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">square</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 다음과 같은 타입의 함수를 반환할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이후 첫 번째 <code class=\"language-text\">fmap</code>은 이 함수를 취하고 다음과 같은 타입의 함수를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 비로소 이 함수가 <code class=\"language-text\">mis</code>에 적용된다. 따라서 두 펑터의 합성은 해당 <code class=\"language-text\">fmap</code>들의 합성인 펑터라고 볼 수 있다.</p>\n<p>다시 카테고리 이론으로 돌아가보자. 대상들의 매핑이 결합법칙을 만족하며, 사상들의 매핑도 결합법칙을 만족하니 펑터의 합성 또한 결합법칙을 만족한다는 사실은 명확하다. 그리고 모든 카테고리에는 당연히 항등 펑터 또한 존재한다. 항등 펑터는 모든 대상과 사상이 자기자신에게 매핑되는 펑터이다.</p>\n<p>즉, 펑터는 마치 어떠한 카테고리의 사상들과 동일한 특성을 가지게 된다. 그렇다면 그 카테고리란 무엇일까?</p>\n<p>바로 대상이 카테고리이고, 사상이 펑터인 카테고리이다. 즉, 카테고리들의 카테고리라고 할 수 있다. 그러나 모든 카테고리들의 카테고리 또한 카테고리이니, 자기 자신을 자기 자신 안에 포함해야하는 모순에 빠지게 된다.</p>\n<p>모든 “작은” 카테고리의 카테고리인 <strong>Cat</strong>이라는 개념이 있다. 작은 카테고리는 대상들이 집합을 형성하는 카테고리를 가리키며, 심지어 무한하여 셀 수 없는 집합도 “작은” 카테고리로 간주된다. 필자는 이런 개념들이 다양한 추상화 수준에서 동일한 구조가 반복되는 것을 표현할 수 있다는 것에 매우 놀라웠다. 심지어 나중에는 펑터들이 카테고리를 형성하는 케이스도 보게 될 것이다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240315-category-theory-for-programmers-7-functors","path":"/2024/03/15/category-theory-for-programmers-7-functors/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 7. 펑터","subTitle":null,"date":"Mar 19, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"47605aa1-3714-56bb-adc5-4cb4803954da","tableOfContents":"<ul>\n<li><a href=\"#61-%EA%B3%B1-%ED%83%80%EC%9E%85product-types\">6.1 곱 타입(Product Types)</a></li>\n<li><a href=\"#62-%EB%A0%88%EC%BD%94%EB%93%9Crecords\">6.2 레코드(Records)</a></li>\n<li><a href=\"#63-%ED%95%A9-%ED%83%80%EC%9E%85sum-types\">6.3 합 타입(Sum Types)</a></li>\n<li><a href=\"#64-%ED%83%80%EC%9E%85%EC%9D%98-%EB%8C%80%EC%88%98%ED%95%99\">6.4 타입의 대수학</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"앞서 우리는 곱과 합이라는 두 가지 기본적인 방법을 통해 타입을 결합하는 것을 보았다. 사실 우리가 일상적인 프로그래밍에서 자주 접하는 데이터 구조는 이 두 가지 메커니즘만으로도 충분히 표현할 수 있다. 이처럼 데이터 구조의 많은 속성들을 합성할 수 있다는 사실은 굉장히 중요한 포인트이다. 예를 들어 동등성을 사용하여 기본적인 타입의 값들을 비교하는 방법과 이러한 비교 행위를 곱과 합 타입으로 일반화하는 방법을 알고 있다면, 우리는 자연스럽게 합성 타입에 대한 동등 연산자라는 개념을 유도할 수 있다. Haskell에서는 이렇게 합…","html":"<p>앞서 우리는 곱과 합이라는 두 가지 기본적인 방법을 통해 타입을 결합하는 것을 보았다. 사실 우리가 일상적인 프로그래밍에서 자주 접하는 데이터 구조는 이 두 가지 메커니즘만으로도 충분히 표현할 수 있다.</p>\n<p>이처럼 데이터 구조의 많은 속성들을 합성할 수 있다는 사실은 굉장히 중요한 포인트이다. 예를 들어 동등성을 사용하여 기본적인 타입의 값들을 비교하는 방법과 이러한 비교 행위를 곱과 합 타입으로 일반화하는 방법을 알고 있다면, 우리는 자연스럽게 합성 타입에 대한 동등 연산자라는 개념을 유도할 수 있다. Haskell에서는 이렇게 합성된 타입의 하위 집합에 대해 동등성, 비교, 문자열로의 변환과 같은 연산들을 유도할 수 있다.</p>\n<p>그럼 프로그래밍에서 곱 및 합 타입이 나타나는 방식에 대해서 자세히 살펴보도록 하자.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 409px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/fcf5139ae1c84cc62f66e0f43c59f1ba/e9a96/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.12499999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB0lsLLOMUf//EABoQAAMBAAMAAAAAAAAAAAAAAAECAwAREjH/2gAIAQEAAQUCejKwsRlPKvLuXiG3m//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABoQAAICAwAAAAAAAAAAAAAAAAABEBEhMVH/2gAIAQEABj8C3ZmmJss5H//EABoQAQEBAAMBAAAAAAAAAAAAAAERACExUaH/2gAIAQEAAT8hgQCyB8wZdekzQFfMVTOMmJ1OJ7gBAgb/2gAMAwEAAgADAAAAENgP/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EKF//8QAFhEAAwAAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EIV//8QAHhABAQACAQUBAAAAAAAAAAAAAREAITFBUWGBkfD/2gAIAQEAAT8QcsEhUefb9rIZxuzvshgYALvT7myGQQ63nGIptMi1fOqYZMCAEDP/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/fcf5139ae1c84cc62f66e0f43c59f1ba/e9a96/1.jpg\" srcset=\"/static/fcf5139ae1c84cc62f66e0f43c59f1ba/0913d/1.jpg 160w,\n/static/fcf5139ae1c84cc62f66e0f43c59f1ba/cb69c/1.jpg 320w,\n/static/fcf5139ae1c84cc62f66e0f43c59f1ba/e9a96/1.jpg 409w\" sizes=\"(max-width: 409px) 100vw, 409px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"61-곱-타입product-types\" style=\"position:relative;\">6.1 곱 타입(Product Types)<a href=\"#61-%EA%B3%B1-%ED%83%80%EC%9E%85product-types\" aria-label=\"61 곱 타입product types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>프로그래밍 언어에서 두 타입의 곱의 대표적인 구현은 바로 쌍(Pair)이다. Haskell에서는 쌍이 원시 타입 생성자이며, C++에서는 표준 라이브러리에서 정의된 템플릿이다.</p>\n<p>엄밀히 말해 쌍은 교환 법칙을 따르지 않는다. 어떠한 쌍 <code class=\"language-text\">(Int, Bool)</code>은 <code class=\"language-text\">(Bool, Int)</code>으로 대체될 수 없다는 것이다. 하지만 이 두 타입은 동형성(Isomorphism)을 지니고 있다. 이 동형성은 Swap 함수에 의해 제공되며, Swap 함수는 아래와 같이 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">swap</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">swap</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 두 쌍은 동일한 데이터를 저장하지만 단순히 다른 형식을 사용하고 있는 것이라고 생각할 수 있다. 이는 마치 빅 엔디안(Big Endian) vs 리틀 엔디안(Little Endian)의 관계와도 비슷하다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>엔디안(Endian)은 컴퓨터 메모리에 데이터를 저장하는 방식을 의미한다. 빅 엔디안(Big Endian)은 가장 상위 바이트(Most Significant Byte, MSB)를 가장 낮은 주소에 저장하고, 반대로 리틀 엔디안은 MSB를 가장 높은 주소에 저장한다. 즉, 같은 데이터를 다루더라도 저장하는 방식만 다르다는 것이다.</p>\n<p>이는 <code class=\"language-text\">(Int, Bool)</code>과 <code class=\"language-text\">(Bool, Int)</code> 쌍처럼 같은 타입들의 곱이지만 각 구성 요소의 위치만 다른 상황과도 유사하기에 작가는 이러한 예시를 든 것이다.</p>\n</blockquote>\n<p>만약 임의의 개수인 타입들을 곱으로 결합하려면 그저 쌍을 중첩시키는 것만으로도 표현할 수 있지만 더 쉬운 방법도 있다. 이렇게 중첩된 쌍은 튜플과 동일한데, 이는 쌍을 중첩하는 다양한 방법들이 동형(Isomorphic)이기 때문이다. 세가지 타입 <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code>, <code class=\"language-text\">c</code>를 순서대로 곱으로 결합하려면 아래와 같은 두 가지 방법을 사용해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 또는</span>\n<span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 타입들은 분명히 다른 타입이다. <code class=\"language-text\">((a, b), c)</code> 타입을 받을 수 있는 함수에 <code class=\"language-text\">(a, (b, c))</code> 타입을 전달할 수 없다는 것을 생각해보면 된다. 하지만 이 타입들이 가진 각각의 요소들은 분명 일대일 대응 관계에 놓여있다.</p>\n<p>여기 이 두 타입을 서로 매핑해주는 함수가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">alpha</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그리고 이 함수에는 역함수 또한 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">alpha_inv</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">alpha_inv</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, 이 매핑 함수는 동형사상(Isomorphism)이며, 이 과정에서 이 타입들이 결국 동일한 데이터를 여러 방법으로 패키징하고 있을 뿐이라는 사실을 알 수 있다.</p>\n<p>이렇게 생성된 곱 타입을 타입에 대한 이항 연산이라고 생각해볼 수도 있다. 이 관점에서 바라보면 위에서 알아본 동형사상은 모노이드(Monoid)에서 본 결합 법칙과 매우 유사한 형태를 띄고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그러나 모노이드의 경우 이 두 가지 방법이 완전히 동일하다고 말할 수 있겠지만, 곱 타입의 경우 완전히 동일하다는 의미가 아닌 동형사상에 따라 동일하다고 말할 수 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>만약 <code class=\"language-text\">(a * b) * c</code>와 <code class=\"language-text\">a * (b * c)</code>를 모노이드인 곱 연산의 관점에서 바라본다면, 이 연산은 교환법칙을 만족하기 때문에 완벽히 동일(Equal)하다고 이야기할 수 있다.</p>\n<p>하지만 곱 타입의 경우 각 튜플 안에 있는 요소들이 서로 정보의 손실 없이 매핑될 수 있는 일대일 대응함수가 존재하는 동형(Isomorphic)일 뿐이다.</p>\n<p>즉, 두 곱 타입이 동형사상을 통해 서로 매핑이 가능하므로 “동형성에 의해 같다”고 말할 수는 있겠지만 엄밀한 의미에서 동일하지는 않다는 것이다.</p>\n</blockquote>\n<p>만약 우리가 동형사상을 수용할 수 있고 엄격한 동일성을 요구하지 않는다면, 유닛 타입인 <code class=\"language-text\">()</code>이 곱셈의 항등원인 1과 같이  작동한다는 것을 보일 수도 있다. 실제로 임의의 타입 <code class=\"language-text\">a</code>인 값과 Unit을 쌍으로 묶는 것은 어떠한 정보도 추가하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>결국 이 타입은 <code class=\"language-text\">a</code>와 동형(Isomorphic)이다. 아래와 같이 동형사상을 정의할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">rho</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">rho</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token hvariable\">rho_inv</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">rho_inv</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이러한 분석을 통해 집합의 카테고리가 모노이드 카테고리(Monoidal Category)라는 것을 형식적으로 설명할 수 있다. 결국 집합의 카테고리는 각 대상을 데카르트 곱(Cartesian Product)의 형태로 곱할 수 있는 카테고리라는 것이다. 이에 대한 자세한 정의는 추후 다시 논의해보도록 하자.</p>\n<p>Haskell에서는 곱 타입을 더 일반적인 방식으로 정의할 수 있는 방법을 제공하고 있다. 나중에 다시 보겠지만 이런 방법은 특히 곱 타입이 합 타입과 합쳐질 때 빛을 발하게 된다. 이 방법은 여러 개의 인자를 받는 생성자로 표현되는데, 쌍의 경우는 아래와 같이 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Pair</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">P</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">Pair a b</code>는 매개변수화된 두 개의 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>, 그리고 데이터 생성자인 <code class=\"language-text\">P</code>를 의미한다. 우리는 <code class=\"language-text\">Pair</code> 타입 생성자에 두 개의 타입을 전달함으로써 간단하게 쌍이라는 타입을 생성할 수 있다. 그리고 <code class=\"language-text\">P</code>에는 정의해둔 타입에 맞는 두 값을 전달하여 쌍 타입의 값을 생성할 수 있다.</p>\n<p>한번 <code class=\"language-text\">String</code>과 <code class=\"language-text\">Bool</code>의 쌍으로 값을 정의해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">stmt</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Pair</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">stmt</span> <span class=\"token operator\">=</span> <span class=\"token constant\">P</span> <span class=\"token string\">\"This statements is\"</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>첫 번째 줄은 타입 선언부이다. 여기서 <code class=\"language-text\">Pair</code> 타입 생성자를 사용하며, 일반화했었던 <code class=\"language-text\">Pair</code> 정의의 매개변수인 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 대신에 <code class=\"language-text\">String</code>과 <code class=\"language-text\">Bool</code>을 직접 넘겨준다. 두 번째 줄은 데이터 생성자 <code class=\"language-text\">P</code>를 사용하여 구체적인 문자열과 부울값을 전달하여 실제 값을 정의하고 있다. 타입 생성자는 타입을 생성할 때 사용되고, 데이터 생성자는 해당 타입을 가진 값을 생성할 때 사용되는 것이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>완전히 동일하지는 않지만, 위 Haskell 코드를 TypeScript로 표현해보자면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 데이터 생성자</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">P</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 타입 생성자</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Pair<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> ReturnType<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> <span class=\"token constant\">P</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> \n\n<span class=\"token keyword\">const</span> stmt<span class=\"token operator\">:</span> Pair<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token constant\">P</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This statements is\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n</blockquote>\n<p>Haskell에서는 타입 생성자와 데이터 생성자의 네임스페이스가 분리되어있기 때문에 아래와 같이 동일한 이름도 종종 사용되고는 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Pair</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Pair</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>더 깊게 들여다보면 <code class=\"language-text\">Pair</code>를 이항 연산자인 <code class=\"language-text\">(,)</code>으로 대체하고 있는 것 또한 결국은 빌트인 쌍(Pair) 타입의 선언을 변형한 것이라고 볼 수 있다. 실제로 <code class=\"language-text\">(,)</code>을 전위 연산자로 표현하여 타입 생성자처럼 사용할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">stmt</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"This statement is\"</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이와 유사하게 <code class=\"language-text\">(,,)</code>을 사용하면 트리플(원소가 3개인 튜플)을 생성할 수 있으며, 같은 방법으로 계속 해서 튜플을 확장해나갈 수도 있다. 또한 일반적인 쌍이나 튜플 대신 원하는 곱 타입을 정의할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Stmt</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Stmt</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Bool</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 타입은 단순히 <code class=\"language-text\">String</code>과 <code class=\"language-text\">Bool</code>의 곱이지만 이 타입은 자체적인 이름과 생성자를 가지고 있다. 이러한 선언 방법의 장점은 동일한 내용을 가지지만 의미와 기능이 다른 타입을 다양하게 정의할 수 있다는 것이다. 또한 이렇게 선언된 각 타입들은 서로 대체될 수 없다.</p>\n<p>이처럼 튜플과 다중 인자 생성자를 사용하는 생성자는 각 구성 요소가 무엇을 나타내고 있는지 추적하기 어렵기 떄문에 종종 혼란스러운 표현이 되기 쉽고 오류가 발생하기도 쉽다. 그래서 때로는 각 구성 요소에 이름을 지정해주는 것이 나을 수도 있다. 이처럼 이름이 지정된 필드를 가진 곱 타입을 Haskell에서는 <code class=\"language-text\">record</code>라고 하며, C에서는 <code class=\"language-text\">struct</code>라고 한다.</p>\n<h2 id=\"62-레코드records\" style=\"position:relative;\">6.2 레코드(Records)<a href=\"#62-%EB%A0%88%EC%BD%94%EB%93%9Crecords\" aria-label=\"62 레코드records permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>본격적인 설명에 앞서 간단한 예시를 먼저 살펴보도록 하자. 우리는 화학 원소들을 설명하기 위해 원소의 이름과 원소 기호로 이루어진 두 개의 문자열과 원자 번호를 표현하는 하나의 정수가 결합된 데이터 구조를 만드려고 한다. 먼저 <code class=\"language-text\">(String, String, Int)</code>와 같이 튜플을 사용하여 각 구성 요소를 표현해볼 수 있다. 그 다음 원소 기호가 원소 이름의 접두사가 맞는지 확인하는 함수로 패턴 매칭하여 구성 요소들을 추출할 것이다. 아래는 <code class=\"language-text\">He</code>가 <code class=\"language-text\">Helium</code>의 접두사인지 확인하는 함수이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">name</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">isPrefixOf</span> <span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">name</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러나 이 코드는 에러가 발생할 가능성이 있고 유지 보수하기도 쉽지 않은 코드이다. 이런 경우에는 레코드를 정의하는 것이 훨씬 더 낫다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Element</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">name</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span>\n                       <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span>\n                       <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">atomicNumber</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위 표현과 튜플을 사용한 표현은 동형(Isomorphic)이다.이는 서로 역함수의 관계를 가지는 두 개의 변환 함수를 통해 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">tupleToElem</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Element</span>\n<span class=\"token hvariable\">tupleToElem</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Element</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">name</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">n</span>\n                                <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">s</span>\n                                <span class=\"token punctuation\">,</span> <span class=\"token hvariable\">atomicNumber</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token hvariable\">elemToTuple</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">elemToTuple</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">name</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">atomicNumber</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서 레코드 필드의 이름은 필드에 액세스하기 위한 함수로도 작동한다는 사실에 주목하도록 하자. 예를 들어 <code class=\"language-text\">atomicNumber e</code>라는 표현은 <code class=\"language-text\">e</code>에서 <code class=\"language-text\">atomicNumber</code>필드를 검색한다. 이처럼 <code class=\"language-text\">e</code>라는 레코드의 필드에 액세스하는 <code class=\"language-text\">atomicNumber</code> 함수의 타입은 다음과 같이 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">atomicNumber</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Element</code>의 레코드 문법을 사용하면 이제 <code class=\"language-text\">startWithSymbol</code> 함수도 더 읽기 쉬운 형태로 다시 표현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Element</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">isPrefixOf</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">name</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>심지어 Haskell이 제공하는 트릭을 사용하여 함수인 <code class=\"language-text\">isPrefixOf</code>를 중위 연산자로 표현하여 거의 하나의 자연어 문장처럼 읽히도록 만들어 볼 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">startsWithSymbol</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">symbol</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">`isPrefixOf`</span> <span class=\"token hvariable\">name</span> <span class=\"token hvariable\">e</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2 id=\"63-합-타입sum-types\" style=\"position:relative;\">6.3 합 타입(Sum Types)<a href=\"#63-%ED%95%A9-%ED%83%80%EC%9E%85sum-types\" aria-label=\"63 합 타입sum types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>집합의 카테고리의 곱 연산에서 곱 타입을 유도할 수 있듯이, 합 연산에서 합 타입을 유도해볼 수도 있다. Haskell에서 합 타입을 표현하는 전형적인 방법은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Right</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>쌍과 마찬가지로 <code class=\"language-text\">Either</code>도 두 연산 대상이 동형성(Isomorphic)인 경우에 한해 교환 법칙을 만족하고 중첩도 가능하다. 또한 두 대상이 동형이라는 전제 하에 중첩 순서 또한 중요하지 않다. 그런 이유로 다음과 같이 세 개의 구성 요소를 가진 합 타입을 정의해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">OneOfThree</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Sinistral</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Medial</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Dextral</span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 집합의 카테고리가 합을 기준으로 대칭적인 모노이드 카테고리라는 것이 밝혀졌다. 여기서 이항 연산의 역할은 서로소 합에 의해 수행되며 단위 원소의 역할은 초기 대상에 의해 수행된다.</p>\n<p>타입 관점에서 바라보면 <code class=\"language-text\">Either</code>는 모노이드 연산자, 그리고 Uninhabited(아무런 값도 가질 수 없는) 타입인 <code class=\"language-text\">Void</code>는 이 연산에 대한 항등원으로 볼 수 있다. <code class=\"language-text\">Either</code>를 덧셈으로, <code class=\"language-text\">Void</code>를 0이라고 생각해보자. 실제로 <code class=\"language-text\">Void</code>를 합 타입에 추가하더라도 해당 타입의 내용은 변하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token constant\">Void</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 정의는 <code class=\"language-text\">a</code>와 동형(Isomorphic)이다. 그 이유는 <code class=\"language-text\">Void</code>는 아무런 값도 가질 수 없는 타입이기 때문에 이 합 타입에서 <code class=\"language-text\">Right</code> 생성자 부분을 채워넣을 방법이 없기 때문이다. <code class=\"language-text\">Either a Void</code> 타입을 가질 수 있는 유일한 값은 <code class=\"language-text\">Left</code> 생성자를 사용하여 생성되기 때문에 결과적으로는 그저 타입 <code class=\"language-text\">a</code>의 값을 캡슐화하는 역할만 하게 될 것이다. 따라서 형식적으로 <code class=\"language-text\">a + 0 = a</code>와 같은 관점이 성립한다.</p>\n<p>이처럼 Haskell에서는 합 타입이라는 개념이 일상적으로 사용되지만, C++의 합 타입이라고 할 수 있는 <code class=\"language-text\">union</code>이나 <code class=\"language-text\">variants</code>은 Haskell처럼 일상적으로 사용되지는 않는다.</p>\n<p>이에는 여러 이유가 있다. 일단 C++에서 간단한 합 타입은 굳이 <code class=\"language-text\">union</code>을 사용하지 않더라도 <code class=\"language-text\">enum</code> 키워드를 사용하여 선언하는 열거형(Enumerations)으로 표현할 수 있다.</p>\n<p>Haskell에서 합 타입을 표현하는 방법을 다시 살펴보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Color</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Red</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Green</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Blue</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 합 타입을 C++에서 다시 표현해보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">enum</span> <span class=\"token punctuation\">{</span> Red<span class=\"token punctuation\">,</span> Green<span class=\"token punctuation\">,</span> Blue <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>마찬가지로 Haskell에서는 간단한 합 타입 중 하나인 <code class=\"language-text\">Bool</code>을 아래와 같이 합 타입임을 명시하여 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Bool</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span> <span class=\"token operator\">|</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>하지만 C++에서 이러한 합 타입은 그저 원시 자료형인 <code class=\"language-text\">bool</code>일 뿐이다.</p>\n<p>C++에서 값의 존재나 부재를 인코딩하는 간단한 합 타입은 여러가지 트릭과 빈 문자열, 음수, Null 포인터와 같이 “불가능한” 값들을 사용하여 다양하게 구현되고 있다. 이렇게 선택적으로 값이 존재할 수 있는 경우 Haskell에서는 <code class=\"language-text\">Maybe</code> 타입을 사용하여 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Maybe</code> 타입은 두 타입의 합 타입으로 구성되어있다. Maybe 타입을 구성하는 두 생성자를 각각의 개별적인 타입으로 분리하면 아래와 같이 보일 것이다. 먼저 첫 번째 생성자를 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">NothingType</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 타입은 값이 단 하나뿐인 열거형(Enumeration)이며, <code class=\"language-text\">Nothing</code>이라는 하나의 값만 가지고 있다. 다시 말해 이 타입은 싱글톤, 즉 단일 원소 집합이며 이는 유닛 타입인 <code class=\"language-text\">()</code>와 동등하다.</p>\n<p>이제 두 번째 생성자도 한번 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">JustType</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사실 위 타입은 그저 타입 <code class=\"language-text\">a</code>를 캡슐화한 것에 불과하다. 결과적으로 우리는 <code class=\"language-text\">Maybe</code> 타입을 다음과 같이 표현할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>C++에서 이보다 더 복잡한 합 타입을 표현하고 싶을 때는 포인터를 사용하여 일종의 모방을 한다. 포인터는 <code class=\"language-text\">null</code>이거나 특정 타입인 값을 가리킬 수 있다. 예를 들어 Haskell의 <code class=\"language-text\">List</code> 타입은 재귀적인 합 타입으로 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Cons</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>C++에서 이 표현을 모방하려면 Null 포인터 트릭을 사용하여 빈 리스트를 구현하는 방법으로 시도해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">List</span> <span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token operator\">*</span> _head<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">List</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">_head</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// Nil</span>\n    <span class=\"token function\">List</span><span class=\"token punctuation\">(</span>A a<span class=\"token punctuation\">,</span> List<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> l<span class=\"token punctuation\">)</span>       <span class=\"token comment\">// Cons</span>\n      <span class=\"token operator\">:</span> <span class=\"token function\">_head</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token generic-function\"><span class=\"token function\">Node</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 개의 Haskell 생성자인 <code class=\"language-text\">Nil</code>과 <code class=\"language-text\">Cons</code>는 오버로딩된 두 개의 <code class=\"language-text\">List</code> 생성자로 번역된다. <code class=\"language-text\">List</code> 클래스는 합 타입의 두 구성 요소를 구별하는데 별도의 태그가 필요하지는 않지만, 리스트의 헤드를 의미하는 <code class=\"language-text\">_head</code>를 <code class=\"language-text\">nullptr</code>로 초기화함으로써 <code class=\"language-text\">Nil</code> 생성자를 표현하고 있다.</p>\n<p>Haskell과 C++ 타입 간의 주요한 차이는 Haskell의 데이터 구조가 불변(Immutable)하다는 점에서 발생한다. 특정한 생성자를 사용하여 객체를 생성하면 해당 객체는 자신을 생성할 때 어떤 생성자가 사용되었는지, 그리고 어떤 인수가 전달되었는지 영원히 기억하고 있다. 따라서 <code class=\"language-text\">Just \"energy\"</code>로 생성된 <code class=\"language-text\">Maybe</code> 객체는 절대 <code class=\"language-text\">Nothing</code>으로 변하지 않는다는 것이다. 마찬가지로 빈 리스트는 영원히 빈 상태로 유지되며, 세 개의 원소를 가진 리스트는 영원히 동일한 세 개의 원소를 가진다.</p>\n<p>이러한 불변성은 구성 자체를 뒤집을 수 있도록 만들어주기도 한다. 주어진 객체를 항상 해당 구성에 사용된 부분으로 분해할 수 있다는 뜻이다. 이러한 분해에는 패턴 매칭이 사용되며 주어진 생성자를 패턴으로 다시 사용한다. 생성자에 인자가 주어진 경우 해당 인자는 변수로 대체된다.</p>\n<p><code class=\"language-text\">List</code> 데이터 타입은 두 개의 생성자를 가지고 있기 때문에 <code class=\"language-text\">List</code>를 해체할 때는 해당 생성자들에 각각 대응하는 두 가지 패턴을 사용해야 한다. 하나는 빈 <code class=\"language-text\">Nil</code> 리스트와 매칭될 것이고 다른 하나는 <code class=\"language-text\">Cons</code>로 생성된 리스트와 매칭될 것이다. 아래는 <code class=\"language-text\">List</code>에 대한 간단한 함수의 정의들이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">maybeTail</span> <span class=\"token operator\">::</span> <span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Maybe</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">maybeTail</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span>\n<span class=\"token hvariable\">maybeTail</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Cons</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">t</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">maybeTail</code>의 정의의 첫 번째 부분은 <code class=\"language-text\">Nil</code> 생성자를 패턴으로 사용하여 <code class=\"language-text\">Nothing</code>을 반환하고 있다. 두 번째 부분은 <code class=\"language-text\">Cons</code> 생성자를 패턴으로 사용하고 있는데, 생성자에게 주어진 첫 번째 인자는 필요없기 때문에 와일드 카드인 <code class=\"language-text\">_</code>로 대체하고 있다. 생성자에게 주어진 두 번째 인자는 변수 <code class=\"language-text\">t</code>에 바인딩되며 최종 반환 값은 <code class=\"language-text\">Just t</code>이다. 이제 <code class=\"language-text\">List</code>가 어떻게 생성되었느냐에 따라 두 정의 중 하나와 패턴 매칭이 될 것이다. 만약 <code class=\"language-text\">Cons</code>를 사용하여 생성되었다면 생성자에 전달된 두 인자 중 두 번째인자가 검색될 것이고 이후 <code class=\"language-text\">Just t</code>의 형태로 반환될 것이다.</p>\n<p>C++에서 이보다 더 복잡한 합 타입은 다형적인 클래스 계층을 사용하여 구현한다. 공통 조상을 가진 클래스 패밀리는 숨겨진 태그로 이해될 수 있으며, Haskell에서 생성자에 대한 패턴 매칭을 통해 수행되는 작업은 C++의 vtable 포인터를 기반으로 가상 함수 호출을 디스패치함으로써 수행된다.</p>\n<p>사실 C++에서는 합 타입을 온전하게 구현하기 어려운 여러가지 제약 때문에 <code class=\"language-text\">union</code>이 많이 사용되지는 않는다. 심지어 <code class=\"language-text\">string::std</code>이 복사 생성자(Copy Constructor)를 가지고 있기 때문에 <code class=\"language-text\">std::string</code>를 <code class=\"language-text\">union</code>에 넣을 수 조차 없다.</p>\n<h2 id=\"64-타입의-대수학\" style=\"position:relative;\">6.4 타입의 대수학<a href=\"#64-%ED%83%80%EC%9E%85%EC%9D%98-%EB%8C%80%EC%88%98%ED%95%99\" aria-label=\"64 타입의 대수학 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>곱 타입과 합 타입 모두 각각 데이터 구조를 정의할 때 유용하게 사용할 수 있지만, 실질적인 강점은 이 둘을 결합할 때 나타난다. 여기서 다시 한번 우리는 합성의 힘을 느끼게된다.</p>\n<p>먼저 우리가 지금까지 발견한 내용을 요약해보도록 하자. 타입 시스템의 기초에는 교환 법칙을 만족하는 두 가지 모노이달(Monoidal) 구조가 있다. 바로 <code class=\"language-text\">Void</code>를 항등원으로 가지는 합 타입과 유닛 타입인 <code class=\"language-text\">()</code>을 항등원으로 가지는 곱 타입이다. 우리는 이 개념들을 덧셈과 곱셉에 비유해서 생각해보려고 한다. 이 비유에서 <code class=\"language-text\">Void</code>는 덧셈의 항등원인 0, 그리고 <code class=\"language-text\">()</code>는 곱셈의 항등원인 1에 해당할 것이다.</p>\n<p>이 비유를 한번 어디까지 확장해서 적용할 수 있는지 보도록 하자. 우리는 이미 어떤 수에 0을 곱하게 되면 0이라는 결과를 얻는다는 사실을 알고 있다. 그렇다면 곱 타입인 쌍의 한 요소가 <code class=\"language-text\">Void</code>라면 이 타입은 Void와 동형일까? 예를 들면 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Void</code>를 구성요소로 가진 쌍을 만드는 것이 가능하냐는 것이다.</p>\n<p>쌍이라는 타입을 가진 값을 생성하기 위해서는 쌍의 구성 요소가 될 두 개의 값이 필요하다. 문제는 정수는 쉽게 만들 수 있지만 문제는 <code class=\"language-text\">Void</code> 타입의 값이 존재하지 않는다는 것이다. 따라서 모든 타입 <code class=\"language-text\">a</code>에 대해 타입 <code class=\"language-text\">(a, Void)</code>는 값을 가질 수 없는 타입(Uninhabited Type)이며, 결과적으로 <code class=\"language-text\">Void</code>와 동등하다. 다시 말해 <code class=\"language-text\">a*0 = 0</code>인 것이다.</p>\n<p>덧셈과 곱셈을 연결하는 또 다른 속성은 분배 법칙이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>곱셈과 덧셈의 분배 법칙이라는 속성은 일반적으로 곱 타입과 합 타입에도 적용될 수 있다. 위 식의 좌변은 아래와 같은 타입에 해당한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 우변은 아래와 같은 타입에 해당한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>좌변과 우변에 해당하는 타입들은 아래와 같은 방법을 통해 상호 변환될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">prodToSum</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">prodToSum</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">case</span> <span class=\"token hvariable\">e</span> <span class=\"token keyword\">of</span>\n      <span class=\"token constant\">Left</span>  <span class=\"token hvariable\">y</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Left</span>  <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>\n      <span class=\"token constant\">Right</span> <span class=\"token hvariable\">z</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한 위 함수의 역함수도 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">sumToProd</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Either</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">b</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">sumToProd</span> <span class=\"token hvariable\">e</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">case</span> <span class=\"token hvariable\">e</span> <span class=\"token keyword\">of</span>\n      <span class=\"token constant\">Left</span>  <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Left</span>  <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>\n      <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Right</span> <span class=\"token hvariable\">z</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">case of</code> 문은 함수 내에서 패턴 매칭에 사용된다. 주어진 변수가 화살표 왼쪽의 패턴과 일치한다면 화살표 오른쪽의 표현식이 실행되는 것이다. 예를 들어 <code class=\"language-text\">prodToSum</code> 함수를 호출해보는 상황을 한번 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">prod1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Either</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Float</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">prod1</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Left</span> <span class=\"token string\">\"Hi!\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">case e</code> 구문의 <code class=\"language-text\">e</code>는 <code class=\"language-text\">Left \"Hi!\"</code>에 해당한다. 이는 <code class=\"language-text\">Left y</code>라는 패턴과 일치하기 때문에 <code class=\"language-text\">y</code>는 <code class=\"language-text\">“Hi!”</code>라는 값으로 대체된다. 이 경우 <code class=\"language-text\">x</code>는 <code class=\"language-text\">2</code>에 매칭될 것이기 때문에 <code class=\"language-text\">case</code> 문을 사용한 전체 함수의 결과는 <code class=\"language-text\">Left(2, \"Hi!\")</code>가 되는 것이다.</p>\n<p>여기서 굳이 이 두 함수가 서로의 역함수임을 증명할 생각은 없지만, 가만 생각해보면 이 두 함수는 서로의 역함수여야하는 것이 당연하다. 왜냐하면 이 두 함수는 그저 자신이 받은 두 데이터 구조의 내용을 간단하게 재포장하는 것에 불과하기 때문이다. 즉, 데이터는 동일하지만 표현 방식이 다른 것 뿐이다.</p>\n<p>수학자들은 이처럼 얽혀있는 두 개의 모노이드에 대해 반환(Semiring)이라는 이름을 붙혔다. 이것은 이 경우 타입 간의 뺄셈에 대해서는 정의할 수 없기 때문에 완전한 “환(Ring)”이라고 말할 수는 없는 것이다.</p>\n<p>반환(Semiring)은 환(Ring)에서 음의 요소(<strong>N</strong>egative) n이 빠진 것이므로, 말장난처럼 “Rig”라고 부르기도 한다.</p>\n<p>하지만 음의 요소가 빠진 반환만으로도 자연수의 관한 명제를 타입에 관한 명제로 번역하여 많은 이점을 얻을 수 있다. 여기 몇 가지 흥미로운 항목들을 담은 번역 표가 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Numbers</th>\n<th>Types</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">0</code></td>\n<td><code class=\"language-text\">Void</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">1</code></td>\n<td><code class=\"language-text\">()</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">a+b</code></td>\n<td>`Either a b = Left a</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">a*b</code></td>\n<td><code class=\"language-text\">(a, b)</code> or <code class=\"language-text\">Pair a b = Pair a b</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">2=1+1</code></td>\n<td>`data Bool = True</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">1+a</code></td>\n<td>`data Maybe = Nothing</td>\n</tr>\n</tbody>\n</table>\n<p>리스트 타입은 특히 더 흥미로운데, 이 타입은 방정식의 해로 정의되기 때문이다. 우리가 정의하려는 타입은 일종의 방정식이며 아래와 같이 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nil</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Cons</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">List</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 방정식의 <code class=\"language-text\">List a</code>를 <code class=\"language-text\">x</code>로 치환해서 이 식을 일반화하면 아래와 같은 방정식을 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>하지만 타입의 세계에는 뺄셈이나 나눗셈이 없으니 우리는 이 문제를 전통적인 대수적 방법론으로는 해결할 수 없다. 하지만 이 식에 표현되어있는 녀석들을 치환하는 것 정도는 할 수 있다. 우변에 있는 <code class=\"language-text\">x</code>를 <code class=\"language-text\">(1 + a * x)</code>로 계속 해서 치환하고 분배 법칙을 사용해보자. 그러면 이제 이러한 식으로 이어질 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span>\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span>\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">...</span>\n\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">*</span><span class=\"token hvariable\">a</span><span class=\"token operator\">...</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>결국 이 식은 무한한 곱(튜플)의 합으로 끝나게 되는데, 이것은 리스트가 빈 경우 <code class=\"language-text\">1</code>, 단일 값인 경우 <code class=\"language-text\">a</code>, 쌍인 경우는 <code class=\"language-text\">a*a</code>, 트리플인 경우 <code class=\"language-text\">a*a*a</code>처럼 무한히 나아갈 것이라고 해석할 수 있다. 이게 결국 리스트의 정의 그 자체이다.</p>\n<p>이외에도 리스트에 대한 더 많은 내용들이 있지만, 다른 내용들에 대해서는 추후 펑터(Functor)와 고정점(Fixed Point)에 대해서 배운 후에 리스트와 같은 기타 재귀적인 데이터 구조에 대해서 다시 다룰 때 이야기를 해볼 것이다.</p>\n<p>결국 이처럼 기호로 표현되는 변수를 사용하여 어떠한 방정식을 해결하는 것이 바로 대수(Algebra)이며, 대수학으로 표현할 수 있는 타입에 이름을 붙힌 것이 대수적 데이터 타입(Algebraic Data Type)이다.</p>\n<p>마지막으로 타입의 대수에 대한 아주 중요한 해석 중 하나를 이야기하려고 한다. 두 타입 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 곱 타입에는 <code class=\"language-text\">a</code> 타입의 값과 <code class=\"language-text\">b</code> 타입의 값이 모두 포함되어야 하지만, 두 타입의 합 타입에는 <code class=\"language-text\">a</code> 타입이나 <code class=\"language-text\">b</code> 타입의 값이 둘 중 하나라도 포함되어 있으면 충분하다. 이는 논리식인 AND와 OR도 반환(Semiring)을 형성한다는 것을 의미하며, 결국 논리식 또한 타입 이론으로 매핑될 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>Logic</th>\n<th>Types</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">Void</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">()</code></td>\n</tr>\n<tr>\n<td>`a</td>\n<td>b`</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">a &amp;&amp; b</code></td>\n<td><code class=\"language-text\">(a, b)</code></td>\n</tr>\n</tbody>\n</table>\n<p>논리식과 타입 이론 간의 유사성은 이외에도 더 깊게 이어질 수 있으며, 커리-하워드 동형성(Curry-Howard Isomorphism)의 기초라고 할 수 있다. 이 내용에 대해서는 추후 함수 타입에 대해 이야기할 때 다시 살펴보도록 하겠다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240305-category-theory-for-programmers-6-simple-algebraic-data-types","path":"/2024/03/05/category-theory-for-programmers-6-simple-algebraic-data-types/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 6. 단순한 대수적 타입","subTitle":null,"date":"Mar 05, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"9562ca4b-c2f9-5e2e-b14c-225a051f1690","tableOfContents":"<ul>\n<li><a href=\"#51-%EC%B4%88%EA%B8%B0-%EB%8C%80%EC%83%81initial-object\">5.1 초기 대상(Initial Object)</a></li>\n<li><a href=\"#52-%EC%A2%85%EA%B2%B0-%EB%8C%80%EC%83%81terminal-object\">5.2 종결 대상(Terminal Object)</a></li>\n<li><a href=\"#53-%EC%8C%8D%EB%8C%80%EC%84%B1duality\">5.3 쌍대성(Duality)</a></li>\n<li><a href=\"#54-%EB%8F%99%ED%98%95%EC%84%B1isomorphisms\">5.4 동형성(Isomorphisms)</a></li>\n<li><a href=\"#55-%EA%B3%B1products\">5.5 곱(Products)</a></li>\n<li><a href=\"#56-%ED%95%A9coproduct\">5.6 합(Coproduct)</a></li>\n<li><a href=\"#57-%EB%B9%84%EB%8C%80%EC%B9%AD%EC%84%B1asymmetry\">5.7 비대칭성(Asymmetry)</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"고대 그리스의 시인 에우리피데스가 “사귀는 친구를 보면 그 사람을 알 수 있다.”라고 말했듯이, 우리의 존재는 우리가 가진 관계를 통해 정의된다. 카테고리 이론에서는 이 개념이 더더욱 중요하다. 만약 우리가 어떤 카테고리 내에 존재하는 특정 대상에 대해 명확하게 설명하기 위해서는 그 대상과 다른 대상들과의 관계까지도 함께 보아야 하기 때문이다. 그리고 이러한 관계는 사상(Morphism)에 의해 정의된다. (물론 여기서 관계라 함은 항등 사상으로 표현되는 자기 자신과의 관계 또한 포함된다.) 카테고리 이론에는 “보편적 구성(Uni…","html":"<p>고대 그리스의 시인 에우리피데스가 “사귀는 친구를 보면 그 사람을 알 수 있다.”라고 말했듯이, 우리의 존재는 우리가 가진 관계를 통해 정의된다. 카테고리 이론에서는 이 개념이 더더욱 중요하다. 만약 우리가 어떤 카테고리 내에 존재하는 특정 대상에 대해 명확하게 설명하기 위해서는 그 대상과 다른 대상들과의 관계까지도 함께 보아야 하기 때문이다. 그리고 이러한 관계는 사상(Morphism)에 의해 정의된다. (물론 여기서 관계라 함은 항등 사상으로 표현되는 자기 자신과의 관계 또한 포함된다.)</p>\n<p>카테고리 이론에는 “보편적 구성(Universal Construction)”이라고 불리는 방법이 존재한다. 이 구조는 각 대상들이 가지고 있는 관계를 통해 대상 자체를 정의하는 방법 중 하나이다. 이 방법은 먼저 특정 대상, 그리고 그 대상과 다른 대상 간의 관계를 나타내는 사상으로 구성된 특별한 패턴을 선택하고, 이 패턴이 카테고리 안에서 어떤 방식으로 나타나는지를 찾아내는 방식으로 진행된다. 만약 이 패턴이 일반적이고 카테고리의 크기가 충분히 크다면 이 패턴과 매칭되는 결과 또한 매우 많을 것이다. 결국 이 구성 방법의 핵심은 이렇게 찾아낸 무수한 결과들을 특정한 기준으로 평가하고 랭킹을 매겨 가장 적합한 결과를 찾아내는 것이다.</p>\n<p>이 과정은 마치 웹에서 검색을 하는 방식과 유사하다. 검색 쿼리는 일종의 패턴이다. 만약 이 쿼리가 매우 일반적인 쿼리라면 무수히 많은 쿼리 결과가 노출될 것이다. 이 결과 중 일부는 우리가 질의한 쿼리와 관련이 있을 수도 있지만 어떤 것들은 관련이 없을 수도 있다. 결국 우리는 관련없는 결과들을 제외하기 위해 쿼리를 더 세밀하게 다듬어가며 검색의 정확도를 높혀나간다. 최종적으로 검색 엔진은 이렇게 질의된 검색 결과들에게 랭킹을 매겨 결과를 순위 별로 나열하고, 사용자가 가장 관심을 가질만한 결과를 검색 결과 리스트의 최상단에 위치시킬 것이다.</p>\n<h2 id=\"51-초기-대상initial-object\" style=\"position:relative;\">5.1 초기 대상(Initial Object)<a href=\"#51-%EC%B4%88%EA%B8%B0-%EB%8C%80%EC%83%81initial-object\" aria-label=\"51 초기 대상initial object permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>카테고리 내에서 가장 단순한 형태는 단일 대상 그 자체이다. 아마 이렇게 단순한 형태의 패턴을 가진 무언가를 카테고리 내에서 찾아본다면, 당연히 패턴에 매칭되는 결과는 매우 많을 것이다.</p>\n<p>이처럼 일반적인 패턴을 사용하면 너무 많은 매칭 결과가 나오기 때문에, 우리는 이 결과들에 랭킹을 매길 수 있는 기준을 정하고 이 랭킹에서 비롯된 계층구조 내에서 가장 최상위에 있는 대상을 찾아야 한다. 앞서 말했듯이 이러한 대상을 정의하기 위해 우리가 사용해볼 수 있는 유일한 수단은 바로 사상이다.</p>\n<p>사상을 대상에서 다른 대상으로 향하는 일종의 화살표라고 생각해보자. 이 경우 카테고리의 한쪽 끝에서 다른쪽 끝으로 향하는 전반적인 화살표의 흐름이 존재할 수 있고, 만약 카테고리가 부분순서(Partial Order)와 같이 정렬되었다면 이 가정은 반드시 참이다. 그렇다면 어떠한 대상 <code class=\"language-text\">a</code>에서 다른 대상 <code class=\"language-text\">b</code>로 향하는 화살표(사상)가 존재하는 경우, “<code class=\"language-text\">a</code>가 <code class=\"language-text\">b</code>보다 더 초기적(Initial)이다”라고 정의하여 대상의 선행성이라는 개념을 일반화해볼 수 있다.</p>\n<p>이제 우리는 초기 대상이라는 개념을 “다른 모든 대상들로 향하는 화살표를 가진 대상”이라고 정의할 것이다. 물론 카테고리 내에 이런 대상이 반드시 존재하리란 보장은 없겠지만, 사실 이 문제보다는 오히려 이런 성질을 가진 대상이 너무 많을 수 있다는 것이 문제가 될 것이다. 다시 말해 쿼리의 검출율(Recall)은 높지만 정밀도(Precision)가 부족하다는 뜻이다.</p>\n<p>이 문제의 해결책에 대한 힌트는 정렬되어있는 카테고리(Ordered Categories)에서 얻을 수 있다. 대상 간의 순서가 명확하게 정의된 카테고리에서는 두 대상 간 최대 하나의 화살표만 허용되기 때문이다. 이러한 카테고리에서 어떤 대상이 다른 대상보다 작거나 같을 수 있는 방법은 하나 뿐이다. 이러한 사실을 토대로 우리는 초기 대상에 대해 다음과 같은 정의를 내려볼 수 있다.</p>\n<blockquote>\n<p>👉  “초기 대상”은 해당 카테고리 내에서 다른 대상으로 향하는 단 하나의 사상을 가진 유일한 대상이다.</p>\n</blockquote>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 608px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/38374193f4fa1493e2383b55a5a4734c/640be/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 105%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAVABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAMCBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7kaQjcFSoGIP/8QAGxABAAICAwAAAAAAAAAAAAAAAgABERIDEyH/2gAIAQEAAQUCa1I5d1Eveo0ohmYqA6V//8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAHBAAAgICAwAAAAAAAAAAAAAAABEBIQIQElFh/9oACAEBAAY/AmmKNcWO1jqqnsn0R//EABwQAQADAAMBAQAAAAAAAAAAAAEAESExUWEQQf/aAAgBAQABPyGyup+EEQK7v4NsGt3SWAeZUNJzV3A1nU9QaSvrP//aAAwDAQACAAMAAAAQF8g8/8QAFREBAQAAAAAAAAAAAAAAAAAAIHH/2gAIAQMBAT8Qo//EABcRAAMBAAAAAAAAAAAAAAAAAAERIEH/2gAIAQIBAT8QLyP/xAAdEAEBAAMAAgMAAAAAAAAAAAABEQAhMRBBUWGB/9oACAEBAAE/EHMP11nzlQ4V2z6k741a2UdCBr97gej2OlltNuIBGjswmbIQIHq50EPQ65C6qq1Vz//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/38374193f4fa1493e2383b55a5a4734c/640be/1.jpg\" srcset=\"/static/38374193f4fa1493e2383b55a5a4734c/0913d/1.jpg 160w,\n/static/38374193f4fa1493e2383b55a5a4734c/cb69c/1.jpg 320w,\n/static/38374193f4fa1493e2383b55a5a4734c/640be/1.jpg 608w\" sizes=\"(max-width: 608px) 100vw, 608px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>그러나 비록 이렇게 초기 대상에 대해 정의를 했고 실제로 초기 대상이 카테고리 안에 존재하는 것이 확인되었다고 해서 초기 대상이 카테고리 내에 유일하게 존재한다는 사실을 보장하는 것은 또 다른 이야기이다. 초기 대상의 유일성을 보장하기 위해 우리가 사용해볼 수 있는 유용한 아이디어는 바로 동형성(Isomorphism)이다. 동형성은 카테고리 이론에서 굉장히 중요한 부분을 차지하기 때문에 조만간 이에 대해서도 다룰테지만, 일단 지금은 동형성에 따라 초기 대상의 유일성을 보장할 수 있다는 점만 언급하고 넘어가도록 하겠다.</p>\n<p>간단한 예시를 한 번 보자. Poset이라고도 부르는 부분순서집합(Paritally Ordered Set)에서의 초기 대상은 이 집합에서 가장 작은 요소이다. 물론 이 개념이 모든 Poset에 적용되는 것은 아니고, 모든 정수(양수, 0, 음수)의 집합에 “작거나 같음” 관계를 적용한 특정 Poset같은 경우는 초기 대상이 존재하지 않는다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>초기 대상은 카테고리 내의 다른 모든 대상으로 향하는 사상을 가져야 한다. 그러나 “작거나 같음”이라는 사상을 가진 정수 집합은 무한 집합이기 때문에 “모든 정수에 대해 작거나 같기만 하는 관계를 가진 대상”이 존재할 수 없으므로 초기 대상이 존재하지 않는 것이다.</p>\n</blockquote>\n<p>반면 집합과 함수로 이루어진 카테고리에서 초기 대상은 공집합으로 정의할 수 있으며, 공집합은 Haskell에서의 <code class=\"language-text\">Void</code> 타입에 해당한다. 지난 챕터에서 우리가 <code class=\"language-text\">Void</code> 타입에서 임의의 다른 타입 <code class=\"language-text\">a</code>로 나아가는 <code class=\"language-text\">absurd</code> 함수를 정의했던 것을 기억하는가?</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">absurd</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Void</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>바로 이러한 종류의 사상들이 타입으로 이루어진 카테고리에서 <code class=\"language-text\">Void</code>를 초기 대상으로 만들어주는 녀석들이다.</p>\n<h2 id=\"52-종결-대상terminal-object\" style=\"position:relative;\">5.2 종결 대상(Terminal Object)<a href=\"#52-%EC%A2%85%EA%B2%B0-%EB%8C%80%EC%83%81terminal-object\" aria-label=\"52 종결 대상terminal object permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 단일 대상에 대한 패턴 이야기를 계속 해보자. 이번에는 대상에 대한 랭킹을 매기는 방식을 변경해볼 것이다. 우리는 어떠한 대상 <code class=\"language-text\">b</code>에서 대상 <code class=\"language-text\">a</code>로 향하는 사상이 있는 경우 ”<code class=\"language-text\">a</code>가 <code class=\"language-text\">b</code>보다 더 종결적(Terminal)이다”라고 이야기할 수 있다. 앞서 보았던 초기 대상과는 방향이 정반대라는 점에 주목하자. 우리는 카테고리 안에서 다른 대상들보다 더 많이 종결적인 대상을 찾아볼 것이다. 그리고 다시 한번 말하지만 이 검색 결과는 고유성을 가져야 한다.</p>\n<blockquote>\n<p>👉 종결 대상은 카테고리 내의 모든 객체로부터 오는 유일한 화살표를 가진 유일한 대상이다.</p>\n</blockquote>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ccbd3fc68e5ce8c978d1487a138556c0/c08c5/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 99.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIDBQT/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB2oy4k0EiqiLRX//EABwQAAICAgMAAAAAAAAAAAAAAAECAAMQMREhIv/aAAgBAQABBQJt8mDVillq6OAvqf/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABkQAAIDAQAAAAAAAAAAAAAAABARAAEhMf/aAAgBAQAGPwJHLU6y9H//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEQITFhof/aAAgBAQABPyFqBZADT7HezuVu324X5WRHZVwXH//aAAwDAQACAAMAAAAQW8i8/8QAFhEAAwAAAAAAAAAAAAAAAAAAESAh/9oACAEDAQE/EKU//8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EFA1iT//xAAdEAEBAAEFAQEAAAAAAAAAAAABEQAQITFRYYGx/9oACAEBAAE/EA77GMfuIS6yrQJ3vjhuDZxk8nYOvzJRZXiW+i+GEDYnmj05igC8un//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/ccbd3fc68e5ce8c978d1487a138556c0/c08c5/2.jpg\" srcset=\"/static/ccbd3fc68e5ce8c978d1487a138556c0/0913d/2.jpg 160w,\n/static/ccbd3fc68e5ce8c978d1487a138556c0/cb69c/2.jpg 320w,\n/static/ccbd3fc68e5ce8c978d1487a138556c0/c08c5/2.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>초기 대상과 마찬가지로 종결 대상 또한 동형성에 따라 카테고리 내에서 유일하게 존재한다고 이야기할 수 있다. 이에 대해서는 조만간 다시 설명하겠다.</p>\n<p>먼저 몇 가지 예제를 한번 살펴보도록 하겠다. 만약 Poset 내부에 종결 대상이 존재한다면 이는 아마 가장 큰 요소일 것이다. 집합의 카테고리에서의 종결 대상은 단일원소집합이다. 이미 우리는 단일원소집합에 대해서도 한번 이야기를 했었는데, 단일원소집합은 C++의 <code class=\"language-text\">void</code> 타입, Haskell에서는 <code class=\"language-text\">()</code>로 표현되는 Unit 타입에 해당한다.</p>\n<p>이것은 단 하나의 값만을 가진 타입으로, C++에서는 이러한 사실을 암묵적으로 표현하지만 Haskell에서는 <code class=\"language-text\">()</code> 라는 빈 괄호의 형태를 통해 명시적으로 표현하고 있다. 또한 이전 챕터에서 어떤 임의의 타입에서 Unit 타입으로 향하는 순수 함수는 단 하나만 존재할 수 있다는 사실 또한 언급했었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">unit</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">unit</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이렇게 종결 대상에 대한 모든 조건이 만족되었다.</p>\n<p>종결 대상에 대한 예시에서 유일성에 대한 조건이 중요한 이유는 결국 공집합을 제외한 다른 모든 집합들도 각각의 집합으로부터 오는 사상을 가질 수 있기 때문이다. 예를 들면 모든 타입을 받을 수 있고 <code class=\"language-text\">Boolean</code> 타입의 값을 반환하는 사상인 Predicate 함수가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">yes</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">yes</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러나 <code class=\"language-text\">Bool</code> 타입은 종결 대상이 아니다. 다른 타입에서 Bool 타입으로 향하는 함수는 <code class=\"language-text\">yes _ = True</code> 외에도 하나가 더 있기 때문에 유일한 사상이라고 말할 수 없기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">no</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">no</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>즉, 우리는 종결 대상은 유일해야한다는 조건을 통해 종결 대상의 정의를 단 하나의 타입으로 좁힐 수 있는 정밀도를 만들어낼 수 있다.</p>\n<h2 id=\"53-쌍대성duality\" style=\"position:relative;\">5.3 쌍대성(Duality)<a href=\"#53-%EC%8C%8D%EB%8C%80%EC%84%B1duality\" aria-label=\"53 쌍대성duality permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여기까지 오면 여러분은 아마 초기 대상과 종결 대상을 정의하는 방식 간에 대칭성이 존재한다는 사실을 눈치챘을 것이다. 이 두 정의 사이의 유일한 차이점은 그저 사상의 방향 뿐이었다. 여기서 한발짝 더 나아가보자면 이제 우리는 어떤 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>가 가진 모든 사상의 방향을 반대로 뒤집어서 반대 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span></span>를 정의할 수도 있을 것이다.</p>\n<p>반대 카테고리는 그저 특정 카테고리의 사상의 방향을 반대로 뒤집은 것 뿐이니 당연히 사상의 합성 규칙이나 다른 요구사항도 만족한다. 만약 원래 카테고리에서 사상 <code class=\"language-text\">f::a->b</code>와 <code class=\"language-text\">g::b->c</code>가 사상 <code class=\"language-text\">h::a->c</code>로 합성되었다면, 반대 카테고리의 뒤집힌 사상인 <code class=\"language-text\">f^op::b->a</code>와 <code class=\"language-text\">g^op::c->b</code>  또한 <code class=\"language-text\">h^op::c->a</code>로 합성된다는 것이다. 그리고 각 대상에 대한 항등사상을 반대로 뒤집는 것은 의미가 없으므로, 항등사상은 그대로 유지된다.</p>\n<p>쌍대성(Duality)이라는 개념은 수학자들이 카테고리 이론을 사용할 때의 생산성을 두 배로 높혀주기 때문에 꽤 중요한 속성으로 취급된다. 우리가 구성한 모든 것들에는 그와 대응하는 것들이 존재하며, 증명하는 모든 정리들에 대응하는 정리들 또한 자동으로 따라오기 때문이다.</p>\n<p>반대 카테고리의 구성 요소들은 곱(product)와 쌍대곱(coproduct), 모나드(monad)와 쌍대모나드(comonad), 콘(cone)과 쌍대콘(cocone), 극한(limit)과 쌍대극한(colimit)과 같이 “co 또는 쌍대”라는 접두사가 붙어있다. 그러나 cocomonad와 같은 개념은 존재하지 않는다. 왜냐하면 화살표를 두 번 뒤집으면 다시 원래 상태로 돌아오기 때문이다.</p>\n<p>즉, 위의 정의에 따라 반대 카테고리에서의 초기 대상은 종결 대상이다.</p>\n<h2 id=\"54-동형성isomorphisms\" style=\"position:relative;\">5.4 동형성(Isomorphisms)<a href=\"#54-%EB%8F%99%ED%98%95%EC%84%B1isomorphisms\" aria-label=\"54 동형성isomorphisms permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리는 프로그래머로서 같다는 개념, 즉 동등성(Equality)을 정의한다는 것이 쉽지 않다는 것을 이미 잘 알고 있다. 두 개의 대상이 같다는 것은 무엇을 의미하는 걸까? 메모리에서 동일한 위치를 차지하는 것을 의미할까? 이 대상이 집합이라면 원소들이 전부 동일하면 같다고 봐야할까? 혹은 하나는 실수부와 허수부로 표현되고, 다른 하나는 크기와 각도로 표현되는 복소수라면 이 두 복소수는 같다고 봐야할까?</p>\n<p>아마 여러분은 수학자들이 이미 동등성에 대한 의미를 찾아냈을 것이라고 생각하겠지만, 사실 수학자들도 아직 동등성이 무엇인가에 대한 명확한 정의를 내리지 못 했다. 동등성에 대한 정의에는 명제 동등성, 의미 동등성, 확장 동등성, 호모토피 유형 이론에서의 경로로 정의되는 동등성 등 여러가지 방법이 제시된다. 그리고 동등성보다 더 약한 개념인 동형성, 그리고 동형성보다도 더 약한 개념인 등가성이라는 개념도 있다.</p>\n<p>우선 동형에 대해 직관적으로 이해해보자면 동형이라는 의미는 동일한 형태를 가지고 있다는 말이니 동형인 대상들은 서로 비슷하게 보일 것이다. 비슷하게 보인다는 것은 어떤 한 대상의 각 부분들이 다른 대상의 어떠한 부분과 일대일로 대응된다는 것을 의미한다. 즉, 상대적인 상황에 따라 조금씩 달라질 수는 있지만 대체로 동형인 두 대상은 서로 완벽한 복사본처럼 보일 수 있다는 것이다.</p>\n<p>수학적으로 이야기해보자면 어떤 대상 <code class=\"language-text\">a</code>에서 대상 <code class=\"language-text\">b</code>로의 매핑이 존재하고 대상 <code class=\"language-text\">b</code>에서 대상 <code class=\"language-text\">a</code>로 향하는 매핑이 존재하며, 이 두 매핑이 서로의 역함수라는 것을 의미한다. 또한 우리는 이미 카테고리 이론에서 이러한 매핑을 사상이라고 한다는 것을 잘 알고 있다. 정리해보자면 두 대상이 동형이라는 의미는 두 대상이 서로에게 향하는 사상을 가지고 있고, 이 사상들이 서로의 반대 개념인 역사상(Inverse Morphism)이 되어야 한다는 것이다.</p>\n<p>이러한 역사상에 대한 개념은 합성과 항등이라는 개념을 통해 이해하는 것이 쉽다. 사상 <code class=\"language-text\">g</code>가 사상 <code class=\"language-text\">f</code>의 역사상이라면, 이 두 사상의 합성사상은 항등사상이 되어야 한다. 이러한 관계를 나타낼 수 있는 식은 총 두 가지가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">id</span>\n<span class=\"token hvariable\">g</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">id</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>앞서 필자가 초기 대상이나 종결 대상이 동형성을 기준으로 했을때 카테고리 내에 유일하게 존재한다고 말한 것은 어떤 두 초기 대상 또는 종결 대상이 서로 동형(Isomorphic) 관계에 있다는 것을 의미한다는 설명이었다.</p>\n<p>말이 조금 어렵게 느껴지지만 조금만 생각해보면 쉽게 이해할 수 있다. 한번 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>과 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>라는 두 초기 대상이 있다고 가정해보자. <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>은 초기 대상이니 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 향하는 유일한 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>가 존재할 것이다. 마찬가지로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>또한 초기 대상이니 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 향하는 유일한 사상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>가 존재한다. 그렇다면 이 두 사상의 합성은 무엇일까?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 320px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/516e915f7161e4ca2ff7bc7baff41e50/cb69c/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdp0ihh//8QAGRABAAMBAQAAAAAAAAAAAAAAARESIQAi/9oACAEBAAEFAre1qGkE1zv/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAADAQAAAAAAAAAAAAAAAAAAESAh/9oACAEBAAY/AkbP/8QAGhABAQEBAQEBAAAAAAAAAAAAAREAITFRcf/aAAgBAQABPyEdPt8y08335m0SOWpNPHf3BCG//9oADAMBAAIAAwAAABBgz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQADAQEBAAAAAAAAAAAAAAEAESExQbH/2gAIAQEAAT8QBkLPmqxH7ET2uHLOQSLgg3TCVxCqeTW1W3rTYAAAcDyf/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"\" src=\"/static/516e915f7161e4ca2ff7bc7baff41e50/cb69c/3.jpg\" srcset=\"/static/516e915f7161e4ca2ff7bc7baff41e50/0913d/3.jpg 160w,\n/static/516e915f7161e4ca2ff7bc7baff41e50/cb69c/3.jpg 320w\" sizes=\"(max-width: 320px) 100vw, 320px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이 다이어그램에 존재하는 모든 사상은 전부 유일하게 존재한다.</small>\n</center>\n<p>위 그림을 보면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>를 합성한 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span> 사상은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>에서 출발해 다시 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 돌아가는 사상이 된다. 그러나 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>은 초기 대상이니 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 향하는 사상은 반드시 항등 사상 하나만 존재해야하는데, 모든 카테고리에는 항등 사상이 반드시 존재해야 하기 때문에 이 사상을 제거할 수는 없다. 결국 이러한 제약으로 인해 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>는 항등 사상일 수 밖에 없는 것이다. 마찬가지로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>i</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>로 향하는 사상도 결국 하나만 존재할테니, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">f\\circ g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>도 항등사상이라고 할 수 있다. 이렇게 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>가 서로의 역이 되어야 한다는 것이 입증됨으로써 어떤 두 초기 대상이든 모두 동형 관계에 놓인다는 사실 또한 증명되었다.</p>\n<p>위 증명 과정에서는 초기 대상에서 다시 자기 자신에게 향하는 사상의 유일성을 사용했다. 만약 이 유일성이 보장되지 않는다면 “동형성을 기준으로 유일하다”라는 명제를 증명할 수 없다.</p>\n<p>그런데 왜 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>의 유일성이 필요한걸까? 그 이유는 두 초기 대상이 동형이라는 가정에서 출발하여 초기 대상의 유일함을 증명하기 위해서는 이 동형성마저도 유일하다는 조건이 만족되어야 하기 때문이다. 원칙적으로는 두 대상 간의 여러 개의 동형성이 존재할 수 있겠지만, 이번에 살펴본 예시에서의 두 초기 대상은 서로에게 동형이 될 수 있는 케이스가 단 하나만 존재한다. 이처럼 “유일한 동형성을 기준으로 유일하다”는 것은 보편적 구성의 매우 중요한 특징이다.</p>\n<h2 id=\"55-곱products\" style=\"position:relative;\">5.5 곱(Products)<a href=\"#55-%EA%B3%B1products\" aria-label=\"55 곱products permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>다음으로 살펴볼 보편적 구성은 바로 곱의 개념이다. 우리는 두 집합의 데카르트 곱(Cartesian Product)이 쌍으로 이루어진 집합이라는 것을 알고 있다. 그렇다면 곱 집합과 곱 집합 내부의 쌍을 이루는 구성 요소 집합들을 연결해주는 패턴은 무엇일까? 우리가 이 패턴을 이해할 수만 있다면 이제 다른 카테고리에도 일반화해서 적용해볼 수 있을 것이다.</p>\n<blockquote>\n<p><strong>💡 역주</strong></p>\n<p>만약 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">A = \\{1, 2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span></span>이고, 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">B = \\{a, b\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">}</span></span></span></span></span>라면 이 두 집합의 데카르트 곱은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">A\\times B = \\{(1,a),(1,b),(2,a),(2,b)\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)}</span></span></span></span></span>와 같이 각 집합의 원소로 구성된 튜플을 원소로 가진 집합으로 정의된다. 즉, 구성 요소 집합이라는 의미는 데카르트 곱 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\times B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>의 원소들인 각 튜플을 구성하고 있는 값들의 집합이라는 의미이며, 결국 곱 연산의 재료로 사용된 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>와 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>를 의미하는 것이다.</p>\n<p>여기서 역자가 데카르트 곱의 원소가 쌍(Pair)이 아닌 튜플(Tuple)이라고 설명한 이유는, 데카르트 곱이 이항연산이 아니기 때문이다. 즉, 이 연산에는 두 개 이상의 집합이 사용될 수 있으며 데카르트 곱의 원소의 형태도 (x, y, z, …)처럼 계속 길어질 수 있다는 의미이다. 쌍이란 순서가 있는 2개의 구성요소를 가진 개념이고, 튜플은 n개의 구성요소를 가진 개념이므로 엄밀한 정의는 튜플이라고 하는 것이 맞다.</p>\n<p>다만 작가는 여기서 “두 집합의 데카르트 곱”이라는 전제를 깔고 있기 때문에 데카르트 곱의 원소들이 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(1,a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span></span>와 같은 쌍의 형태라고 말하고 있는 것이다.</p>\n</blockquote>\n<p>일단 우리가 당장 확실하게 이야기할 수 있는 것은 곱 집합에서 각 구성 요소로 향하는 두 개의 함수, 즉 투영 사상(Projections)이 존재한다는 것이다. Haskell에서는 이 두 함수를 <code class=\"language-text\">fst</code>와 <code class=\"language-text\">snd</code>라고 부르며, 이 함수들은 각각 쌍의 첫 번째와 두 번째 구성요소를 선택한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fst</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">fst</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token builtin\">snd</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n<span class=\"token builtin\">snd</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">y</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수들은 인자를 패턴 매칭하는 형태로 정의된다. 임의의 쌍에 매칭되는 패턴은 위 코드의 <code class=\"language-text\">(x, y)</code>이며, 최종적으로는 이렇게 매칭된 쌍에 접근하여 각 구성요소를 변수 <code class=\"language-text\">x</code>와 <code class=\"language-text\">y</code>로 추출한다.</p>\n<p>이 정의는 와일드카드(<code class=\"language-text\">_</code>)를 사용하면 더 간단하게 표현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fst</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n<span class=\"token builtin\">snd</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">y</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>C++에서 이와 같은 동작은 템플릿 함수를 사용하여 구현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token operator\">></span> A\n<span class=\"token function\">fst</span><span class=\"token punctuation\">(</span>pair<span class=\"token operator\">&lt;</span>A<span class=\"token punctuation\">,</span> B<span class=\"token operator\">></span> <span class=\"token keyword\">const</span> <span class=\"token operator\">&amp;</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 내용을 토대로 집합의 카테고리에서 두 집합 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 곱집합을 구성할 수 있는 대상과 사상의 패턴을 정의해보겠다.</p>\n<p>이 패턴은 대상 <code class=\"language-text\">c</code>와 그것을 각각 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>에 연결해주는 두 개의 사상 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>로 구성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">q</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 417px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/21474f37fbfc536731aa732ab1037274/6eca5/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB70aahiK//8QAGxABAAICAwAAAAAAAAAAAAAAARESAAIQITH/2gAIAQEAAQUCWMs68V7SQ8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAADAAMAAAAAAAAAAAAAAAAAECEBEYH/2gAIAQEABj8CLxWmsr//xAAbEAEAAwADAQAAAAAAAAAAAAABABEhEDFRQf/aAAgBAQABPyEaX9gLPbW9eNWeGw8hv0MuabfZ/9oADAMBAAIAAwAAABALD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABYRAAMAAAAAAAAAAAAAAAAAABARIf/aAAgBAgEBPxBUf//EAB0QAAIBBAMAAAAAAAAAAAAAAAERACExQVEQYdH/2gAIAQEAAT8QNtW2BFx4Cy4u+8rXF7ahCnpYMFkSBFFGCCF2ic//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"\" src=\"/static/21474f37fbfc536731aa732ab1037274/6eca5/4.jpg\" srcset=\"/static/21474f37fbfc536731aa732ab1037274/0913d/4.jpg 160w,\n/static/21474f37fbfc536731aa732ab1037274/cb69c/4.jpg 320w,\n/static/21474f37fbfc536731aa732ab1037274/6eca5/4.jpg 417w\" sizes=\"(max-width: 417px) 100vw, 417px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이 패턴에 부합하는 모든 <code class=\"language-text\">c</code>는 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 곱집합의 후보라고 볼 수 있다. 하지만 문제는 이런 후보들이 한두개가 아니라는 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/497145782e1ce89bc605805e3ade82a8/c08c5/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 50.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAduNwA//xAAZEAEAAgMAAAAAAAAAAAAAAAABAAIQITH/2gAIAQEAAQUCbbVhzP8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAgMAAAAAAAAAAAAAAAAAAREAICH/2gAIAQEABj8CQjOV/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARQSAh/9oACAEBAAE/IazQsEHoMyKw8f/aAAwDAQACAAMAAAAQMM//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAEAAQUBAAAAAAAAAAAAAAABEQAQITFBof/aAAgBAQABPxDIoyo1M0BmUrzlaIycsk2//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"\" src=\"/static/497145782e1ce89bc605805e3ade82a8/c08c5/5.jpg\" srcset=\"/static/497145782e1ce89bc605805e3ade82a8/0913d/5.jpg 160w,\n/static/497145782e1ce89bc605805e3ade82a8/cb69c/5.jpg 320w,\n/static/497145782e1ce89bc605805e3ade82a8/c08c5/5.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>예를 들어 두 개의 Haskell 타입, <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Bool</code>을 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>라고 생각하고 이 타입(집합)들에 대한 곱집합 후보를 한번 살펴보자.</p>\n<p>자, <code class=\"language-text\">Int</code> 타입은 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Bool</code> 타입의 곱집합 후보가 맞을까? 맞다. 아래 투영 사상들을 한번 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">p</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token hvariable\">q</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">q</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 정의는 단순 그 자체이지만, 우리가 정의했던 기준에는 부합한다. 그러면 이번에는 세 개의 구성 요소로 이루어진 튜플인 <code class=\"language-text\">(Int, Int, Bool)</code>을 살펴보자. 이 튜플 또한 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Bool</code>의 곱집합이 될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Bool</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">p</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token hvariable\">q</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Bool</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">q</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>아마도 이미 눈치챘겠지만 우리가 찾아낸 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Bool</code>의 곱집합 후보 중 첫 번째 후보는 곱의 Int 차원만을 다루고 있어 너무 작다고 느껴지고, 두 번째 후보는 Int 차원을 중복시켜놓았으니 너무 크다고 느껴진다.</p>\n<p>이제 보편적 구성(Universal Construction)의 랭킹 개념이 등장할 차례이다. 이제 우리는 패턴에 일치되어 뽑힌 두 결과 후보를 비교해볼 수 있을 것이다.</p>\n<p>우선 <code class=\"language-text\">c</code>가 <code class=\"language-text\">c'</code>보다 “더 나은 경우”를 설명하고 싶은 상황이라고 가정하고, 하나의 후보 대상인 <code class=\"language-text\">c</code>와 이 대상의 투영 사상 <code class=\"language-text\">p</code>, <code class=\"language-text\">q</code>를 다른 후보 대상인 <code class=\"language-text\">c'</code>와 이 대상의 투영 사상 <code class=\"language-text\">p'</code>, <code class=\"language-text\">q'</code>와 비교해보려고 한다.</p>\n<p>만약 <code class=\"language-text\">c'</code>에서 <code class=\"language-text\">c</code>로 향하는 임의의 사상 <code class=\"language-text\">m</code>이 존재한다면 경우 <code class=\"language-text\">c</code>가 더 낫다고 말할 수 있겠지만, 그래도 이런 설명은 너무 빈약하다. 우리는 대상 뿐 아니라 이 대상이 가진 투영 사상들에 대해서도 어떤 것이 더 낫다고 설명할 수 있어야하기 때문이다. 즉, 투영 사상 <code class=\"language-text\">p'</code>와 <code class=\"language-text\">q'</code> 또한 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>, 그리고 사상 <code class=\"language-text\">m</code>의 합성을 통해 구성될 수 있어야 한다는 의미이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">p</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m</span>\n<span class=\"token hvariable\">q'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">q</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 541px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/064dcc92871175f26dde24e634e3cce2/8af7b/6.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 81.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHeWVHkB//EABkQAQACAwAAAAAAAAAAAAAAAAEAEgIRIv/aAAgBAQABBQJdQy6jZaIE/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAgMAAAAAAAAAAAAAAAAAARAAElH/2gAIAQEABj8CeCGq/8QAGxAAAwEAAwEAAAAAAAAAAAAAAREhABAxUUH/2gAIAQEAAT8h+jUMHtAcBHD2vFk02+4mKFv/2gAMAwEAAgADAAAAELPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAAIDAQEAAAAAAAAAAAAAAREhADFBURD/2gAIAQEAAT8QAjK2KMVpCDbGJs578isZsOxyvMiA4LTTU6oxBUfR5n//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"\" src=\"/static/064dcc92871175f26dde24e634e3cce2/8af7b/6.jpg\" srcset=\"/static/064dcc92871175f26dde24e634e3cce2/0913d/6.jpg 160w,\n/static/064dcc92871175f26dde24e634e3cce2/cb69c/6.jpg 320w,\n/static/064dcc92871175f26dde24e634e3cce2/8af7b/6.jpg 541w\" sizes=\"(max-width: 541px) 100vw, 541px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이 방정식을 바라보는 다른 방법은 사상 <code class=\"language-text\">m</code>이 투영 사상 <code class=\"language-text\">p'</code>와 <code class=\"language-text\">q'</code>를 인수분해한다고 보는 것이다. 이 방정식들의 변수들이 함수가 아니라 자연수, 그리고 함수의 합성을 의미하는 점(<code class=\"language-text\">.</code>)이 곱셉 연산 기호라고 가정해보자. 결국 <code class=\"language-text\">m</code>은 <code class=\"language-text\">p'</code>와 <code class=\"language-text\">q'</code>가 공유하는 공통 인수라는 사실을 알 수 있다.</p>\n<p>좀 더 직관적인 이해를 위해, <code class=\"language-text\">fst</code>, <code class=\"language-text\">snd</code> 라는 두 표준 투영 사상을 가진 <code class=\"language-text\">(Int, Bool)</code> 쌍이 앞서 알아봤던 두 개의 후보보다 더 나은 후보가 맞는지를 직접 보여주겠다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 320px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/bff3233c699c3f1604778632826dfb07/cb69c/7.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 69.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHdgMsEH//EABoQAAICAwAAAAAAAAAAAAAAAAABAhEQEiH/2gAIAQEAAQUCbFzCiaCuv//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAAMBAAAAAAAAAAAAAAAAAAAQIQH/2gAIAQEABj8Cd1U//8QAGxAAAgMAAwAAAAAAAAAAAAAAAREAIUEQMaH/2gAIAQEAAT8hQV7DHQtnTfBbuZahBECqyKDU/9oADAMBAAIAAwAAABCjD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEAAwEBAAAAAAAAAAAAAAERADFBIRD/2gAIAQEAAT8QTSCVT4ZE4J0Pia2ENThjWUsTxgCQglO5/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"7\" title=\"\" src=\"/static/bff3233c699c3f1604778632826dfb07/cb69c/7.jpg\" srcset=\"/static/bff3233c699c3f1604778632826dfb07/0913d/7.jpg 160w,\n/static/bff3233c699c3f1604778632826dfb07/cb69c/7.jpg 320w\" sizes=\"(max-width: 320px) 100vw, 320px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>첫 번째 후보를 위한 사상 <code class=\"language-text\">m</code>은 다음과 같이 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Bool</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">m</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">True</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이때 두 투영 사상 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>는 다음과 같이 재구성될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fst</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">m</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n<span class=\"token hvariable\">q</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">snd</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">m</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또한 두 번째 후보의 <code class=\"language-text\">m</code> 또한 아래와 같이 유일한 형태로 결정된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이렇게 <code class=\"language-text\">(Int, Bool)</code>이 다른 두 곱집합 후보보다 더 낫다는 사실을 보였다. 그럼 이제 반대 경우가 성립하지 않는 이유를 살펴보도록 하자. <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>에서 <code class=\"language-text\">fst</code>와 <code class=\"language-text\">snd</code>를 재구성할 수 있는 <code class=\"language-text\">m’</code>을 찾을 수 있을까?</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">fst</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">p</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m'</span>\n<span class=\"token builtin\">snd</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">q</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>첫 번째 곱집합 후보에서 <code class=\"language-text\">q</code>는 항상 <code class=\"language-text\">True</code>를 반환했지만, 우리는 이미 두 번째 요소가 <code class=\"language-text\">False</code>인 쌍 또한 존재할 수 있다는 사실을 알고 있다. 결국 이에 따라 <code class=\"language-text\">q</code>를 통해 <code class=\"language-text\">snd</code>를 재구성할 수는 없다는 것을 알 수 있다.</p>\n<p>두 번째 예제는 조금 다르다. 두 번째 예제는 <code class=\"language-text\">p</code> 또는 <code class=\"language-text\">q</code> 중 하나를 실행한 이후에도 충분한 정보들을 유지하고 있지만, 이번에는 <code class=\"language-text\">fst</code>와 <code class=\"language-text\">snd</code>를 인수분해하는 방법이 너무 많다는 것이 문제가 된다.</p>\n<p>두 번째 후보의 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>는 모두 3개의 구성요소 중 두 번째 요소를 무시하기 때문에 <code class=\"language-text\">m'</code> 에 어떤 값을 넣어도 전부 말이 된다. 즉 아래와 같은 예시들이 있을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m'</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 또는</span>\n<span class=\"token hvariable\">m'</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- 기타 등등...</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>정리해보자면 어떤 두 투영 사상 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>를 가지는 타입 <code class=\"language-text\">c</code>가 주어졌을 때 이들을 인수분해할 수 있는 <code class=\"language-text\">m</code>은 유일하게 존재해야하는 후보가 가장 적합한 곱집합 후보라고 볼 수 있다. 사실 이 <code class=\"language-text\">m</code>은 단순히 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>를 하나의 쌍으로 결합하는 녀석이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">m</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">p</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">q</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이러면 결국 데카르트 곱 <code class=\"language-text\">(a, b)</code>가 가장 최적의 선택이 되며, 결국 이는 어떠한 두 집합의 곱을 선택하는 것과 동일하므로 이러한 보편적 구성이 집합 카테고리 위에서 제대로 작동한다는 것을 의미한다.</p>\n<p>자 이제 집합에 대한 것은 모두 잊어버리고, 동일한 보편적 구성을 이용하여 임의의 카테고리에서 두 대상에 대한 곱을 정의해보도록 하자. 이러한 곱이 항상 존재한다고 말하기는 어렵지만, 만약 존재한다면 독특하게 유일한 동형성(Isomorphism)을 가지게 된다.</p>\n<blockquote>\n<p>👉 두 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 곱은 “두 투영 사상을 갖춘 대상 <code class=\"language-text\">c</code>“이며, 다른 “두 투영 사상을 갖춘 대상 <code class=\"language-text\">c'</code>“에 대해 그 투영 사상들을 인수분해하는 유일한 사상 <code class=\"language-text\">m</code>이 존재하는 경우를 의미한다.</p>\n</blockquote>\n<p><code class=\"language-text\">c</code>와 <code class=\"language-text\">c'</code> 두 후보로부터 인수분해 사상 <code class=\"language-text\">m</code>을 생성하는 고차함수는 <code class=\"language-text\">factorizer</code>라고 불린다. 앞서 살펴본 예시의 경우에는 아래와 같은 함수가 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorizer</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">c</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">factorizer</span> <span class=\"token hvariable\">p</span> <span class=\"token hvariable\">q</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">p</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">q</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h2 id=\"56-합coproduct\" style=\"position:relative;\">5.6 합(Coproduct)<a href=\"#56-%ED%95%A9coproduct\" aria-label=\"56 합coproduct permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>카테고리의 모든 구성 요소들과 마찬가지로 곱(Product)에도 대응되는 개념이 존재하는데, 이를 반대곱(Coproduct) 또는 합이라고 한다. 앞서 살펴보았던 곱의 패턴에서 화살표를 반대로 하면 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>에서부터 <code class=\"language-text\">c</code>로 향하는 두 개의 삽입 사상을 가진 대상 <code class=\"language-text\">c</code>를 만들어볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">i</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span>\n<span class=\"token hvariable\">j</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 616px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d472bf852bdba883d0bdeac5212604c2/4ae3a/8.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 62.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7WWnDDlf/8QAGxAAAgIDAQAAAAAAAAAAAAAAAQIAERASITH/2gAIAQEAAQUCphC1xeKfFTXH/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAgMBAQAAAAAAAAAAAAAAAREAECECYf/aAAgBAQAGPwI6xFyjkDo+1//EABsQAQEBAAIDAAAAAAAAAAAAAAERABAxIVGB/9oACAEBAAE/IT4Svea3R9usECqHnVUY4mxWrx//2gAMAwEAAgADAAAAEMsP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHhABAAICAQUAAAAAAAAAAAAAAREhAFEQMUFhcZH/2gAIAQEAAT8Qb0EehuXvkgQGbFouL38wYggrtjzgQSBTExl5UggB64//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"8\" title=\"\" src=\"/static/d472bf852bdba883d0bdeac5212604c2/4ae3a/8.jpg\" srcset=\"/static/d472bf852bdba883d0bdeac5212604c2/0913d/8.jpg 160w,\n/static/d472bf852bdba883d0bdeac5212604c2/cb69c/8.jpg 320w,\n/static/d472bf852bdba883d0bdeac5212604c2/4ae3a/8.jpg 616w\" sizes=\"(max-width: 616px) 100vw, 616px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이는 단지 곱의 패턴에서 화살표를 반대로 뒤집은 것 뿐이므로 랭킹 또한 역전된 형태를 띈다. 대상 <code class=\"language-text\">c</code>가 삽입 사상 <code class=\"language-text\">i’</code>와 <code class=\"language-text\">j’</code>를 갖춘 대상 <code class=\"language-text\">c’</code>보다 더 낫다고 이야기하려면, 삽입 사상을 인수분해하는 사상 <code class=\"language-text\">m</code>이 존재해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">i'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">i</span>\n<span class=\"token hvariable\">j'</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">j</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 575px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/64afd72f0aa385b61631a29cde698ded/8c797/9.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 83.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9uaYxq6VYFB//8QAGRABAAMBAQAAAAAAAAAAAAAAAQACERIg/9oACAEBAAEFAnR7ldxNlB8//8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGxAAAQQDAAAAAAAAAAAAAAAAAAEQEiEgMWH/2gAIAQEABj8C4UXtllj/AP/EABsQAAIDAAMAAAAAAAAAAAAAAAABESExIJGh/9oACAEBAAE/IWyy3hF5bjaKJISyUiY++P8A/9oADAMBAAIAAwAAABCIxwD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAfEAACAgIBBQAAAAAAAAAAAAABESExAFFxIEFhgcH/2gAIAQEAAT8QhW0hlrzj6JUFFy64vBrbEotTg0Owv3lcDQhBbkl/On//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"9\" title=\"\" src=\"/static/64afd72f0aa385b61631a29cde698ded/8c797/9.jpg\" srcset=\"/static/64afd72f0aa385b61631a29cde698ded/0913d/9.jpg 160w,\n/static/64afd72f0aa385b61631a29cde698ded/cb69c/9.jpg 320w,\n/static/64afd72f0aa385b61631a29cde698ded/8c797/9.jpg 575w\" sizes=\"(max-width: 575px) 100vw, 575px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이렇게 찾아낸 가장 잘 들어맞는 대상, 다른 패턴으로 연결되는 유일한 사상을 가지고 있는 대상을 합이라고 하며, 만약 카테고리 내에 합이 존재한다면 이 합은 카테고리 내에서 특정한 두 대상의 결합을 나타내는 유일한 방법을 제공한다는 것을 의미한다.</p>\n<blockquote>\n<p>👉 두 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>의 합은 두 개의 삽입 사상을 가진 대상 <code class=\"language-text\">c</code>로 정의된다. 만약 다른 대상 <code class=\"language-text\">c'</code> 또한 두 삽입 사상을 갖추고 있다면, <code class=\"language-text\">c</code>에서 <code class=\"language-text\">c'</code>로 향하는 유일한 사상 <code class=\"language-text\">m</code>이 존재하며, 이는 <code class=\"language-text\">c</code>가 가진 삽입 사상 <code class=\"language-text\">i</code>와 <code class=\"language-text\">j</code>를 인수분해한다.</p>\n</blockquote>\n<p>집합의 카테고리에서 합은 두 집합의 서로소 합집합(Disjoint Union)이다. 집합 <code class=\"language-text\">a</code>와 집합 <code class=\"language-text\">b</code>의 서로소 합집합의 원소는 모두 <code class=\"language-text\">a</code>의 원소이거나 <code class=\"language-text\">b</code>의 원소이다. 만약 두 집합이 겹치는 경우, 서로소 합집합에는 겹치는 부분의 두 복사본이 포함된다. 즉, 서로소 합집합의 원소는 원본을 나타내는 식별자로 일종의 태그가 지정된 것이라고 생각해볼 수 있다.</p>\n<p>프로그래머에게는 타입 관점에서 합을 이해하는 것이 더 쉽게 다가올 수 있다. 이는 두 타입의 태그가 지정된 유니온(Tagged Union)이다. C++은 유니온을 지원하지만, 이들은 태그가 없다. 이는 프로그램에서 어떻게든 어떤 유니온 멤버가 유효한지, 어떻게 추적할지 관리해야 한다는 것을 의미한다.</p>\n<p>태그가 지정된 유니온을 생성하려면 먼저 Enum(tag)을 정의하고 유니온과 결합해야한다. 예를 들어 <code class=\"language-text\">int</code>와 <code class=\"language-text\">char const *</code>의 태그가 지정된 유니온은 아래와 같이 구현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Contact</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">enum</span> <span class=\"token punctuation\">{</span> isPhone<span class=\"token punctuation\">,</span> isEmail <span class=\"token punctuation\">}</span> tag<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> phoneNum<span class=\"token punctuation\">;</span> <span class=\"token keyword\">char</span> <span class=\"token keyword\">const</span> <span class=\"token operator\">*</span> emailAddr<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이때 두 삽입 사상은 생성자 또는 함수로 구현할 수 있다. 예를 들어 첫 번째 삽입 사상을 함수 <code class=\"language-text\">PhoneNum</code>으로 구현해본다면 아래와 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Contact <span class=\"token function\">PhoneNum</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tContact c<span class=\"token punctuation\">;</span>\n\t\tc<span class=\"token punctuation\">.</span>tag <span class=\"token operator\">=</span> isPhone<span class=\"token punctuation\">;</span>\n\t\tc<span class=\"token punctuation\">.</span>phoneNum <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 정수를 <code class=\"language-text\">Contact</code>에 삽입하는 역할을 한다.</p>\n<p>이렇게 태그가 지정된 유니온은 때로 변형(Variant)라고도 불리며, <code class=\"language-text\">boost:variant</code> 클래스 템플릿에서 이러한 변형에 대한 기능을 제공받을 수 있다.</p>\n<p>Haskell에서는 수직바(<code class=\"language-text\">|</code>)로 데이터 생성자를 구분하여 어떤 데이터 형식이든 태그가 지정된 유니온으로 결합할 수 있다. 방금 C++로 만들어본 <code class=\"language-text\">Contact</code>는 Haskell에서 아래와 같은 선언으로 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Contact</span> <span class=\"token operator\">=</span> <span class=\"token constant\">PhoneNum</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">|</span> <span class=\"token constant\">EmailAddr</span> <span class=\"token constant\">String</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">PhoneNum</code> 과 <code class=\"language-text\">EmailAddr</code>은 생성자(삽입 사상)와 패턴 매칭에 대한 태그로 사용된다. 아직 잘 이해가 되지 않겠지만 이는 나중에 더 알아보도록 하겠다.</p>\n<p>예를 들어 전화번호를 사용하여 연락처를 생성하는 방법은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">helpdesk</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Contact</span><span class=\"token punctuation\">;</span>\n<span class=\"token hvariable\">helpdesk</span> <span class=\"token operator\">=</span> <span class=\"token constant\">PhoneNum</span> <span class=\"token number\">2222222</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Haskell에 기본적으로 내장된 곱의 표준 구현과 다르게 합의 표준 구현은 <code class=\"language-text\">Either</code>라는 데이터 타입이며, 이는 표준 Prelude에 정의되어있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Right</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Either</code>는 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 두 타입을 나타내는 매개변수와 두 생성자를 가진 데이터 타입이다. <code class=\"language-text\">Left</code>는 <code class=\"language-text\">a</code> 타입의 값을 나타내며 <code class=\"language-text\">Right</code>는 <code class=\"language-text\">b</code> 타입의 값을 나타낸다.</p>\n<p>우리가 곱에 대해서 <code class=\"language-text\">factorizer</code>라는 함수로 정의한 것과 마찬가지로, 합에 대해서도 함수를 정의해볼 수 있다. 후보 대상인 <code class=\"language-text\">c</code>와 두 후보 삽입 사상 <code class=\"language-text\">i</code>, <code class=\"language-text\">j</code>가 주어진다면, <code class=\"language-text\">Either</code>를 사용하여 함수를 만들어볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorizer</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span>\n<span class=\"token hvariable\">factorizer</span> <span class=\"token hvariable\">i</span> <span class=\"token hvariable\">j</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Left</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">i</span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">factorizer</span> <span class=\"token hvariable\">i</span> <span class=\"token hvariable\">j</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Right</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">j</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h2 id=\"57-비대칭성asymmetry\" style=\"position:relative;\">5.7 비대칭성(Asymmetry)<a href=\"#57-%EB%B9%84%EB%8C%80%EC%B9%AD%EC%84%B1asymmetry\" aria-label=\"57 비대칭성asymmetry permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇게 쌍대성을 가진 두 개의 집합을 살펴보았다. 종결 대상의 정의는 초기 대상의 정의에서 화살표의 방향을 반대로 하여 얻을 수 있으며, 이와 유사하게 합의 정의는 곱의 정의를 뒤집음으로써 만들어볼 수 있다.</p>\n<p>하지만 집합의 카테고리에서 초기 대상은 최종 대상과는 매우 다르며, 합 또한 곱과 다르다. 추후 우리는 곱셈처럼 작동하는 곱집합의 정의에서 종결 대상이 1의 역할을 하고, 덧셈처럼 작동하는 합집합의 정의에서는 초기 대상이 0의 역할을 하는 것을 살펴볼 것이다.</p>\n<p>특히 유한 집합의 경우 곱집합의 크기는 개별 집합의 크기를 곱한 것과 같으며, 합집합의 크기는 개별 집합의 크기를 더한 것과 같다. 이는 집합의 카테고리가 화살표의 반전에 대해서 대칭적으로 작동하지 않는다는 사실을 보여준다.</p>\n<p>여기서 주의해야 할 점은 공집합이 어떤 집합에 대해 고유한 사상(<code class=\"language-text\">absured</code> 함수)을 가질 수는 있지만, 이 사상에 대한 역사상은 존재하지 않는다는 것이다. 단일원소집합은 어떤 집합에서 자신에게로 향하는 고유한 사상을 가지고 있지만, 자신에게서 공집합을 제외한 다른 모든 집합으로 향하는 사상 또한 가지고 있다. 종결 대상에서부터 다른 곳으로 향하는 사상은 다른 집합의 원소를 선택하는 매우 중요한 역할을 하지만, 공집합에는 원소가 없기 때문에 선택할 수 있는 것이 없다.</p>\n<p>바로 이러한 단일원소집합과 곱집합의 관계가 합집합과의 차별점이다. Unit 타입 <code class=\"language-text\">()</code> 으로 표현되는 단일원소집합을 곱 패턴의 후보로 생각해보자. 그럼 이제 단일원소집합은 자신으로부터 구성 요소 집합으로 향하는 투영 사상 <code class=\"language-text\">p</code>와 <code class=\"language-text\">q</code>를 가지게 된다.</p>\n<p>결국 이 두 사상들이 표현하고 있는 행위는 곱집합의 원소를 구성하는 구성요소 중 하나를 선택하는 것이다. 또한 곱집합은 보편적 구성을 따르기 때문에 우리가 정한 후보인 단일원소집합으로부터 곱집합으로 향하는 유일한 사상 <code class=\"language-text\">m</code>도 존재할 것이다. 이 사상은 곱집합에서 특정 원소, 즉 구체적인 하나의 쌍을 선택할 것이며, 이 사상으로 두 투영 사상을 인수분해할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fst</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m</span>\n<span class=\"token hvariable\">q</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">snd</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">m</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이를 단일원소집합의 유일한 원소인 값 <code class=\"language-text\">()</code>에 대입해보면 위의 식은 아래와 같이 변형될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">p</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">fst</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">m</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">q</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">snd</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">m</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">m ()</code>은 사상 <code class=\"language-text\">m</code>에 의해 선택된 곱집합의 원소이므로 이 식들은 <code class=\"language-text\">p</code>가 첫번째 집합에서 선택한 요소, 즉 <code class=\"language-text\">p ()</code>가 <code class=\"language-text\">m</code>에 의해 선택된 쌍의 첫번째 구성요소와 동일하다는 것을 나타낸다. 마찬가지로 <code class=\"language-text\">q ()</code>는 두번째 구성요소와 동일할 것이다. 이는 곱집합의 원소가 각 구성 집합의 원소로 이루어진 쌍이라는 개념과 완전히 일치한다.</p>\n<p>하지만 합에 대해서는 이렇게 간단한 해석이 불가능하다. 물론 단일원소집합을 합의 후보로 삼아 원소를 추출하려고 해볼 수는 있겠지만, 여기에는 단일원소집합에서 다른 구성요소집합으로 향하는 두 투영 사상이 아니라 다른 구성요소집합에서 단일원소집합으로 향하는 두 삽입 사상이 필요하다. 하지만 이 삽입 사상들은 원본의 정보에 대해 아무것도 알려주지 않을 것이다. 이는 앞서 살펴본 삽입 사상의 <code class=\"language-text\">factorizer</code>의 구현을 보면 이 함수가 입력된 매개변수 중 하나를 무시하고 있다는 사실에서 알 수 있다. 마찬가지로 합집합에서 단일원소집합으로 향하는 유일한 사상도 아무런 정보를 주지 못한다.</p>\n<p>결국 집합의 카테고리는 초기 대상의 방향에서 바라볼 때와 종결 대상의 방향에서 바라볼 때 다르게 보일 수 있다는 것이다. 이것은 일반적으로 수학에서의 집합이 가지는 본질적인 특성이라기보다는 모든 집합이 대상으로 정의되는 카테고리 이론에서 사상으로 사용되는 함수의 특성이다.</p>\n<p>함수는 일반적으로 비대칭적이다. 함수는 정의역 집합의 모든 원소에 대해서 정의되어야 한다만, 공역 집합의 모든 원소에 대해 대응될 필요는 없다. 방금 우리는 이러한 함수의 특성 중 극단적인 몇 가지를 살펴본 것이다. 결국 단일원소집합을 정의역으로 가지는 함수들은 공역 집합에서 딱 하나의 원소만 선택하는 함수들이다.</p>\n<p>우리는 종종 정의역 집합의 크기가 공역 집합의 크기보다 훨씬 작을 때, 이러한 함수들이 정의역 집합을 공역 집합에 포함시키는 행위라고 생각한다. 예를 들어 우리는 단일원소집합을 정의역으로 가진 함수가 정의역 집합이 가진 단 하나의 원소를 공역 집합에 포함시키는 것이라고 생각할 수 있다. 필자는 이들을 포함 함수(Embedding Functions)라고 부르지만, 수학자들은 이와 반대 시각을 가진 개념을 통해 이름을 부여했다. 이렇게 정의역을 공역에 꽉 채워넣을 수 있는 함수들을 “전사 함수(Surjective Functions)” 또는 “위로의 함수(Onto Functions)”라고 한다.</p>\n<p>다른 비대칭성의 원인은 함수가 정의역 집합 있는 여러 원소들을 공역 집합에 있는 하나의 원소로도 매핑할 수 있다는 점이다. 즉 함수는 이러한 원소들을 축소할 수 있다고 보는 것이다. 이에 대한 극단적인 예시는 정의역 집합에 있는 모든 원소를 공역 집합의 단 하나의 원소로 매핑하는 함수들이다. 이전에 보았던 <code class=\"language-text\">unit :: a -> ()</code>의 정의를 가진 다형적 유닛 함수(Polymorphic Unit Function)이 바로 이 역할을 한다. 이러한 축소 행위는 합성을 통해 더 강화될 수 있다. 두 개의 축소 함수를 합성하는 것은 각각의 개별 함수보다 더 많은 축소 행위를 만들어낼 수 있다. 수학자들은 이렇게 축소되지않는 함수에 대해서 특별한 이름을 붙혔는데, 이를 “단사 함수(Injective Functions)” 또는 “일대일 함수(One-to-one Functions)”라고 부른다.</p>\n<p>물론 이렇게 포함도 축소도 아닌 일부 함수들도 존재한다. 이들은 “전단사 함수(Bijection Functions)”라고 불린다. 이 함수들은 전사, 단사 함수와는 다르게 대칭적이며, 이에 따라 역함수도 존재할 수 있다. 집합의 카테고리에서는 동형사상(Isomorphism)이 전단사 함수와 동일한 개념이다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240227-category-theory-for-programmers-5-products-and-coproducts","path":"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 5. 곱과 합","subTitle":null,"date":"Feb 27, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"610888fd-70a9-5b54-a6f0-bbcaf8d1d8c9","tableOfContents":"<ul>\n<li><a href=\"#41-writer-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\">4.1 Writer 카테고리</a></li>\n<li><a href=\"#42-%ED%95%98%EC%8A%A4%EC%BC%88%EC%9D%98-writer\">4.2 하스켈의 Writer</a></li>\n<li><a href=\"#43-%ED%81%AC%EB%9D%BC%EC%9D%B4%EC%8A%AC%EB%A6%AC-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACkleisli-categories\">4.3 크라이슬리 카테고리(Kleisli Categories)</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"우리는 지금까지 타입과 순수 함수들을 카테고리로 모델링하는 방법을 살펴봤다. 앞서 필자는 카테고리 이론에서 사이드 이펙트나 순수하지 않은 함수를 모델링하는 방법이 있다고 이야기했었는데, 어떠한 실행과정을 추적하거나 로깅하는 함수를 예시로 들어 이 방법에 대해 한번 살펴보도록 하자. 우리가 명령형 언어를 사용하여 무언가를 구현할 때는 일반적으로 전역 상태를 선언하고 변경해가며 구현하게 된다. 이 함수는 자신의 외부 세계에 선언되어있는 를 변경한다는 사이드이펙트를 가지고 있기 때문에 순수함수가 아니다. 모던 프로그래밍의 세계에서는 가…","html":"<p>우리는 지금까지 타입과 순수 함수들을 카테고리로 모델링하는 방법을 살펴봤다. 앞서 필자는 카테고리 이론에서 사이드 이펙트나 순수하지 않은 함수를 모델링하는 방법이 있다고 이야기했었는데, 어떠한 실행과정을 추적하거나 로깅하는 함수를 예시로 들어 이 방법에 대해 한번 살펴보도록 하자.</p>\n<p>우리가 명령형 언어를 사용하여 무언가를 구현할 때는 일반적으로 전역 상태를 선언하고 변경해가며 구현하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">string logger<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     logger <span class=\"token operator\">+=</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span>b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 자신의 외부 세계에 선언되어있는 <code class=\"language-text\">logger</code>를 변경한다는 사이드이펙트를 가지고 있기 때문에 순수함수가 아니다.</p>\n<p>모던 프로그래밍의 세계에서는 가급적이면 변경 가능한 전역 상태를 사용하지 않기 위해 노력하는데, 다른 것은 둘째치고 동시성의 복잡성때문에라도 이러한 행위는 최대한 피해야 한다. 아마 독자 여러분도 이런 코드를 라이브러리에 넣고 싶지는 않을 것이라 생각한다.</p>\n<p>다행히도 이 함수는 순수함수로 변경될 수 있는 가능성이 있다. 그저 함수에게 <code class=\"language-text\">logger</code>를 명시적으로 전달하기만 하면 된다. 즉, 함수에 하나의 문자열 인수를 추가함으로써 함수의 출력과 로그가 포함된 문자열을 짝지어볼 수 있는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">,</span> string logger<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>b<span class=\"token punctuation\">,</span> logger <span class=\"token operator\">+</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이제 이 함수는 사이드 이펙트를 발생시키지 않기 때문에 순수하다. 동일한 인수가 주어졌을 때 항상 동일한 값의 쌍을 출력하며, 이러한 특성으로 인해 필요한 경우에는 메모이제이션 할 수도 있다. 그러나 메모이제이션을 할 경우 이전 값을 토대로 다음 값을 생성한다는 누산적인 로그의 특성으로 인해, 결국은 이 함수가 호출되기까지의 모든 이력을 메모이제이션해야 할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"It was the best of times. \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 또는</span>\n<span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"It was the worst of times. \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p><strong>💡 역주</strong></p>\n<p>여기서 작가는 누산적인 연산을 한다는 로그의 특성으로 인해 메모이제이션을 하나마나라는 이야기를 하고 있다. negate 함수는 “이전 로그”를 받아 “Not so! “라는 문자열을 이어붙히는 방식으로 새로운 로그 문자열을 생성하여 반환하는데, 이는 결국 negate 함수가 반환하는 로그 문자열이 negate 함수가 호출되기 이전의 로그 상태의 영향을 받는다는 의미이다.</p>\n<p>아무리 negate 함수가 참조 투명성을 보장하는 순수함수라도, 결국 함수의 호출 맥락이라는 것은 상황에 따라 달라질 수 있기 때문에 negate 함수가 반환하는 로그 문자열 또한 매번 달라질 가능성이 크다. 그로 인해 이를 메모이제이션하는 것은 큰 의미가 없어지는 것이다.</p>\n</blockquote>\n<p>이러한 설계는 라이브러리 함수로써 좋은 설계라고 볼 수도 없다. 함수 호출자는 이 함수가 반환하는 로그 문자열을 무시할 수 있으니 출력 형태에 대해서는 큰 문제가 없겠지만, 입력에 대해서는 다르다. 로그가 필요없는 상황에도 매번 호출자가 특정한 로그 문자열을 함수에게 직접 전달해줘야 하기 때문이다.</p>\n<p>그렇다면 관심사를 분리하는 방법을 통해 이 함수를 조금 더 편하게 호출할 수 있는 방법은 없을까? 결국 위 예시에서 negate 함수의 주 목적은 인수로 받은 하나의 Boolean 값을 다른 Boolean 값으로 변환하는 것이며, 로깅은 그저 보조적인 역할만 수행한다. 물론 이 로그에 기록되는 메세지가 함수의 목적에 특화되어 있기는 하지만, 결국 어떠한 메세지를 하나의 로그로 통합하는 작업 자체는 negate 함수의 주 목적과는 별개의 관심사이다. 즉, 우리는 로깅에 대한 관심사를 분리해야 한다.</p>\n<p>그렇다면 이런 방법으로 타협을 볼 수 있을 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>b<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>결국 이 아이디어는 함수가 호출될 때마다 로그를 계속 쌓는다는 컨셉에서 출발한다. 이제 이 아이디어를 어떻게 구현할 수 있을지 알아보기 위해 약간 더 현실적인 예제를 보도록하자.</p>\n<p>여기 어떤 문자열을 받아 소문자를 대문자로 변경하는 함수가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">string <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    string result<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>toupper<span class=\"token punctuation\">;</span> <span class=\"token comment\">// toupper is overloaded</span>\n    <span class=\"token function\">transform</span><span class=\"token punctuation\">(</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">back_inserter</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 두번째 함수는 인수로 받은 문자열을 공백을 기준으로 나누어 벡터를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">toWords</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">words</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">toWords</code> 함수의 실제 동작은 <code class=\"language-text\">words</code> 함수에서 수행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">words</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> result<span class=\"token punctuation\">{</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> i <span class=\"token operator\">=</span> <span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">!=</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isspace</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            result<span class=\"token punctuation\">.</span><span class=\"token function\">back</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+=</span> <span class=\"token operator\">*</span>i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>우리는 <code class=\"language-text\">toUpper</code> 함수와 <code class=\"language-text\">toWords</code> 함수를 수정하여 문자열 메세지를 이 함수들의 반환값과 함께 묶어 표현하고 싶다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 300px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/01933c7eafd8f72afd7f176b92dbd607/f93b5/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 106.87500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAVABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAMFAQIE/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAbblngSyC41CQH//xAAbEAACAgMBAAAAAAAAAAAAAAABAgMRABASIv/aAAgBAQABBQKVqwSt0DYkj9MrYBQYWOBr/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAHBAAAgEFAQAAAAAAAAAAAAAAAREAAhASIWEy/9oACAEBAAY/Ava5A2LCqlDe3AMwYooOW//EAB4QAAICAgIDAAAAAAAAAAAAAAERACExQRBhcYGx/9oACAEBAAE/IVXg03CwWsFK4JwIPiKNuwIZaidfYIYagXH6iaV04//aAAwDAQACAAMAAAAQtA88/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHhABAQACAgIDAAAAAAAAAAAAAREAMSFBYXEQgaH/2gAIAQEAAT8QhUlUC8usmlWJB+3XnBhjVVL3iSBF0F6d/nnOM1+Lt9nzkRIJqYjQDusGIVogL7+P/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/01933c7eafd8f72afd7f176b92dbd607/f93b5/1.jpg\" srcset=\"/static/01933c7eafd8f72afd7f176b92dbd607/0913d/1.jpg 160w,\n/static/01933c7eafd8f72afd7f176b92dbd607/f93b5/1.jpg 300w\" sizes=\"(max-width: 300px) 100vw, 300px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>우리는 이제 이 함수들의 반환값을 아름답게 꾸며볼 것이다. 가장 먼저 임의의 타입 A인 값이 첫 번째 요소이고 문자열이 두 번째 요소인 쌍을 캡슐화하는 템플릿 <code class=\"language-text\">Writer</code>를 정의함으로써 이 문제를 일반화하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">using</span> Writer <span class=\"token operator\">=</span> pair<span class=\"token operator\">&lt;</span>A<span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이제 <code class=\"language-text\">Writer</code>를 사용하여 각 함수들을 꾸며줄 차례이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span> <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    string result<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>toupper<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">transform</span><span class=\"token punctuation\">(</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">end</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">back_inserter</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> toupperp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token string\">\"toUpper \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nWriter<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">toWords</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token function\">words</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"toWords \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 이 두 함수를 조합하여 문자열을 대문자로 변환하고 공백을 기준으로 나눠주는 함수를 꾸며보자. 바로 이 과정에서 이 작업에 대한 로그를 생성할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">auto</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">toUpper</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">auto</span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">toWords</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 처음의 목표를 달성했다. 각각의 로그를 합치는 것은 이제 더 이상 개별 함수들의 관심사가 아니다. 각 함수들은 자체적으로 자신과 관련된 메세지를 생성할 뿐이고, 이 개별 함수들의 외부에서 이러한 메세지들을 합쳐 더 큰 로그를 만들어낸다.</p>\n<p>이제 이러한 스타일로 작성된 거대한 프로그램을 한번 상상해보자. 아마 이러한 패턴을 계속해서 반복하게되면 오류가 발생하기 쉬운 악몽과도 같은 코드가 될 것이다. 하지만 우리는 프로그래머이기 때문에 이런 반복적인 코드를 추상화를 사용하여 우아하게 해결하는 일에 이미 익숙하다. 그러나 이것은 우리가 지금까지 알던 추상화와는 약간 다르다. 바로 함수의 합성이라는 개념 자체를 추상화해야하기 때문이다.</p>\n<p>결국 합성이라는 개념은 카테고리 이론의 본질이니, 코드를 더 작성하기 전에 일단 카테고리 이론의 관점에서 이 문제를 한번 분석해보자.</p>\n<h2 id=\"41-writer-카테고리\" style=\"position:relative;\">4.1 Writer 카테고리<a href=\"#41-writer-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC\" aria-label=\"41 writer 카테고리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수들의 반환 타입을 꾸며 추가 기능을 끼워넣을 수 있다는 아이디어는 우리에게 큰 가치를 가져다준다. 이제 이에 대한 더 많은 예제를 한번 보도록 하자. 대상을 타입으로 가지고 사상은 우리가 꾸며주었던 함수로 가지는 일반적인 카테고리에서부터 시작해보는 것이 좋겠다.</p>\n<p>예를 들어 <code class=\"language-text\">int</code> 타입에서 <code class=\"language-text\">bool</code> 타입으로 향하는 <code class=\"language-text\">isEven</code> 함수를 꾸며본다고 생각해보자. 가장 먼저 카테고리의 사상을 우리가 앞서 꾸며보았던 함수로 다시 표현해볼 것이다. 여기서 중요한 점은 이 함수가 비록 <code class=\"language-text\">pair&lt;bool, string></code> 타입을 반환한다고 해도 카테고리 내에서는 여전히 <code class=\"language-text\">int</code> 대상과 <code class=\"language-text\">bool</code> 대상 사이의 화살표로 간주된다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">isEven</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"isEven \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>카테고리 법칙에 의하면 우리는 이 사상을 다른 사상과 합성하여 대상 <code class=\"language-text\">bool</code>에서 다른 대상으로 향하는 사상을 만들 수 있어야 한다. 여기서는 앞서 정의했던 <code class=\"language-text\">negate</code> 함수와 합성하는 상황을 한번 보도록 하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>b<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Not so! \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>물론 <code class=\"language-text\">isEven</code> 함수와 <code class=\"language-text\">negate</code> 함수는 서로의 입력과 출력 타입이 일치하지 않기 때문에 이 두 개의 사상을 일반적인 함수와 같은 방식으로 합성할 수는 없다. 이 두 사상의 합성은 아래와 같이 표현해줘야 할 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> <span class=\"token function\">isOdd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">isEven</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tpair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">,</span> string<span class=\"token operator\">></span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">negate</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 카테고리에서 두 개의 사상을 합성하는 과정은 다음과 같다.</p>\n<hr>\n<ol>\n<li>첫 번째 사상에 해당하는 함수를 실행시킨다. 위 예시에서는 <code class=\"language-text\">isEven(n)</code>에 해당한다.</li>\n<li>첫 번째 함수가 반환한 값의 쌍에서 첫 번째 요소를 추출하고, 이 요소를 두 번째 사상에 해당하는 함수에 전달한다. 위 예시에서는 <code class=\"language-text\">negate(p1.first)</code>에 해당한다.</li>\n<li>첫 번째 사상과 두 번째 사상이 반환한 로그 문자열, 즉 각 함수가 반환한 쌍에서 두 번째 요소를 추출하여 직접 연결해준다.</li>\n<li>위 과정을 통해 얻어낸 값과 연결한 로그 문자열을 사용하여 새로운 쌍을 만들어 반환한다. 위 예시에서는 <code class=\"language-text\">make_pair(p2.first, p1.second + p2.second)</code>에 해당한다.</li>\n</ol>\n<hr>\n<p>만약 이 과정을 C++의 고차함수로 추상화하려면 이 카테고리가 가진 세 개의 대상을 타입 변수로 표현한 템플릿을 사용해야한다. 그리고 결과값과 로그 문자열 쌍을 반환하는 두 개의 함수를 가져와 합성하고, 마지막으로 새로운 쌍을 만드는 함수를 반환하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token operator\">></span>\n\nfunction<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">Writer</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>C<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>function<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">Writer</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>B<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> m1<span class=\"token punctuation\">,</span>\n                               function<span class=\"token operator\">&lt;</span><span class=\"token generic-function\"><span class=\"token function\">Writer</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>C<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span><span class=\"token operator\">></span> m2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>m1<span class=\"token punctuation\">,</span> m2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>A x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">m1</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">m2</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기까지 왔으면 이제 거의 끝났다. 이제 이 템플릿을 사용하여 원래 우리가 합성하려고 했던 <code class=\"language-text\">toUpper</code> 함수와 <code class=\"language-text\">toWords</code> 함수의 합성을 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>string<span class=\"token punctuation\">,</span> string<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span></span></span><span class=\"token punctuation\">(</span>toUpper<span class=\"token punctuation\">,</span> toWords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>하지만 아직도 <code class=\"language-text\">compose</code> 템플릿에 타입을 전달하는 과정이 번거로워 보인다. 이는 C++14 호환 컴파일러에서 지원하는 반환 타입 추론 기능을 지원하는 람다 함수를 사용함으로써 해결해볼 수 있다. (아래 코드의 작성자는 Eric Niebler이다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> <span class=\"token keyword\">const</span> compose <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> m1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">auto</span> m2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>m1<span class=\"token punctuation\">,</span> m2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p1 <span class=\"token operator\">=</span> <span class=\"token function\">m1</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">auto</span> p2 <span class=\"token operator\">=</span> <span class=\"token function\">m2</span><span class=\"token punctuation\">(</span>p1<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">,</span> p1<span class=\"token punctuation\">.</span>second <span class=\"token operator\">+</span> p2<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 타입 추론을 지원하도록 정의된 <code class=\"language-text\">compose</code> 함수를 사용하여 함수를 더 간단하게 합성해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">>></span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>string s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>toUpper<span class=\"token punctuation\">,</span> toWords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>아직 끝난 것이 아니다. 우리는 지금까지 카테고리 내 사상의 합성만 정의한 것이고 아직 항등 사상에 대한 것은 정의하지 않았다. 이 항등 사상은 일반적인 항등 함수와는 약간 다르다. 이들은 타입 A로부터 다시 타입 A로 돌아가는 사상이기 때문에 아래와 같은 타입 선언을 가질 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">Writer<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token function\">identity</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 항등 사상은 합성에 대한 항등원처럼 작동해야한다. 우리가 정의해놓은 로직의 합성 과정에 의하면 이 항등 사상은 자신이 인수로 받은 값을 변경하지도 않고, 로그에는 빈 문자열만 기록하는 방식으로 정의해야 할 것 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span><span class=\"token operator\">></span> Writer<span class=\"token operator\">&lt;</span>A<span class=\"token operator\">></span> <span class=\"token function\">identity</span><span class=\"token punctuation\">(</span>A x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 정의한 카테고리는 카테고리가 지켜야하는 모든 조건들을 만족하고 있다. 특히 이 카테고리의 합성은 명확하게 결합법칙을 만족하고 있다. 각 함수들이 반환하는 값의 쌍 중 첫 번째 요소만 보면 일반적인 함수의 합성으로 바라볼 수 있으며, 이 연산은 결합법칙을 만족한다. 또한 두 번째 요소인 로그 문자열에 대한 연산은 그저 문자열의 연결일 뿐이니 이 또한 결합법칙을 만족한다.</p>\n<p>여기서 영리한 독자라면 우리가 이 구조를 문자열 모노이드 뿐 아니라 어떤 모노이드에던 일반화해서 적용할 수 있다는 사실을 알아차렸을 것이다. <code class=\"language-text\">compose</code> 함수에서 <code class=\"language-text\">+</code> 연산자 대신 <code class=\"language-text\">mappend</code>를, 그리고 <code class=\"language-text\">identity</code> 함수에서는 <code class=\"language-text\">\"\"</code>라는 값 대신에 <code class=\"language-text\">mempty</code>를 사용하기만 하면 된다.</p>\n<p>반드시 문자열을 다룰 때에만 한해서 로깅을 한다는 법은 없다. 좋은 라이브러리 작성자는 라이브러리가 동작하는 데 필요한 최소한의 제약 조건을 식별할 수 있어야 한다. 우리가 만든 로깅 라이브러리의 유일한 요구 사항은 그저 로그라는 개념이 모노이드적인 특성을 가져야 한다는 것이다.</p>\n<h2 id=\"42-하스켈의-writer\" style=\"position:relative;\">4.2 하스켈의 Writer<a href=\"#42-%ED%95%98%EC%8A%A4%EC%BC%88%EC%9D%98-writer\" aria-label=\"42 하스켈의 writer permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 구현했던 것들을 Haskell에서는 조금 더 간결하게 작성할 수 있고 컴파일러로부터 더 많은 도움을 받을 수 있기도 하다.</p>\n<p>일단 <code class=\"language-text\">Writer</code> 타입을 정의하는 것부터 시작해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서는 단순히 타입 별칭(Type Alias)을 정의하고 있으며, 이것은 C++의 <code class=\"language-text\">typedef</code> 또는 <code class=\"language-text\">using</code>과 동일한 기능이다. <code class=\"language-text\">Writer</code> 타입은 타입 변수 <code class=\"language-text\">a</code>를 받아 <code class=\"language-text\">a</code> 타입과 <code class=\"language-text\">String</code> 타입의 쌍을 반환한다. 이 문법은 쌍을 의미하는 괄호 안에 두 개의 요소가 존재하고, 이 요소들이 쉼표로 부분되는 최소한의 형태로만 이루어져있다.</p>\n<p>이 카테고리에서의 사상은 임의의 타입에서 다른 타입을 매개변수로 가지는 <code class=\"language-text\">Writer</code> 타입으로 나아가는 함수라고 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이제 “fish”라고도 불리는 재미있는 중위 연산자(Infix Operator)를 사용하여 합성을 정의할 차례이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">>=></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 연산자는 두 개의 인수를 받아 합성하는 함수이며, 이 인수들은 합성의 대상이 되는 함수들이고 최종적으로는 합성된 함수를 반환한다. 첫 번째 인수는 <code class=\"language-text\">(a -> Writer b)</code> 타입, 두 번째 인수는 <code class=\"language-text\">(b -> Writer c)</code> 타입이며, 최종 반환 결과는 <code class=\"language-text\">(a -> Writer c)</code> 타입을 가진다.</p>\n<p>아래 예시는 <code class=\"language-text\">m1</code> 이라는 인수와 <code class=\"language-text\">m2</code>라는 인수를 받았을 때 이 중위 연산자가 어떻게 작동하는지를 보여준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">m1</span> <span class=\"token operator\">>=></span> <span class=\"token hvariable\">m2</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m1</span> <span class=\"token hvariable\">x</span>\n        <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">m2</span> <span class=\"token hvariable\">y</span>\n    <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">z</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">s1</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s2</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>연산의 결과는 <code class=\"language-text\">x</code>라는 하나의 인수를 받는 람다 함수이다. 람다 함수는 역슬래시(<code class=\"language-text\">\\</code>)로 표현할 수 있다. 기억하기 어렵다면 다리를 하나 잃은 그리스 문자 λ(Lambda)라고 생각하자.</p>\n<p><code class=\"language-text\">let</code> 표현을 사용하면 함수 내의 지역변수를 선언할 수 있다. 여기서 <code class=\"language-text\">m1</code> 함수의 호출 결과는 <code class=\"language-text\">(y, s1)</code> 변수에 담기고, 이 변수에서 가져온 <code class=\"language-text\">y</code> 인자를 사용하여 호출된 <code class=\"language-text\">m2</code> 함수의 호출 결과는 <code class=\"language-text\">(z, s2)</code> 변수에 담긴다.</p>\n<p>이처럼 Haskell에서는 C++에서 <code class=\"language-text\">p1.first</code> 같이 접근자를 사용했던 것과는 다르게, <code class=\"language-text\">(y, s1) = m1 x</code> 처럼 패턴 매칭하여 쌍을 분해하는 방법을 주로 사용한다. 이 외에도 두 언어의 기능 간에는 이렇게 직관적으로 대응해볼 수 있는 관계가 꽤 존재한다.</p>\n<p>위 함수의 <code class=\"language-text\">let</code> 표현식에서 선언된 변수들은 함수 동작의 구현을 의미하는 <code class=\"language-text\">in</code>절에서 접근할 수 있다. 즉 <code class=\"language-text\">in</code>절 내부에서 접근한 변수들은 <code class=\"language-text\">let</code> 표현식 내부에서 선언된 값들이며, 최종적으로 첫 번째 요소는 <code class=\"language-text\">z</code> 이고, 두 번째 요소는 두 문자열의 연결인 <code class=\"language-text\">s1 ++ s2</code>로 구성된 쌍을 만들어내고 이쓴 것이다.</p>\n<p>이런 합성 외에도 우리의 카테고리 내부에 존재해야하는 항등 사상도 정의를 해야하겠지만 이건 조금 이따 보도록 하겠다. 일단 항등사상은 <code class=\"language-text\">return</code> 이라고 네이밍하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">return</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">return</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>자 이제 원래 합성하려고 했던 대상인 <code class=\"language-text\">upCase</code> 와 <code class=\"language-text\">toWords</code> 함수의 Haskell 버전을 추가하면 거의 다 완성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">upCase</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">upCase</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">map</span> <span class=\"token builtin\">toUpper</span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"upCase \"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token hvariable\">toWords</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">toWords</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">words</span> <span class=\"token hvariable\">s</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"toWords \"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">map</code> 함수는 C++의 <code class=\"language-text\">transform</code>에 해당한다. 이 함수는 문자열 <code class=\"language-text\">s</code> 에 <code class=\"language-text\">toUpper</code> 함수를 적용한다. 그리고 <code class=\"language-text\">words</code> 함수는 표준 Prelude 라이브러리에 이미 정의되어있다.</p>\n<p>최종적으로 이 두 함수의 합성은 앞서 정의했던 fish 연산자를 사용하여 간단하게 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">process</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Writer</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">String</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">process</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">upCase</span> <span class=\"token operator\">>=></span> <span class=\"token hvariable\">toWords</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h2 id=\"43-크라이슬리-카테고리kleisli-categories\" style=\"position:relative;\">4.3 크라이슬리 카테고리(Kleisli Categories)<a href=\"#43-%ED%81%AC%EB%9D%BC%EC%9D%B4%EC%8A%AC%EB%A6%AC-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACkleisli-categories\" aria-label=\"43 크라이슬리 카테고리kleisli categories permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이러한 카테고리는 필자가 직접 고안해낸 것이 아니다. 이는 모나드라는 개념에서 기반한 크라이슬리 카테고리(Kleisli Category)의 한 예시이다. 아직 우리가 모나드에 대해 자세히 논의하기에는 조금 이르긴 하지만, 모나드가 어떤 역할을 하는지에 대해서 간략하게 살펴봤다고 생각하면 된다.</p>\n<p>크라이슬리 카테고리는 프로그래밍 언어의 타입들을 대상으로 가진다. 그리고 타입 A에서 타입 B로 나아가는 사상은 타입 A에서 특정 “장식(Embellishment)”를 적용하여 B로 나아가는 함수라고 볼 수 있다.</p>\n<p>모든 크라이슬리 카테고리는 이러한 사상들을 고유한 방법으로 합성하는 방법을 정의하고, 이러한 합성에 대한 항등 사상 또한 정의할 수 있다. (추후 이 애매한 “장식”이라는 용어가 카테고리의 엔도펑터(Endofunctor)라는 개념을 의미한다는 사실을 설명하겠다.)</p>\n<p>이 챕터에서 함수들의 실행 과정을 추적하고 로깅하기 위해 만들었던 Writer 모나드는 순수함수들의 연산 결과에 이펙트를 포함하기 위한 일반적인 매커니즘의 예시이기도 하다.</p>\n<p>우리는 이전 챕터에서 프로그래밍 언어에서 bottom을 제외한 일반 타입들과 함수들을 집합으로 구성된 카테고리로 모델링하는 방법에 대해서 알아봤다. 그리고 이번에는 이 모델을 기반으로 함수들의 합성이라는 행위가 단지 한 함수의 출력을 다른 함수의 입력으로 전달하는 것뿐 아니라 조금 더 다양한 기능을 포함할 수 있는 카테고리로 발전시켜보았다.</p>\n<p>이제 우리는 함수의 합성을 가지고 놀 때 조금 더 자유로운 아이디어를 표현해볼 수 있게 되었다. 바로 우리가 앞서 알아본 개념들이 지금까지 명령형 언어들이 사이드이펙트를 사용하여 구현해왔던 프로그램에도 표시적 의미론(Denotational Semantics)을 적용할 수 있는 자유를 선물해준 것이다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240220-category-theory-for-programmers-4-kleisli-category","path":"/2024/02/20/category-theory-for-programmers-4-kleisli-category/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 4. 크라이슬리 카테고리","subTitle":null,"date":"Feb 20, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"fc391796-a98c-59b0-ae4c-d43bc2dee153","tableOfContents":"<ul>\n<li><a href=\"#31-%EB%8C%80%EC%83%81%EC%9D%B4-%EC%97%86%EB%8A%94-%EA%B2%BD%EC%9A%B0\">3.1 대상이 없는 경우</a></li>\n<li><a href=\"#32-%EB%8B%A8%EC%88%9C%ED%95%9C-%EA%B7%B8%EB%9E%98%ED%94%84\">3.2 단순한 그래프</a></li>\n<li><a href=\"#33-%EC%B0%A8%EC%88%98\">3.3 차수</a></li>\n<li><a href=\"#34-%EC%A7%91%ED%95%A9%EC%9C%BC%EB%A1%9C%EC%8D%A8%EC%9D%98-%EB%AA%A8%EB%85%B8%EC%9D%B4%EB%93%9C\">3.4 집합으로써의 모노이드</a></li>\n<li><a href=\"#35-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC%EB%A1%9C%EC%8D%A8%EC%9D%98-%EB%AA%A8%EB%85%B8%EC%9D%B4%EB%93%9C\">3.5 카테고리로써의 모노이드</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"우리는 다양한 예시들을 연구해보면서 카테고리에 대한 진정한 이해에 한발짝 더 다가갈 수 있다. 카테고리는 매우 다양한 형태와 크기를 가지고 있기 때문에 종종 전혀 예상하지 못 했던 곳에서 나타나기도 한다. 일단 가장 간단한 것부터 한번 시작해보도록 하자. 3.1 대상이 없는 경우 가장 간단한 카테고리는 어떠한 대상이나 사상을 전혀 가지고 있지 않는 카테고리이다. 이 카테고리만 따로 떼놓고 본다면 별로 쓸모가 없어보이겠지만 다른 카테고리와의 관계에서는 매우 중요한 의미를 가질 수도 있다. 예를 들면 모든 카테고리를 대상으로 가진 카…","html":"<p>우리는 다양한 예시들을 연구해보면서 카테고리에 대한 진정한 이해에 한발짝 더 다가갈 수 있다. 카테고리는 매우 다양한 형태와 크기를 가지고 있기 때문에 종종 전혀 예상하지 못 했던 곳에서 나타나기도 한다. 일단 가장 간단한 것부터 한번 시작해보도록 하자.</p>\n<h2 id=\"31-대상이-없는-경우\" style=\"position:relative;\">3.1 대상이 없는 경우<a href=\"#31-%EB%8C%80%EC%83%81%EC%9D%B4-%EC%97%86%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"31 대상이 없는 경우 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>가장 간단한 카테고리는 어떠한 대상이나 사상을 전혀 가지고 있지 않는 카테고리이다. 이 카테고리만 따로 떼놓고 본다면 별로 쓸모가 없어보이겠지만 다른 카테고리와의 관계에서는 매우 중요한 의미를 가질 수도 있다. 예를 들면 모든 카테고리를 대상으로 가진 카테고리와 빈 카테고리의 관계 같은 것들이 있다. 상상하기 어렵겠지만 이런 카테고리도 분명 존재한다. 만약 여러분이 공집합의 존재 의의에 공감한다면 빈 카테고리도 나름의 의미가 있지 않을까?</p>\n<h2 id=\"32-단순한-그래프\" style=\"position:relative;\">3.2 단순한 그래프<a href=\"#32-%EB%8B%A8%EC%88%9C%ED%95%9C-%EA%B7%B8%EB%9E%98%ED%94%84\" aria-label=\"32 단순한 그래프 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리는 단순히 어떠한 대상을 화살표로 연결하는 것만으로도 카테고리를 만들어볼 수 있다. 한번 임의의 유향 그래프(Directed Graph)에 몇 개의 화살표를 추가하여 카테고리를 만드는 상상을 해보자. 먼저 그래프의 각 노드에 특정 대상으로부터 나와서 다시 자기 자신에게 돌아가는 항등 화살표를 추가한다. 그 다음 한 화살표의 종점 노드가 다른 화살표의 시작 노드와 일치하는 경우에는 이 두 화살표가 합성 가능하다는 사실을 의미하므로, 그 화살표들의 합성을 의미하는 새로운 화살표를 추가한다.</p>\n<p>항등 화살표를 제외하면 우리는 항상 새로운 화살표를 추가할 때마다 추가된 화살표와 다른 화살표들과의 합성 여부에 대한 것들을 고려해야 한다. 이러다보면 무한히 많은 화살표들이 생기겠지만 뭐 딱히 문제는 없다.</p>\n<p>즉 이러한 과정을 통해 우리는 모든 그래프의 노드들은 대상을, 그리고 간선은 합성 가능한 사상을 표현하는 일종의 카테고리를 만들었다고 볼 수 있다. (항등 사상의 경우에는 길이가 0인 특별한 간선이라고 볼 수 있다.)</p>\n<p>이렇게 미리 주어진 그래프에서부터 생성된 카테고리는 자유 카테고리(Free Category)라고 불린다. 즉, 미리 주어진 구조에 최소한의 항목만을 추가하여 원하는 법칙을 만족시킬 수 있는 일종의 자유 구성인 것이다. 여기서 우리가 원하는 법칙이란 결국 카테고리의 법칙일 것이다. 이와 관련된 자세한 내용은 추후 더 알아보도록 하자.</p>\n<h2 id=\"33-차수\" style=\"position:relative;\">3.3 차수<a href=\"#33-%EC%B0%A8%EC%88%98\" aria-label=\"33 차수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자 그러면 이제 완전히 다른 예시를 한번 살펴보자. 이번 카테고리는 대상들간의 사상이 “작거나 같음”으로 나타나는 관계를 가진 카테고리이다.</p>\n<p>먼저 이것이 정말 카테고리가 될 수 있는지부터 확인해보자. 항등 사상이 존재하는가? 모든 대상은 자기 자신보다 작거나 같으므로 답은 참이다. 사상의 합성은 존재하는가? 만약 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a≤b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">b≤c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></span>라면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">a≤c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span></span>일테니 답은 참이다. 합성 간의 결합법칙은 적용되는가? 이도 참이다. 이와 같은 관계를 가진 집합은 원순서(Preorder)라고 하는데, 원순서 집합 또한 카테고리의 모든 조건을 만족시키므로 원순서 집합도 카테고리라고 할 수 있다.</p>\n<p>그럼 여기에 몇 가지 조건을 추가하여 더 강한 관계를 만들어보자. 만약 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a≤b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>이고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">b≤a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>라면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>가 같을 수 밖에 없는 경우도 있다. 이러한 관계는 부분순서(Partial Order)라고 한다.</p>\n<p>또한 우리는 어떠한 두 대상이 서로 상호 관계를 가진다는 조건도 부여할 수 있다. 이 경우에는 전순서(Linear Order 또는 Total Order)라는 개념을 얻을 수 있다.</p>\n<p>자 그럼 이제 이 순서 집합들을 한번 카테고리로 표현해보도록 하자. 원순서 집합은 어떤 대상 a에서 다른 대상 b로 향하는 사상이 최대 1개만 존재하는 카테고리이다. 이러한 카테고리는 “Thin”하다고 표현하며, 원순서 집합은 Thin 카테고리라고 볼 수 있다.</p>\n<p>어떠한 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>가 가진 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>에서 대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>로 향하는 사상들의 집합은 Hom 집합(Hom-set)이라고 하며, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><msub><mi>m</mi><mi>c</mi></msub><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hom_c(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Ho</span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></span>라고 표기한다.</p>\n<p>즉, 원순서 집합에 속한 모든 Hom 집합은 공집합이거나 하나의 원소만을 가지는 단일원소집합이다. 이는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C(a,a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span></span></span></span></span>로 표현되는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>로 향하는 사상 집합인 항등사상 집합 또한 예외는 아니며, 이 집합은 어떤 원순서 집합 내에서도 단 하나의 원소, 즉 항등사상(identity) 하나만을 가지고 있다.</p>\n<p>이러한 원순서 내에서는 한 대상에서 시작한 여러 사상을 거쳐 동일한 대상으로 돌아오는 사이클이라는 개념이 성립할 수 있지만, 부분순서 내에서는 이러한 사이클이 성립될 수 없다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>원순서와 다르게 부분순서는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a≤b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>이고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">b≤a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>라면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></span>는 같다는 반대칭관계를 만족해야한다. 대상이 a,b 밖에 없는 카테고리를 상상해보자. 사이클이라는 개념이 성립하려면 a→b로 향하는 사상과 b→a로 향하는 사상이 존재해야 한다. 원순서는 a→b로 향하는 사상과 b→a로 향하는 사상이 있다고 해서 이 두 대상을 같은 것이라고 정의하지 않아도 되지만, 부분순서는 반대칭관계를 만족해야하기 때문에 반드시 a=b가 되어버린다.</p>\n<p>즉, a와 b가 다른 대상이 될 수가 없으므로 사이클을 정의할 수가 없다.</p>\n</blockquote>\n<p>정렬 문제와 같은 일상적인 문제를 해결할 때 퀵 정렬, 버블 정렬, 병합 정렬과 같은 정렬 알고리즘은 오직 전순서에서만 제대로 작동하며 부분순서에서는 위상 정렬 알고리즘을 사용해야 하기 때문에 어떠한 카테고리가 원순서인지 부분순서인지 또는 전순서인지를 알아내는 능력은 프로그래머에게 매우 중요하다고 할 수 있다.</p>\n<h2 id=\"34-집합으로써의-모노이드\" style=\"position:relative;\">3.4 집합으로써의 모노이드<a href=\"#34-%EC%A7%91%ED%95%A9%EC%9C%BC%EB%A1%9C%EC%8D%A8%EC%9D%98-%EB%AA%A8%EB%85%B8%EC%9D%B4%EB%93%9C\" aria-label=\"34 집합으로써의 모노이드 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>모노이드(Monoid)는 굉장히 간단하지만 놀라울 정도로 강력한 개념이다. 모노이드는 덧셈과 곱셈과 같은 기본적인 산술 연산의 기반이 되는 개념이며, 문자열, 리스트, Fold 연산이 가능한 구조, 동시성 프로그래밍에서의 Future, 함수형 반응형 프로그래밍에서의 이벤트 등 다양한 프로그래밍 기법에서도 빈번하게 사용되는 개념이다.</p>\n<p>전통적으로 모노이드는 이항연산을 가진 집합으로 정의된다. 이 이항연산은 결합법칙을 만족시켜야 하며, 이 연산에 대해서 항등원과 같은 역할을 하는 특별한 원소가 하나 있어야 한다. 예를 들어 0을 포함하는 자연수 집합(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">N</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span>)은 덧셈에 대해 모노이드를 이룬다.</p>\n<p>결합법칙은 아래와 같은 특성을 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">(a + b) + c = a + (b + c)</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이건 다른 말로 하면 수를 더할 때 식 내에 있는 괄호를 생략해도 괜찮다는 의미이다. 그리고 덧셈에 대한 항등원은 0인데, 이 또한 결합법칙을 통해 간단하게 확인해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">0 + a = a\na + 0 = a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>여기서 두 번째 식은 결국 첫 번째 식과 같은 의미이다. 덧셈은 <code class=\"language-text\">a + b = b + a</code> 와 같은 교환법칙도 만족하는 연산이기 때문이다. 하지만 교환법칙은 모노이드에서 반드시 만족시켜야 하는 대상은 아니다.</p>\n<p>예를 들어 문자열 연결 연산(Concatenation)의 경우 교환법칙을 만족하지 않지만 모노이드이다. 문자열 연결 연산의 항등원은 빈 문자열이고 이는 문자열의 어느 쪽에 가져다 붙여도 문자열을 변경하지 않기 때문이다.</p>\n<p>Haskell에서는 모노이드에 대한 타입 클래스를 정의할 수 있다. 이는 <code class=\"language-text\">mempty</code>라고 불리는 항등원과 <code class=\"language-text\">mappend</code>라고 불리는 이항연산을 정의한 타입이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Monoid</span> <span class=\"token hvariable\">m</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">mempty</span>  <span class=\"token operator\">::</span> <span class=\"token hvariable\">m</span>\n    <span class=\"token hvariable\">mappend</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">m</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>지금은 두 개의 인자를 받는 함수를 <code class=\"language-text\">m->m->m</code> 이라는 타입으로 표현한 것이 조금 어색하게 보일 수 있겠지만, 이건 나중에 커링(Currying)에 대해서 배우면 완벽하게 이해할 수 있을 것이다.</p>\n<p>이렇게 여러 화살표가 있는 타입 선언은 보통 두 가지 방식으로 해석해볼 수 있다. 첫째로는 오른쪽에 있는 타입이 반환 타입이 되는 다인수 함수로 해석할 수 있으며, 두 번째로는 가장 왼쪽에 있는 첫 번째 인수를 받아 함수를 반환하는 함수로도 해석해볼 수 있다. 후자의 해석은 <code class=\"language-text\">m -> (m -> m)</code> 처럼 괄호를 추가해서 강조해볼 수는 있지만, 사실 애초에 연산순서가 오른쪽에서 왼쪽으로 흘러가기 때문에 의미없는 괄호이기는 하다. 이러한 해석 방식에 대해서는 잠시 후 다시 이야기해보도록 하겠다.</p>\n<p>여기서 우리가 주의해야 할 점은 Haskell에서 <code class=\"language-text\">mempty</code>가 항등성을 가져야한다는 것과 <code class=\"language-text\">mappend</code>가 결합법칙을 만족시켜야 한다는 사실을 명시적으로 표현할 수 있는 방법이 없다는 것이다. 이런 법칙들을 만족시키고 준수하는 것은 전적으로 프로그래머의 책임에 달려있다.</p>\n<p>Haskell의 클래스는 C++의 클래스처럼 강제적이지 않다. 그래서 새로운 타입을 정의할 때도 굳이 해당 클래스를 미리 지정할 필요가 없으며, 주어진 타입이 어떤 클래스의 인스턴스가 되는지에 대한 것은 나중에 정의해도 된다.</p>\n<p>예를 들어 <code class=\"language-text\">String</code>에 <code class=\"language-text\">mempty</code>와 <code class=\"language-text\">mappend</code>를 구현해서 모노이드가 되었다고 가정해보겠다. (사실 이건 <a href=\"https://hackage.haskell.org/package/base-4.19.0.0/docs/Prelude.html\" target=\"_blank\" rel=\"nofollow\">Standard Prelude</a>에 이미 구현되어있기는 하다.)</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Monoid</span> <span class=\"token constant\">String</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">mempty</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n    <span class=\"token hvariable\">mappend</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>결국 String은 그저 문자들의 리스트일 뿐이므로, 위 예시에서는 리스트 연결 연산자인 <code class=\"language-text\">(++)</code>를 사용했다.</p>\n<p>여기서 Haskell의 문법에 대해서 하나 짚고 넘어가야 할 것 같다. Haskell에서 임의의 중위 연산자를 괄호로 감싸면 두 개의 인자를 받는 함수가 된다. 즉 두 문자열을 연결하기 위해 우리는 아래와 같이 문자열 사이에 ++ 연산자를 넣어주거나,</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token string\">\"Hello \"</span> <span class=\"token operator\">++</span> <span class=\"token string\">\"world!\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>또는 ++ 연산자를 괄호로 감싸 <code class=\"language-text\">(++)</code>로 표현하여 함수로 만들고 두 개의 인자를 넘기는 방식으로 코드를 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token string\">\"Hello \"</span> <span class=\"token string\">\"world!\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 함수의 인자들은 쉼표로 구분되지도 않고 괄호로 감싸지도 않았다는 사실을 기억하도록 하자. (이게 바로 Haskell을 배울 때 가장 익숙해지기 어려운 부분인 것 같다.)</p>\n<p>또한 Haskell에서는 함수가 서로 같다는 동등성을 표현할 수 있다는 점을 이야기하고 넘어가면 좋을 것 같다. 아래 예시를 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">mappend</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 코드는 함수가 생성한 값의 비교를 표현하는 것과는 개념적으로 다른 표현이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">mappend</span> <span class=\"token hvariable\">s1</span> <span class=\"token hvariable\">s2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">s1</span> <span class=\"token hvariable\">s2</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 두 가지 예시 중 전자는 Hask 카테고리 또는 연산이 종료되지 않음을 의미하는 bottom을 제외한 집합에서의 사상의 동등성을 표현하고 있다고 볼 수 있다. 이러한 등식은 간결할 뿐 아니라 다른 카테고리에도 일반화될 수 있다.</p>\n<p>후자의 경우는 확장 동등성(Extensional Equality)라고 불리며, <code class=\"language-text\">mappend</code> 함수와 <code class=\"language-text\">(++)</code> 함수가 인자로 동일한 두 개의 문자열을 입력받았을 때 이 함수들이 반환하는 출력 또한 동일하다는 것을 의미한다. 인수의 값은 점(Point)이라고 불리기도 하기 때문에 이 개념을 점별 동등성(Point-wise Equality)이라고 부르기도 한다. 인수를 지정하지 않은 함수들의 동등성은 Point-Free하다고 한다.</p>\n<p>참고로 Point-Free 스타일을 표현할 때 주로 함수의 합성(Composition)을 사용하는데, 이때 함수의 합성은 점(<code class=\"language-text\">.</code>)을 사용하여 표현하므로, 초보자에게는 조금 헷갈릴 수 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p><code class=\"language-text\">mappend = (++)</code>가 표현하는 동등한 사상이라는 개념과 <code class=\"language-text\">mappend s1 s1 = (++) s1 s2</code> 가 표현하는 Extensional Equality의 개념이 조금 어려울 수 있다. 사실 잘 생각해보면 두 함수가 같은 인자를 받았을 때 같은 값을 반환한다는 것이 이 함수들이 정말로 “같은 함수”라는 것을 의미하는 것은 아니다.</p>\n<p>예를 들어 <code class=\"language-text\">(a, b) ⇒ a + b</code> 처럼 두 인자를 받아 두 값을 더해주는 함수와 <code class=\"language-text\">(a, b) ⇒ a + b + 0</code> 처럼 항등원을 한번 더 더하는 함수는 같은 인자를 받았을 때 항상 같은 값을 반환할테지만, 엄연히 두 함수의 구현은 다르므로 “다른 함수”라고 보는 것이다.</p>\n<p>즉, “같은 함수”라는 개념은 단지 같은 인자를 받았을 때 같은 값을 반환하는 것만으로는 만족할 수 있는 개념이 아니기 때문에 이 두 가지 개념을 엄밀하게 구분하는 것이다.</p>\n</blockquote>\n<p>C++에서 모노이드를 가장 비슷하게 흉내낼 수 있는 방법은 현재 표준 제안 단계인 <code class=\"language-text\">concepts</code> 키워드를 사용하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n  T mempty <span class=\"token operator\">=</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n  T <span class=\"token function\">mappend</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> T<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">M</span><span class=\"token operator\">></span>\n  <span class=\"token keyword\">concept</span> <span class=\"token keyword\">bool</span> Monoid <span class=\"token operator\">=</span> <span class=\"token keyword\">requires</span> <span class=\"token punctuation\">(</span>M m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">{</span> mempty<span class=\"token operator\">&lt;</span>M<span class=\"token operator\">></span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">-></span> M<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token function\">mappend</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">-></span> M<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 정의는 마찬가지로 표준 제안 단계인 Value Template 기능을 사용하며, 다형적인 값을 받아들일 수 있도록 선언하여 모든 타입을 커버할 수 있도록 작성하였다.</p>\n<p>그리고 <code class=\"language-text\">delete</code> 키워드는 기본값이 정의되어 있지 않다는 것을 의미하며, 이는 각 케이스 별로 모두 명시해줘야 한다. 즉 위 예시에서 <code class=\"language-text\">mappend</code>의 경우는 기본값이 정의되지 않은 것이다.</p>\n<p>concept으로 정의된 Monoid는 주어진 임의의 타입 <code class=\"language-text\">M</code>에 대해서 <code class=\"language-text\">mempty</code>와 <code class=\"language-text\">mappend</code>가 적절하게 정의되었는지를 검사하는 구문이기 때문에 bool을 반환하도록 작성되어있다.</p>\n<p>이러한 Monoid concept은 아래와 같이 적절한 특수화와 오버로딩을 통해 인스턴스로 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\nstd<span class=\"token double-colon punctuation\">::</span>string mempty<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nstd<span class=\"token double-colon punctuation\">::</span>string <span class=\"token function\">mappend</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>string s1<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>string s2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> s1 <span class=\"token operator\">+</span> s2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h2 id=\"35-카테고리로써의-모노이드\" style=\"position:relative;\">3.5 카테고리로써의 모노이드<a href=\"#35-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC%EB%A1%9C%EC%8D%A8%EC%9D%98-%EB%AA%A8%EB%85%B8%EC%9D%B4%EB%93%9C\" aria-label=\"35 카테고리로써의 모노이드 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자 지금까지 우리에게 익숙한 원소를 가진 집합의 관점에서 모노이드를 정의해보았다. 그러나 이 책은 카테고리 이론에 대한 이야기를 하고 있기 때문에, 이제부터는 집합과 원소에서 벗어나 대상과 사상에 대해 이야기를 해보려고 한다.</p>\n<p>자 일단 관점을 조금 바꿔서, 이항연산을 적용한다는 것을 어떤 대상에서 다른 대상으로 “이동”하는 것으로 생각해보자.</p>\n<p>예를 들어 모든 자연수에 5를 더하는 연산을 생각해보자. 이 연산은 0을 5로, 1을 6으로, 2를 7로 매핑할 것이다. 이런 개념은 일종의 자연수 집합에 정의된 함수와 동일하다. 역시 함수와 집합으로 생각하니 편하고 좋은 것 같다.</p>\n<p>어떤 수 n에 대해서 다시 n을 더하는 “Adder”라는 함수가 있다고 생각해보자. 이 Adder는 어떤 방식으로 합성될까? 5를 더하는 함수와 7을 더하는 함수를 합성하면 12를 더하는 함수가 될 것이다. 즉, Adder들간의 합성은 덧셈의 규칙을 그대로 유지한다고 볼 수 있다. 그렇다면 덧셈이라는 개념을 함수의 합성이라고 생각해도 문제가 없을 것이다.</p>\n<p>그리고 항등원인 0을 다루는 Adder도 존재할 수 있다. 0을 더한다는 행위는 아무것도 바꾸지 않는다는 의미이니 결국 자연수 집합에서의 항등함수라고 봐도 좋을 것 같다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 503px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/0c6fe1eaa13884efac67be8a65a2ac54/ebfc4/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 127.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAaABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAECBAUD/8QAFgEBAQEAAAAAAAAAAAAAAAAAAgAB/9oADAMBAAIQAxAAAAHci+BrYhUKOkDQY8//xAAeEAEBAAAGAwAAAAAAAAAAAAABAgADEBESICEiMf/aAAgBAQABBQJr2K30fDWYYPlzyCRen//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/ASn/xAAXEQADAQAAAAAAAAAAAAAAAAABEBEC/9oACAECAQE/AbEc1f/EAB8QAAAFBAMAAAAAAAAAAAAAAAABECExAhESICJBgf/aAAgBAQAGPwLHsQfqXHGp1JpPX//EAB0QAQEAAgIDAQAAAAAAAAAAAAERADEQIUFRYXH/2gAIAQEAAT8hEPkLlyRnpLwyiHW3JoEOk3mj8zoSX7rIGggtwIQ4k4//2gAMAwEAAgADAAAAEH/KgP/EABcRAQEBAQAAAAAAAAAAAAAAAAEREDH/2gAIAQMBAT8QC8wgmf/EABcRAQEBAQAAAAAAAAAAAAAAAAEQMUH/2gAIAQIBAT8QRphsXk//xAAeEAEBAAEEAwEAAAAAAAAAAAABEQAhMUFxEFFhkf/aAAgBAQABPxAIr6nQNr+45wFvF0waXHzw18B9+ZrzAqkDxTbvHXeRjQH6FruYQpiXGDYYR7AQ8AAAAcHj/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/0c6fe1eaa13884efac67be8a65a2ac54/ebfc4/1.jpg\" srcset=\"/static/0c6fe1eaa13884efac67be8a65a2ac54/0913d/1.jpg 160w,\n/static/0c6fe1eaa13884efac67be8a65a2ac54/cb69c/1.jpg 320w,\n/static/0c6fe1eaa13884efac67be8a65a2ac54/ebfc4/1.jpg 503w\" sizes=\"(max-width: 503px) 100vw, 503px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <br>\n</center>\n<p>즉, 전통적인 덧셈의 규칙들 대신에 Adder 함수들을 합성하는 규칙을 사용한다고 해도 연산 과정에서 딱히 어떤 정보를 잃어버리는 일은 없다는 말이다. 함수의 합성은 결합법칙을 만족하기 때문에 Adder의 합성 또한 결합법칙을 만족할 것이니 말이다. 그리고 항등함수에 해당하는 0을 더하는 Adder까지 존재한다.</p>\n<p>여기서 눈치 빠른 독자분들이라면 정수를 Adder로 매핑하는 것이 <code class=\"language-text\">mappend</code> 의 두 번째 해석이었던 <code class=\"language-text\">m->(m->m)</code>의 타입 선언과 유사하다는 것을 알아차릴 수 있었을 것이다. 이는 <code class=\"language-text\">mappend</code>가 모노이드 집합의 한 원소를 해당 집합에 작용하는 함수로 매핑한다는 것을 의미한다.</p>\n<p>자 이제 자연수 집합 같은 것들은 다 잊어버리고, 그냥 이 집합을 Adder라는 수많은 사상이 달린 하나의 대상이라고 생각해보자. 결국 모노이드는 단 하나의 대상을 가진 단일대상 카테고리이다. 모노이드라는 이름 또한 단일한 무언가를 의미하는 그리스어 mono에서 유래되었다. 모든 모노이드는 단 하나의 대상과 서로 적절하게 합성할 수 있는 여러 사상들로 이루어진 단일대상 카테고리라고 할 수 있다.</p>\n<p>문자열 연결 연산은 굉장히 흥미로운 경우인데, 우리는 연결하려고 하는 문자열을 대상 문자열의 뒤쪽에 붙힐 것인지, 앞쪽에 붙힐 것인지 선택할 수 있기 때문이다. 이 두 가지 모델의 합성 테이블(Composition Table)은 마치 거울처럼 대칭적이다.</p>\n<p>이는 “foo” 뒤에 “bar”를 추가하여 “foobar”를 만드는 것과 “bar” 앞에 “foo”를 추가하여 “foobar”를 만드는 것이 결국 동일하다는 것을 통해 확인해볼 수 있다.</p>\n<p>그렇다면 이제 “모노이드라는 단일대상 카테고리가 어떤 이유로 이항연산자를 가진 집합과 연결되는가”에 대한 질문이 나올 차례인 것 같다.</p>\n<p>우리는 단일대상 카테고리에서 사상의 집합이라는 하나의 집합을 뽑아낼 수 있다. 위의 예시와 연결해보자면 이 집합의 원소인 사상들은 Adder들일 것이다. 다시 말해 우리는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span></span>의 단일대상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span></span>의 Hom 집합인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M(m,m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span>을 얻게되는 것이다.</p>\n<p>이 집합에서의 이항연산은 쉽게 정의해볼 수 있는데, Hom 집합 내 두 원소 간의 모노이드 곱은 각 사상들의 합성에 해당하는 원소일 것이다. 만약 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M(m,m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span>에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span>에 해당하는 두 원소를 가지고 모노이드 곱 이항연산을 한다면 결과는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>라는 것이다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d3da6336c55d688c889b42faf7546c4f/c08c5/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 65.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB7caMqFf/xAAYEAEBAQEBAAAAAAAAAAAAAAABAhEAIf/aAAgBAQABBQJfavEdGdWRTv/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABcRAAMBAAAAAAAAAAAAAAAAAAIQEUH/2gAIAQIBAT8BK4v/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAbEAADAAIDAAAAAAAAAAAAAAAAAREhMUFhcf/aAAgBAQABPyFy3wYRTukhilOtecl0xIof/9oADAMBAAIAAwAAABBs7//EABcRAAMBAAAAAAAAAAAAAAAAAAEQEUH/2gAIAQMBAT8QE1f/xAAWEQEBAQAAAAAAAAAAAAAAAAABABH/2gAIAQIBAT8QCMWMX//EABsQAQEAAwEBAQAAAAAAAAAAAAERACExQVFh/9oACAEBAAE/ENIQDmo4gwhNn3mUUinMURBFF45cEdpGe5Hqz8mf/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/d3da6336c55d688c889b42faf7546c4f/c08c5/2.jpg\" srcset=\"/static/d3da6336c55d688c889b42faf7546c4f/0913d/2.jpg 160w,\n/static/d3da6336c55d688c889b42faf7546c4f/cb69c/2.jpg 320w,\n/static/d3da6336c55d688c889b42faf7546c4f/c08c5/2.jpg 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>결국 이 사상들의 출발 대상과 도착 대상은 모두 동일한 대상이기 때문에 이러한 합성 또한 항상 존재할 수 밖에 없다. 그리고 카테고리의 규칙에 따라 사상 간의 합성은 결합법칙을 만족하며, 항등 사상이 모노이드 곱 연산의 항등원이라고 볼 수 있다. 즉 우리는 항상 모노이드 카테고리에서 모노이드 집합을 만들어낼 수 있으며, 이 두 개념은 본질적으로 같은 것이라고 볼 수 있다.</p>\n<p>다만 여기에는 수학자들이 지적할만한 작은 문제가 하나 있는데, 반드시 사상들이 집합을 이뤄야 할 필요는 없다는 것이다. 카테고리의 세계에서는 집합보다 더 거대한 개념들이 있다. 임의의 두 대상 간의 사상이 집합을 이루는 카테고리를 작은 카테고리(Locally Small Category)라고 한다. 물론 앞서 이야기했듯이 필자는 이러한 사소한 부분들은 무시하고 넘어갈 것이지만, 이런 개념이 있다는 것 정도만 알아두자는 차원에서 언급해보았다.</p>\n<p>카테고리 이론에서 흥미롭게 여겨지는 많은 개념들은 Hom 집합의 원소가 합성이 가능한 사상임과 동시에 어떤 집합의 원소로써의 성질도 가질 수 있다는 점에서부터 비롯된다. 즉, 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span></span>이 가진 사상들의 합성은 사상들의 집합인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M(m,m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></span>이 가진 원소(사상)들 간의 모노이드 곱이라고 해석할 수도 있다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240213-category-theory-for-programmers-3-categories-great-and-small","path":"/2024/02/13/category-theory-for-programmers-3-categories-great-and-small/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 3. 다양한 카테고리들","subTitle":null,"date":"Feb 13, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"7dfd699d-2573-5c25-bc88-12139a87df70","tableOfContents":"<ul>\n<li><a href=\"#21-%EC%96%B4%EB%96%A4-%EC%9D%B4%EB%93%A4%EC%97%90%EA%B2%8C-%ED%83%80%EC%9E%85%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80\">2.1 어떤 이들에게 타입이 필요한가?</a></li>\n<li><a href=\"#22-%ED%95%A9%EC%84%B1%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%ED%83%80%EC%9E%85\">2.2 합성과 관련된 타입</a></li>\n<li><a href=\"#23-%ED%83%80%EC%9E%85%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">2.3 타입이란 무엇인가?</a></li>\n<li><a href=\"#24-%EC%9A%B0%EB%A6%AC%EB%8A%94-%EC%99%9C-%EC%88%98%ED%95%99%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%85%90%EC%9D%84-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80\">2.4 우리는 왜 수학적인 개념을 알아야 하는가?</a></li>\n<li><a href=\"#25-%EC%88%9C%EC%88%98%ED%95%A8%EC%88%98%EC%99%80-%EC%88%9C%EC%88%98%ED%95%98%EC%A7%80%EC%95%8A%EC%9D%80-%ED%95%A8%EC%88%98\">2.5 순수함수와 순수하지않은 함수</a></li>\n<li><a href=\"#26-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%88%EC%8B%9C\">2.6 타입에 대한 예시</a></li>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"타입과 함수로 이루어진 카테고리는 프로그래밍에서 꽤나 중요한 역할을 한다. 자 이제 타입이라는 것이 무엇이며 왜 이런 개념이 필요한지에 대해 이야기를 해보자. 2.1 어떤 이들에게 타입이 필요한가? 정적타입과 동적타입, 그리고 강타입과 약타입의 각각의 장단점에 대해서는 약간의 논란이 존재한다. 한번 간단한 사고실험을 통해 이 선택들에 대해 한번 상상해보자. 여기 수백만 마리의 원숭이가 컴퓨터 키보드 앞에 앉아 행복한 기분을 느끼며 아무런 키나 랜덤하게 누르고, 프로그램을 작성하고, 컴파일하고, 실행시키고 있다. 만약 원숭이들이 기…","html":"<p>타입과 함수로 이루어진 카테고리는 프로그래밍에서 꽤나 중요한 역할을 한다. 자 이제 타입이라는 것이 무엇이며 왜 이런 개념이 필요한지에 대해 이야기를 해보자.</p>\n<h2 id=\"21-어떤-이들에게-타입이-필요한가\" style=\"position:relative;\">2.1 어떤 이들에게 타입이 필요한가?<a href=\"#21-%EC%96%B4%EB%96%A4-%EC%9D%B4%EB%93%A4%EC%97%90%EA%B2%8C-%ED%83%80%EC%9E%85%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80\" aria-label=\"21 어떤 이들에게 타입이 필요한가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>정적타입과 동적타입, 그리고 강타입과 약타입의 각각의 장단점에 대해서는 약간의 논란이 존재한다. 한번 간단한 사고실험을 통해 이 선택들에 대해 한번 상상해보자. 여기 수백만 마리의 원숭이가 컴퓨터 키보드 앞에 앉아 행복한 기분을 느끼며 아무런 키나 랜덤하게 누르고, 프로그램을 작성하고, 컴파일하고, 실행시키고 있다.</p>\n<p>만약 원숭이들이 기계어를 사용하는 상황이라면 이들이 만든 어떠한 바이트들의 조합이든 모두 허용되고 실행될 수 있다. 그러나 원숭이들이 고급 언어를 사용한다면 컴파일러가 어휘 및 문법 오류를 잡아준다는 사실에 그저 감사하게 될 것이다. 비록 많은 원숭이들이 바나나를 받지 못하고 떠나게 되겠지만, 그나마 유지보수할 수 있는 프로그램을 만들어낼 수 있을테니 말이다.</p>\n<p>타입 체킹은 무의미하게 작성된 프로그램에 대한 하나의 방어막이라고 볼 수 있다. 더 나아가 타입의 불일치를 런타임에서만 잡아낼 수 있는 동적 타입 언어와 다르게, 강력하게 타입이 정적으로 체크되는 언어에서는 타입의 불일치가 컴파일 타임에 발견되기 때문에 굳이 실행해보지 않더라도 잘못된 프로그램들을 잡아낼 수 있다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b8ac7991e21256d5af389e375d200d2e/10435/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 116.25000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAIEBQP/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHbhT4m0iKsAuA//8QAGxABAAIDAQEAAAAAAAAAAAAAAQIDABESEyL/2gAIAQEAAQUCnLkLTrL/ALm77HZZUr4uRNR//8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAHBAAAwACAwEAAAAAAAAAAAAAAAERECECEkFR/9oACAEBAAY/AiPE0odly2vpSr3EP//EABwQAQADAAIDAAAAAAAAAAAAAAEAETEhURBhcf/aAAgBAQABPyEe5cIzhC5Tvg8hBlLsqFktVSr7RH9U99RiTdT/2gAMAwEAAgADAAAAELAIAP/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QH//EAB8QAAICAQQDAAAAAAAAAAAAAAERADFBIVHB4RBh0f/aAAgBAQABPxAKJDSYn1AHP1g9KB++FbRiAYI6O7hD89wDarXqDBBI1tBEjJisAcCAuJOyXxGqNjvP/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/b8ac7991e21256d5af389e375d200d2e/c08c5/1.jpg\" srcset=\"/static/b8ac7991e21256d5af389e375d200d2e/0913d/1.jpg 160w,\n/static/b8ac7991e21256d5af389e375d200d2e/cb69c/1.jpg 320w,\n/static/b8ac7991e21256d5af389e375d200d2e/c08c5/1.jpg 640w,\n/static/b8ac7991e21256d5af389e375d200d2e/10435/1.jpg 944w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <br>\n</center>\n<p>우리에게는 이 원숭이들을 행복하게 만드는 것이 중요할까? 아니면 정확한 프로그램을 만드는 것이 중요할까?</p>\n<p>일반적으로 이러한 원숭이 사고실험의 목표는 바로 셰익스피어의 전집을 만들어내는 것이며, 이때 맞춤법 검사기와 문법 검사기를 사용할 수 있다면 성공 확률은 크게 증가한다. 만약 타입 검사기와 비슷한 것이 있다면 로미오를 인간이라고 표현해놓고 뜬금없이 그에게서 나뭇잎이 자란다고 하거나, 로미오가 블랙홀이 되어 강력한 중력장으로 광자를 사로잡거나 하는 상황을 방지함으로써 셰익스피어 전집의 정밀도를 높혀나갈 수 있을 것이다.</p>\n<h2 id=\"22-합성과-관련된-타입\" style=\"position:relative;\">2.2 합성과 관련된 타입<a href=\"#22-%ED%95%A9%EC%84%B1%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%ED%83%80%EC%9E%85\" aria-label=\"22 합성과 관련된 타입 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 이야기했듯이 카테고리 이론은 결국 화살표를 합성하는 것이다. 하지만 임의의 두 화살표를 아무렇게나 합성할 수 있는 것은 아니다. 한 화살표의 목표인 대상은 다음 화살표의 출발 대상과 동일해야 한다. 프로그래밍에서는 한 함수의 결과를 다른 함수로 전달하는 것과 동일하다고 볼 수 있다. 만약 합성하려고 하는 함수의 결과물을 다른 함수가 제대로 해석할 수 없는 경우 프로그램은 제대로 작동하지 않을 것이다. 즉, 합성이 제대로 되려면 양 끝단이 일치해야 한다는 것이며, 프로그래밍 언어가 제공하는 타입 시스템이 강력할수록 이러한 일치 여부를 잘 표현할 수 있고, 기계적으로 잘 검증할 수도 있다.</p>\n<p>내가 들었던 정적타입, 강타입 체킹에 대한 반대 의견 중 유일하게 일리가 있었던 것은 바로 타입은 맞지 않더라도 의미적으로는 올바른 일부 프로그램이 배제될 수도 있다는 것이었다. 하지만 실제로 이런 일은 극히 드물기도 하고, 모든 정적 타입, 강타입 언어는 타입 시스템을 무시할 수 있는 방법을 제공해주기도 한다.</p>\n<p>심지어 Haskell에도 <code class=\"language-text\">unsafeCoerce</code> 라는 녀석이 존재하기는 하지만, 이러한 기능들은 매우 신중하게 사용되어야 한다. 프란츠 카프카의 소설인 “<a href=\"https://ko.wikipedia.org/wiki/%EB%B3%80%EC%8B%A0_(%EC%B9%B4%ED%94%84%EC%B9%B4)\" target=\"_blank\" rel=\"nofollow\">변신</a>”의 주인공인 Gregor Samsa는 어느 날 갑자기 거대한 벌레가 되어버리면서 타입 시스템을 깨뜨렸고, 결국 그 결과가 어땠는지는 우리 모두 잘 알고 있다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>소설 변신에서의 Gregor Samsa는 어느 날 갑자기 거대한 벌레가 되어버리며, 단지 모습 뿐만 아니라 그가 인간으로써 지켜왔던 모든 것들을 함께 잃어버리게 된다. 이후 가족들은 그를 챙기려는 모습을 보이기는 하지만, 결국 가족들에게 그는 인간이 아닌 벌레로 평가되어 버림받았으며, 최종적으로는 쓸쓸히 죽음을 맞이한다. 경제적 능력을 상실한 한 명의 인간이 가정이나 사회에서 버림받게 된다는 씁쓸한 메세지를 던지는 소설인데, 이 책의 작가는 unsafeCoerce 타입을 “타입 역할을 제대로 못 하는 타입”으로 바라보고 있기 때문에 이런 예시를 든 것은 아닐까? 하는 생각을 해본다.</p>\n</blockquote>\n<p>흔히 들을 수 있는 또 다른 주장은 이러한 타입 처리들이 프로그래머에게 너무 많은 부담을 지운다는 것이다. 물론 C++에서 이터레이터 선언을 몇 번 해보고 난 뒤에는 이러한 마음에 어느 정도 공감할 수 있었다. 그러나 사실 컴파일러가 문맥을 통해 대부분의 타입을 추론할 수 있는 타입 추론 기술이 존재하기 때문에, C++에서는 변수를 auto로 선언하더라도 이 변수의 타입이 무엇인지 컴파일러가 알아서 결정할 수 있다.</p>\n<p>Haskell을 사용하는 대부분의 경우, 타입 선언은 선택 사항이다. 하지만 프로그래머들은 직접 타입 선언을 하는 경우가 많은데, 이러한 선언들이 코드의 의미에 대한 많은 정보를 알려주기도 하고 컴파일 오류를 이해하기 쉽게 만들어주기도 하기 때문이다. 사실 Haskell을 사용하여 프로젝트를 시작하는 경우에는 타입부터 설계하는 것이 일반적이다. 설계 이후에는 타입 선언들로부터 점진적으로 프로그램을 구현하게 된다.</p>\n<p>종종 강력한 정적 타이핑은 코드를 테스트하지 않는 핑계로도 사용된다. 간혹 Haskell 프로그래머들이 “컴파일된다면 이건 제대로 된 프로그램이다”라고 이야기하는 것을 들을 수 있다. 하지만 당연하게도 제대로 타이핑된 프로그램이라고 해서 반드시 제대로된 프로그램이라고 보장할 수는 없다.</p>\n<p>이런 경솔한 태도들은 여러 연구들에서 생각보다 Haskell이 코드 품질 측면에서 강력한 성과를 내지 못한다는 사실과도 이어진다. 상업적인 환경에서는 반드시 최고의 품질을 만들어 내야한다기보다는 일정한 품질 수준만 만족시키는 것이 나을 수도 있다. 이런 전략 선택의 팩터는 소프트웨어 개발의 경제적인 측면, 그리고 최종 사용자의 품질 허용 수준과 밀접한 관련이 있으며, 사실 프로그래밍 언어나 기술적 방법론과는 거의 관련이 없다.</p>\n<p>이런 환경에서 가장 우선시 되어야 하는 품질 기준은 얼마나 많은 프로젝트가 일정이 밀렸는지, 그리고 원하는 기능을 제대로 만족시키지 못한 상태로 사용자에게 전달되는지를 측정하는 것이다.</p>\n<p>또한 유닛 테스트가 강타입 시스템을 대체할 수 있다는 주장도 있다. 한번 강타입 시스템을 가진 언어에서 특정 함수가 가진 인수의 타입을 변경하는 일반적인 리팩토링 작업을 생각해보자.</p>\n<p>약타입 시스템 언어에서는 이제 이 함수가 다른 타입의 데이터를 기대한다는 사실이 호출부에 전달이 되지 않을 수도 있겠지만, 강타입 시스템 언어에서는 해당 함수의 선언을 수정하고 이후 파생된 빌드 오류들을 수정하는 것만으로도 충분할 것이다.</p>\n<p>하지만 결국 테스트라는 것은 확률적인 작업이기 때문에 증명이라는 개념을 대체하기에는 역부족이며, 유닛 테스트로 몇몇 구현의 불일치를 잡아내는 정도일 것이다.</p>\n<h2 id=\"23-타입이란-무엇인가\" style=\"position:relative;\">2.3 타입이란 무엇인가?<a href=\"#23-%ED%83%80%EC%9E%85%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"23 타입이란 무엇인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>타입을 가장 간단하게 설명하는 말은 바로 집합이다. <code class=\"language-text\">Bool</code> 타입은 True와 False 2개의 원소로 이루어진 집합이며, <code class=\"language-text\">Char</code> 타입은 a나 ą와 같은 모든 유니코드 문자를 원소로 가진 집합이다.</p>\n<p>집합은 유한할 수도 있고 무한할 수도 있다. <code class=\"language-text\">Char</code>의 리스트와 동일한 의미인 <code class=\"language-text\">String</code> 타입의 경우가 바로 무한집합의 예이다.</p>\n<p>한번 <code class=\"language-text\">x</code>라는 변수를 <code class=\"language-text\">Integer</code> 타입으로 선언해보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">x</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Integer</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>우리는 이제 이 <code class=\"language-text\">x</code>라는 값이 정수 집합에 들어있는 하나의 원소라고 이야기할 수 있다. Haskell에서 <code class=\"language-text\">Integer</code> 타입은 <a href=\"https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic\" target=\"_blank\" rel=\"nofollow\">임의 정밀도 산술</a>을 사용하기 때문에 무한한 집합이다. C++의 <code class=\"language-text\">int</code>와 같이 원시 타입에 해당하는 유한집합 <code class=\"language-text\">Int</code>도 존재한다.</p>\n<p>물론 타입과 집합을 완전히 동일시 하기에는 재귀적인 정의를 포함하는 다형성 함수나 모든 집합을 원소로 가지는 집합을 정의할 수 없다는 등의 몇 가지 문제가 있기는 하지만, 앞서 이야기한대로 너무 엄격한 수학적인 정의를 이야기하지는 않겠다. 여기서 중요한 것은 “Set”이라고 불리는 집합들의 카테고리가 존재하며 우리가 앞으로 이 개념을 다룰 것이라는 점이다. 이 Set 카테고리에서 대상은 집합이고 사상(화살표)는 함수이다.</p>\n<p>Set은 매우 특별한 카테고리이다. 왜냐하면 우리는 이미 이 카테고리의 대상인 집합에 대해서 잘 알고 있으니 이로부터 많은 직관을 얻을 수 있기 때문이다. 예를 들어 우리는 이미 공집합이라는 것이 어떠한 원소도 가지고 있지 않다는 사실을 알고 있다. 또한 특별한 하나의 원소를 가진 집합도 알고 있으며, 함수라는 것이 어떤 한 집합의 원소를 다른 집합의 원소와 매핑(Mapping)해주는 개념이라는 것도 알고 있다.</p>\n<p>또한 함수가 두 개의 원소를 하나의 원소로 매핑할 수는 있지만, 반대로 하나의 원소를 두 개의 원소로 매핑할 수는 없다는 것도 알고 있다. 그리고 우리는 항등 함수가 집합의 각 원소를 자기 자신에게 매핑한다는 것을 알고 있다. 이제 우리의 목표는 이렇게 디테일한 개념들은 점점 잊어버리고 순수한 카테고리 이론의 용어, 즉 대상과 화살표만으로 이런 개념들을 추상화해서 이해하는 것이다.</p>\n<p>이상적인 상황에서 우리는 Haskell의 타입을 집합으로, Haskell의 함수는 집합 간의 수학적인 함수로 정의해볼 수 있을 것이다. 하지만 한 가지 문제가 있다. 바로 수학적인 함수는 코드를 실행하는 것이 아니라, 단순히 답을 알고 있는 추상적 개념이라는 것이다. 하지만 Haskell의 함수는 직접 답을 계산해야한다. 물론 유한한 계산단계 내에서 답을 얻어낼 수만 있다면 계산이 얼마나 복잡하던 이 차이가 딱히 문제로 번지지는 않는다. (물론 너무 큰 수를 사용한다면 문제가 될 수도 있지만 말이다.)</p>\n<p>하지만 재귀와 같은 일부 계산은 영원히 종료되지 않을 수도 있다. 그러나 종료되는 함수와 종료되지 않는 함수를 구분하는 것은 <a href=\"https://namu.wiki/w/%EC%A0%95%EC%A7%80%20%EB%AC%B8%EC%A0%9C\" target=\"_blank\" rel=\"nofollow\">정지 문제</a>라는 유명한 난제이기 때문에, Haskell 내에서 종료되지 않는 함수만 찾아내어 금지하는 것은 불가능하다. 그래서 컴퓨터 과학자들은 관점에 따라 훌륭한 아이디어 또는 Hack으로도 볼 수 있는 bottom이라는 한 가지 특별한 값을 제안했다.</p>\n<p>이 “값”은 종료되지 않는 연산을 표현하며, <code class=\"language-text\">_|_</code> 또는 유니코드 <code class=\"language-text\">⊥</code>로도 표현할 수 있다. 한번 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Bool</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 함수는 True, False 또는 <code class=\"language-text\">_|_</code> 를 반환하며, 이것은 이 함수가 종료되지 않을 수도 있다는 사실을 의미한다.</p>\n<p>재미있는 사실은 bottom을 타입 시스템의 일부로 받아들이기만 하면, 프로그램에서 발생하는 모든 런타임 에러를 bottom으로 표현하고 명시적으로 함수가  bottom을 반환할 수 있다는 개념만으로도 엄청난 편의성이 생긴다는 것이다. 이는 <code class=\"language-text\">undefined</code>를 사용한 표현에서 확인해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Bool</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">undefined</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>위 표현에서 <code class=\"language-text\">undefined</code>는 bottom으로 평가되기 때문에 타입 체크를 통과한다. bottom은 <code class=\"language-text\">Bool</code>을 포함한 모든 타입의 원소이기 때문이다. 심지어 아래와 같이 작성할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Bool</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">f</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">undefined</span>\n<span class=\"token comment\">-- (x는 생략 가능)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이게 가능한 이유는 bottom이 <code class=\"language-text\">Bool -> Bool</code> 타입에도 해당하기 때문이다. 이처럼 bottom을 반환할 수 있는 함수를 부분 함수(Partial Function)이라고 하며, 반대로 모든 인수에 대해 반드시 유효한 결과를 반환하는 함수는 전체 함수(Total Function)이라고 한다.</p>\n<p>바로 이 bottom이라는 개념 때문에 Haskell의 타입과 함수로 이루어진 카테고리는 Set이 아닌 Hask라는 이름으로 불린다. 하지만 이렇게 이론적으로 계속 파고 들다보면 끝도 없이 복잡해지기도 하고 어차피 실용적인 측면에서 보면 종료되지 않는 함수와 bottom을 그냥 무시하고 Hask를 Set이라고 생각해도 무방하니 이 이야기는 이쯤에서 마무리지으려고 한다.</p>\n<h2 id=\"24-우리는-왜-수학적인-개념을-알아야-하는가\" style=\"position:relative;\">2.4 우리는 왜 수학적인 개념을 알아야 하는가?<a href=\"#24-%EC%9A%B0%EB%A6%AC%EB%8A%94-%EC%99%9C-%EC%88%98%ED%95%99%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%85%90%EC%9D%84-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"24 우리는 왜 수학적인 개념을 알아야 하는가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>아마 여러분은 프로그래머로서 프로그래밍 언어의 구문과 문법에 대해 깊은 이해도를 가지고 있을 것이다. 언어의 문법이나 구문과 같은 요소들은 보통 언어 명세의 가장 첫 부분에 형식적인 표기를 사용하여 설명된다. 그러나 언어의 의미론적인 부분은 설명하기가 훨씬 까다롭다. 언어의 의미에 대한 설명들은 훨씬 더 많은 페이지를 필요로 하고 형식적이기도 어려우며, 대부분의 경우에는 설명이 완벽하기도 어렵다. 이 때문에 언어에 대한 논의는 끝나지 않고 언어 표준에 대한 내용에 대해 각자의 해석을 통해 저술한 책들이 범람하고 있는 것이다.</p>\n<p>물론 언어의 의미론적인 측면을 설명하는 형식화된 몇몇 도구들이 존재하기는 하지만, 워낙 복잡하기 때문에 주로 단순화된 학술적인 언어에나 사용되는 편이며 현실의 거대한 프로그래밍 언어에서는 잘 사용되지 않는다. 이러한 도구 중 하나인 운용 의미론(Operational Semantics)은 프로그램 실행 매커니즘을 기술하는데, 이는 형식화된 가상 인터프리터를 정의하는 것이다. 산업용 언어인 C++와 같은 언어들의 경우에는 보통 “추상기계(Abtract Machine)”와 같은 비형식적인 운용 추론을 사용하여 설명한다.</p>\n<p>문제는 이러한 운용 의미론을 이용하여 프로그램에 대한 증명을 하는 것이 굉장히 어렵다는 것이다. 어떤 프로그램에 대한 특징을 보여주기 위해서는 반드시 가상 인터프리터를 사용하여 프로그램을 “실행”시켜봐야 한다.</p>\n<p>단지 프로그래머들이 어떤 문제에 대한 형식적인 증명을 수행하는 것에 대해 익숙하지 않기 때문에 어렵다고 하는 것은 아니다. 우리는 항상 우리가 올바른 프로그램을 작성하고 있다고 “생각”한다. 아무도 키보드 앞에 앉아서 “일단 대충 몇 줄 짜보고 무슨 일이 벌어지는지 봐야지”라고 말하지는 않는다는 것이다. 우리는 우리가 작성하는 코드들이 원하는 결과를 얻을 수 있도록 특정한 동작을 수행할 것이라고 기대하는 것이다. 그래서 작성한 코드가 우리의 예상과 다르게 동작하면 우리는 크게 놀라게 된다.</p>\n<p>즉, 우리는 우리가 작성하는 프로그램의 동작에 대한 일종의 이성적 추론을 하고 있으며, 이러한 추론은 우리의 머릿속의 인터프리터를 통해 코드를 실행시켜보며 수행하고 있다는 것이다. 하지만 우리가 모든 변수를 추적한다는 것은 불가능에 가깝다. 컴퓨터는 프로그램을 실행하는 것에 특화되어있는 녀석이지만 우리 인간은 그렇지 않으니 말이다! 만약 우리가 컴퓨터만큼 프로그램을 잘 실행시킬 수 있었다면 컴퓨터라는 개념 자체가 필요없었을테니 말이다.</p>\n<p>이런 문제를 해결하기 위해 표시적 의미론(Denotational Semantics)라고 불리는 대안이 있다. 이는 수학을 기반으로 하며, 표시적 의미론에서는 모든 프로그래밍 구성에 수학적 해석이 부여되기 때문에 프로그램의 속성을 증명하려면 그저 수학적 정리를 증명하기만 하면 된다. 이런 수학적인 증명이 어려울 것이라고 생각할 수는 있겠지만, 사실 우리 인간은 지난 수천년동안 수학적 기술들을 발전시켜왔기 때문에, 이미 우리가 활용할 수 있는 많은 지식들이 쌓여있다. 또한 우리가 프로그래밍에서 마주치는 문제들은 전문적인 수학자들이 증명해야하는 문제들에 비해 상대적으로 간단한 경우가 많다.</p>\n<p>표시적 의미론을 아주 잘 표현할 수 있는 Haskell에서의 팩토리얼 함수 정의를 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">fact</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">product</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token hvariable\">n</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">[1..n]</code> 표현식은 1부터 n까지의 정수로 이루어진 리스트를 의미한다. 함수 <code class=\"language-text\">product</code>는 이 리스트의 모든 원소를 곱한다. 이런 표현들은 우리가 수학 교과서에서 볼 수 있는 팩토리얼의 정의와 굉장히 유사하다. 한번 C와 비교해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">fact</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n        result <span class=\"token operator\">*=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>설명이 더 필요할까?</p>\n<p>사실 팩토리얼 함수에는 이미 명백한 수학적 표현이 존재하기 때문에 살짝 비겁한 예시이기는 하다. 여기서 영리한 독자라면 “그럼 키보드에서 문자를 읽거나 네트워크를 통해 패킷을 보내는 행위들에 대한 수학적 모델은 뭔가요?”라고 물어볼 수도 있겠다. 나도 오랜 기간 고민해봤지만 이런 질문들은 자칫 난해한 설명을 하게 되기 쉬운 까다로운 질문이었다.</p>\n<p>물론 질문과 같이 중요한 작업들을 운용 의미론으로 다루기는 쉽지만 표시적 의미론으로 다루기에는 적합하지 않아보인다는 것은 인정한다. 이런 문제에 대한 돌파구는 바로 카테고리 이론에서 나왔다. Eugenio Moggi는 계산에서 파생된 효과(Computational Effect)를 모나드에 매핑할 수 있다는 사실을 발견했는데, 이는 표시적 의미론에 새로운 생명을 불어넣어 주었고 순수 함수형 프로그램을 더 유용하게 만들 뿐 아니라 전통적인 프로그래밍에도 새로운 시각을 제공해주었다. 추후 모나드에 대해서는 카테고리론적인 도구들에 좀 더 익숙해지고난 뒤 다시 설명하도록 하겠다.</p>\n<p>정리하자면 프로그래밍에서 수학적 모델이 가지는 중요한 장점 중 하나는 소프트웨어의 정확성에 대한 형식적인 증명을 수행할 수 있다는 것이다. 일상 속에서 비즈니스 소프트웨어를 작성할 때는 그렇게 중요하지 않을 수 있겠지만, 작은 실패 하나가 큰 대가로 돌아오는 프로그래밍 분야나 심지어 사람의 목숨이 위험해질 수 있는 분야도 있다. 만약 여러분이 의료 시스템을 위한 웹 어플리케이션을 작성한다면 Haskell 표준 라이브러리가 제공하는 알고리즘과 함수들이 프로그램의 정확성을 보장해준다는 사실에 감사하게 될 수도 있다.</p>\n<h2 id=\"25-순수함수와-순수하지않은-함수\" style=\"position:relative;\">2.5 순수함수와 순수하지않은 함수<a href=\"#25-%EC%88%9C%EC%88%98%ED%95%A8%EC%88%98%EC%99%80-%EC%88%9C%EC%88%98%ED%95%98%EC%A7%80%EC%95%8A%EC%9D%80-%ED%95%A8%EC%88%98\" aria-label=\"25 순수함수와 순수하지않은 함수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리가 C++ 또는 다른 명령형 언어에서 함수라고 부르는 것들은 수학자들이 함수라고 부르는 것과는 약간 다른 개념이다. 수학적 함수는 그저 어떠한 값들 간의 사상(Mapping)일 뿐이기 때문이다.</p>\n<p>물론 프로그래밍 언어를 사용하여 수학적인 함수를 구현하는 것도 가능하다. 이러한 함수는 주어진 입력 값을 받아 출력 값을 계산한다. 어떠한 수의 제곱을 구하는 함수는 받아들인 입력 값을 그 입력 값과 다시 곱하여 계산하고 반환할 것이다. 이 함수는 동일한 입력 값을 받아 호출될 때마다 항상 같은 출력 값을 보장한다. 어떠한 수의 제곱이라는 것은 달의 위상처럼 매번 변하는 개념이 아니기 때문이다.</p>\n<p>또한 어떠한 수의 제곱을 계산하는 일이 강아지에게 맛있는 간식을 주는 것과 같은 사이드이펙트를 가지면 안된다. 이런 “함수”는 수학적 함수로 모델링하기가 쉽지 않기 때문이다.</p>\n<p>이처럼 프로그래밍 언어에서 동일한 입력 값이 주어질 때 항상 동일한 결과를 생성하고 함수 외부세계에 영향을 끼치는 사이드이펙트가 없는 함수를 순수 함수라고 한다. Haskell과 같은 순수 함수형 언어에서는 모든 함수가 순수하기 때문에, 명령형 언어에 비해 표시적 의미론이나 카테고리 이론을 사용하여 모델링하는 것이 상대적으로 더 쉽다. 물론 다른 언어들을 사용하더라도 순수한 부분을 제한하거나 사이드이펙트를 별도로 다룰 수 있도록 만드는 것이 가능하다. 따라서 수학적 함수만 사용한다는 제약이 우리에게 어떠한 불이익을 가져다주는 일은 없을 것이며, 추후 모나드가 어떤 방식으로 순수 함수만을 사용하여 모든 종류의 효과들을 모델링할 수 있도록 만들어주는지도 알아볼 것이다.</p>\n<h2 id=\"26-타입에-대한-예시\" style=\"position:relative;\">2.6 타입에 대한 예시<a href=\"#26-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%9C-%EC%98%88%EC%8B%9C\" aria-label=\"26 타입에 대한 예시 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>타입이 사실은 집합이라는 사실을 깨닫고 나면, 이제 우리는 약간 독특한 타입에 대해서도 한번 생각해볼 수 있다. 예를 들어 공집합에 해당하는 타입은 무엇일까? Haskell에서는 이러한 타입을 Void라고 부르기는 하지만, C++에서의 void와는 다른 개념이다.</p>\n<p>이 타입은 어떠한 값도 가지고 있지 않는 타입이다. Void를 인자로 받는 함수를 정의할 수는 있겠지만 이를 호출할 수는 없을 것이다. 왜냐하면 이런 함수를 호출하기 위해서는 Void 타입의 값을 인자로 넣어줘야 하는데, 이 타입의 값이 존재하지 않기 때문이다. 이 함수는 어떤 타입이든 반환할 수 있기 때문에 반환할 수 있는 것들에 대한 제약은 전혀 없겠지만, 결국 호출할 수 없기 때문에 뭔가가 반환되는 일도 벌어지지 않을 것이다. 즉, 이 함수는 반환 타입에 대한 다형성을 가진 함수라고 할 수 있다.</p>\n<p>Haskell 개발자들은 이런 함수를 <code class=\"language-text\">absurd</code>라고 부른다. 여기서 <code class=\"language-text\">a</code>는 어떤 타입이든지 될 수 있는 타입 변수라는 것을 기억하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">absurd</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Void</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 함수의 이름은 그냥 지어진 것이 아니다. Curry-Howard 동형성이라는 논리학적인 측면에서 타입과 함수를 더 깊게 해석해볼 수 있다. Void 타입은 거짓을 나타내고, absurd 함수의 타입은 “거짓인 가정에서 시작된 모든 명제는 참이다”라는 명제에 해당한다. 이는 라틴어 속담 “ex falso sequitur quodlibet(모든 것은 거짓으로부터 나온다)”과 같은 말이다.</p>\n<blockquote>\n<p><strong>💡 역주</strong></p>\n<p>이는 형식논리학의 개념인데, P→Q(만약 P라면 Q이다)라는 명제가 있는 경우, P가 거짓이라 할 지라도 Q가 참이라면 전체 명제는 참으로 평가받는 것을 이야기하는 것이다. 만약 P가 “하늘이 하얀색이다”, Q가 “태양은 뜨겁다”라면 하늘이 하얀색이든 아니든 항상 태양은 뜨거우므로 P→Q(하늘이 하얀색이면 태양은 뜨겁다)도 참이 된다.</p>\n</blockquote>\n<p>다음으로는 단일원소 집합에 해당하는 타입이다. 이 타입은 단 하나의 값만을 가질 수 있으며, 이 값은 그저 “존재”한다. 처음에는 이 말이 잘 이해가 안 갈 수도 있지만, C++의 void가 바로 이러한 타입이다. void 타입의 인자를 받고 void 타입을 반환하는 함수를 한번 생각해보면, 이 함수는 어떤 상황이든 항상 호출될 수 있다. 만약 이 함수가 순수함수라면 이 함수는 항상 같은 값을 반환할 것이다.</p>\n<p>아래 예시를 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">f44</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token number\">44</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 함수가 “아무 인자도 받지 않는 함수”로 보일 수도 있지만, 앞서 살펴본 것처럼 “아무 인자도 받지 않는 함수”는 호출될 수 없다. 왜냐하면 “아무것도 존재하지 않는다”라는 것을 나타내는 값이 없기 때문이다. 그렇다면 이 함수는 무엇을 인자로 받고 있는걸까? 사실 개념적으로 보면 이 함수는 단 하나의 원소만 존재할 수 있는 더미 값을 받는다고 볼 수 있기 때문에 우리가 직접 이 값을 명시해줄 필요는 없다. 그러나 Haskell에서는 이러한 더미 값을 빈 괄호쌍인 <code class=\"language-text\">()</code> 으로 표현한다.</p>\n<p>이것이 우연인지 아닌지는 모르겠지만 C++과 Haskell에서 void를 인자로 받는 함수를 호출하는 방법은 같은 모양으로 보인다. 또한 Haskell은 간결함을 사랑하기 때문에 기호 <code class=\"language-text\">()</code> 가 그 값의 타입, 생성자, 그리고 이로 인해 생성되는 유일한 값을 표현하는데에도 사용된다.</p>\n<p>즉, 위의 C++함수는 Haskell에서는 아래와 같이 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f44</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Integer</span>\n<span class=\"token hvariable\">f44</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">44</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>첫 번째 줄은 <code class=\"language-text\">f44</code> 함수가 unit이라고 발음하는 타입 <code class=\"language-text\">()</code>을 받아 <code class=\"language-text\">Integer</code> 타입을 반환한다고 선언하고 있다. 두 번째 줄은 <code class=\"language-text\">f44</code> 함수가 unit의 유일한 생성자인 <code class=\"language-text\">()</code>를 패턴 매칭하여 숫자 <code class=\"language-text\">44</code>를 생성한다는 것을 정의한다. 이 함수를 호출하기 위해서는 unit의 값 <code class=\"language-text\">()</code>를 인자로 제공하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f44</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>unit을 인자로 받는 모든 함수는 반환 타입에 해당하는 원소 하나를 뽑는 것과 동일하다고 생각할 수 있다. (이 예시에서는 정수 44를 뽑았다.)</p>\n<p>사실 <code class=\"language-text\">f44</code>는 숫자 <code class=\"language-text\">44</code>의 또 다른 표현이라고 볼 수도 있다. 이는 집합의 특정한 원소를 명시적으로 표현하는 것이 아니라 이를 함수(화살표)로 표현하는 것으로 대체하는 방법의 예시이기도 하다. unit에서 임의의 타입 A로 나아가는 함수(unit을 인자로 받아 A를 반환하는 함수)는 집합 A의 원소들과 일대일 대응 관계에 있다.</p>\n<p>그렇다면 void 타입을 반환하는 함수, Haskell에서는 unit 타입을 반환하는 함수는 어떨까? 보통 C++에서 이런 함수는 사이드이펙트를 표현하기 위해 사용되지만, 우리는 이미 이런 함수들이 수학적인 의미에서 진짜 함수가 아니라는 것을 알고 있다. 즉, unit을 반환하는 순수 함수는 아무 일도 하지 않고, 그냥 인자를 버리기만 하는 것이다.</p>\n<p>수학적으로 집합 A에서 단일원소 집합으로 향하는 함수는 집합 A의 모든 원소를 공역에 해당하는 단일원소 집합에 들어있는 원소 하나에 매핑한다. 따라서 모든 A의 원소에 대해 이러한 일을 하는 함수는 단 하나만이 존재할 수 있다.</p>\n<p>아래 예시를 보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">fInt</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Integer</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">fInt</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 함수는 임의의 정수를 인자로 입력받으면 반드시 unit을 반환한다. 앞서 언급했듯이 Haskell은 간결함을 추구하기 때문에 와일드카드 패턴인 언더스코어(<code class=\"language-text\">_</code>)를 사용하여 버려지는 인자를 표현할 수 있으며, 이 표현을 사용하면 인자의 이름을 지정할 필요도 없다.</p>\n<p>즉, 위의 예시는 아래와 같이 다시 표현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">fInt</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Integer</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">fInt</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 함수는 인자로 넘겨받는 값 뿐 아니라 인자의 타입에도 의존하고 있지 않다는 점에 주목하자.</p>\n<p>이처럼 임의의 타입에 대해서 항상 같은 형태로 구현될 수 있는 함수를 매개변수 다형성(Parametrically Polymorphic)을 가진 함수라고 한다. 구체적인 타입을 정하는 대신 타입 변수를 사용하여 하나의 방정식으로 다양한 함수들을 구현할 수 있다. 이렇게 임의의 타입을 받아 unit을 반환하도록 만들어져 다형성을 갖춘 함수를 뭐라고 부르면 좋을까?</p>\n<p>공교롭게도 이런 함수도 똑같이 unit이라고 부른다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">unit</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">unit</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>C++에서는 이 함수를 아래와 같이 작성해볼 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">unit</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>다음으로 살펴볼 타입의 유형은 두 개의 원소를 가진 집합이다. C++에서는 이를 <code class=\"language-text\">bool</code>이라고 부르며, Haskell에서도 이와 비슷하게 <code class=\"language-text\">Bool</code>이라고 부른다. 이 두 개념 간의 차이점은 C++의 bool은 built-in 타입인 반면에, Haskell에서는 아래와 같이 정의할 수 있다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Bool</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span> <span class=\"token operator\">|</span> <span class=\"token constant\">False</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 정의는 Bool 타입이 <code class=\"language-text\">True</code> 또는 <code class=\"language-text\">False</code> 중 하나임을 의미한다. 원칙적으로는 C++에서도 Enum을 사용하여 bool 타입을 정의할 수 있어야 한다.</p>\n<p>하지만 C++의 Enum은 내부적으로 정수를 나타낸다. C++11의 “Enum Class”를 사용할 수도 있겠지만, 이 경우 해당 타입의 값을 사용할 때 <code class=\"language-text\">bool::false</code> 처럼 항상 클래스 이름을 붙혀주어야 한다. 또한 <code class=\"language-text\">bool</code> Enum을 사용하는 모든 파일들에 적절한 헤더를 포함시켜줘야 한다.</p>\n<p>Bool 타입을 인자로 받는 순수 함수는 대상 타입 내에서 <code class=\"language-text\">True</code>, <code class=\"language-text\">False</code> 두 값을 선택한다.</p>\n<p>Bool을 반환하는 함수들은 predicates라고 불리는데, 예를 들어 Haskell 라이브러리인 <code class=\"language-text\">Data.char</code>는 <code class=\"language-text\">isAlpha</code>, <code class=\"language-text\">isDigit</code> 같은 predicates들로 가득 차있다. C++에도 이와 비슷한 라이브러리가 존재하며, 역시 <code class=\"language-text\">isalpha</code>, <code class=\"language-text\">isdigit</code> 같은 함수들도 있지만 이 녀석들은 bool 타입이 아닌 int 타입을 반환한다. 실제 predicates는 <code class=\"language-text\">std::ctype</code> 에 정의되어있으며, <code class=\"language-text\">ctype::is(alpha, c)</code>, <code class=\"language-text\">ctype::is(digit, c)</code>와 같은 형태를 가지고 있다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240206-category-theory-for-programmers-2-types-and-functions","path":"/2024/02/06/category-theory-for-programmers-2-types-and-functions/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 2. 타입과 함수","subTitle":null,"date":"Feb 06, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"61858242-0d79-5fe9-8f83-b24a973ba365","tableOfContents":"<ul>\n<li>\n<p><a href=\"#11-%ED%95%A8%EC%88%98%EB%A1%9C%EC%8D%A8%EC%9D%98-%ED%99%94%EC%82%B4%ED%91%9C\">1.1 함수로써의 화살표</a></p>\n</li>\n<li>\n<p><a href=\"#12-%ED%95%A9%EC%84%B1%EC%9D%98-%EC%86%8D%EC%84%B1\">1.2 합성의 속성</a></p>\n<ul>\n<li><a href=\"#1-%ED%95%A9%EC%84%B1%EC%97%90%EB%8A%94-%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99%EC%9D%B4-%EC%84%B1%EB%A6%BD%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\">1. 합성에는 결합법칙이 성립해야 한다.</a></li>\n<li><a href=\"#2-%EB%AA%A8%EB%93%A0-%EB%8C%80%EC%83%81-a%EC%97%90%EB%8A%94-%ED%95%AD%EB%93%B1%EC%9D%98-%EA%B0%9C%EB%85%90%EC%9D%84-%EA%B0%80%EC%A7%84-%ED%99%94%EC%82%B4%ED%91%9C%EA%B0%80-%EC%A1%B4%EC%9E%AC%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\">2. 모든 대상 A에는 항등의 개념을 가진 화살표가 존재해야 한다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#13-%ED%95%A9%EC%84%B1%EC%9D%80-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EB%B3%B8%EC%A7%88%EC%9D%B4%EB%8B%A4\">1.3 합성은 프로그래밍의 본질이다.</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></p>\n</li>\n</ul>","excerpt":"카테고리는 놀라울 정도로 단순한 개념이다. 카테고리는 대상과 그 사이를 이어주는 화살표로 구성되기 때문에 그림으로 나타내기도 매우 쉽다. 대상은 원이나 점으로 그리면 되고, 화살표는 그냥 화살표로 그리면 된다. (쉬운 이해를 위해 객체를 돼지 모양으로 그리고 화살표는 폭죽으로 그릴 것이다.) 하지만 카테고리의 본질은 합성(Composition)이다. 취향에 따라서 합성의 본질은 카테고리라고 말할 수도 있겠다. 만약 카테고리 내에 대상 A에서 다른 대상 B로 향하는 화살표와 대상 B에서 다른 대상 C로 향하는 화살표가 존재한다면, …","html":"<p>카테고리는 놀라울 정도로 단순한 개념이다. 카테고리는 대상과 그 사이를 이어주는 화살표로 구성되기 때문에 그림으로 나타내기도 매우 쉽다. 대상은 원이나 점으로 그리면 되고, 화살표는 그냥 화살표로 그리면 된다. (쉬운 이해를 위해 객체를 돼지 모양으로 그리고 화살표는 폭죽으로 그릴 것이다.)</p>\n<p>하지만 카테고리의 본질은 합성(Composition)이다. 취향에 따라서 합성의 본질은 카테고리라고 말할 수도 있겠다. 만약 카테고리 내에 대상 A에서 다른 대상 B로 향하는 화살표와 대상 B에서 다른 대상 C로 향하는 화살표가 존재한다면, 반드시 대상 A에서 대상 C로 향하는 화살표, 즉 A→B와 B→C의 합성이 존재해야한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d0f06f731f3390dda0d7113c6f3aeaab/8e43b/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 43.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAGQAAAQUAAAAAAAAAAAAAAAAAAAECAwQF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB1VsgwkD/xAAYEAEAAwEAAAAAAAAAAAAAAAACAAESEP/aAAgBAQABBQKrcLtEaz3/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAcEAABAwUAAAAAAAAAAAAAAAABAAIxESAiQXH/2gAIAQEABj8CcXxpVAPFlNn/xAAYEAEBAQEBAAAAAAAAAAAAAAABEQAgUf/aAAgBAQABPyE0DGQFpiQQHjj/2gAMAwEAAgADAAAAELAP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAQACAwEAAAAAAAAAAAAAAREAISAxQZH/2gAIAQEAAT8QhzVk9PLN42UCU2/TWM6RsHXD/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/d0f06f731f3390dda0d7113c6f3aeaab/c08c5/1.jpg\" srcset=\"/static/d0f06f731f3390dda0d7113c6f3aeaab/0913d/1.jpg 160w,\n/static/d0f06f731f3390dda0d7113c6f3aeaab/cb69c/1.jpg 320w,\n/static/d0f06f731f3390dda0d7113c6f3aeaab/c08c5/1.jpg 640w,\n/static/d0f06f731f3390dda0d7113c6f3aeaab/6a068/1.jpg 960w,\n/static/d0f06f731f3390dda0d7113c6f3aeaab/eea4a/1.jpg 1280w,\n/static/d0f06f731f3390dda0d7113c6f3aeaab/8e43b/1.jpg 1845w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>하나의 카테고리에서 A에서 B로 이어지는 화살표와 B에서 C로 이어지는 화살표가 있다면,<br>반드시 A에서 C로 직접 이어지는 화살표, 즉 A→B 화살표와 A→C 화살표의 합성도 존재해야 한다.<br>나중에 다시 설명하겠지만 이 다이어그램은 항등 사상이 빠져있기 때문에 완벽한 카테고리는 아니다.</small>\n</center>\n<h2 id=\"11-함수로써의-화살표\" style=\"position:relative;\">1.1 함수로써의 화살표<a href=\"#11-%ED%95%A8%EC%88%98%EB%A1%9C%EC%8D%A8%EC%9D%98-%ED%99%94%EC%82%B4%ED%91%9C\" aria-label=\"11 함수로써의 화살표 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>벌써부터 너무 추상적이라 잘 이해가 안 가는가? 자 그럼 이제 조금 더 구체적인 이야기를 해보자. 화살표를 사상(Morphisms)이라고 불리는 함수라고 한번 생각해보는 것이다.</p>\n<p>자 여기 두 개의 함수 f와 g가 있다. 함수 f는 A 타입의 인자를 받아 B 타입의 값을 반환하며, 함수 g는 B 타입의 인자를 받아 C 타입의 값을 반환한다. 그럼 이제 우리는 함수 f의 결과를 함수 g에 전달하여 이 두 개의 함수를 합성할 수 있다. 우리는 결국 A 타입의 인자를 받아 C 타입의 값을 반환하는 새로운 함수를 정의한 것이다.</p>\n<p>수학에서는 이러한 함수들의 합성을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>와 같이 함수 사이에 작은 원을 그려 표현하며, 합성된 함수의 실행 순서는 오른쪽에서 왼쪽으로 흘러간다. 아마 Unix의 파이프 표기법이나 F#의 Shevron(<code class=\"language-text\">>></code>)에 익숙한 일부 프로그래머들에게는 이게 조금 헷갈릴 수도 있다. 이러한 표기법들은 모두 왼쪽에서 오른쪽으로 진행되기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\"><span class=\"token comment\"># Unix의 파이프 표기법</span>\n<span class=\"token function\">lsof</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> Chrome</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그러나 수학과 Haskell에서 함수 합성은 모두 오른쪽에서 왼쪽의 순서로 진행된다. 만약 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">g\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span>를 “f 다음에 g”로 읽는다면 앞으로 나오는 설명들을 이해하는데 도움이 될 것이다.</p>\n<p>더 명확한 설명을 위해 C 코드를 예시로 들어보겠다. 여기 하나의 A타입의 인자를 받아 B타입의 값을 반환하는 함수 f가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">B <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>A a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 B타입 인자를 받아 C타입의 값을 반환하는 또 다른 함수인 g도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">C <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>B b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이들의 합성은 다음과 같이 나타낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">C <span class=\"token function\">g_after_f</span><span class=\"token punctuation\">(</span>A a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>즉, 이렇게 C로 작성된 코드를 통해서도 다시 한번 오른쪽에서 왼쪽으로 진행되며 합성되는 <code class=\"language-text\">g(f(a));</code>를 확인해볼 수 있다.</p>\n<p>C++ 표준 라이브러리에 두 개의 함수를 받아 합성함수를 반환하는 템플릿이 있다면 좋겠지만 그런 템플릿은 존재하지 않는다. 그러면 한번 Haskell로 한번 표현해보면 어떨까?</p>\n<p>여기 A를 인자로 받아 B를 반환하는 함수 f가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">A</span> <span class=\"token operator\">-></span> <span class=\"token constant\">B</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기에 이어 B를 인자로 받아 C를 반환하는 함수 g를 선언하겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span> <span class=\"token operator\">::</span> <span class=\"token constant\">B</span> <span class=\"token operator\">-></span> <span class=\"token constant\">C</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그리고 이 두 함수의 합성 함수는 아래와 같이 나타낼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\">g<span class=\"token punctuation\">.</span>f</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이처럼 Haskell에서 함수의 합성에 대한 개념을 간단하게 표현하는 것을 보면, C++에서 직관적인 함수 개념을 표현하지 못하는 것이 당혹스럽기까지 하다. 심지어 Haskell은 유니코드 문자를 사용하여 아래와 같이 합성을 표현하는 기능까지 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span>◦<span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>또한 아래와 같이 유니코드 이중 콜론과 화살표 문자도 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">A</span> → <span class=\"token constant\">B</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서 이중 콜론은 “~의 타입을 가진다”라는 의미이며, 함수 타입은 두 개의 타입 사이에 화살표를 삽입하여 표현한다. 두 개의 함수를 합성하기 위해서는 그 사이에 <code class=\"language-text\">.</code> 이나 유니코드 <code class=\"language-text\">◦</code> 기호를 사용할 수 있다. 이것이 바로 내가 여러분에게 제공하는 첫 번째 Haskell 수업이다.</p>\n<h2 id=\"12-합성의-속성\" style=\"position:relative;\">1.2 합성의 속성<a href=\"#12-%ED%95%A9%EC%84%B1%EC%9D%98-%EC%86%8D%EC%84%B1\" aria-label=\"12 합성의 속성 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>어떤 카테고리든 상관없이, 합성이라는 개념이 만족시켜야하는 매우 중요한 두 가지 특성이 있다.</p>\n<hr>\n<h3 id=\"1-합성에는-결합법칙이-성립해야-한다\" style=\"position:relative;\">1. 합성에는 결합법칙이 성립해야 한다.<a href=\"#1-%ED%95%A9%EC%84%B1%EC%97%90%EB%8A%94-%EA%B2%B0%ED%95%A9%EB%B2%95%EC%B9%99%EC%9D%B4-%EC%84%B1%EB%A6%BD%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"1 합성에는 결합법칙이 성립해야 한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>만약 세 개의 사상인 f, g, h가 있고 이들이 합성될 수 있다면, 괄호 여부, 위치와 상관없이 항상 같은 결과를 반환해야 한다. 수학 표기법에서는 다음과 같이 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">h◦(g◦f) = (h◦g)◦f = h◦g◦f</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서의 의사(Pseudo) 코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">A</span> <span class=\"token operator\">-></span> <span class=\"token constant\">B</span>\n<span class=\"token hvariable\">g</span> <span class=\"token operator\">::</span> <span class=\"token constant\">B</span> <span class=\"token operator\">-></span> <span class=\"token constant\">C</span>\n<span class=\"token hvariable\">h</span> <span class=\"token operator\">::</span> <span class=\"token constant\">C</span> <span class=\"token operator\">-></span> <span class=\"token constant\">D</span>\n\n<span class=\"token hvariable\">h</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">f</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">h</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">g</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">f</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">h</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">g</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">f</span>\n<span class=\"token comment\">-- 함수에 대해서는 비교 연산 정의가 없기 때문에 Pseudo 코드라고 이야기 했다.</span>\n<span class=\"token comment\">-- 함수의 결합법칙은 꽤나 당연하고 명확해보이지만, 다른 카테고리에서는 이렇게 명확한 정의가 안 될수도 있다.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"2-모든-대상-a에는-항등의-개념을-가진-화살표가-존재해야-한다\" style=\"position:relative;\">2. 모든 대상 A에는 항등의 개념을 가진 화살표가 존재해야 한다.<a href=\"#2-%EB%AA%A8%EB%93%A0-%EB%8C%80%EC%83%81-a%EC%97%90%EB%8A%94-%ED%95%AD%EB%93%B1%EC%9D%98-%EA%B0%9C%EB%85%90%EC%9D%84-%EA%B0%80%EC%A7%84-%ED%99%94%EC%82%B4%ED%91%9C%EA%B0%80-%EC%A1%B4%EC%9E%AC%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"2 모든 대상 a에는 항등의 개념을 가진 화살표가 존재해야 한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 화살표는 해당 대상에서 나와 다시 해당 대상으로 되돌아가는 루프라고 볼 수 있으며, 항등 화살표가 되기 위해서는 이 화살표를 대상 A에서 시작하거나, 또는 대상 A에서 끝나는 어떤 화살표와 합성하더라도 항상 같은 화살표가 나와야 한다. 대상 A에 대한 항등 화살표는 idA(항등사상. identity on A.)이라고 불린다. 만약 f가 A에서 B로 나아가는 경우 수학 표기로는 아래와 같이 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"mathematica\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-mathematica line-numbers\"><code class=\"language-mathematica\">f◦idA <span class=\"token operator\">=</span> f\nidB◦f <span class=\"token operator\">=</span> f</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<hr>\n<p>이를 함수로 다룰 때, 항등 화살표는 받은 인자를 그대로 반환하는 항등 함수로 구현된다. 이러한 특성은 모든 타입에 대해 동일하기 때문에 이 함수는 보편적인 다형성(Universally polymorphic)을 가지고 있다고 볼 수 있다.</p>\n<p>C++에서는 아래와 같은 Template으로 정의해볼 수 있겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">class</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> T <span class=\"token function\">id</span><span class=\"token punctuation\">(</span>T x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>물론 C++에서는 인자의 타입 뿐만 아니라 By reference, By const, By value 등 인자를 전달하는 방식도 함께 고려해야하기 떄문에 실제로는 이렇게 간단하지 않다.</p>\n<p>Haskell에서는 Prelude라고 불리는 표준 라이브러리에 항등함수의 정의가 선언되어있고, 그 정의는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">id</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">id</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이처럼 Haskell에서는 타입을 타입 변수로 대체하기만 하면 되기 때문에 다형성을 만족시키는 함수를 정의하기가 매우 쉬운 편이다. 위 예시에서 주의해야 할 점이 하나 있는데, Haskell에서 구체적인 타입의 이름은 항상 대문자로 시작하고 타입 변수의 이름은 소문자로 시작한다는 것이다. 즉, 위 예시의 <code class=\"language-text\">a</code>는 타입 변수이며 모든 타입을 의미한다.</p>\n<p>Haskell의 함수 정의는 함수 이름 다음에 Formal Paramter가 따라오도록 작성한다. (위 예시에서의 Formal Paramter는 <code class=\"language-text\">x</code> 하나이다.) Haskell 초보자들에게 이러한 간결함은 익숙하지 않을 수도 있지만 금방 이 표현이 말이 된다는 것은 이해할 수 있을 것이다.</p>\n<p>함수형 프로그래밍에서 함수를 정의하는 것과 호출하는 것은 빠질 수 없는 필수요소이므로 관련된 문법을 최소한으로 줄인 것이다. 인수 목록에는 괄호가 없을 뿐만 아니라 인수들 간의 쉼표 조차도 없다. (추후 여러 인수를 가진 다인수 함수를 정의할 때 쉼표가 나올 것이다.)</p>\n<p>함수의 본문은 항상 표현식(Expression)이며, 문(Statement)은 존재하지 않는다. 함수의 결과는 바로 이 표현식이며 위 예시에서는 <code class=\"language-text\">x</code>일 것이다. 이게 바로 나의 두 번째 Haskell 레슨이다.</p>\n<p>앞서 언급했던 항등사상에 대한 조건은 Haskell 의사 코드로 다음과 같이 작성해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">id</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">f</span>\n<span class=\"token builtin\">id</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">f</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">f</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이쯤 되면 아마 “왜 아무런 기능도 없는 항등 함수 같은 개념이 필요한지”에 대한 질문이 나올 수 있다. 하지만 잘 생각해보자. 그러면 우리는 왜 0이라는 숫자에 관심을 가질까? 0은 아무것도 없음을 나타내는 기호이지 않은가? 심지어 고대 로마인들은 0이 없는 수 체계를 가졌지만 그들은 훌륭한 도로와 수로를 건설할 수 있었으며, 그 중 일부는 오늘날까지도 남아있다.</p>\n<p>사실 0이나 id와 같은 중립적인 값들은 기호로 이루어진 변수들을 다룰 때 매우 유용하다. 그래서 로마인들은 대수학을 잘 하는 편이 아니었지만, 이미 0이라는 개념에 익숙했던 아랍과 페르시아인들은 대수학을 잘 했다. 어쨌든 항등함수는 고차함수(Higher Ordered Function)의 인수로 사용하거나 반환값으로 사용할 때 매우 편리하며, 이러한 고차함수들은 함수를 일종의 기호로써 바라보고 조작하는 것을 가능하게 해준다. 즉, 함수를 사용한 대수학이 가능해지는 것이다.</p>\n<p>요약해보자면, 하나의 카테고리는 대상과 화살표(사상)으로 이루어져 있다. 이러한 화살표들은 합성이 가능하며, 이 합성에는 결합법칙이 성립되어야 한다. 모든 대상들은 항등화살표(항등사상)을 가지고 있으며 이는 합성에 대한 항등원 역할을 한다.</p>\n<h2 id=\"13-합성은-프로그래밍의-본질이다\" style=\"position:relative;\">1.3 합성은 프로그래밍의 본질이다.<a href=\"#13-%ED%95%A9%EC%84%B1%EC%9D%80-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%EB%B3%B8%EC%A7%88%EC%9D%B4%EB%8B%A4\" aria-label=\"13 합성은 프로그래밍의 본질이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수형 프로그래머들은 상당히 독특한 방식으로 문제에 접근한다. 이들은 가장 먼저 철학적인 질문을 던지며 접근을 시작하는데, 예를 들어 인터렉티브 프로그램을 만들어야 한다면 가장 먼저 “상호작용(Interactive)란 무엇인가?”라는 질문을 던지는 식이다.</p>\n<p>콘웨이의 생명 게임(Conway’s Game of Life)을 구현할 때는 아마 인생의 의미에 대해 생각할지도 모르겠다. 그렇다면 이러한 맥락에 따라 나는 이런 질문을 던져보고자 한다.</p>\n<blockquote>\n<p>“프로그래밍이란 무엇인가?”</p>\n</blockquote>\n<p>가장 기본적인 수준에서 이야기해보자면 프로그래밍은 결국 컴퓨터에게 어떠한 행위를 하기 위한 명령을 내리는 것이다. “메모리 주소 x가 가리키는 내용을 EAX 레지스터에 더해라”처럼 말이다.</p>\n<p>그러나 우리가 어셈블리어로 프로그래밍을 할 때조차도 우리가 컴퓨터에게 내리는 명령들은 이것보다는 좀 더 많은 의미를 가지고 있다. 우리는 매우 크고 복잡한 문제를 풀기 위해 컴퓨터를 사용하며, 애초에 그 정도 수준의 문제가 아니었다면 컴퓨터를 사용하지도 않았을 것이다.</p>\n<p>그렇다면 우리는 문제들을 어떻게 해결하는가? 우선 우리는 큰 하나의 문제를 작은 여러 개의 문제들로 쪼갠다. 그래도 여전히 이 문제가 너무 크다면 이를 다시 더 작은 문제들로 쪼개고, 계속 이 과정을 계속 반복하며, 최종적으로 우리는 이러한 작은 문제들을 해결할 수 있는 코드를 작성한다.</p>\n<p>그리고 바로 이때 프로그래밍의 본질이 나타난다. 바로 작은 문제들을 해결하는 코드 조각들을 합성하여 더 큰 문제에 대한 해결책을 만들어낸다는 것이다. 만약 문제를 쪼갤 수만 있고 이들을 다시 합칠 수 없다면 애초에 문제를 분할해서 해결한다는 의미도 없었을 것이다.</p>\n<p>이러한 계층적인 분해와 재조립 과정은 컴퓨터가 우리에게 강제한 사고방식이 아니며, 이는 결국 인간의 사고력에 대한 한계를 반영한 것이다. 우리의 뇌는 한 번에 처리할 수 있는 개념의 수가 제한적이다. 심리학에서 많이 인용되는 논문 중 하나인 “<a href=\"https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two\" target=\"_blank\" rel=\"nofollow\">The Magical Number Seven, Plus or Minus Two</a>”에서는 우리가 한 번에 7±2개의 정보 청크(Chunk)만을 기억할 수 있다고 이야기하고 있다.</p>\n<p>물론 인간의 단기기억 능력에 대한 개념들과 주장들은 시간이 지남에 따라 조금씩 변하기는 하지만, 인간의 단기기억 능력이 제한적이라는 사실 하나만큼은 변하지 않는다. 결국 우리는 너무 많은 객체들이 버무려져있는 스파게티 코드를 처리할 수 없다는 것이다.</p>\n<p>우리는 단지 잘 설계된 프로그램이 멋있어 보이기 때문에 설계를 하는 것이 아니라, 제대로 설계를 하지 않으며 우리의 뇌가 코드를 효율적으로 읽기 어렵기 때문에 하는 것이다. 우리는 종종 어떤 코드를 보고 우아하다거나 아름답다고 이야기하지만, 이런 표현들은 결국 우리의 제한된 두뇌를 사용하여 이 코드를 이해하기가 쉽다는 것을 의미한다. 즉, 우아한 코드는 우리의 뇌가 처리할 수 있는 적절한 크기, 그리고 적절한 개수의 청크들을 만들어내는 것이라고 볼 수 있다.</p>\n<p>그렇다면 프로그램을 구성하는 데에 있어 적합한 청크는 무엇일까? 일단 청크의 면적은 청크의 부피보다 느리게 증가해야 한다. (나는 이 비유를 좋아하는데, 기하학적 대상의 면적이 길이의 제곱에 비례하여 증가한다는 직관 때문이다. 길이의 세제곱에 비례해서 증가하는 부피보다는 느린 속도로 증가한다.)</p>\n<p>여기서 면적이라는 것은 우리가 하나의 청크를 합성하는 데에 필요한 정보이며, 부피는 우리가 청크를 구현하는 데에 필요한 정보이다. 즉, 하나의 청크를 구현하고 나면 그 구현의 세부 정보는 모두 잊어버리고 다른 청크와의 상호작용에만 집중할 수 있도록 하자는 것이다.</p>\n<p>객체지향 프로그래밍에서의 면적은 클래스 선언이나 추상 인터페이스이지만, 함수형 프로그래밍에서는 함수의 선언이라고 볼 수 있다. (조금 단순화해서 설명했지만, 결국 이게 핵심이다.)</p>\n<p>카테고리 이론은 각 대상의 내부를 살피는 것을 적극적으로 막기 때문에 극단적인 예시라고 볼 수도 있다. 카테고리 이론에서의 대상은 굉장히 추상적인 객체이다.</p>\n<p>어떤 대상에 대해서 알 수 있는 것은 그저 다른 대상과의 관계, 즉 화살표를 사용하여 어떤 식으로 연결되어있는지 뿐이다. 이는 인터넷 검색 엔진이 서로 연결되어있는 링크를 분석하여 각 웹사이트들의 순위를 매기는 방식과 동일하다. 객체지향 프로그래밍에서의 이상적인 객체는 추상적인 인터페이스(면적에 대한 특성만 가지고 부피가 없는 녀석)를 통해서만 볼 수 있으며, 메소드는 카테고리 내 화살표의 역할을 수행한다. 만약 객체를 다른 객체와 합성하기 위해 객체의 구현을 까봐야 하는 순간 이 프로그래밍 패러다임의 장점은 사라지게 된다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240130-category-theory-for-programmers-1-category","path":"/2024/01/30/category-theory-for-programmers-1-category/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 1. 카테고리: 합성의 본질","subTitle":null,"date":"Jan 30, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"e9b3e8a2-5111-57e1-b278-0a2be7d34e13","tableOfContents":"<ul>\n<li><a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\">원문 보기</a></li>\n</ul>","excerpt":"얼마 전부터 나는 프로그래머를 대상으로 하는 카테고리 이론에 대한 책을 작성하려는 아이디어를 떠올렸다. 즉 이 책은 컴퓨터 과학자가 아닌 프로그래머, 그리고 과학자보다는 엔지니어들을 대상으로 하는 책이다. 분명 과학과 엔지니어링 사이에는 큰 간극이 존재한다. 게다가 나는 그 간극의 양쪽 끝에서 일해보기도 했기 때문에 다른 사람들에게는 이런 아이디어가 미친 생각처럼 보일 수도 있을 것이다. 하지만 나는 항상 이 이론을 제대로 설명하고 싶다는 강한 의지를 가지고 있었다. 나는 단순한 설명의 달인인 물리학자 리처드 파인만을 굉장히 존경…","html":"<p>얼마 전부터 나는 프로그래머를 대상으로 하는 카테고리 이론에 대한 책을 작성하려는 아이디어를 떠올렸다. 즉 이 책은 컴퓨터 과학자가 아닌 프로그래머, 그리고 과학자보다는 엔지니어들을 대상으로 하는 책이다.</p>\n<p>분명 과학과 엔지니어링 사이에는 큰 간극이 존재한다. 게다가 나는 그 간극의 양쪽 끝에서 일해보기도 했기 때문에 다른 사람들에게는 이런 아이디어가 미친 생각처럼 보일 수도 있을 것이다. 하지만 나는 항상 이 이론을 제대로 설명하고 싶다는 강한 의지를 가지고 있었다.</p>\n<p>나는 단순한 설명의 달인인 물리학자 리처드 파인만을 굉장히 존경해왔다. 물론 내가 파인만처럼 잘 설명할 수는 없겠지만 그래도 한번 최선을 다 해볼 것이다.</p>\n<p>우선 카테고리 이론을 학습하려는 독자들에게 동기를 부여하기 위해 이 서문을 작성함으로써, 이 서문이 앞으로 활발한 토론과 피드백을 구할 수 있는 초석이 되기를 바란다.</p>\n<p>우선 다음 몇 문단을 통해 이 책이 여러분을 위해 작성된 것이며 당신이 “남는 시간”을 투자하는 것만으로도 가장 추상적인 수학 분야 중 하나를 배우는 것에 대해 전혀 거부감을 가질 필요가 없다는 것을 보여주려고 한다. 나의 이러한 낙관론은 관찰 끝에 나온 몇 가지 사실들에 기반을 두고 있다.</p>\n<p>첫째, 카테고리 이론은 매우 유용한 프로그래밍 아이디어들의 보물 창고이다. 이미 오래전부터 Haskell 프로그래머들은 이 아이디어들을 사용해왔고, 이제는 슬슬 이 아이디어들이 다른 언어로도 퍼지고 있기는 하지만, 이 과정은 느려도 너무 느리다. 우리는 이 전파 속도를 가속시켜야 한다.</p>\n<p>둘째, 수학에는 많은 분야가 있으며, 이 분야들은 모두 각기 다른 대상에 대한 연구를 하고 있다. 물론 여러분이 미적분학이나 대수학 같은 것들에 대한 알레르기가 있을 수는 있겠지만, 그렇다고 해서 카테고리 이론을 즐길 수 없는 것은 아니다.</p>\n<p>사실 카테고리 이론은 어떤 구체적인 계산과 같은 내용이 아닌 추상적인 구조에 대한 이야기를 하고 있기 때문에 특히 프로그래머의 사고방식과 잘 맞는 수학 분야이다. 카테고리 이론은 프로그램을 합성 가능하도록(composable) 만들 수 있는 구조에 대해서 다룬다.</p>\n<p>합성이라는 것은 카테고리 이론을 이루는 가장 근본적인 개념이며, 프로그래밍의 본질이기도 하다. 옛날옛적 몇몇 위대한 엔지니어가 서브루틴이라는 개념을 도입하기 이전부터 우리는 이미 합성이라는 행위를 하고 있었다.</p>\n<p>예전 구조적 프로그래밍의 원칙은 코드 블록이라는 개념을 합성할 수 있도록 만들어줌으로써 프로그래밍에 대한 혁신을 불러왔다. 그리고 이후 OOP(객체지향 프로그래밍)가 등장했으며, 이 또한 객체들을 합성하는 방법에 대한 이야기를 하고 있다.</p>\n<p>하지만 FP(함수형 프로그래밍)는 이를 넘어 함수와 대수적인 데이터 구조들을 합성할 수 있게 해주고, 심지어 동시성(concurrency) 또한 합성할 수 있도록 해준다. 이는 지금까지의 다른 프로그래밍 패러다임으로는 거의 불가능한 일이다.</p>\n<p>마지막으로 나는 수학을 프로그래머들에게 보다 재미있게 전달할 수 있는 비밀 무기를 하나 가지고 있다.</p>\n<p>만약 당신이 전문적인 수학자라면 모든 가정을 명확하게 정의하고 모든 주장을 정확하게 설명할 수 있어야 하며, 여기서 파생된 증명들은 엄격하게 구성할 수 있어야 한다. 하지만 오히려 이러한 수학의 특징들로 인해 일반인들이 수학과 관련된 논문이나 책을 이해하기란 결코 쉽지 않은 것이 현실이다.</p>\n<p>나는 물리학자 출신이며, 물리학은 이러한 수학의 틀을 벗어난 직관적 사고를 통해 놀라운 발전을 이루어냈다는 말을 먼저 하고 싶다. 수학자들은 위대한 물리학자 P.A.M 디랙이 미분 방정식을 풀기 위해 즉흥적으로 만들어낸 디랙-델타 함수를 보고 비웃었지만, 결국 디랙의 아이디어가 구체적인 형식을 갖춘 뒤 분포 이론이라는 완전히 새로운 미적분 분야로 정립된 이후에 그들은 더 이상 웃지 못했다.</p>\n<p>물론 Hand-waving하게 설명을 할 때는 잘못된 설명을 할 가능성이 있으므로, 이 책에서 나는 직관적인 설명이나 개념 뒤에는 사실 탄탄한 수학적 이론이 함께 존재한다는 것을 이야기해줄 것이다.</p>\n<blockquote>\n<p><strong>💡 역주</strong></p>\n<p>Hand wave는 “상대방이 이해하기 쉽도록 어려운 것을 간단하게 풀어서 설명한다”는 관용 표현이다.</p>\n</blockquote>\n<p>물론 이 글은 프로그래머들을 위한 카테고리 이론에 대한 이야기를 하고 있으니, 나는 앞으로 설명할 모든 주요 개념을 컴퓨터 코드와 함께 설명할 것이다.</p>\n<p>아마 여러분도 알고 있겠지만 함수형 언어는 명령형 언어에 비해 수학에 더 가까우며, 더 강력하게 추상화를 할 수 있는 힘을 가져다준다. 그래서 자연스럽게 “카테고리 이론을 이해하려면 Haskell을 배워야해”라고 말하고 싶은 유혹에 빠지게 된다.</p>\n<p>하지만 오히려 이런 생각들이 마치 함수형 프로그래밍 이외의 분야에서는 카테고리 이론이 적용될 수 없다는 오해를 불러일으킬 수도 있기 때문에 나는 가급적이면 많은 C++ 예제를 함께 제공해보려고 한다.</p>\n<p>물론 몇 가지 난해한 문법들을 극복해야할 수도 있고, 장황한 패턴들도 존재할 수 있으며, 높은 레벨의 추상화 대신 복사 붙여넣기를 해야할 수도 있겠지만, 뭐 그게 원래 C++ 프로그래머들이 하는 일이 아닌가?</p>\n<p>하지만 한 가지 알아둬야 할 점은 여러분이 Haskell 프로그래머가 될 필요까지는 없어도 C++로 구현할 아이디어들을 스케치하고 문서화하기 위해서는 결국은 Haskell이 필요하기 때문에 여전히 Haskell이 중요하기는 하다는 것이다.</p>\n<p>사실 이것이 내가 Haskell을 시작했던 이유이다. Haskell의 간결한 문법과 강력한 타입 시스템은 내가 C++의 템플릿, 데이터 구조 그리고 알고리즘을 이해하고 구현하는데에 큰 도움이 된다고 생각한다. 하지만 여러분이 이미 Haskell을 알고 있다고 기대하기는 어렵기 때문에 이런 것들에 대해서는 천천히 소개하고 진행하며 설명해나가려고 한다.</p>\n<p>만약 여러분이 경력직 개발자라면 “지금까지 나는 카테고리 이론이나 함수형 개념같은 것들을 몰라도 코딩하는데는 문제가 없었는데, 도대체 뭐가 변한걸까?”라는 생각이 들 수도 있다. 하지만 이미 여러분은 알게 모르게 기존의 명령형 언어들에 계속 해서 함수형 개념이 도입되고 있다는 사실을 느끼고 있을 것이다.</p>\n<p>객체 지향 프로그래밍의 최후의 보루로 여겨졌던 자바에도 C++의 람다(Lambda)와 같은 개념이 추가되었으며, C++의 람다는 변화하는 세상을 따라잡기 위해 몇 년에 한번씩 새로운 표준이 나올만큼 미친 속도로 발전하고 있다.</p>\n<p>이러한 모든 현상들은 급격한 변화, 흔히 물리학자들이 이야기하는 “상전이(Phase Transition)”를 준비하는 과정이다. 물을 계속 가열하면 결국 끓기 시작하는 것처럼 말이다. 우리는 이제 점점 더 뜨거워지는 물 속에서 계속 헤엄을 칠지, 혹은 다른 대안을 찾아보기를 시작해야할지 결정해야하는 개구리의 입장에 놓여있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/a43196a41329474bae8b5d061ef59f6e/ad059/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 71.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAv/aAAwDAQACEAMQAAAB7KpCWoRT/8QAGhABAAIDAQAAAAAAAAAAAAAAAQACAxMiMf/aAAgBAQABBQIeq5BZYU1Q8//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABoQAAICAwAAAAAAAAAAAAAAAAAhAhEQMmH/2gAIAQEABj8Clwq8I2Yz/8QAHBAAAgICAwAAAAAAAAAAAAAAAREAITFBEFFh/9oACAEBAAE/Icoa7QjyA73woKHlx6LH1GFjM//aAAwDAQACAAMAAAAQ38//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAXEQADAQAAAAAAAAAAAAAAAAABECEx/9oACAECAQE/EKMX/8QAHBABAAICAwEAAAAAAAAAAAAAAQARIUEQMVGR/9oACAEBAAE/EFwom1B1AmSgCqvzh6jdg1HEhGQiOb89ISBbUKJ//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"\" src=\"/static/a43196a41329474bae8b5d061ef59f6e/c08c5/1.jpg\" srcset=\"/static/a43196a41329474bae8b5d061ef59f6e/0913d/1.jpg 160w,\n/static/a43196a41329474bae8b5d061ef59f6e/cb69c/1.jpg 320w,\n/static/a43196a41329474bae8b5d061ef59f6e/c08c5/1.jpg 640w,\n/static/a43196a41329474bae8b5d061ef59f6e/ad059/1.jpg 758w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이러한 큰 변화를 주도하는 힘 중에 하나는 바로 멀티코어(multicore) 혁명이다. 기존의 주류 프로그래밍 패러다임이었던 객체지향 프로그래밍은 동시성과 병렬성 영역에서 아무런 이점을 제공하지 못 하며, 오히려 위험한 버그를 발생시킬 수 있는 설계를 하게 되기 쉽상이다. 결국 객체지향의 기본 컨셉은 불필요한 정보를 은닉하는 것인데, 이러한 특성이 공유(Share), 변이(Mutation)와 결합되면 결국 데이터 레이스(Data race)가 발생하게 된다.</p>\n<blockquote>\n<p><strong>💡 역주</strong></p>\n<p>데이터 레이스(Data Race)란 여러 개의 쓰레드나 프로세스가 하나의 자원에 접근하려고 할 때 발생하는 Race Condition을 의미한다.</p>\n</blockquote>\n<p>물론 뮤텍스(Mutex)와 뮤텍스가 보호할 데이터를 결합하는 것은 좋은 아이디어이지만, 불행하게도 락(Lock)은 합성이 불가능하고 락을 은닉했다가는 데드락(Deadlock)이 발생할 가능성이 커져 디버깅을 더더욱 어렵게 만든다.</p>\n<p>하지만 꼭 이러한 동시성 이슈가 아니더라도, 점점 더 복잡해지는 소프트웨어 시스템이 명령형 패러다임의 확장성의 한계가 어디까지인지를 시험하고 있다. 간단히 이야기하자면 사이드이펙트의 관리가 점점 더 어려워지고 있다.</p>\n<p>사이드이펙트를 발생시키는 함수가 편리하기도 하고 작성하기도 쉽다는 사실은 인정한다. 원칙적으로 이러한 이펙트들은 함수의 이름이나 주석으로 표현될 수 있다. 예를 들어 SetPassword 나 WriteFile 같은 함수들은 명백하게 함수 외부의 상태들은 변경하고 사이드이펙트를 발생시키지만, 이미 우리는 이런 함수들을 다루는 것에 익숙하다.</p>\n<p>하지만 이렇게 사이드이펙트를 발생시키는 함수들을 다른 사이드이펙트를 발생시키는 함수와 합성하다보면 점점 문제가 복잡해진다. 사이드이펙트가 본질적으로 나쁘다는 이야기는 아니지만, 이런 이펙트들은 예측하기가 어렵기 때문에 큰 규모의 어플리케이션에서는 관리하기가 거의 불가능하다는 것이 문제이다. 즉, 모든 명령형 프로그래밍은 사이드이펙트를 피할 수 없지만, 사이드이펙트는 확장이 불가능하다는 것이다.</p>\n<p>하드웨어의 변화, 그리고 점점 더 복잡해지는 소프트웨어의 특성으로 인해 우리는 프로그래밍의 기반을 이루는 것이 무엇인가에 대해 다시 한번 생각해볼 필요가 생겼다.</p>\n<p>마치 유럽의 위대한 고딕 대성당을 짓던 건축가들처럼 우리는 재료와 구조에 대해 한계까지 기술을 연마해왔다. 현재까지도 미완성된 프랑스의 보베 대성당은 이러한 인간의 한계에 대한 투쟁을 잘 보여주는 사례이다. 보베 대성당은 이전에 지어진 그 어떤 성당보다 더 높고 경이로운 성당을 짓기 위해 건설되었지만 몇 차례의 붕괴 사고를 겪었다. 철제와 목재로 지지대를 만들어 계속 붕괴가 진행되는 것은 막았지만 여전히 많은 문제가 있다는 것은 분명하다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 360px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f68f06bd8feb123d3becedf20b45b561/158ba/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 133.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAwH/xAAXAQEAAwAAAAAAAAAAAAAAAAABAAID/9oADAMBAAIQAxAAAAGRk2yeGxYk1lZaSEJ//8QAGhABAQEBAAMAAAAAAAAAAAAAARECAAMQMf/aAAgBAQABBQJtzI46C4PGN7CiukNw9P3/xAAWEQEBAQAAAAAAAAAAAAAAAAARABD/2gAIAQMBAT8BI3//xAAXEQADAQAAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/AWbf/8QAHRAAAgEEAwAAAAAAAAAAAAAAABEBAhAgISIxMv/aAAgBAQAGPwJzImdnodXKLaNpY//EABsQAQACAwEBAAAAAAAAAAAAAAEAIRExQVFx/9oACAEBAAE/ITSsvPIFiNzB1GxtjyaEPJbWozTerikHwhAMIRsf/9oADAMBAAIAAwAAABCf0g7/xAAXEQADAQAAAAAAAAAAAAAAAAAAAREQ/9oACAEDAQE/EE8LFn//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREQ/9oACAECAQE/EGrzSH//xAAeEAEAAwACAwEBAAAAAAAAAAABABEhMUFRYXGB8P/aAAgBAQABPxA1GsX3aH7dxIPbctPMtBZlj5++4qcGuWEJu8wia8aR5Ha4zqHmUWt1/EPg8F3kLu0y4kFFH01G8W19neM//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"\" src=\"/static/f68f06bd8feb123d3becedf20b45b561/158ba/2.jpg\" srcset=\"/static/f68f06bd8feb123d3becedf20b45b561/0913d/2.jpg 160w,\n/static/f68f06bd8feb123d3becedf20b45b561/cb69c/2.jpg 320w,\n/static/f68f06bd8feb123d3becedf20b45b561/158ba/2.jpg 360w\" sizes=\"(max-width: 360px) 100vw, 360px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>임시 조치로 붕괴를 방지하고 있는 보베 대성당의 모습</small>\n</center>\n<p>현대적인 관점에서 보면 고딕 구조물이 재료 공학, 컴퓨터 모델링, 유한요소해석, 일반 수학과 물리학의 도움 없이도 성공적으로 완성되었다는 것은 기적에 가깝다. 나는 후대의 사람들도 우리가 복잡한 운영체제, 웹 서버, 그리고 인터넷 인프라를 구축하는 과정에서 사용해왔던 프로그래밍 기술들에 대해서 감탄해주길 바란다.</p>\n<p>아니, 그들은 감탄할 수 밖에 없을 것이다. 왜냐하면 우리는 매우 얄팍한 이론적 기초 위에서 이 모든 것들을 만들어왔기 때문이다. 하지만 우리는 결국 앞으로 더 나아가기 위해 이러한 기초들을 제대로 고쳐야 할 필요가 있다.</p>\n<h2 id=\"원문-보기\" style=\"position:relative;\">원문 보기<a href=\"#%EC%9B%90%EB%AC%B8-%EB%B3%B4%EA%B8%B0\" aria-label=\"원문 보기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<blockquote>\n<p>👉 <a href=\"https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf\" target=\"_blank\" rel=\"nofollow\">Category Theory for Programmers</a></p>\n</blockquote>","fields":{"slug":"20240130-category-theory-for-programmers-0-preface","path":"/2024/01/30/category-theory-for-programmers-0-preface/","lang":"ko"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 0. 서문","subTitle":null,"date":"Jan 30, 2024","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/1cda5/thumbnail.jpg 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b1a47/thumbnail.jpg 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/3a812/thumbnail.jpg 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/698e2/thumbnail.jpg 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/3e5ca/thumbnail.webp 80w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/b72f1/thumbnail.webp 160w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/fc5c5/thumbnail.webp 320w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/c5332/thumbnail.webp 640w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#e8d8c8","images":{"fallback":{"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/23110/thumbnail.jpg 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/da421/thumbnail.jpg 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/a2093/thumbnail.jpg 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/2c11c/thumbnail.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/6858b/thumbnail.webp 750w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/f5547/thumbnail.webp 1080w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/29310/thumbnail.webp 1366w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/dc0d9/thumbnail.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"b32128e6-4ad7-5b01-a6e0-47e1af5d0a18","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%83%80%EC%9D%B8%EC%9D%98-%ED%8F%89%EA%B0%80%EC%97%90-%EB%8C%80%ED%95%9C-%EB%B6%80%EB%8B%B4\">타인의 평가에 대한 부담</a></p>\n<ul>\n<li><a href=\"#%EB%84%93%EC%96%B4%EC%A7%84-%EC%B1%85%EC%9E%84%EB%A7%8C%ED%81%BC-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%9D%B4%EB%93%A4%EC%9D%98-%ED%8F%89%EA%B0%80%EB%A5%BC-%EB%B0%9B%EB%8A%94-%EC%83%81%ED%99%A9\">넓어진 책임만큼 다양한 이들의 평가를 받는 상황</a></li>\n<li><a href=\"#%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EA%B8%8D%EC%A0%95%EC%A0%81-%ED%8F%89%EA%B0%80%EC%99%80-%EC%84%A0%EC%9E%85%EA%B2%AC\">블로그로 인한 긍정적 평가와 선입견</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%82%B6%EC%9D%98-%EC%A3%BC%EC%9D%B8%EC%9C%BC%EB%A1%9C-%EC%82%B4%EC%95%84%EB%9D%BC\">삶의 주인으로 살아라</a></p>\n<ul>\n<li><a href=\"#%ED%86%B5%EC%A0%9C%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EA%B2%83%EA%B3%BC-%ED%86%B5%EC%A0%9C%ED%95%A0-%EC%88%98-%EC%97%86%EB%8A%94-%EA%B2%83%EC%9D%84-%EB%AA%85%ED%99%95%ED%9E%88-%EA%B5%AC%EB%B6%84%ED%95%98%EC%9E%90\">통제할 수 있는 것과 통제할 수 없는 것을 명확히 구분하자</a></li>\n<li><a href=\"#%EA%B2%B0%EA%B5%AD-%EC%9B%80%EC%A7%81%EC%9D%B4%EB%8A%94-%EA%B2%83%EC%9D%80-%EA%B7%B8%EB%8C%80%EC%9D%98-%EB%A7%88%EC%9D%8C%EC%9D%B4%EB%8B%A4\">결국 움직이는 것은 그대의 마음이다</a></li>\n<li><a href=\"#%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%80-%EC%96%91%EB%A9%B4%EC%A0%81%EC%9D%B8-%ED%8F%89%EA%B0%80%EB%A5%BC-%ED%95%9C%EB%8B%A4%EB%8A%94-%EC%82%AC%EC%8B%A4%EC%9D%84-%EA%B8%B0%EC%96%B5%ED%95%98%EC%9E%90\">대부분은 양면적인 평가를 한다는 사실을 기억하자</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"인간은 관계 속에서 살아가는 사회적 동물이라고 한다. 특히 사람들과의 관계 속에서 나 자신을 정의하는 특성이 강한 동양 문화권에서 살아가는 사람들은 타인의 시선과 평가를 의식하고 이에 따라 자신의 가치를 결정하는 실수를 흔히들 저지르고는 한다. 필자 또한 지난 30여년 간 대한민국이라는 동아시아 국가의 문화 속에서 살아온 한 명의 인간인 만큼 이러한 관념에서 자유로울 수 없어, 타인의 평가에 대해 신경을 쓰지 않으려고 해도 어쩔 수 없이 이에 흔들리는 상황을 경험하고는 한다. 물론 우리는 대부분의 인생을 어떠한 집단 속에 속해서 …","html":"<p>인간은 관계 속에서 살아가는 사회적 동물이라고 한다. 특히 사람들과의 관계 속에서 나 자신을 정의하는 특성이 강한 동양 문화권에서 살아가는 사람들은 타인의 시선과 평가를 의식하고 이에 따라 자신의 가치를 결정하는 실수를 흔히들 저지르고는 한다.</p>\n<p>필자 또한 지난 30여년 간 대한민국이라는 동아시아 국가의 문화 속에서 살아온 한 명의 인간인 만큼 이러한 관념에서 자유로울 수 없어, 타인의 평가에 대해 신경을 쓰지 않으려고 해도 어쩔 수 없이 이에 흔들리는 상황을 경험하고는 한다.</p>\n<p>물론 우리는 대부분의 인생을 어떠한 집단 속에 속해서 살아가게 되니 이러한 평가에서 온전히 자유로울 수는 없을 것이다. 비단 필자와 같은 직장인이 아닌 프리랜서라고 해도 본인이 일하는 업계라는 집단의 평가를 받을 수 있으며, 자영업을 하는 사람이라고 해도 특정 플랫폼 내에서의 리뷰나 동네의 로컬 네트워크 내에서의 평가에서 자유로울 수 없다.</p>\n<p>그러나 너무 이러한 평가들에 휘둘려 살게되면 진정한 나 자신을 잃어버리게 되는 일이 발생한다. 특히 모두에게 사랑받고 싶다는 마음을 가진 사람이라면 더더욱 이런 상황에 휩쓸리기 쉬운데, 어차피 타인의 평가는 매우 주관적이라 모두의 입맛에 맞추기란 굉장히 어렵기 때문이다. <small>(모두에게 사랑받고 싶다면 이순신 장군 정도의 위인은 되어야 하지 않을까)</small></p>\n<p>필자는 온전히 “나”라는 주체의 자존감과 신념을 지켜내야만 자신의 자아정체성을 확립하고 자아실현의 단계까지 나아갈 수 있다고 믿는다. 만약 나의 가치를 타인의 주관적 잣대에 의존하게 된다면 성숙한 자아를 유지하기 쉽지 않을 것이다. 결국 내 가치는 내 이성이 결정하는 것이다.</p>\n<p>이번 포스팅에서는 필자가 타인의 평가 속에서 겪었던 어려움과 이를 이겨내려고 노력하고 있는 방법에 대해서 이야기해보려고 한다.</p>\n<h2 id=\"타인의-평가에-대한-부담\" style=\"position:relative;\">타인의 평가에 대한 부담<a href=\"#%ED%83%80%EC%9D%B8%EC%9D%98-%ED%8F%89%EA%B0%80%EC%97%90-%EB%8C%80%ED%95%9C-%EB%B6%80%EB%8B%B4\" aria-label=\"타인의 평가에 대한 부담 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>먼저 필자가 타인의 평가를 신경썼던 경우들에 대한 이야기를 먼저 해보려고 한다. 이 중에서는 아마 독자 여러분이 공감하실만한 내용도, 필자만이 경험했던 특수한 상황도 있겠지만, 아마 누구나 한번 쯤은 타인의 평가에서부터 출발한 고민을 해보았으리라 생각한다.</p>\n<h3 id=\"넓어진-책임만큼-다양한-이들의-평가를-받는-상황\" style=\"position:relative;\">넓어진 책임만큼 다양한 이들의 평가를 받는 상황<a href=\"#%EB%84%93%EC%96%B4%EC%A7%84-%EC%B1%85%EC%9E%84%EB%A7%8C%ED%81%BC-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%9D%B4%EB%93%A4%EC%9D%98-%ED%8F%89%EA%B0%80%EB%A5%BC-%EB%B0%9B%EB%8A%94-%EC%83%81%ED%99%A9\" aria-label=\"넓어진 책임만큼 다양한 이들의 평가를 받는 상황 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자의 최근 커리어는 IC(Individual Contributor)가 아닌 조직을 이끄는 리더의 역할이었다. 리더라는 역할은 다른 사람들에게 방향성을 제시하고 공감시켜 움직이게 만듦으로써 혼자서는 해결할 수 없었던 문제들을 해결할 수 있다는 장점도 있지만, 역설적으로 이렇게 넓어진 책임만큼 IC일 때에 비해 더 다양한 이들에게 다양한 시각의 평가를 받을 수 있는 역할이기도 하다.</p>\n<p>아무래도 리더의 의사결정들은 조직 내의 많은 사람들에게 영향을 주게 되기도 하고, 평소 접하는 이해관계자 자체가 IC에 비해서 많기도 하다. 즉, 리더는 의사결정의 영향력이 IC에 비해 큰 만큼 주로 직접적으로 함께 일하는 동료들의 평가를 받게되는 IC와 달리 조직 전체에 속해있는 사람들에게서 비롯된 다양한 평가를 받게 된다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e46810019d235256fffc4e442cf29a91/89557/dri.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAADD0lEQVR42m1TX0iaURS/1UxNS5dbzubGosBt1NgYtcEaDQY9BIte3BiLBXsQKdrDYsTYgzDoYZRr/aEIqaigB8PFbAjh1JaJYmnln7TMxL85NXSuCQny7dzwGz3swuW7597f+Z1zfud8aG5urgwhRFlfX3+0u7v7QS6XX56YmCghCKIAnVn9/f2M6elp9uzsLEMikZQB9q3NZnuK36xW68W1tbVKqVRK/+dwcHCgABLC4XC8wLZOp6OBWUi+j46OMklbrVbXJ5NJIhgMunAg8LX7fL6wQqGoRSTI6XS2wKVsY2ODJxKJKJBpEb4nM4VK+BDkOQQsHhoaonp9vs9AJIKngv39fReQB8Cn7mxVmJiRP58DcGsgEOiBMmn4YmlpqUGv129OTU1dwTaPxyvBONhUnL1KpaKOjY1V4NLaQAMpBnG53FNC0Igdj8e3s9ks4fV6G/MZluWzLTDL5YKTeExxHAp94iNE9/v95yHDWyMjI5XIZDI9BEHfe398b4g7HD0OufwSztTtdrdHo9GPIDwXEyqVynrArQmbm8vtev14Kp0mErEYYVEqn/mDwflcLkdAY18ig9H42q9SVWeSyQhuSioQUIA/HXQsce/sfPV4PCtCoZAOJfG3trbEmNxjMr3D2F+JRNa4MH/PHwq9iUQiLq1W+xhptNrxoF53P5NO/8kB6OToaBV8mK+6uiqhUVGXy5Xo6+vjguDMycnJm+U1NWVChIridvuTuNVajwNAlVWAEwwMDFxAKysrLYODg4K409Z+HIl8CRgMtU1NTVhslMlkrqZSqer8qDSazeag0WjkdnZ2Mje3txU7e3sSXI3dbo8dHh7+lslkDxCMidpisbR+W1y8q9FoViHJIjyg5NiQCzcFSDn4PDMzc+dnNEqEQiEH/ilAloVwOKwZHh6uQqAPUyAQlELrby8vL7eLxeIKIKPnu12INz7j2cOBent7WVAB22AwtIGujRwOp7S7u5va0dFBAywNMRiMCgqFUldcXHwD/K7B5qP/r9MBZ7FYbPiQWCzHdfIHwGP1F/WavDK/RBI6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"dri\" title=\"\" src=\"/static/e46810019d235256fffc4e442cf29a91/6af66/dri.png\" srcset=\"/static/e46810019d235256fffc4e442cf29a91/69538/dri.png 160w,\n/static/e46810019d235256fffc4e442cf29a91/72799/dri.png 320w,\n/static/e46810019d235256fffc4e442cf29a91/6af66/dri.png 640w,\n/static/e46810019d235256fffc4e442cf29a91/d9199/dri.png 960w,\n/static/e46810019d235256fffc4e442cf29a91/21b4d/dri.png 1280w,\n/static/e46810019d235256fffc4e442cf29a91/89557/dri.png 1928w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>리더의 의사결정은 IC에 비해 넓어진 책임만큼 조직 내의 더 많은 사람들에게 영향을 끼치고 평가를 받게 된다.<br>이런 부담을 생각해보면 리더를 한다는 게 좋기만 한 것도 아닌 것 같다.</small>\n</center>\n<p>그런 이유로 인해 필자 또한 IC로 일할 때보다는 상대적으로 다양한 사람들에게 다양한 평가를 받는 환경에 노출되게 되었고, 아무래도 자연스럽게 이런 평가들에 대해 신경을 쓰게 되기 쉬운 환경에 노출되었다.</p>\n<p>여기서 재밌는 점은 이러한 평가들이 꽤나 주관적으로 이루어진다는 것이다. 리더가 A라는 방향성을 제시했을 때 이 방향성이나 가치관에 대하여 어떤 사람은 “잘 하고 있는 것 같다”라고 할 수도 있고 어떤 사람은 “저런 식으로 하면 안될 것 같다”라고 이야기할 수도 있다.</p>\n<p>물론 리더도 결국 한 명의 인간이니 리더의 의사결정들 또한 개인의 주관, 가치관, 경험, 인지한 정보 등에서 발현된 직관에 의해 진행된다. 정량적 데이터를 참고할 수 있는 상황이라면 좋겠지만 데이터 자체가 정답을 말해주는 것은 아니니 이를 해석해서 진행하는 의사결정은 결국 인간의 직관에서 비롯된다. 즉, 리더는 늘 정답을 제시하는 것이 아닌 본인의 기준에 따라 정답이라고 생각하는 방향을 제시한다는 것이다.</p>\n<p>마찬가지로 리더의 의사결정에 대한 평가들도 각 평가자의 주관에서 비롯된 기준에 의해 진행된다. 같은 현상을 보더라도 이 현상에 대한 평가는 이를 평가하는 인간 객체마다 각각 다를 수 있으며, 심지어 평가자의 중립성 또는 내향성이 강하다면 조직 내 다수의 의견이나 자신이 신뢰하는 다른 인간 객체의 의견에 편승하여 평가하는 경우도 있다.</p>\n<p>물론 평가 대상이 OKR, NSM, KPI와 같이 정량적인 목표 달성 여부라면 주관성이 포함되어있지 않은 평가를 할 수 있겠지만, 아직 결과가 나오지 않았을 때 목표를 달성하기 위해 제시된 방향성 또는 조직 문화와 같이 정량적 목표를 잡기 어려운 미션에 대해서는 성공/실패와 같은 이분법적 사고를 할 수가 없으니 결국 주관적인 요소들이 평가의 근거가 되기 쉬운 것이다.</p>\n<p>정리하자면 현실적으로 리더의 가치관은 모두의 공감을 받기 어려울 수도 있으며, 생각보다 이러한 의사결정이나 가치관에 대한 평가는 그것 자체보다는 오히려 리더라는 인간에 대한 평가, 즉 호감도나 신뢰 자산과 같은 요소들이 더 큰 영향을 끼치는 경우가 많다. 특히 조직 전체가 추구하는 공통적인 가치가 부재한 경우라면 더더욱 그렇다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/91b1a1491e66a4045794d72dae0055b2/acb04/review.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 32.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAcuAqD//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAEDH/2gAIAQEABj8CKv/EABcQAQEBAQAAAAAAAAAAAAAAAAEAYRH/2gAIAQEAAT8hdbpF2//aAAwDAQACAAMAAAAQA8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAEAAgIDAAAAAAAAAAAAAAABABEhUaHR8P/aAAgBAQABPxB0FJqhnsPcNcPmf//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"review\" title=\"\" src=\"/static/91b1a1491e66a4045794d72dae0055b2/c08c5/review.jpg\" srcset=\"/static/91b1a1491e66a4045794d72dae0055b2/0913d/review.jpg 160w,\n/static/91b1a1491e66a4045794d72dae0055b2/cb69c/review.jpg 320w,\n/static/91b1a1491e66a4045794d72dae0055b2/c08c5/review.jpg 640w,\n/static/91b1a1491e66a4045794d72dae0055b2/acb04/review.jpg 750w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>그래서 일을 하다보면 익명 플랫폼 내에서 이런 평가를 받기도 한다.<br>\"ㅌㅅ\"의 원문은 토스였는데, 이 조직에 토스를 경험하고 온 개발자는 필자 뿐이었다.</small>\n</center>\n<p>예를 들어 “일을 못하는 사람은 회사에서 해고 당하고 일을 잘하는 사람은 그에 걸맞는 보상을 받아야 한다”라는 가치관을 가진 리더가 있다고 생각해보자. 누군가는 이 리더의 생각에 대해 “자본주의 시장경제체제에서 그건 당연한 것 아니야?”라고 평가할 수 있는 반면, 누군가는 “그래도 회사는 우리가 하루의 대부분을 보내는 곳인데, 너무 차가운 것 같아”라고 평가할 수도 있다.</p>\n<p>이러한 가치들에 대한 옳고 그름을 따지는 것은 사실 의미가 없다. 이러한 이데올로기에는 정답이 없기 때문이다. 그저 각자가 옳다고 믿는 방향성을 외칠 뿐이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 559px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/88380e1d1c538b6f85ed9691d2d203c3/db7b4/politics.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 50.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABAACA//EABYBAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAABGhGM6Nd4/8QAGRAAAwADAAAAAAAAAAAAAAAAAAECEBJB/9oACAEBAAEFAphM0gcyjjx//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8Bqv/EABgQAAIDAAAAAAAAAAAAAAAAAAAyASAx/9oACAEBAAY/AsFgWn//xAAcEAEAAQQDAAAAAAAAAAAAAAABABARIUFhcYH/2gAIAQEAAT8hbtcvM1CdxrOsJOPCn//aAAwDAQACAAMAAAAQD/8A/8QAFhEAAwAAAAAAAAAAAAAAAAAAAAER/9oACAEDAQE/EIkQ/8QAFhEBAQEAAAAAAAAAAAAAAAAAAREQ/9oACAECAQE/EKVmf//EAB4QAQACAQQDAAAAAAAAAAAAAAEAESExQVGBcbHx/9oACAEBAAE/ELiAUsYO9NoE3Dt8gYa0JQ4HuY48QgABwHiUW4NX3P/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"politics\" title=\"\" src=\"/static/88380e1d1c538b6f85ed9691d2d203c3/db7b4/politics.jpg\" srcset=\"/static/88380e1d1c538b6f85ed9691d2d203c3/0913d/politics.jpg 160w,\n/static/88380e1d1c538b6f85ed9691d2d203c3/cb69c/politics.jpg 320w,\n/static/88380e1d1c538b6f85ed9691d2d203c3/db7b4/politics.jpg 559w\" sizes=\"(max-width: 559px) 100vw, 559px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이는 다당제 민주주의 국가의 의회를 생각해보면 쉽게 이해할 수 있다.<br>여러 정당이 외치는 이념 중 어떤 것이 정답인가?<br>정답은 없다. 그저 각자의 이익을 위해 혹은 국가의 이익을 위해 옳다고 생각하는 방향을 주장할 뿐이다.</small>\n</center>\n<p>하지만 결국 리더라는 역할을 맡은 사람은 자신의 가치관에 의거하여 조직에 가장 큰 임팩트를 만들어낼 수 있다고 생각하는 특정한 방향성을 제시해야만 한다. 아무리 다양성을 중시하는 조직이라도 기초가 되는 방향성조차 없다면 그저 각자가 자신이 옳다고 생각하는 것들을 외치고만 있는 혼란스러운 상황이 되어버리기 쉽기 때문이다.</p>\n<p>그래서 리더는 팀원들을 공감시킬 수 있는 미션, 즉 최소한의 방향성을 제시하고 이를 공감시킨 후 미션을 달성하기 위한 다양한 의견을 받아들이는 등 집단지성을 극대화할 수 있는 방향성과 다양성 간의 적절한 밸런스를 잡아야 한다.</p>\n<p>아마 필자가 제시했던 방향성도 그저 이런 수많은 방향성 중 하나였을테니 당연히 이 방향성에 대해 조직 내부에 있는 수많은 인간 객체들은 각자 저마다의 주관적 기준과 가치관에 의거하여 필자에 대한 평가를 했을 것이다.</p>\n<p>이렇게 필자를 평가하는 사람 자체도 많아지고 필자에 대한 각자의 기대치나 평가가 갈리는 환경에 노출되다보니 아무래도 예전에 비하면 이러한 평가들에 대해 신경을 쓰게 되기 쉬운 환경이었던 것 같다.</p>\n<h3 id=\"블로그로-인한-긍정적-평가와-선입견\" style=\"position:relative;\">블로그로 인한 긍정적 평가와 선입견<a href=\"#%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EA%B8%8D%EC%A0%95%EC%A0%81-%ED%8F%89%EA%B0%80%EC%99%80-%EC%84%A0%EC%9E%85%EA%B2%AC\" aria-label=\"블로그로 인한 긍정적 평가와 선입견 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>2017년 필자가 이 블로그를 처음 시작했을 때, 필자는 그저 글 쓰는 행위를 취미로 즐기는 평범한 한 명의 개발자였다. 물론 2023년 현재도 평범한 개발자인 것은 변하지 않았지만, 아무래도 오랜 기간 글을 써온 만큼 일상생활 속에서도 필자를 알아봐주시고 필자가 작성한 글에 대한 이야기를 해주시거나 심지어 팬이라고 해주시는 분들도 생겼다.</p>\n<p>아마 필자의 존재를 알고 있는 사람들은 아무래도 실제로 필자와 함께 일해보거나 일상을 보내본 분들보다는 필자의 글을 통해서 필자를 알게 되는 분들이 많을 것이다.</p>\n<p>이렇게 블로그를 통해 필자를 먼저 알게 되시는 분들은 필자가 굉장히 진중한 사람이라고 생각하시는 경우가 많았던 것 같다. 이는 아마 글이라는 매체와 필자의 필체 특성 상 감정이 크게 드러나지 않는 것, 그리고 필자가 작성하는 글의 주제들이 주로 학술적인 이야기나 필자의 철학에 대한 이야기를 많이 다루기 때문이라 생각한다.</p>\n<p>물론 그런 모습도 필자의 일부이긴 하겠지만 실제 현실에 존재하는 필자는 그렇게 진지하기만 한 사람도 아니거니와 오히려 돈, 명예, 학벌, 스펙과 같이 사회가 제시하는 공통적 가치보다는 그냥 자기 하고 싶은 대로 하면서 사는 사람에 가깝다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e29d08b6cd6fef0018fbd6525801f5ac/acb04/star.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 236.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAvABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAECAwQF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQMA/9oADAMBAAIQAxAAAAHy6xbbVui8lZix1CLzQWN1kn//xAAbEAEAAgMBAQAAAAAAAAAAAAABABECAxAxEv/aAAgBAQABBQKq59Yc9XQEuHroSNQLXDaSk4mrrqCf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwFf/8QAGhEAAgIDAAAAAAAAAAAAAAAAAAEQUQIREv/aAAgBAgEBPwE6whN3G1Z//8QAHxAAAQIGAwAAAAAAAAAAAAAAAQAQAhEhMTKRM6Gi/9oACAEBAAY/Artx9tIIVKs2QKspKsXp6GLT5jS//8QAIBABAAICAgEFAAAAAAAAAAAAAQARITEQUUFhcYGRsf/aAAgBAQABPyF2AfaW9zCejPbgEgLZUm2s6jfY/ILBYX5YwbhdgxLVIgDbGA8EKcku+vqWMuLxXDtXfKf/2gAMAwEAAgADAAAAEHA/PcAv/8QAGBEAAwEBAAAAAAAAAAAAAAAAAAERURD/2gAIAQMBAT8QIxEWcjw//8QAHREBAAIABwAAAAAAAAAAAAAAAQAxEBEhgZGh8P/aAAgBAgEBPxCoMaLyxqZKvWAxb20//8QAHhABAAMAAQUBAAAAAAAAAAAAAQARITFBUWFxkaH/2gAIAQEAAT8QfAM1dziLFKT3GpKIBX13g03j7jZTgZWzdFKAw9TmdXGgw6DxAYCgeA8srQFCiT5BcHhRpxKkbALa1m+YwUaPsMZNDtPJHgQHiCisrbBs/VcC0O8I6BdkP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"star\" title=\"\" src=\"/static/e29d08b6cd6fef0018fbd6525801f5ac/c08c5/star.jpg\" srcset=\"/static/e29d08b6cd6fef0018fbd6525801f5ac/0913d/star.jpg 160w,\n/static/e29d08b6cd6fef0018fbd6525801f5ac/cb69c/star.jpg 320w,\n/static/e29d08b6cd6fef0018fbd6525801f5ac/c08c5/star.jpg 640w,\n/static/e29d08b6cd6fef0018fbd6525801f5ac/acb04/star.jpg 750w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>블로그에서는 좀 선비같아 보일 수 있지만<br>필자도 그냥 남들처럼 저녁에 친구랑 게임하는 것 좋아하는 평범한 30대 남자다.</small>\n  <br>\n  <br>\n</center>\n<p>물론 이러한 긍정적인 평가와 선입견들이 분명 필자의 인생에 큰 도움이 되는 것은 사실이며, 실제로 이러한 평가들로 인해 이직, 오퍼 등 커리어에 대한 좋은 기회나 부업에 대한 기회도 많이 제안받고 있다.</p>\n<p>하지만 이러한 평가가 항상 좋은 점만 가져다 주지는 않는다. 오히려 필자의 경우 이러한 긍정적 선입견들로 인해 꽤나 많은 고민들을 했었다.</p>\n<p>필자는 지금까지 개발자로 일을 해오며 스스로가 훌륭한 개발자라고 생각했던 적이 단 한 번도 없었다. 당연히 필자는 절대 완벽한 인간이 아니며 아직 부족한 점도 많고 실제로 필자의 역량으로는 해결하기 어려운 문제들을 만나 실패한 경험도 많다.</p>\n<p>또한 필자 주변을 보면 워낙 훌륭하신 분들이 많기도 해서 필자는 지금도 스스로를 그냥 강남이나 판교에 굴러다니는 평범한 개발자 정도의 수준이라고 생각한다.</p>\n<p>하지만 인터넷을 벗어나 일상 속에서 사람들을 만나다보면 간혹 이러한 이야기들을 듣게 된다.</p>\n<blockquote>\n<p>“저도 동욱님 같은 개발자가 되고 싶어요.”</p>\n<p>“우와 연예인 보는 것 같아요.”</p>\n<p>“동욱님 정도면 먹고 살 걱정은 없지 않아요?”</p>\n<p>“동욱님은 회사도 원하는 곳으로 골라서 가실 수 있지 않아요?”</p>\n</blockquote>\n<p>물론 이러한 말씀을 해주신 분들은 필자의 글을 사랑해주시고 공감해주시는 독자님들이시고 필자를 응원해주시는 분들이니, 이는 너무나도 감사한 일이다. 누군가가 나의 생각과 가치관에 공감해주고 응원해준다는 것은 너무 행복한 일이라고 생각한다.</p>\n<p>하지만 이런 이야기들을 듣다보면 감사하다는 마음과 동시에 이런 생각이 들기도 한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 496px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b4ec7a5ca3af9bd5b634dc29a2234796/6a372/surprised.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAwAEBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAUEgOnZ4/8QAGxAAAgIDAQAAAAAAAAAAAAAAAQIAAxESEyH/2gAIAQEAAQUC6NrXayHqRCfGY5n/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAYEAACAwAAAAAAAAAAAAAAAAAAARARMf/aAAgBAQAGPwIq2zI2P//EABwQAQADAAIDAAAAAAAAAAAAAAEAESExQVFhsf/aAAgBAQABPyGpCl637jRWPsM3ksa+9yu1DeZ//9oADAMBAAIAAwAAABBYH//EABYRAAMAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPxAxf//EABYRAAMAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAgEBPxAVf//EABoQAQADAQEBAAAAAAAAAAAAAAEAESFBMVH/2gAIAQEAAT8QCBJCi0uxSFmnK+oa9MC9VhaV4iVWau17M1032f/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"surprised\" title=\"\" src=\"/static/b4ec7a5ca3af9bd5b634dc29a2234796/6a372/surprised.jpg\" srcset=\"/static/b4ec7a5ca3af9bd5b634dc29a2234796/0913d/surprised.jpg 160w,\n/static/b4ec7a5ca3af9bd5b634dc29a2234796/cb69c/surprised.jpg 320w,\n/static/b4ec7a5ca3af9bd5b634dc29a2234796/6a372/surprised.jpg 496w\" sizes=\"(max-width: 496px) 100vw, 496px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>엇 내가 그 정도는 아닌데...?</small>\n</center>\n<p>현실의 필자는 무슨 경제적 자유를 이룬 사람도 아니고 연예인도 아닌 그저 이런저런 고민이 많고 글쓰기를 좋아하는 한 명의 평범한 개발자일 뿐이다.</p>\n<p>하지만 앞서 여러 번 이야기 했듯 평가라는 행위는 평가자의 주관적 기준에 의해 수행되며, 당연히 블로그를 통해 필자를 처음 접한 분들은 실제로 필자가 어떤 사람인지, 어떤 역량을 지녔는지에 대한 자세한 정보가 없으니 그저 블로그 포스팅이나 깃허브에 올려둔 코드와 같이 본인들이 접한 표면적인 정보를 토대로 필자를 평가하게 될 것이다.</p>\n<p>문제는 필자 입장에서는 이 평가가 도대체 어디까지 올려쳐진 상태인지 알기 어렵다는 것이다. 아무래도 필자도 사람인지라 누군가가 필자에게 기대를 한다면 이 기대에 부응하고 실망시키지 않고 싶다는 마음이 생기기 마련인데, 만약 필자의 실제 역량보다 타인의 평가가 매우 높게 형성된 상태라면 이를 만족시키기 쉽지 않을테니 이런 심리가 결국 부담으로 돌아오는 상황이 발생하는 것이다.</p>\n<p>그래서 한때 누군가가 필자를 알아보거나 긍정적인 평가를 해주시는 상황이라면, 이 평가들에 부응하기 위해 몸가짐을 바르게 하고<small>(…)</small> 언행도 주의하는 등 타인의 시선을 많이 의식하는 상태가 되었었다. <small><del>(쉽게 말해 그냥 연예인 병이다)</del></small></p>\n<h2 id=\"삶의-주인으로-살아라\" style=\"position:relative;\">삶의 주인으로 살아라<a href=\"#%EC%82%B6%EC%9D%98-%EC%A3%BC%EC%9D%B8%EC%9C%BC%EB%A1%9C-%EC%82%B4%EC%95%84%EB%9D%BC\" aria-label=\"삶의 주인으로 살아라 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 긍정적인 평가든 부정적인 평가든 이렇게 타인의 평가에 집중해서 살아가는 삶은 스스로에게 꽤나 큰 스트레스가 된다. 물론 사람에 따라 타인의 인정으로부터 충족감을 얻는 경우가 있기도 하겠지만, 근본적으로 타인의 마음이란 내 통제 영역 밖에 있는 것이기 때문에 원하는 대로 되지 않는 경우가 더 많기 때문이다.</p>\n<p>게다가 타인의 평가에 너무 집중하다보면 나 자신의 가치관이 흔들리고 방향성을 잃게 되는 경우도 발생한다. 필자의 경우에도 이러한 평가에 과한 신경을 쏟다보니 지금까지 필자가 옳다고 믿어왔던 신념들에 반하는 행동을 하는 경험을 하게 되었고, 이로 인해 큰 스트레스를 받아 신체적인 영향까지 발생했었다.</p>\n<p>사실 사회 생활을 하다보면, 그리고 경력을 쌓아가면 쌓아갈수록 내가 해왔던 일들로 인해 자연스레 나를 기억하는 사람들이 많아지게 된다. 이렇게 나를 기억하는 사람들이 많아진다는 것은 나를 평가할 가능성이 있는 사람들이 많아진다는 것과 동일한 이야기이고, 이 과정 속에서 많은 이들에게 좋은 평가를 받을 수록 사회라는 거대한 조직 안에서 내 이익을 챙기기 수월해진다.</p>\n<p>하지만 그렇다고 해서 나라는 사람에 대한 근본적인 가치 평가를 온전히 다른 이들에게 맡겨선 안 된다. 앞서 이야기했듯이 근본적으로 타인의 평가란 내 통제 영역 밖에 있는 일이기 때문이다.</p>\n<p>필자 또한 이러한 평가를 신경쓰게 될수록 스스로가 중심을 잃어간다는 생각을 했었고, 이를 벗어나 자유로워 질 수 있는 방법에 대한 고민을 오랜 시간 해왔다. 이 자유를 되찾기 위해 필자가 가장 먼저 했던 것은 내가 통제할 수 있는 것과 통제할 수 없는 것이 무엇인지를 분류하고 이를 인정한 후, 통제할 수 없는 것에 대해서는 집착을 버리는 일이었다.</p>\n<h3 id=\"통제할-수-있는-것과-통제할-수-없는-것을-명확히-구분하자\" style=\"position:relative;\">통제할 수 있는 것과 통제할 수 없는 것을 명확히 구분하자<a href=\"#%ED%86%B5%EC%A0%9C%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EA%B2%83%EA%B3%BC-%ED%86%B5%EC%A0%9C%ED%95%A0-%EC%88%98-%EC%97%86%EB%8A%94-%EA%B2%83%EC%9D%84-%EB%AA%85%ED%99%95%ED%9E%88-%EA%B5%AC%EB%B6%84%ED%95%98%EC%9E%90\" aria-label=\"통제할 수 있는 것과 통제할 수 없는 것을 명확히 구분하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>세상을 살아가며 가만히 주위를 둘러보면 생각보다 내가 온전히 통제할 수 있는 것들이 그렇게 많지 않다는 사실을 깨달을 수 있다. 내가 통제 가능한 부분은 대부분 나의 생각, 나의 감정과 같이 내가 주체가 되는 것들이며, 나를 벗어난 타인과 관련된 것들은 대부분 통제가 불가능한 영역에 위치한다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/75882324a1834fcc0529ebf9f418eded/07a9c/out-of-control.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADrklEQVR42m1Vy44bVRB1gsQCFKRI8F9ILIKikdgEIfiJWWYNkZJVEKMoSlgwiDEIEQmYCbEzEzsittuP+P3qd7vbY/yM+97DqY5n5EnSUrna11V1T516OJXaegBcFm3b9ofj8fhaGIb3R6NRnTINgmBGafLsR8oO3z/a9nnrOfvBcZxPPc+r0AkMqi3LQr/fB8/h+z5OT081z+V7gxdd2/heEtkOdmkT7OZ0OsV8Pkc6nVYHBwfx3t6evn3nDo6OjnCQTuv9/f348PBQMbheLpdwXfdb+r93Hmx3dzdBRkQ3lVKgjkejQAki1/XgUttE6brUtpUgdT1P0GrarrXWINJb28BS5OMzSaPX66l2u62pMQoCBEzR80dw/DFsbwwvCHnuIQh8DIdDdLtdsY0nkwnPgi+SYPl8/gMeFIWrk5MTlclk8Tyf560R+v4cTS9Gw9NouApNN0bPmyeBy4Yh9sjlckqCk6pGsVi8miLcz2ezmaSgwjBCFBEFddNeoNRbwOjPqaeoDJeoDBbUr1C35rQZJ7biQ3Sx8BlF0Y0UP+5tyI0p8MjVMFgiU7TwMP0Y9376E7d/2MejbAU/P3pGOcHjFwMMglViK3yKrxSSsX6RgDVByFs03+EznYazRs16hZq5RHkwx3HZwVPDeo2Q8tJa0yaGS37DUCTSwiP9rRR77D/mjlqthlKxgFbPTDir00F4E50tmTh63rlwJmKxUC9rVRQKBZRKJQwGA50ioVMJ1mq1USkbaPdtOulzp7q9JkIbf+WaRL16K2Cr1UC1Wk3ENE0t/VeXZn4z5TM0UoxMcYjDfJvFmW0FXJO/1ymzsJoTJCk7wuEDKQrHLaaw9zz03BlqjkqchcOnhol//u2h0JmwjRRqtkLHXSSjKCK+UhSC+00Q7iwWyY+KNyGkBGyFlsv0POBZxcXfuQb+eFLGk8IATR9oOitmEiW24kPfeLVaScCvU/xyhVNSlZZh5ysKOp02TMtBz1+iuqm09GN1uEDXWyTVNYcDsed0dRXpkqXRrdfrnyTTwqDXhVROjcpms8hQ2q1WgsD1Q9j+JBF5F0pkJMvlMo6Pj2VaYq47sG2+urBpePCdDDrRrgldy63CT5CIdx7ojDcpBPlf019SvXthOfCRfXaZm+SWkCs7jxQoIdvfCnJWABHZlcI9fb43DOP9CwG3FySddujQFWMGlxW1jSo523TFkPLlOxfsm7uRt1+l8w0G+ZVOruy+DToq/3ei/4YUffyuv4D/AbN8BMBkHMxNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"out of control\" title=\"\" src=\"/static/75882324a1834fcc0529ebf9f418eded/6af66/out-of-control.png\" srcset=\"/static/75882324a1834fcc0529ebf9f418eded/69538/out-of-control.png 160w,\n/static/75882324a1834fcc0529ebf9f418eded/72799/out-of-control.png 320w,\n/static/75882324a1834fcc0529ebf9f418eded/6af66/out-of-control.png 640w,\n/static/75882324a1834fcc0529ebf9f418eded/d9199/out-of-control.png 960w,\n/static/75882324a1834fcc0529ebf9f418eded/21b4d/out-of-control.png 1280w,\n/static/75882324a1834fcc0529ebf9f418eded/07a9c/out-of-control.png 1440w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>올바른 자기인식은 자신이 통제가 가능한 부분이 어디까지이고<br>통제가 불가능한 부분이 어디까지인지를 인식하는 것에서부터 시작한다</small>\n  <br>\n  <br>\n</center>\n<p>즉, 타인이 나에 대해서 평가하는 것은 나의 통제 영역을 벗어난 개념이다. 물론 타인의 마음을 돌리기 위해 그 사람을 설득하고 공감시키기 위한 행동을 하는 것은 통제 영역 안에 있지만, 그 행위에 대한 결과는 여전히 나의 통제 영역을 벗어나 있다.</p>\n<p>서두에서 필자는 모두에게 사랑받고 싶어하는 사람은 자기 자신을 잃게 되기 쉽다고 이야기했다. 이는 모두에게 사랑받고 싶다는 그 마음이 타인의 평가라는 나의 통제 영역을 벗어난 개념에 대해 집착하는 형태로 나타나기 쉽기 때문이다.</p>\n<p>우리 주변에는 굉장히 다양한 가치관과 이념을 가진 인간들이 함께 살아가고 있으며, 이는 어떤 조직이라고 해도 마찬가지이다. 결국 같은 현상을 보더라도 이에 대한 평가나 감정은 각각의 인간 객체마다 다를 수 있다는 것이다.</p>\n<p>이러한 현실은 내가 통제할 수 있는 것이 아니다. 어차피 내가 통제할 수 없는 것이라면 왜 거기에 집착하는가? 내가 어떤 행동을 하던 나를 좋아할 사람은 좋아하고 싫어할 사람은 싫어하기 마련이다. 내가 절대 가질 수 없는 것을 가지고자 발버둥치는 것만큼 스스로를 불행하게 만드는 일이 또 있을까?</p>\n<p>필자는 인생의 Focus on Impact가 내가 통제 가능한 영역을 더 잘 해내기 위해 집중하는 것, 그리고 통제 불가능한 영역에 존재하는 것들을 가급적이면 통제 가능한 영역으로 끌어들이는 것이라고 생각한다. 당장 내가 통제할 수 없는 것들에 지나친 관심을 쏟는 것은 집중력이라는 한정된 자원을 의미없는 곳에 지출하고 있는 것이나 마찬가지이다.</p>\n<p>이러한 한계를 인지하고 인정하는 행위는 결국 내가 아는 것이 무엇이고 모르는 것이 무엇인지, 할 수 있는 것이 무엇이고 하지 못 하는 것이 무엇인지 등을 스스로 인지하는 메타인지와도 연결된다. 통제 영역에 대한 인지 또한 “나”라는 주체가 세상에 행사할 수 있는 영향력이 어디까지인지에 대한 경계를 인지하는 것이기 때문이다.</p>\n<h3 id=\"결국-움직이는-것은-그대의-마음이다\" style=\"position:relative;\">결국 움직이는 것은 그대의 마음이다<a href=\"#%EA%B2%B0%EA%B5%AD-%EC%9B%80%EC%A7%81%EC%9D%B4%EB%8A%94-%EA%B2%83%EC%9D%80-%EA%B7%B8%EB%8C%80%EC%9D%98-%EB%A7%88%EC%9D%8C%EC%9D%B4%EB%8B%A4\" aria-label=\"결국 움직이는 것은 그대의 마음이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<blockquote>\n<p>어느 날 사찰 깃발이 바람에 나부끼고 있었다. 이 광경을 본 두 스님이 서로 논쟁을 했다. 한 스님은 “깃발이 움직이고 있다”라고 말하고, 다른 스님은 “바람이 움직인다”라고 주장했다. 서로의 주장만이 오갈 뿐 논쟁은 해결되지 않는다.</p>\n<p>이때 육조 혜능은 말했다. <strong>“바람이 움직이는 것도, 깃발이 움직이는 것도 아닙니다. 그대들의 마음이 움직이고 있을 뿐입니다.”</strong> 두 스님은 소스라치게 놀랄 수 밖에 없었다.</p>\n<p>[무문관] 29칙. 비풍 비번.</p>\n</blockquote>\n<p>이 에피소드에서 혜능 스님은 어떤 것을 이야기하고 싶었던 것일까? 본래 무문관이란 질문만 던져놓고 답을 제시하지는 않는 화두집이니 이 책에서 이 질문에 대한 답을 알려주지는 않는다.</p>\n<p>필자는 이 에피소드를 읽고 “현상은 그저 존재할 뿐, 그 현상을 해석하는 것은 인간의 주관적인 판단이다”라는 생각을 했었다.</p>\n<p>대승 불교의 경전인 화엄경은 **일체유심조(一切唯心造)**라는 핵심 사상에 대해서 이야기한다. 이 말은 단어 그대로 “모든 것은 오직 마음이 지어낸다”라는 뜻이며, 필자는 내가 내 삶의 주인으로 살 수 있는 핵심 포인트가 바로 이 일체유심조라고 생각한다.</p>\n<p>일반적으로 사람들이 타인의 평가로 인해 힘들어하는 상황은 좋은 평가를 받는 상황보다는 좋지 못한 평가를 받는 상황인 경우가 많으니, 누군가가 뒤에서 여러분에 대한 가십을 퍼트리고 다니는 상황을 한번 생각해보자.</p>\n<p>아마도 그 가십은 100% 사실로만 이루어진 내용은 아닐 것이다. 게다가 여러 가십들이 그러하듯 약간의 사실과 그 사실에 대한 오해와 주관이 덧붙혀진 내용들일 가능성이 높다. 이런 이야기를 들었을 때 당사자에게 제대로 된 사실 관계를 확인하려고 하는 사람은 드물기도 하거니와 담백한 사실보다는 이런저런 거품이 붙어야 더 재미도 있기 때문이다.</p>\n<p>만약 여러분이 이 사실을 알게 되었다면 여러분은 답답함, 억울함, 분노, 배신감과 같은 여러가지 감정에 휩싸이게 될 수도 있다. 그렇다면 이 감정은 어디에서 비롯된 것일까? 누군가 뒤에서 나에 대한 가십을 퍼트리고 다닌다는 그 환경이나 상황에서 비롯된 것일까? 혹은 그 가십을 퍼트리고 다니는 인물에게서 비롯된 것일까?</p>\n<p>아니다. <strong>결국 답답함, 억울함, 분노, 배신감과 같은 감정은 내 마음에서부터 시작하는 것이다.</strong> 이런 감정들은 결국 내 감정인 것이며, 앞서 이야기했듯이 내 감정은 내가 온전히 통제 가능한 영역 안에 있는 개념이다. 결국 현재 벌어지고 있는 상황과 관계없이 내가 스스로 이런 감정을 만들어내어 나를 힘들게 하는 것이다.</p>\n<p>이것이 바로 일체유심조(一切唯心造), 모든 것은 오직 마음이 지어낸다는 말의 의미이다. 물론 현재 벌어지고 있는 상황 자체가 옳거나 옳지 않다는 가치 판단, 그리고 옳지 않다면 바로 잡아야하는 액션 아이템의 수립이 필요할 수도 있다. 하지만 문제 상황을 해결하기 위한 전략을 수립하고 행동을 수행하는 것과 내 감정은 별개의 문제라는 사실을 잊지 말아야 한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 420px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6271f4799e9572d8153bd8477492a94b/65f94/water.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 132.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAaABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAwACAQX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAH3TQzFqFJMh3Y//8QAGRAAAQUAAAAAAAAAAAAAAAAAIAAQESFB/9oACAEBAAEFAg1rUB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAVEAEBAAAAAAAAAAAAAAAAAAAgMf/aAAgBAQAGPwJ0/wD/xAAbEAEBAAIDAQAAAAAAAAAAAAABABEhEDFxgf/aAAgBAQABPyFl3iSZNGZ6sY7z+Xrhm//aAAwDAQACAAMAAAAQswMw/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHBABAAMBAAMBAAAAAAAAAAAAAQARMSFBUXGx/9oACAEBAAE/EDxhUWuUQbioV8S0Jwv8mp2j2QMBdN5+RV9bGYmp/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"water\" title=\"\" src=\"/static/6271f4799e9572d8153bd8477492a94b/65f94/water.jpg\" srcset=\"/static/6271f4799e9572d8153bd8477492a94b/0913d/water.jpg 160w,\n/static/6271f4799e9572d8153bd8477492a94b/cb69c/water.jpg 320w,\n/static/6271f4799e9572d8153bd8477492a94b/65f94/water.jpg 420w\" sizes=\"(max-width: 420px) 100vw, 420px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>컵에 들어있는 물은 그저 거기에 담겨있을 뿐, 이를 어떻게 바라볼 지는 사람의 마음에 달려있다.</small>\n</center>\n<p>일체유심조라는 말은 어찌 보면 꽤 현실과 동떨어진 이야기처럼 느껴진다. 하지만 필자는 이 말이 수많은 평가와 비교 속에서 고통받고 있는 현대인들에게 가장 필요한 말이 아닐지 생각한다.</p>\n<p>물론 누군가 나에 대한 가십을 퍼트리고 다닌다는 것이나 익명 뒤에 숨어서 비난을 하는 것이 감정적으로 힘들어지기 쉬운 상황인 것은 맞다. 하지만 내가 힘들어하든 힘들어하지않든 내가 이성적으로 이 현상의 원인에 대해서 고민하고 해결하기 위한 액션아이템을 수행하지 않는다면 상황 자체는 개선되지 않을 것이다.</p>\n<p>즉 조직 내에서 가십이 돌 정도로 건강하지 않은 조직의 현재 상태를 개선하는 것이 중요하지 내가 가십의 대상이 되었다는 그 상황 자체가 중요한 것은 아니라는 이야기이다.</p>\n<p>그렇다면 그냥 담백하게 그런 상황이 발생하게 된 원인에 대해서 고민하고, 만약 그 원인이 내 통제 가능한 영역 안에 있는 것이라면 빠른 액션아이템 수행을, 그리고 내가 통제할 수 없는 것이라면 통제 가능한 영역으로 끌어들일 수 있는지에 대해서만 고민하면 되는 것이다.</p>\n<p>이처럼 일체유심조를 이해하고 내 감정을 온전히 통제 가능한 영역에 둘 수 있다면 주변에서 발생하는 현상을 관찰할 때 조금 더 문제의 본질에 대해 이성적으로 바라볼 수 있는 시각을 얻을 수 있다.</p>\n<p>이는 감정을 없애라는 것이 아니다. 주변에서 발생하는 상황이나 주어진 환경과 같은 외부 변수에 내 감정이 의존하게 만들지 말라는 것이다. 주변 환경이 어떻든 내 감정은 내가 컨트롤하는 것이다. 주변 환경이나 상황에 관계없이 행복할 수도 불행할 수도 있는 것이다.</p>\n<h3 id=\"대부분은-양면적인-평가를-한다는-사실을-기억하자\" style=\"position:relative;\">대부분은 양면적인 평가를 한다는 사실을 기억하자<a href=\"#%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%80-%EC%96%91%EB%A9%B4%EC%A0%81%EC%9D%B8-%ED%8F%89%EA%B0%80%EB%A5%BC-%ED%95%9C%EB%8B%A4%EB%8A%94-%EC%82%AC%EC%8B%A4%EC%9D%84-%EA%B8%B0%EC%96%B5%ED%95%98%EC%9E%90\" aria-label=\"대부분은 양면적인 평가를 한다는 사실을 기억하자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>평소 주변의 평가에 대해 신경을 쓰다 보면 아무래도 좋은 평가보다는 좋지 않은 평가에 더 집중하게 되기 쉽다. 인간은 부정적인 정보가 가져다주는 위협에 대해 민감하게 반응하도록 설계되었기 때문에 일종의 부정성 편향을 가지고 있기 때문이다. <small>(신문이나 뉴스도 긍정적인 소식보다는 부정적인 소식이 더 잘 팔린다고 한다)</small></p>\n<p>이때 만약 감정 컨트롤까지 능숙하지 않다면 “나는 안 될 거야”와 같은 자조적인 가치 절하와 함께 절망의 구렁텅이로 빠져들 수도 있다. 게다가 내가 나에게 부정적인 피드백을 주는 구렁텅이로 한번 빠져들게 되면 스스로 헤어나오는 것이 쉽지 않을 수도 있다.</p>\n<p>하지만 사실 특정 인간에 대한 평가는 대부분 양면적이다. 즉 나에 대해 나쁘게만 평가하는 사람이나 좋게만 평가하는 사람보다는 대부분 좋은 점도 있고 부족한 점도 있다고 평가한다는 것이다.</p>\n<p>어찌보면 이는 당연한 사실인게, 인간이라면 누구나 다 강점과 약점이 존재하기 때문에 강점에 대해서는 좋은 평가를 받을 가능성이 높고 약점에 대해서는 좋지 못한 평가를 받을 가능성이 높다.</p>\n<p>물론 <a href=\"https://namu.wiki/w/%ED%8E%B8%ED%96%A5#s-2.2.5\" target=\"_blank\" rel=\"nofollow\">행위자-관찰자 편향</a>이나 <a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EA%B8%B0_%EA%B3%A0%EC%96%91%EC%A0%81_%ED%8E%B8%EA%B2%AC\" target=\"_blank\" rel=\"nofollow\">자기 고양 편향</a>으로 인해 자신에 비해 타인에게 더 엄격한 평가를 하는 경우도 있기는 하지만, 기본적으로 이성적인 성인이라면 특정 인물에 대해서 어느 정도는 중립적인 평가를 하기 마련이다. <small>(특정 인물에 대해 좋지 않은 평가만 하는 사람이라면 특정 현상에 대해 다각적인 시각을 가지지 않은 사람일 가능성이 높으니 가급적 피하는 것을 추천한다)</small></p>\n<p>그리고 대부분의 평가는 양면적이며 중립적이라는 사실을 스스로 인지한다는 것은 나의 자존감을 지키는 데 큰 도움이 된다. 물론 반대로 너무 긍정적인 정보에만 집중하면 현실을 제대로 보지 못 할 수도 있으니 적절한 밸런스를 잡는 것이 중요할 것이다. 물론 이것은 단순한 가정이 아니라 실제로 여러분 주위에서 벌어지고 있는 현실이기도 하다.</p>\n<p>중요한 것은 나 또한 중립적인 시각을 가지고 타인이 나에 대해 긍정적 평가를 한 부분에 있어서는 강화를, 부정적 평가를 한 부분에 있어서는 개선을 하는 것이다. 굳이 이런 평가들로 인해 기분이 나빠질 필요도 좋아질 필요도 없다. 앞서 이야기했듯 그저 이런 평가가 발생했다는 담백한 사실을 인지하고 강화하거나 개선하기 위한 액션 아이템을 수행하면 되는 것이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>누구나 그러하듯이 필자 또한 지금까지 삶을 살아오며 수많은 평가를 마주할 수 있었다. 이는 비단 개발자로 일을 할 때 뿐만이 아니라 어릴 적 비보이, 사운드 엔지니어로 활동했을 때도 동일했었다.</p>\n<p>아무리 관계를 중시하지 않는 인간이라고 해도 결국 사회라는 거대한 네트워크 내에서 알게 모르게 다른 인간들과 인터랙션을 하며 살아갈 수 밖에 없다. 그리고 이 과정 속에서 타인이 자연스레 나에 대한 평가를 한다는 사실 또한 너무나 당연한 현실일 것이다.</p>\n<p>하지만 이 평가들에 너무 매몰되면 온전한 나 자신을 잃어버릴 수 있다. 물론 타인의 평가나 조언을 듣고 나의 가치관이나 삶의 방향성에 대한 수정이 필요할 수도 있겠지만, 결국 이에 대한 결정 주체는 오롯이 나 자신이어야 하며, 이 결정 권한을 타인에게 위임해서는 안 된다.</p>\n<p>우리가 타인에게 하는 말이나 평가에는 어떠한 비용도 들지 않는다. 또한 타인은 나에 대해 평가를 할 수는 있지만 그 평가에 대한 책임을 지는 경우는 거의 없다.</p>\n<p>즉, 그 행위를 함에 있어서 마치 10억이 넘는 아파트에 대한 구매 결정을 할 때와 비슷한 수준의 고민을 하지는 않는다는 이야기이다.</p>\n<p>그러니 필자는 그런 행위에 너무 무게를 두지 않는 것을 추천한다. 결국 내 가치는 내 이성이 결정하는 것이며, 올바른 자기 가치관을 가진 성인이라면 응당 그래야만 한다고 생각한다.</p>\n<p>앞서 이야기했듯이 인간의 사상과 가치관에는 정답이라고 할 만한 것이 없다. 그저 그런 생각들이 존재할 뿐, 그 생각들에 대한 가치판단은 모두 다를 수 있다는 것이다.</p>\n<blockquote>\n<p>“스타트업에 다니는 것이 옳은 것인가? 대기업에 다니는 것이 옳은 것인가?”</p>\n<p>“높은 소득과 워라밸을 맞바꾸는 것이 옳은 것인가? 돈보다는 내 시간을 챙기는 것이 옳은 것인가?”</p>\n<p>“기회의 평등이 옳은 것인가? 결과의 평등이 옳은 것인가?”</p>\n<p><strong>이러한 이데올로기들에 대한 정답은 그 누구도 제시할 수 없다. 그저 자신이 믿는 가치에 따라 선택할 뿐이다.</strong></p>\n</blockquote>\n<p>그러니 정답을 찾으려 하거나 모두에게 사랑받으려고 하지 말고 자신이 믿는 신념에 따라 자신이 옳다고 생각하는 길을 따라 자신만의 페이스를 유지하며 걷자.</p>\n<p>주변과 나를 비교하거나, 지나고 나면 별 것 아닌 상황에 감정을 이입하거나, 당장 가질 수 없는 것을 가지기 위해 발버둥 쳐 나를 더 힘들게 하는 것도 결국은 나 자신이다.</p>\n<p>나 자신을 온전히 통제하고 주변의 현상들을 이성적으로 관찰하다보면 사실 별 것 아닌 단순한 문제들을 때로는 너무 복잡하게 바라보고 있지는 않았나 하는 생각이 든다.</p>\n<p>이상으로 나는 타인의 평가에서 자유로울 수 있을까 포스팅을 마치며, 오늘도 인간들 사이에서 많은 고민을 하고 행복을 느끼고 상처를 받기도 하는 독자분들에게 이 글을 바친다.</p>","fields":{"slug":"20231121-how-to-overcome-being-self-conscious","path":"/2023/11/21/how-to-overcome-being-self-conscious/","lang":"ko"},"frontmatter":{"title":"나는 타인의 평가에서 자유로울 수 있을까","subTitle":"평가받는 삶에서 벗어나 나답게 사는 방법에 대한 고찰","date":"Nov 21, 2023","categories":["에세이"],"tags":null,"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#0868f8","images":{"fallback":{"src":"/static/12625a231e18b80c9ad703659f128755/fc5c5/thumbnail.webp","srcSet":"/static/12625a231e18b80c9ad703659f128755/3e5ca/thumbnail.webp 80w,\n/static/12625a231e18b80c9ad703659f128755/b72f1/thumbnail.webp 160w,\n/static/12625a231e18b80c9ad703659f128755/fc5c5/thumbnail.webp 320w,\n/static/12625a231e18b80c9ad703659f128755/c5332/thumbnail.webp 640w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#0868f8","images":{"fallback":{"src":"/static/12625a231e18b80c9ad703659f128755/dc0d9/thumbnail.webp","srcSet":"/static/12625a231e18b80c9ad703659f128755/6858b/thumbnail.webp 750w,\n/static/12625a231e18b80c9ad703659f128755/f5547/thumbnail.webp 1080w,\n/static/12625a231e18b80c9ad703659f128755/29310/thumbnail.webp 1366w,\n/static/12625a231e18b80c9ad703659f128755/dc0d9/thumbnail.webp 1920w","sizes":"100vw"},"sources":[]},"width":1,"height":0.5}}}}}}],"pageInfo":{"currentPage":1,"pageCount":7}}},"pageContext":{"limit":15,"skip":0,"lang":"ko","totalCount":102}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}