{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/http/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"43a4e283-1828-56b2-9174-cc59fa365513","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EA%B5%B3%EC%9D%B4-%EC%9D%B4%EB%9F%AC%ED%95%9C-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\">굳이 이러한 가이드라인을 지켜야 하나요?</a></p>\n<ul>\n<li><a href=\"#%ED%91%9C%EC%A4%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A1%B4%EC%9E%AC-%EC%9D%B4%EC%9C%A0%EB%A5%BC-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EC%9E%90\">표준 인터페이스의 존재 이유를 생각해보자</a></li>\n<li><a href=\"#%EB%B0%B1%EC%97%94%EB%93%9C%EB%8A%94-%EC%9E%98-%EB%AA%A8%EB%A5%B4%EB%8A%94-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%9D%98-%EC%8A%AC%ED%94%88-%EC%82%AC%EC%A0%95\">백엔드는 잘 모르는 프론트엔드의 슬픈 사정</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9E%91%EC%97%85%EC%9D%98-%EC%88%98%ED%96%89-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C\">작업의 수행 상태를 알려주는 HTTP 상태 코드</a></p>\n<ul>\n<li><a href=\"#100%EB%B2%88%EB%8C%80\">100번대</a></li>\n<li><a href=\"#200%EB%B2%88%EB%8C%80\">200번대</a></li>\n<li><a href=\"#300%EB%B2%88%EB%8C%80\">300번대</a></li>\n<li><a href=\"#400%EB%B2%88%EB%8C%80\">400번대</a></li>\n<li><a href=\"#500%EB%B2%88%EB%8C%80\">500번대</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"최근의 모던 어플리케이션은 완전히 네트워크 위에서 돌아가는 프로그램이라고 해도 과언이 아닐 정도로 프로그램의 비즈니스 로직에서 통신이 차지하는 비중이 높다. 클라이언트 어플리케이션은 백엔드에 위치한 서버와 통신하여 현재 로그인한 사용자의 정보를 받아오거나, 새로운 게시글을 생성하기도 하고, 때로는 Web Socket을 통해 서버에서 발생한 이벤트를 구독하여 푸시 메세지나 채팅과 같은 기능을 구현하기도 한다.","html":"<p>최근의 모던 어플리케이션은 완전히 네트워크 위에서 돌아가는 프로그램이라고 해도 과언이 아닐 정도로 프로그램의 비즈니스 로직에서 통신이 차지하는 비중이 높다. 클라이언트 어플리케이션은 백엔드에 위치한 서버와 통신하여 현재 로그인한 사용자의 정보를 받아오거나, 새로운 게시글을 생성하기도 하고, 때로는 Web Socket을 통해 서버에서 발생한 이벤트를 구독하여 푸시 메세지나 채팅과 같은 기능을 구현하기도 한다.</p>\n<!-- more -->\n<p>이 과정에서 프론트엔드와 백엔드는 어떤 방식으로 통신을 할 것인지부터 시작하여 리소스의 생성과 삭제는 어떻게 정의할 것인지, 프론트엔드에서 요청한 백엔드 작업의 성공/실패 여부는 어떻게 알려줄 것인지 등 많은 규칙들을 정의해야한다.</p>\n<p>그래서 이러한 규칙들을 정의할 때 도움을 주는 몇 가지 가이드라인들이 존재하는데, 이때 등장하는 것들이 HTTP 메소드나 상태 코드같은 표준과 REST 같은 녀석들이다.</p>\n<p>이번 포스팅에서는 이 중에서  프론트엔드와 백엔드 간의 통신을 할 때 조금 더 명확한 정의를 위해 필요한 요소 중 하나인 HTTP 상태 코드를 파헤쳐보는 시간을 가져보려고 한다.</p>\n<h2 id=\"굳이-이러한-가이드라인을-지켜야-하나요\" style=\"position:relative;\">굳이 이러한 가이드라인을 지켜야 하나요?<a href=\"#%EA%B5%B3%EC%9D%B4-%EC%9D%B4%EB%9F%AC%ED%95%9C-%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8%EC%9D%84-%EC%A7%80%EC%BC%9C%EC%95%BC-%ED%95%98%EB%82%98%EC%9A%94\" aria-label=\"굳이 이러한 가이드라인을 지켜야 하나요 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 HTTP 메소드나 상태 코드, 그리고 REST 같은 것들은 말 그대로 가이드라인에 불과하다. 이것들을 지키지 않는다고 해서 프로그램이 작동하지 않는 것도 아니고 사용자가 프로그램을 사용하던 도중 런타임 에러가 발생하는 슬픈 일도 발생하지 않는다.</p>\n<p>즉, 지키지 않아도 사실 프로그램을 작성하는데는 아무런 지장이 없다는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgH/2gAMAwEAAhADEAAAAdFHeGZyL//EABwQAAEDBQAAAAAAAAAAAAAAAAACAxIBEyIjM//aAAgBAQABBQK4ZUVMbVsc5SP/xAAXEQADAQAAAAAAAAAAAAAAAAAAARIh/9oACAEDAQE/AXjJP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAQEBAQAAAAAAAAAAAAAAAAEAECL/2gAIAQEABj8ClXnCc//EABsQAAICAwEAAAAAAAAAAAAAAAABESExQVFh/9oACAEBAAE/IUje34sl0GmCI6npJS8JH//aAAwDAQACAAMAAAAQHO//xAAXEQEAAwAAAAAAAAAAAAAAAAAAETFR/9oACAEDAQE/EKGoP//EABYRAQEBAAAAAAAAAAAAAAAAAAEAEf/aAAgBAgEBPxABLb//xAAdEAEAAwACAwEAAAAAAAAAAAABABExcZEhUWGx/9oACAEBAAE/EKiWem1wSj+FUKG39MhTp3PLbaTkdjZ2W37AjTqf/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ebichu\" title=\"\" src=\"/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg\" srcset=\"/static/5ab263e405da8a4381a5fe32c5581820/0913d/ebichu.jpg 160w,\n/static/5ab263e405da8a4381a5fe32c5581820/cb69c/ebichu.jpg 320w,\n/static/5ab263e405da8a4381a5fe32c5581820/41099/ebichu.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>그럼 굳이 안 지켜도 상관없는 것 아닌가요?</small>\n</center>\n<p>음, 이러한 규칙들을 지키지 않는 것은 자유지만 그로 인해 발생하는 사이드 이펙트들을 생각해보면 되도록이면 지켜주는 것이 좋다고 이야기하고 싶다.</p>\n<h3 id=\"표준-인터페이스의-존재-이유를-생각해보자\" style=\"position:relative;\">표준 인터페이스의 존재 이유를 생각해보자<a href=\"#%ED%91%9C%EC%A4%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%A1%B4%EC%9E%AC-%EC%9D%B4%EC%9C%A0%EB%A5%BC-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"표준 인터페이스의 존재 이유를 생각해보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>산업 표준은 불특정 다수에 의해 생산되는 제품들의 호환성을 맞추고, 제품 생산자들 간의 커뮤니케이션을 원활하게 하기 위해서 제정되며, 이렇게 각자 다른 객체들을 호환하기 위해 정의하는 일련의 표준 규격을 우리는 “인터페이스(Interface)“라고 부른다.</p>\n<p>이 인터페이스라는 개념은 꽤나 광범위해서 뭐든 연결해주기만 할 수 있다면 인터페이스라고 생각하면 된다. 모니터와 컴퓨터를 연결하는 HDMI, 저장 장치에 사용되는 SATA, USB와 같은 친구들도 전부 인터페이스다. 심지어 UI(User Interface)같은 경우에는 기계와 기계가 아니라 인간과 기계를 이어준다는 개념으로까지 사용된다.</p>\n<p>그 중 개발자들에게 가장 친숙한 인터페이스는 바로 API(Application Programming Interface)이다. API는 응용 프로그램을 제작할 때 필요한 기능들을 일련의 인터페이스로 제공된 것을 의미한다.</p>\n<p>이때 API를 사용하는 쪽에서는 API의 사용법만 알면 되고 그 이면에 어떤 거대한 로직들이 숨어있는지는 일절 관심을 끊어도 되기 때문에 굉장히 편리하다는 장점이 있다. 대표적인 API의 한 종류로는 C에서 제공하는 Windows 운영체제의 API가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c line-numbers\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;Windows.h></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;tchar.h></span></span>\n\n<span class=\"token keyword\">int</span> APIENTRY <span class=\"token function\">_tWinMain</span><span class=\"token punctuation\">(</span>\n  HINSTANCE hInstance<span class=\"token punctuation\">,</span>\n  HINSTANCE hPrevInstance<span class=\"token punctuation\">,</span>\n  LPTSTR lpCmdLine<span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">int</span> nCmdShow\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">MessageBox</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token function\">TEXT</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, Windows!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">TEXT</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"App\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> MB_OK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>개발자는 Windows 운영체제가 어떻게 저 메세지박스를 렌더하는지 모르더라도 단지 <code class=\"language-text\">MessageBox</code>라는 API의 함수를 사용함으로써 간단하게 메세지박스를 사용할 수 있다. 그리고 이 과정은 필자가 작성하는 C 어플리케이션과 운영체제, 전혀 다른 두 프로그램 간의 통신이기도 하다.</p>\n<p>즉, API는 프로그램 간의 통신을 위한 인터페이스라고 할 수 있다. 마찬가지로 클라이언트가 서버에게 뭔가를 요청할 때도 특정 규칙으로 정의된 API를 사용하여 서버의 리소스를 사용하게 되는데, HTTP를 사용하여 통신하는 대부분의 모던 어플리케이션에서는 이 API를 엔드포인트(endpoint)라고 불리는 특정한 URL을 사용하여 정의하게되며, 서버는 일관된 방식으로 이 엔드포인트로 들어온 클라이언트 요청에 대한 응답을 보내줘야한다.</p>\n<p>이때 HTTP 상태 코드는 클라이언트가 보냈던 요청의 수행 결과를 의미하는 일종의 약속이며, API를 구성하는 중요한 요소 중 하나이다.</p>\n<h3 id=\"백엔드는-잘-모르는-프론트엔드의-슬픈-사정\" style=\"position:relative;\">백엔드는 잘 모르는 프론트엔드의 슬픈 사정<a href=\"#%EB%B0%B1%EC%97%94%EB%93%9C%EB%8A%94-%EC%9E%98-%EB%AA%A8%EB%A5%B4%EB%8A%94-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%9D%98-%EC%8A%AC%ED%94%88-%EC%82%AC%EC%A0%95\" aria-label=\"백엔드는 잘 모르는 프론트엔드의 슬픈 사정 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이 섹션에서는 잘못 정의된 API를 사용하는 프론트엔드 개발자라면 한번쯤은 겪어보았음직한 일을 한번 짧게 이야기해보려고 한다. 아마 백엔드 개발자들은 프론트엔드 어플리케이션의 소스를 직접 보는 경우가 드물기 때문에 이런 상황이 있다는 사실조차 모를 수 있을 것 같다.</p>\n<p>바로 HTTP 상태 코드를 잘못 사용하고 있는 경우인데, 이런 상황에 대한 대표적인 예시는 바로 요청이 실패했을 때에도 상태 코드를 요청 성공을 의미하는 <code class=\"language-text\">200 Ok</code>로 내려주는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET /api/users/123</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">200</span> <span class=\"token reason-phrase string\">OK</span></span>\n{ \"success\": false }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이렇게 설계한 API의 경우, 위 예시처럼 HTTP 응답 바디에 요청의 성공/실패 여부나 실패 이유를 함께 담아서 보내주는 경우가 대다수인데, 그러면 프론트엔드 어플리케이션에서는 처리가 약간 애매해지는 상황이 발생한다.</p>\n<p>프론트엔드에서는 이런 비동기 요청을 Promise를 통해서 처리하게 되는데, 문제는 대부분의 HTTP 통신 라이브러리나 API들은 백엔드에서 보내주는 요청의 상태 코드에 따라 요청의 성공/실패 여부를 판단하고, 요청이 실패했을 경우에만 에러를 던진다는 것이다.</p>\n<p>그래서 일반적인 경우, 프론트엔드 어플리케이션에서는 대략 이런 느낌으로 통신을 담당하는 코드를 작성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUsers</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/users/123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'요청이 실패했어요!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>서버로 보냈던 요청이 실패했다면 서버는 반드시 400이나 500번대의 상태 코드를 보내줄 것이고, 그렇게 되면 <code class=\"language-text\">fetch</code> API는 에러를 발생시킨다. 그래서 <code class=\"language-text\">fetch</code>를 사용할 때는 단순히 외부에서 <code class=\"language-text\">try/catch</code> 구문을 사용하는 것만으로도 간단하게 통신에 대한 에러를 핸들링할 수 있는 것이다.</p>\n<p>하지만 위의 잘못된 예시처럼 백엔드 어플리케이션에서 요청이 실패했음에도 불구하고 상태 코드로 200번대 코드를 내려준다면 프론트엔드 어플리케이션의 코드에는 이런 슬픈 상황이 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUsers</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api/users/123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> success <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'요청이 실패했어요'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>아까 전에는 없던 <code class=\"language-text\">if (!success)</code>가 생긴 것을 볼 수 있다. 즉, 불필요한 예외 처리가 한번 더 발생한 것인데, 이런 불필요한 예외처리는 코드의 가독성을 해치지만 프론트엔드 입장에서는 딱히 선택권이 없다. 그렇다고 서버가 보내주는 에러를 무시하고 핸들링을 안 할수도 없지 않은가?</p>\n<p>게다가 백엔드 어플리케이션이 미처 핸들링하지 못한 에러가 발생하거나 서버가 아예 죽어버리기라도 하면 응답의 상태 코드에는 에러 코드인 500이나 502가 내려올 것이기 때문에 <code class=\"language-text\">try/catch</code> 구문을 사용하지 않을 수도 없다.</p>\n<p>클라이언트에서 사용하는 모든 HTTP 통신 라이브러리들은 올바른 HTTP 상태 코드의 사용을 가정하고 설계되었기 때문에, 서버가 올바르지 않은 상태 코드를 사용한다면 이런 슬픈 상황이 발생할 수도 있다는 점을 이야기해두고 싶다. 그리고 사실 백엔드 어플리케이션에서 상황에 맞는 올바른 상태 코드를 내려주는 것이 그렇게 어려운 일도 아니다. <small>(다만 조금 귀찮을 뿐이다)</small></p>\n<p>클라이언트와 마찬가지로 대부분의 서버 프레임워크에서 제공하는 통신 라이브러리들도 모든 상황에 맞는 HTTP 상태 코드들을 제공하고 있으니 되도록이면 알맞은 상황에 맞는 상태 코드를 사용하는 것을 추천한다.</p>\n<p>자, 그럼 이제 본격적으로 이 수많은 HTTP 상태 코드들이 정확히 어떤 상태를 의미하는지 알아보도록하자.</p>\n<h2 id=\"작업의-수행-상태를-알려주는-http-상태-코드\" style=\"position:relative;\">작업의 수행 상태를 알려주는 HTTP 상태 코드<a href=\"#%EC%9E%91%EC%97%85%EC%9D%98-%EC%88%98%ED%96%89-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C\" aria-label=\"작업의 수행 상태를 알려주는 http 상태 코드 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>클라이언트가 서버에게 작업을 요청하면 서버는 요청받은 작업을 수행한 후 작업의 수행 결과를 응답으로 보내주는데, 이때 HTTP 상태 코드를 사용하여 작업의 성공/실패 여부와 작업이 실패했다면 어떤 이유로 실패했는지도 알려주게 된다. 위에서 보았던 잘못된 예시처럼 HTTP 응답 바디에 작업의 실패 여부를 담아서 응답해주는 경우도 있지만, 더 좋은 방법은 바로 올바른 HTTP 상태 코드를 사용하는 것이다.</p>\n<p>HTTP 상태 코드는 “200 = 성공”, “400 = 클라이언트가 요청 잘못함”, “500 = 서버가 잘못함”과 같이 각 상황에 맞는 코드가 표준으로 정해져있으며, 웹 상에서 돌아가는 기본적인 프로그램의 동작이나 프론트엔드, 백엔드 프레임워크들의 설계 또한 이 표준을 기준으로 만들어져 있기 때문에 되도록이면 이 표준을 지켜주는 것이 좋다.</p>\n<p>HTTP 프로토콜을 사용하는 대표적인 프로그램인 웹 브라우저 또한 이러한 상태 코드 표준을 엄격하게 지키는 녀석 중 하나인데, 실제로 브라우저는 서버가 어떤 상태 코드를 응답으로 내려주는지에 따라 이번에 자신이 보낸 요청의 성공/실패 여부를 구분하고, 이를 시각적으로 표현해주기도 한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/581d5098769863da7581ecc2a09a19ed/d7ab4/browser-response.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 44.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABO0lEQVR42o1S7XKDIBD0VRJj4kc1ioqCCJh+vP8bbe8uaaadJtP+2Dk4cbndJbHWIoSAGAOMsRj1hLZTUvthxEw9Y5d71dMsfaV6WQ+jRkdrrue2RTJNE9Z1FVhv6EeDqqqw3+8FacpI7zgcDnd87b/3k3me4ZzDYh0632JajNyWFwXqusHxeLwRp8iy7AfhIyQsOcaIQJK3sEH1vcgbtYZbA+0H1E0jYFIhv13wkNCQRPbQey9yeTr2zy4O02zg44bL2wfi9gpDPfaPz1Qv9UNS8ZAls4duuZpelpVIZZxOuSDPcxRkA9c8L5DRt6cT8nRu9XjvFSzJ7SWxTlJjibvdTvAsnF8ebtt29ZGmHMeRnoeDprDWEIWUAyrK8s9AhFApBU0BMNEwXAPoqNecW7Q0JYfCnnJY/0n5E8S6FKangsPMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"browser response\" title=\"\" src=\"/static/581d5098769863da7581ecc2a09a19ed/6af66/browser-response.png\" srcset=\"/static/581d5098769863da7581ecc2a09a19ed/69538/browser-response.png 160w,\n/static/581d5098769863da7581ecc2a09a19ed/72799/browser-response.png 320w,\n/static/581d5098769863da7581ecc2a09a19ed/6af66/browser-response.png 640w,\n/static/581d5098769863da7581ecc2a09a19ed/d9199/browser-response.png 960w,\n/static/581d5098769863da7581ecc2a09a19ed/d7ab4/browser-response.png 1014w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>브라우저는 200번대의 상태 코드와 400, 500번대의 상태 코드를 전혀 다르게 인식한다</small>\n</center>\n<p>이런 상황에서 서버가 상태 코드는 200인데 응답의 바디로만 에러를 표현한다고 하면, 브라우저는 요청이 성공했다고 생각하지만 실제로는 요청이 실패한, 요상한 상황이 발생하게 된다.</p>\n<p>심지어 서버가 응답의 상태 코드로 301과 같은 코드를 내려준다면, 브라우저는 자동으로 사용자를 다른 페이지로 리다이렉트(Redirect)해버리기 때문에 서버가 제대로 된 상태 코드를 응답에 담아주지 않는다면 브라우저가 예측하지 못한 동작을 일으킬 수도 있다.</p>\n<p>자, 그럼 이제 각 HTTP 상태 코드가 어떤 상태들을 의미하는 것인지 하나씩 살펴보도록 하자. HTTP 상태 코드는 100번대 부터 500번대까지로 이루어져 있으며 꽤나 다양한 상태들을 정의할 수 있지만, 이걸 다 알 필요도 없고 설명하려면 너무 길기도 하니, 필자가 단 한번이라도 사용해보았던 상태 코드들을 기준으로 설명을 진행하려고 한다.</p>\n<h3 id=\"100번대\" style=\"position:relative;\">100번대<a href=\"#100%EB%B2%88%EB%8C%80\" aria-label=\"100번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>100번대 코드는 프로토콜을 교체해도 된다거나 계속 요청을 보내도 된다거나하는 식의 정보성을 띄고 있는 상태를 의미하지만, 실제로 필자가 어플리케이션을 개발하며 이 상태 코드들을 만나본 사례는 아직 단 한번도 없기 때문에 건너뛰도록 하겠다.</p>\n<h3 id=\"200번대\" style=\"position:relative;\">200번대<a href=\"#200%EB%B2%88%EB%8C%80\" aria-label=\"200번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>200번대 코드들은 클라이언트가 요청한 작업을 서버가 성공적으로 수행했다는 상태라는 것을 알려주는 코드이다. 200번대 코드들은 브라우저의 콘솔의 네트워크 탭에서도 깔끔한 초록색으로 표시해준다.</p>\n<p>물론 “요청한 작업이 성공”이라는 응답만으로도 클라이언트가 원하는 정보를 모두 만족시킬 수 있긴 하지만, 조금 더 디테일한 상태를 정의해야하는 상황이라면 이 200번대의 상태 코드를 적극적으로 사용하여 클라이언트에게 더 자세한 정보를 알려줄 수도 있다.</p>\n<p><strong>200 OK</strong></p>\n<p>상태 코드 <code class=\"language-text\">200</code>은 단순히 작업이 성공했음을 의미한다. 대부분의 경우 클라이언트는 자신이 요청한 작업이 정확히 어떤 작업인지 알고 있기 때문에, 서버에서 “니가 보낸 요청이 성공했어”라는 정보만 알려주면 굳이 그 이상의 디테일한 정보는 알 필요가 없다. 그래서 이 상태 코드 하나만으로 모든 API 응답 성공 상태를 퉁치는 경우가 대다수이다.</p>\n<p><strong>201 Created</strong></p>\n<p>상태 코드 <code class=\"language-text\">201</code>은 말 그대로 요청이 정상적으로 수행되었고, 그로 인해 리소스가 새롭게 생성되었다는 것을 의미한다. 클라이언트가 서버에게 요청을 보내서 새로운 리소스를 생성하는 상황은 굉장히 흔한데, 그 중 필자가 경험했던 대표적인 사례는 바로 “회원가입”이다. 결국 클라이언트의 회원가입 요청으로 인해 데이터베이스에 새로운 유저의 로우가 생성되었기 때문에, 이런 경우가 <code class=\"language-text\">201</code> 상태 코드가 아주 잘 들어맞는 케이스라고 볼 수 있다.</p>\n<p><strong>204 No Content</strong></p>\n<p>상태 코드 <code class=\"language-text\">204</code>는 요청이 정상적으로 수행되었고, 이 요청과 관련되었던 컨텐츠 또한 더 이상 깔끔하게 존재하지 않음을 의미한다. 이 상태 코드는 클라이언트가 서버에게 요청을 보내서 뭔가를 삭제해야하는 응답으로 사용될 수 있고, 실제로 필자가 경험했던 사례 또한 게시글을 삭제하는 API였다.</p>\n<p>참고로 이때 이 삭제 작업이 Soft Delete냐 Hard Delete냐와는 아무런 상관이 없다. 서버에서 어떤 방식으로 리소스의 삭제를 표현하던 클라이언트가 알아야할 정보는 “이 리소스는 삭제되었고, 더 이상 사용할 수 없다” 뿐이라는 사실을 명심하자.</p>\n<h3 id=\"300번대\" style=\"position:relative;\">300번대<a href=\"#300%EB%B2%88%EB%8C%80\" aria-label=\"300번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>300번대 코드들은 리다이렉션에 관련된 상태들을 의미한다. 클라이언트가 요청한 리소스가 옮겨졌거나 리소스가 삭제되었거나해서 정상적인 방법으로는 더 이상 해당 리소스에 접근할 수 없고 다른 URL을 통해서 그 리소스에 접근해야하는 경우 서버는 “여기로 가면 니가 찾는 리소스가 있어!”라는 정보를 알려줄 수 있는데, 이때 사용되는 상태 코드들이 바로 300번대 코드들이다.</p>\n<p><strong>301 Moved Permanetly</strong></p>\n<p>상태 코드 <code class=\"language-text\">301</code>은 <code class=\"language-text\">301 Redirect</code>라는 별칭으로 불리기도 할 만큼 리다이렉션을 위한 코드 중 가장 많이 사용되는 녀석이다. 브라우저는 자신의 대한 요청의 응답으로 <code class=\"language-text\">301</code>을 받으면 HTTP 헤더에 들어있는 <code class=\"language-text\">Location</code> 필드를 찾아보고, 해당 필드가 존재할 경우 <code class=\"language-text\">Location</code> 필드에 담긴 URL로 자동으로 리다이렉션한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\"><span class=\"token response-status\"><span class=\"token http-version property\">HTTP/1.1</span> <span class=\"token status-code number\">301</span> <span class=\"token reason-phrase string\">Moved Permanetly</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Location</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">https://evan/moved-contents/1234</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>또한 구글과 같은 검색 엔진의 봇들은 특정 페이지에 접근했는데 응답으로 <code class=\"language-text\">301</code> 상태 코드를 받을 경우 자동으로 페이지 정보를 갱신하기도 하기 때문에, SEO(Search Engine Optimization) 관점에서도 이 상태 코드를 올바르게 사용하는 것은 매우 중요하다.</p>\n<p>이런 리다이렉션 설정은 보통 서버 엔진의 설정 파일 내에서도 할 수 있고, 백엔드 어플리케이션 내에서 직접 할 수도 있다. 일반적인 경우 이 상태코드는 HTTP 프로토콜로 접속한 사용자를 HTTPS 프로토콜을 사용해야만 접근 가능한 포트로 보내버릴 때에도 많이 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-nginx line-numbers\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>         <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span>    evan.com</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">return</span>         <span class=\"token number\">301</span> https://<span class=\"token variable\">$host</span><span class=\"token variable\">$request_uri</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>         <span class=\"token number\">443</span> ssl</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span>    evan.com</span><span class=\"token punctuation\">;</span>\n    ...\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 경우 <code class=\"language-text\">80</code> 포트로 접속한 사용자를 발견한 Nginx는 HTTPS 프로토콜을 사용해야만 접근할 수 있는 <code class=\"language-text\">443</code> 포트로 리다이렉트시켜서 해당 프로토콜 사용을 강제할 수 있다.</p>\n<p><strong>304 Not Modified</strong></p>\n<p>상태 코드 <code class=\"language-text\">304</code>는 클라이언트가 요청한 리소스가 이전 요청때와 비교해보았을 때 전혀 달라진 점이 없다는 것을 의미한다. 즉, 말 그대로 Not Modified, 수정되지 않음이다.</p>\n<p>서버가 응답으로 이 상태 코드를 보내주면 클라이언트는 굳이 서버에게 리소스를 재전송받아야할 필요가 없기에 자신이 캐싱해놓았던 리소스를 사용하게되며, 이 과정에서 불필요한 통신 페이로드의 낭비를 줄일 수 있다.</p>\n<p>이 과정에서 클라이언트는 서버로부터 요청된 리소스를 받은 것이 아니라 자신의 캐싱해놓았던 리소스를 사용하는 것이므로 이 또한 캐싱된 리소스로 리다이렉션되었다고 치는 것이다. 그런 이유로 <code class=\"language-text\">304</code> 상태 코드는 암묵적인 리다이렉션으로 불리기도 한다.</p>\n<p>브라우저 역시 이 응답을 위한 자체 캐싱 기능을 가지고 있으며, 만약 <code class=\"language-text\">304</code> 상태 코드를 응답으로 받았는데 캐싱된 리소스가 없는 경우에는 빈 화면을 띄우거나 에러 화면이 노출된다. 그러니 이런 상황을 만나면 “브라우저에 Cached Resource가 없는 거 아님?”이라는 킹리적 갓심을 발휘해볼 수 있다.</p>\n<h3 id=\"400번대\" style=\"position:relative;\">400번대<a href=\"#400%EB%B2%88%EB%8C%80\" aria-label=\"400번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>400번대의 코드들은 클라이언트가 서버에게 보낸 요청이 잘못된 경우를 의미한다. 만약 이 상태 코드를 발견한다면 높은 확률로 프론트엔드 개발자가 예외 처리를 제대로 안 했거나 요청에 이상한 값이 묻은 경우가 많으니, 프론트엔드 개발자의 멱살을 잡도록 하자. <small><strike>(낮은 확률로 백엔드의 잘못인 경우도 있다…)</strike></small></p>\n<p><strong>400 Bad Request</strong></p>\n<p>상태 코드 <code class=\"language-text\">400</code>는 가장 많이 만날 수 있는 400번대 코드 중 하나이며, 밑도 끝도 없이 “클라이언트가 요청 잘못 날림”을 의미한다. 이때 뭘 어떻게 잘못 날렸는지는 보통 HTTP 응답 바디에 담아서 알려주는 경우도 있지만, 그렇지 않은 경우에는 백엔드 어플리케이션의 로그를 까봐야하는 슬픈 상황이 펼쳐질 수도 있다.</p>\n<p><strong>401 Unauthorized</strong></p>\n<p>상태 코드 <code class=\"language-text\">401</code>는 인증되지 않은 사용자가 인증이 필요한 리소스를 요청하는 경우에 “너 인증 필요함”이라고 알려주는 상태 코드이다. 보통 로그인이 필요한 API를 비로그인 사용자가 호출했을 때 많이 사용된다.</p>\n<p>클라이언트에서는 서버가 <code class=\"language-text\">401</code>을 응답으로 보내준 경우, 로그인이 필요하다는 것으로 판단하고 로그인 페이지로 사용자를 리다이렉션하기도 한다.</p>\n<p><strong>403 Forbidden</strong></p>\n<p>상태 코드 <code class=\"language-text\">403</code>는 클라이언트가 접근이 금지된 리소스를 요청했음을 의미한다. 이 상태 코드는 간혹 <code class=\"language-text\">401 Unauthorized</code>와 헷갈리고는 하는데, 상태 코드의 의미만 보면 확실히 애매모호하지만, 사실 분명한 한 가지 차이점이 있다.</p>\n<p><code class=\"language-text\">401</code>은 말 그대로 인증되지 않았다는 것을 의미하며, 인증이 되지 않았다는 것은 백엔드 어플리케이션이 현재 요청한 사용자가 누구인지 알 수가 없다는 것을 의미한다. 즉 이때 서버는 클라이언트에게 “너의 신원을 밝혀!”라고 말하고 있는 것이다.</p>\n<p>그러나 <code class=\"language-text\">403</code>의 경우, 백엔드 어플리케이션은 현재 리소스를 요청한 사용자가 누구인지 전혀 신경쓰지 않는다. 클라이언트가 현재 자신이 누구인지 밝혔던 밝히지 않았던, 인증이 되었던 안 되었던 간에, 이 리소스를 요청하는 것은 무조건 금지라고 말하고 있는 것이다.</p>\n<p>HTTPS 프로토콜로만 접근해야하는 리소스에 HTTP 프로토콜을 사용하여 접근했을 경우에 서버에서 <code class=\"language-text\">403</code> 응답을 보내주기도 한다.</p>\n<p><strong>404 Not Found</strong></p>\n<p>상태 코드 <code class=\"language-text\">404</code>는 말 그대로 요청한 리소스가 존재하지 않다는 것을 의미한다.</p>\n<p><strong>405 Method Not Allowed</strong></p>\n<p>상태 코드 <code class=\"language-text\">405</code>는 현재 리소스에 맞지않는 메소드를 사용했음을 의미한다. 백엔드 프레임워크의 경우 특정 컨트롤러에 해당 메소드를 사용하는 로직이 없다면 자동으로 <code class=\"language-text\">405</code>를 내려주기도 한다.</p>\n<p><strong>406 No Acceptable</strong></p>\n<p>상태 코드 <code class=\"language-text\">406</code>은 <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Content_negotiation#%EC%84%9C%EB%B2%84_%EC%A3%BC%EB%8F%84_%EC%BB%A8%ED%85%90%EC%B8%A0_%ED%98%91%EC%83%81\" target=\"_blank\" rel=\"nofollow\">서버 주도 컨텐츠 협상</a>을 진행했음에도 불구하고 알맞은 컨텐츠 타입이 없다는 것을 의미한다.</p>\n<p>사실 클라이언트는 서버에게 리소스를 요청할 때, HTTP 헤더의 <code class=\"language-text\">Accept</code> 필드를 사용하여 어떤 컨텐츠 타입의 리소스를 원하는지도 함께 이야기해준다. 일반적으로 이 필드를 명시하지않을 경우 브라우저는 자동으로 <code class=\"language-text\">text/html</code>을 비롯한 몇 가지 타입들을 스스로 정의해서 헤더에 담아주고는 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-http line-numbers\"><code class=\"language-http\">GET http://evan.com/\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">text/html,application/xhtml+xml,application/xml,*/*</span></span>\n...</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이런 요청을 받은 서버는 클라이언트가 보낸 요청의 <code class=\"language-text\">Accept</code> 필드를 보고 앞에서부터 하나씩 찾아가며 요청받은 리소스와 알맞은 컨텐츠 타입이 있는지 하나씩 살펴보게 되고, 이후 알맞은 컨텐츠 타입이 있다면 HTTP 응답 헤더의 <code class=\"language-text\">Content-Type</code> 필드에 해당 컨텐츠 타입을 명시해주게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">HTTP/1.1 200 OK\nContent-Type: text/html</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 과정에서 어떤 컨텐츠 타입의 리소스를 응답으로 내려줄 것인지는 전적으로 서버가 결정하게 되므로 이 과정을 “서버 주도 컨텐츠 협상”이라고 하는 것이다. 위의 예시의 경우 클라이언트가 받기를 원했던 컨텐츠 타입 중 첫 번째 우선순위를 가진 <code class=\"language-text\">text/html</code>를 받아왔지만, 만약 서버에 <code class=\"language-text\">text/html</code> 타입의 리소스가 존재하지 않는 경우, 서버는 <code class=\"language-text\">application/xhtml+xml</code>, <code class=\"language-text\">application/xml</code> 순서로 리소스를 탐색하게 된다.</p>\n<p>만약 앞에 나열된 모든 컨텐츠 타입이 없는 경우 클라이언트가 요청했던 컨텐츠 타입 중 가장 마지막인 <code class=\"language-text\">*/*</code> 와일드 카드에 걸리기 때문에, 서버는 리소스가 어떤 컨텐츠 타입인지 상관하지 않고 그대로 응답해줄 것이다. 그러나 만약 클라이언트가 요청한 컨텐츠 타입을 모두 탐색했는데도 불구하고 알맞은 리소스가 없을 경우 서버는 <code class=\"language-text\">406</code> 상태 코드와 함께 “니가 찾는 컨텐츠 타입과 맞는 리소스가 없어”라는 응답을 주는 것이다.</p>\n<p><strong>408 Request Timeout</strong></p>\n<p>상태 코드 <code class=\"language-text\">408</code>은 클라이언트와 서버의 연결은 성사되었지만 요청의 본문이 계속 서버에 도착하지 않는 상황을 의미한다.</p>\n<p>HTTP 프로토콜을 사용하여 통신을 할 때는 반드시 클라이언트와 서버 간의 연결을 생성하고, 그 이후에 요청 본문에 해당하는 데이터를 전송하게 되는데, <code class=\"language-text\">408</code> 상태 코드는 이 과정에서 연결은 제대로 생성되었지만 서버가 아무리 기다려도 클라이언트가 보냈던 요청 본문을 받지 못하는 경우에 발생하게 된다.</p>\n<p><strong>429 Too Many Requests</strong></p>\n<p>상태 코드 <code class=\"language-text\">429</code>는 클라이언트가 서버에 너무 요청을 많이 보내는 경우에 발생한다. 너무 많이 보냈다는 것은, 너무 짧은 시간 안에 빠르게 요청을 마구 날려대서 서버가 “워워 진정해”라고 하는 경우일수도 있고, 유료 API를 사용하는 경우에는 현재 금액으로 사용할 수 있는 API 요청 횟수를 초과해서 “돈을 더 내세요”라는 의미로 사용되기도 한다.</p>\n<p>서버에서는 <code class=\"language-text\">429</code> 상태 코드와 함께 응답 헤더의 <code class=\"language-text\">Retry-After</code>라는 필드를 사용하여 “이 시간 이후에 재요청해봐”라는 의미를 전달할 수도 있다.</p>\n<h3 id=\"500번대\" style=\"position:relative;\">500번대<a href=\"#500%EB%B2%88%EB%8C%80\" aria-label=\"500번대 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>500번대의 코드들은 클라이언트가 아닌 서버에서 뭔가 말썽이 일어난 경우이다. 만약 이 상태 코드를 발견했다면 서버에서 뭔가 박살났다는 의미이므로 다소곳이 백엔드 개발자의 멱살을 잡아보도록 하자.</p>\n<p><strong>500 Internal Server Error</strong></p>\n<p>상태 코드 <code class=\"language-text\">500</code>은 백엔드 어플리케이션 내에서 뭔가 알 수 없는 에러가 발생했다는 의미이다. 대부분 제대로 핸들링되지 않은 에러가 발생한 경우가 많으므로, 에러의 원인을 클라이언트에게 알려주지 않는다.<small><strike>(라기 보다 알려줄 수 없는 상태인 경우가 많다)</strike></small></p>\n<p>또한 이렇게 핸들링되지 않은 에러의 원인을 클라이언트에게 고스란히 알려주는 것은 보안 사고가 발생할 가능성이 너무 크므로, <code class=\"language-text\">500</code> 상태 코드로 에러의 발생 자체만을 알려주는 경우가 대부분이다. 만약 이 상태 코드를 만난다면, 바로 서버 로그를 까보거나 <a href=\"https://sentry.io/welcome/\" target=\"_blank\" rel=\"nofollow\">Sentry</a>나 <a href=\"https://www.bugsnag.com/\" target=\"_blank\" rel=\"nofollow\">Bugsnag</a>과 같은 에러 모니터링 솔루션을 적극 활용하는 것을 추천한다.</p>\n<p><strong>502 Bad Gateway</strong></p>\n<p>상태 코드 <code class=\"language-text\">502</code>를 만날 수 있는 가장 흔한 상황은 바로 백엔드 어플리케이션이 죽은 상황이다. 근데 왜 “Server Died”와 같이 직접적인 메세지가 아니라 “Bad Gateway”와 같은 메세지를 보내주는 것일까?</p>\n<p>그 이유는 백엔드 아키텍처가 아무리 간단한 구조라고 해도 절대 어플리케이션 1개로만 구성되지 않기 때문이다. 여기서 말하는 게이트웨이는 어플리케이션 간의 추상적인 연결점을 의미하는데, 이 메세지가 의미하듯 백엔드의 아키텍처는 최소 2개 이상의 어플리케이션으로 구성된 경우가 대부분이다.</p>\n<p>일반적인 경우 클라이언트가 보낸 요청은 곧바로 백엔드 어플리케이션에 전달되는 것이 아니다. 사실 백엔드 어플리케이션에 앞단에는 아파치나 Nginx 같은 서버 엔진이나 로드밸런서 같은 친구들이 대신 요청을 받아서 백엔드 어플리케이션으로 전달해주는 경우가 대부분이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-nginx line-numbers\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span> <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span> evan.com</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://127.0.0.1:3000</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_http_version</span> 1.1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Upgrade <span class=\"token variable\">$http_upgrade</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Connection <span class=\"token string\">'upgrade'</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Host <span class=\"token variable\">$host</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_cache_bypass</span> <span class=\"token variable\">$http_upgrade</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Nginx를 사용하면 일반적으로 이런 설정을 사용하게 되는데, 이렇게 되면 Nginx는 80번 포트에서 대기하며 HTTP 프로토콜을 사용한 요청을 받아 3000번 포트에서 대기하고 있는 백엔드 어플리케이션에게 전달해주는 역할을 수행하게 된다.</p>\n<p>이런 아키텍처를 사용하는 이유는 보안과 처리 효율 때문이다. 백엔드 어플리케이션 자체가 완전무결한 친구가 아니기 때문에 모든 요청을 안심하고 백엔드 어플리케이션에게 먹여줄 수가 없는 것이다. 그렇다고 누가 사용하는 지도 모르는 클라이언트에서 안전한 요청만 보내줄 것이라는 기대 또한 어불성설이다.</p>\n<p>게다가 뭔가 연산이 필요한 요청이 아닌, 파일을 찾아서 보내주기만 하는 간단한 요청 같은 경우는 굳이 안 그래도 바쁜 백엔드 어플리케이션에게 시킬 필요가 없으므로 이런 서버 엔진이 대신 처리해주기도 한다.</p>\n<p>그래서 백엔드에서는 앞 단에 아예 프록시 서버를 두어서 문지기 역할을 시키는 것이다. 이때 이 프록시 서버와 백엔드 어플리케이션 간의 연결된 추상적인 통로를 “게이트웨이”라고 부르는 것이다. 백엔드 어플리케이션이 죽어버릴 경우 앞 단의 문지기인 프록시 서버는 백엔드 어플리케이션에게 아무런 응답을 받지 못하게 되고, 클라이언트에게 <code class=\"language-text\">502 Bad Gateway</code>라는 응답을 보내주는 것이다.</p>\n<p><strong>503 Service Unavailable</strong></p>\n<p>상태 코드 <code class=\"language-text\">503</code>은 서버가 요청을 처리할 준비가 되지 않았음을 의미한다. 간혹 <code class=\"language-text\">502 Bad Gateway</code>와 비슷한 느낌으로 사용되기는 하지만, <code class=\"language-text\">503</code>은 보다 “일시적인 상황”을 의미하는 상태 코드이며, 일반적으로 서버에 부하가 심해서 현재 요청을 핸들링 할 수 있는 여유가 없는 경우에 많이 사용된다.</p>\n<p>AWS Lambda에서는 요청을 처리할 때 컨테이너의 동시 실행 갯수를 초과할 정도의 리소스가 필요하거나 어떤 작업의 처리 시간이 Lambda에 설정된 컨테이너의 최대 수명 시간을 초과했을 경우에 발생하기도 한다.</p>\n<p>이렇듯이 <code class=\"language-text\">503</code>은 일시적인 상황을 의미하므로 <code class=\"language-text\">429 Too Many Requests</code>와 동일하게 응답 헤더의 <code class=\"language-text\">Retry-After</code> 필드를 사용하여 “이 시간 이후에 다시 요청해봐”라는 의미를 클라이언트에게 전달해줄 수 있다.</p>\n<p><strong>504 Gateway Timeout</strong></p>\n<p>상태 코드 <code class=\"language-text\">504</code>는 <code class=\"language-text\">408</code>과 마찬가지로 요청에 대한 타임아웃을 의미한다. 그러나 <code class=\"language-text\">504</code> 상태 코드는 클라이언트에서 보낸 요청 때문에 타임아웃이 발생하는 것이 아니라 백엔드 아키텍처 내부에서 서버끼리 주고받는 요청에서 발생한다.</p>\n<p>앞서 이야기했듯이 백엔드의 아키텍처는 단순히 백엔드 어플리케이션 하나로만 구성된 것이 아니기 때문에, 클라이언트의 요청이 서버에 닿은 뒤에도 백엔드 어플리케이션끼리의 통신이 발생하게 된다. 만약 프록시 서버 역할을 맡은 Nginx가 백엔드 어플리케이션에 클라이언트의 요청을 전달했는데, 백엔드 어플리케이션이 일정 시간 동안 응답을 하지 않는 경우 Nginx는 클라이언트에게 <code class=\"language-text\">504 Geteway Timeout</code>을 내려주게 되는 것이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 이번 포스팅에서는 HTTP 상태 외에도 RESTful API에 대한 내용도 함께 이야기하려고 했지만, 다시 한번 분량 조절에 대실패하면서 포스팅을 나누어 작성하게 되었다.<small>(점점 빈도가 잦아진다…)</small></p>\n<p>앞서 이야기했듯이 이런 상태 코드와 같은 요소들은 딱히 안 지킨다고 해서 프로그램에서 에러가 발생하는 것도 아니기 때문에 가볍게 생각하고 넘어가기 쉽상이지만, 보다 명확한 인터페이스를 정의하게되면 프로그램의 작동을 예측하기도 쉬워지고, 프론트엔드와 백엔드 개발자 간의 커뮤니케이션에도 큰 도움이 되기 때문에 되도록이면 표준을 지켜주는 것을 권장한다.</p>\n<p>이상으로 서버의 상태를 알려주는 HTTP 상태 코드 포스팅을 마친다.</p>","fields":{"slug":"20200315-about-http-status-code","path":"/2020/03/15/about-http-status-code/","lang":"ko"},"frontmatter":{"title":"서버의 상태를 알려주는 HTTP 상태 코드","subTitle":"인터넷의 질서를 만드는 작은 숫자들","date":"Mar 15, 2020","categories":["프로그래밍","네트워크","아키텍처"],"tags":["HTTP","HTTP 상태코드","RESTful","Axios","HTTP Status"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/14576b0c5dc2ed40f94b7160f16c1e06/d803c/thumbnail.png","srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/d803c/thumbnail.png 320w,\n/static/14576b0c5dc2ed40f94b7160f16c1e06/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/fc5c5/thumbnail.webp 320w,\n/static/14576b0c5dc2ed40f94b7160f16c1e06/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/14576b0c5dc2ed40f94b7160f16c1e06/01fb2/thumbnail.png","srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/14576b0c5dc2ed40f94b7160f16c1e06/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"10f3f894-af40-5c3f-af3f-e6d6e621d61f","tableOfContents":"<ul>\n<li>\n<p><a href=\"#http2%EB%9E%80\">HTTP/2란?</a></p>\n</li>\n<li>\n<p><a href=\"#aws-cloud-front%EC%97%90%EC%84%9C-http2-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">AWS Cloud Front에서 HTTP/2 사용하기</a></p>\n<ul>\n<li><a href=\"#cloudfront-distributions-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0\">CloudFront Distributions 변경하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#elastic-beanstalk%EC%97%90%EC%84%9C-http2-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">Elastic Beanstalk에서 HTTP/2 사용하기</a></p>\n<ul>\n<li><a href=\"#application-load-balancer%EB%9E%80\">Application Load Balancer란?</a></li>\n<li><a href=\"#%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\">설정하기</a></li>\n<li><a href=\"#%EC%84%9C%EB%B2%84%EC%97%90-%EB%B3%84%EB%8F%84-%EC%84%A4%EC%A0%95%EC%9D%84-%EC%95%88%ED%96%88%EB%8A%94%EB%8D%B0\">서버에 별도 설정을 안했는데?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#http2-%EC%9E%98-%EC%A0%81%EC%9A%A9-%EB%90%90%EB%8B%88\">HTTP/2, 잘 적용 됐니?</a></p>\n</li>\n<li>\n<p><a href=\"#waterfall%EB%A1%9C-%EB%B9%84%EA%B5%90%ED%95%B4%EB%B3%B4%EC%9E%90\">Waterfall로 비교해보자</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 AWS(Amazon Web Service) 환경에서 HTTP/2 프로토콜을 적용하는 방법에 대해서 설명하려고 한다. AWS의 CloudFront와 Application Load Balancer는 자체적으로 HTTP/2 프로토콜을 사용할 수 있는 기능들을 제공해주고 있기 때문에 별도의 작업 없이 간단하게 HTTP/2 프로토콜을 적용할 수 있다.","html":"<p>이번 포스팅에서는 AWS(Amazon Web Service) 환경에서 HTTP/2 프로토콜을 적용하는 방법에 대해서 설명하려고 한다. AWS의 CloudFront와 Application Load Balancer는 자체적으로 HTTP/2 프로토콜을 사용할 수 있는 기능들을 제공해주고 있기 때문에 별도의 작업 없이 간단하게 HTTP/2 프로토콜을 적용할 수 있다.</p>\n<!-- more -->\n<h2 id=\"http2란\" style=\"position:relative;\">HTTP/2란?<a href=\"#http2%EB%9E%80\" aria-label=\"http2란 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>HTTP/1은 이미 세상에 나온지 30년이 다 되어가는 프로토콜로, 웹 어플리케이션을 위한 프로토콜이라기 보다는 문서를 위한 프로토콜로 설계되었기 때문에 모던 웹 어플리케이션과 같이 무거운 페이로드, 빈번한 통신 등의 환경에서는 여러 가지 비효율적인 점이 많다.</p>\n<p>그래서 HTTP/2는 현대적인 통신을 지원하기 위해 다음과 같은 목표를 가지고 고안되었다.</p>\n<hr>\n<ul>\n<li>전체 요청, 응답 다중화를 통한 지연 시간 단축</li>\n<li>비대한 HTTP 헤더 필드의 효율적인 압축을 통해 프로토콜 오버헤드를 최소화</li>\n<li>요청 우선 순위 지정</li>\n<li>서버 푸시 지원</li>\n</ul>\n<hr>\n<p>HTTP/2는 기존 HTTP/1 프로토콜을 사용하고 있는 어플리케이션을 수정하지 않고도 모든 핵심 개념(메소드, 상태 코드, URI 및 헤더 필드)을 공유하도록 설계되었다. 대신 HTTP/2는 클라이언트와 서버 간 데이터 프레임과 전송 방식을 수정하는 방식으로 통신 효율을 높였다.</p>\n<p>또한 클라이언트와 서버 간 통신에서 가장 효과가 큰 것은 응답 다중화가 정식으로 지원된다는 것이다. 이 말은 하나의 연결만 으로 여러 리소스를 주고 받을 수 있다는 뜻이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cd17700751cbce62e857b08574923f45/9c177/multiplexing.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 97.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAADeUlEQVR42p2U/U9TVxjH+08tWChCaaGlvbcUmagzCiuzbqAD0Y3o3BCVQSl9oS1liCUWYWTJiJuEqJsvGUucUfe+yUtfLy1QzP6Hz869JUxQt+kPT07Oued87vPyfR6d5E9hG0xxcCTLiak87ZM5jsQUmi8p1A+lqRlIiv0KrssKFm8S9X5rPMfJz/O0ifW9Kys0RjLUCobkS6KT/Eks4tGp6VUCNzfovV6g+1qBs1+usT+aodojgOMrtKhAca8umMY7t0HPtXUG5gr0zxZwjSnajzeBGeyDCey+lLAksjCnbwlZeKKa6tU7OzxUI6rdtOK71NZ7na3/d6ShvIAuYxrMYTr3C66uGSy+rPbwRcDtkB1AvamO2t4fcUQK9Ez9xsy9JT6bXeBEfImmkcSrA8vsTegrrZTu6eBgyzGGZrO4x0SuAqq92EPp34BquMYjAQzy25i771PRr2D2pLH50trjbcCBhIAltJzLfhVeLIS6/gMURZHDG1oeLT4FaXCRhuACDv+yBt0GFN/rImvIoTymgRzVXgWrOKv2ZgQ0rdVBV/5mO3axcYqLJ68q3LoR5+G9i/RO3uHAcBarNyGACi2xPDXnH1DXPoH71GW6J+9ycfoB7f5beCfmMQl5ycEVdCVlRgxSE+VHRznWeYaZ71KcnlzkQCRBfTClaU8Vumt8HfvHN7GYjDirSuhyV3H2+F66OtzEwn1UuTzYL/wgZOP5k/I9x9m1u5rKji8wehR2f5re0pgastYpY1ks/hx7vY9o6LnBvgvfEpmeJxodRWo+jfP9MHpDZTGHUmgNyfMHpsBT9nl/ZmTqNlZ/dgv4bFHsAQV7cFVYDnuogKP/J0pth3nDYKaq9ZKQjdSM3btIffQpnVcW+Xp+gUxigdbYMoeiCZHDHbJRq+pLaKtaBBWsNof13PeaYzq9UaK0poGyw324WzuYuJ2hbTzF/rBoweAzIb9U2OqZiHIoV6yyuql46yP0JifGD+eoFDm0+IWEvOnnQ35ppyS3TGfr+xV5+C9NqLWhDeTBJ3QOf0NjaFmcpZ8P+b9ab1eFBWvPfRzhNT6JP+b6ncdcjUX5IP6EQyPJVwcanO8KyZgpkY/S2NSG5ysxXMdWcQR2yOb/AuXQuij3qNBiG+bzj4QOM2JYFuej5H+N8aVVSZRbDhdE6yibTV+cKK8D/BtyUDBzrCWA+QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"multiplexing\" title=\"\" src=\"/static/cd17700751cbce62e857b08574923f45/6af66/multiplexing.png\" srcset=\"/static/cd17700751cbce62e857b08574923f45/69538/multiplexing.png 160w,\n/static/cd17700751cbce62e857b08574923f45/72799/multiplexing.png 320w,\n/static/cd17700751cbce62e857b08574923f45/6af66/multiplexing.png 640w,\n/static/cd17700751cbce62e857b08574923f45/9c177/multiplexing.png 880w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>[출처] csstrick.com<small>\n</small></small></center>\n<p>HTTP/1에서는 프로토콜 차원의 응답 다중화가 지원되지않았고 응답의 병렬 처리는 브라우저가 책임을 가졌다. 그렇기 때문에 브라우저의 정책에 따라 요청의 병렬처리가 가능한 개수가 달랐다.</p>\n<hr>\n<ul>\n<li>Internet Explorer: 출처 별 10개~11개</li>\n<li>Chrome: 출처 별 6개</li>\n<li>Firefox: 출처 별 6개</li>\n<li>Opera: 출처 별 6개</li>\n</ul>\n<hr>\n<p>그렇기 때문에 프론트엔드 개발자들은 어플리케이션 초기화 시 최대한 리소스 요청을 줄이기 위해 모든 JavaScript와 CSS 파일을 하나의 번들로 묶어 <code class=\"language-text\">index.js</code>나 <code class=\"language-text\">style.css</code>와 같은 파일로 만들고 Minify나 Uglify 등의 기법을 사용하여 용량을 최대한 줄이기도 하고, 여러 개의 이미지를 요청하지 않기 위해 하나의 커다란 이미지를 다운로드받아 마스킹해서 사용하는 스프라이트 방식과 같은 방식을 사용했다.</p>\n<p>하지만 HTTP/2는 출처 별로 최대 128개의 병렬 요청을 처리할 수 있으므로, 이제 우리는 하나의 큰 파일이 아닌 작은 여러 개의 파일로 나눠서 동시에 요청하고 받아올 수 있는 등의 HTTP/1.1에서는 하지 못했던 성능 개선의 여지를 만들 수 있게되었다.</p>\n<h2 id=\"aws-cloud-front에서-http2-사용하기\" style=\"position:relative;\">AWS Cloud Front에서 HTTP/2 사용하기<a href=\"#aws-cloud-front%EC%97%90%EC%84%9C-http2-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"aws cloud front에서 http2 사용하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>AWS는 2016년 9월부터 Cloud Front에서 HTTP/2를 지원해주기 시작했다. 간단한 세팅 만으로 HTTP/1.1에서 HTTP/2로 변경할 수 있다. 또한 HTTP/2를 지원하지않는 하위 버전의 브라우저에서 요청을 받는다면 HTTP/1.1으로 프로토콜을 변경하여 응답하는 기능 또한 가지고 있다.</p>\n<p><a href=\"https://aws.amazon.com/blogs/aws/new-http2-support-for-cloudfront/\" target=\"_blank\" rel=\"nofollow\">AWS CloudFront HTTP/2 세팅 메뉴얼</a>에서 HTTP/2를 세팅할 수 있는 방법을 자세히 설명해주고 있기 때문에 프로토콜을 변경하는 과정은 전혀 어려움이 없었다.</p>\n<h3 id=\"cloudfront-distributions-변경하기\" style=\"position:relative;\">CloudFront Distributions 변경하기<a href=\"#cloudfront-distributions-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0\" aria-label=\"cloudfront distributions 변경하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>먼저 Cloud Front 대시보드로 이동하면 현재 등록되어있는 배포판들의 목록이 보인다. 이 중 HTTP/2 프로토콜을 적용하고 싶은 배포판을 선택한 후 상단의 <code class=\"language-text\">Distribution Settings</code>을 선택한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 634px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e1216e67d70cafeea2556e898cbfef79/374ac/cloudfront1.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 16.249999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAs0lEQVR42k2OXQqCQBSF3XD02Eu7aAf1Ei2hVVSazBSVaGlC4Pivo/g1CUUHDufjXjgc6xk+kOKIc9jjXS+cTgLbObDb7zjaDrZxEAR8NAzDL//5qw9b/qvE9RPkXXEOFW6gSPKKNDWZJCilSFVK27b0fU/TNHRdN7qu69+tKAq07rAWW5/pymW2Fsw3gslSIB4ZoX8za894noeUkjCKxtI4jseiqip5GtZaE5mfFIIsy3kDCJDel9x/7mwAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"cloudfront1\" title=\"\" src=\"/static/e1216e67d70cafeea2556e898cbfef79/374ac/cloudfront1.png\" srcset=\"/static/e1216e67d70cafeea2556e898cbfef79/69538/cloudfront1.png 160w,\n/static/e1216e67d70cafeea2556e898cbfef79/72799/cloudfront1.png 320w,\n/static/e1216e67d70cafeea2556e898cbfef79/374ac/cloudfront1.png 634w\" sizes=\"(max-width: 634px) 100vw, 634px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p><code class=\"language-text\">Distribution Settings</code>을 클릭해서 배포판 설정 화면으로 들어가면 현재 배포판에 대한 여러 가지 정보가 있는 화면이 나온다. 이 정보들 중 이 배포판이 지원하고 있는 프로토콜에 대한 정보도 함께 담겨있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9590e8009282b8ca9e49b979a697dc38/636c2/cloudfront2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 59.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABY0lEQVR42oWS63KDIBCFff9Xa2baRsd410RRVMQUvIKXrpq0SSZNvx87wOxhzy4oJWsDRL7qluRZli7wipfnsiiKpmnyPId1SSnGSVVXOMGEFHVdF5T2fa8UhFQVn+cZNkKItm0Z513XNXUN66qqhmGYxgki5Eg5jOM4TRNkQlS2zXxFSpli7PvB8Xg0DcOyrCzL6Ap4gUgIAUdbsjLfwxkHjaaqjPHt0mEYhxV5Beo9irfU8BR+frxrmhbHcUlL0AgphRQ/glvuKkMGdOs6zsEwCMkRijHG4cpm9bbBXzEMgC+wKIpQFBmmyRiDEc4vuYi7roVJgABeS93vVU0LgsAyTdu2YWae5yGE4BWfV14GI2VBizhJ3nY7sI3TNCfwyGc4hEvHlT97HoTAgR+6jqvrnn4IHZcmSQ+yXvxj+6Lve4wi2zR1dY9OYRxG8Eu6tn1w+1y84fme47pdvwCf7MXYvgFuGrA4CzbmowAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"cloudfront2\" title=\"\" src=\"/static/9590e8009282b8ca9e49b979a697dc38/6af66/cloudfront2.png\" srcset=\"/static/9590e8009282b8ca9e49b979a697dc38/69538/cloudfront2.png 160w,\n/static/9590e8009282b8ca9e49b979a697dc38/72799/cloudfront2.png 320w,\n/static/9590e8009282b8ca9e49b979a697dc38/6af66/cloudfront2.png 640w,\n/static/9590e8009282b8ca9e49b979a697dc38/636c2/cloudfront2.png 911w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이제 상단의 <code class=\"language-text\">Edit</code> 버튼을 눌러 배포판의 설정을 변경하도록 하자. 밑으로 쭉 내리다보면 <code class=\"language-text\">Supported HTTP Versions</code>라는 항목이 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 598px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5246325f1e672822f3bab327f1bf4566/0c69d/cloudfront3.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 12.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAgElEQVR42m1O0QrCMAzc//+iY0qXKjZZHybrbGl7pkVhqAchueMuyYA3Ss4opeCIWmuvz9y7er59RwzjeALRjJkI1lqcpwnO3RFCwMUYGNWZGXS9QdhBRMDC2ML2c7wvjDEipdSvZv2y8dabxhqWZcFjXeG9h1e+788WV3/9++EL7pvpWv+Z2GQAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Supported HTTP Versions\" title=\"\" src=\"/static/5246325f1e672822f3bab327f1bf4566/0c69d/cloudfront3.png\" srcset=\"/static/5246325f1e672822f3bab327f1bf4566/69538/cloudfront3.png 160w,\n/static/5246325f1e672822f3bab327f1bf4566/72799/cloudfront3.png 320w,\n/static/5246325f1e672822f3bab327f1bf4566/0c69d/cloudfront3.png 598w\" sizes=\"(max-width: 598px) 100vw, 598px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이제 첫 번째 항목인 <code class=\"language-text\">HTTP/2, HTTP/1.1, HTTP/1.0</code>을 선택하면 된다.</p>\n<h2 id=\"elastic-beanstalk에서-http2-사용하기\" style=\"position:relative;\">Elastic Beanstalk에서 HTTP/2 사용하기<a href=\"#elastic-beanstalk%EC%97%90%EC%84%9C-http2-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"elastic beanstalk에서 http2 사용하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Elastic Beanstalk은 Web 서버나 Worker와 같이 친숙한 웹 어플리케이션이나 서비스를 간편하게 배포하거나 컨트롤할 수 있는 서비스이다. Elastic Beanstalk에서 환경을 생성할 때 사용할 언어나 서버 엔진등을 설정해놓으면 해당 설정을 사용하여 다른 환경으로 복사할 수도 있고 Auto Scaling이나 Load Balancing과 같은 귀찮은 설정이 필요한 작업들도 간단한 몇개의 설정만 건드려주면 알아서 다 해주기 때문에 꿀이 따로 없다.</p>\n<p>또한 프로젝트의 루트에 <code class=\"language-text\">.ebextensions</code> 디렉토리를 생성하고 내부에 쉘 스크립트 파일을 넣어놓으면 파일 정렬 순서에 따라서 배포할 때마다 해당 스크립트들을 실행시킬 수도 있어서 굉장히 유연하다.<small><del>(node-sass가 말썽부려서 rebuild 해야할 때 아주 유용하다)</del></small></p>\n<p>환경을 생성할 때 Classic Load Balancer와 Application Load Balancer 중 하나의 로드 밸런서를 선택할 수 있는데 Classic Load Balancer는 기존의 ELB를 의미한다. Elastic Beanstalk에서 HTTP/2를 사용하고 싶다면 Application Load Balancer를 선택하도록 하자. 물론 ELB를 고르고 직접 세팅하는 방법도 있지만 필자는 굳이 어려운 길을 선택하지 않았다.</p>\n<h3 id=\"application-load-balancer란\" style=\"position:relative;\">Application Load Balancer란?<a href=\"#application-load-balancer%EB%9E%80\" aria-label=\"application load balancer란 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>AWS는 지난 2016년에 L7(Application) 계층에서 작동하는 <a href=\"https://aws.amazon.com/ko/blogs/korea/new-aws-application-load-balancer/\" target=\"_blank\" rel=\"nofollow\">Application Load Balancer(ALB)</a>를 공개하였다.</p>\n<p>기존에 사용되던 로드밸런서인 Elastic Load Balancer(ELB)는 L4(Network) 계층에서 동작하기 때문에 HTTP나 HTTPS와 같은 Application Layer에서 사용되는 프로토콜을 인지하지도 못하고 이에 따라서 유연하게 처리하지도 못했지만 ALB는 Application 계층에서 작동하기 때문에 직접 HTTP 헤더를 까보고 이에 따른 유연한 부하 분산이 가능한 것이 장점이다.</p>\n<p>예를 들면 동일한 호스트로 요청을 보내더라도 <code class=\"language-text\">/a</code> 경로로 요청을 보내면 a 서버로 보내고 <code class=\"language-text\">/b</code> 경로로 요청을 보내면 b 서버로 보내는 등의 유연한 라우팅이 가능하게 된다는 것이다.</p>\n<p>하지만 무엇보다 좋은 점은 위에서 설명했듯이 <code class=\"language-text\">HTTP/2</code> 프로토콜과 <code class=\"language-text\">WebSocket</code>을 자체적으로 지원한다는 것이다. 만약 기존에 ELB, 즉 Classic Load Balancer를 사용하고 있던 환경에서 HTTP/2 프로토콜을 사용하고 싶다면 직접 세팅하거나 ALB로 마이그레이션 해야한다.</p>\n<p>하지만 로드 밸런서를 마이그레이션해도 기존 ELB에 연결되어있던 인스턴스들과 자동으로 연결해주지는 않기 때문에 Elastic Beanstalk을 사용하고 있다면 그냥 환경을 다시 만드는 게 정신건강에 이롭다.<small><del>(처음에 쉽게 가보려다가 안되서 실망한 1인)</del></small></p>\n<h3 id=\"설정하기\" style=\"position:relative;\">설정하기<a href=\"#%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"설정하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>먼저 Elastic Beanstalk 환경에 접속하여 새로운 환경을 생성하자.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2c4c368507f2816bfd6aea8f30a79582/ad12c/eb1.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 80.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACdUlEQVR42p1UyVLbQBDVP5HAjQSuWciv5pLKJbkEMCaEhNiSLVu2FmvxItuSF8laX7rHyAUGLumqV7Oo5/Xrnh5JR6dnODr9hMOTM7x++xEHx+/x6s0HMa/AewfH74TfPg5Ptj58nteS0mpBlhW02ir6ugFVVXFdr6N2cU7jFeq1Gv78vkWn3YbaJt9GA4oso0mjTKPW60E3THQ1TfBIWrcrSHq6DrunYVL/AeP6ElrtAr2rS/SvahjLDfhKE9bN9Xavdk77hO9fMVBkON4QpmGg0+lAKssSAgCyMEDq2GArww4QtICwLeZFsEU5a6BIV1v/yQjFdIycVkWeCR4pjmNsNhskWY546iNu/kLkakj1BhL9L1JDRmYqyKwWcltFaVMAz0Lpj5CoTcSTCVIiT7ICm7SAZJDUCnpfx9DWcNf5DJtKYGk9GJSGQ7W16dtyOkUexShJBJIIi3mArruAPl7DnEToeqttyjuj6TpZ4M76BtfzYNk2DMuCOxzCdh04rgt/Otu5Z3mOXcnuIWHP1psQt/0vsJlMqO7DcRzoep/WOlarFdI0Eb75PeFDe0xI36LNCpr3E77vYzQawSOlPOcATOySyvF4vFWYZft6HtwygSMyiqLAfD5HGIYCPN9Xwus0TQVpdY7xLCE7WVS76rJY1ZQuZLlcPiJm34cBnqTMyhhMqNMtm6YpiHnU6CXwXpIkO/8gCETAwWAgSsKQnkuD+3I2m4lU+dCEeo0VMqIoEkoZvOa6MhEH5vmTW67Sf2nNNqQ2Eh1Aivm5teh/wBkoCr1ljviSVUT7hJVxJlwOJueRA0nr9Rr/Y1waJuDWqlqMCf8BnQCWST/aBEoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Elastic Beanstalk 환경 생성\" title=\"\" src=\"/static/2c4c368507f2816bfd6aea8f30a79582/6af66/eb1.png\" srcset=\"/static/2c4c368507f2816bfd6aea8f30a79582/69538/eb1.png 160w,\n/static/2c4c368507f2816bfd6aea8f30a79582/72799/eb1.png 320w,\n/static/2c4c368507f2816bfd6aea8f30a79582/6af66/eb1.png 640w,\n/static/2c4c368507f2816bfd6aea8f30a79582/ad12c/eb1.png 856w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이후 <code class=\"language-text\">Web server environment</code>를 선택하면 환경 이름이나 사용할 언어등 간단한 세팅을 할 수 있는 화면으로 이동한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 518px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ce0af85cf4b6cc034de1f43536f7c668/6b9fd/eb2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 89.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACJElEQVR42p1Uaa+bQAx8//9PtVK/tVLvg1cSBXISwrEXEM6pbUJe2qRN1EijZWF37PHYeXLOYrfbwRiNumngnIOzFlobFIWjVdFa4NHf07GqkCQHWOvQti3SNMF+v0cURbSOSNNUAjFxWZYvz0VJ9yy6rnsh/DOCLWpkykGZArl2yGlVtpR3mS6gbUXfaK9H0puEwzCcX6SqRLjaIlhuEIRr+LMFtlFCxG4McEKUGFxcu5Xh+PXZX+DV6zd4++4DPn35hvcfP+Prdw/ezxm8Z1/WH54Pf768XcPLTd8PsK5EsJhLDYe+Fzlt29DaUka9gFNrmu5ehqcaEuEyDBEEgSBJMzHKkhFj0DFIVbePSVbaYjabwfdJnudJpkpppFkmbjNaIjzeJxwp+eDhEEtrGGOg8hyaCLldJnT/IgyCEJv1RjIpy4qkVdKHaZIgo6yyPJMMu64XuZPkvxJOh3opOKQ2q9VyNOXUUj2BSS7xkGR2uTo2WK9XIpcD8fQw/ouwrmsibGm2t+RuenZVsjxJncCBp2BN056H46ptNE1EGAaYz+fIyRDnCqklZ8x1ZDImdzTHcXxAnqXYx7E4f5PQ2EL6j9smoH40xpLrdFGp37IUyfcmhbPmgzG5zEM/GcZyhivJrZjFzTZcUF/V0NCkRPsDDmmO8lijrGoJUtOoXaKqu3P3DueEhhuSqVZZlssfrCKZPBnjXsuezVL0PO0ZXGsGN/0vveJ2udRNtk4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Elastic Beanstalk Platform 설정\" title=\"\" src=\"/static/ce0af85cf4b6cc034de1f43536f7c668/6b9fd/eb2.png\" srcset=\"/static/ce0af85cf4b6cc034de1f43536f7c668/69538/eb2.png 160w,\n/static/ce0af85cf4b6cc034de1f43536f7c668/72799/eb2.png 320w,\n/static/ce0af85cf4b6cc034de1f43536f7c668/6b9fd/eb2.png 518w\" sizes=\"(max-width: 518px) 100vw, 518px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>Elastic Beanstalk에서는 다양한 언어를 제공해주고 있으니 입맛대로 골라담아보자. 이렇게 기본적인 세팅을 하고서 하단의 <code class=\"language-text\">Configure more options</code>를 클릭하면 좀 더 디테일한 설정을 할 수 있는 화면으로 이동할 수 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/c58be6012821f6a5d25c879335789b05/302a4/eb3.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 30.624999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAyklEQVR42q2QzWrCUBSEfcTiVoqvpBRKUFz4DgUXre6Emmhs1IRKSDGEQDUgUfAnN73386ZZCbUrBz7mrIY5U+HOqtw9UEpJgdIUUrlAHQ+QnUrOBUd9n+GkXWR/Bimlrhtm4ocozdlFMcnSxTPf+bRG+NMxvj3GNUesZxaN7pDqs8ejMadmLKi3XB6aDgNvex0ockmcCvbfG9JgyZcOCiYmoTP9xbctkoXNy+sHT28hncEKo7+irb3RC5hH+xsbFtWV5MZfJf9seAGDucj3Hwwz8wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Configure more option\" title=\"\" src=\"/static/c58be6012821f6a5d25c879335789b05/6af66/eb3.png\" srcset=\"/static/c58be6012821f6a5d25c879335789b05/69538/eb3.png 160w,\n/static/c58be6012821f6a5d25c879335789b05/72799/eb3.png 320w,\n/static/c58be6012821f6a5d25c879335789b05/6af66/eb3.png 640w,\n/static/c58be6012821f6a5d25c879335789b05/d9199/eb3.png 960w,\n/static/c58be6012821f6a5d25c879335789b05/302a4/eb3.png 1080w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>만약 손이 미끄러져서 <code class=\"language-text\">Create environment</code>를 클릭하면 환경이 생성되는 동안 10분 정도는 그냥 날리게 되므로 눈 크게 뜨고 클릭하도록 하자.</p>\n<p>제대로 클릭했다면 디테일 설정화면으로 이동하게 되는데 상단의 <code class=\"language-text\">Configuration presets</code>를 확인해보면 아마 기본 값으로 <code class=\"language-text\">Low cost</code>가 선택되어 있을 것이다. 이 옵션에서는 로드 밸런서를 사용할 수 없으므로 우리는 <code class=\"language-text\">Custom configuration</code>을 선택해야한다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b3ef6724a1eb0a47401fbd6ffdac9c27/27b8e/eb4.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 46.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABO0lEQVR42o1Ry3KCQBDk//8rFzl40VJEQAXR+AJU3o+O3amlTA6pbFUzOzs9vUOv1fc9fN/HarXCfD7HbDZDEATwPA+O44xg7rqu6rZtKx4OByyXS0WzrGEYcDweJbrb7TCdTiW82WwQhqFECO4nk4mEKWLOeBn7R0F+rtcrLpeLkKap4vl8xul0QpIk2pPDfZZlAs8YTZ1cTirB+/2O5/OJPM8VSTRnxO1200WPx2MEc8M3XPZJkD6+k4miKEYibem6DlVVoSxL1UwkzDDkSbBpGnmzWCz0OAT9pD/b7VZi2UucnsVxLH/p+X6/V04/oygSz8K/1oCqLBC+mugXm3kRJ1P1NdmPRzGHv9H3g8TcT+DDKRCHPjw/GKfiX63Xa1lhNKy/5/peeQ0keY+ubVDXNdq2Hf1k/j7hF1cmq2XFWr3rAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Configuration presets\" title=\"\" src=\"/static/b3ef6724a1eb0a47401fbd6ffdac9c27/6af66/eb4.png\" srcset=\"/static/b3ef6724a1eb0a47401fbd6ffdac9c27/69538/eb4.png 160w,\n/static/b3ef6724a1eb0a47401fbd6ffdac9c27/72799/eb4.png 320w,\n/static/b3ef6724a1eb0a47401fbd6ffdac9c27/6af66/eb4.png 640w,\n/static/b3ef6724a1eb0a47401fbd6ffdac9c27/27b8e/eb4.png 836w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p><code class=\"language-text\">Custom configuration</code> 옵션을 선택하면 하단의 Load balancer 카드에 <code class=\"language-text\">Modify</code> 버튼이 활성화 되었을 것이다. 해당 버튼을 클릭하면 이제 드디어 로드 밸런서를 선택할 수 있는 화면이 나타난다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/1a3b213065692e5e6e9300b99e424245/d2782/eb5.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABrElEQVR42o1Ue0/CMBzs9/9c/mmMxoARwQljbOzhXt37cfaqxQrE0OTyW9txvbv+hgjDENvtFp7nYb/fw3Vd+L6PcRwxz/MJ18a1PZE3PeKyUWiRyBZhXiNtBsgBqBSydkZSjfqAruvQ9z3attXzc+JpmiD8VOJh+Ybntw88vb7j8WWDjRfCCRI4foxtLBFWilxK7YQO6IbOiqJAWZYnlayCipbvLnZhBu+zxEEdsE9KuHGu1yLZKZUT5ulXhalUyWorFaV6uVAo+1nblMOMopv1nMjVXl6rPH+IbNJzy5qQuaRpijzPEccxsiz7Y4FE0zTi1iEYsM4kipAkiSZnNiRmPua2byYcBnWjKnBWo8rkY8gmy+55u1y0DduAtom6rnVLXOu3mxXS2uFwQKQss6FZm6a5AA8j7Pn5O3QpmBd7iiAZL+Z4PCIIAl3NM/d5IOd85hp/S2JGJqtauxTMibbJboNrdhwmU7PPXEnMz5UOX18WSkz0rdBxHH26Ubnb7bBarfQa63q9PimzodfoQOHufgHPDyB4EpXYwRt1//0x2GNUX9G9I5FVPb4A9Co8/w8ketwAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"로드 밸런서 선택화면\" title=\"\" src=\"/static/1a3b213065692e5e6e9300b99e424245/6af66/eb5.png\" srcset=\"/static/1a3b213065692e5e6e9300b99e424245/69538/eb5.png 160w,\n/static/1a3b213065692e5e6e9300b99e424245/72799/eb5.png 320w,\n/static/1a3b213065692e5e6e9300b99e424245/6af66/eb5.png 640w,\n/static/1a3b213065692e5e6e9300b99e424245/d9199/eb5.png 960w,\n/static/1a3b213065692e5e6e9300b99e424245/21b4d/eb5.png 1280w,\n/static/1a3b213065692e5e6e9300b99e424245/d2782/eb5.png 1864w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>3개 다 맛있어보이지만 한번에 하나만 먹을 수 있으므로 욕심 부리지말고 Application Load Balancer를 선택하자. 그리고 밑으로 스크롤을 조금만 내려보면 로드 밸런서 설정 메뉴들이 보인다.</p>\n<p>우리는 이 중 <code class=\"language-text\">Listener</code>를 생성해주어야한다. ALB의 리스너는 구성한 프로토콜이나 포트를 사용한 요청을 확인하는 프로세스라고 보면 된다. 기본 설정에는 HTTP 프로토콜을 사용하여 80포트로 들어오는 요청에 대한 리스너만 있기 때문에 우리는 HTTPS 프로토콜을 사용하여 443포트로 들어오는 요청에 대한 리스너를 만들어주면 된다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2447dd384b41d2fe99a736d917073cae/3a1b1/eb6.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.74999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABqklEQVR42p1Sy07CUBDlV12TmJC4UNC9gARYiFIgwY1LkMcvuFJCXLlQEzUQEyhBWqCE9vZ4Z2RK8REfNzmZmfs4c2bmRqLRKLLZLFKpFNLpNJLJZGAzmQxyuRwjn89/CzovFAqIx+OINBoN0JrNZlgsFpjP53Ach2PP8/CbpZRi2+12EWk2mxzQY9d1Yds2k5FPkP2vYvGXyyVzdDodTdhqBYSkjBROp1P2JfOfFDZCComI1I3HY4xGI1iWxTHty5lA4nBiJrxY9ZAORLpawfsA5fucWEBEgoCwVqtxmf1+H71eD44ejD94gXq8g//8sMbTPTzb0qSb5fqrJAFha9XDV10mwaYS6mdQhztQuQOo7L5GAupoF87tDZbvLD9Pmb6MaZrcG1c/oIcb0HsL3RJSRARiCTTpgLDdbnMg4yc70UrNwYAxMocwh0P2J5MJD4JaFB6QZdlwddlX1521QiKjbNQP+eDyyQV0JzwUGcyGwlboH/5nTXU/xjMX510HxfolIrFYDNVqFcViEYZhoFQqsRVfUC6XUalUPuHUKOP4xMDWXh5b2wm8ARletbTJSXtIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"로드 밸런서 리스너 생성화면\" title=\"\" src=\"/static/2447dd384b41d2fe99a736d917073cae/6af66/eb6.png\" srcset=\"/static/2447dd384b41d2fe99a736d917073cae/69538/eb6.png 160w,\n/static/2447dd384b41d2fe99a736d917073cae/72799/eb6.png 320w,\n/static/2447dd384b41d2fe99a736d917073cae/6af66/eb6.png 640w,\n/static/2447dd384b41d2fe99a736d917073cae/d9199/eb6.png 960w,\n/static/2447dd384b41d2fe99a736d917073cae/21b4d/eb6.png 1280w,\n/static/2447dd384b41d2fe99a736d917073cae/3a1b1/eb6.png 1686w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>리스너를 생성했다면 하단의 <code class=\"language-text\">Save</code> 버튼을 눌러 로드 밸런서 설정을 저장하고 나머지 설정도 입맛대로 설정한 후 <code class=\"language-text\">Create environment</code>를 클릭하면 드디어 환경이 올라가기 시작한다. 참고로 좀 오래 걸린다.</p>\n<h3 id=\"서버에-별도-설정을-안했는데\" style=\"position:relative;\">서버에 별도 설정을 안했는데?<a href=\"#%EC%84%9C%EB%B2%84%EC%97%90-%EB%B3%84%EB%8F%84-%EC%84%A4%EC%A0%95%EC%9D%84-%EC%95%88%ED%96%88%EB%8A%94%EB%8D%B0\" aria-label=\"서버에 별도 설정을 안했는데 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>따로 안해도 된다. ALB에 HTTPS 리스너를 가지고 있다면 이 리스너가 알아서 해준다. 만약 브라우저가 HTTP/2를 지원하는 브라우저라면 리스너도 HTTP/2로 응답할 것이고 만약 HTTP/1.1만 지원하는 브라우저<small><del>인터넷익스플로러</del></small>라면 리스너도 HTTP/1.1 프로토콜로 응답할 것이다.</p>\n<p>그리고 HTTPS 리스너가 HTTP/2 요청을 받더라도 로드 밸런서에 연결된 인스턴스들과는 각각의 HTTP/1.1 프로토콜로 통신하기 때문에 서버에서는 그냥 평소대로 HTTP/1.1에 대한 처리만 하면 된다.</p>\n<p>자세한 내용은 <a href=\"https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html#http-connections\" target=\"_blank\" rel=\"nofollow\">Elastic Load Balancing 사용 설명서의 HTTP Connections</a>을 읽어보도록 하자.</p>\n<h2 id=\"http2-잘-적용-됐니\" style=\"position:relative;\">HTTP/2, 잘 적용 됐니?<a href=\"#http2-%EC%9E%98-%EC%A0%81%EC%9A%A9-%EB%90%90%EB%8B%88\" aria-label=\"http2 잘 적용 됐니 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>환경을 생성했다면 이제 끝이다. 가장 간단하게 테스트해볼 수 있는 방법은 역시 <code class=\"language-text\">curl</code>을 사용하는 것이다. 여러분이 생성한 환경에 요청을 해봐도 되고 아니면 그냥 아무데나 찔러보자. 생각보다 많은 서비스들이 HTTP/2를 사용하고 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">curl</span> <span class=\"token parameter variable\">--http2</span> <span class=\"token parameter variable\">-I</span> https://www.naver.com/\n\nHTTP/2 <span class=\"token number\">200</span>\nserver: NWS\ndate: Thu, <span class=\"token number\">13</span> Jun <span class=\"token number\">2019</span> <span class=\"token number\">14</span>:59:09 GMT\ncontent-type: text/html<span class=\"token punctuation\">;</span> <span class=\"token assign-left variable\">charset</span><span class=\"token operator\">=</span>UTF-8\ncache-control: no-cache, no-store, must-revalidate\npragma: no-cache</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>크롬 브라우저를 사용한다면 <a href=\"https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin?utm_source=chrome-ntp-icon\" target=\"_blank\" rel=\"nofollow\">HTTP/2 and SPDY indicator 크롬익스텐션</a>을 설치하는 방법도 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 98px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ea713cc7adcbac869f0ddc1c27f52939/a4837/http2-plugin.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 96.93877551020407%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB2klEQVR42q2TsW7bMBCGOfUVOmTs1FcoMsSGPbW2swbJ2AxFMgdeMmVwAqSFDXSIA8Qo4MKWbImSKEs2EmTOY/25o3I2rSpDAQ8fRIrkf/8dj6rZbGKXqEajgV2idu5w54K1Wg1V1Ot1izuuonxOdTodlGm32/+FnPnWakHFcQwmiiJorddszyOEoSZCSxAEa+yciGn/U5ZDLRYLZFmGPM8hYyFNUxiT0v+E1mMkiSESy9pIHCFPF/jre/hxfQXFTpj5fI7BYIDxeGzn4kbrANNpSGuGHPmYzWZ274zwfB8RZTCl7+fTY3z4ug/Fh1hgOByi1+uh3++/CWkS0FguA1xcPOLg4IXcBltpTz0PS3J3OfiJvZNDnP2+LRwaYzAajdDtdq1LTqVIzWC1SnB3t8LNzRONjS0Bl4LXgyBETmX6403w8aiFT6dHUO5FTCYTG3nzr3ATx5pEikwkmHmrJbOiy/j1cI8v59+hfH9TFxaRlORwGam52wkhBc7I+XO+3FyKiLmiLm6ruC3D+zlQIayhuH6pMbaOjKThjrfaxDFQ7lceKznsUvSfwXtNX4UEUlUpbr0C+nJ9be9RrQWey75/BN0oblrvUeVQzCh3o4hJquUSMPw83XmZV3Oj5CsAxn8kAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"HTTP/2 and SPDY indicator\" title=\"\" src=\"/static/ea713cc7adcbac869f0ddc1c27f52939/a4837/http2-plugin.png\" srcset=\"/static/ea713cc7adcbac869f0ddc1c27f52939/a4837/http2-plugin.png 98w\" sizes=\"(max-width: 98px) 100vw, 98px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>이런 귀여운 아이콘이 HTTP/2나 SPDY 프로토콜 사용 여부를 알려줄 것이다. 근데 SPDY는 아직까지 구글 말고는 쓰는 곳을 본 적이 없는듯…?</p>\n<p>또는 크롬 브라우저의 개발자 도구 <code class=\"language-text\">Network</code> 탭에서 테이블 헤드에 마우스 우클릭을 하면 <code class=\"language-text\">Protocol</code> 컬럼을 활성화 시킬 수도 있다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 362px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/b4034d3ba3d49737892b8eeb0dc3101d/10600/network.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFQ0lEQVR42nWV2U8bVxTG5/+oEohtzGKMWQwYYkiIjfeNkiZNorYPbV/aNFUWKgFJCgYHbLPEhtiAN8A7pmmz0EppCk1e+md9/c4EpEhVHz7dc2fm/uY759w7o3zi/wrnnFfRZJtEk9mK1r5RaHotMHQYoW/RQavToaW1FbqWFugYi1r+JxYp50a9aBq8DE33AJrbjWhvM0Fn7IRB3wq9Vgut9r+LRFre+xio0WhUKYZOIzrb22Fs06OjowOmdgOMpi6YDB3qg61018b7rW1t6lxieU6v16uws7Grqws9PT1QjD3d6GRg7O2FUUaqgzcHhoYQmZ7B9J0fMfX9bUz9cAfzs7OIL0WxEo0jPBfGo0ePMTc3jwdTU3B6fQhevQbFRbqHcsqoa4GXo+PCBdwc7Mffu2nsRx6jEPkZh5tr+OdFDe9/reCEOmb8J3X8uoFGrQB7dzeGJWWBuakAJXAbUwhqmuExDeDGVAnfzdfx9WwJ9+NH+PbJ7/hi/jW+XHiNW9SN8CvcXPwDn87WMWLswYhOC0WcuVgbHyWxnUAPgeNdFljvvsWNxXf4Jv4etyInsP50AvPdY/TfO0Yf1XvvL/TdfwfT7ZewGHpxUYAegrwids3NMUC5m5txzdyHk9wW8nOPsT71AJuPZvG2vIs31T0cVffxorKLXzj/rV5Ens85TCZYJeVJuhJNUD6681MB3rje3483mSzyCwvYnp9HPhZFY3sb5a0tlDIZ1Pb3UdrbQ7VcRmpnB+Ns5iXZhy46c1J2QvyUQ+KmJgT6+nCUTiNLWCYcRm55GRscVzlPRKMqsKwCS0jzRZe4MyxspuKQmlHuU3eiK4TeMptRj8eQjyxii1vjaHcXR8UiXpRKOOSoAilxmD51OCIOx6VuBATpLiQuOffT4efcl9XVVWQXF/F0Zga5WAyvCHhONagaoQKsnKYsNRwVh58JkPXzU0EZZdvwxjXW8GU2i52lJaw+fIgka/mcKYq7A6pKlT5yOMaUh9lMxUJI/6kGKDOPWj+BNgIbLH6CDjdZv9XwApbn5rDHxQeVCiolOhQw4zQbZb9ohbXPDEVDR9pTqTGB55l6/8AA0mtriBKSSSbRkMV0WGMNa3RV4ViSa9UqUs+eweXzw+0PQWnjoRe1n4mHXz5VFgJT62tYZ0fX6bBBSJ2qlcpqmlK7UrFEhwSmUnC63Bh3uAikK1ErIaJ2xno6tDDlcqGARCyOKOuX4aLnBwc4rNVQk5TPgNUPQLvDiSs2B0/K6T6cJERiOTET58/hOk+KpLexsoqVJ0uIRZ4gwa4n19exV9hFjaAzh+mdDMbZ5RE5KV5vAD5fAH5/EC6XBx6Pj/MgQqEJ1JleiYtFe/kCdnN55LM5AgvYZz2L7HKRdUyyxk46tNvFIUG2cdrlxO5007pLnfuDIRwwvbX4CmLL/AYy9Q0ufEqHEXY+kUigwtSz3FrLrLGHTZH1itvrh9PtxeUxG0cf5AUuugxNTKJeqyPxNIFoNIYYgblcDvV6HWU6L+4XVXcZbq0oG+fyeFUjyqDFgkHLEAYGLRgavgjL0DDM7LB93IEagVmmKAsbjUNVB2yMXK/RvTSkyDqLWwE6WDJFYAaDASZTN4xG/ktYXIOhE1brCLa3dxBeWERyYxP7dJRKpbHDL9AWrwskmdxAPB7HzPQ0s/PAQSluNkRSPpOLaXu5QW10OHbFzjgIKYuk08kf2uilMQzzVFzgMZOflvyktFqNmp30QRGbKoh1czKW0eH8MApYrgVZT4GK5CXWkVH1TyeHQA5FC8FjNjt8gRD+BcIaJTG18gx0AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"네트워크 탭의 Protocol 컬럼 활성화\" title=\"\" src=\"/static/b4034d3ba3d49737892b8eeb0dc3101d/10600/network.png\" srcset=\"/static/b4034d3ba3d49737892b8eeb0dc3101d/69538/network.png 160w,\n/static/b4034d3ba3d49737892b8eeb0dc3101d/72799/network.png 320w,\n/static/b4034d3ba3d49737892b8eeb0dc3101d/10600/network.png 362w\" sizes=\"(max-width: 362px) 100vw, 362px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>그러면 네트워크 탭에서 HTTP/2 프로토콜로 통신하여 받아온 리소스는 <code class=\"language-text\">h2</code>라고 표시가 된다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 165px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/64a2efd14eb3ccf3c692e6d32ed99f81/04c57/http2-check.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 27.500000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDElEQVR42oWRa0vDMBiF808a2ia9pde13brZ2d2cojKGIvgLREFhgozJmOi++K+PSWAw3NAPDyFv3pyc84Z4ngff9zUOd8A5/xfXdfXKGIdpmggCofeO44CMJlMs159YvL2j7jeghiEbGWzbPkDVKaWoeid4Xa7x+LzAw9MLbu7uoXS6vRokTTP0mwEGwzFEGOoXj4ntsCwLgRDoVF1Mpue4ms0RRTHyopApA5AwjNDKC2RZS1oPtG0V6S+EFEzSVAtTaoBL54zZ8i4Hubi8xmb7jdXmC6PxGZh0oeapZvsbVVfn9WmD1ccWs/mtnt3uD1QPSZIEZdlGu1MhlJGVg2Ni+6gkeVEijpOD/h++CLzRmVvtPAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"네트워크 탭의 Protocol 컬럼 모습\" title=\"\" src=\"/static/64a2efd14eb3ccf3c692e6d32ed99f81/04c57/http2-check.png\" srcset=\"/static/64a2efd14eb3ccf3c692e6d32ed99f81/69538/http2-check.png 160w,\n/static/64a2efd14eb3ccf3c692e6d32ed99f81/04c57/http2-check.png 165w\" sizes=\"(max-width: 165px) 100vw, 165px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2 id=\"waterfall로-비교해보자\" style=\"position:relative;\">Waterfall로 비교해보자<a href=\"#waterfall%EB%A1%9C-%EB%B9%84%EA%B5%90%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"waterfall로 비교해보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>왼쪽이 <code class=\"language-text\">HTTP/1.1</code>, 오른쪽이 <code class=\"language-text\">HTTP/2</code>이다. HTTP/2 쪽의 붉은 라인은 이미지 요청 에러인데, 스테이징 환경에서 리소스 출처 문제로 인해 발생하는 403에러이기 때문에 무시해도된다.</p>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/10f6fcafbe60f0c9d6f5291aabf79d51/9cab2/result.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 183.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAlCAYAAABCr8kFAAAACXBIWXMAABYlAAAWJQFJUiTwAAAGhklEQVR42oWWy3Pb1hXG/ad305lsmukuXbgzTTtdtEnaNI2sie1YsSXVlmSRlPgm8SIJEiAA4o0LgHp8/e4FJUtyZrLAXIo8+t3z+M45eGaaJnTdgGla6Pf7eP3za5ycnMAwDH6vQ9M0zGYzLBYL9Z1lzZTdwcEBzs7OIP9ffm8YujqfxUmCpb3AxvcQBhGcpQPP9RCHMaJNhE0QI8syJEkK254/svPXPu0i/h0i3CS0SfBMiAqTaQ9RtEJdXaGqKlRl85SiRBLXuL6+5ucKI62LKHawraVdqWzLskSRC6RJjdvbGwksMZn0CXT4Y4U8z2lQKFhRFLy1aoD8bTztIwwdgmr1mxBCPVlWIE0r3NxcN0BNHyFOPZTSUBTKWN38CFhiqtEu9pRnCsjvBO2zLFd29x5q0yGiYIk8SpDFMfJCGkpvBQENUP6tTQkMA8KvUcQZnxwiKwmsCNx+Aup6D4F2jsQaIt/YvDmiFxEhGxpmBN4QUmCqn8IdvUZsHiGxT5G758iTIYET2vkEQgIz6OYBQ36H7fYMZc2n/IC6PuF5zNxoBEIBR1obYWygLleMYglROUzRisAFgRGBtxIomJsuwsRiZUOG6TM/MqwNT1/Jpakyi2dMMOjMEPmyGDVEUavzs5DH4xbsWRdF5hHCWwuXwLX6LG+WIcuLNWuCk3cdjM4t/i52lf6sKEIBZ0YPebqmh656hJCfHRalATYeDjG+HCP0EyWvh7K5B5YiZ7J/gb16wxBaNDhXT1W16MUpDQ0Cb++Bc7ZjXW9pW/w6sCgEjNkY2miEwI2Y5Iy3ZyoUecZxeZ9DYzFFr9PHpDNnUQijHgU7JqPMkrT+BNStMSyKO3Q3Sth34chTAdkBQl6s9dA97eDwxQUWfRN1tIHwfcpnjTTImipLoMZQ/MDGyloryK8CKXJtconeWQf/e3mJtW6j3gQQnofccZH6KW5x21R5qg+RFB60jonxxxkcM1CJl1W8C1kUTcjddhfvf7qEbXkMVajQc/Eg5KaXh4jzNTw7gDW0kaXZYw93QN0aodfq4ni/g/5HjUMkV0+WZE96mSFHKbVXV1joMxYnYCWrByFTh6ykcXaI3uEHvH/dZdjsmtM26l4X+XkbqblkwNj1sslezJgPcaV61xo7yNn0opQdUH/ykGrotnsqh6cHXcQcqlVF2aQPhS2rbHaQFjql4dMzD+6cE9xboqrXHLBx4yGLYow66NGrY+bw/C09s1eoXF6+WCL1kk9F0YxLJPmMQuaEYf/maQTfcehx0PSyAjLkQQv9k5YCdo/6qG0b1XKJwpojpYYbYCGBYwJ9ArbNLOTg3PDGPBNNyBJIsPXyB/R/eoOjN0N0/3uE8pt/od57ger7/yBvD3Cjclg0VU6yNaS3TZdwR3CAxmGiRrsCcvha//gag+/3cPR2guG3r1D/4UuUX/0J5Zd/RPbmeAfcVTnhpGmmNEXNSZKEKbcegVlTFLmINCWbHnV4gdbhAJa2gmyMR70sPVTCzh8ARVO5YB0pwd5VWTMZ6vkl3rPK7191ML0wOUPFEx0q4OAeWBT5/ZLa+NH9krqTjRT2h1eXLEwLk66Fels9kY0KeURhy4Ha5PAubGfBFtwItR7vdXjexRE75d3eR+iDOaVVMs/55yHHT4Alx5Lvhnxy3NCwAXIFXHQxauvQR3OVY7lSH0/soilKnD0BlvJtIOOrSEEPb9T4kivA0saw9TXzG6scy3Cznbx+E5hEKQK/2HnIjpoNORP7sC6H8FZrrPmk3Dl5HhMofiNkCYwJ9PLGQ64KbXGMqDjBYn6G5fwt1st32IQfkdcXbF0H5DXAiTb4DHg3vnwCpbBLjjT9aB/Fhx+RHbxE++AYHfa1ubcP77tvkAxGu2kjk80qx4mrxNsAM7WE5Om7fHPgaC+5/fS950i//T3E119gfPgKo8FbhPvPUf3td0hPf2k6pVkBo10vy5cl7ltKqZQLiFpMooJAhsypo7/4J7J//wX5X59j/MM+uhdjBC9+RP33PyM7azXA7faaiV8gXg9RbPiKwd2S+XMUoYuE54Y7o6kyi6exo0IPGyfArKdhtfAQOCH/N0IalU1R5BJPU95uDrBwDNiujpkzhb3m6/Cyj4W3YLJvVQqmZlvNze01h3HtIFgZcI0ZXNPgDvKbHMq2utpeMUTu2bpQTynPLQuzLVBfNa1X8611udTgLnv02uS81HjKdWHAcyhyP6C8bvF/+fnTvqnZQYkAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"result\" title=\"\" src=\"/static/10f6fcafbe60f0c9d6f5291aabf79d51/6af66/result.png\" srcset=\"/static/10f6fcafbe60f0c9d6f5291aabf79d51/69538/result.png 160w,\n/static/10f6fcafbe60f0c9d6f5291aabf79d51/72799/result.png 320w,\n/static/10f6fcafbe60f0c9d6f5291aabf79d51/6af66/result.png 640w,\n/static/10f6fcafbe60f0c9d6f5291aabf79d51/9cab2/result.png 864w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<p>HTTP/2 쪽의 Waterfall은 상당히 많은 수의 요청이 동시에 처리되고 있는 것을 확인할 수 있다. HTTP/2의 이런 특징을 이용하면 기존에 하나로 번들링하고 있던 JavaScript 파일을 여러 개로 Chunking하여 파일 용량을 줄이거나, 기존에 스프라이트로 사용하던 이미지도 개별 요청을 통해 동시에 받아옴으로써 로딩 속도를 조금 더 단축시킬 수도 있다.</p>\n<p>이상으로 AWS와 함께 간단하게 HTTP/2 적용하기 포스팅을 마친다.</p>","fields":{"slug":"20190613-http2-with-aws","path":"/2019/06/13/http2-with-aws/","lang":"ko"},"frontmatter":{"title":"AWS와 함께 간단하게 HTTP/2 적용하기","subTitle":"HTTP/2의 장점과 AWS에서 쉽게 활성화하는 법","date":"Jun 13, 2019","categories":["프로그래밍","네트워크"],"tags":["Amazon Web Service","AWS","HTTP","HTTP/2","HTTP2","Network","네트워크","ALB","Application Load Balancer","ELB","Elastic Load Balancer","Cloud Front","튜토리얼"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/be9e83d603d0e671bc285680c3aa165f/d803c/aws.png","srcSet":"/static/be9e83d603d0e671bc285680c3aa165f/d803c/aws.png 320w,\n/static/be9e83d603d0e671bc285680c3aa165f/2a1fd/aws.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/be9e83d603d0e671bc285680c3aa165f/fc5c5/aws.webp 320w,\n/static/be9e83d603d0e671bc285680c3aa165f/e9225/aws.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/be9e83d603d0e671bc285680c3aa165f/01fb2/aws.png","srcSet":"/static/be9e83d603d0e671bc285680c3aa165f/01fb2/aws.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/be9e83d603d0e671bc285680c3aa165f/b384d/aws.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"HTTP","lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}