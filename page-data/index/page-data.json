{"componentChunkName":"component---src-templates-home-page-template-index-tsx","path":"/","result":{"data":{"books":{"edges":[{"node":{"id":"d9d7c255-4dab-5272-9976-ee23d22e5bd1","fields":{"slug":"developer-in-ai-era","path":"/books/developer-in-ai-era/"},"frontmatter":{"title":"AI 시대의 개발자","subTitle":"AI가 코드를 짜기 시작한 시대의 개발자","description":"AI가 개발 업무에 들어오면서 개발자의 역할이 어떻게 바뀌고 있는지, 그 안에서 어떻게 생각해야 하는지 살펴봅니다.","author":"Evan Moon","date":"Feb 10, 2026","posts":["/2024/06/23/perspective-on-ai/","/2026/01/30/developer-intuition-readable-code-and-neuroscience/","/2026/02/10/developer-in-ai-era/"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/f3e7e95695f94e8513c768994ddcd10a/fc5c5/thumbnail.webp","srcSet":"/static/f3e7e95695f94e8513c768994ddcd10a/fc5c5/thumbnail.webp 320w,\n/static/f3e7e95695f94e8513c768994ddcd10a/e9225/thumbnail.webp 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/f3e7e95695f94e8513c768994ddcd10a/8efde/thumbnail.webp","srcSet":"/static/f3e7e95695f94e8513c768994ddcd10a/8efde/thumbnail.webp 750w","sizes":"100vw"},"sources":[]},"width":1,"height":0.572}}}}}},{"node":{"id":"dcabc7b3-aa62-5a49-92d4-f1c6070abe60","fields":{"slug":"math-and-programming","path":"/books/math-and-programming/"},"frontmatter":{"title":"수학과 프로그래밍","subTitle":"프로그래밍 속 수학적 개념들","description":"난수, 신호 처리, 타입 이론, 모나드 같은 프로그래밍에 등장하는 수학적 개념들을 코드와 함께 살펴봅니다.","author":"Evan Moon","date":"Feb 07, 2026","posts":["/2019/07/14/what-is-random/","/2019/07/17/programmer-with-math/","/2019/08/11/average-filter/","/2019/10/30/make-simple-with-math/","/2026/01/25/types-as-proofs-typescript-hidden-math/","/2026/02/07/monads-in-typescript/"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/a801f480d325ee0f4ce6bccd0622d392/3a812/thumbnail.jpg","srcSet":"/static/a801f480d325ee0f4ce6bccd0622d392/3a812/thumbnail.jpg 320w,\n/static/a801f480d325ee0f4ce6bccd0622d392/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/a801f480d325ee0f4ce6bccd0622d392/fc5c5/thumbnail.webp 320w,\n/static/a801f480d325ee0f4ce6bccd0622d392/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/a801f480d325ee0f4ce6bccd0622d392/b5857/thumbnail.jpg","srcSet":"/static/a801f480d325ee0f4ce6bccd0622d392/b5857/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/a801f480d325ee0f4ce6bccd0622d392/ab195/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.39333333333333337}}}}}},{"node":{"id":"ba805bf0-9f82-572b-8211-a50bda4e57a6","fields":{"slug":"programming-paradigms","path":"/books/programming-paradigms/"},"frontmatter":{"title":"프로그래밍 패러다임","subTitle":"같은 문제를 다르게 바라보는 방법들","description":"객체지향, 함수형, 선언형 프로그래밍이 같은 문제를 각각 어떻게 다르게 바라보는지, 그리고 추상화와 타입 시스템의 수학적 토대까지 살펴보는 시리즈입니다.","author":"Evan Moon","date":"Feb 07, 2026","posts":["/2019/08/24/what-is-object-oriented-programming/","/2019/12/15/about-functional-thinking/","/2023/01/15/what-is-abstract/","/2025/09/07/declarative-programming-misconceptions-and-essence/","/2026/01/25/types-as-proofs-typescript-hidden-math/","/2026/02/07/monads-in-typescript/"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/2f02b656a28de12eb8100adecd7d55af/3a812/thumbnail.jpg","srcSet":"/static/2f02b656a28de12eb8100adecd7d55af/3a812/thumbnail.jpg 320w,\n/static/2f02b656a28de12eb8100adecd7d55af/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/2f02b656a28de12eb8100adecd7d55af/fc5c5/thumbnail.webp 320w,\n/static/2f02b656a28de12eb8100adecd7d55af/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/2f02b656a28de12eb8100adecd7d55af/4ba93/thumbnail.jpg","srcSet":"/static/2f02b656a28de12eb8100adecd7d55af/4ba93/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/2f02b656a28de12eb8100adecd7d55af/fed18/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5626666666666666}}}}}},{"node":{"id":"30cfe63e-9268-56a0-bf4e-e2e656852eac","fields":{"slug":"leadership-and-culture","path":"/books/leadership-and-culture/"},"frontmatter":{"title":"리더십과 조직 문화","subTitle":"팀이 생기고 나서야 알게 된 것들","description":"애자일, 조직 문화, 피드백, 리더십, 다양성 같은 팀을 이끄는 개발자가 마주치는 주제들을 다룹니다.","author":"Evan Moon","date":"Jan 24, 2026","posts":["/2019/07/02/what-is-agile/","/2019/07/04/danger-of-data-driven/","/2019/08/06/developer-with-organizational-culture/","/2019/12/04/about-honestly-feedback/","/2020/10/24/buisiness-with-programming/","/2023/10/03/how-to-be-a-better-leader/","/2025/07/06/diversity-illusion-leadership/","/2026/01/24/leading-frontend-organization/"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/ddbff2c3ca65fe24699da104fe514fa7/3a812/thumbnail.jpg","srcSet":"/static/ddbff2c3ca65fe24699da104fe514fa7/3a812/thumbnail.jpg 320w,\n/static/ddbff2c3ca65fe24699da104fe514fa7/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/ddbff2c3ca65fe24699da104fe514fa7/fc5c5/thumbnail.webp 320w,\n/static/ddbff2c3ca65fe24699da104fe514fa7/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/ddbff2c3ca65fe24699da104fe514fa7/4ba93/thumbnail.jpg","srcSet":"/static/ddbff2c3ca65fe24699da104fe514fa7/4ba93/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/ddbff2c3ca65fe24699da104fe514fa7/fed18/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5626666666666666}}}}}},{"node":{"id":"22f00112-aba8-595b-8cf5-beea16b1b5f4","fields":{"slug":"developer-mind-and-philosophy","path":"/books/developer-mind-and-philosophy/"},"frontmatter":{"title":"개발자의 마음과 철학","subTitle":"코드 바깥에서 마주치는 문제들","description":"번아웃, 불안, 자의식, 피드백, 인식론처럼 개발자로 일하면서 마주치는 기술 바깥의 문제들을 다룹니다.","author":"Evan Moon","date":"Dec 23, 2024","posts":["/2019/07/04/danger-of-data-driven/","/2019/09/23/how-to-overcome-burnout/","/2019/11/16/the-way-to-control-anxiety/","/2019/12/04/about-honestly-feedback/","/2020/02/11/question-driven-thinking/","/2020/03/02/what-is-knowing/","/2020/09/27/work-life-balance/","/2023/11/21/how-to-overcome-being-self-conscious/","/2024/12/23/the-illusion-of-a-right-answer/"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/89e6b571a1a59e725c099d90ca7e6397/d803c/thumbnail.png","srcSet":"/static/89e6b571a1a59e725c099d90ca7e6397/d803c/thumbnail.png 320w,\n/static/89e6b571a1a59e725c099d90ca7e6397/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/89e6b571a1a59e725c099d90ca7e6397/fc5c5/thumbnail.webp 320w,\n/static/89e6b571a1a59e725c099d90ca7e6397/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/89e6b571a1a59e725c099d90ca7e6397/3c8a4/thumbnail.png","srcSet":"/static/89e6b571a1a59e725c099d90ca7e6397/3c8a4/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/89e6b571a1a59e725c099d90ca7e6397/3a4b3/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.6253333333333334}}}}}}]},"posts":{"edges":[{"node":{"id":"b7529b72-8f0e-5da0-aba5-3ec7b344e1ef","tableOfContents":"<ul>\n<li>\n<p><a href=\"#chatgpt-%EC%9D%B4%ED%9B%84-3%EB%85%84\">ChatGPT 이후 3년</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%91%EC%84%B1%EC%9E%90%EC%97%90%EC%84%9C-%EC%9D%98%EC%82%AC%EA%B2%B0%EC%A0%95%EA%B6%8C%EC%9E%90%EB%A1%9C\">작성자에서 의사결정권자로</a></p>\n<ul>\n<li><a href=\"#%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B1%85%EC%9E%84%EC%9D%84-%EC%A7%88-%EC%82%AC%EB%9E%8C%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4\">코드에 대한 책임을 질 사람이 필요하다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#ai-%EC%8B%9C%EB%8C%80%EC%97%90-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%EC%9A%94%EA%B5%AC%EB%90%98%EB%8A%94-%EC%97%AD%EB%9F%89\">AI 시대에 개발자에게 요구되는 역량</a></p>\n<ul>\n<li><a href=\"#%EC%9E%A5%EA%B8%B0-%EB%B3%80%EA%B2%BD-%EB%B9%84%EC%9A%A9%EC%9D%84-%EC%98%88%EC%B8%A1%ED%95%98%EB%8A%94-%EC%97%AD%EB%9F%89\">장기 변경 비용을 예측하는 역량</a></li>\n<li><a href=\"#%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%8B%A4%EA%B0%81%EB%8F%84%EB%A1%9C-%ED%8F%89%EA%B0%80%ED%95%98%EB%8A%94-%EC%97%AD%EB%9F%89\">코드를 다각도로 평가하는 역량</a></li>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%99%94-%EC%97%AD%EB%9F%89\">추상화 역량</a></li>\n<li><a href=\"#%EC%95%94%EB%AC%B5%EC%A7%80%EB%A5%BC-%EB%AA%85%EC%8B%9C%ED%99%94%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%97%AD%EB%9F%89\">암묵지를 명시화할 수 있는 역량</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%98%EB%8F%84%EC%A0%81-%EC%88%98%EB%A0%A8-%EC%84%A4%EA%B3%84%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\">의도적 수련 설계의 필요성</a></p>\n<ul>\n<li><a href=\"#ai%EC%97%90%EA%B2%8C-%EB%84%98%EA%B8%B0%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0-%EB%91%90-%EC%A7%80%EC%A0%90-%EC%84%A4%EA%B3%84%EC%99%80-%EB%A6%AC%EB%B7%B0\">AI에게 넘기지 말아야 할 두 지점: 설계와 리뷰</a></li>\n<li><a href=\"#%EC%9D%98%EB%8F%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A7%81%EC%A0%91-%EC%A7%9C%EB%B3%B4%EB%8A%94-%EC%8B%9C%EA%B0%84\">의도적으로 직접 짜보는 시간</a></li>\n<li><a href=\"#%EB%91%90-%EA%B0%80%EC%A7%80%EB%A5%BC-%EA%B4%80%ED%86%B5%ED%95%98%EB%8A%94-%ED%83%9C%EB%8F%84-%EC%99%9C%EB%A5%BC-%EC%96%B8%EC%96%B4%ED%99%94%ED%95%98%EB%8A%94-%EC%97%B0%EC%8A%B5\">두 가지를 관통하는 태도: “왜”를 언어화하는 연습</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EA%B5%AD-%EB%B3%B8%EC%A7%88%EC%9D%80-%EB%B3%80%ED%95%98%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4\">결국 본질은 변하지 않았다</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 AI 시대에 개발자의 역할이 어떻게 달라지고 있는지, 그리고 무엇을 준비해야 하는지 이야기해보려 한다. 최근 필자가 재직 중인 직장에서도 많은 개발자들이 이 주제에 대해 고민을 하고 있는데, 비단 이 주제는 필자 같은 개발자뿐 아니라 다양한 직군이 함께 고민하는 문제일 것이다.","html":"<p>이번 포스팅에서는 AI 시대에 개발자의 역할이 어떻게 달라지고 있는지, 그리고 무엇을 준비해야 하는지 이야기해보려 한다. 최근 필자가 재직 중인 직장에서도 많은 개발자들이 이 주제에 대해 고민을 하고 있는데, 비단 이 주제는 필자 같은 개발자뿐 아니라 다양한 직군이 함께 고민하는 문제일 것이다.</p>\n<!-- more -->\n<p>공통적으로는 AI로 인한 생산성 향상에 대한 기대와 함께, 대체 가능성에 대한 불안도 동시에 느끼는 것 같다.</p>\n<p>물론 AI로 인해 앞으로의 먼 미래가 어떻게 달라질 것인지에 대해서는 아무도 알지 못할테고, 필자 또한 마찬가지이다. 그래도 아무것도 안할 수는 없으니 필자가 그리는 미래의 개발자의 역할과 모습에 대해서 한번 가볍게 이야기해보려고 한다.</p>\n<h2 id=\"chatgpt-이후-3년\" style=\"position:relative;\">ChatGPT 이후 3년<a href=\"#chatgpt-%EC%9D%B4%ED%9B%84-3%EB%85%84\" aria-label=\"chatgpt 이후 3년 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>처음 ChatGPT가 등장한 2022년 말, 사실 필자는 AI가 이렇게 빠르게 발전할 것이라고는 상상하지 못 했다. 당시에는 할루시네이션 이슈도 많았고 무엇보다 출력의 퀄리티 자체가 그리 좋지 않았기 때문이다.</p>\n<p>하지만 이제 겨우 3년 정도가 지났음에도 불구하고 우리 개발자의 하루는 상당히 많은 부분이 변화했다.</p>\n<p>지금까지의 개발자라는 직업의 정의는 “프로그래밍이라는 행위를 통해 세상의 문제를 해결하는 사람” 정도였던 것 같다. 자연어로 된 요구사항을 분석하고, 설계에 대해 고민하고, 직접 키보드를 타이핑해 구현체를 만들어내는 일련의 과정을 직접 수행했다.</p>\n<p>그래서 불과 몇 년 전까지만 해도 아침에 출근하면 에디터를 열고 빈 파일에 커서를 놓는 것으로 하루를 시작했지만, 최근에는 직접 코딩을 하기보다는 AI에게 맥락을 전달하고, 생성된 코드를 읽고, 고치고, 다시 요청하는 것이 하루의 많은 부분을 차지한다.</p>\n<p>ChatGPT가 처음 등장한 지 3년 남짓한 시간 동안 변화가 워낙 빨랐기에, 나름 휴대폰과 스마트폰의 등장을 모두 겪어본 아재인 필자도 이렇게 빨리 세상이 바뀔 줄은 상상하지 못했다.</p>\n<p>이미 AI 코딩 에이전트의 성능은 단순 보조 수준을 넘어선지 오래다. 프롬프트만 잘 제공하면 함수 하나, 모듈 하나 정도는 사람이 작성한 것과 쉽게 구별하기 어려운 코드를 내놓는다. 이런 환경에서 개발자가 모든 코드를 직접 한 줄씩 작성하는 방식은, 최소한 일부 업무에서는 점점 비효율이 되어가고 있다.</p>\n<p>앞으로 변화 속도는 더 빨라질 가능성이 높다. 그리고 이 과정에서 개발자의 역할도 팀과 조직의 맥락에 따라 다르게 재편될 것이다. 그렇다면 지금 우리는 어떤 방향으로 미래를 준비해야 할까?</p>\n<h2 id=\"작성자에서-의사결정권자로\" style=\"position:relative;\">작성자에서 의사결정권자로<a href=\"#%EC%9E%91%EC%84%B1%EC%9E%90%EC%97%90%EC%84%9C-%EC%9D%98%EC%82%AC%EA%B2%B0%EC%A0%95%EA%B6%8C%EC%9E%90%EB%A1%9C\" aria-label=\"작성자에서 의사결정권자로 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이 질문에 답하려면 먼저 개발 과정에서 우리가 사용하는 시간이 어디에 주로 투자되고 있는지부터 봐야 한다. 예전에는 구현을 위해 직접 타이핑하는 시간이 길었다면 지금은 AI에게 프롬프트로 맥락을 전달하고, 생성된 코드를 읽고 고치고 다시 요청하는 시간이 빠르게 늘어나고 있다.</p>\n<p>즉, 코드를 통해 제품을 생산하는 행위는 직접적인 코드 작성에서 점점 “코드에 대한 판단”으로 이동하고 있다. 여기서 판단이란 단순히 AI 출력이 의도대로 됐는지 확인하는 것이 아니라 비즈니스 의도가 기술적 구현으로 올바르게 번역됐는지 검증하는 과정을 의미한다.</p>\n<p>물론 AI가 계속 발전하면 코드 리뷰조차 인간이 할 필요가 없어질 수 있다고 생각할 수 있겠지만, 필자 생각은 다르다. 그 이유는 기술적 가능성이 아닌 훨씬 더 근본적인 곳에 있다.</p>\n<h3 id=\"코드에-대한-책임을-질-사람이-필요하다\" style=\"position:relative;\">코드에 대한 책임을 질 사람이 필요하다<a href=\"#%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B1%85%EC%9E%84%EC%9D%84-%EC%A7%88-%EC%82%AC%EB%9E%8C%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4\" aria-label=\"코드에 대한 책임을 질 사람이 필요하다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>최근 많은 개발자들이 코드 리뷰에도 AI를 활용하고 있다. 보통 Pull Request에 AI가 코드를 읽어보고 코멘트를 남겨주는 방식으로 작동하는데, 의외로 예리한 부분을 지적하는 경우도 있어서 필자도 가끔 놀란다.</p>\n<p>하지만 필자는 기술이 얼마나 발전하든 결국 최종적인 “문제 없음”이라는 승인 도장을 찍는 인간의 역할은 여전히 존재할 것이라 생각한다.</p>\n<p>그 이유는 바로 이 질문 때문이다.</p>\n<blockquote>\n<p>과연 코드로 인해 문제가 발생했을 때 누가 책임을 지는가?</p>\n</blockquote>\n<p>AI는 법적으로 인격체가 아니기 때문에 책임을 질 수 없다. 그렇다면 AI가 생성한 코드로 인해 문제가 발생했다면 과연 누가 책임을 져야하는 것인지에 대한 질문을 던져볼 필요가 있다.</p>\n<p>만약 AI가 작성한 코드로 인해 결제 로직에 버그가 생겨 고객에게 잘못된 금액이 청구됐을 때 서비스 운영자가 이렇게 답변하면 어떻게 될까?</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 268px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6d88ccc76e457cfbd94e60f058a4d6cf/6b6e1/dontknow.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe7lSWD/xAAXEAADAQAAAAAAAAAAAAAAAAAAAREg/9oACAEBAAEFAqLP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGhAAAQUBAAAAAAAAAAAAAAAAAQAQESFBYf/aAAgBAQABPyGmIyTbYEBE8b//2gAMAwEAAgADAAAAEAMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhAAAwEBAQEAAAAAAAAAAAAAAREhADEQUf/aAAgBAQABPxAoAYzdYSrUPjh9wgIEuO4Ub//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"dontknow\" title=\"\" src=\"/static/6d88ccc76e457cfbd94e60f058a4d6cf/6b6e1/dontknow.jpg\" srcset=\"/static/6d88ccc76e457cfbd94e60f058a4d6cf/0913d/dontknow.jpg 160w,\n/static/6d88ccc76e457cfbd94e60f058a4d6cf/6b6e1/dontknow.jpg 268w\" sizes=\"(max-width: 268px) 100vw, 268px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>AI가 작성한거라 전 왜 이렇게 됐는지 모르겠는디요</small>\n</center>\n<p>이딴 답변을 고객이 받아줄리가 없다. 입장바꿔서 생각해보면 아주 복장터지는 일이다.</p>\n<p>아무리 AI가 작성한 코드라고 해도 결국 누군가는 “책임”을 져야한다. 그리고 필자가 생각하기에 그 책임을 져야하는 사람은 바로 그 코드를 리뷰하고 승인한 개발자, 그리고 그 개발자가 속한 조직이다.</p>\n<p>이러한 방향성은 필자의 뇌피셜이 아니라 이미 여러 규제로 나타나고 있다.</p>\n<p>2024년 발효된 EU AI Act는 의료, 금융, 인프라 같은 고위험 영역에서 AI 시스템에 인간 감독을 의무화했다. 시행 자체는 단계적으로 진행 중이지만 방향성 자체는 분명하다. AI가 판단을 내리더라도 이 과정을 인간이 리뷰 가능하도록 만들어야 한다는 원칙을 법으로 못 박은 것이다.</p>\n<p>또한 EU 쪽에서는 제품책임 체계를 디지털 제품/소프트웨어까지 포괄하려는 논의도 이어지고 있다. “AI가 만들었으니 우리 책임이 아니다”는 주장이 법적으로 점점 통하기 어려워지는 방향으로 가고 있는 것이다.</p>\n<p>규제 뿐 아니라 다른 분야에서 나타난 실제 사례들도 보여지고 있다. 자율주행차는 사고가 나면 책임이 제조사와 운전자에게 돌아간다. FDA 승인을 받은 의료 AI 진단 도구도 최종 판단은 의사가 내려야 한다. 2010년 미국 주식시장에서 알고리즘 트레이딩이 연쇄 폭락을 일으킨 Flash Crash 사건에서도 알고리즘을 포함한 자동화 시스템을 운영하는 주체가 규제/집행의 대상이 된다는 걸 보여준다.</p>\n<p>자동화가 고도화될수록 책임 구조는 희미해지는 게 아니라 오히려 더 선명하게 인간 쪽으로 귀속되는 경향이 존재하는 것이다.</p>\n<p>그래서 필자는 앞으로 개발자의 역할이 사라지기보다는 코드를 작성하는 사람에서 “코드를 리뷰하고 승인 도장을 찍는 사람”으로 변화하게 될 것이라 생각한다.</p>\n<p>결국 개발자의 역할이 사라지는 것이 아니라 무게 중심이 이동하는 것에 가깝다. 코드를 생산하는 방법이 달라졌을 뿐, 최종 코드의 품질이 그것을 리뷰하는 개발자의 역량에 달려 있다는 사실은 변하지 않는다. 그렇다면 이 새로운 구조에서 개발자에게 구체적으로 어떤 역량이 필요해지는 걸까?</p>\n<h2 id=\"ai-시대에-개발자에게-요구되는-역량\" style=\"position:relative;\">AI 시대에 개발자에게 요구되는 역량<a href=\"#ai-%EC%8B%9C%EB%8C%80%EC%97%90-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%EC%9A%94%EA%B5%AC%EB%90%98%EB%8A%94-%EC%97%AD%EB%9F%89\" aria-label=\"ai 시대에 개발자에게 요구되는 역량 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>아무래도 AI 시대이니 프롬프트를 잘 다루거나 AI 도구에 능숙한 것이 핵심 역량이 될 것 같지만, 필자 생각은 조금 다르다.</p>\n<p>뭐 요즘에는 “유명한 개발자 누구처럼 짜줘”라고 하면 알아서 해준다고는 하는데, 반대로 생각해보면 그 프롬프트를 작성할 수 있는 누구나 그렇게 짤 수 있다는 말이다. 거기에 어떤 경쟁력이 있는 것일까.</p>\n<p>중요한 것은 그런 프롬프트를 작성하는 것이 아니라, 혹여나 그런 프롬프트를 넣었음에도 불구하고 퀄리티 기준을 충족하지 않는 코드가 출력됐을 경우 문제를 감지할 수 있는 능력이다. 그 프롬프트 넣는다고 무조건 결과물의 퀄리티가 좋은 것은 아닐테니 말이다.</p>\n<p>아이러니하게도, 필자는 AI 시대에 개발자에게 요구되는 역량 또한 지금 좋은 개발자에게 요구되는 역량과 크게 다르지 않을 것이라 생각한다.</p>\n<p>왜냐하면 리뷰 과정 속에서 인간은 이 코드가 런타임에서 큰 문제가 없을지, 장기적인 변화에 대비할 수 있는 코드인지, 빠진 예외처리는 없을지, 정책에 위반되는 코드는 없는지와 같은 고맥락의 체크 리스트를 확인해야하기 때문이다. 그리고 결정적으로 코드에 대해서 최종적으로 승인 도장을 찍는 사람이 존재한다는 것은 여전히 “인간이 이해하기 쉬운 코드”를 작성해야한다는 것을 의미한다.</p>\n<p>만약 인간이 코드를 읽을 필요가 없다면 모든 코드는 기계어로 작성해도 된다. 하지만 만약 이 코드에서 문제가 생기면 여러분이 책임을 져야하는데, 아무리 시대가 발전한다고 해도 그 코드를 읽지도 않고 라이브에 배포할 수 있겠는가?</p>\n<p>이 벽을 넘지 못하는 이상, 결국 인간이 코드를 읽고 이해해야하는 상황은 여전히 발생하기 때문에 인간이 이해하기 쉬운 코드란 무엇일지, 어떻게 하면 그런 코드를 작성할 수 있을지와 같은 지금 시대에 개발자들이 고민하고 있는 내용은 AI 시대에도 반복될 가능성이 높다.</p>\n<h3 id=\"장기-변경-비용을-예측하는-역량\" style=\"position:relative;\">장기 변경 비용을 예측하는 역량<a href=\"#%EC%9E%A5%EA%B8%B0-%EB%B3%80%EA%B2%BD-%EB%B9%84%EC%9A%A9%EC%9D%84-%EC%98%88%EC%B8%A1%ED%95%98%EB%8A%94-%EC%97%AD%EB%9F%89\" aria-label=\"장기 변경 비용을 예측하는 역량 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>최근 링크드인에 올라오는 게시물을 보면, 처음에는 “AI로 이런 거 만들었어요”라는 포스팅만 올라오더니, 요즘에는 간간히 “유지보수가 어려워서 개발자를 고용했습니다”, “기능을 도저히 못 붙히겠어서 접었습니다”와 같은 슬픈 엔딩도 보인다.</p>\n<p>이런 일이 발생하는 이유는 AI가 “작동하는 코드”를 만드는데 최적화되어있기 때문이다. 결국 학습 데이터에서 가장 빈번하게 등장하는 패턴을 재현하는 것이 AI의 동작 방식인데, 그 패턴들은 당연히 정상적으로 실행되는 코드들이다. 하지만 지금 당장 작동하는 코드와 6개월 뒤에도 유지보수가 쉬운 코드는 전혀 다른 기준이다.</p>\n<p>물론 최근 모델은 유지보수성까지 고려한 답을 제시하는 경우도 늘고 있다. 하지만 필자가 말하고자 하는 핵심은 단일 산출물의 품질과 장기 변경 비용 예측이 다른 문제라는 점이다.</p>\n<p>소프트웨어의 품질이라는 건 원래 즉시 드러나지 않는 성질의 것이다. 나쁜 설계의 비용은 코드를 작성한 시점이 아니라, 그 코드를 변경해야 하는 시점에 발생하기 때문이다.</p>\n<h3 id=\"코드를-다각도로-평가하는-역량\" style=\"position:relative;\">코드를 다각도로 평가하는 역량<a href=\"#%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%8B%A4%EA%B0%81%EB%8F%84%EB%A1%9C-%ED%8F%89%EA%B0%80%ED%95%98%EB%8A%94-%EC%97%AD%EB%9F%89\" aria-label=\"코드를 다각도로 평가하는 역량 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>나쁜 설계의 비용이 작성 시점이 아닌 변경 시점에 드러난다는 건 AI 등장 이전에도 마찬가지였지만, 코드 생성 속도가 빨라지면서 이 “지연된 비용”이 쌓이는 속도도 함께 빨라졌다는 게 차이점이다.</p>\n<p>검수의 대상도 다양하다. 단순히 “이 코드가 맞느냐 틀리느냐”와 같은 기능적 정확성은 테스트로 어느 정도 검증할 수 있다. 더 까다로운 건 구조적 품질이다.</p>\n<p>과연 이 모듈의 책임 범위가 적절한가? 이 의존성 방향이 맞는가? 이 인터페이스가 변경에 유연한가? 이런 질문들은 자동화된 테스트로는 잡기 어렵다. 그 너머에는 성능적 함의도 있다. AI가 생성한 코드가 작동은 하지만, 데이터가 10배 늘었을 때도 괜찮을까? 그리고 보안적 측면도 있다. 입력 검증이 충분한가, 권한 확인이 빠져 있지는 않은가. 이 모든 차원을 동시에 고려하면서 코드를 평가하는 건, 단순히 “코드를 읽을 줄 아는 것”과는 다른 수준의 역량이다.</p>\n<p>그리고 AI의 생성 속도가 빨라질수록 이 문제는 더 심각해진다.</p>\n<p>사람이 직접 코드를 작성하던 시절, 코드 생산량에는 물리적 상한이 있었다. 한 개발자가 하루에 만들어낼 수 있는 코드의 양이 제한되어 있었기 때문에, 팀 전체가 검토해야 할 코드의 규모도 그 속도에 맞춰 조절됐다. 생산 속도와 리뷰 역량 사이에 어느 정도의 균형이 자연스럽게 유지됐던 것이다. 물론 느리게 작성한다고 코드가 더 좋아지는 건 아니지만 생산량이 리뷰 역량을 크게 앞지르기 어려운 구조이기는 했다.</p>\n<p>하지만 AI가 수 초 만에 수백 줄의 코드를 생성할 수 있는 환경에서는 코드 생산 속도와 리뷰 역량 사이의 균형이 쉽게 깨질 수 있다.</p>\n<p>특히 리뷰 기준, 병렬 리뷰 체계, 자동화 게이트가 충분하지 않다면 코드 양이 두세 배 늘어도 리뷰 인력과 시간은 그대로라 검증 누락이 생기기 쉽다. 그 결과 기술 부채가 더 빠르게 쌓일 가능성이 커진다. 공장의 생산 라인이 빨라졌는데 품질 검사 체계가 그대로인 상황인 것이다.</p>\n<p>필자는 아마 많은 회사들이 AI를 도입했음에도 생산성 증가를 못 느끼는 이유가 이것이 아닐까 생각한다. 코드 생산은 빨라졌을지 몰라도 AI가 뱉은 코드를 리뷰하는 과정이 제일 병목이다.</p>\n<p>이 구조에서 코드를 제대로 빠르게 검수할 수 있는 개발자의 가치는 자연스럽게 올라간다. AI가 쏟아내는 코드의 양이 많아질수록 그 코드에 섞인 잠재적 위험과 기술 부채를 선별할 수 있는 사람의 필요성이 커지기 때문이다.</p>\n<h3 id=\"추상화-역량\" style=\"position:relative;\">추상화 역량<a href=\"#%EC%B6%94%EC%83%81%ED%99%94-%EC%97%AD%EB%9F%89\" aria-label=\"추상화 역량 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자는 추상화 역량도 중요한 포인트 중 하나라고 생각한다. 결국 추상화란 복잡한 시스템에서 무엇을 감추고 무엇을 드러낼지, 그리고 어디에 경계를 그을지 결정하는 능력이다.</p>\n<p>AI가 추상화를 못하느냐고 물으면 솔직히 그건 아니다. AI도 인터페이스를 정의하고 클래스를 나누고 모듈을 분리할 수 있다. 사실 형식적인 측면에서는 필자보다 잘 하는 경우도 있다. 하지만 AI가 만드는 추상화와 숙련된 개발자가 만드는 추상화 사이에는 결정적인 차이가 하나 있다.</p>\n<p>AI의 추상화는 학습 데이터의 통계적 평균에 기반한다. 수많은 프로젝트에서 본 “그럴듯한 패턴”을 현재 상황에 적용하는 방식이다. 하지만 실제 소프트웨어 설계는 정답을 맞히는 게임이 아니라, 한정된 자원과 불확실한 미래 속에서 무엇을 포기할지 결정하는 트레이드오프의 영역이다.</p>\n<p>AI는 코드 내부의 정합성을 맞추는 데 능숙할지 몰라도 코드 외부의 맥락까지 고려하여 “어디에 경계를 그을지” 결정하는 것은 어려워한다. 특정 맥락에서 최적인 코드는 통계적 평균 너머의 전략적 판단이 개입될 때 비로소 완성되기 때문이다.</p>\n<p>이건 AI의 결함이라기보다는 통계적 학습이라는 방식 자체가 가진 구조적 한계에 가깝다. 평균적으로 좋은 코드를 만들 수는 있지만, 특정 맥락에서 최적인 코드를 만드는 건 다른 문제다.</p>\n<p>AI가 출력한 코드의 위험한 점은 겉보기에 좋아 보인다는 것이다. 코드 리뷰에서도 쉽게 통과할 수 있다. 파일이 적절히 나뉘어 있고, 네이밍도 관례를 따르고, 패턴도 익숙하기 때문이다. 문제는 실제로 변경이 필요한 시점에 발견된다. 결제 수단을 하나 추가하려고 하는데, “깔끔하게 나뉘어 있던” 구조의 여기저기를 동시에 수정해야 한다는 걸 그제야 깨닫게 되는 것이다. 이런 종류의 결함은 코드를 쓸 때가 아니라 코드를 고칠 때 드러난다.</p>\n<p>AI가 만든 코드에서 이런 패턴은 꽤 자주 발견된다. 통계적으로 가장 흔한 구조를 따랐기 때문에 표면적으로는 나무랄 데가 없지만, 실제 요구사항과 어긋나 있는 경우가 적지 않다.</p>\n<p>또 다른 예로, 프론트엔드에서 흔히 보이는 상황을 생각해보자. AI에게 대시보드 컴포넌트를 만들어달라고 하면, 보통은 하나의 거대한 컴포넌트 안에 데이터 페칭, 상태 관리, UI 렌더링을 모두 담은 구조를 내놓는다. 혹은 반대로 학습 데이터에서 본 모범 사례를 과하게 적용해서, 간단한 차트 하나를 그리기 위해 커스텀 훅 세 개와 컨텍스트 프로바이더를 만들어놓기도 한다.</p>\n<p>전자는 추상화가 부족한 것이고, 후자는 추상화가 과잉인 것이다. 둘 다 현재 프로젝트의 복잡도 수준에 맞지 않는다는 점에서는 같은 문제다. 적절한 추상화란 결국 현재 상황에서 딱 필요한 만큼의 구조를 만드는 것이고, 이 “만큼”을 판단하는 건 맥락을 아는 사람만 할 수 있다.</p>\n<p>숙련된 개발자는 이런 코드를 읽을 때 “여기서 이렇게 나눈 건 이 도메인의 특성을 모르고 한 거구나”라는 걸 알아채고 도메인에 맞는 경계를 다시 긋는다. 이 과정에서 동원되는 건 코딩 스킬이 아니라 시스템에 대한 이해와 설계에 대한 감각이다.</p>\n<p>즉, AI가 만든 코드를 평가할 때도 사람이 만든 코드를 평가할 때와 동일한 기준이 적용된다. “이 추상화가 실제로 복잡도를 줄이고 있는가, 아니면 추적해야 할 간접 경로만 늘리고 있는가?” 이 질문을 던질 수 있는 것 자체가 이미 하나의 역량이다.</p>\n<h3 id=\"암묵지를-명시화할-수-있는-역량\" style=\"position:relative;\">암묵지를 명시화할 수 있는 역량<a href=\"#%EC%95%94%EB%AC%B5%EC%A7%80%EB%A5%BC-%EB%AA%85%EC%8B%9C%ED%99%94%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%97%AD%EB%9F%89\" aria-label=\"암묵지를 명시화할 수 있는 역량 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>추상화 역량이 “어디에 경계를 그을지 아는 것”이라면, 암묵지를 명시화하는 역량은 “왜 거기에 경계를 그어야 하는지 설명할 수 있는 것”이다. 서로 다른 능력이지만 실제로는 함께 작동한다.</p>\n<p>좋은 코드와 나쁜 코드를 구분하는 감각은 코드를 많이 읽고 쓰면서 자연스럽게 체득하게된다. 보통 “뭔가 이상한데”라는 직감으로 시작되는 암묵지는 언어로 명확하게 설명하기가 꽤나 어렵다.</p>\n<p>그런데 이 암묵지를 언어로 만드는 능력이 AI 시대에 특히 중요해진다. “뭔가 이상한데”라는 직감을 “이 함수는 두 가지 책임을 가지고 있다”, “이 인터페이스가 변경에 취약하다”는 구체적인 언어로 바꿀 수 있어야 AI에게 올바른 명령을 내릴 수 있기 때문이다.</p>\n<p>다만 여기서 말하는 건 few-shot 예시나 chain-of-thought 같은 형식적인 프롬프트 기법이 아니다. 어차피 그런 것들은 모델이 발전하면서 자연스럽게 희석된다.</p>\n<p>필자가 이야기하고 싶은 건 그 아래에 있는 능력, 즉 무엇을 만들어야 하는지 명확하게 정의하고, 어떤 맥락이 중요한지 판단해서 전달하는 것이다.</p>\n<p>대충 “이걸 만들어줘”라고 말할 수 있는 사람은 많다. 하지만 개발자는 AI가 뱉은 코드의 문제점을 정확하게 파악하고 “이걸 이런 방식이 아니라 저런 방식으로 만들어야 하는 이유”를 설명할 수 있는 사람이 되어야한다.</p>\n<p>“뭔가 이상한 코드”를 보고 그 이유를 구체적으로 알고 말할 수 있는 것이 곧 개발자의 설계 역량이 될 것이다. 즉, 시스템과 코드에 대한 이해가 깊을수록, AI에게 더 구체적이고 더 정확한 지시를 내릴 수 있다.</p>\n<p>메모리를 직접 다루지 않아도 메모리 모델을 이해해야 성능 문제를 해결할 수 있듯이, 코드를 직접 작성하지 않아도 추상화를 이해해야 설계 문제를 잡아낼 수 있다. 추상화의 계층이 하나 더 생겼을 뿐, 추상화를 다루는 능력의 필요성 자체는 사라지지 않았다.</p>\n<p>이 역량들의 유효기간은 도구 숙련도보다 훨씬 길다. 도구 숙련도의 수명은 도구의 교체 주기에 묶여 있다. jQuery가 React에 밀리는 데 몇 년이 걸렸고, Webpack이 Vite에 밀리는 데 또 몇 년이 걸렸다. 반면 설계 판단과 암묵지 언어화 역량의 수명은 소프트웨어의 본질적 복잡성이 존재하는 한 유효하다.</p>\n<p>이 복잡성은 도구가 바뀌어도 사라지지 않는다. 결제 시스템이 복잡한 이유는 프레임워크 때문이 아니라 결제 도메인 자체가 복잡하기 때문이고, 그 복잡성을 다루는 감각은 특정 도구에 종속되지 않는다.</p>\n<h2 id=\"의도적-수련-설계의-필요성\" style=\"position:relative;\">의도적 수련 설계의 필요성<a href=\"#%EC%9D%98%EB%8F%84%EC%A0%81-%EC%88%98%EB%A0%A8-%EC%84%A4%EA%B3%84%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"의도적 수련 설계의 필요성 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여기까지 읽으면 자연스럽게 떠오르는 질문이 하나 있다. 코드를 직접 작성하는 시간이 줄어드는데, 도대체 추상화나 설계 감각은 어떻게 기르라는 걸까?</p>\n<p>이건 “도구가 할 수 없는 것에 집중하라”고 말하면서 정작 그것을 기를 기회가 줄어드는 모순적인 상황이다.</p>\n<p>해법은 두 층으로 나뉜다. 하나는 업무 흐름 안에서 AI에게 넘기지 말아야 할 두 지점을 지키는 것이고, 다른 하나는 그 판단력의 바탕이 되는 설계 감각을 업무 밖에서 의도적으로 유지하는 것이다. 그리고 이 두 가지를 관통하는 태도가 하나 있다.</p>\n<h3 id=\"ai에게-넘기지-말아야-할-두-지점-설계와-리뷰\" style=\"position:relative;\">AI에게 넘기지 말아야 할 두 지점: 설계와 리뷰<a href=\"#ai%EC%97%90%EA%B2%8C-%EB%84%98%EA%B8%B0%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%A0-%EB%91%90-%EC%A7%80%EC%A0%90-%EC%84%A4%EA%B3%84%EC%99%80-%EB%A6%AC%EB%B7%B0\" aria-label=\"ai에게 넘기지 말아야 할 두 지점 설계와 리뷰 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>평소 업무 흐름 안에서 AI에게 넘기지 말아야 할 지점이 두 군데 있다. 바로 코드 작성 앞단의 설계와 뒷단의 리뷰다.</p>\n<p>설계를 직접 하는 것은 단순한 습관의 문제가 아니다. 프롬프트를 치기 전에 “이 모듈이 외부에 노출할 인터페이스는 무엇인가”, “책임의 경계는 어디에 그을 것인가”를 먼저 정의하는 과정을 거치고 구현을 AI에게 위임하면, AI가 만들어낸 결과물을 자신의 설계 결정과 비교할 수 있게 된다.</p>\n<p>AI가 다른 구조를 선택했다면 왜 그랬는지 분석하게 되고, 내가 놓친 것은 없는지, AI가 틀린 것은 아닌지 다시 생각하게 된다. 만약 이 과정이 부재한다면 단순히 AI가 출력한 코드를 소비하게 될 가능성이 높은데, 단순히 출력을 소비하는 것과 자신의 판단을 기준으로 출력을 평가하는 것은 완전히 다른 경험이다.</p>\n<p>또한 리뷰는 의도적으로 시간을 따로 내지 않아도 업무 흐름 안에서 자동으로 주어지는 역량 성장 기회다. 그렇기 때문에 이 기회를 그냥 흘려보내는 것이 가장 위험하다.</p>\n<p>AI에게 PR 리뷰를 맡기고 별다른 문제가 없으면 그냥 승인해버리는 습관은 마치 체육 시간에 운동장에 나가서 벤치에만 앉아 있다가 들어오는 것과 같다. 업무 자체는 어찌어찌 진행할 수 있겠지만, 그렇게 몇 년을 일을 해도 실력은 그대로일 가능성인 높다.</p>\n<p>코드 리뷰는 요구사항, 설계 의도, 비즈니스 맥락을 동시에 고려하면서 코드를 읽는 과정이고, 이 과정 자체가 설계 감각을 유지하는 훈련이라고 생각해야한다.</p>\n<h3 id=\"의도적으로-직접-짜보는-시간\" style=\"position:relative;\">의도적으로 직접 짜보는 시간<a href=\"#%EC%9D%98%EB%8F%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A7%81%EC%A0%91-%EC%A7%9C%EB%B3%B4%EB%8A%94-%EC%8B%9C%EA%B0%84\" aria-label=\"의도적으로 직접 짜보는 시간 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>업무 안에서 설계와 리뷰를 직접 한다고 해서 충분한 건 아니다. 설계 감각 자체가 구현의 고통을 알아야 생기기 때문이다. 어떤 구조가 변경에 취약한지를 직접 손으로 겪어봐야 “이 추상화가 잘못됐다”는 직감이 생긴다. 겪어보지 못한 고통은 감각으로 남지 않는다.</p>\n<p>주니어 개발자의 경우 특히 그렇다. 경험이 적은 상태에서 AI가 생성한 코드를 리뷰하는 건, 아직 운전을 배우는 중인 사람에게 자율주행차의 판단을 평가하라고 하는 것과 비슷한 면이 있다. 직접 핸들을 잡아봐야 도로 위의 감각이 생기는 것처럼 직접 코드를 짜봐야 구조에 대한 감각이 생긴다.</p>\n<p>미래의 개발자에게 코딩하는 역량은 매일 하는 업무가 아니라 판단력을 유지하기 위한 훈련이 될 가능성이 높다고 본다. <small>(아마 주니어 시절의 고통스러운 직접 구현 경험은 선택이 아니라 리뷰어로서 면허를 따는 과정 정도가 되지는 않을까.)</small></p>\n<p>그래서 사이드 프로젝트나 개인 학습에서는 의도적으로 AI를 내려놓고 처음부터 끝까지 직접 구현해보는 시간을 만드는 게 좋다.</p>\n<p>AI가 편리할수록 그 마찰이 귀찮게 느껴지지만 그 마찰과 고통을 겪어야 빠른 실력 향상이 생길 것이라고 생각한다. 그리고 구현이 막히는 지점이나 리팩토링을 해야 하는 순간이 깨달음을 얻을 수 있는 순간이다.</p>\n<h3 id=\"두-가지를-관통하는-태도-왜를-언어화하는-연습\" style=\"position:relative;\">두 가지를 관통하는 태도: “왜”를 언어화하는 연습<a href=\"#%EB%91%90-%EA%B0%80%EC%A7%80%EB%A5%BC-%EA%B4%80%ED%86%B5%ED%95%98%EB%8A%94-%ED%83%9C%EB%8F%84-%EC%99%9C%EB%A5%BC-%EC%96%B8%EC%96%B4%ED%99%94%ED%95%98%EB%8A%94-%EC%97%B0%EC%8A%B5\" aria-label=\"두 가지를 관통하는 태도 왜를 언어화하는 연습 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>업무에서 설계와 리뷰를 직접 하든, 따로 시간을 내서 직접 짜든 이 두 가지 모두에서 작동해야 하는 태도가 있다. 바로 “뭔가 이상한데”라는 직감이 드는 순간 그 감각을 그냥 넘기지 않고 왜 그렇게 느꼈는지 명확한 말로 표현할 수 있을 때까지 다듬는 것이다.</p>\n<p>“이상한데”에서 멈추면 그냥 직감에서 끝나버리지만, “이 함수가 두 가지 책임을 가지고 있다”까지 가면 언어가 된다. 직감은 나만 아는 것이고 언어는 쓸 수 있는 것이다. 언어가 되어야 AI에게 정확한 지시를 내릴 수 있고, 팀원에게 설명할 수 있고, 다음에 비슷한 패턴을 만났을 때 알아챌 수 있다.</p>\n<p>AI가 만들어낸 코드가 작동한다고 해서 거기서 멈추지 않고, “왜 이 구조를 선택했을까”, “다른 구조였다면 어떤 트레이드오프가 있었을까”를 스스로에게 물어보는 것. 이 습관이 있는 개발자와 없는 개발자 사이의 격차는 시간이 갈수록 벌어질 것이다.</p>\n<h2 id=\"결국-본질은-변하지-않았다\" style=\"position:relative;\">결국 본질은 변하지 않았다<a href=\"#%EA%B2%B0%EA%B5%AD-%EB%B3%B8%EC%A7%88%EC%9D%80-%EB%B3%80%ED%95%98%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4\" aria-label=\"결국 본질은 변하지 않았다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>AI의 등장으로 개발자의 역할이 코드 작성자에서 리뷰어로 이동하고 있다. 생산과 검수를 모두 인간이 하던 시대에서 생산은 AI가 하고 검수는 인간이 담당하는 시대로 변화하고 있는 것이다.</p>\n<p>그리고 이러한 변화가 기술적 한계가 아닌 책임 소재라는 사회적 문제에서 비롯된다는 걸 이해하면 역할 전환의 의미가 더 명확해진다.</p>\n<p>결국 필자는 리뷰 승인이라는 도장을 잘 찍으려면 작동하는 코드와 오래 살아남는 코드를 구분하는 눈, 맥락에 맞는 추상화를 판단하는 설계 감각, 그 감각을 언어로 만들어 정확한 방향을 잡는 역량이 필요해질 것이라 생각한다.</p>\n<p>즉, AI 시대의 차이는 생산량이 아니라 누가 맥락을 이해하고 책임 있게 승인하느냐에서 난다. 시대는 변화했지만 결국 개발자라는 사람이 책임져야하는 영역이 코드의 퀄리티라는 사실은 변하지 않는 것이다.</p>\n<p>AI가 이전 도구들과 근본적으로 다른 것은 사실이다. 농기구나 기계와 달리 AI는 스스로 추론하고 생성한다. “AI도 그냥 또 하나의 도구야”라는 식의 주장이 설득력을 잃는 건 당연하다. 그렇다면 왜 요구되는 역량이 바뀌지 않는다고 할 수 있을까.</p>\n<p>논리는 책임에서 시작한다. 책임을 진다는 건 판단을 한다는 뜻이고, 판단의 질은 코드의 구조적 건강함을 알아보는 눈, 도메인에 맞는 추상화를 구분하는 감각, 장기 변경 비용을 예측하는 능력에서 온다. 이것들이 항상 좋은 개발자와 평범한 개발자를 갈랐던 것들이다.</p>\n<p>프레드 브룩스(Fred Brooks)는 1986년에 소프트웨어의 복잡성을 두 가지로 나눴다. 우발적 복잡성은 도구의 한계에서 오는 것이고, 본질적 복잡성은 문제 자체에 내재된 것이다. AI가 해결하는 건 우발적 복잡성이다. 보일러플레이트, 반복 패턴, 문법 오류 같은 것들. 하지만 비즈니스 요구사항의 모호함, 상충하는 설계 목표 사이의 균형, 미래 변경 방향에 대한 불확실성 같은 본질적 복잡성은 AI가 아무리 발전해도 사라지지 않는다. 이 복잡성은 도구의 수준이 아니라 문제 자체의 성격에서 온다.</p>\n<p>그래서 AI의 성격이 이전 도구들과 달라도 인간이 판단과 책임의 주체로 남아 있는 한 그 판단에 필요한 역량의 본질은 바뀌지 않는다. 필자는 오히려 코드 생산이 자동화될수록 그 생산물을 검수하는 판단력의 비중이 오히려 부각될 것이라 생각한다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 567px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cfed549021f0c0b30f757fa171543e0e/a7172/buffett.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 64.375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAgADBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeYyjCUf/8QAGxAAAgIDAQAAAAAAAAAAAAAAAhEBAwAQEjL/2gAIAQEAAQUC5WGtCcs7FNnv/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAgMAAAAAAAAAAAAAAAAAABARITH/2gAIAQEABj8CtwYv/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARIUExYf/aAAgBAQABPyE467sWTrE+ysYV5LIIWp//2gAMAwEAAgADAAAAEKQP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHRABAAICAgMAAAAAAAAAAAAAAQARIUExUaGx8P/aAAgBAQABPxDEcgNGGLqrkx1qJeFUEoYj7cYsU4WvVRSnYPif/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"buffett\" title=\"\" src=\"/static/cfed549021f0c0b30f757fa171543e0e/a7172/buffett.jpg\" srcset=\"/static/cfed549021f0c0b30f757fa171543e0e/0913d/buffett.jpg 160w,\n/static/cfed549021f0c0b30f757fa171543e0e/cb69c/buffett.jpg 320w,\n/static/cfed549021f0c0b30f757fa171543e0e/a7172/buffett.jpg 567w\" sizes=\"(max-width: 567px) 100vw, 567px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>필자와 함께 일하는 코치 중 한 분은 이 상황을 빗대어<br>\n  \"물이 빠지면 비로소 누가 발가벗고 수영을 하고 있었는지 알 수 있을 것\"이라고 했는데<br>\n  아주 찰떡인 비유인 것 같다.\n  </small>\n</center>\n<p>그래서 필자는 최근 많은 사람들이 AI라는 도구를 잘 깎는 것에 집중하는 것을 보면서 뭔가 조금 이상하다는 생각을 했었다.</p>\n<p>불과 1년 전만해도 프롬프트 엔지니어링이 굉장히 중요한 화두였지만 지금은 그 얘기는 쏙 들어가고 스킬, 병렬 에이전트, 팀과 같은 기능들에 대한 이야기가 오간다. 아마 6개월만 지나도 이 키워드들도 쏙 들어갈 것이다.</p>\n<p>어차피 AI는 길가는 초등학생이 프롬프트를 갈겨도 제대로된 출력을 낼 수 있는 수준까지 발전할텐데, 지금 도구를 잘 사용하는 방법에 집중하는 것이 정말 옳은 방향일까? 오히려 필자는 도구를 잘 깎는 것에만 집중하면 도태되기 쉬워지지는 않을까 하는 생각을 가지고 있다.</p>\n<p>물론 필자가 그리는 미래가 실제로 그렇게 펼쳐질지는 모른다. AI가 어느 방향으로 얼마나 빠르게 발전할지 정확히 아는 사람은 없고, 필자도 예외가 아니다. 이 글도 결국 불확실한 미래를 앞에 두고 한 명의 개발자가 지금 할 수 있는 생각을 정리해본 것일 뿐이다.</p>\n<p>정답은 없지만, 물이 빠지는 속도 만큼은 분명히 빨라지고 있다. 이 글을 읽는 독자 분들도 물이 빠졌을 때 발가벗고 수영을 하고 있는 사람이 되지 않도록 최선을 다해 각자만의 답을 찾아보기를 바란다.</p>","fields":{"slug":"20260210-developer-in-ai-era","path":"/2026/02/10/developer-in-ai-era/","lang":"ko"},"frontmatter":{"title":"AI가 코드를 쓰는 시대, 개발자의 진짜 역량이 드러난다","subTitle":"물이 빠지면 누가 발가벗고 수영했는지 알 수 있다","date":"Feb 10, 2026","categories":["에세이"],"tags":["AI","개발자","추상화","소프트웨어 설계","커리어"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/669d1ffce728369397df91471ecb0088/d803c/thumbnail.png","srcSet":"/static/669d1ffce728369397df91471ecb0088/d803c/thumbnail.png 320w,\n/static/669d1ffce728369397df91471ecb0088/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/669d1ffce728369397df91471ecb0088/fc5c5/thumbnail.webp 320w,\n/static/669d1ffce728369397df91471ecb0088/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/669d1ffce728369397df91471ecb0088/01fb2/thumbnail.png","srcSet":"/static/669d1ffce728369397df91471ecb0088/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/669d1ffce728369397df91471ecb0088/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"289bd335-2b88-5a2f-ab97-44d3e5eb1157","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A0%84-%EA%B8%80%EC%97%90%EC%84%9C-%EB%8B%A4%EB%A4%98%EB%8D%98-%EA%B2%83%EB%93%A4\">이전 글에서 다뤘던 것들</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%91%ED%84%B0%EC%9D%98-%ED%95%9C%EA%B3%84\">펑터의 한계</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%95%B4%EA%B2%B0%EC%B1%85-%EC%84%A4%EA%B3%84-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%ED%8B%B0%EB%B8%8C-%ED%8E%91%ED%84%B0%EC%99%80-%EB%AA%A8%EB%82%98%EB%93%9C\">해결책 설계: 어플리케이티브 펑터와 모나드</a></p>\n<ul>\n<li><a href=\"#%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%ED%8B%B0%EB%B8%8C-%ED%8E%91%ED%84%B0%EC%9D%98-%ED%95%9C%EA%B3%84\">어플리케이티브 펑터의 한계</a></li>\n<li><a href=\"#%EB%AA%A8%EB%82%98%EB%93%9C-%EC%A4%91%EC%B2%A9%EC%9D%84-%ED%8E%B4%EB%8A%94-%EC%97%B0%EC%82%B0%EC%9D%98-%EB%B0%9C%EB%AA%85\">모나드, 중첩을 펴는 연산의 발명</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B2%95%EC%B9%99%EC%9D%80-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A6%9D%EB%AA%85\">법칙은 리팩토링에 대한 증명</a></p>\n<ul>\n<li><a href=\"#%EC%84%B8-%EA%B0%80%EC%A7%80-%EB%B2%95%EC%B9%99\">세 가지 법칙</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A4%EC%8B%9C-%EB%82%B4%EB%B6%80%ED%95%A8%EC%9E%90-%EB%B2%94%EC%A3%BC%EC%9D%98-%EB%AA%A8%EB%85%B8%EC%9D%B4%EB%93%9C-%EB%8C%80%EC%83%81%EC%9C%BC%EB%A1%9C\">다시 “내부함자 범주의 모노이드 대상”으로</a></p>\n<ul>\n<li><a href=\"#%EB%B2%94%EC%A3%BCcategory-%EB%8C%80%EC%83%81%EA%B3%BC-%ED%99%94%EC%82%B4%ED%91%9C%EC%9D%98-%EC%84%B8%EA%B3%84\">범주(Category): 대상과 화살표의 세계</a></li>\n<li><a href=\"#%EB%82%B4%EB%B6%80%ED%95%A8%EC%9E%90endofunctor-%EA%B0%99%EC%9D%80-%EC%84%B8%EA%B3%84-%EC%95%88%EC%97%90%EC%84%9C-%EB%8F%84%EB%8A%94-%ED%8E%91%ED%84%B0\">내부함자(Endofunctor): 같은 세계 안에서 도는 펑터</a></li>\n<li><a href=\"#%EB%82%B4%EB%B6%80%ED%95%A8%EC%9E%90-%EB%B2%94%EC%A3%BC-%ED%8E%91%ED%84%B0%EB%93%A4-%EC%9E%90%EC%B2%B4%EA%B0%80-%EB%8C%80%EC%83%81%EC%9D%B8-%EC%84%B8%EA%B3%84\">내부함자 범주: 펑터들 자체가 대상인 세계</a></li>\n<li><a href=\"#%EB%AA%A8%EB%85%B8%EC%9D%B4%EB%93%9Cmonoid-%EB%8C%80%EC%83%81-%ED%95%A9%EC%B9%98%EA%B8%B0%EC%9D%98-%EB%8C%80%EC%88%98%ED%95%99\">모노이드(Monoid) 대상: 합치기의 대수학</a></li>\n<li><a href=\"#%EC%97%B0%EA%B2%B0%EC%A0%90-%EB%AA%A8%EB%82%98%EB%93%9C%EB%8A%94-%EB%82%B4%EB%B6%80%ED%95%A8%EC%9E%90-%EB%B2%94%EC%A3%BC%EC%9D%98-%EB%AA%A8%EB%85%B8%EC%9D%B4%EB%93%9C-%EB%8C%80%EC%83%81\">연결점: 모나드는 내부함자 범주의 모노이드 대상</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%82%AC%EC%8B%A4-%EB%AA%A8%EB%82%98%EB%93%9C%EB%8A%94-%EB%B0%95%EC%8A%A4%EA%B0%80-%EC%95%84%EB%8B%88%EB%8B%A4\">사실 모나드는 박스가 아니다</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 이전에 다뤘던 펑터의 개념에 이어 모나드에 대한 설명을 이어가보려고 한다. 아무래도 모나드라고 하면 가장 먼저 떠오르는 것은 “모나드는 내부함자 범주의 모노이드 대상 어쩌고”하는 설명인데, 사실 이것은 모나드를 가장 잘 설명하는 문장이면서도 가장 설명을 못하는 문장이기도 하다. 모나드를 이해하는 순간 모나드를 설명할 수 없게 되어버린다는 모나드의 저주라고 불리는 유명한 밈이 존재할만큼, 수학을 잘 모르는 입장에서는 참 이해하기 난해한 대상이기는 하다. 이에 필자도 야심차게 모나드를 설명하기 위한 도전을 한번 해보려고 한다. (물론 실패할 수도 있다…)","html":"<p>이번 포스팅에서는 이전에 다뤘던 펑터의 개념에 이어 모나드에 대한 설명을 이어가보려고 한다.</p>\n<p>아무래도 모나드라고 하면 가장 먼저 떠오르는 것은 “모나드는 내부함자 범주의 모노이드 대상 어쩌고”하는 설명인데, 사실 이것은 모나드를 가장 잘 설명하는 문장이면서도 가장 설명을 못하는 문장이기도 하다.</p>\n<p>모나드를 이해하는 순간 모나드를 설명할 수 없게 되어버린다는 모나드의 저주라고 불리는 유명한 밈이 존재할만큼, 수학을 잘 모르는 입장에서는 참 이해하기 난해한 대상이기는 하다.</p>\n<p>이에 필자도 야심차게 모나드를 설명하기 위한 도전을 한번 해보려고 한다. <small>(물론 실패할 수도 있다…)</small></p>\n<!-- more -->\n<h2 id=\"이전-글에서-다뤘던-것들\" style=\"position:relative;\">이전 글에서 다뤘던 것들<a href=\"#%EC%9D%B4%EC%A0%84-%EA%B8%80%EC%97%90%EC%84%9C-%EB%8B%A4%EB%A4%98%EB%8D%98-%EA%B2%83%EB%93%A4\" aria-label=\"이전 글에서 다뤘던 것들 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>일단 이전 글을 적은 것이 무려 6년 전이니, 이전 글의 내용을 간단히 복기하고 넘어가도록 하자. 자세한 내용은 <a href=\"/2020/01/27/safety-function-composition/\">이전 포스팅</a>을 참고하면 된다.</p>\n<p>뭐가 복잡하고 말이 많지만 결국 핵심은 간단하다. 함수형 프로그래밍의 세계에서 함수를 합성하려면 첫 번째 함수의 출력 타입과 다음 함수의 입력 타입이 일치해야 한다.</p>\n<p>하지만 문제는 프로그래밍의 세계에는 <code class=\"language-text\">null</code>, <code class=\"language-text\">undefined</code>, 에러 같은 불확실성이나 사이드 이펙트가 존재하기 때문에 이 규칙을 지키기가 쉽지 않다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getFirstLetter</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getStringLength</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// getFirstLetter의 치역이 string | undefined이므로</span>\n<span class=\"token comment\">// getStringLength와 바로 합성할 수 없다</span>\n<span class=\"token function\">getStringLength</span><span class=\"token punctuation\">(</span><span class=\"token function\">getFirstLetter</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 문제를 해결하기 위해 값과 사이드 이펙트를 컨테이너로 감싸는 개념을 도입했고, 그 컨테이너가 바로 함자, 영어로는 펑터(Functor)였다.</p>\n<p>즉, 펑터는 <code class=\"language-text\">map</code>이라는 연산을 통해 컨테이너 안의 값을 꺼내지 않고도 안전하게 변환할 수 있는 구조체라고 보면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">map: F&lt;A> → (A → B) → F&lt;B></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 타입 시그니처는 <code class=\"language-text\">F&lt;A></code>라는 펑터의 <code class=\"language-text\">map</code> 연산에 내부 값을 변환하는 계산인 <code class=\"language-text\">(A → B)</code>을 넘겨주면 결과적으로 내부 값이 변경되어 <code class=\"language-text\">F&lt;B></code>가 된다는 것을 의미한다.</p>\n<p>이때 <code class=\"language-text\">F&lt;A></code>와 <code class=\"language-text\">F&lt;B></code>는 내부 값이 바뀌었을지언정, 본래 가지고 있던 구조 자체가 변경되어서는 안되기 때문에 아래 두 가지 법칙을 만족해야한다.</p>\n<hr>\n<ol>\n<li>항등 법칙: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mtext>id</mtext><mo stretchy=\"false\">)</mo><mo>=</mo><mtext>id</mtext></mrow><annotation encoding=\"application/x-tex\">F(\\text{id}) = \\text{id}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">id</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">id</span></span></span></span></span></span></li>\n<li>합성 법칙: <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo>∘</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>∘</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(g \\circ f) = F(g) \\circ F(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span></span></li>\n</ol>\n<hr>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">id</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span></span></span></span></span>는 인자로 받은 값을 그대로 반환하는 항등 함수이다. 이 항등 함수에 매핑을 적용하면 아무 일도 발생하지 않아야하는 것이 항등 법칙이다.</p>\n<p>두 번째 합성 법칙은 합성된 함수를 매핑한 것과 각각의 함수를 따로 매핑하고 합성한 결과가 같아야 한다는 것을 의미한다.</p>\n<p>이 법칙들을 지켜야하는 이유는 단순한 수학적 결벽증 때문이 아니라, 이 법칙들을 지켜줘야 펑터가 “구조를 보존하는 사상”이라는 사실을 보장하기 때문이다.</p>\n<p>항등 법칙이 성립하면 <code class=\"language-text\">a.map(x => x)</code>가 정말로 아무것도 하지 않음을 신뢰할 수 있지만, 만약 이 과정에서 리스트의 순서라던가 트리의 높이와 같은 내부 구조가 변형된다면 이건 더 이상 매핑이 아니라 “재구성”이다. 즉, 항등 법칙은 펑터가 반드시 알맹이만 건드리고 껍데기는 건드리지 않는다는 신뢰의 기반이라고 할 수 있다.</p>\n<p>그리고 합성 법칙이 성립하면 <code class=\"language-text\">a.map(f).map(g)</code>를 <code class=\"language-text\">a.map(x => g(f(x)))</code>로 바꿔도 동작이 동일함을 보장받는다.</p>\n<p>이는 루프를 두 번 도는 <code class=\"language-text\">a.map(f).map(g)</code>을 <code class=\"language-text\">a.map(x => g(f(x)))</code>로 합쳐서 루프를 한 번만 돌아도 동작이 똑같다는 것을 보장하며, 반대로 복잡한 로직을 가독성을 위해 여러 개의 <code class=\"language-text\">map</code>으로 쪼개도 안전하다는 뜻이기도 하다.</p>\n<p>하지만 이 펑터에도 한계가 존재한다. 바로 이 한계로 인해 우리가 오늘 알아볼 모나드가 등장하게 된다.</p>\n<h2 id=\"펑터의-한계\" style=\"position:relative;\">펑터의 한계<a href=\"#%ED%8E%91%ED%84%B0%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"펑터의 한계 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>1988년, 에든버러 대학의 컴퓨터 과학자 에우제니오 모지(Eugenio Moggi)는 골치 아픈 문제와 씨름하고 있었다. 프로그램의 의미를 수학적으로 정의하는 의미론 연구를 하던 그는, 순수 람다 계산법과 현실 프로그램 사이의 간극을 어떻게 메울지 고민하고 있었다.</p>\n<p>순수 람다 계산법에서 타입 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>는 “입력 A를 받아 B를 돌려주는 전체 함수”를 의미한다. 수학적으로는 아주 깔끔하지만 사실 현실의 프로그램은 그렇지 않다.</p>\n<p>프로그램은 무한 루프에 빠질 수도 있고, 예외를 던질 수도 있고, 상태를 변경할 수도 있고, 파일을 읽을 수도 있기 때문이다. 이런 여러가지 “효과(effect)“를 발생시키는 프로그램을 순수 함수 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>로 보면 의미가 왜곡된다.</p>\n<p>그래서 모지는 프로그램을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 아니라 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\to T(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span></span>로 보자는 것에서 출발했다. 여기서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>는 “계산의 개념”을 담는 구조를 의미하며, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>라는 값을 결과로 내는 계산이라는 뜻이다. 값 자체가 아니라 값을 만들어내는 계산을 타입으로 표현하는 것이다.</p>\n<p>말로만 하면 어려우니 직접적인 예시를 한번 보자면, 우리에게 익숙한 계산들은 이런 것들이 있다.</p>\n<hr>\n<ul>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mtext>Maybe</mtext><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\to \\text{Maybe}(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Maybe</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span></span>: 실패할 수도 있는 계산</li>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mtext>IO</mtext><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\to \\text{IO}(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">IO</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span></span>: 외부 세계와 상호작용하는 계산</li>\n<li><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mtext>State</mtext><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\to \\text{State}(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">State</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span></span>: 상태를 변경하는 계산</li>\n</ul>\n<hr>\n<p>그런데 막상 이렇게 접근하자니 또 한 가지 문제가 발생한다. 바로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\to T(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span></span> 형태의 함수들을 합성하는 것이 까다로워진 것이다. 첫 함수가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\to T(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span></span>라면 두 번째 함수는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>→</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">B \\to T(C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>의 형태가 될텐데, 첫 번째 함수의 출력인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span></span>와 두 번째 함수의 입력 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 맞지 않는 문제가 발생한다.</p>\n<p>모지는 이 합성 문제를 해결하는 구조가 카테고리 이론에서 이미 연구되어 있다는 것을 발견했고, 그것이 바로 함수형 프로그래밍에서의 모나드의 시작이었다.</p>\n<p>이렇게 모지가 수학에서 빌려온 “모나드”라는 이름표가, 오늘날 컴퓨터 이론에서 가장 악명 높으면서도 강력한 추상화의 이름이 되었다.</p>\n<h4 id=\"왜-펑터로는-해결이-안될까\" style=\"position:relative;\">왜 펑터로는 해결이 안될까?<a href=\"#%EC%99%9C-%ED%8E%91%ED%84%B0%EB%A1%9C%EB%8A%94-%ED%95%B4%EA%B2%B0%EC%9D%B4-%EC%95%88%EB%90%A0%EA%B9%8C\" aria-label=\"왜 펑터로는 해결이 안될까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>그렇다면 모지의 고민은 왜 펑터만으로 해결이 어려운 것일까? 우리는 펑터의 <code class=\"language-text\">map</code>이 해결하지 못하는 두 가지 결정적인 병목 지점을 마주하게 된다.</p>\n<p>먼저 계산의 맥락인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span> 안에 함수가 갇혀버린 경우를 생각해보자. 이런 케이스를 발생시키는 대표적 예시로는 커링이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> maybeA<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> maybeB<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> map<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 펑터의 <code class=\"language-text\">map</code>을 사용하면 <code class=\"language-text\">maybeA</code>에 <code class=\"language-text\">add</code> 연산을 적용하여 다음 인자를 기다리는 함수를 만들어낼 수 있을까? 결론부터 말하자면 불가능하다. 왜냐하면 펑터의 <code class=\"language-text\">map</code>을 통해 적용된 연산의 결과가 그냥 함수가 아니기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> addA <span class=\"token operator\">=</span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>maybeA<span class=\"token punctuation\">,</span> add<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// map의 타입 시그니처에 대입해보면...</span>\nmap<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n  maybeNumber<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">add</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>일반적으로 커링된 함수를 사용하면 <code class=\"language-text\">addA</code>는 <code class=\"language-text\">(b: number) => number</code> 타입이 되어야겠지만, 여기서는 <code class=\"language-text\">map</code>을 사용하여 연산을 적용했으므로, 결과적으로 <code class=\"language-text\">Maybe&lt;(b: number) => number></code>라는 타입을 얻게 된다. 즉, 함수가 계산의 맥락 안에 갇혀버렸다.</p>\n<p>그런데 문제는 이렇게 되어버리면 쌩 함수만 인자로 받을 수 있는 펑터의 <code class=\"language-text\">map</code>을 사용하여 합성을 진행하는 것이 불가능해진다는 것이다. <code class=\"language-text\">map</code>은 맥락 밖의 함수를 맥락 안의 값에 적용할 뿐, 맥락 안에 갇힌 함수를 다른 맥락 안에 있는 값에게 전달할 방법이 없다.</p>\n<p>이것은 기본적으로 펑터의 <code class=\"language-text\">map</code>이 커링된 함수를 받을 때 바깥 쪽에 있는 함수에만 연산을 적용하기 때문이다. 커링된 함수처럼 함수가 함수를 반환하는 경우에는 안 쪽의 함수까지 닿을 수가 없다.</p>\n<p>그리고 또 다른 문제는 펑터를 반환하는 두 함수를 합성하는 상황 속에서 발생한다. 이번에도 “값이 있을 수도 있고 없을 수도 있다”를 의미하는 <code class=\"language-text\">Maybe</code> 펑터를 예시로 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> findUser<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> findTeam<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span>Team<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 함수들은 모지가 고안해냈던 입력 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>를 받아 계산 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span></span>를 반환하는 함수들을 의미한다.</p>\n<p><code class=\"language-text\">findUser</code> 함수는 유저의 아이디를 인자로 받아 <code class=\"language-text\">User</code>를 반환한다. 이때 이상한 아이디가 들어오면 매칭되는 유저가 없을 것이기 때문에 <code class=\"language-text\">Maybe</code> 펑터를 사용한 것이다. 그리고 <code class=\"language-text\">findTeam</code> 함수는 <code class=\"language-text\">User</code>를 인자로 받아 유저의 소속 팀을 반환한다. 우리는 이 두 함수를 합성해서 유저의 팀을 찾는 함수를 만드려고 한다.</p>\n<p>문제는 <code class=\"language-text\">findUser</code>가 반환하는 <code class=\"language-text\">Maybe&lt;User></code>를 <code class=\"language-text\">findTeam</code>이 바로 받아들일 수 없다는 것이다.</p>\n<p>하지만 펑터의 <code class=\"language-text\">map</code>을 사용하면 어찌저찌 합성을 해볼 수는 있다. 한번 합성을 진행해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token function\">findUser</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> findTeam<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// map의 타입 시그니처에 대입해보면...</span>\n<span class=\"token generic-function\"><span class=\"token function\">map</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>User<span class=\"token punctuation\">,</span> Maybe<span class=\"token operator\">&lt;</span>Team<span class=\"token operator\">>></span></span></span><span class=\"token punctuation\">(</span>maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> User<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Maybe<span class=\"token operator\">&lt;</span>Team<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span>Maybe<span class=\"token operator\">&lt;</span>Team<span class=\"token operator\">>></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>어찌어찌 합성은 성공했지만, 결과적으로 타입이 <code class=\"language-text\">Maybe&lt;Maybe&lt;Team>></code>이라는 슬픈 상황이 되어버렸다. 만약 여기서 팀 정보를 통해 팀장을 찾는 과정을 한 번 더 추가한다면 타입은 <code class=\"language-text\">Maybe&lt;Maybe&lt;Maybe&lt;Manager>>></code>와 같이 무한히 중첩될 것이다.</p>\n<h4 id=\"이-쯤에서-한번-정리해보자\" style=\"position:relative;\">이 쯤에서 한번 정리해보자<a href=\"#%EC%9D%B4-%EC%AF%A4%EC%97%90%EC%84%9C-%ED%95%9C%EB%B2%88-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"이 쯤에서 한번 정리해보자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>우리는 모지의 문제를 따라가면서 펑터로는 해결할 수 없는 두 가지의 문제에 직면했다.</p>\n<table>\n<thead>\n<tr>\n<th>문제</th>\n<th>원인</th>\n<th>필요한 것</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>맥락 안의 함수 적용</td>\n<td><code class=\"language-text\">map</code>은 바깥의 함수만 받음</td>\n<td>안의 함수를 안의 값에 적용하는 연산</td>\n</tr>\n<tr>\n<td>맥락 중첩</td>\n<td><code class=\"language-text\">map</code>은 한 겹만 벗김</td>\n<td>이중 맥락을 단일 맥락으로 펴는 연산</td>\n</tr>\n</tbody>\n</table>\n<center>\n <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 420px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/4142324907ddfda791bb342ea64416ec/65f94/head.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 73.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGZmVRLsCg//8QAGhAAAgIDAAAAAAAAAAAAAAAAAQIAAxIhI//aAAgBAQABBQI2rK06FZtSLSsR81//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAwEBPwGn/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bh//EABsQAAICAwEAAAAAAAAAAAAAAAABESECECJR/9oACAEBAAY/AqYoc+6g5oWR/8QAGRAAAgMBAAAAAAAAAAAAAAAAASEAEUEx/9oACAEBAAE/Ib+mKBBSo19ggUZR5dHYRBdTvYnHs//aAAwDAQACAAMAAAAQp9//xAAXEQADAQAAAAAAAAAAAAAAAAAAASEx/9oACAEDAQE/EM0TP//EABYRAQEBAAAAAAAAAAAAAAAAAAABYf/aAAgBAgEBPxDKx//EABwQAQADAAIDAAAAAAAAAAAAAAEAESExQVGB0f/aAAgBAQABPxB1FVie0GUWWTs+zQoJdVcWYCVwSPO4Mk9IxgEUPCOz/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"head\" title=\"\" src=\"/static/4142324907ddfda791bb342ea64416ec/65f94/head.jpg\" srcset=\"/static/4142324907ddfda791bb342ea64416ec/0913d/head.jpg 160w,\n/static/4142324907ddfda791bb342ea64416ec/cb69c/head.jpg 320w,\n/static/4142324907ddfda791bb342ea64416ec/65f94/head.jpg 420w\" sizes=\"(max-width: 420px) 100vw, 420px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n <small>펑터로 전부 해결할 수 있을 줄 알았는데 전혀 아니었다는 슬픈 결말</small>\n</center>\n<p>괜찮다. 문제는 해결하면 되니까. 이제 우리는 이 문제를 해결하기 위한 설계도를 차근차근 그려보려고 한다.</p>\n<p>이 중 첫 번째 문제인 맥락 안에 함수가 갇혀버린 상황은 어플리케이티브 펑터(Applicative Functor)라는 녀석으로 해결할 수 있고, 함수를 합성할 때마다 맥락이 계속 중첩되어 버린다는 문제를 바로 모나드(Monad)가 해결할 수 있다.</p>\n<h2 id=\"해결책-설계-어플리케이티브-펑터와-모나드\" style=\"position:relative;\">해결책 설계: 어플리케이티브 펑터와 모나드<a href=\"#%ED%95%B4%EA%B2%B0%EC%B1%85-%EC%84%A4%EA%B3%84-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%ED%8B%B0%EB%B8%8C-%ED%8E%91%ED%84%B0%EC%99%80-%EB%AA%A8%EB%82%98%EB%93%9C\" aria-label=\"해결책 설계 어플리케이티브 펑터와 모나드 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이제 우리는 첫 번째 문제를 해결하기 위해 새로운 연산을 발명해야 한다. 이제부터는 앞서 언급했던 “계산의 맥락”이라는 표현이 너무 기니, 간단하게 “컨테이너”라고 부르도록 하겠다.</p>\n<p>첫 번째 문제는 컨테이너 내부에 함수가 갇혀버린 상황이었으니, 이 함수를 다른 컨테이너 안에 있는 값에 적용할 수 있는 연산이 있으면 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// 컨테이너 안의 함수를 다른 컨테이너 안의 값에 적용한다\napply: T&lt;(A → B)> → T&lt;A> → T&lt;B></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 연산과 펑터의 <code class=\"language-text\">map</code>과 차이는 적용하려는 함수가 컨테이너 밖에 있느냐 안에 있느냐 뿐이다. 그리고 이 연산을 <code class=\"language-text\">apply</code>라고 부른다.</p>\n<p>그리고 이 함수를 값에 적용한 뒤 다시 컨테이너에 담아줘야 하는 연산도 필요하다. 이 연산은 <code class=\"language-text\">pure</code> 연산이라고 부른다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// 순수한 값을 컨테이너에 넣는다\npure: A → T&lt;A></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>그리고 이렇게 <code class=\"language-text\">apply</code>와 <code class=\"language-text\">pure</code> 연산을 갖춘 펑터를 어플리케이티브 펑터라고 부른다. 이번에도 우리에게 익숙한 <code class=\"language-text\">Maybe</code> 컨테이너를 예시로 들어 이 연산들을 타입스크립트 타입 시그니처로 표현해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> apply<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> f<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span>\n<span class=\"token keyword\">const</span> pure<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이제 이 어플리케이티브 펑터를 통해 앞서 우리가 겪었던 첫 번째 문제인 커링된 함수를 합성해보면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> maybeA<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> maybeB<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> maybeAddA <span class=\"token operator\">=</span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>maybeA<span class=\"token punctuation\">,</span> add<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Maybe&lt;(b: number) => number>;</span>\n\n<span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>maybeB<span class=\"token punctuation\">,</span> maybeAddA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Maybe&lt;number></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// apply의 타입 시그니처에 대입해보면...</span>\n<span class=\"token generic-function\"><span class=\"token function\">apply</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  f<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이제 우리는 어플리케이티브 펑터의 <code class=\"language-text\">apply</code>라는 연산을 통해 위 예시의 <code class=\"language-text\">maybeA</code>, <code class=\"language-text\">maybeB</code>와 같은 여러 개의 컨테이너를 동시에 다루는 문제를 우아하게 해결할 수 있게 되었다.</p>\n<h3 id=\"어플리케이티브-펑터의-한계\" style=\"position:relative;\">어플리케이티브 펑터의 한계<a href=\"#%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%ED%8B%B0%EB%B8%8C-%ED%8E%91%ED%84%B0%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"어플리케이티브 펑터의 한계 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>하지만 우리가 해결한 문제에는 중요한 전제가 하나 있다. 바로 어떤 상자들을 합성할지 미리 정해져 있어야 한다는 것이다.</p>\n<p>한번 어플리케이티브 펑터의 <code class=\"language-text\">apply</code> 연산 과정을 다시 떠올려보자. <code class=\"language-text\">maybeA</code>와 <code class=\"language-text\">maybeB</code>는 계산이 시작되기 전부터 이미 우리 손에 들려있는 독립적인 컨테이너들이다. 즉, 계산의 구조가 값과 상관없이 고정되어있다는 것이다.</p>\n<p>하지만 현실의 프로그램은 이보다 훨씬 동적인 경우가 많다. 이전 계산의 결과 값을 보고 나서야 다음에 어떤 컨테이너를 가져올지, 아니면 아예 컨테이너를 가져오지 않을지를 결정해야하는 상황이 훨씬 많다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// 유저를 찾고, 그 유저의 정보를 토대로 팀을 찾는다.</span>\n<span class=\"token comment\">// 즉, 팀을 찾는 함수는 유저가 누구냐에 따라 다른 결과를 내놓는다.</span>\n<span class=\"token function\">findUser</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>user <span class=\"token operator\">=></span> <span class=\"token function\">findTeam</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>teamId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>여기서 또 문제가 발생한다. <code class=\"language-text\">findTeam</code>이 반환하는 <code class=\"language-text\">Maybe</code> 컨테이너는 <code class=\"language-text\">user</code>라는 값에 의존하여 생성되기 때문이다. 즉, 이전 계산의 결과가 다음 계산의 맥락을 결정한다.</p>\n<p>어플리케이티브 펑터는 이미 존재하는 컨테이너끼리만 소통시킬 수 있기 때문에 이렇게 실행 중에 동적으로 만들어지는 순차적 의존성을 표현할 수가 없다.</p>\n<table>\n<thead>\n<tr>\n<th>정적(Static)</th>\n<th>동적(Dynamic)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>“A와 B를 각각 가져와서 합쳐라”</td>\n<td>“A를 가져오고, 그 결과를 보고 B를 할지 말지 정해라”</td>\n</tr>\n</tbody>\n</table>\n<p>결국 동적으로 만들어지는 순차적 의존성을 해결하려면 이전 계산의 결과물로 다음 계산(컨테이너)을 생성해야 하고, 이 과정에서 컨테이너가 중첩되는 것은 피할 수 없는 숙명이 된다.</p>\n<center>\n <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 282px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/298c3198f4c789d26495cbde7800fa25/822fd/oh.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 136.24999999999997%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGQAAAwADAAAAAAAAAAAAAAAAAAQFAQID/8QAFwEBAAMAAAAAAAAAAAAAAAAAAgADBf/aAAwDAQACEAMQAAABszaKIdUwMRJriVWjsciL/8QAGxABAQADAAMAAAAAAAAAAAAAAQIAAwQQETH/2gAIAQEAAQUC2qQe4vNtARQoidFrOF1OdP3x/8QAGBEAAgMAAAAAAAAAAAAAAAAAARADITL/2gAIAQMBAT8BApQ5X//EABURAQEAAAAAAAAAAAAAAAAAAAEg/9oACAECAQE/AWP/xAAeEAABBAIDAQAAAAAAAAAAAAABAAIQESEiMVFhgf/aAAgBAQAGPwLHKBD3Hu4ytjqrBtH0xhxC+z//xAAeEAACAgICAwAAAAAAAAAAAAABEQAhEEExYVFxsf/aAAgBAQABPyE7dFTlt4QhUsIxrfqN4tohAPInOAqA6jKTqBEI6M+rP//aAAwDAQACAAMAAAAQvwTy/8QAGBEBAAMBAAAAAAAAAAAAAAAAAQARIRD/2gAIAQMBAT8QvtXCaiDqT//EABgRAAMBAQAAAAAAAAAAAAAAAAABIRAR/9oACAECAQE/EGsxs6f/xAAfEAEBAAICAQUAAAAAAAAAAAABEQAhMUGhEGFxkfH/2gAIAQEAAT8Qa6AEWV2/WS094knfpCgRqdDnAN7uxl6rhpR4SmLy00ah/POPNPZdY0cGxAuJSLxDzjxh385//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"oh\" title=\"\" src=\"/static/298c3198f4c789d26495cbde7800fa25/822fd/oh.jpg\" srcset=\"/static/298c3198f4c789d26495cbde7800fa25/0913d/oh.jpg 160w,\n/static/298c3198f4c789d26495cbde7800fa25/822fd/oh.jpg 282w\" sizes=\"(max-width: 282px) 100vw, 282px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n <small>오 그렇다면 중첩된 컨테이너를 펴주는 연산이 있다면 어떨까?</small>\n</center>\n<p>어플리케이티브 펑터는 <code class=\"language-text\">apply</code>라는 새로운 연산을 통해 컨테이너 안의 함수를 실행했다. 하지만 만약 우리가 중첩을 평평하게 펴주는 도구를 갖게 된다면, 굳이 새로운 컨테이너 내부의 함수를 실행하는 번거로운 짓을 하지 않고도 이 문제를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> maybeA<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> maybeB<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// 중첩을 펴주는 녀석이 있다면 map만으로도 문제를 해결할 수 있다!</span>\n\n<span class=\"token comment\">// 1. 커링된 함수를 매핑하면 컨테이너에 담긴 함수가 나온다</span>\n<span class=\"token keyword\">const</span> maybePartialFn <span class=\"token operator\">=</span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>maybeA<span class=\"token punctuation\">,</span> add<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 결과: Maybe&lt;(b: number) => number></span>\n\n<span class=\"token comment\">// 2. map을 사용하여 컨테이너 안에 담긴 함수에 접근하고 계산 수행</span>\n<span class=\"token keyword\">const</span> nested <span class=\"token operator\">=</span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>maybePartialFn<span class=\"token punctuation\">,</span> fn <span class=\"token operator\">=></span> <span class=\"token function\">map</span><span class=\"token punctuation\">(</span>maybeB<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 결과: Maybe&lt;Maybe&lt;number>></span>\n\n<span class=\"token comment\">// 3. 그리고 중첩을 제거하면?</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">펴주는녀석</span><span class=\"token punctuation\">(</span>nested<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 결과: Maybe&lt;number></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>즉, 일단 합성해서 중첩시켜버리고 나중에 중첩을 펴버리면 되는 것이다.</p>\n<h3 id=\"모나드-중첩을-펴는-연산의-발명\" style=\"position:relative;\">모나드, 중첩을 펴는 연산의 발명<a href=\"#%EB%AA%A8%EB%82%98%EB%93%9C-%EC%A4%91%EC%B2%A9%EC%9D%84-%ED%8E%B4%EB%8A%94-%EC%97%B0%EC%82%B0%EC%9D%98-%EB%B0%9C%EB%AA%85\" aria-label=\"모나드 중첩을 펴는 연산의 발명 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>결국 모나드는 이러한 문제를 해결하기 위해 등장했다. 다시 말하자면 모나드는 컨테이너의 중첩을 펴는 연산을 가진 무언가이다.</p>\n<p>그리고 이렇게 중첩을 펴는 연산을 <code class=\"language-text\">join</code> 또는 <code class=\"language-text\">flatten</code>이라고 부른다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">join: T&lt;T&lt;A>> → T&lt;A></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> join<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span>Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">>></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>즉, <code class=\"language-text\">join</code> 연산은 <code class=\"language-text\">Maybe&lt;Maybe&lt;A>></code>를 <code class=\"language-text\">Maybe&lt;A></code>로 만든다. 수학적으로는 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>를 두 번 적용한 것을 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span> 한 번으로 줄이는 것”이다.</p>\n<p>사실 이러한 연산은 우리 주변에서도 쉽게 찾아볼 수 있는데, 바로 JavaScript의 <code class=\"language-text\">Array.prototype.flat</code>이 바로 이러한 역할을 한다.</p>\n<p>그리고 어플리케이티브 펑터와 마찬가지로 순수한 값을 컨테이너에 넣어주는 연산도 필요하다. 이 연산은 어플리케이티브 펑터와 마찬가지로 <code class=\"language-text\">pure</code>라고 부르거나, <code class=\"language-text\">of</code>라고 부르기도 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">pure: A → T&lt;A></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> pure<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>하지만 실제 프로그래밍에서 <code class=\"language-text\">join</code>을 직접 쓰는 일은 거의 없다. 앞선 예시에서 보았듯이 모나드는 <code class=\"language-text\">map</code>을 사용하여 컨테이너 안에 담긴 무언가에 접근하여 합성을 진행하고 <code class=\"language-text\">join</code>을 이용해서 중첩을 다시 펴는 것이 한 세트로 작동하기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">1. 컨테이너 안의 값에 함수를 적용하고 싶다 = map을 쓴다\n2. 그런데 그 함수가 결과를 컨테이너에 담아서 반환한다 = 이중 포장이 된다\n3. 이중 포장을 벗겨야 한다 = join을 쓴다</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그래서 우리는 이 두 가지 연산을 하나로 합쳐 좀 더 편리하게 사용하려고 한다.</p>\n<h4 id=\"flatmap--map--join\" style=\"position:relative;\">flatMap = map + join<a href=\"#flatmap--map--join\" aria-label=\"flatmap  map  join permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>매번 <code class=\"language-text\">map</code> 다음에 <code class=\"language-text\">join</code>을 부르는 것이 번거로우니, 이 두 단계를 하나로 합친 것이 <code class=\"language-text\">flatMap</code>이다. 이번에도 마찬가지로 우리에게 친숙한 <code class=\"language-text\">Maybe</code> 컨테이너를 받는 <code class=\"language-text\">flatMap</code>이 어떤 타입 시그니처로 표현되는지 알아보도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">map:     T&lt;A> → (A → B)    → T&lt;B>     // 일반 함수를 적용\nflatMap: T&lt;A> → (A → T&lt;B>) → T&lt;B>     // 컨테이너 반환 함수를 적용 + 펴기</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> map<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> flatMap<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">map</code>과 <code class=\"language-text\">flatMap</code>의 차이점은 두 번째 인자에 있다. <code class=\"language-text\">map</code>은 단순히 <code class=\"language-text\">A => B</code> 형태의 함수를 받지만, <code class=\"language-text\">flatMap</code>은 <code class=\"language-text\">(A => Maybe&lt;B>)</code> 형태의 함수를 받는다.</p>\n<p>타입시그니처로는 표현되지 않았지만 내부적으로 <code class=\"language-text\">flatMap</code>은 <code class=\"language-text\">join</code>의 역할까지 하고 있기 때문에 결과 타입은 <code class=\"language-text\">Maybe&lt;Maybe&lt;B>></code>와 같은 슬픈 형태가 아니라 <code class=\"language-text\">Maybe&lt;B></code>가 되는 것이다.</p>\n<p>이제 우리는 이 <code class=\"language-text\">flatMap</code>을 사용하여 계산들 간의 순차적 의존성을 표현할 수 있게 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// map을 쓰면 결과 타입이 중첩됨</span>\n<span class=\"token function\">findUser</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>user <span class=\"token operator\">=></span> <span class=\"token function\">findDepartment</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>deptId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Maybe&lt;Maybe&lt;Department>></span>\n\n<span class=\"token comment\">// flatMap을 쓰면 해결</span>\n<span class=\"token function\">findUser</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>user <span class=\"token operator\">=></span> <span class=\"token function\">findDepartment</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>deptId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Maybe&lt;Department></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기까지 펑터의 <code class=\"language-text\">map</code>, 어플리케이티브 펑터의 <code class=\"language-text\">apply</code>, 모나드의 <code class=\"language-text\">flatMap</code>에 대해서 알아보았다. 분량이 워낙 많았으니 한번 다시 정리하고 넘어가보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token comment\">// 펑터의 map</span>\n<span class=\"token keyword\">const</span> map<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 어플리케이티브 펑터의 apply</span>\n<span class=\"token keyword\">const</span> apply<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> f<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span>\n\n<span class=\"token comment\">// 모나드의 flatMap</span>\n<span class=\"token keyword\">const</span> flatMap<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>먼저 <code class=\"language-text\">map</code>은 컨테이너 안에 있는 값에 일반 함수를 적용하는 녀석이다. 하지만 이것만으로는 컨테이너 내부에 갇힌 함수는 사용할 수 없다는 문제가 발생한다.</p>\n<p>그래서 <code class=\"language-text\">apply</code>가 등장했다. <code class=\"language-text\">apply</code>는 컨테이너 내부에 있는 함수에 접근할 수 있도록 만들어줘서 이런 상황일 때도 계산의 합성이 가능하도록 만들어주었다. 하지만 결국 순차적 의존성을 가진 동적인 계산을 진행하면 컨테이너가 중첩된다는 문제가 발생했다.</p>\n<p>이를 해결하기 위해 중첩된 연산을 펴주는 <code class=\"language-text\">join</code>과 펑터의 <code class=\"language-text\">map</code>이 합쳐진 <code class=\"language-text\">flatMap</code>이 등장했다. 우리는 이제 이 연산을 통해 앞 결과에 의해 다음 계산을 결정하는 순차적 의존성을 가진 계산도 자유롭게 합성할 수 있게 되었다.</p>\n<h2 id=\"법칙은-리팩토링에-대한-증명\" style=\"position:relative;\">법칙은 리팩토링에 대한 증명<a href=\"#%EB%B2%95%EC%B9%99%EC%9D%80-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A6%9D%EB%AA%85\" aria-label=\"법칙은 리팩토링에 대한 증명 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그렇다면 <code class=\"language-text\">flatMap</code>은 정말 우리가 함수를 안전하게 합성할 수 있게 만들어주는 마법인걸까? 글쎄, 이것을 자신있게 이야기하기 위해서는 <code class=\"language-text\">flatMap</code>이 지켜줘야하는 몇 가지 법칙이 존재한다.</p>\n<h3 id=\"세-가지-법칙\" style=\"position:relative;\">세 가지 법칙<a href=\"#%EC%84%B8-%EA%B0%80%EC%A7%80-%EB%B2%95%EC%B9%99\" aria-label=\"세 가지 법칙 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>우리가 <code class=\"language-text\">flatMap</code>을 자유롭게 사용하기 위해 이 연산은 아래 법칙을 지켜준다는 것이 보장되어야 한다.</p>\n<h4 id=\"결합-법칙-어느-층부터-합쳐도-같아야-한다\" style=\"position:relative;\">결합 법칙: 어느 층부터 합쳐도 같아야 한다<a href=\"#%EA%B2%B0%ED%95%A9-%EB%B2%95%EC%B9%99-%EC%96%B4%EB%8A%90-%EC%B8%B5%EB%B6%80%ED%84%B0-%ED%95%A9%EC%B3%90%EB%8F%84-%EA%B0%99%EC%95%84%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"결합 법칙 어느 층부터 합쳐도 같아야 한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>가장 먼저 결합 법칙이다. 즉, 중첩을 펼 때, 어느 쪽부터 펴든 결과가 같아야 한다는 것을 의미한다. 한번 <code class=\"language-text\">Maybe&lt;Maybe&lt;Maybe&lt;A>>></code>처럼 삼중의 계산으로 감싸진 컨테이너가 있다고 생각해보자.</p>\n<p>우리는 이제 이 컨테이터를 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span></span>형태로 만들기 위해 중첩을 펴내야 한다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>→</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>→</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(T(T(A))) \\to T(T(A)) \\to T(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span></span></div>\n<p>이 중첩을 펴서 한 겹으로 만드는 방법은 두 가지다. 첫 번째 방법은 안쪽 두 개의 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>를 먼저 합친 다음, 바깥 쪽에 남은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>를 벗겨내 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span></span>로 만드는 방법이다. 그리고 두 번째 방법은 바깥에 있는 두 개의 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>를 합친 다음, 안 쪽에 남은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>를 벗기는 방법이다.</p>\n<p>이 중 어떤 순서로 연산을 수행하던 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span></span>라는 최종 결과는 같아야 한다는 것이 바로 결합법칙이다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>μ</mi><mo>∘</mo><mi>T</mi><mi>μ</mi><mo>=</mo><mi>μ</mi><mo>∘</mo><mi>μ</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\mu \\circ T\\mu = \\mu \\circ \\mu T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\">m<span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> m<span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=></span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 수식에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span></span>(뮤)는 <code class=\"language-text\">join</code>을 의미한다.</p>\n<p>여기서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">T\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">μ</span></span></span></span></span>는 “안쪽 두 겹”을 합치는 것이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\mu T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>는 “바깥쪽 두 겹”을 합치는 것이라고 보면 된다. 즉, 3층 마트료시카를 2층으로 줄일 때, 안쪽 인형들을 먼저 합치느냐 바깥쪽 인형들을 먼저 합치느냐의 차이가 없어야 한다는 것이다.</p>\n<h4 id=\"좌단위-법칙-입구에서-장난치지-말자\" style=\"position:relative;\">좌단위 법칙: 입구에서 장난치지 말자<a href=\"#%EC%A2%8C%EB%8B%A8%EC%9C%84-%EB%B2%95%EC%B9%99-%EC%9E%85%EA%B5%AC%EC%97%90%EC%84%9C-%EC%9E%A5%EB%82%9C%EC%B9%98%EC%A7%80-%EB%A7%90%EC%9E%90\" aria-label=\"좌단위 법칙 입구에서 장난치지 말자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>두 번째는 좌단위 법칙이다. 이 법칙은 넣었다가 바로 벗기면 아무 일도 없었던 것과 동일한 상태여야한다는 것을 의미한다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>μ</mi><mo>∘</mo><mi>T</mi><mi>η</mi><mo>=</mo><mtext>id</mtext></mrow><annotation encoding=\"application/x-tex\">\\mu \\circ T\\eta = \\text{id}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">id</span></span></span></span></span></span></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token function\">pure</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 수식에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span></span>(에타)는 <code class=\"language-text\">pure</code>를 의미한다.</p>\n<p>여기서 특히 주목해야 할 부분은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span></span> 앞에 붙은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">T\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span></span>)인데, 이는 상자 바깥이 아니라 이미 상자에 담겨 있는 내부의 값에 <code class=\"language-text\">pure</code>를 적용하라는 뜻이다.</p>\n<p>즉, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span></span>라는 컨테이너가 있을 때 내부의 알맹이 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>를 <code class=\"language-text\">pure</code>로 감싸서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(T(A))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">))</span></span></span></span></span>라는 이중 구조를 만든 뒤, 이를 다시 <code class=\"language-text\">join</code>(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span></span>)으로 펴내면 원래의 상태(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>id</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{id}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">id</span></span></span></span></span></span>)로 돌아와야 한다는 법칙이다.</p>\n<p>이 법칙이 보장되어야 우리는 컨테이너 내부에서 일어나는 계산의 최소 단위인 <code class=\"language-text\">pure</code> 연산을 신뢰할 수 있다. 만약 이 좌단위 법칙이 깨진다는 것은 <code class=\"language-text\">pure</code>가 단순히 값을 감싸는 것을 넘어 내부적으로 로직을 변형시키고 있다는 것을 의미하기 때문이다.</p>\n<h4 id=\"우단위-법칙-포장지만-바꿨다면-알맹이는-그대로\" style=\"position:relative;\">우단위 법칙: 포장지만 바꿨다면 알맹이는 그대로<a href=\"#%EC%9A%B0%EB%8B%A8%EC%9C%84-%EB%B2%95%EC%B9%99-%ED%8F%AC%EC%9E%A5%EC%A7%80%EB%A7%8C-%EB%B0%94%EA%BF%A8%EB%8B%A4%EB%A9%B4-%EC%95%8C%EB%A7%B9%EC%9D%B4%EB%8A%94-%EA%B7%B8%EB%8C%80%EB%A1%9C\" aria-label=\"우단위 법칙 포장지만 바꿨다면 알맹이는 그대로 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>세 번째는 우단위 법칙이다. 이는 좌단위 법칙과 유사하지만, 컨테이너를 씌우는 순서가 반대다.</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>μ</mi><mo>∘</mo><mi>η</mi><mi>T</mi><mo>=</mo><mtext>id</mtext></mrow><annotation encoding=\"application/x-tex\">\\mu \\circ \\eta T = \\text{id}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">id</span></span></span></span></span></span></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\">m<span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>pure<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> m</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\eta T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>는 이미 존재하는 컨테이너 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span></span> 자체를 하나의 값으로 간주하고, 그 바깥을 pure(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span></span>)로 한 번 더 감싸는 행위를 의미한다. 결과적으로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\eta(T(A))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">))</span></span></span></span></span>가 되어 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(T(A))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">))</span></span></span></span></span>라는 이중 구조가 만들어지는 것이다.</p>\n<p>우단위 법칙이 말하고자 하는 핵심은 명확하다. 상자 바깥을 <code class=\"language-text\">pure</code>로 한 겹 더 감싼 뒤(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\eta T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>), 다시 <code class=\"language-text\">join</code>(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span></span>)으로 그 겉껍데기를 벗겨내면 결국 처음의 상태(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>id</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{id}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">id</span></span></span></span></span></span>)와 동일해야 한다는 것이다.</p>\n<p>앞서 언급했듯이 이 단위 법칙들이 중요한 이유는 <code class=\"language-text\">pure</code>라는 연산이 맥락을 왜곡하지 않는 항등원임을 보장하기 때문이다.</p>\n<p>마치 우리가 숫자에 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span>을 더해도 값이 변하지 않듯, 어떤 컨테이너를 <code class=\"language-text\">pure</code>로 감싸고 다시 펴는 행위는 그 컨테이너가 가진 원래의 정보나 상태에 아무런 영향을 주지 않아야 한다.</p>\n<h2 id=\"다시-내부함자-범주의-모노이드-대상으로\" style=\"position:relative;\">다시 “내부함자 범주의 모노이드 대상”으로<a href=\"#%EB%8B%A4%EC%8B%9C-%EB%82%B4%EB%B6%80%ED%95%A8%EC%9E%90-%EB%B2%94%EC%A3%BC%EC%9D%98-%EB%AA%A8%EB%85%B8%EC%9D%B4%EB%93%9C-%EB%8C%80%EC%83%81%EC%9C%BC%EB%A1%9C\" aria-label=\"다시 내부함자 범주의 모노이드 대상으로 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 그렇다면 이것이 위키에 나와있는 모나드의 정의인 “내부함자 범주의 모노이드 대상”과 무슨 관련이 있는 것일까?</p>\n<p>여기서부터는 추상적이고 수학적인 이야기가 많이 나오니, 실무적인 수준으로 모나드를 이해하는 것만으로도 충분한 독자들은 건너뛰어도 된다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9e58e5b0f155e0d74c064038ab30b02d/10fd8/hard.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 54.37499999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAABAAF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQAC/9oADAMBAAIQAxAAAAFmfoFNBm0//8QAGhAAAgMBAQAAAAAAAAAAAAAAAQIDESEAMv/aAAgBAQABBQLB3uUrIDevjBjX/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEREv/aAAgBAwEBPwFKmD//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEv/aAAgBAgEBPwFT/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEQIRH/2gAIAQEABj8CHwxzJ//EABoQAQACAwEAAAAAAAAAAAAAAAEAETFBcSH/2gAIAQEAAT8hHaG455pvXkRCByWTbDfhyZhn/9oADAMBAAIAAwAAABCDD//EABcRAQADAAAAAAAAAAAAAAAAAAABESH/2gAIAQMBAT8Qiyu//8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EFyP/8QAHBABAAICAwEAAAAAAAAAAAAAAQARITFBUWGR/9oACAEBAAE/EChAOWeXcQBa1HEVv7LKs4tfsBiJ1xqF1PxF2se0Gf/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"hard\" title=\"\" src=\"/static/9e58e5b0f155e0d74c064038ab30b02d/c08c5/hard.jpg\" srcset=\"/static/9e58e5b0f155e0d74c064038ab30b02d/0913d/hard.jpg 160w,\n/static/9e58e5b0f155e0d74c064038ab30b02d/cb69c/hard.jpg 320w,\n/static/9e58e5b0f155e0d74c064038ab30b02d/c08c5/hard.jpg 640w,\n/static/9e58e5b0f155e0d74c064038ab30b02d/10fd8/hard.jpg 942w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>하지만 운동 많이 될테니 그래도 한번 읽어보는 것을 추천한다</small>\n</center>\n<p>사실 앞서 말했듯이 모나드는 처음부터 수학자들이 “이런 걸 써라”하고 던져준 것이 아니다. 오히려 공학적인 필요에 의해 안전하게 함수를 합성하는 방법을 찾다 보니, 아래와 같은 도구들이 필연적으로 발명된 것에 가깝다.</p>\n<table>\n<thead>\n<tr>\n<th>발명된 것</th>\n<th>설명</th>\n<th>예시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></td>\n<td>타입을 받아서 새로운 타입을 만드는 타입 생성자</td>\n<td><code class=\"language-text\">Maybe&lt;A></code>, <code class=\"language-text\">Array&lt;A></code>, …</td>\n</tr>\n<tr>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span></span>(에타)</td>\n<td>값을 컨테이너에 넣는 연산</td>\n<td><code class=\"language-text\">pure</code>, <code class=\"language-text\">Promise.resolve</code>, …</td>\n</tr>\n<tr>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span></span>(뮤)</td>\n<td>중첩된 컨테이너를 단일 컨테이너로 펴는 연산</td>\n<td><code class=\"language-text\">join</code>, <code class=\"language-text\">flatten</code>, …</td>\n</tr>\n</tbody>\n</table>\n<p>그리고 이 연산들을 우리가 안전하게 사용하기 위해서는 앞서 살펴본 세 가지 법칙(결합, 좌단위, 우단위)을 지켜야 한다고 했다. 이제 이 구조를 수학적으로 분석해 보면 아주 흥미로운 지점에 도달하게 된다.</p>\n<h3 id=\"범주category-대상과-화살표의-세계\" style=\"position:relative;\">범주(Category): 대상과 화살표의 세계<a href=\"#%EB%B2%94%EC%A3%BCcategory-%EB%8C%80%EC%83%81%EA%B3%BC-%ED%99%94%EC%82%B4%ED%91%9C%EC%9D%98-%EC%84%B8%EA%B3%84\" aria-label=\"범주category 대상과 화살표의 세계 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>범주(Category)는 대상(Object)과 대상 사이의 사상(Morphism, 화살표)으로 이루어진 구조다. 필자는 개인적으로 범주보다는 카테고리라는 단어가 더 익숙하므로, 앞으로 카테고리라고 부르도록 하겠다.</p>\n<p>우선 TypeScript 관점에서 가장 친숙한 카테고리는 타입의 카테고리다. 타입의 카테고리에서 대상은 <code class=\"language-text\">number</code>, <code class=\"language-text\">string</code>과 같은 타입들이고 사상은 <code class=\"language-text\">(a: number) => string</code>과 같이 한 대상에서 다른 대상으로 나아가는 계산, 함수이다.</p>\n<p>카테고리와 함자(Functor)에 대한 자세한 내용은 <a href=\"/2020/01/27/safety-function-composition/\">이전 포스팅</a>에 수록되어있으므로, 한번 읽고 오는 것을 추천한다.</p>\n<h3 id=\"내부함자endofunctor-같은-세계-안에서-도는-펑터\" style=\"position:relative;\">내부함자(Endofunctor): 같은 세계 안에서 도는 펑터<a href=\"#%EB%82%B4%EB%B6%80%ED%95%A8%EC%9E%90endofunctor-%EA%B0%99%EC%9D%80-%EC%84%B8%EA%B3%84-%EC%95%88%EC%97%90%EC%84%9C-%EB%8F%84%EB%8A%94-%ED%8E%91%ED%84%B0\" aria-label=\"내부함자endofunctor 같은 세계 안에서 도는 펑터 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그렇다면 모나드의 정의 중 “내부함자 범주의…”라는 것은 결국 내부함자(Endofunctor)로 이루어진 카테고리라는 의미이다.</p>\n<p>이전 포스팅에 간단하게 적어놓았지만 함자, 즉 펑터는 어떤 카테고리를 다른 카테고리로 나아가게 만들어주는 사상이다. 일반적인 펑터는 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>에서 다른 카테고리 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span>로 매핑하지만, 내부함자, 엔도펑터는 출발지와 도착지가 같은 범주인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">T: C \\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>라는 것을 의미한다.</p>\n<p>왜 모나드는 “내부함자 카테고리”의 대상인 것일까? 그 이유는 우리가 프로그래밍 세계 안에서 사용하는 펑터는 결국 프로그래밍 세계에서만 돌고 있기 때문이다. 예를 들어 펑터의 <code class=\"language-text\">map</code> 연산을 한번 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> map<span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>maybe<span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Maybe<span class=\"token operator\">&lt;</span><span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 타입 시그니처를 보면 <code class=\"language-text\">map</code> 함수는 <code class=\"language-text\">A</code>를 받아 <code class=\"language-text\">B</code>로 나아가는 것을 볼 수 있다. 중요한 점은 <code class=\"language-text\">A</code>도 결국 타입스크립트의 타입 시스템에 있는 타입이고, 결과 타입인 <code class=\"language-text\">Maybe&lt;B></code>도 타입스크립트의 타입 시스템에 있는 타입이라는 것이다.</p>\n<p>즉, 타입의 세계에서 타입의 세계로 향한다. 이것이 프로그래밍에서 사용하는 펑터가 엔도펑터(내부함자)인 이유이다. 다른 세계로 가는 것이 아니라 같은 세계 안에서 변환하기 때문이다.</p>\n<h3 id=\"내부함자-범주-펑터들-자체가-대상인-세계\" style=\"position:relative;\">내부함자 범주: 펑터들 자체가 대상인 세계<a href=\"#%EB%82%B4%EB%B6%80%ED%95%A8%EC%9E%90-%EB%B2%94%EC%A3%BC-%ED%8E%91%ED%84%B0%EB%93%A4-%EC%9E%90%EC%B2%B4%EA%B0%80-%EB%8C%80%EC%83%81%EC%9D%B8-%EC%84%B8%EA%B3%84\" aria-label=\"내부함자 범주 펑터들 자체가 대상인 세계 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>자 그럼 이제 추상화를 한 단계 올려보자. 프로그래밍에서 사용하는 펑터들이 엔도펑터라는 사실을 알았다면 이제는 엔도펑터들 자체를 대상으로 놓는 새로운 카테고리를 생각할 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>일반 타입 카테고리</th>\n<th>엔도펑터 카테고리</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>대상</td>\n<td><code class=\"language-text\">number</code>, <code class=\"language-text\">string</code>, …</td>\n<td><code class=\"language-text\">Maybe</code>, <code class=\"language-text\">Array</code>, <code class=\"language-text\">Promise</code>, …</td>\n</tr>\n<tr>\n<td>사상</td>\n<td><code class=\"language-text\">(a: A) => B</code></td>\n<td>펑터 → 펑터</td>\n</tr>\n</tbody>\n</table>\n<p>카테고리의 사상은 어떠한 대상에서 다른 대상으로 나아가는 것이니, 엔도펑터 카테고리에서의 사상은 펑터에서 다른 펑터로 나아가는 것이라고 생각해볼 수 있다.</p>\n<p>그리고 이렇게 펑터를 다른 펑터로 바꾸는 사상을 우리는 <a href=\"https://ko.wikipedia.org/wiki/%EC%9E%90%EC%97%B0_%EB%B3%80%ED%99%98\" target=\"_blank\" rel=\"nofollow\">자연 변환(Natural Transformation)</a>이라고 부른다.</p>\n<h3 id=\"모노이드monoid-대상-합치기의-대수학\" style=\"position:relative;\">모노이드(Monoid) 대상: 합치기의 대수학<a href=\"#%EB%AA%A8%EB%85%B8%EC%9D%B4%EB%93%9Cmonoid-%EB%8C%80%EC%83%81-%ED%95%A9%EC%B9%98%EA%B8%B0%EC%9D%98-%EB%8C%80%EC%88%98%ED%95%99\" aria-label=\"모노이드monoid 대상 합치기의 대수학 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>여기까지 모나드의 정의 중 “내부함자 범주의…”라는 내용을 살펴봤다면, 이제 “모노이드 대상이다”라는 말이 어떤 의미인지 살펴보자.</p>\n<p>수학에서 모노이드라는 것은 다음 세 가지를 갖춘 구조를 의미한다.</p>\n<hr>\n<ol>\n<li>집합 또는 대상들의 모임</li>\n<li>이항 연산: 두 원소를 합쳐서 같은 집합 안에 들어있는 원소를 만든다. 반드시 결합 법칙을 만족해야한다.</li>\n<li>항등원: 어떤 원소와 연산해도 그 원소를 그대로 반환하는 특별한 원소.</li>\n</ol>\n<hr>\n<p>개념이 워낙 추상적이라 조금 어렵게 느껴질 수 있지만 막상 예시를 그렇게 복잡하지 않다. 가장 대표적인 모노이드는 정수와 덧셈의 관계이다.</p>\n<p>정수와 덧셈에서 덧셈은 정수 집합의 두 원소를 뽑아와 연산하면 정수 집합의 원소를 다시 반환한다. 마치 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">1 + 2 = 3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span>처럼 말이다. 그리고 이미 독자 분들도 알다시피 덧셈은 결합 법칙을 만족한다. 그리고 마지막으로 어떤 정수와 더해도 그 정수를 그대로 반환하는 녀석인 항등원은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span>이다.</p>\n<p>이러한 이유로 정수와 덧셈을 묶은 세트는 “모노이드”라고 부를 수 있는 것이고 수학적으로는 정수 집합 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span></span>과 덧셈 기호를 묶어 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mo separator=\"true\">,</mo><mo>+</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathbb{Z}, +)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">Z</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mclose\">)</span></span></span></span></span>라고 표기한다. <small>(정확하게는 덧셈에 대한 정수군에는 역원도 존재하지만, 이 설명에서 중요한 것은 아니니 넘어가겠다)</small></p>\n<h3 id=\"연결점-모나드는-내부함자-범주의-모노이드-대상\" style=\"position:relative;\">연결점: 모나드는 내부함자 범주의 모노이드 대상<a href=\"#%EC%97%B0%EA%B2%B0%EC%A0%90-%EB%AA%A8%EB%82%98%EB%93%9C%EB%8A%94-%EB%82%B4%EB%B6%80%ED%95%A8%EC%9E%90-%EB%B2%94%EC%A3%BC%EC%9D%98-%EB%AA%A8%EB%85%B8%EC%9D%B4%EB%93%9C-%EB%8C%80%EC%83%81\" aria-label=\"연결점 모나드는 내부함자 범주의 모노이드 대상 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>자 모노이드가 무엇인지 이해했다면 이제 드디어 “내부함자 범주의 모노이드 대상”이 무슨 뜻인지를 이해할 수 있게 된다.</p>\n<p>일단 내부함자(Endofunctor) 범주는 <code class=\"language-text\">Maybe</code>, <code class=\"language-text\">Promise</code>와 같은 프로그래밍에서의 펑터들로 이루어진 카테고리를 의미하니, 이 친구들이 모노이드 구조를 갖춘 대상이 맞는지를 살펴보면 될 것 같다.</p>\n<p>앞서 언급했던 대표적인 모노이드인 정수 집합과 덧셈의 관계, 그리고 엔도펑터와 합성 연산 간의 관계를 비교해보자.</p>\n<table>\n<thead>\n<tr>\n<th>모노이드 요소</th>\n<th>정수 덧셈</th>\n<th>내부함자 범주</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>이항 연산</td>\n<td><code class=\"language-text\">+</code> (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">1 + 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span></span>)</td>\n<td>합성 <code class=\"language-text\">∘</code> (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>∘</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T \\circ T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>)</td>\n</tr>\n<tr>\n<td>연산의 결과</td>\n<td>정수</td>\n<td>내부함자</td>\n</tr>\n<tr>\n<td>항등원</td>\n<td><code class=\"language-text\">0</code></td>\n<td>항등 함자 <code class=\"language-text\">Id</code></td>\n</tr>\n</tbody>\n</table>\n<p>이렇게 비교해보니 얼추 비슷해보이긴 한다. 하지만 문제가 하나 있는데, 바로 엔도펑터들의 이항 연산인 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>∘</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T \\circ T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>의 결과는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span></span>가 아니라 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(T(A))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">))</span></span></span></span></span>처럼 중첩된 결과라는 것이다. 즉, 같은 집합 안에 있는 원소가 아니다.</p>\n<p>여기서 바로 아까 정의한 모나드의 <code class=\"language-text\">join</code>(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span></span>)과 <code class=\"language-text\">pure</code>(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span></span>)가 등장한다.</p>\n<table>\n<thead>\n<tr>\n<th>연산</th>\n<th>표현</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">join</code> (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span></span>)</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>∘</mo><mi>T</mi><mo>⇒</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T \\circ T \\Rightarrow T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></td>\n<td>두 겹의 T를 하나의 T로 합치는 자연변환</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">pure</code> (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span></span>)</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Id</mtext><mo>⇒</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\text{Id} \\Rightarrow T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">Id</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></td>\n<td>항등 함자에서 T로 가는 자연변환</td>\n</tr>\n</tbody>\n</table>\n<p>자연변환이란 펑터 사이의 “구조를 보존하는 변환”이다. <code class=\"language-text\">pure</code>가 단순히 값을 컨테이너에 넣는 녀석이 아니라 자연변환이라는 점이 중요하다. 이는 <code class=\"language-text\">pure</code>가 어떤 타입 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>에 대해서든 일관된 방식으로 동작해야 함을 의미한다. 즉, 타입에 따라 동작이 달라지면 안 된다.</p>\n<p>그리고 앞서 살펴봤던 모나드의 법칙들을 다시 살펴보면, 이 법칙들이 모노이드가 요구하는 결합 법칙과 항등원에 대한 법칙을 만족한다는 사실을 알 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>법칙</th>\n<th>표현</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>결합 법칙</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mo>∘</mo><mi>T</mi><mi>μ</mi><mo>=</mo><mi>μ</mi><mo>∘</mo><mi>μ</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\mu \\circ T\\mu = \\mu \\circ \\mu T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></td>\n<td>어떤 순서로 합치든 같다</td>\n</tr>\n<tr>\n<td>단위 법칙</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mo>∘</mo><mi>T</mi><mi>η</mi><mo>=</mo><mi>i</mi><mi>d</mi><mo>=</mo><mi>μ</mi><mo>∘</mo><mi>η</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\mu \\circ T\\eta = id = \\mu \\circ \\eta T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></td>\n<td>넣었다 빼면 원래대로 돌아온다. 즉, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span></span>는 항등원이다.</td>\n</tr>\n</tbody>\n</table>\n<p>이처럼 우리가 프로그래밍에서 연산의 결과를 일관되게 보장하기 위해 세웠던 법칙들이 모노이드가 요구하는 것들과 정확하게 일치하는 것을 볼 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>정수의 모노이드</th>\n<th>내부함자 범주의 모노이드 (= 모나드)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>대상</td>\n<td>정수</td>\n<td>내부함자 (<code class=\"language-text\">Maybe</code>, <code class=\"language-text\">Array</code>, …)</td>\n</tr>\n<tr>\n<td>이항 연산</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo></mrow><annotation encoding=\"application/x-tex\">+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">+</span></span></span></span></span></td>\n<td><code class=\"language-text\">join</code> (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span></span>) (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>∘</mo><mi>T</mi><mo>⇒</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T \\circ T \\Rightarrow T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>)</td>\n</tr>\n<tr>\n<td>항등원</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></td>\n<td><code class=\"language-text\">pure</code> (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span></span>) (<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Id</mtext><mo>⇒</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\text{Id} \\Rightarrow T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">Id</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span>)</td>\n</tr>\n<tr>\n<td>결합 법칙</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>c</mi><mo>=</mo><mi>a</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(a+b)+c = a+(b+c)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\">)</span></span></span></span></span></td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mo>∘</mo><mi>T</mi><mi>μ</mi><mo>=</mo><mi>μ</mi><mo>∘</mo><mi>μ</mi><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\mu \\circ T\\mu = \\mu \\circ \\mu T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></td>\n</tr>\n<tr>\n<td>단위 법칙</td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>+</mo><mi>n</mi><mo>=</mo><mi>n</mi><mo>=</mo><mi>n</mi><mo>+</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0+n = n = n+0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></span></td>\n<td><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi><mo>∘</mo><mi>η</mi><mi>T</mi><mo>=</mo><mtext>id</mtext><mo>=</mo><mi>μ</mi><mo>∘</mo><mi>T</mi><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\mu \\circ \\eta T = \\text{id} = \\mu \\circ T\\eta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord text\"><span class=\"mord\">id</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span></span></span></span></span></td>\n</tr>\n</tbody>\n</table>\n<p>즉 이러한 이유들로 인해 우리가 프로그래밍에서 사용하는 모나드를 “내부함자 범주의 모노이드 대상이다”라고 말할 수 있는 것이다.</p>\n<p>하지만 앞서 언급했듯이 이 정의는 우리가 프로그래밍에서 모나드를 사용하게 된 이유가 아니다. 우리는 그저 “효과가 있는 계산을 순차적으로 합성하고 싶다”라는 실용적이고 공학적인 필요성에서 출발해서  <code class=\"language-text\">join</code>과 <code class=\"language-text\">pure</code>를 발명했을 뿐인데, 그것이 마침 수학자들이 이미 알고 있던 “모노이드”라는 구조와 정확하게 일치했던 것이다.</p>\n<h2 id=\"사실-모나드는-박스가-아니다\" style=\"position:relative;\">사실 모나드는 박스가 아니다<a href=\"#%EC%82%AC%EC%8B%A4-%EB%AA%A8%EB%82%98%EB%93%9C%EB%8A%94-%EB%B0%95%EC%8A%A4%EA%B0%80-%EC%95%84%EB%8B%88%EB%8B%A4\" aria-label=\"사실 모나드는 박스가 아니다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>우리는 지금까지 <code class=\"language-text\">Maybe</code>라는 구체적인 예시를 통해 모나드의 원리를 파헤쳤다. 하지만 실무에서 모나드를 다룰 때는 단순히 코드를 구현하는 것보다, 이 도구가 담고 있는 맥락을 이해하고 기존 도구들과의 차이를 인지하는 것이 훨씬 중요하다.</p>\n<p>지금까지 많은 모나드 설명 포스팅들이 펑터와 모나드를 박스에 비유해서 설명했고 필자도 그렇게 설명을 했었지만, 사실 이 비유는 직관적이기는 하나 모나드의 정체성을 절반만 설명할 뿐이다.</p>\n<p>만약 <code class=\"language-text\">Promise</code>와 같은 녀석을 단순히 “미래의 값이 담긴 박스”로만 본다면, 왜 <code class=\"language-text\">then</code>이 순차적으로 실행되어야 하는지 설명하기 어렵다. 그래서 펑터나 모나드는 단순한 박스라기보다 “특정 효과가 수반되는 계산의 맥락”이라고 표현하는 것이 적합하다.</p>\n<p>따라서 모나드의 <code class=\"language-text\">flatMap</code>이 하는 일도 단순히 박스를 까서 펼치는 것이 아니라, 서로 다른 맥락을 가진 계산들을 안전하게 이어 붙이는 것에 가깝다.</p>\n<table>\n<thead>\n<tr>\n<th>모나드</th>\n<th>담고 있는 맥락(Effect)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">Maybe</code></td>\n<td>값이 없을 수도 있다는 맥락</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Result</code></td>\n<td>실패의 이유(에러)를 포함한 맥락</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Promise</code></td>\n<td>시간이 걸리는 비동기 계산의 맥락</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">Array</code></td>\n<td>여러 개의 결과가 존재할 수 있는 비결정적 맥락</td>\n</tr>\n</tbody>\n</table>\n<p>추가적으로 한 가지 더 짚고 넘어가자면 우리는 <code class=\"language-text\">Promise</code>에 대해 다시 바라볼 필요가 있다. 코드 상에서 <code class=\"language-text\">Promise</code>는 매우 모나딕하게 작동하지만 엄밀한 수학적 잣대를 들이대면 모나드가 아니다.</p>\n<p>모나드는 구조를 보존하는 <code class=\"language-text\">map</code>과 구조를 펴는 <code class=\"language-text\">flatMap</code>이 엄격히 구분되어야 하는데, Promise의 then은 반환값에 따라 이 둘을 적당히 섞어서 처리해버리기 때문이다.</p>\n<p>또한 수학적 모나드는 이중으로 겹쳐진 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">⟨</mo><mi>T</mi><mo stretchy=\"false\">⟨</mo><mi>A</mi><mo stretchy=\"false\">⟩</mo><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">T\\langle T\\langle A \\rangle \\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">⟩⟩</span></span></span></span></span> 상태가 존재해야 하지만, Promise는 런타임 수준에서 이를 허용하지 않고 즉시 단일 계층으로 뭉쳐버린다. 물론 이러한 설계가 실무적인 편의성을 주긴 하지만, 수학적 엄밀함이 주는 예측 가능성과는 어느 정도 거리가 있는 셈이다.</p>\n<p>따라서 <code class=\"language-text\">Promise</code>는 엄밀하게 이야기하자면 모나드라고 할 수 없다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이렇게 펑터부터 시작해서 어플리케이티브 펑터, 모나드까지 긴 여정을 마쳤다.</p>\n<p>돌이켜보면 이 긴 여정은 “어떻게 하면 안전하게 함수를 합성할 수 있을까?”라는 지극히 공학적인 질문에서 시작되었다. 우리는 펑터의 한계를 넘기 위해 <code class=\"language-text\">apply</code>를 만났고, 중첩되는 맥락을 해결하기 위해 <code class=\"language-text\">join</code>과 <code class=\"language-text\">flatMap</code>을 발명했다. 그리고 우리가 만든 이 도구들이 사실 수학자들이 수백 년 전부터 연구해온 ‘내부함자 범주의 모노이드 대상’이라는 견고한 구조와 일치한다는 사실도 발견할 수 있었다.</p>\n<p>이러한 발견이 우리에게 주는 진짜 가치는 바로 우리가 작성하는 코드들의 합성 가능성에 대한 수학적 확신이다. 결합 법칙과 단위 법칙을 통해 맥락에 진입하는 입구가 중립적임을 신뢰할 수 있고, 결합 법칙을 통해서는 어떤 레이어에서 리팩토링을 하던 결과가 같다는 것을 보장받을 수 있다. 그리고 이러한 신뢰가 쌓여야 우리가 작은 맥락 조각들을 이어붙여가며 거대하고 복잡한 비즈니스 로직을 구축해나갈 수 있다.</p>\n<p>결국 모나드를 이해한다는 것은 추상적인 맥락을 다루는 법을 배우고 우리가 작성하는 소프트웨어에 수학적인 질서를 부여하여 코드에 대한 확신을 얻는 과정이라고 볼 수 있다.</p>\n<p>필자도 나름 모나드를 설명해보겠다고 발버둥을 쳐봤는데, 솔직히 이 글의 난이도가 쉬운 것인지 어려운 것인지 전혀 가늠이 안된다.</p>\n<p>혹시라도 추가적인 궁금증이 있는 분들은 필자의 이메일을 통해 질문을 남겨주시면 최대한 설명을 해드릴테니 많은 함수형 프로그래밍 러버들의 관심과 사랑을 부탁드린다.</p>\n<p>이상으로 펑터를 넘어서, 모나드까지 포스팅을 마친다.</p>","fields":{"slug":"20260207-monads-in-typescript","path":"/2026/02/07/monads-in-typescript/","lang":"ko"},"frontmatter":{"title":"펑터를 넘어서, 모나드까지","subTitle":"TypeScript로 이해하는 어플리케이티브 펑터와 모나드","date":"Feb 07, 2026","categories":["프로그래밍"],"tags":["TypeScript","함수형 프로그래밍","모나드","펑터","카테고리 이론"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/c89635397231f003aa3a56876872770c/d803c/thumbnail.png","srcSet":"/static/c89635397231f003aa3a56876872770c/d803c/thumbnail.png 320w,\n/static/c89635397231f003aa3a56876872770c/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/c89635397231f003aa3a56876872770c/fc5c5/thumbnail.webp 320w,\n/static/c89635397231f003aa3a56876872770c/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/c89635397231f003aa3a56876872770c/01fb2/thumbnail.png","srcSet":"/static/c89635397231f003aa3a56876872770c/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/c89635397231f003aa3a56876872770c/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"cca520f5-4ad7-5867-8d7e-204a8480f038","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EC%9D%84-%EB%95%8C-%EB%87%8C%EC%97%90%EC%84%9C%EB%8A%94-%EB%AC%B4%EC%8A%A8-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C\">코드를 읽을 때 뇌에서는 무슨 일이 일어날까</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%91%EC%97%85-%EA%B8%B0%EC%96%B5-4%EA%B0%9C%EC%9D%98-%EC%8A%AC%EB%A1%AF\">작업 기억: 4개의 슬롯</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B2%AD%ED%82%B9-%EB%87%8C%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%95%95%EC%B6%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">청킹: 뇌의 데이터 압축 알고리즘</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-1%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-2-%EC%A7%81%EA%B4%80%EA%B3%BC-%EB%B6%84%EC%84%9D\">시스템 1과 시스템 2: 직관과 분석</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%8C%EC%8A%88%ED%83%88%ED%8A%B8-%EC%9B%90%EB%A6%AC-%EC%BD%94%EB%93%9C%EC%9D%98-%EC%8B%9C%EA%B0%81%EC%A0%81-%EA%B5%AC%EC%A1%B0%EA%B0%80-%EC%9D%B4%ED%95%B4%EC%97%90-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5\">게슈탈트 원리: 코드의 시각적 구조가 이해에 미치는 영향</a></p>\n<ul>\n<li><a href=\"#%EA%B7%BC%EC%A0%91%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\">근접성의 원리</a></li>\n<li><a href=\"#%EC%9C%A0%EC%82%AC%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\">유사성의 원리</a></li>\n<li><a href=\"#%EC%97%B0%EC%86%8D%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\">연속성의 원리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B8%EC%A7%80-%EB%B6%80%ED%95%98-%EC%9D%B4%EB%A1%A0-%EC%84%B8-%EA%B0%80%EC%A7%80-%EB%B6%80%ED%95%98%EC%9D%98-%EC%A2%85%EB%A5%98\">인지 부하 이론: 세 가지 부하의 종류</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%BD%ED%97%98%EC%9D%B4-%EB%87%8C%EB%A5%BC-%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B0%94%EA%BE%BC%EB%8B%A4\">경험이 뇌를 물리적으로 바꾼다</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%98%88%EC%B8%A1-%EB%B6%80%ED%98%B8%ED%99%94-%EB%87%8C%EB%8A%94-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EB%8A%94-%EA%B2%8C-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%98%88%EC%B8%A1%ED%95%9C%EB%8B%A4\">예측 부호화: 뇌는 코드를 읽는 게 아니라 예측한다</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EA%B2%B0%EA%B5%AD\">그래서 “좋은 코드”란 결국</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n</li>\n</ul>","excerpt":"이전에 좋은 코드란 무엇일까? - 가독성이란 허상에 대하여라는 글에서, “좋은 코드 = 가독성이 좋은 코드”라는 공식이 얼마나 주관적이고 맥락 의존적인지에 대해 이야기한 적이 있다. 물론 사람마다 가독성이 좋다고 판단하는 결과는 주관적이라고 볼 수 있다. 하지만 가독성이 좋은 코드라는 것이 어떤 원리로 동작하는지, 그 감각은 대체 어디서 오는 것인지를 추적해보다보면 약간은 힌트를 얻을 수 있다.","html":"<p>이전에 <a href=\"/2024/12/23/the-illusion-of-a-right-answer/\">좋은 코드란 무엇일까? - 가독성이란 허상에 대하여</a>라는 글에서, “좋은 코드 = 가독성이 좋은 코드”라는 공식이 얼마나 주관적이고 맥락 의존적인지에 대해 이야기한 적이 있다.</p>\n<p>물론 사람마다 가독성이 좋다고 판단하는 결과는 주관적이라고 볼 수 있다. 하지만 가독성이 좋은 코드라는 것이 어떤 원리로 동작하는지, 그 감각은 대체 어디서 오는 것인지를 추적해보다보면 약간은 힌트를 얻을 수 있다.</p>\n<!-- more -->\n<p>그래서 이번 포스팅에서는 바로 그 이야기를 해보려 한다. 인간이 코드를 이해하는 방식, 그리고 어떤 형태의 정보가 이해하기 쉽다고 느끼는지에 대한 이야기이다.</p>\n<h2 id=\"코드를-읽을-때-뇌에서는-무슨-일이-일어날까\" style=\"position:relative;\">코드를 읽을 때 뇌에서는 무슨 일이 일어날까<a href=\"#%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EC%9D%84-%EB%95%8C-%EB%87%8C%EC%97%90%EC%84%9C%EB%8A%94-%EB%AC%B4%EC%8A%A8-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%A0%EA%B9%8C\" aria-label=\"코드를 읽을 때 뇌에서는 무슨 일이 일어날까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://doi.org/10.7554/eLife.58906\" target=\"_blank\" rel=\"nofollow\">MIT에서 2020년에 진행한 기능적 MRI 연구</a>에서 프로그래머들이 코드를 읽을 때 뇌의 어떤 영역이 활성화되는지를 관찰했는데, 재밌는 결과가 나왔다.</p>\n<p>연구에 따르면 코드를 읽을 때는 언어 네트워크가 아니라 논리 추론과 복잡한 인지 작업을 담당하는 다중 수요 네트워크가 주로 활성화되었다고 한다. 언어 영역의 관여가 완전히 없었던 것은 아니지만, 다중 수요 네트워크의 반응이 지배적이었다.</p>\n<p>쉽게 말해서, 우리 뇌는 코드를 읽을 때 언어 처리보다는 논리적 추론 쪽에 더 크게 의존한다는 뜻이다.</p>\n<p>이 연구에서 확인된 것은 코드 이해 시 작업 기억, 주의 집중, 언어 처리와 관련된 다섯 개의 뇌 영역이 뚜렷하게 활성화된다는 점이다. 동시에 디폴트 모드 네트워크(뇌가 쉬고 있을 때 활성화되는 영역)의 활동은 감소했다. 즉, 코드를 읽는 건 뇌 입장에서 꽤 비싼 작업인 셈이다.</p>\n<p>여기까지는 그러려니 할 수 있겠지만, 더 흥미로운 사실은 바로 전문가와 초보자의 차이에서 나온다. 숙련된 개발자는 코드를 읽을 때 뇌의 전반적인 활성화 수준이 낮았다. 덜 열심히 한 게 아니라, 더 효율적으로 처리한 것이다. 반면 초보 개발자는 뇌의 넓은 영역이 활성화됐는데, 이는 거의 모든 것을 의식적으로 하나씩 처리하고 있다는 뜻이다.</p>\n<p>초보자는 코드를 자연어 텍스트처럼 위에서 아래로 읽는 경향이 있었고, 전문가는 프로그램의 실행 흐름을 따라 읽었다. 같은 코드를 보고 있지만, 뇌가 처리하는 방식 자체가 다른 것이다.</p>\n<h2 id=\"작업-기억-4개의-슬롯\" style=\"position:relative;\">작업 기억: 4개의 슬롯<a href=\"#%EC%9E%91%EC%97%85-%EA%B8%B0%EC%96%B5-4%EA%B0%9C%EC%9D%98-%EC%8A%AC%EB%A1%AF\" aria-label=\"작업 기억 4개의 슬롯 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>왜 어떤 코드는 쉽게 읽히는데 어떤 코드는 머릿속에서 정리가 안 되는지를 이해하려면, 작업 기억이라는 개념을 알아야 한다.</p>\n<p>1956년 인지심리학자 조지 밀러(George A. Miller)가 발표한 유명한 논문 <a href=\"https://doi.org/10.1037/h0043158\" target=\"_blank\" rel=\"nofollow\">“The Magical Number Seven, Plus or Minus Two”</a>에서, 인간의 단기 기억 용량이 약 7±2개의 항목이라는 사실이 밝혀졌다. 이후 연구에서는 이 숫자가 더 줄어들어, <a href=\"https://doi.org/10.1017/s0140525x01003922\" target=\"_blank\" rel=\"nofollow\">Cowan(2001)</a> 등의 견해에 따르면 작업 기억에 동시에 유지할 수 있는 청크는 약 3~4개 수준으로 수렴한다는 주장이 유력하다. 다만 이 수치는 과제의 종류, 숙련도, 정보의 양식에 따라 달라질 수 있다.</p>\n<p>코드를 읽을 때 우리가 머릿속에 올려놓는 것들을 떠올려보자. 변수의 현재 값, 제어 흐름의 방향, 함수 호출 순서, 현재 스코프의 상태 등 다양한 것들이 작업 기억의 슬롯을 차지한다. 그리고 이 슬롯이 꽉 차면, 뇌는 새로운 정보를 받아들이기 어려워는데, 바로 이때 “이 코드 뭔가 복잡한데”라는 느낌이 찾아오는 것이다.</p>\n<p>이걸 개발랭이들이 이해하기 쉬운 프로그래밍적인 비유로 바꿔보면, 작업 기억은 일종의 고정 크기 스택이라고 볼 수 있다.</p>\n<p>실제 작업 기억은 스택보다 훨씬 복잡한 시스템이지만, “용량에 한계가 있고 초과하면 처리가 무너진다”는 특성을 직관적으로 이해하기에는 나쁘지 않은 비유다. 스택 사이즈가 약 4인데 이걸 초과하면 스택 오버플로우가 나는 것이다. 다만 실제로는 슬롯에 담기는 항목의 크기가 균일하지 않고, 항목 간 간섭도 발생하기 때문에, 숫자 자체보다는 “용량에 한계가 있다”는 사실이 핵심이다. 그리고 이 용량이 한계에 부딪히는 순간이 바로 “이 코드 읽기 어렵다”는 감각이 발생하는 순간이다.</p>\n<p>한번 작업 기억을 빠르게 소진하는 코드와 그렇지 않은 코드를 비교해보며 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 작업 기억 슬롯 4개를 빠르게 소진하는 코드</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">processOrder</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token string\">'pending'</span> <span class=\"token operator\">&amp;&amp;</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> discount <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>customer<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span>\n      <span class=\"token operator\">?</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> sum <span class=\"token operator\">+</span> item<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span>\n      <span class=\"token operator\">:</span> order<span class=\"token punctuation\">.</span>coupon<span class=\"token operator\">?.</span>discount <span class=\"token operator\">??</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">const</span> tax <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>domestic <span class=\"token operator\">?</span> <span class=\"token number\">0.1</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> finalPrice <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount <span class=\"token operator\">+</span> tax <span class=\"token operator\">+</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>cost<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>order<span class=\"token punctuation\">,</span> finalPrice<span class=\"token punctuation\">,</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'processed'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 틀린 코드는 아니지만, 읽는 사람의 작업 기억에 동시에 올려야 할 것이 너무 많다.</p>\n<p><code class=\"language-text\">order.status</code>의 조건, <code class=\"language-text\">order.items</code>의 존재 여부, <code class=\"language-text\">customer.tier</code>에 따른 할인 분기, 쿠폰의 널 체크, 세금 계산의 국내/해외 분기, 최종 가격 산출 등 이 모든 맥락을 3~4개의 슬롯에 동시에 담으려 하니 뇌가 비명을 지르는 것이다.</p>\n<p>만약 이 맥락을 적절한 단위와 크기로 나눠줄 수 있다면, 어떤 동작을 이해하기 위해 필요한 작업 슬롯을 아낄 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 작업 기억 부담을 줄인 버전</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateDiscount</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>customer<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> subtotal <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> sum <span class=\"token operator\">+</span> item<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> subtotal <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">.</span>coupon<span class=\"token operator\">?.</span>discount <span class=\"token operator\">??</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">calculateTax</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> shipping<span class=\"token operator\">:</span> ShippingInfo<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> shipping<span class=\"token punctuation\">.</span>domestic <span class=\"token operator\">?</span> amount <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">processOrder</span><span class=\"token punctuation\">(</span>order<span class=\"token operator\">:</span> Order<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>status <span class=\"token operator\">!==</span> <span class=\"token string\">'pending'</span> <span class=\"token operator\">||</span> order<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> order<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> discount <span class=\"token operator\">=</span> <span class=\"token function\">calculateDiscount</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> tax <span class=\"token operator\">=</span> <span class=\"token function\">calculateTax</span><span class=\"token punctuation\">(</span>order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount<span class=\"token punctuation\">,</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> finalPrice <span class=\"token operator\">=</span> order<span class=\"token punctuation\">.</span>total <span class=\"token operator\">-</span> discount <span class=\"token operator\">+</span> tax <span class=\"token operator\">+</span> order<span class=\"token punctuation\">.</span>shipping<span class=\"token punctuation\">.</span>cost<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>order<span class=\"token punctuation\">,</span> finalPrice<span class=\"token punctuation\">,</span> status<span class=\"token operator\">:</span> <span class=\"token string\">'processed'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 버전에서는 각 단계에서 머릿속에 올려야 할 것이 확연하게 줄어든다. 동작 자체는 동일하지만, 정보를 일정한 단위로 패키징함으로서 작업 슬롯에 들어가는 맥락을 제어해주는 것이다.</p>\n<p><code class=\"language-text\">calculateDiscount</code>를 읽을 때는 할인 로직에만 집중하면 되며, <code class=\"language-text\">processOrder</code>를 읽을 때는 각 계산의 세부 구현을 몰라도 전체 흐름을 이해할 수 있다. 각 함수가 작업 기억의 용량 안에서 소화 가능한 크기이기 때문에 이해가 쉽다고 느껴진다. 그리고 이것이 우리가 설계를 할 때 적절한 단위로 추상화를 해야하는 이유라고도 할 수 있다. 물론 반대로, 지나치게 잘게 쪼개면 함수 간 점프와 맥락 추적에 작업 기억을 소모하게 된다. 분리 자체가 목적이 아니라, 한 번에 머릿속에 올려야 할 양을 줄이는 것이 목적이다.</p>\n<h2 id=\"청킹-뇌의-데이터-압축-알고리즘\" style=\"position:relative;\">청킹: 뇌의 데이터 압축 알고리즘<a href=\"#%EC%B2%AD%ED%82%B9-%EB%87%8C%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%95%95%EC%B6%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"청킹 뇌의 데이터 압축 알고리즘 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그런데 여기서 한 가지 의문이 생긴다. 작업 기억의 슬롯이 겨우 4개라면, 우리는 대체 어떻게 수백 줄의 코드를 이해할 수 있는 걸까?</p>\n<p>답은 청킹이라는 인지 메커니즘에 있다. 청킹이란 여러 개의 작은 정보 단위를 하나의 의미 있는 덩어리로 묶어서 처리하는 것을 말한다. <a href=\"https://doi.org/10.5334/joc.451\" target=\"_blank\" rel=\"nofollow\">취리히 대학교의 연구</a>에 따르면, 청킹은 장기 기억에서 압축된 청크 표상을 불러와 개별 요소의 표상을 대체함으로써 작업 기억의 부하를 줄인다. 이로 인해 확보된 용량은 이후에 입력되는 새로운 정보를 처리하는 데 사용된다.</p>\n<p>전화번호를 생각해보자. <code class=\"language-text\">01012345678</code>이라는 11자리 숫자를 한 자리씩 기억하려면 작업 기억의 용량을 한참 초과한다. 그런데 <code class=\"language-text\">010-1234-5678</code>로 나누면 세 덩어리만 기억하면 된다. 더 나아가, 이미 익숙한 <code class=\"language-text\">010</code>은 “한국 휴대폰 번호 앞자리”라는 하나의 청크로 자동 처리되니, 실질적으로 두 덩어리만 새로 기억하면 되는 것이다.</p>\n<p>코드에서도 같은 일이 일어난다. 숙련된 개발자가 아래 코드를 볼 때 일어나는 일을 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> activeUsers <span class=\"token operator\">=</span> users<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">=></span> u<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>u <span class=\"token operator\">=></span> u<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>초보 개발자는 이걸 읽을 때 <code class=\"language-text\">users</code>라는 변수, <code class=\"language-text\">.filter</code> 메서드의 동작, 화살표 함수의 문법, <code class=\"language-text\">u.isActive</code>라는 속성 접근, <code class=\"language-text\">.map</code> 메서드의 동작, 또 다른 화살표 함수… 이런 개별 요소들을 하나씩 작업 기억에 올려야 한다.</p>\n<p>반면 숙련된 개발자에게 <code class=\"language-text\">users.filter(...).map(...)</code>은 “배열 필터링 후 변환”이라는 하나의 청크로 인식된다. 이 패턴을 수백, 수천 번 봤기 때문에, 장기 기억에 저장된 청크를 꺼내와서 작업 기억의 슬롯을 하나만 쓰는 것이다. 나머지 슬롯은 “왜 필터링하는가”, “결과가 어디에 쓰이는가” 같은 더 상위 수준의 사고에 할당할 수 있다.</p>\n<p>이것이 바로 체스 마스터가 체스판을 한 번 보고 전체 상황을 파악할 수 있는 원리와 같다. 체스 마스터는 개별 말의 위치를 하나씩 기억하는 게 아니라, 익숙한 포진 패턴을 하나의 청크로 인식한다. 그래서 의미 있는 배치의 체스판은 빠르게 기억하지만, 말을 무작위로 배치하면 초보자와 별 차이가 없다.</p>\n<p>코드도 마찬가지다. 관용적인 코드가 읽기 쉬운 이유는 그게 “올바른” 코드여서가 아니라, 개발자의 장기 기억에 이미 저장된 청크와 일치하기 때문이다.</p>\n<p>그리고 특정 패턴이 관용적이 되는 데는 언어의 설계 의도, 표준 라이브러리의 관례, 커뮤니티의 반복적 선택 같은 외부 요인이 작용한다. 단순히 “많이 써서 익숙한 것”이 아니라, 여러 이유로 수렴한 결과가 익숙함을 만든 것이다. 프로젝트만의 독특한 패턴이나 지나치게 창의적인 코드가 읽기 어려운 이유도 여기에 있다. 기존 청크와 매칭되지 않으면, 뇌는 모든 것을 개별 요소로 분해해서 처리해야 하고, 작업 기억은 순식간에 포화된다.</p>\n<h2 id=\"시스템-1과-시스템-2-직관과-분석\" style=\"position:relative;\">시스템 1과 시스템 2: 직관과 분석<a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-1%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-2-%EC%A7%81%EA%B4%80%EA%B3%BC-%EB%B6%84%EC%84%9D\" aria-label=\"시스템 1과 시스템 2 직관과 분석 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여기서 다니엘 카너먼(Daniel Kahneman)의 이중 처리 이론을 꺼내야 한다. 카너먼은 인간의 사고를 두 가지 시스템으로 나눴다.</p>\n<hr>\n<ul>\n<li><strong>시스템 1</strong>: 빠르고, 자동적이고, 직관적인 사고. 패턴 인식에 기반한다.</li>\n<li><strong>시스템 2</strong>: 느리고, 의식적이고, 분석적인 사고. 논리적 추론에 기반한다.</li>\n</ul>\n<hr>\n<p>우리가 일상적으로 하는 판단 대부분은 시스템 1이 담당한다. 운전을 하거나, 전화기 너머 여친의 기분을 한마디에 알아채는 것도 시스템 1의 영역이다. 시스템 1은 새로운 정보를 접했을 때, 완전히 새로운 패턴을 만들어내는 게 아니라 기존에 저장된 패턴과 대조하는 방식으로 작동한다.</p>\n<p>시스템 1이 막히면 그때서야 시스템 2가 호출된다. “이게 뭐지?” 하고 의식적으로 분석을 시작하는 순간이 바로 시스템 2가 개입하는 시점이다. 그리고 이 프레임워크를 코드 읽기에 적용하면 정말 많은 것이 설명된다.</p>\n<p>읽기 쉬운 코드란, 대부분 시스템 1의 패턴 인식으로 처리되고 시스템 2의 개입이 최소화되는 코드다.</p>\n<p>숙련된 개발자가 코드를 읽을 때, 익숙한 패턴은 시스템 1이 자동으로 처리한다. <code class=\"language-text\">for</code> 루프, <code class=\"language-text\">if-else</code> 분기, <code class=\"language-text\">map</code>/<code class=\"language-text\">filter</code>/<code class=\"language-text\">reduce</code> 체이닝, <code class=\"language-text\">try-catch</code> 블록 등 이런 것들은 수천 번 봐온 패턴이기 때문에 의식적 노력 없이 처리된다. 시스템 2는 편안한 저전력 모드에 머물면서, 시스템 1이 올려주는 정보를 승인하기만 하면 된다.</p>\n<p>그런데 갑자기 예상치 못한 패턴이 나타나면 상황이 달라진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 시스템 1이 처리 가능한 코드</span>\n<span class=\"token keyword\">const</span> canPurchase <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">>=</span> <span class=\"token number\">18</span> <span class=\"token operator\">&amp;&amp;</span> user<span class=\"token punctuation\">.</span>isVerified<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 시스템 2를 호출하는 코드</span>\n<span class=\"token keyword\">const</span> canPurchase <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">&lt;</span> <span class=\"token number\">18</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>user<span class=\"token punctuation\">.</span>isVerified<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>age <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 코드는 같은 의도를 표현한다. 하지만 두 번째 코드를 보는 순간 뇌에서는 시스템 1이 “모르겠다”는 신호를 보내고, 시스템 2가 비싼 비용을 들여 분석을 시작한다. 이중 부정을 풀고, 드모르간 법칙을 머릿속에서 돌리고, 마지막 <code class=\"language-text\">undefined</code> 체크가 왜 필요한지를 따져봐야 한다. 이러한 전환 자체가 인지적 비용이다.</p>\n<p>카너먼은 이런 현상을 인지적 긴장이라 불렀다. 시스템 2가 개입할수록 뇌는 더 많은 에너지를 소비하고 피로감을 느끼게 된다. “읽기 어려운 코드”라는 주관적 느낌의 실체는 바로 패턴 매칭 실패로 인한 시스템 전환, 그리고 그에 따르는 인지적 비용이 발생하는 것이다.</p>\n<p>이 관점에서 보면, 코드 리뷰에서 “이해하기 어렵다”는 피드백은 단순한 취향 불만이 아니라, 인지 시스템의 전환 비용이 실제로 발생하고 있다는 신호에 가깝다. 그 비용의 크기는 개인의 경험과 청크 구성에 따라 다르겠지만, 비용이 발생한다는 사실 자체는 실재한다.</p>\n<h2 id=\"게슈탈트-원리-코드의-시각적-구조가-이해에-미치는-영향\" style=\"position:relative;\">게슈탈트 원리: 코드의 시각적 구조가 이해에 미치는 영향<a href=\"#%EA%B2%8C%EC%8A%88%ED%83%88%ED%8A%B8-%EC%9B%90%EB%A6%AC-%EC%BD%94%EB%93%9C%EC%9D%98-%EC%8B%9C%EA%B0%81%EC%A0%81-%EA%B5%AC%EC%A1%B0%EA%B0%80-%EC%9D%B4%ED%95%B4%EC%97%90-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5\" aria-label=\"게슈탈트 원리 코드의 시각적 구조가 이해에 미치는 영향 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>읽기 쉬운 코드에는 논리적 구조뿐만 아니라 시각적 구조도 중요하다. 여기서 게슈탈트 심리학의 지각 원리가 등장한다.</p>\n<p>게슈탈트 심리학은 인간의 뇌가 개별 요소가 아닌 전체 패턴과 구조를 우선적으로 인식한다는 점을 연구하는 분야다. 그 핵심 원리 몇 가지는 코드 가독성에 직접적으로 연결된다.</p>\n<h3 id=\"근접성의-원리\" style=\"position:relative;\">근접성의 원리<a href=\"#%EA%B7%BC%EC%A0%91%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"근접성의 원리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>가까이 있는 요소들은 하나의 그룹으로 인식된다. 한번 두 가지 버전의 코드를 살펴보며 이 그룹이 왜 중요한지를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 근접성 원리가 적용되지 않은 코드</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> user<span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> email <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> isValid <span class=\"token operator\">=</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'@'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> role <span class=\"token operator\">=</span> <span class=\"token function\">determineRole</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>permissions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dashboard <span class=\"token operator\">=</span> <span class=\"token function\">getDashboard</span><span class=\"token punctuation\">(</span>role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> notifications <span class=\"token operator\">=</span> <span class=\"token function\">getNotifications</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 근접성 원리가 적용된 코드</span>\n<span class=\"token keyword\">const</span> name <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> user<span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> email <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> isValid <span class=\"token operator\">=</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'@'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> email<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> role <span class=\"token operator\">=</span> <span class=\"token function\">determineRole</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>permissions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dashboard <span class=\"token operator\">=</span> <span class=\"token function\">getDashboard</span><span class=\"token punctuation\">(</span>role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> notifications <span class=\"token operator\">=</span> <span class=\"token function\">getNotifications</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span> role<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 번째 버전에서 빈 줄 하나가 추가됐을 뿐인데 뇌는 자동으로 “사용자 정보 처리”와 “권한 기반 데이터 조회”라는 두 그룹을 인식한다.</p>\n<p>게슈탈트 연구에 따르면 근접성은 색상이나 형태의 유사성보다도 더 강력한 그룹핑 단서다. 이 원리는 UI 디자인에서도 그대로 사용되는데, 서로 연관이 있는 정보는 가까이 붙이고 연관이 없는 정보는 간격을 늘려 멀리 떨어트려놓는 것이 이 때문이다.</p>\n<p>마찬가지로 코드에서 빈 줄과 들여쓰기가 중요한 이유는 단순히 미관 때문이 아니라, 뇌의 지각 시스템이 그걸 기반으로 구조를 파악하기 때문이다.</p>\n<h3 id=\"유사성의-원리\" style=\"position:relative;\">유사성의 원리<a href=\"#%EC%9C%A0%EC%82%AC%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"유사성의 원리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>근접성과 마찬가지로 비슷하게 생긴 요소들도 같은 그룹으로 인식된다. 이것을 유사성의 원리라고 하는데, 이 원리는 코드에서 일관된 네이밍이 왜 중요한지를 설명한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 유사성 원리가 깨진 네이밍</span>\n<span class=\"token keyword\">const</span> userData <span class=\"token operator\">=</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> get_orders <span class=\"token operator\">=</span> <span class=\"token function\">retrieveOrderList</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> pmtHistory <span class=\"token operator\">=</span> <span class=\"token function\">loadPayments</span><span class=\"token punctuation\">(</span>uid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 유사성 원리가 적용된 네이밍</span>\n<span class=\"token keyword\">const</span> user <span class=\"token operator\">=</span> <span class=\"token function\">fetchUser</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> orders <span class=\"token operator\">=</span> <span class=\"token function\">fetchOrders</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> payments <span class=\"token operator\">=</span> <span class=\"token function\">fetchPayments</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 버전에서는 데이터 페칭이라는 같은 종류의 작업임에도 네이밍 규칙이 제각각이다. <code class=\"language-text\">userData</code>, <code class=\"language-text\">get_orders</code>, <code class=\"language-text\">pmtHistory</code>라는 변수명은 각각 다른 형태를 가지고, <code class=\"language-text\">fetchUser</code>, <code class=\"language-text\">retrieveOrderList</code>, <code class=\"language-text\">loadPayments</code>라는 함수명도 일관성이 없다. 뇌는 이런 코드를 보면 이들을 같은 그룹으로 인식하지 못하고 각 라인을 개별 항목으로 처리하면서 작업 기억을 소진한다.</p>\n<p>두 번째 버전에서는 패턴이 명확하다. <code class=\"language-text\">fetch + 리소스명</code>이라는 일관된 구조 덕분에, 세 줄이 “동일한 패턴의 데이터 패칭”이라는 하나의 청크로 인식된다.</p>\n<h3 id=\"연속성의-원리\" style=\"position:relative;\">연속성의 원리<a href=\"#%EC%97%B0%EC%86%8D%EC%84%B1%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"연속성의 원리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>연속성의 원리는 시선이 자연스럽게 흐르는 방향을 따라 요소들을 하나의 연속된 것으로 인식하는 원리다. 코드에서 이건 실행 흐름의 선형성과 관련된다.</p>\n<p>우리 뇌는 위에서 아래로, 왼쪽에서 오른쪽으로 흐르는 것을 자연스럽게 느낀다. 깊은 중첩, 복잡한 콜백, 여기저기 점프하는 <code class=\"language-text\">goto</code>문 등이 읽기 어려운 이유는 연속성의 원리를 위반하기 때문이다.</p>\n<p>우리가 얼리 리턴 패턴을 사용했을 때, 중첩된 <code class=\"language-text\">if</code>문보다 읽기 쉬운 이유도 마찬가지다. 예외 케이스를 먼저 걸러내고 나면 남은 코드는 위에서 아래로 한 방향으로 흐른다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 연속성이 깨지는 코드</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">,</span> product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>inStock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>onSale<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>salePrice<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Out of stock'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Inactive user'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 연속성이 유지되는 코드</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getPrice</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">,</span> product<span class=\"token operator\">:</span> Product<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>user<span class=\"token punctuation\">.</span>isActive<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Inactive user'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>product<span class=\"token punctuation\">.</span>inStock<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Out of stock'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>tier <span class=\"token operator\">===</span> <span class=\"token string\">'premium'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price <span class=\"token operator\">*</span> <span class=\"token number\">0.8</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">.</span>onSale<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>salePrice<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> product<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 버전은 들여쓰기가 깊어지면서 시선이 오른쪽으로, 다시 왼쪽으로 지그재그를 그린다. 뇌는 각 중첩 수준에서 “지금 어느 조건 안에 있는가”를 작업 기억에 유지해야 한다.</p>\n<p>반면 두 번째 버전은 예외를 먼저 걸러낸 뒤 위에서 아래로 자연스럽게 흘러내린다. 연속성의 원리에 부합하기 때문에 뇌가 구조를 파악하는 데 드는 비용이 크게 줄어든다.</p>\n<h2 id=\"인지-부하-이론-세-가지-부하의-종류\" style=\"position:relative;\">인지 부하 이론: 세 가지 부하의 종류<a href=\"#%EC%9D%B8%EC%A7%80-%EB%B6%80%ED%95%98-%EC%9D%B4%EB%A1%A0-%EC%84%B8-%EA%B0%80%EC%A7%80-%EB%B6%80%ED%95%98%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"인지 부하 이론 세 가지 부하의 종류 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>여기까지의 이야기를 좀 더 체계적으로 정리해주는 프레임워크가 있다. 존 스웰러(John Sweller)의 <a href=\"https://ko.wikipedia.org/wiki/%EC%9D%B8%EC%A7%80_%EB%B6%80%ED%95%98\" target=\"_blank\" rel=\"nofollow\">인지 부하 이론</a>이다.</p>\n<p>이 이론에 따르면 학습이나 문제 해결 시 발생하는 인지 부하는 세 가지로 나뉜다.</p>\n<hr>\n<ol>\n<li><strong>내재적 부하</strong>: 과제 자체의 본질적 복잡성. 알고리즘의 난이도, 도메인의 복잡성 같은 것.</li>\n<li><strong>외재적 부하</strong>: 과제와 무관한, 표현 방식에서 오는 불필요한 복잡성. 일관되지 않은 네이밍, 불필요한 간접 참조, 혼란스러운 코드 구조 같은 것.</li>\n<li><strong>본유적 부하</strong>: 새로운 스키마를 형성하고 학습하는 데 드는 유익한 부하.</li>\n</ol>\n<hr>\n<p>이 이론에 따르면 우리가 읽기 쉬운 코드를 작성하기 위해 추구해야하는 것은 외재적 부하를 최소화하는 것이다.</p>\n<p>어차피 내재적 부하는 문제 자체에 내재된 것이니 줄일 수 없다. 예를 들어 분산 시스템의 합의 알고리즘을 구현하는 코드는 아무리 잘 써도 복잡할 수밖에 없는 것이다. 우리가 피해야할 문제는 “표현 방식”에서 오는 외재적 부하가 내재적 부하 위에 불필요하게 쌓일 때다.</p>\n<p>이 관점으로 보면 코드 가독성을 높이는 일관된 네이밍, 적절한 함수 분리, 명확한 타입 선언, 의미 있는 빈 줄과 같은 패턴은 결국 외재적 인지 부하를 줄이는 행위다. 뇌의 제한된 자원을 외재적 부하에 낭비하지 않고, 내재적 부하(실제 문제)를 처리하는 데 집중할 수 있게 해주는 것이다.</p>\n<p><a href=\"https://doi.org/10.1016/j.jss.2023.111619\" target=\"_blank\" rel=\"nofollow\">2023년에 발표된 체계적 문헌 리뷰</a>에서도 흥미로운 사실이 확인됐다. 소스 코드 메트릭과 실제 측정된 인지 부하 사이의 관계를 조사한 연구들에서 전통적 코드 메트릭 중 실제 인지 부하와 일관되게 높은 상관을 보인 것은 드물었고, 상관이 확인된 경우에도 과제 조건이나 측정 방식에 따라 결과가 달라지는 경향이 있었다. 즉, 우리가 “복잡도”라고 측정하는 것과 개발자의 뇌가 실제로 “복잡하다”고 느끼는 것은 다를 수 있다는 뜻이다.</p>\n<p>이건 의미심장한 결과다. 기계적으로 측정 가능한 메트릭은 코드의 외형적 복잡도를 포착하지만, 개발자의 뇌가 실제로 겪는 인지 부하는 패턴의 익숙함, 청킹의 효율성, 시각적 구조의 명확성과 같이 주관적 인식에 영향을 받는다는 것이다.</p>\n<h2 id=\"경험이-뇌를-물리적으로-바꾼다\" style=\"position:relative;\">경험이 뇌를 물리적으로 바꾼다<a href=\"#%EA%B2%BD%ED%97%98%EC%9D%B4-%EB%87%8C%EB%A5%BC-%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B0%94%EA%BE%BC%EB%8B%A4\" aria-label=\"경험이 뇌를 물리적으로 바꾼다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 전문가와 초보자의 뇌 활성화 패턴이 다르다고 했다. 이건 단순히 개발 짬바가 쌓이면 더 잘한다는 이야기가 아니다. <a href=\"https://www.nature.com/articles/s41598-024-56090-6\" target=\"_blank\" rel=\"nofollow\">2024년 Scientific Reports에 발표된 연구</a>에서는 62명의 파이썬 프로그래머를 대상으로 뇌파를 측정하며, 코드에 의도적으로 삽입한 문법 오류와 의미 오류에 대한 뇌의 반응을 관찰했다.</p>\n<p>결과는 놀라웠다. 숙련된 프로그래머는 코드의 문법적 위반과 의미적 위반에 대해 서로 다른 뇌파 패턴을 보였다. 이는 자연어를 읽을 때 문법 오류와 의미 오류에 대해 다른 뇌파가 나타나는 것과 유사한 패턴이다. 프로그래밍 경험이 뇌에 특정 언어와 패턴을 처리하기 위한 신경 회로를 형성한다는 뜻이다.</p>\n<p>다시 말해, 코딩 경험은 뇌의 물리적 구조를 변화시킨다. 신경가소성에 의해, 반복적으로 노출된 코드 패턴은 장기 기억에 스키마로 저장되고, 이 스키마가 청킹의 기반이 된다. 시스템 1이 코드를 자동으로 처리할 수 있는 것은 이런 스키마가 축적된 결과다.</p>\n<p>또한 스키마는 개인이 노출된 패턴에 따라 형성되기 때문에 같은 코드베이스에서 같은 패턴을 반복적으로 접한 사람들은 비슷한 스키마를 공유하게 된다. 이걸 뒤집어 생각하면 팀에서 일관된 코드 스타일을 유지하는 것은 취향의 문제가 아니라 팀원들의 뇌에 공유된 청크를 형성하는 과정인 셈이다. 코딩 컨벤션이 중요한 이유가 단순히 통일성이 아니라, 집단적 인지 효율성 때문인 것이다.</p>\n<h2 id=\"예측-부호화-뇌는-코드를-읽는-게-아니라-예측한다\" style=\"position:relative;\">예측 부호화: 뇌는 코드를 읽는 게 아니라 예측한다<a href=\"#%EC%98%88%EC%B8%A1-%EB%B6%80%ED%98%B8%ED%99%94-%EB%87%8C%EB%8A%94-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%BD%EB%8A%94-%EA%B2%8C-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%98%88%EC%B8%A1%ED%95%9C%EB%8B%A4\" aria-label=\"예측 부호화 뇌는 코드를 읽는 게 아니라 예측한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>최근 인지과학에서 주목받는 이론 중 하나는 예측 부호화다. 이 이론에 따르면, 뇌는 수동적으로 정보를 수신하는 게 아니라, 끊임없이 다음에 올 정보를 예측하고, 실제 입력이 그 예측과 다를 때만 추가적인 처리를 한다.</p>\n<p>코드를 읽을 때도 마찬가지다. 우리 뇌는 다음 줄에 뭐가 올지 끊임없이 예측한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUserProfile</span><span class=\"token punctuation\">(</span>userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>userId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 여기에 뭐가 올지, 이미 예측하고 있다</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 코드를 읽는 숙련된 개발자의 뇌는 이미 “뭐 이제 응답 데이터를 파싱해서 리턴하겠지”라고 예측하고 있다. 그리고 실제로 <code class=\"language-text\">return response.data;</code> 같은 코드가 나오면 그 예측이 맞았으므로 추가적인 인지 비용이 거의 발생하지 않는다.</p>\n<p>하지만 만약 예측과 전혀 다른 쌩뚱맞은 코드가 나오면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">fetchUserProfile</span><span class=\"token punctuation\">(</span>userId<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> api<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>userId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    globalEventBus<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'user-fetched'</span><span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 엥 이거 뭐임?</span>\n    localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">setItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lastUser'</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 어라?</span>\n    analytics<span class=\"token punctuation\">.</span><span class=\"token function\">track</span><span class=\"token punctuation\">(</span><span class=\"token string\">'profile_view'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> userId <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 아 로깅을 왜 여기서 해</span>\n    <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">fetchUserProfile</code>이라는 이름에서 뇌가 예측한 것은 “사용자 프로필을 가져와서 돌려주는 함수”다. 그런데 이벤트 버스 발행, 로컬 스토리지 저장, 애널리틱스 추적이라는 예측 밖의 동작이 나타난다. 이때마다 뇌는 예측 오류 신호를 발생시키고, 시스템 2를 호출해서 이 코드가 왜 여기에 있는지를 분석하기 시작한다.</p>\n<p>즉, 우리가 두 번째 버전의 코드를 읽기 어렵다고 느끼는 이유는 함수의 이름은 <code class=\"language-text\">fetchUserProfile</code>이지만, 내부에서는 그와 전혀 상관없는 동작들이 발생하고 있기 대문이다. 이름이 설정한 예측과 실제 동작이 일치할수록 예측 오류가 줄어들고 인지 비용이 절감된다.</p>\n<p>이건 함수 내부뿐 아니라 인터페이스 설계에서도 마찬가지다. 필자와 같은 프론트엔드 개발자에게 익숙한 컴포넌트 인터페이스를 예시로 들어보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 예측 가능한 인터페이스</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">TextInput</span></span>\n  <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>setName<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">placeholder</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>이름을 입력하세요<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-tsx line-numbers\"><code class=\"language-tsx\"><span class=\"token comment\">// 예측이 어려운 인터페이스</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserNameInput</span></span>\n  <span class=\"token attr-name\">user</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">setUser</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>setUser<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">blank</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>이름을 입력하세요<span class=\"token punctuation\">\"</span></span>\n<span class=\"token punctuation\">/></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 번째 컴포넌트는 <code class=\"language-text\">value</code>, <code class=\"language-text\">onChange</code>, <code class=\"language-text\">defaultValue</code>라는 React 생태계에서 거의 모든 입력 컴포넌트가 공유하는 인터페이스를 따른다. 이 패턴을 수없이 접해온 개발자의 시스템 1은 “입력 컴포넌트구나”로 처리하고 넘어간다.</p>\n<p>반면 두 번째는 <code class=\"language-text\">user</code>, <code class=\"language-text\">setUser</code>, <code class=\"language-text\">blank</code>라는 비즈니스 로직에 강하게 결합되었거나 의미를 알기 어려운 인터페이스를 가지고 있다. 이 컴포넌트가 내부에서 <code class=\"language-text\">user</code> 객체의 어떤 필드를 건드리는지, <code class=\"language-text\">blank</code>는 도대체 언제 사용되는 것인지 파악하기 전까지는 안심하고 사용할 수가 없다. 매번 내부 구현을 들여다봐야 하고, 그때마다 예측 오류가 발생한다.</p>\n<p>즉 읽기 쉬운 코드를 작성하기 위해서 우리는 함수의 이름 뿐 아니라 변수명, 파일 구조, 디렉토리 구성, API 설계 등 코드베이스의 모든 수준에서 예측 가능성을 높여야한다.</p>\n<h2 id=\"그래서-좋은-코드란-결국\" style=\"position:relative;\">그래서 “좋은 코드”란 결국<a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%9E%80-%EA%B2%B0%EA%B5%AD\" aria-label=\"그래서 좋은 코드란 결국 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지의 내용을 정리해보면, “읽기 쉬운 코드”라는 주관적 느낌의 실체는 다음과 같다.</p>\n<hr>\n<ol>\n<li><strong>작업 기억을 초과하지 않는 코드</strong>: 동시에 머릿속에 담아야 할 맥락이 3~4개 이내인 코드</li>\n<li><strong>기존 청크와 매칭되는 코드</strong>: 익숙한 패턴을 사용해서 장기 기억의 스키마를 활용할 수 있는 코드</li>\n<li><strong>시스템 1에서 처리 가능한 코드</strong>: 시스템 2를 불필요하게 호출하지 않는, 패턴 인식만으로 이해 가능한 코드</li>\n<li><strong>시각적 구조가 논리적 구조와 일치하는 코드</strong>: 게슈탈트 원리에 부합하여 뇌의 지각 시스템이 구조를 자동으로 파악하는 코드</li>\n<li><strong>예측 가능한 코드</strong>: 이름과 구조에서 설정한 기대를 위반하지 않는 코드</li>\n<li><strong>외재적 인지 부하가 낮은 코드</strong>: 문제 자체의 복잡성만 남기고, 표현에서 오는 불필요한 복잡성을 제거한 코드</li>\n</ol>\n<hr>\n<p>이 목록을 보면 재밌는 사실을 하나 발견할 수 있다. 이 중 어느 것도 “정확한 코드”를 의미하지 않는다는 점이다.</p>\n<p>가독성과 정확성은 별개의 축이다. 완벽하게 정확하지만 읽기 불가능한 코드도 있고, 읽기는 쉽지만 틀린 코드도 있다. 다만 읽기 쉬운 코드는 버그를 발견하기도 쉽다. 외재적 부하가 낮으니, 뇌의 자원을 논리적 오류를 찾는 데 집중할 수 있기 때문이다.</p>\n<p>다만 한 가지 주의할 점이 있다. 카너먼은 시스템 1의 편향에 대해서도 경고했다. 시스템 1은 빠르지만, 그 속도의 대가로 편향이 존재한다. 대표적인 것이 익숙함 편향이다. 자신에게 익숙한 패턴을 “읽기 쉬운 코드”로 느끼는 것은 사실이지만, 그것이 객관적으로 최선인지는 별개의 문제다. 함수형 프로그래밍에 익숙한 개발자는 <code class=\"language-text\">for</code> 루프를 “읽기 어렵다”고 느낄 수 있고, 반대의 경우도 마찬가지다. 이때 “읽기 어렵다”는 느낌은 코드의 객관적 품질이 아니라, 자신의 시스템 1에 저장된 청크의 편향을 반영하는 것일 수 있다.</p>\n<p>코드 리뷰에서 “이해하기 어렵다”는 피드백을 줄 때, 한 번쯤 자문해볼 가치가 있다. 이게 정말로 인지 부하가 높은 코드인가, 아니면 단순히 내 시스템 1에 등록되지 않은 패턴인가? 전자라면 리팩토링이 필요하고, 후자라면 오히려 내 청크 라이브러리를 확장할 기회다.</p>\n<h2 id=\"마무리\" style=\"position:relative;\">마무리<a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>“읽기 쉬운 코드”는 그냥 느낌이나 취향의 문제가 아니다. 작업 기억의 용량 제한, 청킹 메커니즘, 이중 처리 시스템, 게슈탈트 지각 원리, 예측 부호화와 같은 인간의 인지 구조가 만들어내는 자연스러운 결과다.</p>\n<p>필자가 이전 글에서 “가독성은 주관적이다”라고 했던 이야기의 이유도 바로 여기에 있다. 청킹은 개인의 경험에 의존하고 시스템 1에 등록된 패턴은 사람마다 다르기 때문이다.</p>\n<p>같은 코드를 보고 누군가는 쉽다고 느끼고 누군가는 어렵다고 느끼는 건 그저 취향이 달라서가 아니라 뇌에 축적된 스키마가 다르기 때문이다. 가독성이 주관적일 수밖에 없는 이유 자체가 인지 구조에 내재되어 있는 셈이다.</p>\n<p>이상으로 우리는 왜 어떤 코드를 읽기 쉽다고 느낄까 포스팅을 마친다.</p>","fields":{"slug":"20260130-developer-intuition-readable-code-and-neuroscience","path":"/2026/01/30/developer-intuition-readable-code-and-neuroscience/","lang":"ko"},"frontmatter":{"title":"우리는 왜 어떤 코드를 읽기 쉽다고 느낄까","subTitle":"개발자의 직관과 코드 가독성, 그리고 뇌과학","date":"Jan 30, 2026","categories":["프로그래밍"],"tags":["뇌과학","가독성","인지심리학","DX"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/018bf68e64ee3bfca73cdc09a1144553/d803c/thumbnail.png","srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/d803c/thumbnail.png 320w,\n/static/018bf68e64ee3bfca73cdc09a1144553/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/fc5c5/thumbnail.webp 320w,\n/static/018bf68e64ee3bfca73cdc09a1144553/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/018bf68e64ee3bfca73cdc09a1144553/01fb2/thumbnail.png","srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/018bf68e64ee3bfca73cdc09a1144553/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"8cbe53c0-b1ad-5980-ba9e-035a2e8d9b9b","tableOfContents":"<ul>\n<li><a href=\"#%ED%83%80%EC%9E%85-%EA%B2%80%EC%82%AC%EB%8A%94-%EC%A0%95%EB%A7%90-%EA%B2%80%EC%82%AC%EC%9D%BC-%EB%BF%90%EC%9D%BC%EA%B9%8C\">타입 검사는 정말 “검사”일 뿐일까</a></li>\n<li><a href=\"#%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%84%B8-%EA%B8%B0%EB%91%A5-%ED%98%95%EC%8B%9D-%EB%85%BC%EB%A6%AC%ED%95%99-%EC%A7%91%ED%95%A9%EB%A1%A0-%EB%9E%8C%EB%8B%A4-%EB%8C%80%EC%88%98\">타입 시스템의 세 기둥: 형식 논리학, 집합론, 람다 대수</a></li>\n<li><a href=\"#%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EB%85%BC%EB%A6%AC%EC%A0%81-%EA%B5%AC%EC%A1%B0\">타입으로 보는 논리적 구조</a></li>\n<li><a href=\"#%ED%95%A9%EC%84%B1%EA%B3%BC-%EB%B3%80%ED%99%98\">합성과 변환</a></li>\n<li><a href=\"#typescript%EB%8A%94-100-%EB%85%BC%EB%A6%AC%EC%A0%81%EC%9D%B4%EC%A7%80-%EC%95%8A%EB%8B%A4\">TypeScript는 100% 논리적이지 않다</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","excerpt":"우리는 매일 타입을 사용하며, 무수한 타입 에러를 마주한다. 그때마다 에러 메시지를 읽고, 구글링해서 해결하긴 하지만 정작 “타입 시스템이 왜 이렇게 동작하는지”를 깊게 생각하며 문제를 해결하는 경우는 드물다. 타입을 쓸 줄 아는 것이 문법을 이해하는 것이라면, 타입 시스템을 이해하는 것은 그 문법이 왜 그렇게 설계되었는지에 대한 본질을 이해하는 것에 가깝다.","html":"<p>우리는 매일 타입을 사용하며, 무수한 타입 에러를 마주한다. 그때마다 에러 메시지를 읽고, 구글링해서 해결하긴 하지만 정작 “타입 시스템이 왜 이렇게 동작하는지”를 깊게 생각하며 문제를 해결하는 경우는 드물다.</p>\n<p>타입을 쓸 줄 아는 것이 문법을 이해하는 것이라면, 타입 시스템을 이해하는 것은 그 문법이 왜 그렇게 설계되었는지에 대한 본질을 이해하는 것에 가깝다.</p>\n<!-- more -->\n<p>사실 이러한 이해를 돕기 위해 <a href=\"/2024/01/30/category-theory-for-programmers-0-preface/\">“프로그래머를 위한 카테고리 이론”</a> 시리즈를 번역하면서 카테고리, 펑터, 합성 같은 개념을 다뤘었는데, 지금 돌아보니 진입 장벽이 꽤 높은 내용이라, 조금 더 쉬운 버전의 포스팅을 다시 작성하려고 한다.</p>\n<p>그래서 이번 포스팅에서는 타입과 논리학의 대응 관계를 중심으로, 타입 검사기가 “통과”라고 말할 때 그것이 정확히 무엇을 의미하는지 살펴보려 한다.</p>\n<h2 id=\"타입-검사는-정말-검사일-뿐일까\" style=\"position:relative;\">타입 검사는 정말 “검사”일 뿐일까<a href=\"#%ED%83%80%EC%9E%85-%EA%B2%80%EC%82%AC%EB%8A%94-%EC%A0%95%EB%A7%90-%EA%B2%80%EC%82%AC%EC%9D%BC-%EB%BF%90%EC%9D%BC%EA%B9%8C\" aria-label=\"타입 검사는 정말 검사일 뿐일까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>TypeScript를 처음 배울 때 대부분의 개발자는 타입 시스템을 일종의 린터(linter)처럼 받아들인다. 마치 린터처럼 잘못된 타입을 넣으면 빨간 줄이 그어지고, 올바른 타입을 넣으면 통과하기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Error: Argument of type 'string' is not assignable to parameter of type 'number'</span>\n<span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>틀린 말은 아니지만 이 관점에는 한 가지 빠진 것이 있다.</p>\n<p>타입 시스템은 단순히 에러를 잡는 도구가 아니다. 그 뒤에는 수학적 구조가 있고, 타입 검사를 통과한다는 것은 단순히 에러가 없다는 것 이상의 의미를 가진다. 타입은 논리학의 명제에 대응하고, 그 타입을 만족하는 코드는 그 명제의 증명에 대응한다.</p>\n<p>그렇다면 우리가 마주하는 타입 에러는 무엇일까? 단순한 실수일까, 아니면 우리가 암묵적으로 맺은 어떤 계약이 깨졌다는 신호일까.</p>\n<p>이 이야기를 이해하려면 가장 먼저 타입 시스템에 사용되는 기본적인 수학의 개념들에 대한 이야기를 해야한다.</p>\n<h2 id=\"타입-시스템의-세-기둥-형식-논리학-집합론-람다-대수\" style=\"position:relative;\">타입 시스템의 세 기둥: 형식 논리학, 집합론, 람다 대수<a href=\"#%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%84%B8-%EA%B8%B0%EB%91%A5-%ED%98%95%EC%8B%9D-%EB%85%BC%EB%A6%AC%ED%95%99-%EC%A7%91%ED%95%A9%EB%A1%A0-%EB%9E%8C%EB%8B%A4-%EB%8C%80%EC%88%98\" aria-label=\"타입 시스템의 세 기둥 형식 논리학 집합론 람다 대수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>타입 시스템은 세 가지 수학적 아이디어 위에 서 있다. 갑자기 수학에 대한 이야기가 나와서 어렵게 느껴질 수 있지만 걱정할 필요 없다. 이 개념들은 우리가 이미 코드로 매일 다루고 있는 것들이다.</p>\n<h4 id=\"형식-논리학-참이다를-증명한다는-것\" style=\"position:relative;\">형식 논리학: “참이다”를 증명한다는 것<a href=\"#%ED%98%95%EC%8B%9D-%EB%85%BC%EB%A6%AC%ED%95%99-%EC%B0%B8%EC%9D%B4%EB%8B%A4%EB%A5%BC-%EC%A6%9D%EB%AA%85%ED%95%9C%EB%8B%A4%EB%8A%94-%EA%B2%83\" aria-label=\"형식 논리학 참이다를 증명한다는 것 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>형식 논리학은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이다, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이거나 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이다, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이다 같은 논리들을 다루는 체계다. 핵심 아이디어는 “참이라고 주장하려면, 그것을 증명해야 한다는 것”이다.</p>\n<table>\n<thead>\n<tr>\n<th>기호</th>\n<th>일상적 의미</th>\n<th>예시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>∧</td>\n<td>그리고</td>\n<td>“우산도 있고 장화도 있다”</td>\n</tr>\n<tr>\n<td>∨</td>\n<td>또는</td>\n<td>“버스를 타거나 지하철을 탄다”</td>\n</tr>\n<tr>\n<td>→</td>\n<td>~하면 ~이다</td>\n<td>“비가 오면 땅이 젖는다”</td>\n</tr>\n</tbody>\n</table>\n<p>예를 들어 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\lor B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 참이라고 말하려면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>가 참임을 보여주거나, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 참임을 보여줘야 한다. “둘 중 하나는 참이겠지만 어느 쪽인지는 몰라요”라는 식의 주장은 증명으로 인정되지 않는다.</p>\n<p>그리고 일단 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\lor B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∨</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“를 받아들이면, 그로부터 무언가를 이끌어내기 위해서는 두 경우(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>)를 모두 다루는 분기가 필요하다는 것도 알 수 있다. 이는 마치 코드에서 <code class=\"language-text\">string | number</code>를 다룰 때 타입 좁히기가 필요한 이유와 같은 구조다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">  <span class=\"token comment\">// \"A 또는 B\"가 참이라고 주장하려면, 둘 중 하나를 구체적으로 보여줘야 한다</span>\n  <span class=\"token keyword\">type</span> <span class=\"token class-name\">Result</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> Result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// \"둘 중 하나겠지\"로는 안 된다. 어떤 경우인지 확인해야 한다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">.</span><span class=\"token function\">toFixed</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id=\"집합론-타입은-원소들의-모임이다\" style=\"position:relative;\">집합론: 타입은 원소들의 모임이다<a href=\"#%EC%A7%91%ED%95%A9%EB%A1%A0-%ED%83%80%EC%9E%85%EC%9D%80-%EC%9B%90%EC%86%8C%EB%93%A4%EC%9D%98-%EB%AA%A8%EC%9E%84%EC%9D%B4%EB%8B%A4\" aria-label=\"집합론 타입은 원소들의 모임이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>집합은 비슷한 것들을 모아놓은 주머니라고 생각하면 된다. 예를 들어 <code class=\"language-text\">number</code> 타입은 프로그램 상에서 표현할 수 있는 모든 숫자를 담은 주머니, <code class=\"language-text\">string</code> 타입은 모든 문자열을 담은 주머니이고, <code class=\"language-text\">number | string</code>은 이 두 주머니의 내용물을 합친 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 숫자 주머니에서 하나 꺼냄</span>\n<span class=\"token keyword\">const</span> n<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 문자열 주머니에서 하나 꺼냄</span>\n<span class=\"token keyword\">const</span> s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 둘 중 아무 주머니에서나 꺼낸 것</span>\n<span class=\"token keyword\">const</span> x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0.5</span> <span class=\"token operator\">?</span> <span class=\"token number\">42</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>타입을 집합으로 생각하면 많은 것이 자연스러워진다. <code class=\"language-text\">never</code> 타입은 빈 주머니이고, <code class=\"language-text\">unknown</code> 타입은 세상 모든 것이 들어있는 주머니다.</p>\n<p>물론 엄밀하게 이야기하자면 TypeScript의 실제 타입 시스템은 순수한 집합론과 다른 부분이 있지만, 이 정도 이해로도 직관을 잡기에는 충분하다.</p>\n<h4 id=\"람다-대수-함수-그-이상의-의미\" style=\"position:relative;\">람다 대수: 함수, 그 이상의 의미<a href=\"#%EB%9E%8C%EB%8B%A4-%EB%8C%80%EC%88%98-%ED%95%A8%EC%88%98-%EA%B7%B8-%EC%9D%B4%EC%83%81%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"람다 대수 함수 그 이상의 의미 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>람다 대수는 1930년대 알론조 처치(Alonzo Church)라는 수학자가 “계산이란 무엇인가?”라는 질문에 답하려고 만든 개념이다. 이름은 무시무시하게 느껴지지만, 사실 개발자라면 이미 매일 쓰고 있는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// 람다 대수로 표현하면 λx.x</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">identity</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 람다 대수로 표현하면 λx.λy.x</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">first</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> <span class=\"token parameter\">y</span> <span class=\"token operator\">=></span> x<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>화살표 함수는 람다(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi></mrow><annotation encoding=\"application/x-tex\">\\lambda</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λ</span></span></span></span></span>) 표기의 현대적 문법에 가깝고, 람다 대수의 핵심 아이디어인 “함수 정의와 적용”을 가장 직접적으로 보여준다. 처치가 증명한 놀라운 사실은 이 단순한 개념만으로도 사칙연산, 조건문, 반복문, 심지어 숫자 자체까지 모두 표현할 수 있다는 것이다.</p>\n<p>물론 실제 JavaScript 함수는 부수효과, 예외, <code class=\"language-text\">this</code> 바인딩, 런타임 객체 모델 같은 것 때문에 람다 대수와 100% 동일하다고 말하기는 어렵다. 하지만 “계산이란 결국 함수를 만들고 적용하는 것”이라는 핵심적인 통찰은 공유하기 때문에 이 정도 이해로도 충분하다.</p>\n<h4 id=\"세-세계가-만나는-지점-curry-howard-대응\" style=\"position:relative;\">세 세계가 만나는 지점: Curry-Howard 대응<a href=\"#%EC%84%B8-%EC%84%B8%EA%B3%84%EA%B0%80-%EB%A7%8C%EB%82%98%EB%8A%94-%EC%A7%80%EC%A0%90-curry-howard-%EB%8C%80%EC%9D%91\" aria-label=\"세 세계가 만나는 지점 curry howard 대응 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>그렇다면 이 세 가지 개념이 타입 시스템에 어떻게 사용되고 있다는 것일까? 이 질문에 대한 답을 하려면 이 개념들을 하나로 묶어주는 Curry-Howard 대응에 대해 이야기해야한다.</p>\n<p>Curry-Howard 대응 또는 Curry-Howard 동형이라고 불리는 개념은 컴퓨터 프로그램과 논리적 증명을 직접적으로 연관시키는 대응 관계를 의미한다. 더 정확하게 말하자면 논리학의 증명 규칙과 타입 시스템의 타입 규칙이 서로 대응한다는 주장이다.</p>\n<p>이 개념은 이미 1930년대에 하스켈 커리(Haskell Curry)라는 논리학자가 람다 대수에 타입을 붙여보다가 발견한 규칙이며, 이후 1969년 윌리엄 하워드(William Howard)가 이 발견을 더 깊이 파고들어 아래와 같은 대응 관계를 확립했다.</p>\n<table>\n<thead>\n<tr>\n<th>논리학에서</th>\n<th>프로그래밍에서</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>명제</td>\n<td>타입</td>\n</tr>\n<tr>\n<td>증명</td>\n<td>프로그램</td>\n</tr>\n<tr>\n<td>A이면 B</td>\n<td>A를 받아 B를 반환하는 함수</td>\n</tr>\n<tr>\n<td>A 그리고 B</td>\n<td>A와 B를 둘 다 가진 튜플/객체</td>\n</tr>\n<tr>\n<td>A 또는 B</td>\n<td>A이거나 B인 유니온 타입</td>\n</tr>\n<tr>\n<td>거짓 (증명 불가능)</td>\n<td>never (값이 존재할 수 없음)</td>\n</tr>\n</tbody>\n</table>\n<p>결국 이 개념의 핵심을 한 줄로 요약해보면 아래와 같다.</p>\n<blockquote>\n<p>타입은 명제에 대응하고, 그 타입의 값을 만드는 프로그램은 그 명제의 증명에 대응한다.</p>\n</blockquote>\n<p>TypeScript는 실용을 위해 이 아이디어를 부분적으로 차용한 언어다. 부분적으로 차용한 언어라는 의미는 <code class=\"language-text\">any</code>나 타입 단언 같은 탈출구가 있기 때문이다.</p>\n<p>그래서 이 글에서 “증명”이라는 표현은 “타입 규칙이 요구하는 계약을 충족한다” 정도로 이해하면 된다. TypeScript의 한계에 대해서는 글 끝에서 다시 이야기해보겠다.</p>\n<h2 id=\"타입으로-보는-논리적-구조\" style=\"position:relative;\">타입으로 보는 논리적 구조<a href=\"#%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%B3%B4%EB%8A%94-%EB%85%BC%EB%A6%AC%EC%A0%81-%EA%B5%AC%EC%A1%B0\" aria-label=\"타입으로 보는 논리적 구조 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그렇다면 이 Curry-Howard 대응이 실제로 어떻게 나타나는지 하나씩 뜯어보자.</p>\n<h4 id=\"함수-a이면-b의-증거\" style=\"position:relative;\">함수: “A이면 B”의 증거<a href=\"#%ED%95%A8%EC%88%98-a%EC%9D%B4%EB%A9%B4-b%EC%9D%98-%EC%A6%9D%EA%B1%B0\" aria-label=\"함수 a이면 b의 증거 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>먼저 가장 핵심적인 대응인 함수 타입부터 살펴보자. 함수 타입 <code class=\"language-text\">(a: A) => B</code>는 논리학에서 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>에 해당한다.</p>\n<p>이게 무슨 말일까? 이해를 돕기 위해 조금 더 일상적인 비유로 풀어보면 이렇다.</p>\n<p>친구가 “네가 밀가루를 주면, 내가 빵을 만들어줄게”라고 약속했다고 하자. 이것은 “밀가루 → 빵”이라는 명제다. 그렇다면 이 약속이 진짜인지는 어떻게 확인할 수 있을까? 간단하다. 실제로 밀가루를 줬을 때 빵이 나오면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">makeBread</span><span class=\"token punctuation\">(</span>flour<span class=\"token operator\">:</span> Flour<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Bread <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 밀가루를 반죽하고, 발효시키고, 굽는 과정을 거친 뒤...</span>\n  <span class=\"token keyword\">return</span> bread<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 함수가 타입 검사를 통과한다는 것은, “밀가루를 주면 빵을 만들 수 있다”는 약속이 타입 규칙 안에서 이행 가능함을 보여준 것이다. 함수의 구현체 자체가 그 계약의 이행인 셈이다.</p>\n<p>그렇다면 반대로 타입 에러가 발생한다면 어떻게 되는 걸까?</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">makeBread</span><span class=\"token punctuation\">(</span>flour<span class=\"token operator\">:</span> Flour<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Bread <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Error: Type 'Flour' is not assignable to type 'Bread'</span>\n  <span class=\"token keyword\">return</span> flour<span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>원래 밀가루를 주면 빵을 만들어서 주기로 했는데, 뜬금없이 밀가루를 다시 돌려줬으니 이것은 계약 불이행이라고 볼 수 있고, 따라서 타입 에러가 발생한다.</p>\n<p>또한 이 계약과 구조가 제대로 지켜지면 이제 우리는 함수의 동작 결과를 추론할 수 있게 된다.</p>\n<p>논리학에는 전건 긍정(Modus Ponens)이라는 추론 규칙이 있는데, 간단하게 정리해보면 아래와 같다.</p>\n<blockquote>\n<p>”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이다”가 참이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>가 참이면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>도 참이다.</p>\n</blockquote>\n<p>예를 들어 “비가 오면 땅이 젖는다”는 명제가 참이고 “비가 온다”라는 명제도 참이라면, 이에 따라 “땅이 젖는다”라는 명제도 참이라는 것을 손쉽게 추론할 수 있다. 이 구조는 프로그래밍에서 함수 호출과 같은 구조이기 때문에 우리는 함수의 결과 타입을 추론할 수 있게 되는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// \"밀가루 → 빵\" 약속</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">makeBread</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>flour<span class=\"token operator\">:</span> Flour<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Bread <span class=\"token operator\">=</span> <span class=\"token comment\">/* ... */</span><span class=\"token punctuation\">;</span>  \n\n<span class=\"token comment\">// 밀가루가 있음</span>\n<span class=\"token keyword\">const</span> flour<span class=\"token operator\">:</span> Flour <span class=\"token operator\">=</span> <span class=\"token function\">getFlour</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 따라서 빵을 얻음</span>\n<span class=\"token keyword\">const</span> bread<span class=\"token operator\">:</span> Bread <span class=\"token operator\">=</span> <span class=\"token function\">makeBread</span><span class=\"token punctuation\">(</span>flour<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>함수 <code class=\"language-text\">makeBread</code>는 “밀가루를 주면 빵을 만들어준다”라는 명제이다. 즉, 이 명제가 참이고 “밀가루를 준다”라는 명제도 참이라면 자연스럽게 <code class=\"language-text\">bread</code> 변수에 담기는 값이 <code class=\"language-text\">Bread</code> 타입이라는 명제도 참이 되는 것이다.</p>\n<p>우리가 매일 하는 함수의 호출과 결과 타입의 추론은 이러한 논리적 추론과 같은 구조를 가지고 있는 것이다.</p>\n<h4 id=\"튜플-그리고의-증거\" style=\"position:relative;\">튜플: “그리고”의 증거<a href=\"#%ED%8A%9C%ED%94%8C-%EA%B7%B8%EB%A6%AC%EA%B3%A0%EC%9D%98-%EC%A6%9D%EA%B1%B0\" aria-label=\"튜플 그리고의 증거 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>논리학의 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> 그리고 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“는 프로그래밍의 튜플이나 객체에 해당한다.</p>\n<p>일상적인 예로 생각해보자. 해외여행을 가려면 “여권이 있고 비행기 표도 있다”는 조건을 만족해야 한다. 이 조건을 충족하려면? 여권과 비행기 표를 둘 다 보여주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">CanTravel</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>Passport<span class=\"token punctuation\">,</span> Ticket<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// \"여행 가능\" 조건의 충족 = 여권과 티켓을 모두 갖춘 튜플</span>\n<span class=\"token keyword\">const</span> proof<span class=\"token operator\">:</span> CanTravel <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>myPassport<span class=\"token punctuation\">,</span> myTicket<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 <code class=\"language-text\">CanTravel</code> 타입이 만족했다면, 다른 말로 “여권도 있고 비행기 표도 있다”는 조건이 만족했다면 아래와 같이 <code class=\"language-text\">CanTravel</code> 타입의 튜플에서 여권이나 비행기표 모두 자유롭게 꺼내올 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getPassport</span><span class=\"token punctuation\">(</span>travel<span class=\"token operator\">:</span> CanTravel<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Passport <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// \"A 그리고 B\"에서 A를 꺼냄</span>\n  <span class=\"token keyword\">return</span> travel<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getTicket</span><span class=\"token punctuation\">(</span>travel<span class=\"token operator\">:</span> CanTravel<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Ticket <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// \"A 그리고 B\"에서 B를 꺼냄</span>\n  <span class=\"token keyword\">return</span> travel<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이것은 논리학에서 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\land B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 참이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>도 참이다”라는 규칙과 같은 구조다. 튜플에서 요소를 꺼내는 것이 논리적 추론과 대응되는 셈이다.</p>\n<h4 id=\"유니온-또는의-증거\" style=\"position:relative;\">유니온: “또는”의 증거<a href=\"#%EC%9C%A0%EB%8B%88%EC%98%A8-%EB%98%90%EB%8A%94%EC%9D%98-%EC%A6%9D%EA%B1%B0\" aria-label=\"유니온 또는의 증거 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>TypeScript의 유니온 타입 <code class=\"language-text\">A | B</code>는 논리학의 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“에 해당한다. 여기서 중요한 점은 우리가 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“가 참이라고 주장하려면 반드시 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>가 참이라는 사실을 보여주거나, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 참이라는 사실을 보여줘야 한다는 것이다. 두 논리 중 하나를 구체적으로 제시해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">PaymentMethod</span> <span class=\"token operator\">=</span> CreditCard <span class=\"token operator\">|</span> BankTransfer<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// \"신용카드 또는 계좌이체\"의 충족 = 둘 중 하나를 구체적으로 제시</span>\n<span class=\"token keyword\">const</span> payment1<span class=\"token operator\">:</span> PaymentMethod <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'credit'</span><span class=\"token punctuation\">,</span> cardNumber<span class=\"token operator\">:</span> <span class=\"token string\">'1234...'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> payment2<span class=\"token operator\">:</span> PaymentMethod <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'bank'</span><span class=\"token punctuation\">,</span> accountNumber<span class=\"token operator\">:</span> <span class=\"token string\">'5678...'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>또한 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“라는 명제가 참이라고 해도 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span> 둘 중 뭐가 참인지 구체적으로 확인하기 전까지는 알 수가 없다는 것과 같다.</p>\n<p>그래서 이 명제로부터 다른 무언가를 이끌어내려면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>에 대한 처리를 모두 해줘야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">processPayment</span><span class=\"token punctuation\">(</span>method<span class=\"token operator\">:</span> PaymentMethod<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Receipt <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> <span class=\"token string\">'credit'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// A인 경우 처리</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">chargeCreditCard</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// B인 경우 처리</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">processBankTransfer</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이것이 TypeScript에서 Exhaustiveness check가 중요한 이유다. 논리적으로 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span> 또는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>“를 다룰 때는 두 경우 모두에 대한 전략이 있어야만 완전한 처리가 되기 때문이다.</p>\n<p>다만 TypeScript가 모든 케이스를 다뤘는지 자동으로 체크해주는 것은 설정과 코드 패턴에 따라 달라진다. 그러니 확실하게 Exhaustiveness check를 강제하고 싶다면 아래와 같은 패턴을 사용하는 것이 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">assertNever</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">never</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unexpected value\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Shape</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'circle'</span><span class=\"token punctuation\">;</span> radius<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'square'</span><span class=\"token punctuation\">;</span> side<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'triangle'</span><span class=\"token punctuation\">;</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">area</span><span class=\"token punctuation\">(</span>shape<span class=\"token operator\">:</span> Shape<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>shape<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'circle'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token constant\">PI</span> <span class=\"token operator\">*</span> shape<span class=\"token punctuation\">.</span>radius <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">'square'</span><span class=\"token operator\">:</span>\n      <span class=\"token keyword\">return</span> shape<span class=\"token punctuation\">.</span>side <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n      <span class=\"token comment\">// Argument of type '{ type: \"triangle\"; height: number; }' is not assignable to parameter of type 'never'.</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">assertNever</span><span class=\"token punctuation\">(</span>shape<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>기본적으로 유니온 타입의 모든 케이스를 처리했다면 <code class=\"language-text\">default</code>에 도달할 일이 없고, <code class=\"language-text\">shape</code>는 <code class=\"language-text\">never</code> 타입이 된다. 하지만 만약 새로운 도형을 추가했는데 처리를 깜빡했다면, <code class=\"language-text\">shape</code>가 <code class=\"language-text\">never</code> 타입이 아니게 되고 컴파일 에러가 발생한다.</p>\n<h4 id=\"never-불가능의-표현\" style=\"position:relative;\">never: “불가능”의 표현<a href=\"#never-%EB%B6%88%EA%B0%80%EB%8A%A5%EC%9D%98-%ED%91%9C%ED%98%84\" aria-label=\"never 불가능의 표현 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>TypeScript의 <code class=\"language-text\">never</code> 타입은 “이런 값은 존재할 수 없다”를 의미한다. 논리학에서는 이것을 모순 또는 거짓이라고 표현한다.</p>\n<p>앞서 언급했던 집합론으로 비유하자면, <code class=\"language-text\">never</code> 타입은 빈 주머니다. 즉, <code class=\"language-text\">never</code>라는 주머니 안에는 아무것도 없고, 앞으로도 없을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">throwError</span><span class=\"token punctuation\">(</span>message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">never</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 이 함수는 정상적으로 반환되지 않는다</span>\n  <span class=\"token comment\">// 반환값이 \"존재할 수 없다\"</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서 논리학의 재미있는 원리 하나가 나온다. 바로 “모순으로부터는 무엇이든 도출할 수 있다”는 것이다. 이는 라틴어로 “Ex falso quodlibet”이라고 하는데, 쉽게 말하면 불가능한 상황이 발생했다면, 그 다음에는 뭐든지 가능하다는 것이다.</p>\n<p>이 원리는 타입스크립트에서 아래와 같은 함수를 선언해봄으로써 구현해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">absurd</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// never에서는 어떤 타입으로든 변환 가능</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 ”<code class=\"language-text\">never</code>이면 <code class=\"language-text\">T</code>이다”라는 규칙을 표현하고 있다. 한번 <code class=\"language-text\">never</code> 타입을 다른 구체적인 타입으로 바꿔보면 바로 에러가 발생하는 것을 알 수 있다. <code class=\"language-text\">never</code>는 거짓, 모순이기 때문이 그 다음에는 어떤 타입이 오든 논리적으로 틀린 것이 아닌 것이다.</p>\n<p>사실 이 부분도 정확하게 뜯어보면 TypeScript가 Ex falso을 정확하게 구현한 것은 아니긴 하다.</p>\n<p><code class=\"language-text\">never</code> 타입은 모든 타입의 서브 타입으로 취급되는 바닥 타입(Bottom Type)이기 때문에, <code class=\"language-text\">never</code> 타입의 값은 어떤 타입 위치에도 대입 가능한 것으로 간주된다. 논리학의 Ex falso 원리와 닮긴 했지만 실제로는 서브타이핑의 결과라고 볼 수 있다.</p>\n<h4 id=\"제네릭-모든-경우에-통하는-계약\" style=\"position:relative;\">제네릭: “모든 경우에 통하는” 계약<a href=\"#%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%AA%A8%EB%93%A0-%EA%B2%BD%EC%9A%B0%EC%97%90-%ED%86%B5%ED%95%98%EB%8A%94-%EA%B3%84%EC%95%BD\" aria-label=\"제네릭 모든 경우에 통하는 계약 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>우리는 제네릭을 처음 배울 때 보통 “타입을 나중에 정하는 것”이라고 배운다. 사실 이것도 틀린 말은 아니지만, 제네릭이 의미하는 바는 더 심오하다.</p>\n<p>논리학에는 전칭 명제라는 것이 있는데, 이는 “모든 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span></span>에 대해 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">P(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span></span>가 성립한다”는 형태의 명제다. 예를 들어 “모든 사람은 죽는다”처럼 말이다.</p>\n<p>그리고 제네릭 함수는 바로 이 전칭 명제와 비슷한 구조를 가진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">identity</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이 함수는 “모든 타입 <code class=\"language-text\">T</code>에 대해, <code class=\"language-text\">T</code>를 주면 <code class=\"language-text\">T</code>를 돌려줄 수 있다”는 계약을 표현한다.</p>\n<p>여기서 중요한 것은 “모든 경우”에 대해 성립함을 보여야한다는 점인데, 이게 가능하려면 어떠한 특정 경우에 대한 가정도 하면 안된다.</p>\n<p>그래서 우리가 제네릭 타입을 사용했을 때 아래와 같은 가정을 하면 바로 타입 에러가 발생하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">broken</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 모든 T가 number임을 가정하면...</span>\n  <span class=\"token comment\">// Operator '+' cannot be applied to types 'T' and 'number'.</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위와 같이 <code class=\"language-text\">T</code>가 <code class=\"language-text\">number</code>라고 가정하는 순간, 이것은 더 이상 모든 <code class=\"language-text\">T</code>에 대한 계약이 아니라, <code class=\"language-text\">number</code>에 대한 계약으로 범위가 좁아져 버린다. 더이상 전칭 명제라고 보기 어려운 것이다.</p>\n<p>그래서 우리는 “모든” 이라는 전제에 제약을 추가함으로서 이 문제를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">addOne</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// OK</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위와 같이 <code class=\"language-text\">T</code>가 <code class=\"language-text\">number</code>를 상속받았다면 자연스럽게 <code class=\"language-text\">T</code>는 이제 ”<code class=\"language-text\">number</code>의 부분 집합인 <code class=\"language-text\">T</code>“로 개념이 변경된다. 즉, “모든” 이라는 개념의 범위를 조정하는 제약을 거는 것이다. 그래서 우리는 이런 제약을 걸때 <code class=\"language-text\">extends</code>라는 상속 키워드를 사용한다.</p>\n<h2 id=\"합성과-변환\" style=\"position:relative;\">합성과 변환<a href=\"#%ED%95%A9%EC%84%B1%EA%B3%BC-%EB%B3%80%ED%99%98\" aria-label=\"합성과 변환 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지는 타입과 논리학의 기본적인 대응 관계를 살펴봤다. 이제부터는 이것들을 조합하고 변환하는 방법에 대해서 이야기해보도록 하자.</p>\n<h4 id=\"함수-합성-추론을-연결하기\" style=\"position:relative;\">함수 합성: 추론을 연결하기<a href=\"#%ED%95%A8%EC%88%98-%ED%95%A9%EC%84%B1-%EC%B6%94%EB%A1%A0%EC%9D%84-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"함수 합성 추론을 연결하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>논리학에는 삼단논법이라는 것이 있다. 가장 기본적인 정언적 삼단논법은 “만약 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이고, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>라면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>이다”로 표현할 수 있다.</p>\n<p>이러한 삼단논법은 가정을 기반으로 한 가언적 삼단논법으로 표현할 수도 있는데, 이 경우 아래와 같은 명제가 된다.</p>\n<blockquote>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이다.\n<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>이다.\n그러므로 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>이면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>이다.</p>\n</blockquote>\n<p>예를 들어 “밥을 먹으면 배부르다”라는 명제가 참이고, “배부르면 잠이온다”라는 명제가 참이라면, “밥을 먹으면 잠이 온다”라는 명제도 참이라는 것이다. 그리고 이것이 프로그래밍에서는 함수의 합성으로 표현된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">compose</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">C</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">f</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">B</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">g</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">C</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">C</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> parseNumber <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=></span> <span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> isPositive <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span> <span class=\"token operator\">=></span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// string → number와</span>\n<span class=\"token comment\">// number → boolean을 연결하면</span>\n<span class=\"token comment\">// string → boolean이 된다</span>\n<span class=\"token keyword\">const</span> isPositiveString <span class=\"token operator\">=</span> <span class=\"token function\">compose</span><span class=\"token punctuation\">(</span>parseNumber<span class=\"token punctuation\">,</span> isPositive<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">isPositiveString</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"42\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이는 마치 작은 추론들을 연결해서 더 크고 복잡한 추론을 만드는 것과 동일한데, 이렇게 작고 간단한 구조를 쌓아나가며 큰 구조를 만들 수 있다는 점이 함수 합성이 강력한 이유이다.</p>\n<p>그래서 함수형 프로그래밍에서는 <code class=\"language-text\">pipe</code>나 <code class=\"language-text\">compose</code>와 같은 개념이나 펑터(Functor)나 모나드(Monad)와 같이 함수의 합성과 관련된 개념들이 핵심이 된다.</p>\n<p>사실 카테고리 이론에서는 이 합성이야말로 카테고리의 본질이라고 말한다. 만약 관심이 있다면 <a href=\"/2024/01/30/category-theory-for-programmers-1-category/\">“프로그래머를 위한 카테고리 이론 - 1. 카테고리: 합성의 본질”</a>도 참고해보자.</p>\n<h4 id=\"커링-논리적으로-자연스러운-변환\" style=\"position:relative;\">커링: 논리적으로 자연스러운 변환<a href=\"#%EC%BB%A4%EB%A7%81-%EB%85%BC%EB%A6%AC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%90%EC%97%B0%EC%8A%A4%EB%9F%AC%EC%9A%B4-%EB%B3%80%ED%99%98\" aria-label=\"커링 논리적으로 자연스러운 변환 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>커링(Currying)은 여러 인자를 받는 함수를 한 인자씩 받는 함수의 체인으로 바꾸는 패턴을 의미한다. 커링을 사용하면 어떤 함수든 단항 함수라는 공통의 패턴으로 만들 수 있기 때문에 합성하기가 편해진다는 장점이 있다.</p>\n<p>한 가지 재미있는 점은 다항 함수를 단항 함수의 합성으로 변환하는 것이 항상 가능하다는 점이다. 왜 이 변환이 항상 가능한 것일까?</p>\n<p>논리학에는 수출 법칙(Exportation)이라는 동치 관계가 있는데, 커링은 바로 이 개념을 활용한 패턴이다.</p>\n<blockquote>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>∧</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>C</mi><mo>≡</mo><mi>A</mi><mo>→</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo>→</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(A \\land B) \\rightarrow C \\equiv A \\rightarrow (B \\rightarrow C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>“(A 그리고 B)이면 C이다”와 “A이면 (B이면 C이다)“는 논리적으로 동치다.</p>\n</blockquote>\n<p>엄밀히 말하면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>∧</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">(A \\land B) \\rightarrow C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>는 ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span></span>와 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>를 튜플로 받아 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></span>를 반환하는 함수”에 대응하며, JavaScript의 다중 인자 함수는 이를 실용적으로 근사한 형태라고 이해하는 것이 정확하다.</p>\n<p>조금 더 일상적인 상황을 예를 들어 보면, “밀가루와 물이 있으면 반죽을 만들 수 있다”라는 명제와 “밀가루가 있으면, (물이 있으면 반죽을 만들 수 있다)“라는 명제는 같은 의미를 가진다는 것이다. 그래서 이 변환은 항상 안전하게 진행된다는 것이 보장된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token comment\">// 두 인자를 한번에 받음</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">makeDough</span><span class=\"token punctuation\">(</span>flour<span class=\"token operator\">:</span> Flour<span class=\"token punctuation\">,</span> water<span class=\"token operator\">:</span> Water<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Dough <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">mix</span><span class=\"token punctuation\">(</span>flour<span class=\"token punctuation\">,</span> water<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 한 인자씩 받음 (커링)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">makeDoughCurried</span><span class=\"token punctuation\">(</span>flour<span class=\"token operator\">:</span> Flour<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>water<span class=\"token operator\">:</span> Water<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Dough <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>water<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">mix</span><span class=\"token punctuation\">(</span>flour<span class=\"token punctuation\">,</span> water<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 둘은 논리적으로 동등하다</span>\n<span class=\"token keyword\">const</span> dough1 <span class=\"token operator\">=</span> <span class=\"token function\">makeDough</span><span class=\"token punctuation\">(</span>flour<span class=\"token punctuation\">,</span> water<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> dough2 <span class=\"token operator\">=</span> <span class=\"token function\">makeDoughCurried</span><span class=\"token punctuation\">(</span>flour<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>water<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>즉, 다항 함수를 단항 함수로 변경하는 커링이 가능한 이유는 단순한 프로그래밍 기법이 아니라 논리적 동치 관계와 닮아있기 때문이다.</p>\n<h4 id=\"타입-대수-덧셈과-곱셈처럼\" style=\"position:relative;\">타입 대수: 덧셈과 곱셈처럼<a href=\"#%ED%83%80%EC%9E%85-%EB%8C%80%EC%88%98-%EB%8D%A7%EC%85%88%EA%B3%BC-%EA%B3%B1%EC%85%88%EC%B2%98%EB%9F%BC\" aria-label=\"타입 대수 덧셈과 곱셈처럼 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>혹시 대수적 데이터 타입(Algebraic Data Type)이라는 말을 들어본 적이 있는가? 이 말은 타입에도 대수학에서의 사칙연산과 같은 연산 법칙들을 적용할 수 있다는 것이다.</p>\n<p>예를 들어 곱 타입과 합 타입이 있는데, 대표적인 곱 타입은 위에서 한번 언급했던 “그리고”를 의미하는 튜플, 그리고 합 타입은 “또는”을 의미하는 유니언 타입이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Bool</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token operator\">|</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 2가지 값</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Pair</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>Bool<span class=\"token punctuation\">,</span> Bool<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 2 * 2 = 4가지 값</span>\n<span class=\"token comment\">// [true, true], [true, false], [false, true], [false, false]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Three</span> <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'b'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 3가지 값</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Five</span> <span class=\"token operator\">=</span> Three <span class=\"token operator\">|</span> Bool<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 3 + 2 = 5가지 값</span>\n<span class=\"token comment\">// 'a', 'b', 'c', true, false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이것이 대수적 데이터 타입(Algebraic Data Types)이라는 이름이 붙은 이유다. 타입을 값의 경우의 수 관점에서 바라보면 합 타입은 덧셈처럼, 그리고 곱 타입은 곱셈처럼 동작한다.</p>\n<p>더 흥미로운 점은 대수학에서처럼 타입에서도 분배법칙이 등장한다는 것이다. 수학적으로는 다음과 같은 관계가 성립한다.</p>\n<blockquote>\n<p><span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo>+</mo><mi>C</mi><mo stretchy=\"false\">)</mo><mo>≡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>×</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\times (B + C) \\equiv (A \\times B) + (A \\times C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span></p>\n</blockquote>\n<p>TypeScript에서도 이 구조는 특정 지점에서 매우 명확하게 드러난다. 바로 조건부 타입(Conditional Type) 이다.</p>\n<p>TypeScript의 조건부 타입은 유니온 타입에 대해 자동으로 분배(distribute)된다. 이 성질을 이용하면 타입 대수의 분배법칙을 직접 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">PairWith<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token builtin\">any</span></span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">A</span></span> <span class=\"token operator\">=</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">B</span></span> <span class=\"token operator\">=</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// boolean = true | false이기 때문에 3가지 곱의 합으로 분배된다</span>\n<span class=\"token comment\">// [string, number] | [string, false] | [string, true]</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Result</span> <span class=\"token operator\">=</span> PairWith<span class=\"token operator\">&lt;</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">B</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 예시는 <code class=\"language-text\">B</code>가 <code class=\"language-text\">number | boolean</code>이라는 합 타입일 때, <code class=\"language-text\">[A, B]</code>라는 곱타입은 다시 <code class=\"language-text\">[A, number] | [A, boolean]</code>이라는 합 타입으로 분배될 수 있음을 보여준다.</p>\n<p>즉, 타입 레벨에서도 대수의 분배 법칙과 동일하게 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo>+</mo><mi>C</mi><mo stretchy=\"false\">)</mo><mo>≡</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mi>A</mi><mo>×</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">A \\times (B + C) \\equiv (A \\times B) + (A \\times C)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span></span>의 모습이 보여지는 것이다.</p>\n<p>물론 TypeScript의 타입 시스템은 이러한 분배 구조를 항상 자동으로 동일한 타입으로 취급하지는 않는다. 하지만 최소한 타입을 계산하고 변환하는 규칙의 수준에서는 대수적 데이터 타입의 덧셈, 곱셈, 분배라는 아이디어가 분명하게 살아있다고 볼 수 있다.</p>\n<p>카테고리 이론에서는 이 곱과 합을 보편적 구성(Universal Construction)이라는 더 추상적인 관점에서 다룬다. <a href=\"/2024/04/18/category-theory-for-programmers-9-function-types/\">“프로그래머를 위한 카테고리 이론 - 9. 함수 타입”</a>에서 이 대수적 구조가 어떻게 확장되는지 볼 수 있다.</p>\n<h2 id=\"typescript는-100-논리적이지-않다\" style=\"position:relative;\">TypeScript는 100% 논리적이지 않다<a href=\"#typescript%EB%8A%94-100-%EB%85%BC%EB%A6%AC%EC%A0%81%EC%9D%B4%EC%A7%80-%EC%95%8A%EB%8B%A4\" aria-label=\"typescript는 100 논리적이지 않다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>기본적인 개념들에 대해서 살펴봤다면, 이제는 필자가 위에서 언급했던 TypeScript의 한계에 대해 한번 알아보자.</p>\n<p>필자는 TypeScript가 Curry-Howard 대응을 부분적으로 차용한 언어라고 했는데, 그 한계가 뭘까?</p>\n<p>TypeScript는 언어의 실용성을 높이기 위해 의도적으로 논리적 모순을 초래할 수 있는 몇 가지 탈출구를 제공한다. 이 포스팅에서는 그 중 대표적인 두 가지에 대해서 이야기해보려 한다.</p>\n<p>첫 번째 탈출구는 <code class=\"language-text\">any</code>와 타입 단언의 존재이다. <code class=\"language-text\">any</code>는 어떤 타입이든 검사하지 않고 통과시키겠다는 선언이다. 즉, 논리학적으로 보면 “검증 없이 뭐든 참으로 인정”하는 것과 같다. <code class=\"language-text\">as</code>를 통한 타입 단언도 마찬가지다.</p>\n<p>이것들은 증명 체계를 우회하는 탈출구이고, 이로 인해 TypeScript는 논리적인 모순을 허용하는 언어가 되어버렸다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> x<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> y<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token comment\">// number 타입에 문자열 할당</span>\n\n<span class=\"token keyword\">const</span> z <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">unknown</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 타입 강제 변환</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>두 번째 탈출구는 바로 구조적 타이핑의 코너 케이스들이다. 대표적으로는 함수 파라미터의 이변성(Bivariance), 인덱스 시그니처, 옵셔널 프로퍼티 등의 탈출구로 인해 논리적 해석이 흔들리는 경우가 존재한다.</p>\n<p>논리적으로 함수 파라미터는 반공변(Contravariant)적이어야 한다. 쉽게 말해 <code class=\"language-text\">Dog</code>가 <code class=\"language-text\">Animal</code>의 서브타입이라면, <code class=\"language-text\">(animal: Animal) => void</code>가 <code class=\"language-text\">(dog: Dog) => void</code>의 서브타입이어야 한다는 것이다. 이는 더 넓은 타입을 받는 함수가 더 좁은 타입을 받는 함수를 대체할 수 있기 때문이다.</p>\n<p>하지만 TypeScript는 메소드 문법으로 선언된 함수에서 이를 이변적으로 처리한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\">  <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Dog</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Animal</span> <span class=\"token punctuation\">{</span> breed<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">type</span> <span class=\"token class-name\">Handler</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>animal<span class=\"token operator\">:</span> Animal<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> dogHandler<span class=\"token operator\">:</span> Handler <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Dog만 처리하는 함수인데 Animal을 받는 자리에 할당됨</span>\n    <span class=\"token comment\">// strictFunctionTypes로도 잡히지 않음</span>\n    <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>dog<span class=\"token operator\">:</span> Dog<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>dog<span class=\"token punctuation\">.</span>breed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  dogHandler<span class=\"token punctuation\">.</span><span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">\"cat\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 런타임 에러 가능</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그리고 인덱스 시그니처 또한 논리적인 모순을 초래할 수 있다. 객체에서 존재하지 않는 키에 접근하더라도 TypeScript는 <code class=\"language-text\">undefined</code>가 아닌 선언된 타입으로 추론하기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> scores<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">[</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> alice<span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> bobScore <span class=\"token operator\">=</span> scores<span class=\"token punctuation\">[</span><span class=\"token string\">\"bob\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 타입은 number, 실제 값은 undefined</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>bobScore<span class=\"token punctuation\">.</span><span class=\"token function\">toFixed</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 런타임 에러</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>조금 더 엄밀한 타입 체크를 원한다면 tsconfig의 <code class=\"language-text\">noUncheckedIndexedAccess</code> 옵션을 활성화하면 제대로 <code class=\"language-text\">number | undefined</code>로 추론되도록 만들 수 있다.</p>\n<p>마지막으로 옵셔널 프로퍼티와 <code class=\"language-text\">undefined</code>의 혼동도 문제가 된다. 예를 들어 <code class=\"language-text\">{ a?: string }</code>이라는 타입에서 <code class=\"language-text\">a</code>가 <code class=\"language-text\">undefined</code>인 상태와 아예 존재하지 않는 것이 논리적으로 구분되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Config</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> timeout<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> config1<span class=\"token operator\">:</span> Config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> timeout<span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n<span class=\"token keyword\">const</span> config2<span class=\"token operator\">:</span> Config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// OK</span>\n\n<span class=\"token comment\">// 둘 다 같은 타입으로 취급되지만,</span>\n<span class=\"token comment\">// Object.hasOwn(config1, 'timeout')과 Object.hasOwn(config2, 'timeout')은 다르다</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 부분 또한 TypeScript 4.4 이후 도입된 <code class=\"language-text\">exactOptionalPropertyTypes</code> 옵션을 사용하면 “존재하지 않음”과 ”<code class=\"language-text\">undefined</code>로 존재함”을 더 엄밀하게 구분할 수 있다.</p>\n<p>이런 탈출구들은 TypeScript가 100% 논리적인 정합성보다는 실용적으로 JavaScript와의 호환성을 선택한 결과라고 볼 수 있다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이 글은 타입스크립트를 잘 쓰는 방법을 설명하려는 글은 아니다. 이미 실무에서 타입을 충분히 다뤄본 사람이라면, 여기서 등장하는 대부분의 예시는 익숙할 수도 있다.</p>\n<p>다만 필자가 이 글을 통해 전하고 싶었던 건, 타입 시스템을 대하는 관점에 가깝다. 타입 에러를 “통과시켜야 할 장애물”로 보는 대신, 내가 어떤 계약을 선언했고, 그 계약이 어디에서 깨지고 있는지를 읽어내는 도구로 바라보는 시선 말이다.</p>\n<p>이 관점이 한 번 자리 잡히면, 타입 에러를 대하는 태도도 자연스럽게 달라진다. 왜 안 되는지를 묻기 전에, 무슨 계약을 어기고 있는지를 먼저 떠올리게 된다.</p>\n<p>타입 시스템은 생각보다 많은 이야기를 하고 있다. 다만 그걸 단순한 컴파일 통과 여부로만 읽고 지나치기엔, 조금 아까운 도구일지도 모르겠다.</p>\n<p>이 글이 흥미로웠다면, <a href=\"/2024/01/30/category-theory-for-programmers-0-preface/\">“프로그래머를 위한 카테고리 이론”</a> 시리즈도 읽어보자. 여기서 다룬 합성, 곱과 합 타입, 함수 타입 같은 개념들이 카테고리 이론에서 어떻게 일반화되는지, 그리고 펑터나 자연 변환 같은 개념이 이 아이디어를 어떻게 확장하는지 볼 수 있다.</p>","fields":{"slug":"20260125-types-as-proofs-typescript-hidden-math","path":"/2026/01/25/types-as-proofs-typescript-hidden-math/","lang":"ko"},"frontmatter":{"title":"타입 시스템은 왜 증명처럼 동작하는가","subTitle":"타입 검사를 컴파일 통과로만 보던 시선에서, 논리로 읽는 타입 시스템까지","date":"Jan 25, 2026","categories":["프로그래밍"],"tags":["TypeScript","타입시스템","수학","논리학","Curry-Howard","람다대수"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/431b08e8376f331ee6da16cb53233c65/d803c/thumbnail.png","srcSet":"/static/431b08e8376f331ee6da16cb53233c65/d803c/thumbnail.png 320w,\n/static/431b08e8376f331ee6da16cb53233c65/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/431b08e8376f331ee6da16cb53233c65/fc5c5/thumbnail.webp 320w,\n/static/431b08e8376f331ee6da16cb53233c65/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/431b08e8376f331ee6da16cb53233c65/01fb2/thumbnail.png","srcSet":"/static/431b08e8376f331ee6da16cb53233c65/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/431b08e8376f331ee6da16cb53233c65/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"f58c9bb7-8172-534f-ac13-0b3c07a7a3cf","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%A1%B0%EC%A7%81%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%80-%EA%B0%9C%EC%9D%B8%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%B4-%EB%AA%A8%EC%97%AC-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A7%84%EB%8B%A4\">조직의 탁월함은 개인의 탁월함이 모여 만들어진다</a></p>\n<ul>\n<li><a href=\"#%ED%83%81%EC%9B%94%ED%95%9C-%EC%A1%B0%EC%A7%81%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">탁월한 조직이란 무엇인가</a></li>\n<li><a href=\"#10%EB%AA%85%EC%97%90%EC%84%9C-140%EB%AA%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\">10명에서 140명, 시스템의 필요성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A1%B0%EC%A7%81%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%ED%94%8C%EB%9D%BC%EC%9D%B4%ED%9C%A0%EC%9D%84-%EA%B5%B4%EB%A0%A4%EB%9D%BC\">조직의 탁월함을 만드는 플라이휠을 굴려라</a></p>\n<ul>\n<li><a href=\"#1%EB%8B%A8%EA%B3%84-%EC%9C%A0%EC%9E%85---%EC%84%B1%EC%9E%A5%EC%97%90-%EB%AF%B8%EC%B3%90%EC%9E%88%EB%8A%94-%ED%83%81%EC%9B%94%ED%95%9C-%EC%9D%B8%EC%9E%AC%EB%A5%BC-%EB%AA%A8%EC%9D%80%EB%8B%A4\">1단계: 유입 - 성장에 미쳐있는 탁월한 인재를 모은다</a></li>\n<li><a href=\"#2%EB%8B%A8%EA%B3%84-%EB%A9%94%ED%83%80%EC%9D%B8%EC%A7%80---%EC%A1%B0%EC%A7%81%EC%9D%98-%EA%B8%B0%EB%8C%80%EC%B9%98%EC%99%80-%EB%82%98%EC%9D%98-%EA%B0%95%EC%A0%90%EC%9D%84-%EA%B0%99%EC%9D%80-%EC%96%B8%EC%96%B4%EB%A1%9C-%EB%B0%94%EB%9D%BC%EB%B3%B8%EB%8B%A4\">2단계: 메타인지 - 조직의 기대치와 나의 강점을 같은 언어로 바라본다</a></li>\n<li><a href=\"#3%EB%8B%A8%EA%B3%84-%EA%B8%B0%ED%9A%8C%EC%A0%9C%EA%B3%B5---%EC%9E%91%EC%9D%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EC%84%B1%EC%9E%A5%EC%9D%84-%EA%B2%BD%ED%97%98%ED%95%98%EA%B2%8C-%ED%95%9C%EB%8B%A4\">3단계: 기회제공 - 작은 단위로 성장을 경험하게 한다</a></li>\n<li><a href=\"#4%EB%8B%A8%EA%B3%84-%EC%9D%B8%EC%A0%95---%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%8B%AC%EB%A6%AC%EC%A0%81-%EB%B3%B4%EC%83%81%EC%9C%BC%EB%A1%9C-%EC%84%B1%EC%B7%A8%EB%A5%BC-%EA%B2%BD%ED%97%98%ED%95%98%EA%B2%8C-%ED%95%98%EB%8B%A4\">4단계: 인정 - 물리적/심리적 보상으로 성취를 경험하게 하다</a></li>\n<li><a href=\"#5%EB%8B%A8%EA%B3%84-%EA%B8%B0%EC%97%AC---%EC%A2%8B%EC%9D%80-%EA%B2%BD%ED%97%98%EC%9D%B4-%EC%A1%B0%EC%A7%81%EC%9D%84-%ED%83%81%EC%9B%94%ED%95%98%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4\">5단계: 기여 - 좋은 경험이 조직을 탁월하게 만든다</a></li>\n<li><a href=\"#6%EB%8B%A8%EA%B3%84-%EB%B8%8C%EB%9E%9C%EB%94%A9---%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%84-%EC%99%B8%EB%B6%80%EB%A1%9C-%EC%95%8C%EB%A6%B0%EB%8B%A4\">6단계: 브랜딩 - 탁월함을 외부로 알린다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"이번 포스팅에서는 필자가 지금까지 약 2년 반 정도 토스에서 프론트엔드 챕터 리드로 일하면서 고민해왔던 내용에 대해 이야기하려고 한다. 필자가 토스팀에서 챕터 리드로서 해야하는 일, 그리고 목표는 명확하다. 토스 프론트엔드 챕터를 세상에서 가장 탁월한 조직으로 만들어내는 것이다.","html":"<p>이번 포스팅에서는 필자가 지금까지 약 2년 반 정도 토스에서 프론트엔드 챕터 리드로 일하면서 고민해왔던 내용에 대해 이야기하려고 한다.</p>\n<p>필자가 토스팀에서 챕터 리드로서 해야하는 일, 그리고 목표는 명확하다. 토스 프론트엔드 챕터를 세상에서 가장 탁월한 조직으로 만들어내는 것이다.</p>\n<!-- more -->\n<p>이 탁월함에 대해서는 여러가지 정의를 할 수 있지만, 사실 중요한 것은 현재 상태에서 탁월함을 만들어내는 것보다 필자가 없어도 스스로 탁월함을 향해 나아갈 수 있는 조직이 되는 것이 핵심이라고 생각한다.</p>\n<h2 id=\"조직의-탁월함은-개인의-탁월함이-모여-만들어진다\" style=\"position:relative;\">조직의 탁월함은 개인의 탁월함이 모여 만들어진다<a href=\"#%EC%A1%B0%EC%A7%81%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%80-%EA%B0%9C%EC%9D%B8%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%B4-%EB%AA%A8%EC%97%AC-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A7%84%EB%8B%A4\" aria-label=\"조직의 탁월함은 개인의 탁월함이 모여 만들어진다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"탁월한-조직이란-무엇인가\" style=\"position:relative;\">탁월한 조직이란 무엇인가<a href=\"#%ED%83%81%EC%9B%94%ED%95%9C-%EC%A1%B0%EC%A7%81%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"탁월한 조직이란 무엇인가 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>탁월한 조직은 기본적으로 탁월한 개인들의 집합이라고 생각한다. 탁월한 개인이 모여 서로에게 자극을 주고 받으며 등을 맞대고 함께 일할 수 있는 조직이 되면 자연스레 조직의 탁월함도 만들어지기 때문이다. 실제로 토스 프론트엔드 챕터에는 복잡한 문제를 빠르게 이해하고, 우아한 해결책을 만들어내고, 서로를 성장시키는 탁월한 개발자들이 많이 있다.</p>\n<p>규모가 작은 조직을 리딩할 때는 명확한 기술 / 문화적 채용 기준을 수립하고 탁월한 인재들을 수집하는 것에 집중함으로서 조직의 탁월함을 만들어볼 수 있다. 그래서 필자가 전직장에 있을 때는 채용에 가장 공을 들였던 기억이 난다.</p>\n<p>그러나 토스 프론트엔드 챕터는 커뮤니티 기준으로 250명, 필자가 몸담고 있는 토스 코어 프론트엔드 챕터만 140명에 가까운 대조직이다. 이렇게 큰 조직을 리딩할 때는 작은 조직과는 조금 다른 접근 방법이 필요하다.</p>\n<p>이 정도로 조직이 크다면 탁월한 개인들을 모으는 것만으로는 충분하지 않다. 더 다양하고 많은 사람들이 모이게 되면서 조직이 이 사람들의 강점과 역량을 파악하고 탁월한 의사결정을 하는데 더 많은 에너지가 필요하기 때문이다.</p>\n<h3 id=\"10명에서-140명-시스템의-필요성\" style=\"position:relative;\">10명에서 140명, 시스템의 필요성<a href=\"#10%EB%AA%85%EC%97%90%EC%84%9C-140%EB%AA%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"10명에서 140명 시스템의 필요성 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>예전 프론트엔드 챕터가 10명 남짓이었을 시절에는 챕터원들이 서로에 대해 상세하게 파악하는 것이 가능했다. 인원이 적으니 얼굴도 이름도 성격도 알 수 있는 것이다.</p>\n<p>하지만 필자가 다시 토스로 돌아왔을 때, 프론트엔드 챕터는 이미 예전에 비해 엄청난 대조직이 되어있었다.</p>\n<p>같은 챕터라고 해도 어떤 사람이 있는지 모르는 경우도 있으며 심지어 특별히 관심을 쓰지 않으면 어떤 신규입사자가 들어왔는지도 모른다. 애초에 10명일 때와 140명일 때는 게임의 룰 자체가 다른 것이다.</p>\n<p>심지어 챕터 리드조차 특별하게 신경을 쓰지 않는다면 이 많은 인원의 강점, 성장 곡선, 동기를 파악하는 것이 굉장히 어렵다. 지금은 그래도 리드 개인의 노력으로 어느 정도 커버가 되는 수준이지만 만약 여기서 인원이 더 늘어난다면 이마저도 불가능한 순간이 분명히 올 것이다.</p>\n<p>개인에 대한 정보는 여러 명의 리드들의 머릿속에 파편화될 것이며, 리드와의 상호작용 여부에 따라 누군가는 더 잘 보이고 누군가는 덜 보이는 상황이 발생하게 될 것이 뻔하다.</p>\n<p>그래서 필자는 이 게임에서 리드의 역할이 “사람을 직접 케어하는 것”에서 “조직을 저절로 탁월하게 만드는 시스템을 구축하는 것”으로 변화해야한다고 생각했다.</p>\n<h2 id=\"조직의-탁월함을-만드는-플라이휠을-굴려라\" style=\"position:relative;\">조직의 탁월함을 만드는 플라이휠을 굴려라<a href=\"#%EC%A1%B0%EC%A7%81%EC%9D%98-%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%ED%94%8C%EB%9D%BC%EC%9D%B4%ED%9C%A0%EC%9D%84-%EA%B5%B4%EB%A0%A4%EB%9D%BC\" aria-label=\"조직의 탁월함을 만드는 플라이휠을 굴려라 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 언급했듯이 탁월한 조직을 만드는 것의 핵심은 탁월함을 향해 저절로 굴러가는 조직을 설계하는 것이다. 이는 마치 제품 개발 개념에서 차용하는 <a href=\"https://brunch.co.kr/@b-rian/4\" target=\"_blank\" rel=\"nofollow\">플라이휠 효과</a>와도 유사하다.</p>\n<p>플라이휠 효과란 하나의 작은 임팩트들이 반복적으로 누적되며 점점 더 큰 성과를 만들어내는 구조를 말한다. 초기에는 많은 에너지가 필요하지만, 한 번 돌아가기 시작하면 관성에 의해 점점 적은 힘으로도 더 큰 성과를 만들어낸다.</p>\n<p>이와 마찬가지로 조직 운영에서도 개별 활동이 선순환 구조로 연결될 때, 탁월함은 자연스럽게 가속된다.</p>\n<p>필자가 설계한 탁월한 조직의 플라이휠은 크게 6단계로 구성된다.</p>\n<hr>\n<ol>\n<li><strong>유입</strong>: 성장에 미쳐있는 탁월한 인재를 모은다.</li>\n<li><strong>메타인지</strong>: 조직이 원하는 기대치, 현재 나의 상태를 파악한다.</li>\n<li><strong>기회제공</strong>: 준비가 되어있는 인재가 다음 성장을 작은 단위로 경험할 수 있는 기회를 제공한다.</li>\n<li><strong>인정</strong>: 성장을 만들어낸 인재들에게 물리/심리적 보상을 전달하여 인정과 성취의 경험을 제공한다.</li>\n<li><strong>기여</strong>: 좋은 경험을 한 인재들이 프론트엔드 챕터의 여러 활동에 참여하여 조직이 탁월해진다.</li>\n<li><strong>브랜딩</strong>: 이렇게 탁월해진 챕터의 활동을 정리하여 외부로 알린다.</li>\n</ol>\n<hr>\n<h3 id=\"1단계-유입---성장에-미쳐있는-탁월한-인재를-모은다\" style=\"position:relative;\">1단계: 유입 - 성장에 미쳐있는 탁월한 인재를 모은다<a href=\"#1%EB%8B%A8%EA%B3%84-%EC%9C%A0%EC%9E%85---%EC%84%B1%EC%9E%A5%EC%97%90-%EB%AF%B8%EC%B3%90%EC%9E%88%EB%8A%94-%ED%83%81%EC%9B%94%ED%95%9C-%EC%9D%B8%EC%9E%AC%EB%A5%BC-%EB%AA%A8%EC%9D%80%EB%8B%A4\" aria-label=\"1단계 유입   성장에 미쳐있는 탁월한 인재를 모은다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>탁월한 조직을 만들려면 탁월한 인재가 계속 들어와야 한다. 그런데 여기서 중요한 건 단순히 실력 있는 인재가 아니라 성장에 미쳐있고 성장 가능성이 높은 인재를 모으는 것이다.</p>\n<p>이를 위해 채용 단계에서 이런 분들을 찾아낼 수 있는 것도 중요하지만, 더 중요한 것은 브랜딩을 통해 외부에 있는 사람들이 “아, 저기에 가면 내가 더 성장할 수 있겠구나”라는 생각을 할 수 있도록 만들어 자연스레 토스팀에 더 많은 지원을 하는 그림을 만드는 것이다.</p>\n<p>토스 프론트엔드 챕터가 어떤 기술력을 가지고 있는지, 어떤 문화를 가진 조직인지를 구체적으로 보여줘야 한다. 이것이 바로 6단계 브랜딩이 다시 1단계 유입으로 연결되는 지점이다.</p>\n<h3 id=\"2단계-메타인지---조직의-기대치와-나의-강점을-같은-언어로-바라본다\" style=\"position:relative;\">2단계: 메타인지 - 조직의 기대치와 나의 강점을 같은 언어로 바라본다<a href=\"#2%EB%8B%A8%EA%B3%84-%EB%A9%94%ED%83%80%EC%9D%B8%EC%A7%80---%EC%A1%B0%EC%A7%81%EC%9D%98-%EA%B8%B0%EB%8C%80%EC%B9%98%EC%99%80-%EB%82%98%EC%9D%98-%EA%B0%95%EC%A0%90%EC%9D%84-%EA%B0%99%EC%9D%80-%EC%96%B8%EC%96%B4%EB%A1%9C-%EB%B0%94%EB%9D%BC%EB%B3%B8%EB%8B%A4\" aria-label=\"2단계 메타인지   조직의 기대치와 나의 강점을 같은 언어로 바라본다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자가 믿는 성장은 언제나 메타인지에서 출발한다. 그래서 탁월한 조직이 만들어내는 구성원들의 성장 또한 결국 구성원 각자가 자신의 역량과 강점을 얼마나 정확하게 인식하고 있는지에서 시작된다고 믿는다.</p>\n<p>이건 마치 삼국지 게임과도 비슷하다. 예를 들어 여포와 제갈량을 한번 생각해보자. 두 사람 모두 뛰어난 인재이지만 맞지 않는 역할이 주어지는 순간 그 탁월함은 사라진다. 여포에게 내정을 맡기거나, 제갈량에게 일기토를 시키면 좋지 않은 결과가 나올 것이 뻔하기 때문이다.</p>\n<p>문제는 현실에서는 자신이 여포인지 제갈량인지조차 모르는 경우가 많고, 혹은 여포임에도 내정을 하고 싶다고 말하는 경우도 있다. 이는 의지의 문제가 아니라 메타인지의 부족에 가깝다고 생각한다.</p>\n<p>그래서 필자는 탁월한 조직에서 만들어내는 성장의 첫걸음은 구성원들이 스스로의 역량과 강점을 제대로 인식하고, 그에 맞는 올바른 성장 기회를 얻는 것에서부터 출발한다고 생각한다.</p>\n<p>이런 생각에 연장선에서, 토스 프론트엔드 챕터에서는 스킬트리라는 도구를 활용하고 있다. 이 스킬트리는 탁월함을 규정하기 위한 장치라기보다는 구성원들이 자신의 현재 역량 상태와 강점을 더 선명하게 인식하고 다음 성장 방향을 스스로 언어화할 수 있도록 돕기 위한 참고선에 가깝다.</p>\n<p>그리고 자신의 성장 방향과 강점을 언어화할 수 있다면 이제 리드들은 이 정보를 바탕으로 각자의 강점이 실제 성과와 성장으로 이어질 수 있도록 코칭한다.</p>\n<h3 id=\"3단계-기회제공---작은-단위로-성장을-경험하게-한다\" style=\"position:relative;\">3단계: 기회제공 - 작은 단위로 성장을 경험하게 한다<a href=\"#3%EB%8B%A8%EA%B3%84-%EA%B8%B0%ED%9A%8C%EC%A0%9C%EA%B3%B5---%EC%9E%91%EC%9D%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EC%84%B1%EC%9E%A5%EC%9D%84-%EA%B2%BD%ED%97%98%ED%95%98%EA%B2%8C-%ED%95%9C%EB%8B%A4\" aria-label=\"3단계 기회제공   작은 단위로 성장을 경험하게 한다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>메타인지가 이루어졌다면, 그 다음으로 조직이 해야 할 일은 명확하다. 구성원들이 부담 없이 도전하고, 작은 단위의 성공을 경험할 수 있는 기회를 제공하는 것이다. 아무리 자신의 강점과 현재 상태를 잘 인식하고 있어도, 실제로 시도해볼 수 있는 장이 없다면 성장은 관념에 머물 수밖에 없다.</p>\n<p>이 생각은 최근 진행한 리더십 설문조사를 통해 더 선명해졌다. 설문 결과를 보면 리더십 역할에 대한 관심은 생각보다 훨씬 많았다. 다만 많은 구성원들이 공통적으로 “관심은 있지만 아직 준비가 안 된 것 같다.”라고 답했다는 점이 특징이었다.</p>\n<p>처음에는 구성원들이 스스로의 역량이 부족하다고 느낀다고 생각했지만, 개별 응답을 더 분석해보니 오히려 “내가 무엇을 준비해야 하는지, 어떤 역량을 쌓아야 하는지 잘 모르겠다”에 더 가까웠다. 즉, 챕터가 성장의 방향성과 기준, 그리고 그 방법에 대한 힌트를 충분히 제공하지 못하고 있었던 것이다.</p>\n<p>그래서 필자는 이런 기회를 더 많이 만들고, 더 자주 노출해야 한다고 생각했다. 성장은 한 번의 큰 도약이 아니라, 여러 번의 작은 성공 경험 위에서 만들어지는 것이기 때문에 챕터원들이 부담없이 도전할 수 있는 환경을 만들어줘야한다.</p>\n<p>이런 문제의식에서 시작된 것이 Next F-Lead 프로그램이다. 이 프로그램은 전략적 사고, 인터뷰 스킬, 1 on 1 코칭이라는 세 가지 핵심 역량에 집중한다. 목표는 누군가를 갑자기 리드로 만드는 게 아니라, F-Lead의 역할을 작은 단위로 미리 경험해볼 수 있도록 돕는 데 있다. 이를 통해 구성원들은 “리더십이 나와는 먼 이야기”가 아니라 “조금씩 준비해볼 수 있는 다음 단계”라는 감각을 얻게 된다.</p>\n<p>Next F-Lead뿐만 아니라, 다양한 교육과 체험 프로그램을 통해 구성원들이 자신의 Next Step을 더 선명하게 그릴 수 있도록 노력하고 있다. 중요한 건 누군가를 특정 방향으로 밀어붙이는 게 아니라, 각자가 스스로 도전해보고 선택할 수 있는 환경을 만들어주는 것이라고 생각한다.</p>\n<p>작은 성공을 경험한 사람은 더 큰 도전을 상상할 수 있고, 그 상상은 다시 다음 성장을 향한 실제 행동으로 이어진다. 이것이 기회제공 단계가 플라이휠에서 중요한 이유다.</p>\n<h3 id=\"4단계-인정---물리적심리적-보상으로-성취를-경험하게-하다\" style=\"position:relative;\">4단계: 인정 - 물리적/심리적 보상으로 성취를 경험하게 하다<a href=\"#4%EB%8B%A8%EA%B3%84-%EC%9D%B8%EC%A0%95---%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%8B%AC%EB%A6%AC%EC%A0%81-%EB%B3%B4%EC%83%81%EC%9C%BC%EB%A1%9C-%EC%84%B1%EC%B7%A8%EB%A5%BC-%EA%B2%BD%ED%97%98%ED%95%98%EA%B2%8C-%ED%95%98%EB%8B%A4\" aria-label=\"4단계 인정   물리적심리적 보상으로 성취를 경험하게 하다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>성장은 경험만으로 완성되지 않는다. 성장을 만들어낸 사람에게는 반드시 인정이 따라와야 한다. 특히 긍정적인 피드백을 통한 보상은 조직 운영에서 과소평가되기 쉽지만, 실제로는 플라이휠을 다시 가속시키는 데 가장 중요한 요소 중 하나다.</p>\n<p>토스 프론트엔드 챕터 안에는 이미 자신의 강점을 드러내며 조직에 기여하고 있는 사람들이 많이 있다. 예를 들면 기술 공유를 꾸준히 하는 사람, 오픈소스 위원회나 코드 퀄리티 위원회 같은 활동에 참여하는 사람, 동료들이 더 잘 일할 수 있도록 도구를 만들어 공유하는 사람들이다.</p>\n<p>이런 기여들은 조직을 한 단계 끌어올리지만, 그 가치가 충분히 드러나지 않으면 당사자조차 자신의 성취를 체감하기 어렵다. 그래서 필자는 이들이 지금보다 더 자주, 더 분명하게 인정받아야 한다고 생각한다.</p>\n<p>리드 역할을 맡고 있는 사람들 역시 마찬가지다. 이들은 자신의 성과뿐 아니라 동료들의 성장을 바로 옆에서 돕는 역할을 수행한다. 조직 관점에서는 매우 중요한 역할이고, 개인 관점에서는 결코 가볍지 않은 책임이다. 실제로 해야 할 일도 많고, 고민해야 할 것도 많다. 필자에게 이들과 함께하는 매일은 감사의 연속이며, 이런 헌신은 반드시 보상받아야 한다.</p>\n<p>그래서 토스 프론트엔드 챕터에서는 이들을 위한 전용 리더십 교육 프로그램을 준비하고 있다. 단순한 교육을 넘어, 챕터의 의사결정에 더 깊이 참여할 수 있는 기회, 명시적인 권한과 역할의 확장도 함께 기획하고 있다. 이건 단순한 보상이 아니라 “당신의 성장은 조직이 진지하게 대하고 있다”는 명확한 메시지다.</p>\n<p>인정은 성과의 끝이 아니라 다음 성장을 시작하게 만드는 신호다. 성취를 경험한 사람은 다시 기여하고 싶어지고, 그 기여는 다시 조직을 탁월하게 만든다. 이것이 인정 단계가 플라이휠에서 빠질 수 없는 이유다.</p>\n<h3 id=\"5단계-기여---좋은-경험이-조직을-탁월하게-만든다\" style=\"position:relative;\">5단계: 기여 - 좋은 경험이 조직을 탁월하게 만든다<a href=\"#5%EB%8B%A8%EA%B3%84-%EA%B8%B0%EC%97%AC---%EC%A2%8B%EC%9D%80-%EA%B2%BD%ED%97%98%EC%9D%B4-%EC%A1%B0%EC%A7%81%EC%9D%84-%ED%83%81%EC%9B%94%ED%95%98%EA%B2%8C-%EB%A7%8C%EB%93%A0%EB%8B%A4\" aria-label=\"5단계 기여   좋은 경험이 조직을 탁월하게 만든다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>인정을 받고 성취를 경험한 인재들은 자연스럽게 조직에 기여하게 된다. 그리고 이런 기여를 했을 때 앞서 4단계에서 언급한 샤라웃, 권한 확장, 의사결정 참여 같은 인정을 다시 받게 되면, 이런 행동은 자연스럽게 강화된다. 이것이 플라이휠의 핵심이다.</p>\n<p>필자는 지식의 공유, 새로운 아이디어와 피드백, 격렬한 토론 등이 자주 등장해야 탁월한 조직이 될 것이라 믿는다. 이런 것들이 바로 기여에 해당하고, 이런 기여들이 모여 결국 탁월한 조직이 된다.</p>\n<p>사실 토스 프론트엔드 챕터는 이런 기여들을 경험해본 적이 많은 조직이다.</p>\n<p>사람이 별로 없던 초반에는 사내 라이브러리 구축, TDS(Toss Design System) 개발, 어드민 개발 등이 이런 기여를 통해 진행됐다. 지금은 기술 관련 도구나 정보 공유, 오픈소스 위원회, 코드 퀄리티 위원회, Frontend Accelerator 멘토링 지원, 유저 접근성 개선 등으로 나타나고 있다.</p>\n<p>Next F-Lead를 수료한 리드들이 프로그램을 개선하고, 오픈소스 위원회에서 활동한 개발자들이 새로운 라이브러리를 제안하고, 스킬트리를 사용한 챕터원들이 피드백을 준다. 이 모든 것이 기여다.</p>\n<p>시스템은 개인에 의해 개선되고, 개선된 시스템은 다시 더 많은 개인을 탁월하게 만든다. 작은 플라이휠은 이미 돌아가고 있는 것이다.</p>\n<h3 id=\"6단계-브랜딩---탁월함을-외부로-알린다\" style=\"position:relative;\">6단계: 브랜딩 - 탁월함을 외부로 알린다<a href=\"#6%EB%8B%A8%EA%B3%84-%EB%B8%8C%EB%9E%9C%EB%94%A9---%ED%83%81%EC%9B%94%ED%95%A8%EC%9D%84-%EC%99%B8%EB%B6%80%EB%A1%9C-%EC%95%8C%EB%A6%B0%EB%8B%A4\" aria-label=\"6단계 브랜딩   탁월함을 외부로 알린다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>마지막 단계는 브랜딩이다. 이렇게 탁월해진 챕터의 활동을 정리해서 외부로 알리는 것이다.</p>\n<p>현재 토스 프론트엔드 챕터는 오픈소스 위원회, Frontend Accelerator 멘토링, Frontend Fundamentals 문서 제작, 모닥불 유튜브 콘텐츠 등 다양한 활동을 통해 탁월함에 대한 브랜드를 구축해나가고 있다.</p>\n<p>예를 들어 오픈소스 위원회는 es-toolkit, es-hangul, overlay-kit 등 여러 라이브러리를 배출해냈는데, 특히 <a href=\"https://es-toolkit.dev/\" target=\"_blank\" rel=\"nofollow\">es-toolkit</a>의 경우 마이크로소프트와 같은 빅테크에서 사용하기도 했고, Storybook이나 yarn 같은 유명한 도구에서 채택되기도 했다. 현재는 주간 다운로드 수가 900만 건에 달한다.</p>\n<p>또한 <a href=\"https://frontend-fundamentals.com/code-quality/\" target=\"_blank\" rel=\"nofollow\">Frontend Fundamentals</a>와 Frontend Accelerator 멘토링은 프론트엔드 생태계를 더욱 성장시키는 것을 목표로 하는데, 이를 통해 더 탁월한 개발자들이 생태계 내에서 배출되고 이로 인해 토스팀에도 자연스럽게 탁월한 인재들이 유입되는 선순환을 기대하고 있다.</p>\n<p><a href=\"https://toss.tech/article/firesidechat_frontend_10\" target=\"_blank\" rel=\"nofollow\">모닥불 유튜브</a>와 같은 콘텐츠는 상대적으로 적은 비용으로 많은 개발자들에게 좋은 영향력을 만들어낼 수 있는 훌륭한 수단이다. 토스 프론트엔드 챕터가 어떤 기준으로 코드를 작성하는지, 챕터 내에 어떤 개발자들이 있는지 자연스럽게 보여주어 브랜딩 효과를 만들어낸다.</p>\n<p>이 모든 활동들은 “토스 프론트엔드 챕터는 탁월한 조직이다”라는 메시지를 외부에 전달하며, 이 메시지를 보고 성장에 미쳐있는 탁월한 인재들이 다시 토스팀으로 유입된다. 브랜딩이 잘 된다면 다시 1단계인 유입으로 이어지며 플라이휠이 완성된다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>리더로서 필자가 가장 중요하게 생각하는 것은 “내가 없어도 돌아가는 조직”을 만드는 것이다. 역설적으로 들릴 수 있지만, 이것이 진짜 지속 가능성이다.</p>\n<p>개인 의존성을 줄이고, 명확한 기준과 작동하는 시스템을 남기는 것. 필자가 휴가를 가거나, 다른 일에 집중하거나, 심지어 이 역할을 떠나더라도 플라이휠이 계속 돌아가도록 만드는 것. 그래서 필자는 지난 2년 반 동안 사람을 직접 케어하는 것이 아니라 조직을 저절로 탁월하게 만드는 시스템을 구축하는 데 집중해왔다.</p>\n<p>진짜 탁월한 조직은 탁월한 개인을 계속 만들어낼 수 있는 조직이다. 그리고 그 개인들이 다시 조직을 더 탁월하게 만드는 조직이다.</p>\n<p>사실 각 시스템은 아직 개선할 부분이 많다. 스킬트리는 더 정교해져야 하고, Next F-Lead는 더 많은 리드를 배출해야 하고, 인정 시스템은 아직 구축 중이다. 무엇보다 이 모든 것이 정말로 “조직을 더 탁월하게 만들고 있는가”에 대한 명확한 답은 여전히 찾아가는 중이다.</p>\n<p>하지만 방향은 맞다고 확신한다. 작은 성과들이 쌓이고 있고, 챕터원들의 피드백이 계속 들어오고 있으며, 무엇보다 작은 플라이휠은 실제로 돌아가고 있기 때문이다.</p>\n<p>조직 운영은 단기간에 답이 나오는 문제가 아니다. 하지만 명확한 방향성과 작동하는 시스템이 있다면, 시간이 지날수록 플라이휠은 더 빠르게 돌고 토스 프론트엔드 챕터는 지금보다 더 탁월한 조직이 될 것이라 믿는다.</p>","fields":{"slug":"20260124-leading-frontend-organization","path":"/2026/01/24/leading-frontend-organization/","lang":"ko"},"frontmatter":{"title":"조직의 탁월함은 사람으로 만들지만 지속성은 시스템이 만든다","subTitle":"개인 의존성을 줄이고 시스템을 남기는 플라이휠 설계","date":"Jan 24, 2026","categories":["에세이"],"tags":["리더십","조직문화","프론트엔드","챕터리드","토스프론트엔드"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/ad36c013dbd2031d00e50cb2530b0f09/d803c/thumbnail.png","srcSet":"/static/ad36c013dbd2031d00e50cb2530b0f09/d803c/thumbnail.png 320w,\n/static/ad36c013dbd2031d00e50cb2530b0f09/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/ad36c013dbd2031d00e50cb2530b0f09/fc5c5/thumbnail.webp 320w,\n/static/ad36c013dbd2031d00e50cb2530b0f09/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/ad36c013dbd2031d00e50cb2530b0f09/01fb2/thumbnail.png","srcSet":"/static/ad36c013dbd2031d00e50cb2530b0f09/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/ad36c013dbd2031d00e50cb2530b0f09/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"lang":"ko"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}