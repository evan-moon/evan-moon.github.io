{"componentChunkName":"component---src-templates-post-tsx","path":"/2018/10/13/sort-algorithm/","result":{"data":{"markdownRemark":{"id":"b6637fb6-7420-5232-a9c3-829e99077e91","excerpt":"이번 포스팅에서는 대표적인 정렬알고리즘 5가지와 대략적인 에 대해서 정리하려고 한다. 먼저, 그 5가지 정렬알고리즘은 다음과 같다.","html":"<p>이번 포스팅에서는 대표적인 정렬알고리즘 5가지와 대략적인 <code class=\"language-text\">빅오표기법</code>에 대해서 정리하려고 한다. 먼저, 그 5가지 정렬알고리즘은 다음과 같다.</p>\n<!-- more -->\n<hr>\n<ol>\n<li>버블정렬(Bubble sort)</li>\n<li>선택정렬(Selection sort)</li>\n<li>삽입정렬(Insertion sort)</li>\n<li>병합정렬(Merge sort)</li>\n<li>퀵정렬(Quick sort)</li>\n</ol>\n<hr>\n<p>그리고 이 알고리즘들의 성능은 <code class=\"language-text\">빅오표기법</code>으로 표현하므로, 빅오표기법에 대한 설명도 간단히 하고 넘어가려한다.</p>\n<h2 id=\"big-o-표기법과-시간복잡도\" style=\"position:relative;\">Big O 표기법과 시간복잡도<a href=\"#big-o-%ED%91%9C%EA%B8%B0%EB%B2%95%EA%B3%BC-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"big o 표기법과 시간복잡도 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>알고리즘들의 성능을 판단하는 지표로는 <code class=\"language-text\">시간 복잡도(Time Complexity)</code>와 <code class=\"language-text\">공간 복잡도(Time Complexity)</code>가 있다. <code class=\"language-text\">시간 복잡도</code>는 알고리즘의 수행시간을 의미하는 지표이며, <code class=\"language-text\">공간 복잡도</code>는 알고리즘의 메모리 사용량을 의미한다.</p>\n<p>보통 알고리즘에 대해서 공부하다보면 <code class=\"language-text\">이 알고리즘의 시간복잡도는 O n입니다</code> 혹은 <code class=\"language-text\">O의 n제곱입니다</code> 이런 식으로 이야기하거나 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> 이런 식으로 작성되어있는 것을 볼 수 있었을 것이다.</p>\n<p>이게 바로 <code class=\"language-text\">빅오(Big O) 표기법</code>이다. 말로 풀어보자면 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>의 의미는 다음과 같다.</p>\n<blockquote>\n<p>이 함수는 n만큼의 데이터가 주어졌을 때, “최악”의 경우 n만큼의 리소스를 소모한다</p>\n</blockquote>\n<p>이때 위에서 말한 <code class=\"language-text\">리소스</code>는 시간복잡도라면 <code class=\"language-text\">시간</code>이고 공간복잡도라면 <code class=\"language-text\">메모리공간</code>이 될 것이다.\n하지만 보통 정렬알고리즘을 평가할때는 주로 <code class=\"language-text\">시간복잡도</code>에 집중하므로 여기서는 시간복잡도만 살펴보도록 하겠다.</p>\n<p>먼저 시간복잡도에 대한 이해를 더 하기위해 <code class=\"language-text\">이진탐색</code> 알고리즘의 시간복잡도를 살펴보자. 혹시 <code class=\"language-text\">이진탐색</code>을 잘모르는 사람은 술게임인 <code class=\"language-text\">업다운</code>을 생각해보자. 다들 잘 알겠지만 <code class=\"language-text\">업다운</code>은 다른 사람이 생각한 임의의 숫자를 맞춰야하는 게임이다.</p>\n<p>이때, 가장 질문을 최소화할 수 있는 방법은 무엇일까? 바로 첫 질문에 중간 값인 <code class=\"language-text\">50</code>을 부르는 것이다. <code class=\"language-text\">50</code>을 부르고 상대방이 <code class=\"language-text\">업</code> 또는 <code class=\"language-text\">다운</code>을 하게되면 우리는 반대쪽에 있는 50개의 수는 버리고 나머지 50개만 다시 생각하면 되는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 306px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8879b1bbc91ecb328b1dc5a32b718efb/01fdd/drink.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB682xjVKpBUH/xAAaEAADAAMBAAAAAAAAAAAAAAAAARECEiIh/9oACAEBAAEFAny1ToaQs/KiUhsz/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQIREiof/aAAgBAQAGPwLLm2a9LEOP/8QAGxAAAwADAQEAAAAAAAAAAAAAAAERIVFhcTH/2gAIAQEAAT8hbQdYrV58pwfYobSWx8Y2JVpjXJmujHyP/9oADAMBAAIAAwAAABArAAD/xAAVEQEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAwEBPxBj/8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQIBAT8QY//EAB4QAQACAwACAwAAAAAAAAAAAAEAESExUUFhcbHh/9oACAEBAAE/EETQATEbyHdSkijSC4Y8ZOxooyh8xxpMthVfDHHFvLb6PyOgCvF8dqVQ7BfWoS0sauz2Zhyj/9k=&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"drink\" title=\"drink\" src=\"/static/8879b1bbc91ecb328b1dc5a32b718efb/01fdd/drink.jpg\" srcset=\"/static/8879b1bbc91ecb328b1dc5a32b718efb/0913d/drink.jpg 160w,\n/static/8879b1bbc91ecb328b1dc5a32b718efb/01fdd/drink.jpg 306w\" sizes=\"(max-width: 306px) 100vw, 306px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  <small>&#xB9CC;&#xC57D; &#xC6B4;&#xC88B;&#xAC8C; &#xC0C1;&#xB300;&#xBC29;&#xC774; &#xC0DD;&#xAC01;&#xD55C; &#xC218;&#xAC00; 50&#xC774;&#xB77C;&#xBA74; &#xBC14;&#xB85C; &#xAC8C;&#xC784;&#xC774; &#xB05D;&#xB098;&#xACE0; &#xC0C1;&#xB300;&#xBC29;&#xC740; &#xBC8C;&#xC8FC;&#xB97C; &#xBA39;&#xAC8C; &#xB41C;&#xB2E4;.</small>\n</center>\n<p>어쨌든 이 게임에서 최악의 경우는 계속 <code class=\"language-text\">업 &amp; 다운</code>을 반복하다가 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O({\\log}N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>번만에 끝나는 것이고 최선의 경우는 찾고자 하는 값을 첫 번째 추측으로 맞춰버린 상황. 즉, 시간복잡도는 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>이 된다.</p>\n<p>보는 바와 같이 최선의 결과와 최악의 결과 간 차이는 늘 있을 수 밖에 없기 때문에 보통 알고리즘을 평가할 때는 주로 <strong>최악</strong>의 경우를 생각한다.\n그리고 이런 <strong>최악</strong>의 경우를 표현할 때 바로 <code class=\"language-text\">빅오 표기법</code>을 사용하는 것이다.</p>\n<p>자주 나오는 것들은 보통 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O({\\log}N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> 정도가 있는데 알기 쉽게 2차원 그래프로 그려보면 다음과 같이 나타난다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 631px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8846c3df1d92e4a3a2108e993a5b69f7/4597d/big_o.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 79.375%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACDElEQVQoz41S2XLbMAzU/39d66buNInjxKZu8ZJIigCvQvJ06rp56A5GIxFaYBdgpZQCgJxz2hFTkhaGeYUQc8oB+4BNSibGxFkn6gHcKmY3KWvWtXogE5zH0XgLoeQUgw5hjEQOyQhN5AjAtWWDAsTq384lZ4PBYdiPSoo6RUw5Bw9uNouD2a6l5FLKp+S0+J2cc0wYo0xpS8ueC21IF9FG3beyrqSUn5ABHSBVj5HcGvpbjWocFWVjROftoFviV1rrB88E5ZEGttWKspQkxdLVvUOrrdRWmXWJkUzl6nQ6xRjvmfQpnM9kKoMH0U3i8n6erXTehLh5ISG7j1Sdz+cHMjlUK2LAUbFW9H3bIfiy45aeh6F9epKM3cveFkvh0TMlWtFJ0xkx+8Wic6vWbp6dUk5KO026aQznfwZGcqibBd2I4VyPRrG5q8Wldkp6Y8A5sDYg7vXzTci2KjqiNwtG6oH3HauFVpMTbJ50uS30N/KukAJ3VEKIZVlG1TXXN/Z+FVyPi+b9mxy5B1hJMMXf8N4Pw9D3/dZ5kG3PLrRGjGmF9XI9kbcQIgLeI9zhNuOqm7qafWi5pLAaJepuAITyHyAHFWvbpy/f64+X19PP14/LyKVWqm3bZsP2vF6vNWPTxMUdOOe0pmqrsd3KmLbZ7AsrpWGXr4dvz88vx+PxcDj8OH536+MtJPwCrpKX9qM/9loAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"big o\" title=\"big o\" src=\"/static/8846c3df1d92e4a3a2108e993a5b69f7/4597d/big_o.png\" srcset=\"/static/8846c3df1d92e4a3a2108e993a5b69f7/69538/big_o.png 160w,\n/static/8846c3df1d92e4a3a2108e993a5b69f7/72799/big_o.png 320w,\n/static/8846c3df1d92e4a3a2108e993a5b69f7/4597d/big_o.png 631w\" sizes=\"(max-width: 631px) 100vw, 631px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  <br>\n</center>\n<p><code class=\"language-text\">빅오 표기법</code>의 계산방법과 같은 더 자세한 내용은 다른 포스팅에서 다시 설명하도록 하겠다.</p>\n<h2 id=\"정렬알고리즘\" style=\"position:relative;\">정렬알고리즘<a href=\"#%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"정렬알고리즘 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<center>\n  <img src=\"/6cfa6f10ba3dfd0a90b03cfb0926f05d/sorts.gif\">\n  <br>\n</center>\n<p><code class=\"language-text\">정렬알고리즘</code>은 컴퓨터 공학에서 중요시되는 문제 중 하나로, 어떤 데이터셋이 주어졌을 때 이를 정해진 순서대로 나열하여 재배치하는 문제이다.</p>\n<p>실제 개발을 하다보면 불규칙한 데이터들을 정렬 후 탐색해야하는 경우가 꽤나 많이 발생하게 되는데 이때 상황에 맞는 알고리즘을 사용하여 효과적으로 문제를 해결할 수 있느냐가 핵심이라고 볼 수 있다.</p>\n<p>예를 들어 1부터 10까지 적혀있는 공이 불규칙하게 들어있는 주머니에서 공을 하나씩 꺼내어 작은 수부터 큰 수의 순서로 공을 나열한다고 생각해보자.\n보통 이런 경우 사람도 어렵지 않게 쓱쓱 정렬해낸다. 하지만 컴퓨터가 주로 다루는 데이터는 <code class=\"language-text\">10,000</code>개일수도 <code class=\"language-text\">10,000,000</code>개일수도 있다. 그리고 데이터베이스 같은 경우는 이론상 무한 개의 데이터를 다룰 수 있어야 한다.</p>\n<p>이때 데이터가 정렬되어 있지 않다면 순차적으로 하나씩 데이터를 봐가면서 탐색해야하지만, 데이터가 이미 정렬되어있다면 위에서 예시로 들었던 <code class=\"language-text\">이진탐색(Binary Search)</code>와 같은 강력한 알고리즘을 사용할 수도 있다.<small>(사실 이게 제일 큰 이유이다)</small></p>\n<p>자 그럼 대표적인 정렬알고리즘인 <code class=\"language-text\">버블정렬</code>, <code class=\"language-text\">선택정렬</code>, <code class=\"language-text\">삽입정렬</code>, <code class=\"language-text\">병합정렬</code>, <code class=\"language-text\">퀵정렬</code>을 한번 살펴보도록 하자.</p>\n<h3 id=\"버블정렬bubble-sort\" style=\"position:relative;\">버블정렬(Bubble sort)<a href=\"#%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%ACbubble-sort\" aria-label=\"버블정렬bubble sort permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<center>\n  <img src=\"/1692a508cdbd24d8651e01ffe00385dd/bubble_sort.gif\">\n  <br>\n</center>\n<p><code class=\"language-text\">버블정렬</code>은 거의 모든 상황에서 최악의 성능을 보여주지만, 이미 정렬된 자료에서는 1번만 순회하면 되기 때문에 최선의 성능을 보여주는 알고리즘이다. 이미 정렬되어 있는 데이터를 왜 정렬하냐는 의문이 들 수 있지만, 정렬알고리즘 자체는 데이터가 정렬되어 있는지 아닌지 모르고 작동하는 것이기 때문에 의미는 있다.</p>\n<p>버블정렬은 다음과 같은 순서로 작동한다.</p>\n<hr>\n<ol>\n<li>0번째 원소와 1번째 원소를 비교 후 정렬</li>\n<li>1번째 원소와 2번째 원소를 비교 후 정렬\n<br>\n…\n<br></li>\n<li>n-1번째 원소와 n번째 원소를 비교 후 정렬</li>\n</ol>\n<hr>\n<p>한번 순회할 때마다 마지막 하나가 정렬되므로 원소들이 거품이 올라오는 것처럼 보여서 <code class=\"language-text\">버블정렬</code>이라고 부른다. 원리도 직관적이라서 구현하기 편하긴 하지만 꽤나 비효율적인 정렬 방식이다. 그래서 보통 처음 배울 때 한번 짜보고 나면 실무에서 쓰는 경우는 거의 못 봤다.<small>(물논 시간이 없다면 쓸 수도 있다…)</small></p>\n<p>버블정렬의 구현코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">bubbleSort</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> len <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> input<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Swap</span>\n        tmp <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        input<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        input<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n        tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"선택정렬selection-sort\" style=\"position:relative;\">선택정렬(Selection sort)<a href=\"#%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%ACselection-sort\" aria-label=\"선택정렬selection sort permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<center>\n  <img src=\"/fb94376d775d18dbffb09f9724ca9c14/selection_sort.gif\">\n  <br>\n</center>\n<p><code class=\"language-text\">선택정렬</code>은 주어진 자료들 중에 현재 위치에 맞는 자료를 찾아 선택하여 위치를 교환하는 정렬 알고리즘이다.\n한번 순회를 돌게되면 알고리즘 상 전체 자료 중 가장 작은 값의 자료가 0번째 인덱스에 위치하게 되므로 그 다음 순회부터는 1번 인덱스부터 순회를 돌며 반복하면 된다.</p>\n<p>선택정렬은 다음과 같은 순서로 작동한다.</p>\n<hr>\n<ol>\n<li>0번 인덱스 ~ n번 인덱스 중 가장 작은 값을 찾아 0번째 인덱스와 swap한다</li>\n<li>1번 인덱스 ~ n번 인덱스 중 가장 작은 값을 찾아 1번째 인덱스와 swap한다\n<br>\n…\n<br></li>\n<li>n-1번 인덱스 ~ n번 인덱스 중 가장 작은 값을 찾아 n번째 인덱스와 swap한다</li>\n</ol>\n<hr>\n<p>선택정렬은 현재 자료가 정렬이 되어있던말던 무조건 전체 리스트를 순회해가며 검사하기 때문에 최선의 경우든 최악의 경우든 한결같이 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>의 시간복잡도를 가지고 있다. 선택정렬의 구현코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">selectionSort</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> len <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> input<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Swap</span>\n        tmp <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        input<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        input<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n        tmp <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"삽입정렬insertion-sort\" style=\"position:relative;\">삽입정렬(Insertion sort)<a href=\"#%EC%82%BD%EC%9E%85%EC%A0%95%EB%A0%ACinsertion-sort\" aria-label=\"삽입정렬insertion sort permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<center>\n  <img src=\"/e10adb7c9d0442b9799b538265a2fc05/insertion_sort.gif\">\n  <br>\n</center>\n<p><code class=\"language-text\">삽입정렬</code>은 주어진 자료의 모든 요소를 앞에서부터 차례대로 정렬된 자료 부분과 비교하여 자신의 위치를 찾아 삽입하는 정렬이다. 사실 인간이 직접 정렬하는 순서와 제일 흡사하다고 할 수 있는 정렬인데, 직접 손안에 있는 카드를 정렬한다고 생각해보자. 대충 다음과 같은 순서로 행동할 것이다.</p>\n<hr>\n<ol>\n<li>카드를 하나 고른다.</li>\n<li>내가 가지고 있는 카드를 쭉 살펴본다.</li>\n<li>현재 카드가 들어가야할 순서에 카드를 껴넣는다.</li>\n</ol>\n<hr>\n<p>삽입정렬은 이 순서와 비슷하게 작동한다.</p>\n<hr>\n<ol>\n<li>0번 인덱스는 건너뛴다.</li>\n<li>0~1번 인덱스 중 1번 인덱스 값이 들어가야할 위치를 찾아서 넣는다</li>\n<li>0~2번 인덱스 중 2번 인덱스 값이 들어가야할 위치를 찾아서 넣는다\n<br>\n…\n<br></li>\n<li>\n<p>0~n번 인덱스 중 n번 인덱스 값이 들어가야할 위치를 찾아서 넣는다</p>\n<hr>\n</li>\n</ol>\n<p>삽입정렬은 최선의 경우 전체 자료를 한번만 순회하면 되기때문에 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>의 시간복잡도를 가지지만 최악의 경우 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>의 시간복잡도를 가진다.</p>\n<p>삽입정렬의 구현코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">insertionSort</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> len <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 두번째 카드부터 시작</span>\n    <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 카드를 잡는다</span>\n    <span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>j <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> input<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> value<span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 이미 정렬된 카드들을 뒤에서부터 살펴보다가</span>\n      <span class=\"token comment\">// 살펴본 카드가 현재 카드보다 크다면</span>\n      <span class=\"token comment\">// 살펴본 카드를 뒤로 한칸 보낸다</span>\n      input<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> input<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 뒤로 보내는 행위가 끝나면</span>\n    <span class=\"token comment\">// 현재 카드보다 작은 카드의 한칸 뒤에</span>\n    <span class=\"token comment\">// 현재 카드를 위치시킨다</span>\n    input<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"병합정렬merge-sort\" style=\"position:relative;\">병합정렬(Merge sort)<a href=\"#%EB%B3%91%ED%95%A9%EC%A0%95%EB%A0%ACmerge-sort\" aria-label=\"병합정렬merge sort permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<center>\n  <img src=\"/d57ade8c3762931df83b836b9c7dc88b/merge_sort.gif\">\n  <br>\n</center>\n<p><code class=\"language-text\">병합정렬</code>은 일종의 <code class=\"language-text\">분할 정복법</code> 중 하나로 큰 문제를 작은 여러 개의 문제로 쪼개서 각각을 해결한 후 결과를 모아서 원래의 문제를 해결하는 방법이다. 병합이라는 이름 그대로 주어진 자료를 잘게 쪼갠 뒤 합치는 과정에서 정렬을 하는 알고리즘이다. 순서를 살펴보면 다음과 같다.</p>\n<hr>\n<ol>\n<li><code class=\"language-text\">[5, 0, 4, 1]</code>라는 자료를 받았다</li>\n<li>length가 1이 될때까지 자료 리스트를 반으로 쪼갠다</li>\n<li><code class=\"language-text\">[5, 0]</code>, <code class=\"language-text\">[4, 1]</code>가 된다.</li>\n<li><code class=\"language-text\">[5]</code>, <code class=\"language-text\">[0]</code>, <code class=\"language-text\">[4]</code>, <code class=\"language-text\">[1]</code>가 된다</li>\n<li>각 리스트의 길이가 1이 되었으므로 병합을 시작한다</li>\n<li><strong>왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합.</strong> <code class=\"language-text\">[5]</code>와 <code class=\"language-text\">[0]</code> 중 0이 더 작으므로 새로운 리스트에 0을 먼저 병합한다</li>\n<li><code class=\"language-text\">[0, 5]</code> 생성</li>\n<li><strong>왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합.</strong> <code class=\"language-text\">[4]</code>와 <code class=\"language-text\">[1]</code> 중 1이 더 작으므로 새로운 리스트에 1을 먼저 병합</li>\n<li><code class=\"language-text\">[1, 4]</code> 생성</li>\n<li>이제 <code class=\"language-text\">[0, 5]</code>와 <code class=\"language-text\">[1, 4]</code>를 병합한다. 이 리스트들은 정렬되었기 때문에 작은 인덱스일 수록 작은 값을 가진다는 것이 보장되어있다.</li>\n<li><strong>왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합</strong></li>\n<li><code class=\"language-text\">[0]</code> 생성. <code class=\"language-text\">[5]</code>와 <code class=\"language-text\">[1, 4]</code>가 남았다</li>\n<li><strong>왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합</strong></li>\n<li><code class=\"language-text\">[0, 1]</code> 생성. <code class=\"language-text\">[5]</code>와 <code class=\"language-text\">[4]</code>가 남았다</li>\n<li><strong>왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합</strong></li>\n<li><code class=\"language-text\">[0, 1, 4]</code> 생성. <code class=\"language-text\">[5]</code>가 남았다</li>\n<li>값이 남았으므로 그냥 병합해준다.</li>\n<li>\n<p><code class=\"language-text\">[0, 1, 4, 5]</code> 정렬완료</p>\n<hr>\n</li>\n</ol>\n<p>위 과정 중에서 강조 처리된 <strong>왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합</strong> 을 보면 이 과정이 계속 반복되고 있는 것을 볼 수 있다.</p>\n<p>같은 방식으로 계속 반복하여 병합하고 있기 때문에 병합정렬은 보통 재귀함수로 구현한다. 또한 병합정렬은 항상 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi></mrow><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O({n\\log n})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span></span><span class=\"mclose\">)</span></span></span></span>의 시간복잡도를 가지기 때문에 효율적이다. 그러나 원소의 개수만큼 리스트를 쪼개고 따로 저장하고 있어야하기 때문에 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>의 공간복잡도를 가진다. 한마디로 메모리를 팔아 수행속도를 얻는 경우라고 할 수 있다.</p>\n<p>병합정렬의 구현코드는 다음과 같다</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">merge</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">left<span class=\"token punctuation\">,</span> right</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&amp;&amp;</span> right<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> right<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">mergeSort</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">input</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> input<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">const</span> middle <span class=\"token operator\">=</span> <span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">.</span>length <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> left <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> middle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> right <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>middle<span class=\"token punctuation\">,</span> input<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"퀵정렬quick-sort\" style=\"position:relative;\">퀵정렬(Quick sort)<a href=\"#%ED%80%B5%EC%A0%95%EB%A0%ACquick-sort\" aria-label=\"퀵정렬quick sort permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<center>\n  <img src=\"/ca493988dbac1ae41fa5e70ae069aca5/quick_sort.gif\">\n  <br>\n</center>\n<p><code class=\"language-text\">퀵정렬</code>도 병합정렬과 마찬가지로 분할정복을 통한 정렬방법이다. 병합정렬과의 차이점은 병합정렬은 분할 단계에서는 아무것도 하지않고 병합하는 단계에서 정렬을 수행하지만, 퀵정렬은 분할 단계에서 중요한 작업들을 수행하고 병합시에는 아무것도 하지않는다는 점이다.</p>\n<p>퀵정렬의 수행 순서는 다음과 같다.</p>\n<hr>\n<ol>\n<li>입력된 자료 리스트에서 하나의 원소를 고른다. 이 원소를 <code class=\"language-text\">피벗</code>이라고 부른다.</li>\n<li>피벗을 기준으로 리스트를 둘로 분할한다.</li>\n<li>피벗을 기준으로 피벗보다 작은 원소들은 모두 피벗의 왼쪽으로 옮긴다</li>\n<li>피벗을 기준으로 피벗보다 큰 원소들은 모두 피벗의 오른쪽으로 옮긴다</li>\n</ol>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//기준점을 찾고 기준점을 중심으로 더 작은수, 더 큰수 분류</span>\n    <span class=\"token keyword\">const</span> i <span class=\"token operator\">=</span>  <span class=\"token function\">position</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//기준점 기준 좌측 정렬</span>\n    <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//기준점 기준 우측 정렬</span>\n    <span class=\"token function\">quicksort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">position</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> right<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> pivot <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">//제자리 더 큰수/더 작은 수 좌우 배치.</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> pivot<span class=\"token punctuation\">)</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j <span class=\"token operator\">&amp;&amp;</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> pivot<span class=\"token punctuation\">)</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\n    tmp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  arr<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> pivot<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> j<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이상으로 정렬 알고리즘 포스팅을 마친다.</p>","tableOfContents":"<ul>\n<li><a href=\"#big-o-%ED%91%9C%EA%B8%B0%EB%B2%95%EA%B3%BC-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\">Big O 표기법과 시간복잡도</a></li>\n<li>\n<p><a href=\"#%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">정렬알고리즘</a></p>\n<ul>\n<li><a href=\"#%EB%B2%84%EB%B8%94%EC%A0%95%EB%A0%ACbubble-sort\">버블정렬(Bubble sort)</a></li>\n<li><a href=\"#%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%ACselection-sort\">선택정렬(Selection sort)</a></li>\n<li><a href=\"#%EC%82%BD%EC%9E%85%EC%A0%95%EB%A0%ACinsertion-sort\">삽입정렬(Insertion sort)</a></li>\n<li><a href=\"#%EB%B3%91%ED%95%A9%EC%A0%95%EB%A0%ACmerge-sort\">병합정렬(Merge sort)</a></li>\n<li><a href=\"#%ED%80%B5%EC%A0%95%EB%A0%ACquick-sort\">퀵정렬(Quick sort)</a></li>\n</ul>\n</li>\n</ul>","fields":{"lang":"ko"},"frontmatter":{"title":"정렬 알고리즘 정리 (Bubble, Selection, Insertion, Merge, Quick)","date":"2018-10-13","categories":["Programming","Algorithm"],"tags":["정렬 알고리즘","Sort Algorithms","Algorithm","알고리즘"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdtUEH//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAXEAEBAQEAAAAAAAAAAAAAAAABABAx/9oACAEBAAE/IWM6QTf/2gAMAwEAAgADAAAAEITv/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGBABAQEBAQAAAAAAAAAAAAAAAQAhETH/2gAIAQEAAT8Q6ADGb5ILcNIBlt//2Q==","aspectRatio":1.5037593984962405,"src":"/static/5971a1ceb80454e7d2a5b0bb79600959/08bc8/thumbnail.jpg","srcSet":"/static/5971a1ceb80454e7d2a5b0bb79600959/f836f/thumbnail.jpg 200w,\n/static/5971a1ceb80454e7d2a5b0bb79600959/2244e/thumbnail.jpg 400w,\n/static/5971a1ceb80454e7d2a5b0bb79600959/08bc8/thumbnail.jpg 660w","sizes":"(max-width: 660px) 100vw, 660px"}}}}},"allMarkdownRemark":{"edges":[]}},"pageContext":{"slug":"/20181013-sort-algorithm/","previous":{"fields":{"slug":"/20180925-vue-ssr/","path":"/2018/09/25/vue-ssr/","lang":"ko","postGroup":"20180925-vue-ssr"},"frontmatter":{"title":"Vue Server Side Rendering"}},"next":{"fields":{"slug":"/20190226-simple-ann/","path":"/2019/02/26/simple-ann/","lang":"ko","postGroup":"20190226-simple-ann"},"frontmatter":{"title":"TypeScript를 사용하여 간단한 인공 신경망 개발 삽질기"}},"lang":"ko","postGroup":"20181013-sort-algorithm"}}}