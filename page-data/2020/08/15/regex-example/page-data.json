{"componentChunkName":"component---src-templates-post-page-template-index-tsx","path":"/2020/08/15/regex-example/","result":{"data":{"markdownRemark":{"id":"587b8917-2535-52e2-a547-970e9deefa34","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%9C%A0%EC%A0%80%EC%9D%98-%EC%9E%85%EB%A0%A5-%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0\">유저의 입력 검증하기</a></p>\n<ul>\n<li><a href=\"#%EC%9D%B4%EB%A9%94%EC%9D%BC-%EC%A3%BC%EC%86%8C-%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0\">이메일 주소 검증하기</a></li>\n<li><a href=\"#%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8\">전화번호</a></li>\n<li><a href=\"#%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8\">비밀번호</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EA%B7%9C%EC%B9%99%ED%95%9C-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%97%90%EC%84%9C-%EC%9B%90%ED%95%98%EB%8A%94-%EC%A0%95%EB%B3%B4%EB%A7%8C-%EA%B3%A8%EB%9D%BC%EB%82%B4%EA%B8%B0\">불규칙한 문자열에서 원하는 정보만 골라내기</a></p>\n<ul>\n<li><a href=\"#%EC%A3%BC%EC%96%B4%EC%A7%84-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4%EC%97%90%EC%84%9C-%EC%88%AB%EC%9E%90%EB%A7%8C-%EA%B3%A8%EB%9D%BC%EB%82%B4%EA%B8%B0\">주어진 문자열 내에서 숫자만 골라내기</a></li>\n<li><a href=\"#%EB%AC%B8%EC%9E%A5-%EC%86%8D%EC%97%90%EC%84%9C-%EA%B8%88%EC%95%A1%EB%A7%8C-%EC%B6%94%EC%B6%9C%ED%95%98%EA%B8%B0\">문장 속에서 금액만 추출하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%EB%82%B4%EA%B0%80-%EC%9B%90%ED%95%98%EB%8A%94-%ED%8F%AC%EB%A7%B7%EC%9C%BC%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0\">문자열을 내가 원하는 포맷으로 변환하기</a></p>\n<ul>\n<li><a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9D%98-%EC%A0%95%EB%B3%B4-%EB%A7%88%EC%8A%A4%ED%82%B9%ED%95%98%EA%B8%B0\">사용자의 정보 마스킹하기</a></li>\n<li><a href=\"#ide-%EB%82%B4%EC%97%90%EC%84%9C-%EC%9B%90%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84%EB%A7%8C-replace%ED%95%98%EA%B8%B0\">IDE 내에서 원하는 부분만 Replace하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n</ul>","excerpt":"필자는 지난 불규칙 속에서 규칙을 찾아내는 정규표현식 포스팅에서 정규식의 기본적인 사용 방법을 한 차례 설명한 바 있다. 그러나 아무리 정규식의 기본적인 사용 방법을 알고 있다고 해도 실제로 정규식을 사용해야하는 상황이 되면 눈 앞이 깜깜해지기 마련이다. 그래서 이번 포스팅에서는 실제로 필자가 지금까지 일을 하며 경험했던 여러가지 상황을 토대로 정규식을 어떻게 사용했는지에 대한 몇 가지 예시와 설명을 조금 곁들여 볼까 한다. 정규식을 가장 많이 사용하는 상황인 “유저의 입력 검증”, “원하는 정보 찾기”, “문자열을 원하는 포맷으…","html":"<p>필자는 지난 <a href=\"/2020/07/24/about-regular-expression\">불규칙 속에서 규칙을 찾아내는 정규표현식</a> 포스팅에서 정규식의 기본적인 사용 방법을 한 차례 설명한 바 있다.</p>\n<p>그러나 아무리 정규식의 기본적인 사용 방법을 알고 있다고 해도 실제로 정규식을 사용해야하는 상황이 되면 눈 앞이 깜깜해지기 마련이다.</p>\n<p>그래서 이번 포스팅에서는 실제로 필자가 지금까지 일을 하며 경험했던 여러가지 상황을 토대로 정규식을 어떻게 사용했는지에 대한 몇 가지 예시와 설명을 조금 곁들여 볼까 한다.</p>\n<p>정규식을 가장 많이 사용하는 상황인 “유저의 입력 검증”, “원하는 정보 찾기”, “문자열을 원하는 포맷으로 변경하기”를 예시로, 문제를 정의하고 정규식을 사용하여 문제를 해결해보도록 하자.</p>\n<h2 id=\"유저의-입력-검증하기\" style=\"position:relative;\">유저의 입력 검증하기<a href=\"#%EC%9C%A0%EC%A0%80%EC%9D%98-%EC%9E%85%EB%A0%A5-%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0\" aria-label=\"유저의 입력 검증하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 개발을 진행하며 정규식이 가장 쉽게 접하는 상황은 유저의 입력을 검증할 때이다.</p>\n<p>개발이나 디자인을 하다보면 자연스럽게 알게 되는 것이기는 하지만, 유저는 절대 내가 설계한 대로 제품을 사용하지 않기 때문에 유저가 입력하는 데이터를 곧이 곧대로 신뢰하고 서버로 전송하는 행위는 꽤나 위험한 짓이다.</p>\n<p>분명히 이메일을 입력하라고 했는데 전화번호를 입력할 수도 있고, 최악의 경우에는 악의를 가지고 이상한 스크립트나 쿼리를 입력하여 서버로 전송할 수도 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 554px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d3d5049ed982f669de8ee19432f6f22e/04abd/sql_injection.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 48.75000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABd0lEQVR42m1R2U7DMBDMF/MnfAa/0JcKkFpKaaAtSCVNFdLch9PmPp2TSS0QIEYra7zeWe14ueGCvu9xFkVxOBw0TXNdRxAEcEVRJEkC3+/3Xdd9VzJwjLNUnuerFf/0xMvycT5/mM1mkImiuFgslsslpfSvuKkrtIzj2PfPURSnWWiRo02Uokz/lDLOzqZp2rblriePyJxOZ8uyCPFUTVytpwjb0SitdV3Tdd0wDLzihAvTNMHTNE2ShJusNl1dE0JM03BdIsm75+3ty/bOcY2qooYxKqGXZRlKRlAMC6M4i4KyqjAD7nXd5EUKB3ESUFqx8X4CZYxUaEwpN/wGHPVdP8YPt/8CBdzRctADk6iqatuObkrrt/vX3Zx45tAPwReiKArD0Pd9dgUZx766mQ5tjZzneUEQHlWR39w9b+8tW8/zce1ois2LX8DaYR5/hsm513chSzM0cxznfPZ140M48Igg9DAbfhXLz7IsuQAEmeKCsiw/AXYMKq9gkgA4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"sql injection\" title=\"\" src=\"/static/d3d5049ed982f669de8ee19432f6f22e/04abd/sql_injection.png\" srcset=\"/static/d3d5049ed982f669de8ee19432f6f22e/69538/sql_injection.png 160w,\n/static/d3d5049ed982f669de8ee19432f6f22e/72799/sql_injection.png 320w,\n/static/d3d5049ed982f669de8ee19432f6f22e/04abd/sql_injection.png 554w\" sizes=\"(max-width: 554px) 100vw, 554px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>물론 최근에는 백엔드 프레임워크에서 사용하는 ORM이 자체적으로 이런 인젝션 어택을 방어해주기는 하지만<br>퍼포먼스를 위해 로우 쿼리를 사용하는 경우도 여전히 존재하기 때문에 방심해서는 안 된다</small>\n</center>\n<p>그렇기 때문에 클라이언트 개발자는 1차적으로 사용자의 입력이 올바른 입력인지를 검증하는 밸리데이션 로직을 작성하게 되는데, 이 과정에서 정규식이 매우 유용하게 사용된다.</p>\n<h3 id=\"이메일-주소-검증하기\" style=\"position:relative;\">이메일 주소 검증하기<a href=\"#%EC%9D%B4%EB%A9%94%EC%9D%BC-%EC%A3%BC%EC%86%8C-%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0\" aria-label=\"이메일 주소 검증하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이메일은 사용자에게 받는 입력 데이터 중 굉장히 흔한 포맷이다. 게다가 이메일 주소라는 것은 각 필드의 역할도 명확하고 규칙도 제한적이라, 사용자가 입력한 데이터가 올바른 이메일 주소인지 검증하는 것도 크게 어렵지 않다.</p>\n<p>MBP(Mailbox Provider)마다 조금씩 다를 수는 있지만, 인터넷 메세지 프로토콜을 정의하고 있는 <a href=\"https://tools.ietf.org/html/rfc2822#section-3.4.1\" target=\"_blank\" rel=\"nofollow\">RFC 2822#Addr-spec specification</a>에서 정의된 바에 따르면 이메일 주소를 다음과 같은 패턴을 가진 문자열로 정의할 수 있다.</p>\n<blockquote>\n<ol>\n<li>\n<p>이메일 주소는 계정, @, 도메인으로 이루어진 문자열이다.</p>\n</li>\n<li>\n<p>계정은 영어와 숫자, 그리고 <code class=\"language-text\">!#$%&amp;'*+-/=?^_{|}~</code> 등의 특수문자를 사용할 수 있다. <code class=\"language-text\">.</code>도 사용할 수 있지만, 계정이 <code class=\"language-text\">.</code>으로 시작하거나 끝나서는 안 된다.</p>\n</li>\n<li>\n<p>도메인은 영어로 된 호스트와 도메인 식별자가 <code class=\"language-text\">.</code>으로 연결된 형태이다 (ex. google.com)</p>\n</li>\n<li>\n<p>계정과 도메인은 <code class=\"language-text\">@</code>으로 연결되어있다.</p>\n</li>\n</ol>\n</blockquote>\n<p>이처럼 이메일 주소는 한정적인 패턴을 가진 정보이기 때문에 정규식으로 간단하게 패턴 매칭을 통해 검증할 수 있다.</p>\n<h4 id=\"이메일-계정\" style=\"position:relative;\">이메일 계정<a href=\"#%EC%9D%B4%EB%A9%94%EC%9D%BC-%EA%B3%84%EC%A0%95\" aria-label=\"이메일 계정 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>이메일의 계정에는 영어와 숫자를 사용할 수 있기 때문에 <code class=\"language-text\">\\w</code>을 사용하여 영어와 숫자를 모두 포함한 워드 그룹을 사용하면 간단하게 이 패턴을 매칭할 수 있다. 또한 <code class=\"language-text\">!#$%&amp;'*+-/=?^_{|}~</code> 등의 특수 문자도 사용할 수 있기 때문에 <code class=\"language-text\">[\\w!#$%&amp;'*+-/=?^_{|}~]</code>과 같이 커스텀 그룹을 사용하면 이메일 계정에 사용할 수 있는 영어와 숫자, 특수문자를 모두 매칭할 수 있다.</p>\n<p>또한 이 패턴은 무조건 1번 이상 등장해야한다. 만약 이 패턴이 0번 등장한다면 계정에 위 패턴이 존재하지 않는다는 것이니 올바른 이메일 주소라고 취급할 수 없기 때문이다. 그래서 표현식의 끝에는 패턴이 1번 이상 등장했음을 의미하는 <code class=\"language-text\">+</code> 수량자를 붙혀줘야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"regex\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-regex line-numbers\"><code class=\"language-regex\"><span class=\"token anchor function\">^</span><span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span><span class=\"token char-set class-name\">\\w</span>!#$%&amp;'*+/=?^_{|}~-<span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">+</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 패턴이 기본적인 이메일 계정의 패턴이다. 하지만 RFC 2822에는 까다로운 규칙이 하나 더 있는데, 바로 ”<code class=\"language-text\">.</code>도 사용할 수 있지만, 계정이 <code class=\"language-text\">.</code>으로 시작하거나 끝나서는 안 된다.” 라는 규칙이다.</p>\n<p>물론 문자열이 <code class=\"language-text\">.</code>으로 시작하거나 끝나지 않는 지를 검사하는 문제는 <code class=\"language-text\">^</code>과 <code class=\"language-text\">$</code> 앵커를 사용하면 간단하게 해결할 수 있지만, 중간에 <code class=\"language-text\">.</code>이 등장하는 경우는 어떻게 처리해야할 지 애매하다.</p>\n<p>사실 이렇게 어떤 문자가 중간에 등장할 수도 있고 아닐 수도 있다는 패턴을 가장 간단하게 정의하는 방법은 별 게 없다.</p>\n<blockquote>\n<p><code class=\"language-text\">.</code>은 무조건 계정의 중간에 등장한다. 즉, <code class=\"language-text\">.</code> 뒤에는 반드시 <code class=\"language-text\">[\\w!#$%&amp;'*+-/=?^_{|}~]</code> 패턴이 다시 등장해야한다.</p>\n</blockquote>\n<p>조금 더 정리해보자면, <code class=\"language-text\">.어쩌고저쩌고</code> 라는 패턴은 계정 문자열 내에 등장할 수도 있고 등장하지 않을 수도 있으며, 만약 등장했다고 하면 반드시 <code class=\"language-text\">.</code> 뒤에는 다른 문자들이 있어야한다는 것이다.</p>\n<p>이 패턴만 따로 떼어내서 정규식으로 표현해보자면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"regex\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-regex line-numbers\"><code class=\"language-regex\"><span class=\"token group punctuation\">(?:</span><span class=\"token special-escape escape\">\\.</span><span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span><span class=\"token char-set class-name\">\\w</span>!#$%&amp;'*+/=?^_{|}~-<span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">+</span><span class=\"token group punctuation\">)</span><span class=\"token quantifier number\">*</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>먼저 <code class=\"language-text\">(?:</code>과 <code class=\"language-text\">)</code>로 묶어준 부분부터 살펴보자. 이 표현은 이전 포스팅에서 설명한 캡쳐링 기능과 동일한 역할을 한다.</p>\n<p>사실 캡쳐링은 캡쳐 외에도 여러 개의 표현을 그룹핑하는 기능 또한 가지고 있는데, 이때 그룹핑을 하는 <code class=\"language-text\">()</code>의 앞 쪽에 <code class=\"language-text\">?:</code>라는 표현을 포함시켜주면 캡쳐링 기능은 사용하지 않고 그룹핑 기능만 사용하겠다는 것을 의미하는 것이다.</p>\n<p>그래서 이 기능을 캡쳐링을 하지 않는 그룹을 만든다고 해서 “Non-Capturing Group”라고 한다.</p>\n<p>그리고 그룹 안쪽의 표현 중 <code class=\"language-text\">\\.</code>은 <code class=\"language-text\">.</code>이라는 문자 그 자체를 의미한다. 만약 이스케이핑 처리 없이 <code class=\"language-text\">.</code>만 적었다면 정규식 엔진은 해당 문자를 <code class=\"language-text\">.</code>이 아닌 모든 문자를 의미하는 캐릭터 클래스로 해석할 것이기 때문에, <code class=\"language-text\">.</code>이라는 문자 그대로 해석할 수 있도록 이스케이핑 처리를 해준 것이다.</p>\n<p>그 뒤로는 앞서 계정 패턴에 사용했던 <code class=\"language-text\">[\\w!#$%&amp;'*+/=?^_{|}~-]+</code> 패턴을 그대로 적어주었다. 즉, <code class=\"language-text\">.</code> 뒤에는 저 패턴이 반드시 1개 이상 따라온다는 것을 표현한 것이다.</p>\n<p>그리고 마지막으로 이 전체 패턴은 나타날 수도 있고 나타나지 않을 수도 있다는 것을 표현해주기 위해 그룹이 끝나는 <code class=\"language-text\">)</code> 부분 뒤 쪽에 0번 또는 그 이상의 패턴이 출몰할 수 있다는 <code class=\"language-text\">*</code> 수량자를 붙혀주었다.</p>\n<p>이제 이 패턴을 앞서 정의한 <code class=\"language-text\">[\\w!#$%&amp;'*+/=?^_{|}~-]+</code> 패턴과 합쳐주면 올바른 이메일 계정을 잡아낼 수 있는 패턴이 완성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^[\\w!#$%&amp;'*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_{|}~-]+)*$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 영어 + 숫자</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// 계정 중간이 .으로 나누어짐</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91.test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\n<span class=\"token comment\">// .으로 끝나거나 시작함</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.bboydart91'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id=\"도메인\" style=\"position:relative;\">도메인<a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8\" aria-label=\"도메인 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>이제 정규식을 사용하여 올바른 이메일 계정을 구분할 수 있는 패턴을 정의했으니, 남은 것은 올바른 도메인을 구분할 수 있는 패턴을 정의하는 것 뿐이다.</p>\n<p>RFC 2822에 따르면 도메인은 “영어로 된 호스트와 도메인 식별자가 <code class=\"language-text\">.</code>으로 연결된 형태”라고 했으니, 패턴 매칭의 조건이 크게 어려운 것은 아니다.</p>\n<p>그러나 조건을 잘 살펴보면 호스트와 도메인 식별자가 <code class=\"language-text\">.</code>으로 연결된 형태라고만 하고 있을 뿐이지 <code class=\"language-text\">.</code>이 단 한번만 등장한다는 이야기가 없기 때문에 이 부분을 신경써줘야한다. 즉, <code class=\"language-text\">google.com</code>과 같은 패턴 뿐만 아니라 <code class=\"language-text\">google.co.kr</code> 처럼 <code class=\"language-text\">.</code>이 여러 번 등장하는 녀석들도 다 잡아줘야 한다는 것이다.</p>\n<p>이런 애매한 패턴들도 방금 전 계정 패턴을 정의할 때 사용했던 Non-Capturing Group을 사용하면 간단하게 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^(?:\\w+\\.)+\\w+$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">(?:\\w+\\.)+</code>은 <code class=\"language-text\">google.</code>과 같이 워드 그룹과 <code class=\"language-text\">.</code>이 합쳐진 패턴이 반드시 한 번 이상 나타나야 한다는 것을 표현하고, 이어지는 <code class=\"language-text\">\\w+</code>는 <code class=\"language-text\">.</code> 뒤에도 워드 그룹으로 이루어진 문자열이 반드시 한 번 이상 나타나야 한다는 것을 표현한 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 호스트와 도메인 식별자가 모두 존재</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google.co.kr'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//true</span>\n\n<span class=\"token comment\">// 도메인 식별자가 없음</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n\n<span class=\"token comment\">// 호스트가 없음</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.co.kr'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id=\"계정-패턴-표현식과-도메인-패턴-표현식을-합치자\" style=\"position:relative;\">계정 패턴 표현식과 도메인 패턴 표현식을 합치자<a href=\"#%EA%B3%84%EC%A0%95-%ED%8C%A8%ED%84%B4-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%8F%84%EB%A9%94%EC%9D%B8-%ED%8C%A8%ED%84%B4-%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%84-%ED%95%A9%EC%B9%98%EC%9E%90\" aria-label=\"계정 패턴 표현식과 도메인 패턴 표현식을 합치자 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>이제 올바른 이메일 계정과 도메인을 잡아낼 수 있는 정규식을 정의했으니 마지막 조건인 “계정과 도메인은 <code class=\"language-text\">@</code>으로 연결되어있다”를 만족시키기 위해, 이 두 표현을 <code class=\"language-text\">@</code>로 합쳐주기만 하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 계정 패턴: ^[\\w!#$%&amp;'*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_{|}~-]+)*</span>\n<span class=\"token comment\">// 도메인 패턴 (?:\\w+\\.)+\\w+$</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^[\\w!#$%&amp;'*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_{|}~-]+)*@(?:\\w+\\.)+\\w+$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">regex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart.evan@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart@naver.co.kr'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.bboydart91@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91@gmail'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91.@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"전화번호\" style=\"position:relative;\">전화번호<a href=\"#%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8\" aria-label=\"전화번호 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>전화번호 같은 경우는 지난 포스팅인 <a href=\"/2020/07/24/about-regular-expression\">불규칙 속에서 규칙을 찾아내는 정규표현식</a>에서 한 차례 언급한 바가 있지만, 이전 포스팅을 읽지 못하신 독자분들을 위해 한번 더 언급하려고 한다.</p>\n<p>전화번호 또한 이메일과 마찬가지로 유저에게 입력받는 경우가 많은 정보이기 때문에 전화번호를 잡아낼 수 있는 패턴을 숙지하고 있으면 좋기 때문이다.</p>\n<p>대한민국의 전화번호는 총 3가지 패턴을 가지고 있는데, 휴대폰 번호같은 경우 반드시 맨 앞에는 3자리의 통신사 식별번호가 위치하고 그 뒤에는 4자리의 전화번호 필드가 두 번 반복되는 형태를 가지며, 그 외 유선전화는 2-3자리의 지역번호 뒤로 3-4 자리의 필드와 4자리의 필드가 반복되는 형태를 가진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'010-0101-0101'</span>\n<span class=\"token string\">'02-0101-0101'</span>\n<span class=\"token string\">'031-010-0101'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>이렇듯 전화번호라는 정보는 그저 숫자들이 일정 횟수만큼 반복적으로 나타나는 패턴 뿐이기 때문에 이 패턴을 잡아내기 위한 정규식 또한 간단하게 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\d{2,3}-?\\d{3,4}-?\\d{4}$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">regex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'01012341234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'010-1234-1234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'0212341234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'02-1234-1234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'031-123-1234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>전화번호는 각 필드의 자릿수가 명확하게 정해져있기 때문에 단순한 수량자 표현만으로도 패턴을 잡아낼 수 있다. 또한 전화번호 중간의 하이픈(<code class=\"language-text\">-</code>)은 등장할 수도 있고 아닐 수도 있으므로 0 또는 1회를 의미하는 수량자인 <code class=\"language-text\">?</code> 를 사용하여 패턴을 처리해주었다.</p>\n<p>이렇게 전화번호 패턴을 잡아내는 표현식 자체는 간단하지만, 의외로 신경쓰고 있지 않던 부분에서 실수를 하는 경우가 생기는데, 바로 이런 패턴을 사용하는 상황 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 휴대폰 번호를 잡아내는 패턴</span>\n<span class=\"token operator\">/</span><span class=\"token number\">010</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 패턴의 문제는 <code class=\"language-text\">010</code>이라는 통신사 식별번호를 가지고 있는 휴대폰 번호만 잡아낼 수 있다는 것이다.</p>\n<p>필자같은 아재들이야 <code class=\"language-text\">011</code>, <code class=\"language-text\">017</code>, <code class=\"language-text\">018</code> 등의 번호가 있던 시절을 아직 기억하고 있기 때문에 이런 실수를 할 확률이 낮지만, 간혹 2000년대에 출생하신 분들 중에서 이 부분을 놓치는 경우를 간혹 보았었다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5d22138cdc7f106c76184f763b009060/41099/old_phone.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDBP/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAF4bZikSGP/xAAbEAACAQUAAAAAAAAAAAAAAAAAAQISEyEiMv/aAAgBAQABBQLQqki2xYHy5s//xAAWEQADAAAAAAAAAAAAAAAAAAABECH/2gAIAQMBAT8BMX//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwFH/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEQMUH/2gAIAQEABj8CwfYxT//EABkQAQEBAQEBAAAAAAAAAAAAAAERACExQf/aAAgBAQABPyEATpndAlQ/HQ9evc7BjOi0uQ7/2gAMAwEAAgADAAAAEGPf/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAwEBPxDBMp//xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8QHY//xAAZEAEBAAMBAAAAAAAAAAAAAAABEQAhMUH/2gAIAQEAAT8QYwEaGgeFyCchT3fIcxh2hVybek20lTmWCj0aO+ZWrXP/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"old phone\" title=\"\" src=\"/static/5d22138cdc7f106c76184f763b009060/41099/old_phone.jpg\" srcset=\"/static/5d22138cdc7f106c76184f763b009060/0913d/old_phone.jpg 160w,\n/static/5d22138cdc7f106c76184f763b009060/cb69c/old_phone.jpg 320w,\n/static/5d22138cdc7f106c76184f763b009060/41099/old_phone.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>1996년 신상 \"걸면 걸리는 걸리버 폰\"...필자의 아버지도 이 폰을 쓰셨던 기억이 있다</small>\n</center>\n<p>물론 정부와 통신사들이 <code class=\"language-text\">01x</code> 번호를 <code class=\"language-text\">010</code>으로 통합하려고 노력하고 있지만 아직까지 추억의 번호를 버리지 못하시는 분들도 꽤나 있기 때문에, 우리는 <code class=\"language-text\">01[0|1|6|7|8|9]</code>처럼 <code class=\"language-text\">011</code>이나 <code class=\"language-text\">016</code>, <code class=\"language-text\">018</code> 등의 통신사 식별번호도 잡아낼 수 있는 패턴을 사용해야한다.</p>\n<h3 id=\"비밀번호\" style=\"position:relative;\">비밀번호<a href=\"#%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8\" aria-label=\"비밀번호 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>비밀번호는 사용자의 인증, 보안과 직결된 정보이기 때문에 유효성을 검사해야하는 정보들 중에서도 꽤 까다로운 검사 조건을 자랑하는 녀석이다.</p>\n<p>지금 바로 생각나는 조건은 대략 세 가지 정도인데, 이 조건들은 기본적인 보안 수준을 지키기 위함이기 때문에 서비스 종류를 망라하고 대부분의 서비스에서 지켜지는 녀석들이다.</p>\n<blockquote>\n<ul>\n<li>반드시 소문자, 대문자, 숫자, 특수 문자가 하나씩 포함되어야한다.</li>\n<li>같은 문자가 3번 이상 반복되면 안된다.</li>\n<li>8글자 이상이어야 한다.</li>\n</ul>\n</blockquote>\n<p>이때 사용자가 비밀번호를 틀렸을 때 얼마나 상세한 에러메세지를 보여줄 계획이냐에 따라서 이 조건들을 한 번에 검사하기도 하고 따로 검사하기도 한다.</p>\n<p>가장 첫 번째 조건은 비밀번호 안에 반드시 영어 소문자, 대문자, 숫자, 특수문자가 하나씩은 포함되어있어야 한다는 조건이다. 물론 이 조건을 하나씩 따로 따로 검사한다면 간단하게 <code class=\"language-text\">/[a-z]/g</code>이나 <code class=\"language-text\">/\\d/g</code>와 같은 표현식으로 간단하게 검사할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> password <span class=\"token operator\">=</span> <span class=\"token string\">'test1234!'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 따로 검사</span>\n<span class=\"token keyword\">const</span> hasNumberPattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\d</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> hasLowerCasePattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[a-z]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> hasUpperCasePattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[A-Z]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> hasSpecialCharPattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\W</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasNumberPattern<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'비밀번호에는 숫자가 하나 이상 어쩌고...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasLowerCasePattern<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'비밀번호에는 영어 소문자가 하나 이상 어쩌고...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>하지만 문제는 이 조건들을 한 번에 검사하고 싶을 때 발생한다. 단순하게 <code class=\"language-text\">[a-zA-Z\\d]</code> 등의 커스텀 그룹으로 검사하려고 한다면 이 중 단 하나의 패턴만 비밀번호에 포함되어 있어도 조건이 통과되어 버릴테고, <code class=\"language-text\">[a-z]+[A-Z]+</code>등의 패턴으로 검사하려고 하면 반드시 “소문자 다음에는 대문자가 와야함”과 같은 순서가 생겨버리기 때문이다.</p>\n<p>이런 상황에서 우리는 약간 트리키(Tricky)한 방법을 사용하여 이 문제를 해결할 수 있다.</p>\n<h4 id=\"lookaround를-사용하여-유효성-검사하기\" style=\"position:relative;\">Lookaround를 사용하여 유효성 검사하기<a href=\"#lookaround%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC%ED%95%98%EA%B8%B0\" aria-label=\"lookaround를 사용하여 유효성 검사하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>그 방법은 바로 특정 패턴 앞에 나타나는 패턴을 표현하는 방법인 Positive Lookahead(<code class=\"language-text\">(?=)</code>)를 사용하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// ://이라는 문자 앞에 등장하는 https를 잡아줘!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">https(?=:\\/\\/)</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">regex<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// null</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ['https']</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이렇게 특정 표현의 앞이나 뒤에 나타나는 패턴을 잡아내는 표현을 “Lookaround”라고 하며, Lookaround는 총 4가지 패턴으로 다시 분류된다.</p>\n<table>\n<thead>\n<tr>\n<th>이름</th>\n<th>패턴</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Positive Lookahead</td>\n<td><code class=\"language-text\">abc(?=123)</code></td>\n<td><code class=\"language-text\">123</code> 앞에 오는 <code class=\"language-text\">abc</code>를 잡아라</td>\n</tr>\n<tr>\n<td>Negative Lookahead</td>\n<td><code class=\"language-text\">abc(?!123)</code></td>\n<td><code class=\"language-text\">123</code> 앞에 오지 않는 <code class=\"language-text\">abc</code>를 잡아라</td>\n</tr>\n<tr>\n<td>Positive Lookbehind</td>\n<td><code class=\"language-text\">(?&lt;=123)abc</code></td>\n<td><code class=\"language-text\">123</code> 뒤에 오는 <code class=\"language-text\">abc</code>를 잡아라</td>\n</tr>\n<tr>\n<td>Negative Lookbehind</td>\n<td><code class=\"language-text\">(?&lt;!123)abc</code></td>\n<td><code class=\"language-text\">123</code> 뒤에 오지 않는 <code class=\"language-text\">abc</code>를 잡아라</td>\n</tr>\n</tbody>\n</table>\n<p>주위를 둘러보라는 “Look around”라는 단어의 의미처럼, Lookaround 표현은 말 그대로 특정 패턴의 앞뒤로 나타나는 패턴이 있는지를 검사하는 용도로 사용되는 표현이지만, 이 표현을 해석하는 정규식 엔진의 작동 원리를 잘 이용하면 문자열 내에 특정한 패턴의 글자가 1번 이상 나타났는지를 잡아내야하는 경우에도 유용하게 사용할 수 있다.</p>\n<p>일단 Lookaround 표현 자체는 특정 문자를 잡아내기 위한 표현이 아니기 때문에 마치 <a href=\"/2020/07/24/about-regular-expression/#%EB%AC%B8%EC%9E%90%EA%B0%80-%EC%95%84%EB%8B%8C-%EA%B2%BD%EA%B3%84%EB%A5%BC-%EC%9E%A1%EC%95%84%EB%82%B4%EB%8A%94-%EC%95%B5%EC%BB%A4\">\\b 앵커</a>처럼 일종의 경계로 인식된다. 또한 한 가지 중요한 특징은 정규식 엔진이 Lookaround를 사용하여 특정 문자와 매칭에 성공하더라도 마치 해당 매칭이 없었던 것처럼 작동한다는 것이다.</p>\n<p>무슨 이야기인지 잘 이해가 안 가시는 분들을 위해 조금 더 자세한 예시를 들어보도록 하겠다. 만약 <code class=\"language-text\">quit</code>라는 문자열에 <code class=\"language-text\">q(?=u)i</code>와 같은 표현식을 적용해보면 정규식 엔진은 다음과 같이 작동한다.</p>\n<blockquote>\n<ol>\n<li>엔진은 문자열의 <code class=\"language-text\">q</code>를 매칭하려 함. 정규식의 <code class=\"language-text\">q</code> 리터럴과 매칭 성공</li>\n<li>엔진은 문자열의 <code class=\"language-text\">u</code>를 매칭하려 함. 정규식의 <code class=\"language-text\">(?=u)</code> 내부의 <code class=\"language-text\">u</code>가 있기에 매칭 성공. 그리고 엔진은 이 패턴과 <code class=\"language-text\">u</code> 문자가 Lookaround로 매칭 성공되었다는 사실을 잊어버린다.</li>\n<li>이제 엔진은 Lookaround 패턴 뒤에 위치한 패턴을 사용하여 다시 문자열의 <code class=\"language-text\">u</code>를 매칭해보려고 시도함.</li>\n<li>근데 표현식의 다음 표현은 <code class=\"language-text\">i</code>임. <code class=\"language-text\">u</code>와 매칭 실패하고 종료.</li>\n</ol>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">q(?=u)i</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'quit'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">null</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이건 어찌보면 당연한 수순인데, <code class=\"language-text\">(?=u)</code>와 같은 Lookaround 표현은 단지 해당 표현 앞에 오는 패턴을 잡아내기 위한 재료일 뿐이지, 실제로 <code class=\"language-text\">u</code>라는 글자를 잡아내기 위한 표현이 아니기 때문이다. 그래서 정규식 엔진은 Lookaround를 사용하여 <code class=\"language-text\">u</code>라는 문자를 매칭했음에도 매칭 성공 후에 <code class=\"language-text\">u</code>라는 문자에 다시 매칭을 시도하는 것이다.</p>\n<p>만약 <code class=\"language-text\">(?=u)</code> 패턴 뒤의 리터럴 표현을 <code class=\"language-text\">i</code>가 아니라 <code class=\"language-text\">u</code>로 바꾸어주면 4번 조건을 통과하면서 매칭을 성공하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">q(?=u)u</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'quit'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"qu\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 가장 중요한 포인트는 정규식 엔진이 Lookaround로 한번 매칭되었던 문자는 재료로써의 매칭만 성공했기 때문에 정식 매칭 성공이 아니라고 판단하여, Lookaround 표현의 뒤에 위치한 표현을 사용하여 다시 해당 문자에 매칭을 시도한다는 것이다.</p>\n<p>정규식 엔진의 이런 특성을 잘 사용하면 Lookaround 표현을 마치 <code class=\"language-text\">if</code>문 처럼 사용할 수도 있다. 그렇다면 이 방법을 사용하여 아까 필자가 정의했던 비밀번호의 조건 중 하나를 검사해보자.</p>\n<blockquote>\n<p>반드시 소문자, 대문자, 숫자, 특수 문자가 하나씩 포함되어야한다.</p>\n</blockquote>\n<p>하지만 이 조건을 한 번에 모두 검사하면 표현식이 길어질 것 같으니, 우선은 비밀번호 안에 반드시 숫자가 포함되어 있는지만 한번 검사를 해보면 좋을 것 같다. 이때 방금 학습한 Positive Lookahead 표현을 사용하여 해당 조건 여부를 검사해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=\\d).</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abc123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서 정규식이 <code class=\"language-text\">1</code>이라는 문자를 잡아낸 이유는 위에서 이야기했던 것처럼 <code class=\"language-text\">(?=\\d)</code>라는 표현이 <code class=\"language-text\">1</code>과 매칭이 되었고, 이후 정규식 엔진이 해당 표현 바로 뒤에 오는 <code class=\"language-text\">.</code>으로 다시 한번 동일한 문자에 매칭을 시도했기 때문이다.</p>\n<p>이 과정을 조금 더 쉽게 의사코드로 다시 풀어보자면 이런 느낌이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=\\d)</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=\\d)</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 매칭에 성공했으니 이 패턴은 제거</span>\n  <span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 그 뒤에 오는 패턴으로 동일한 문자에 다시 매칭 시도</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>즉, 정규식 엔진이 <code class=\"language-text\">.</code>이라는 리터럴 표현을 가지고 매칭을 시도했다는 것은 그 앞에 있던 <code class=\"language-text\">(?=\\d)</code>라는 표현으로 이미 해당 문자에 매칭을 성공했다는 의미인 것이다.</p>\n<p>이제 숫자를 검사했으니 나머지 조건인 영어 소문자와 대문자, 그리고 특수문자도 동일한 방식을 사용하여 앞 쪽에 줄줄이 붙혀주기만 하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// \\d = 숫자</span>\n<span class=\"token comment\">// [a-z] = 영어 소문자</span>\n<span class=\"token comment\">// [A-Z] = 영어 대문자</span>\n<span class=\"token comment\">// [\\W] = Word 그룹(숫자, 영어)가 아닌 문자</span>\n<span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\\d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">[</span>a<span class=\"token operator\">-</span>z<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token operator\">-</span><span class=\"token constant\">Z</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">[</span>\\<span class=\"token constant\">W</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>g</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서 <code class=\"language-text\">\\W</code> 캐릭터 클래스는 사실 영어, 숫자가 아닌 문자를 의미하는 클래스라서 특수문자 뿐 아니라 한글이나 키릴문자 같은 문자도 전부 포함되기는 하는데, 일일히 특수문자를 나열하기는 가독성이 너무 떨어지니<small><del>귀찮으니</del></small> 대충 썼다. <small>(실제로 사용할 때는 <code class=\"language-text\">!@#$%^...</code>처럼 일일히 나열해주는 방식으로 변경해줘야한다.)</small></p>\n<p>이런 식으로 비밀번호의 나머지 조건인 “같은 문자가 3번 이상 반복되면 안 된다”와 “8자리 이상이어야 한다”라는 조건도 동일한 방법으로 검사해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\\W])(?!.*(.)\\1{2}).{8,}</span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<table>\n<thead>\n<tr>\n<th>표현</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">(?=.*\\d)</code></td>\n<td>연속 또는 하나만 나타날 수 있는 <code class=\"language-text\">\\d</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?=.*[a-z])</code></td>\n<td>연속 또는 하나만 나타날 수 있는 <code class=\"language-text\">[a-z]</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?=.*[A-Z])</code></td>\n<td>연속 또는 하나만 나타날 수 있는 <code class=\"language-text\">[A-Z]</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?=.*[\\W])</code></td>\n<td>연속 또는 하나만 나타날 수 있는 <code class=\"language-text\">[\\W]</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?!.*(.)\\1{2})</code></td>\n<td>연속적으로 3번 나타나지 않는 모든 문자</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">.{8,}</code></td>\n<td>위 조건을 모두 통과한 8자리 문자열 패턴</td>\n</tr>\n</tbody>\n</table>\n<p>이 표현은 앞 쪽의 Positive Lookahead와 Negative Lookahead의 조건을 모두 통과해야 비로소 맨 마지막의 <code class=\"language-text\">.{8,}</code> 표현과 매칭을 시도할 것이기 때문에, 이 조건을 통과한 문자열은 우리가 정의했던 비밀번호의 모든 조건을 통과했다는 의미가 된다.</p>\n<p>물론 비밀번호를 이렇게 하나의 정규식 표현으로 검사해버리면 사용자에게 “비밀번호가 올바르지 않습니다” 정도의 에러 메세지 밖에 보여줄 수 없기 때문에 이렇게 한번에 처리하는 경우가 오히려 드물기는 하지만, Lookaround를 사용한 조건 처리 방법은 꽤나 유용한 편이라고 생각이 들어서 이렇게 설명하게 되었다.</p>\n<h2 id=\"불규칙한-문자열에서-원하는-정보만-골라내기\" style=\"position:relative;\">불규칙한 문자열에서 원하는 정보만 골라내기<a href=\"#%EB%B6%88%EA%B7%9C%EC%B9%99%ED%95%9C-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%97%90%EC%84%9C-%EC%9B%90%ED%95%98%EB%8A%94-%EC%A0%95%EB%B3%B4%EB%A7%8C-%EA%B3%A8%EB%9D%BC%EB%82%B4%EA%B8%B0\" aria-label=\"불규칙한 문자열에서 원하는 정보만 골라내기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>대부분의 경우 정규식은 유저의 입력을 검증하는 일에 많이 사용되고는 하지만, 사실 정규식의 존재 의의는 단지 정보를 검증하는 것이라기보다 불규칙한 정보 속에서 특정한 패턴을 찾아내어 추출하는 것에 가깝다.</p>\n<p>이번에는 일상 속에서 필자가 경험했던 사례들과 함께 정규식을 사용하여 어떻게 문제를 해결했었는지에 대한 이야기를 해보려고 한다.</p>\n<h3 id=\"주어진-문자열-내에서-숫자만-골라내기\" style=\"position:relative;\">주어진 문자열 내에서 숫자만 골라내기<a href=\"#%EC%A3%BC%EC%96%B4%EC%A7%84-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4%EC%97%90%EC%84%9C-%EC%88%AB%EC%9E%90%EB%A7%8C-%EA%B3%A8%EB%9D%BC%EB%82%B4%EA%B8%B0\" aria-label=\"주어진 문자열 내에서 숫자만 골라내기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>주어진 문자열 내에서 숫자만 골라내야하는 상황은 생각보다 현업에서 많이 마주치는 문제 중 하나이다. 필자의 경우에는 원본 데이터를 직접 수정할 수 없는 상황에서 금액이나 나이를 의미하는 숫자만 걸러내어 데이터를 정규화하거나 다른 포맷으로 보여줘야하는 상황을 많이 겪었던 것 같다.</p>\n<p>예를 들어 어떤 API를 사용했는데, 이 API에서는 금액 정보를 <code class=\"language-text\">1000</code>과 같은 Number 자료형이 아닌 <code class=\"language-text\">1,000원</code>과 같은 포맷팅된 문자열로 내려준다고 생각해보자. 그리고 이 데이터를 사용하는 클라이언트에서는 이런 비즈니스 로직을 작성해야하는 상황이다.</p>\n<blockquote>\n<p>“1,000원”과 “2,000원” 중 어떤 것이 큰 금액일까?</p>\n</blockquote>\n<p>물론 가장 좋은 상황은 원본 데이터가 <code class=\"language-text\">1000</code>과 같은 Number 자료형으로 내려오고 데이터를 사용하는 쪽에서 적절한 후처리를 통해 가공하는 것이지만, 그렇게 API를 수정해버리면 이 API가 전체 서비스 중 어느 부분에서 사용되고 있는지 전부 파악하고 이 API를 사용하는 클라이언트의 소스를 모두 수정해줘야 하기 때문에 리스크 관리 차원에서 그냥 넘어가는 경우도 꽤나 있다.</p>\n<p>이런 상황 속에서 개발자는 <code class=\"language-text\">1,000원</code>이라는 문자열에서 콤마와 “원”이라는 글자를 제외하고 <code class=\"language-text\">1000</code>이라는 숫자만 뽑아온 후 두 개의 금액을 비교하는 과정을 거쳐야 할 것이다.</p>\n<p>만약 정규식이 없다면 이 문자열을 <code class=\"language-text\">split</code> 메소드를 통해 분해하고 이렇게 만들어진 배열을 순회하면서 이 문자가 숫자인지 아닌지 구분해야하거나 <code class=\"language-text\">String.prototype.replace</code>를 2번씩 해줘야하는 번거로운 과정을 거쳐야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">NUMBERS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'3'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'4'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'5'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'6'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'7'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'8'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'9'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'1,000원'</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> <span class=\"token constant\">NUMBERS</span><span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 또는</span>\n\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'1,000원'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'원'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">1000</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">String.prototype.replace</code> 메소드를 사용하는 방법도 꽤나 간단해보이기는 하지만, 이 방법의 한계는 <code class=\"language-text\">,</code>나 <code class=\"language-text\">원</code> 이외에 다른 문자가 섞여버리면 그 문자의 경우의 수만큼 <code class=\"language-text\">replace</code>를 반복해야하거나 코드를 수정해줘야 한다는 것이다. <small>(<code class=\"language-text\">1,000원...일까요?</code> 같은 문자열이 들어오는 순간 망한다)</small></p>\n<p>물론 똑같이 문자열 내에서 숫자만 발라내는 코드지만, 정규식을 사용하면 상대적으로 간편하고 유연하게 문제를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'1,000원'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^0-9]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 또는</span>\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'1,000원'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^\\d]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// or</span>\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'1,000원'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\D</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">1000</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>자바스크립트의 <code class=\"language-text\">String.prototype.replace</code> 메소드는 특정 문자열을 검색한 후에 두 번째 인자로 주어진 문자열로 모두 치환해주는 메소드이다. <code class=\"language-text\">replace</code> 메소드는 정규식을 사용하여 원하는 문자 패턴을 찾는 기능을 지원하고 있기 때문에, 정규식을 사용하여 “숫자가 아닌 것”을 잡아서 모두 빈 문자열로 치환해버린다면 우리가 원하는 바인 “숫자만 골라내기”라는 문제를 해결할 수 있는 것이다.</p>\n<p>즉, 필자가 사용했던 <code class=\"language-text\">[^0-9]</code>, <code class=\"language-text\">[^\\d]</code>, <code class=\"language-text\">\\D</code> 라는 키워드들은 모두 숫자가 아닌 문자들을 잡아내는 키워드를 의미하기 때문에 “숫자가 아닌 것”을 저 정규식들로 한 방에 잡아내어 없애버릴 수 있었던 것이다.</p>\n<p>물론 처음 필자가 작성했던 예시처럼 정규식을 사용하지 않고도 <code class=\"language-text\">split</code>, <code class=\"language-text\">filter</code>, <code class=\"language-text\">join</code>, <code class=\"language-text\">replace</code> 메소드를 조합하더라도 당장 문제를 해결하는데는 아무 어려움이 없지만, 현실에는 문자열 속에서 숫자만 찾아내는 수준의 간단한 문제보다 복잡한 수준의 문제들이 즐비해 있다는 사실을 잊어서는 안된다.</p>\n<p>그럼 현실 속에서 만날 수 있는 문제들 중 조금 더 어려운 문제를 하나만 더 보도록 하자.</p>\n<h3 id=\"문장-속에서-금액만-추출하기\" style=\"position:relative;\">문장 속에서 금액만 추출하기<a href=\"#%EB%AC%B8%EC%9E%A5-%EC%86%8D%EC%97%90%EC%84%9C-%EA%B8%88%EC%95%A1%EB%A7%8C-%EC%B6%94%EC%B6%9C%ED%95%98%EA%B8%B0\" aria-label=\"문장 속에서 금액만 추출하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>이번에는 방금 전 봤던 문제와 같은 맥락이지만 조금 더 복잡한 문제를 한번 해결해보려고 한다. 방금 우리가 경험했던 문제는 <code class=\"language-text\">1,000원</code>이라는 누가 봐도 명확히 금액을 의미하는 작은 단어에서 숫자를 의미하는 부분만 뽑아내는 것이었다면, 이번에는 자연어로 이루어진 긴 문장 속에서 금액을 의미하는 부분만 찾아내어 금액 데이터를 추출해야한다.</p>\n<p>예시 문장은 부자가 되고 싶다는 필자의 염원을 담아 적당한 기사에서 발췌해왔다.</p>\n<blockquote>\n<p>현재까지 로또 복권의 판매금액은 38조40230억2565만7000원. 2014년 기준 회당 평균 580억원 가량의 로또가 팔린다. 조사에 따르면 1인당 평균 구매액은 9400원으로 19세 이상 성인 인구 기준 매주 약 512만 명이 로또를 구입한다.</p>\n<p><strong>중앙일보</strong> <em><a href=\"https://news.joins.com/article/20308275\" target=\"_blank\" rel=\"nofollow\">로또 1등 당첨돼 189억 받은 남성 지금은…</a></em></p>\n</blockquote>\n<p>이렇게 긴 자연어 문장 속에서 금액을 의미하는 데이터만 추출해야하는 상황이라면 우리가 풀어야 할 문제는 총 두 가지의 작은 문제로 나눠볼 수 있다.</p>\n<blockquote>\n<ol>\n<li>많은 숫자들 중에서 금액을 의미하는 단어만 뽑아내기</li>\n<li><code class=\"language-text\">580억원</code>과 같은 단어를 Number형인 <code class=\"language-text\">5800000000</code>으로 변환하기</li>\n</ol>\n</blockquote>\n<p>이 중 두 번째 문제는 정규식만으로 해결하기에는 약간 무리가 있으니, 우리는 첫 번째 문제인 “많은 숫자들 중에서 금액을 의미하는 단어만 뽑아내기”에만 집중해보도록 하자.</p>\n<p>만약 이 문제를 해결할 때 필자가 위에서 사용했던 <code class=\"language-text\">\\d</code>나 <code class=\"language-text\">[0-9]</code>와 같은 키워드를 사용하게 되면 금액을 의미하는 숫자가 아닌 <code class=\"language-text\">2014년</code>, <code class=\"language-text\">1인당</code>, <code class=\"language-text\">19세</code>, <code class=\"language-text\">512만명</code>에 포함된 숫자도 함께 뽑혀나올 것이므로 우리는 방금과 같이 간단한 방법으로는 이 문제를 해결할 수가 없다.</p>\n<p>하지만 정규식이 강력한 진짜 이유는 이런 난해한 상황 속에서도 원하는 데이터를 뽑아낼 수 있는 패턴만 파악한다면 간단하게 문제를 해결할 수 있다는 점이다. 사실 일반적인 한글 문장 속에서 금액을 의미하는 단어가 불규칙하게 튀어나오는 것 같지만, 자세히 들여다보면 금액을 의미하는 단어는 특정한 패턴을 가지고 출몰한다.</p>\n<p>먼저, 금액을 의미하는 단어는 “철수는 영희에게 <code class=\"language-text\">1,000원</code>을 갚아야한다”, “철수의 이번 달 월급은 <code class=\"language-text\">30원</code>이다”와 같이 반드시 단어 앞에 띄어쓰기가 들어간다. 하지만 이 규칙은 금액 뿐 아니라 다른 숫자 데이터에도 동일하게 적용되는 한글의 문법이라 이것만으로는 이 숫자가 금액을 의미하는 숫자인지 파악하기가 어렵기 때문에 필자는 한 가지 패턴을 더 적용하려고 한다.</p>\n<p>사실 두 번째 패턴도 누구나 다 알 수 있는 패턴인데, 금액을 의미하는 데이터는 반드시 단위를 표현하는 무언가와 함께 출몰한다는 점이다. <code class=\"language-text\">$1,000</code>, <code class=\"language-text\">1,000원</code>, <code class=\"language-text\">₩1,000</code> 처럼 말이다. 위 문장에서의 금액 데이터는 반드시 숫자 뒤에 KRW를 의미하는 “원”이라는 글자 앞 쪽에 출몰하는 것을 알 수 있다.</p>\n<p>이렇게 패턴을 찾아내고 나면 그 다음부터는 정규식을 사용하여 이 패턴을 가진 단어를 찾아내기만 하면 되는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> string <span class=\"token operator\">=</span> <span class=\"token string\">'현재까지 로또 복권의 총 판매금액은 38조40230억2565만7000원. 2014년 기준 회당 평균 580억원 가량의 로또가 팔린다. 조사에 따르면 1인당 평균 구매액은 9400원으로 19세 이상 성인 인구 기준 매주 약 512만 명이 로또를 구입한다.'</span><span class=\"token punctuation\">;</span>\n\nstring<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?&lt;=\\s)\\S*?\\d+(?=원)</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"38조40230억2565만7000\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"9400\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">String.prototype.match</code> 메소드는 문자열 내에서 인자로 주어진 문자열이나 정규식과 매칭되는 부분을 찾아낼 수 있는 메소드이다. 이번에는 앞선 문제와 다르게 문장 내에서 금액을 표현하는 단어가 여러 개 출몰하기 때문에 <code class=\"language-text\">match</code> 메소드를 사용하여 정규식과 매칭된 모든 부분을 찾아낸 것이다.</p>\n<p>위 문제에서 사용했던 <code class=\"language-text\">[^\\d]</code>와 같은 단순한 표현과 다르게 이번에는 조금 더 복잡해보이는 표현을 사용했는데, 사실 이 정규식도 막상 뜯어보면 의미 자체는 크게 복잡하지 않다. <small>(다시 말하지만 정규식은 그냥 가독성이 떨어질 뿐 의미 자체는 어렵지않다)</small></p>\n<p>필자가 사용한 <code class=\"language-text\">(?&lt;=\\s)\\S*?\\d+(?=원)</code>라는 정규식의 의미는 대략 다음과 같다.</p>\n<blockquote>\n<p><code class=\"language-text\">(?&lt;=\\s)</code>: 공백(<code class=\"language-text\">\\s</code>) 뒤에 있고(<code class=\"language-text\">?&lt;=</code>)</p>\n<p><code class=\"language-text\">\\S*?</code>: 공백이 아닌 문자(<code class=\"language-text\">\\S</code>)가 있을 수도 있고 없을 수도 있으며(<code class=\"language-text\">*?</code>)</p>\n<p><code class=\"language-text\">\\d+</code>: 숫자(<code class=\"language-text\">\\d</code>)가 한 개 이상(<code class=\"language-text\">+</code>) 조합되어있고</p>\n<p><code class=\"language-text\">(?=원)</code>: “원”이라는 글자 앞에 있는(<code class=\"language-text\">?=원</code>) 녀석들</p>\n</blockquote>\n<p>이번 예시 문장 속에서 필자가 찾고자 한 패턴은 단순히 하나의 조건으로 이루어진 것이 아니라 여러 개의 조건으로 이루어진 꽤나 복잡한 패턴이기 때문에, <code class=\"language-text\">\\S</code>, <code class=\"language-text\">\\d</code>와 같은 단순한 키워드만 사용한 것이 아니라 정규식에서 제공하는 기능을 충분히 활용해야했다.</p>\n<p>그리고 특정 패턴 앞이나 뒤에 오는 패턴을 잡아내기 위해 위에서 설명했던 Lookahead와 Lookbehind 기능도 활용했으며, <a href=\"/2020/07/24/about-regular-expression/#greedy-vs-lazy\">이전 포스팅에서 설명했던 Greedy</a>도 사용했다.</p>\n<p>이렇듯 정규식은 단지 문자열 속에서 특정한 패턴을 잡아낼 수 있는 도구이기 때문에 이렇게 원하는 데이터를 뽑아내는 것 뿐 아니라, 사용자의 입력을 검증하거나 HTML, 자바스크립트와 같은 코드를 파싱하거나 JPG, OBJ와 같은 파일을 파싱하는 등 다양한 부분에서 활용될 수 있으니 한번 알아두면 여기저기에 써먹을 수 있는 꿀 지식이라고 할 수 있다.</p>\n<h2 id=\"문자열을-내가-원하는-포맷으로-변환하기\" style=\"position:relative;\">문자열을 내가 원하는 포맷으로 변환하기<a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%EB%82%B4%EA%B0%80-%EC%9B%90%ED%95%98%EB%8A%94-%ED%8F%AC%EB%A7%B7%EC%9C%BC%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0\" aria-label=\"문자열을 내가 원하는 포맷으로 변환하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞선 예시에 몇 차례 언급된 바가 있지만 정규식은 문자열을 치환하여 내가 원하는 포맷으로 변경할 때도 꽤나 요긴하게 사용될 수 있다.</p>\n<p>가령 사용자의 중요한 정보를 <code class=\"language-text\">*</code>과 같은 문자로 일부 마스킹 처리를 해준다던가, 사용자가 입력한 전화번호나  카드번호 사이 사이에 <code class=\"language-text\">-</code>를 삽입하여 가독성을 높혀주는 경우처럼 말이다.</p>\n<p>이런 문제를 해결할 때 정규식의 캡쳐링 기능을 사용하면 생각보다 쉽게 풀리는 경우가 많다. 물론 캡쳐링 기능 자체는 굉장히 많은 상황에서 사용될 수 있지만, 특히 원하는 부분만 정확히 잡아내어 내가 원하는 문자로 치환해야하는 상황에서 빛을 발한다.</p>\n<h3 id=\"사용자의-정보-마스킹하기\" style=\"position:relative;\">사용자의 정보 마스킹하기<a href=\"#%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9D%98-%EC%A0%95%EB%B3%B4-%EB%A7%88%EC%8A%A4%ED%82%B9%ED%95%98%EA%B8%B0\" aria-label=\"사용자의 정보 마스킹하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>간혹 서비스를 만들다보면 불특정한 사용자들의 리스트를 보여줘야하는 화면 내에서 각 사용자들의 민감정보를 마스킹해줘야 하는 경우가 왕왕 발생하는데, 이때 이 사용자들이 봇이 아닌 실제 사용자라는 인식을 주기 위해 전체 정보를 마스킹하는 것이 아닌 일부만 마스킹하는 경우가 많다.</p>\n<p>보통 이름같은 경우에는 성, 혹은 이름의 맨 앞 한 글자를 제외한 나머지를 마스킹하거나 전화번호의 경우에는 <code class=\"language-text\">010</code>과 같은 통신사 식별번호와 다음 필드의 한 두 글자를 제외한 나머지를 마스킹하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">mask</span> <span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> headCount <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 문자열 맨 앞의 n 글자를 가져온다</span>\n  <span class=\"token keyword\">const</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">^.{</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>headCount<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">}</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// head를 제외한 나머지를 마스킹한다</span>\n  <span class=\"token keyword\">const</span> tails <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// head와 tails를 합친다</span>\n  <span class=\"token keyword\">return</span> head <span class=\"token operator\">+</span> tails<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'문동욱'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'01012345678'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'문동*'</span>\n<span class=\"token string\">'01012******'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">mask</code> 함수는 마스킹할 글자 수를 인자로 받아서 처리하는 동작을 수행하기 때문에 정규표현식 또한 변수를 사용하여 생성해줘야하며, 이렇게 동적인 값을 사용하여 정규표현식을 생성할 때는 <code class=\"language-text\">/</code>을 사용한 리터럴 표현이 아닌 <code class=\"language-text\">RegExp</code> 객체를 직접 생성하여 표현식을 인자로 넘겨줘야한다.</p>\n<p>하지만 이렇게 단순히 글자 수만 세어서 마스킹 처리를 하게 되면 문제가 발생할 수 있는데, 바로 이런 케이스 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 응 외국인이야~</span>\n<span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'E Van Moon'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 전화번호 구분 필드도 있어~</span>\n<span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'010-1234-5678'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 두 글자를 건너뛰고 마스킹하려 했지만...</span>\n<span class=\"token comment\">// 실제로 보이는 건 한 글자</span>\n<span class=\"token string\">'E ********'</span>\n\n<span class=\"token comment\">// 다섯 글자를 건너뛰고 마스킹하려 했지만...</span>\n<span class=\"token comment\">// 실제로 보이는 건 네 글자</span>\n<span class=\"token string\">'010-1********'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>사실 이런 경우는 그냥 무시하고 넘어가도 UX에 큰 지장은 없지만, <code class=\"language-text\">E V** ****</code>이나 <code class=\"language-text\">***-****-****</code>처럼 특정 문자는 마스킹이 되지 않도록 처리하는 것이 아무래도 완성도도 높고 가독성도 좋아지기 때문에 해둬서 나쁠 건 없다고 생각한다.</p>\n<p>이런 문제를 해결할 때 어려운 부분은 아무래도 맨 앞 글자 중 공백이나 <code class=\"language-text\">-</code>를 제외하고 글자 수를 세야한다는 점인데, 조금만 생각해보면 꽤나 간단하게 이 패턴을 만들어 낼 수 있다. 정규식의 수량자는 각각의 문자가 아니라 내가 정해준 패턴을 카운팅하는 것이기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// (?:)로 그룹핑된 패턴이 2번 나왔음?</span>\n<span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span>\\<span class=\"token constant\">S</span><span class=\"token punctuation\">[</span>\\s<span class=\"token operator\">-</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 표현은 공백이 아닌 문자(<code class=\"language-text\">\\S</code>) 뒤 쪽으로 공백이나 <code class=\"language-text\">-</code>가 있거나 없을 수 있다는 패턴이 2번 나타난 경우를 의미한다. 즉, <code class=\"language-text\">E E-</code>와 같은 문자열이 있는 경우 <code class=\"language-text\">E\\s</code>나 <code class=\"language-text\">E-</code> 패턴을 하나로 묶어서 카운팅한다는 것이다.</p>\n<p>이렇게 복잡한 패턴 전체를 수량자로 카운팅하기 위해서는 해당 패턴을 <code class=\"language-text\">(?:)</code>(Non Capturing Group)이나 <code class=\"language-text\">()</code>(Capturing Group)으로 그룹핑 해줘야 한다는 점도 잊지말자.</p>\n<p>이러한 정규식 수량자의 특성을 이용하면 앞의 n글자를 카운팅하여 마스킹하지 않는 조건과 공백이나 <code class=\"language-text\">-</code>는 이 카운팅에 포함하지 않는다는 조건을 간단하게 만족시킬 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">enhancedMask</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">str<span class=\"token punctuation\">,</span> headCount <span class=\"token operator\">=</span> <span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// \\S[\\s-]* 패턴이 n번 나오는 경우를 모두 묶어서 head로 할당한다</span>\n  <span class=\"token keyword\">const</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">^(?:\\\\S[\\\\s-]*){</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>headCount<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">}</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// head를 제외한 나머지 부분 중 공백과 -를 제외한 부분을 마스킹한다</span>\n  <span class=\"token keyword\">const</span> tails <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^\\s-]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// head와 tails를 합친다</span>\n  <span class=\"token keyword\">return</span> head <span class=\"token operator\">+</span> tails<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'E Van Moon'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'010-1234-5678'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'E V** ****'</span>\n<span class=\"token string\">'010-12**-****'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"ide-내에서-원하는-부분만-replace하기\" style=\"position:relative;\">IDE 내에서 원하는 부분만 Replace하기<a href=\"#ide-%EB%82%B4%EC%97%90%EC%84%9C-%EC%9B%90%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84%EB%A7%8C-replace%ED%95%98%EA%B8%B0\" aria-label=\"ide 내에서 원하는 부분만 replace하기 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>우리가 사용하는 대부분의 IDE나 코드 에디터들은 Find나 Replace 기능에 정규식을 사용할 수 있는 기능을 제공한다. 아무래도 코드라는 것은 특정한 패턴을 가지고 있는 문자열의 집합이다보니 단순한 문자열 검색보다는 정규식이 더 효율적일 수 있기 때문이다.</p>\n<p>정규식을 사용하여 원하는 코드를 찾아내거나 변경하는 예시는 여러가지가 있겠지만, 그 중에서도 필자가 평소에 자주 실수하는 상황을 한번 예시로 가져와봤다.</p>\n<p>자바스크립트의 모듈은 <code class=\"language-text\">default</code> 키워드를 사용하지 않고 상수나 함수 등을 그대로 <code class=\"language-text\">export</code>하는 경우에 모듈 자체를 하나의 객체로 평가하여 반환하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Test</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Test</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Test <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 이 모듈을 사용하는 쪽에서는 일반적으로 위의 예시처럼 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"nofollow\">구조 분해 할당(Destructuring assignment)</a>을 사용하여 원하는 값에 접근하게 되는데, 문제는 이 모듈의 <code class=\"language-text\">export</code> 방식이 중간에 변경되는 경우이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Test</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Test</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// export 구문이 변경됨</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Test<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Test <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Module not found: Error: Cannot resolve 'file' or 'directory'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>바쁘게 작업하다보면 모듈을 불러오는 부분을 크게 생각하지 않고 모듈의 <code class=\"language-text\">export</code> 방식을 바꾸는 실수를 하는데, 이런 경우 모듈의 export 방식을 원래대로 되돌리는 방법도 있지만, 개발자의 원래 의도가 <code class=\"language-text\">export default</code>로 객체 자체를 모듈로 사용하는 것일 경우에는 해당 모듈을 <code class=\"language-text\">import</code>하는 부분을 전부 찾아서 변경해주어야 한다.</p>\n<p>앞서 이야기했듯이 대부분의 IDE나 에디터들은 Find와 Replace 기능에 정규식을 사용할 수 있는 기능을 제공해주고 있기 때문에, 이런 상황에서 정규식을 사용하면 간단하게 원하는 부분을 변경할 수 있다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 528px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cd303e1a62e4fc55b0c2dc0621732980/4af8e/use_regex.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 51.87500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACGElEQVR42mVSa2+bQBDkj0SNHXCwAfOG443BNgY/kjhxIjVqFUVVlR9QqT9/OpxSqVI/jI5bdndmd05Jy0cMzTdoMw/1qkdZdZhMLHy5NnA9MbEwQphWDNfLYC2FhGH40Kwcoj7h7viMZn1CUfawLAGlLi/4PfyCqrkwlxlcv4LtFliYCYtz3uvPOxtZKbxgTYISNzMfptfC9ltYXg3DqaGbKZS2fkGxeoI+j5GVA/rhCcPhGXV7wmb3iG64oN0+wA1WRI1+/46mfcVM9+HFPUynQhj0CMIBtwsqfNz/wPHwDl2PyFCQrYOqCyLEjCQa49o8YoMYllNQYSlX03LMFUmb9oBut8f5ckIQlVBEcoQZbnGrBxBJy2CDNNtAXwSYTC1Mb2xiiQkxVW3Mbj3u25EkdrhjXgo3KZGUBZYkVIr6Gd+7D1mY5luOe0HV7CmfykjyP0KoM5f/YzhRj7mZQZ2PubGMKXl2j5+bD7L6yIotHTugrHuaEElFN5rzD1zGHOn+WGwHW8yNBJorICjmeP8VSpidYImeo/gct6LsHJFo6aiQxSqJVD6pv81Gt12vkHHdiKXi08MrLi9vGPiEFFGcEWd38tmMoyzMmAYEZI5lU30RytOyU57JZ3zMYdyu5C5zTlS1e6lSCcSAQOyhUWFEhaNrFRNyjp9ma3muN0f53e3umFPj6konkZCmjDv0nQ5ZdIbvdvgDLCpH2gIHBEIAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"use regex\" title=\"\" src=\"/static/cd303e1a62e4fc55b0c2dc0621732980/4af8e/use_regex.png\" srcset=\"/static/cd303e1a62e4fc55b0c2dc0621732980/69538/use_regex.png 160w,\n/static/cd303e1a62e4fc55b0c2dc0621732980/72799/use_regex.png 320w,\n/static/cd303e1a62e4fc55b0c2dc0621732980/4af8e/use_regex.png 528w\" sizes=\"(max-width: 528px) 100vw, 528px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>정규식을 사용하면 원하는 부분만 잡아낼 수 있다</small>\n</center>\n<p>하지만 문제는 <code class=\"language-text\">import { Test } from 'components/Test'</code>라는 부분 중에서 <code class=\"language-text\">import</code>나 <code class=\"language-text\">from 'components/Test';</code>처럼 Replace 후에도 유지되어야하는 부분이 있다는 것이다.</p>\n<p>또한 모듈을 가져오는 방식이 바뀐다 뿐이지 모듈을 할당하는 변수명까지 바꿔버리면 일이 더 많아지기 때문에 왠만하면 <code class=\"language-text\">Test</code>라는 변수명 자체는 그대로 두는 것이 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 요것을</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Test <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 요렇게 바꾸고 싶다!</span>\n<span class=\"token keyword\">import</span> Test <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이런 경우에도 정규식의 캡쳐링 기능을 사용하면 정확히 원하는 부분만 캡쳐하여 유지하고 나머지는 변경할 수 있다.</p>\n<p>자바스크립트 코드라고 해도 결국 IDE 입장에서는 단순한 문자열이기 때문에 IDE의 Replace를 사용할 때도 그냥 일반적으로 정규식을 사용하는 경우와 동일하다고 생각하면된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> targetCode <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">import { Component } from 'components/Test';</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\ntargetCode<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\{\\s(Component)\\s\\}</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'$1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">import Component from 'components/Test';</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이렇게 IDE 상에서 정규식을 사용하여 코드 상의 원하는 패턴을 잡아내어 한번에 치환하는 작업은 필자가 예시로 든 저런 상황보다는 라이브러리를 업데이트했는데 브레이킹 체인지가 있다던가 전체적으로 리팩토링을 한다던가 하는 마이그레이션 작업에서 훨씬 빛을 발한다. <small>(사실 그냥 필자가 자주 하는 실수라서 예시로 가져와봤다)</small></p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>정규표현식은 단지 문자열 내에서 원하는 패턴을 매칭하여 가져오는 추상적인 도구이기 때문에 그 활용도가 어마무시한 녀석이다.</p>\n<p>정규식은 필자가 포스팅에 적은 예시들 외에도 파일을 파싱한다던가, 크롤링으로 긁어온 데이터를 정규화한다던가, 로그 파일 내에서 원하는 정보를 빠르게 찾는다던가 하는 많은 상황 속에서 사용될 수 있는데다가 프로그래밍 언어 별로 정규표현식이 그렇게 다르지도 않으므로 한번 익혀두면 두고두고 요긴하게 써먹을 수 있는 도구라고 생각한다.</p>\n<p>이상으로 “정규식은 어떻게 사용되는 것일까?” 포스팅을 마친다.</p>","fields":{"slug":"20200815-regex-example","path":"/2020/08/15/regex-example/","lang":"ko"},"frontmatter":{"title":"정규식은 어떻게 사용되는 것일까?","subTitle":"불규칙한 데이터 속에서 질서를 찾아가는 여정","date":"Sep 15, 2020","categories":["프로그래밍"],"tags":["정규식","정규표현식","Regexp","Regular Expression","숫자만 골라내기","Lookahead","전방탐색","Lookbehind","후방탐색","Lookaround","캡쳐링"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/fc5c5/thumbnail.webp 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}},"allMarkdownRemark":{"edges":[{"node":{"id":"84c50775-bbc4-52ef-ba7f-eed918a9867c","tableOfContents":"<ul>\n<li>\n<p><a href=\"#validating-user-input\">Validating User Input</a></p>\n<ul>\n<li><a href=\"#validating-email-addresses\">Validating Email Addresses</a></li>\n<li><a href=\"#phone-numbers\">Phone Numbers</a></li>\n<li><a href=\"#passwords\">Passwords</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#extracting-specific-information-from-irregular-strings\">Extracting Specific Information from Irregular Strings</a></p>\n<ul>\n<li><a href=\"#extracting-only-numbers-from-a-string\">Extracting Only Numbers from a String</a></li>\n<li><a href=\"#extracting-monetary-values-from-a-sentence\">Extracting Monetary Values from a Sentence</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#reformatting-strings\">Reformatting Strings</a></p>\n<ul>\n<li><a href=\"#masking-user-information\">Masking User Information</a></li>\n<li><a href=\"#find-and-replace-in-your-ide\">Find-and-Replace in Your IDE</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#wrapping-up\">Wrapping Up</a></p>\n</li>\n</ul>","excerpt":"In my previous post, Finding Patterns in Irregularity: A Guide to Regular Expressions, I covered the basics of how regex works. But no matter how well you understand the fundamentals, the moment you actually need to use regex in a real situation, your mind tends to go blank. So in this post, I’d li…","html":"<p>In my previous post, <a href=\"/2020/07/24/about-regular-expression\">Finding Patterns in Irregularity: A Guide to Regular Expressions</a>, I covered the basics of how regex works.</p>\n<p>But no matter how well you understand the fundamentals, the moment you actually need to use regex in a real situation, your mind tends to go blank.</p>\n<p>So in this post, I’d like to walk through several real-world scenarios I’ve encountered at work, with examples and explanations of how I used regex to solve them.</p>\n<p>Regex sees the most action in three situations: “validating user input,” “extracting desired information,” and “reformatting strings.” Let’s define problems in each category and solve them with regex.</p>\n<h2 id=\"validating-user-input\" style=\"position:relative;\">Validating User Input<a href=\"#validating-user-input\" aria-label=\"validating user input permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>The most common place you’ll encounter regex in practice is when validating user input.</p>\n<p>You learn this naturally as you build products, but users absolutely will not use your product the way you designed it. Blindly trusting user-submitted data and shipping it straight to the server is a fairly dangerous thing to do.</p>\n<p>You told them to enter an email address, but they entered a phone number. In the worst case, someone with malicious intent might inject a script or query and send it to the server.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 554px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d3d5049ed982f669de8ee19432f6f22e/04abd/sql_injection.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 48.75000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABd0lEQVR42m1R2U7DMBDMF/MnfAa/0JcKkFpKaaAtSCVNFdLch9PmPp2TSS0QIEYra7zeWe14ueGCvu9xFkVxOBw0TXNdRxAEcEVRJEkC3+/3Xdd9VzJwjLNUnuerFf/0xMvycT5/mM1mkImiuFgslsslpfSvuKkrtIzj2PfPURSnWWiRo02Uokz/lDLOzqZp2rblriePyJxOZ8uyCPFUTVytpwjb0SitdV3Tdd0wDLzihAvTNMHTNE2ShJusNl1dE0JM03BdIsm75+3ty/bOcY2qooYxKqGXZRlKRlAMC6M4i4KyqjAD7nXd5EUKB3ESUFqx8X4CZYxUaEwpN/wGHPVdP8YPt/8CBdzRctADk6iqatuObkrrt/vX3Zx45tAPwReiKArD0Pd9dgUZx766mQ5tjZzneUEQHlWR39w9b+8tW8/zce1ois2LX8DaYR5/hsm513chSzM0cxznfPZ140M48Igg9DAbfhXLz7IsuQAEmeKCsiw/AXYMKq9gkgA4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"sql injection\" title=\"\" src=\"/static/d3d5049ed982f669de8ee19432f6f22e/04abd/sql_injection.png\" srcset=\"/static/d3d5049ed982f669de8ee19432f6f22e/69538/sql_injection.png 160w,\n/static/d3d5049ed982f669de8ee19432f6f22e/72799/sql_injection.png 320w,\n/static/d3d5049ed982f669de8ee19432f6f22e/04abd/sql_injection.png 554w\" sizes=\"(max-width: 554px) 100vw, 554px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Modern backend frameworks and ORMs handle injection attacks automatically,<br>but raw queries are still used for performance reasons — never let your guard down</small>\n</center>\n<p>That’s why client-side developers write validation logic to verify that user input is correct, and regex is incredibly useful in this process.</p>\n<h3 id=\"validating-email-addresses\" style=\"position:relative;\">Validating Email Addresses<a href=\"#validating-email-addresses\" aria-label=\"validating email addresses permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Email is one of the most common data formats you’ll receive from users. And since email addresses have clearly defined fields and limited rules, validating whether a given string is a proper email address isn’t terribly difficult.</p>\n<p>The specifics may vary slightly between MBPs (Mailbox Providers), but according to <a href=\"https://tools.ietf.org/html/rfc2822#section-3.4.1\" target=\"_blank\" rel=\"nofollow\">RFC 2822 § Addr-spec specification</a>, which defines the internet message protocol, an email address can be described as a string with the following pattern:</p>\n<blockquote>\n<ol>\n<li>\n<p>An email address consists of a local part, <code class=\"language-text\">@</code>, and a domain.</p>\n</li>\n<li>\n<p>The local part may contain letters, digits, and special characters such as <code class=\"language-text\">!#$%&amp;'*+-/=?^_{|}~</code>. The <code class=\"language-text\">.</code> character is also allowed, but the local part must not start or end with <code class=\"language-text\">.</code>.</p>\n</li>\n<li>\n<p>The domain consists of a host and domain identifier connected by <code class=\"language-text\">.</code> (e.g., google.com).</p>\n</li>\n<li>\n<p>The local part and domain are connected by <code class=\"language-text\">@</code>.</p>\n</li>\n</ol>\n</blockquote>\n<p>Since email addresses follow a well-defined pattern, we can validate them through simple pattern matching with regex.</p>\n<h4 id=\"the-local-part\" style=\"position:relative;\">The Local Part<a href=\"#the-local-part\" aria-label=\"the local part permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The local part of an email can contain letters and digits, so we can use <code class=\"language-text\">\\w</code> — the word group that matches both letters and digits — to handle this easily. It also allows special characters like <code class=\"language-text\">!#$%&amp;'*+-/=?^_{|}~</code>, so a custom group like <code class=\"language-text\">[\\w!#$%&amp;'*+-/=?^_{|}~]</code> covers all valid characters for the local part.</p>\n<p>This pattern must appear at least once. If it appears zero times, the local part is empty, which isn’t a valid email address. So we append the <code class=\"language-text\">+</code> quantifier at the end, meaning “one or more occurrences.”</p>\n<div class=\"gatsby-highlight\" data-language=\"regex\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-regex line-numbers\"><code class=\"language-regex\"><span class=\"token anchor function\">^</span><span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span><span class=\"token char-set class-name\">\\w</span>!#$%&amp;'*+/=?^_{|}~-<span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">+</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>This is the basic pattern for an email local part. But RFC 2822 has one more finicky rule: ”<code class=\"language-text\">.</code> is allowed, but the local part must not start or end with <code class=\"language-text\">.</code>.”</p>\n<p>Checking that a string doesn’t start or end with <code class=\"language-text\">.</code> is straightforward using the <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code> anchors, but handling <code class=\"language-text\">.</code> appearing in the middle requires a bit more thought.</p>\n<p>The simplest way to express “a character that may or may not appear in the middle” is actually quite intuitive:</p>\n<blockquote>\n<p><code class=\"language-text\">.</code> always appears in the middle of the local part. In other words, <code class=\"language-text\">.</code> must always be followed by the <code class=\"language-text\">[\\w!#$%&amp;'*+-/=?^_{|}~]</code> pattern.</p>\n</blockquote>\n<p>To put it more precisely: the pattern <code class=\"language-text\">.something</code> may or may not appear within the local part, but if it does appear, there must always be other characters after the <code class=\"language-text\">.</code>.</p>\n<p>Expressed as regex on its own:</p>\n<div class=\"gatsby-highlight\" data-language=\"regex\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-regex line-numbers\"><code class=\"language-regex\"><span class=\"token group punctuation\">(?:</span><span class=\"token special-escape escape\">\\.</span><span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span><span class=\"token char-set class-name\">\\w</span>!#$%&amp;'*+/=?^_{|}~-<span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">+</span><span class=\"token group punctuation\">)</span><span class=\"token quantifier number\">*</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Let’s start with the <code class=\"language-text\">(?:</code> and <code class=\"language-text\">)</code> wrapping. This is the same grouping mechanism as the capturing feature I explained in the previous post.</p>\n<p>Capturing groups actually serve double duty — they capture and they group multiple expressions. When you add <code class=\"language-text\">?:</code> at the beginning of a group <code class=\"language-text\">()</code>, you’re saying “I want the grouping but not the capturing.” That’s why it’s called a “Non-Capturing Group.”</p>\n<p>Inside the group, <code class=\"language-text\">\\.</code> means the literal <code class=\"language-text\">.</code> character. Without the escape, the regex engine would interpret <code class=\"language-text\">.</code> as the character class meaning “any character,” so we escape it to match the literal dot.</p>\n<p>After that comes the same <code class=\"language-text\">[\\w!#$%&amp;'*+/=?^_{|}~-]+</code> pattern we used before — meaning at least one character from this set must follow the <code class=\"language-text\">.</code>.</p>\n<p>Finally, since this entire pattern may or may not appear, we append the <code class=\"language-text\">*</code> quantifier (zero or more) after the closing <code class=\"language-text\">)</code>.</p>\n<p>Combining this with the earlier <code class=\"language-text\">[\\w!#$%&amp;'*+/=?^_{|}~-]+</code> pattern gives us a complete regex for valid email local parts:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^[\\w!#$%&amp;'*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_{|}~-]+)*$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Letters + digits</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// Dot in the middle</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91.test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\n<span class=\"token comment\">// Starts or ends with dot</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.bboydart91'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id=\"the-domain\" style=\"position:relative;\">The Domain<a href=\"#the-domain\" aria-label=\"the domain permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Now that we’ve defined a regex pattern for valid email local parts, all that’s left is defining one for valid domains.</p>\n<p>According to RFC 2822, the domain is “a host and domain identifier connected by <code class=\"language-text\">.</code>” — so the matching conditions aren’t particularly demanding.</p>\n<p>But look closely: the spec says the host and domain identifier are connected by <code class=\"language-text\">.</code>, but it doesn’t say <code class=\"language-text\">.</code> appears only once. So we need to handle cases like <code class=\"language-text\">google.com</code> as well as <code class=\"language-text\">google.co.kr</code> where <code class=\"language-text\">.</code> appears multiple times.</p>\n<p>These ambiguous patterns are easily handled with the Non-Capturing Group we just used:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^(?:\\w+\\.)+\\w+$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">(?:\\w+\\.)+</code> expresses that a word group followed by <code class=\"language-text\">.</code> (like <code class=\"language-text\">google.</code>) must appear at least once, and the trailing <code class=\"language-text\">\\w+</code> requires that another word group must follow the final <code class=\"language-text\">.</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Both host and domain identifier present</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google.co.kr'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//true</span>\n\n<span class=\"token comment\">// Missing domain identifier</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n\n<span class=\"token comment\">// Missing host</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.co.kr'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id=\"combining-the-local-part-and-domain-patterns\" style=\"position:relative;\">Combining the Local Part and Domain Patterns<a href=\"#combining-the-local-part-and-domain-patterns\" aria-label=\"combining the local part and domain patterns permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Now that we have regex patterns for both valid local parts and domains, we just need to join them with <code class=\"language-text\">@</code> to satisfy the final condition: “the local part and domain are connected by <code class=\"language-text\">@</code>.”</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Local part pattern: ^[\\w!#$%&amp;'*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_{|}~-]+)*</span>\n<span class=\"token comment\">// Domain pattern: (?:\\w+\\.)+\\w+$</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^[\\w!#$%&amp;'*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_{|}~-]+)*@(?:\\w+\\.)+\\w+$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">regex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart.evan@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart@naver.co.kr'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.bboydart91@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91@gmail'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91.@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"phone-numbers\" style=\"position:relative;\">Phone Numbers<a href=\"#phone-numbers\" aria-label=\"phone numbers permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Phone numbers are another piece of data you frequently receive from users. I touched on this in the previous post, <a href=\"/2020/07/24/about-regular-expression\">Finding Patterns in Irregularity</a>, but I’ll revisit it here for readers who may have missed that one.</p>\n<p>Phone number formats vary by country, but the core idea is universal: digits grouped in a predictable structure separated by delimiters. Let’s use US phone numbers as an example. A standard US phone number has a 3-digit area code, a 3-digit exchange code, and a 4-digit subscriber number:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'212-555-1234'</span>\n<span class=\"token string\">'(212) 555-1234'</span>\n<span class=\"token string\">'2125551234'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Since phone numbers are just digits repeating in fixed-length groups, the regex to match them is straightforward:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\d{3}-?\\d{3}-?\\d{4}$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">regex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2125551234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'212-555-1234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'3015551234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'301-555-1234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The digit counts in each field are clearly defined, so simple quantifiers do the job. The hyphens between fields may or may not be present, so we use the <code class=\"language-text\">?</code> quantifier (zero or one) to handle them.</p>\n<p>The regex itself is straightforward, but there’s a subtle mistake developers sometimes make in practice:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Pattern that only matches numbers starting with a specific area code</span>\n<span class=\"token operator\">/</span><span class=\"token number\">212</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>This pattern only captures phone numbers with the <code class=\"language-text\">212</code> area code. If your validation is too narrow, you’ll reject perfectly valid phone numbers from other regions.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5d22138cdc7f106c76184f763b009060/41099/old_phone.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDBP/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAF4bZikSGP/xAAbEAACAQUAAAAAAAAAAAAAAAAAAQISEyEiMv/aAAgBAQABBQLQqki2xYHy5s//xAAWEQADAAAAAAAAAAAAAAAAAAABECH/2gAIAQMBAT8BMX//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwFH/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEQMUH/2gAIAQEABj8CwfYxT//EABkQAQEBAQEBAAAAAAAAAAAAAAERACExQf/aAAgBAQABPyEATpndAlQ/HQ9evc7BjOi0uQ7/2gAMAwEAAgADAAAAEGPf/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAwEBPxDBMp//xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8QHY//xAAZEAEBAAMBAAAAAAAAAAAAAAABEQAhMUH/2gAIAQEAAT8QYwEaGgeFyCchT3fIcxh2hVybek20lTmWCj0aO+ZWrXP/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"old phone\" title=\"\" src=\"/static/5d22138cdc7f106c76184f763b009060/41099/old_phone.jpg\" srcset=\"/static/5d22138cdc7f106c76184f763b009060/0913d/old_phone.jpg 160w,\n/static/5d22138cdc7f106c76184f763b009060/cb69c/old_phone.jpg 320w,\n/static/5d22138cdc7f106c76184f763b009060/41099/old_phone.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>The 1996 \"Gulliver Phone\" — a nostalgic relic from the early mobile era</small>\n</center>\n<p>The takeaway: when building phone number validation, think about all the formats your users might enter. Consider international prefixes, area codes with varying lengths, and optional delimiters like hyphens, dots, or parentheses. A pattern like <code class=\"language-text\">\\d{3}[-.\\s]?\\d{3}[-.\\s]?\\d{4}</code> handles more cases gracefully.</p>\n<h3 id=\"passwords\" style=\"position:relative;\">Passwords<a href=\"#passwords\" aria-label=\"passwords permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Passwords are directly tied to user authentication and security, making them one of the more demanding fields to validate.</p>\n<p>Off the top of my head, there are roughly three common conditions — these are baseline security requirements observed across most services:</p>\n<blockquote>\n<ul>\n<li>Must contain at least one lowercase letter, one uppercase letter, one digit, and one special character.</li>\n<li>No character may repeat three or more times consecutively.</li>\n<li>Must be at least 8 characters long.</li>\n</ul>\n</blockquote>\n<p>Depending on how detailed you want your error messages to be, you might validate these conditions individually or all at once.</p>\n<p>The first condition requires that the password contains at least one of each character type. Checking them individually is simple with expressions like <code class=\"language-text\">/[a-z]/g</code> or <code class=\"language-text\">/\\d/g</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> password <span class=\"token operator\">=</span> <span class=\"token string\">'test1234!'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Individual checks</span>\n<span class=\"token keyword\">const</span> hasNumberPattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\d</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> hasLowerCasePattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[a-z]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> hasUpperCasePattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[A-Z]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> hasSpecialCharPattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\W</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasNumberPattern<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Password must contain at least one number...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasLowerCasePattern<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Password must contain at least one lowercase letter...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>But the challenge arises when you want to check all conditions at once. A custom group like <code class=\"language-text\">[a-zA-Z\\d]</code> would pass if just one type is present, and a pattern like <code class=\"language-text\">[a-z]+[A-Z]+</code> would enforce a specific order — “lowercase must come before uppercase” — which isn’t what we want.</p>\n<p>This is where we can use a slightly tricky technique.</p>\n<h4 id=\"validating-with-lookaround\" style=\"position:relative;\">Validating with Lookaround<a href=\"#validating-with-lookaround\" aria-label=\"validating with lookaround permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The technique is Positive Lookahead (<code class=\"language-text\">(?=)</code>), which matches a pattern based on what follows it.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Match \"https\" only when followed by \"://\"</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">https(?=:\\/\\/)</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">regex<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// null</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ['https']</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Expressions that match based on what appears before or after a pattern are called “Lookaround,” and they come in four flavors:</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Pattern</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Positive Lookahead</td>\n<td><code class=\"language-text\">abc(?=123)</code></td>\n<td>Match <code class=\"language-text\">abc</code> when followed by <code class=\"language-text\">123</code></td>\n</tr>\n<tr>\n<td>Negative Lookahead</td>\n<td><code class=\"language-text\">abc(?!123)</code></td>\n<td>Match <code class=\"language-text\">abc</code> when NOT followed by <code class=\"language-text\">123</code></td>\n</tr>\n<tr>\n<td>Positive Lookbehind</td>\n<td><code class=\"language-text\">(?&lt;=123)abc</code></td>\n<td>Match <code class=\"language-text\">abc</code> when preceded by <code class=\"language-text\">123</code></td>\n</tr>\n<tr>\n<td>Negative Lookbehind</td>\n<td><code class=\"language-text\">(?&lt;!123)abc</code></td>\n<td>Match <code class=\"language-text\">abc</code> when NOT preceded by <code class=\"language-text\">123</code></td>\n</tr>\n</tbody>\n</table>\n<p>True to the name “look around,” these expressions check whether a specific pattern exists before or after the target. But by understanding how the regex engine processes them, we can repurpose them to check whether a certain pattern appears at least once anywhere in a string.</p>\n<p>Lookaround expressions don’t actually consume characters — they act as boundaries, similar to the <a href=\"/2020/07/24/about-regular-expression/#anchors-that-match-boundaries-not-characters\">\\b anchor</a>. The crucial characteristic is that even when the regex engine successfully matches a character via Lookaround, it then acts as if that match never happened.</p>\n<p>Let me illustrate with a detailed example. If we apply the expression <code class=\"language-text\">q(?=u)i</code> to the string <code class=\"language-text\">quit</code>, the regex engine works like this:</p>\n<blockquote>\n<ol>\n<li>Engine tries to match <code class=\"language-text\">q</code> in the string. The literal <code class=\"language-text\">q</code> in the regex matches — success.</li>\n<li>Engine tries to match <code class=\"language-text\">u</code> in the string. The <code class=\"language-text\">u</code> inside <code class=\"language-text\">(?=u)</code> matches — success. Then the engine “forgets” that this Lookaround match ever happened.</li>\n<li>Engine now tries to match the pattern <em>after</em> the Lookaround against <code class=\"language-text\">u</code> again.</li>\n<li>But the next expression is <code class=\"language-text\">i</code>. It doesn’t match <code class=\"language-text\">u</code> — failure.</li>\n</ol>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">q(?=u)i</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'quit'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">null</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>This makes sense when you think about it: <code class=\"language-text\">(?=u)</code> is merely a condition for what should follow <code class=\"language-text\">q</code> — it’s not actually trying to capture <code class=\"language-text\">u</code>. That’s why the regex engine tries to match <code class=\"language-text\">u</code> again with the next expression after the Lookaround.</p>\n<p>If we change the literal after <code class=\"language-text\">(?=u)</code> from <code class=\"language-text\">i</code> to <code class=\"language-text\">u</code>, condition 4 passes and we get a match:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">q(?=u)u</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'quit'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"qu\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The key insight is that the regex engine treats a Lookaround match as a “preliminary” match rather than a “real” one, so it re-attempts matching the same character with whatever expression comes after the Lookaround.</p>\n<p>By exploiting this behavior, we can effectively use Lookaround as an <code class=\"language-text\">if</code> statement. Let’s use this technique to check one of our password conditions:</p>\n<blockquote>\n<p>Must contain at least one lowercase letter, one uppercase letter, one digit, and one special character.</p>\n</blockquote>\n<p>Checking all at once would make the expression long, so let’s start with just one condition: does the password contain at least one digit?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=\\d).</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abc123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The regex matched <code class=\"language-text\">1</code> because <code class=\"language-text\">(?=\\d)</code> successfully matched <code class=\"language-text\">1</code>, and then the engine re-attempted the match on the same character using <code class=\"language-text\">.</code> — which succeeded.</p>\n<p>In pseudocode, it works like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=\\d)</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=\\d)</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Pattern matched, discard it</span>\n  <span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Re-attempt with the next pattern on the same character</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In other words, the fact that the engine reached the <code class=\"language-text\">.</code> literal means the preceding <code class=\"language-text\">(?=\\d)</code> already matched that character successfully.</p>\n<p>Now that we’ve handled digits, we just chain the remaining conditions — lowercase, uppercase, and special characters — in the same way:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// \\d = digit</span>\n<span class=\"token comment\">// [a-z] = lowercase letter</span>\n<span class=\"token comment\">// [A-Z] = uppercase letter</span>\n<span class=\"token comment\">// [\\W] = non-word character (not a letter or digit)</span>\n<span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\\d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">[</span>a<span class=\"token operator\">-</span>z<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token operator\">-</span><span class=\"token constant\">Z</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">[</span>\\<span class=\"token constant\">W</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>g</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The <code class=\"language-text\">\\W</code> character class technically matches any non-word character, which includes not just special characters but also characters like CJK or Cyrillic. Listing every special character individually would be tedious, so I’m using the shorthand here. <del>(Laziness is a virtue.)</del> <small>(In production, you’d want to explicitly list the allowed special characters like <code class=\"language-text\">!@#$%^...</code>.)</small></p>\n<p>Using the same approach, we can add the remaining conditions — “no character repeats 3+ times consecutively” and “at least 8 characters” — into a single expression:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\\W])(?!.*(.)\\1{2}).{8,}</span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">(?=.*\\d)</code></td>\n<td>Contains at least one <code class=\"language-text\">\\d</code> (digit)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?=.*[a-z])</code></td>\n<td>Contains at least one <code class=\"language-text\">[a-z]</code> (lowercase)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?=.*[A-Z])</code></td>\n<td>Contains at least one <code class=\"language-text\">[A-Z]</code> (uppercase)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?=.*[\\W])</code></td>\n<td>Contains at least one <code class=\"language-text\">[\\W]</code> (special character)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?!.*(.)\\1{2})</code></td>\n<td>No character repeats 3+ times consecutively</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">.{8,}</code></td>\n<td>At least 8 characters that pass all above conditions</td>\n</tr>\n</tbody>\n</table>\n<p>This expression only reaches the final <code class=\"language-text\">.{8,}</code> after all the Positive and Negative Lookahead conditions pass, so any string that matches has satisfied every condition we defined.</p>\n<p>Of course, validating passwords with a single regex like this means you can only show a generic “Invalid password” error message, so in practice it’s more common to check conditions individually. But Lookaround-based conditional checking is such a useful technique that I thought it was worth explaining in detail.</p>\n<h2 id=\"extracting-specific-information-from-irregular-strings\" style=\"position:relative;\">Extracting Specific Information from Irregular Strings<a href=\"#extracting-specific-information-from-irregular-strings\" aria-label=\"extracting specific information from irregular strings permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Most of the time, regex is used for validating user input. But the true raison d’être of regex isn’t merely validation — it’s finding and extracting specific patterns from within irregular data.</p>\n<p>This time, I want to share some real-world scenarios I’ve encountered, along with how I used regex to solve them.</p>\n<h3 id=\"extracting-only-numbers-from-a-string\" style=\"position:relative;\">Extracting Only Numbers from a String<a href=\"#extracting-only-numbers-from-a-string\" aria-label=\"extracting only numbers from a string permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Extracting just the numbers from a given string is a surprisingly common problem in practice. I’ve frequently needed to pull out numbers representing amounts or ages from source data I couldn’t modify directly, in order to normalize the data or display it in a different format.</p>\n<p>For example, imagine an API that returns price information not as a numeric <code class=\"language-text\">1000</code> but as a formatted string like <code class=\"language-text\">$1,000</code>. And your client needs this business logic:</p>\n<blockquote>\n<p>Which is the larger amount: ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>000</mn><mi mathvariant=\"normal\">\"</mi><mi>o</mi><mi>r</mi><mi mathvariant=\"normal\">\"</mi></mrow><annotation encoding=\"application/x-tex\">1,000\" or \"</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">000\"</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord\">\"</span></span></span></span></span>2,000”?</p>\n</blockquote>\n<p>Ideally, the raw data would come as a numeric <code class=\"language-text\">1000</code> and the display formatting would happen on the client side. But modifying the API might require auditing everywhere it’s used and updating every client that consumes it — so sometimes you just leave it as-is for risk management.</p>\n<p>In this situation, the developer needs to strip everything except the digits from <code class=\"language-text\">$1,000</code>, convert it to <code class=\"language-text\">1000</code>, and then compare the two amounts.</p>\n<p>Without regex, you’d have to split the string, iterate through the resulting array checking whether each character is a digit, or call <code class=\"language-text\">String.prototype.replace</code> multiple times:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">NUMBERS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'3'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'4'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'5'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'6'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'7'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'8'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'9'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'$1,000'</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> <span class=\"token constant\">NUMBERS</span><span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Or</span>\n\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'$1,000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'$'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">1000</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The <code class=\"language-text\">String.prototype.replace</code> approach looks simple enough, but its limitation is that if any unexpected characters sneak in, you need to add another <code class=\"language-text\">replace</code> for each one. <small>(The moment a string like <code class=\"language-text\">$1,000...maybe?</code> shows up, you’re in trouble.)</small></p>\n<p>With regex, you can solve the same problem far more concisely and flexibly:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'$1,000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^0-9]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Or</span>\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'$1,000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^\\d]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Or</span>\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'$1,000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\D</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">1000</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>JavaScript’s <code class=\"language-text\">String.prototype.replace</code> method searches for a pattern and replaces it with the second argument. Since <code class=\"language-text\">replace</code> supports regex, we can catch “everything that isn’t a digit” and replace it with an empty string — effectively solving our “extract only numbers” problem.</p>\n<p>The expressions <code class=\"language-text\">[^0-9]</code>, <code class=\"language-text\">[^\\d]</code>, and <code class=\"language-text\">\\D</code> all mean “characters that are not digits,” letting us strip everything non-numeric in one shot.</p>\n<p>Of course, you can solve this without regex by combining <code class=\"language-text\">split</code>, <code class=\"language-text\">filter</code>, <code class=\"language-text\">join</code>, and <code class=\"language-text\">replace</code>. But in the real world, problems far more complex than “find the numbers in a string” are the norm.</p>\n<p>Let’s look at a slightly harder problem.</p>\n<h3 id=\"extracting-monetary-values-from-a-sentence\" style=\"position:relative;\">Extracting Monetary Values from a Sentence<a href=\"#extracting-monetary-values-from-a-sentence\" aria-label=\"extracting monetary values from a sentence permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>This time, we’ll tackle a problem in the same vein but more complex. Instead of extracting digits from a clearly monetary string like <code class=\"language-text\">$1,000</code>, we need to find and extract monetary values from a long natural-language sentence.</p>\n<p>Here’s an example paragraph — drawn from my wishful thinking about getting rich:</p>\n<blockquote>\n<p>The global luxury goods market reached approximately <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>362</mn><mi>b</mi><mi>i</mi><mi>l</mi><mi>l</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>i</mi><mi>n</mi><mn>2023.</mn><mi>T</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>u</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">362 billion in 2023. The average consumer spent around </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">362</span><span class=\"mord mathnormal\">bi</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">nin</span><span class=\"mord\">2023.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">eco</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">ers</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span></span></span></span></span>1,200 per year on luxury items. According to a recent survey, roughly 45% of millennials purchased at least one luxury item, with an average transaction value of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>890</mn><mi>p</mi><mi>e</mi><mi>r</mi><mi>p</mi><mi>u</mi><mi>r</mi><mi>c</mi><mi>h</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi mathvariant=\"normal\">.</mi><mi>T</mi><mi>h</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>i</mi><mi>s</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>t</mi><mi>o</mi><mi>g</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>t</mi><mi>o</mi></mrow><annotation encoding=\"application/x-tex\">890 per purchase. The market is projected to grow to </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">890</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">rc</span><span class=\"mord mathnormal\">ha</span><span class=\"mord mathnormal\">se</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">wt</span><span class=\"mord mathnormal\">o</span></span></span></span></span>500 billion by 2030.</p>\n</blockquote>\n<p>If we need to extract only the monetary data from this long sentence, we can break the problem into two smaller problems:</p>\n<blockquote>\n<ol>\n<li>From all the numbers in the text, pick out only the ones that represent monetary values.</li>\n<li>Convert values like <code class=\"language-text\">$362 billion</code> into a numeric <code class=\"language-text\">362000000000</code>.</li>\n</ol>\n</blockquote>\n<p>The second problem is a bit much for regex alone, so let’s focus on the first: “pick out only the monetary values from all the numbers.”</p>\n<p>If we just used <code class=\"language-text\">\\d</code> or <code class=\"language-text\">[0-9]</code>, we’d also catch numbers from <code class=\"language-text\">2023</code>, <code class=\"language-text\">45%</code>, and <code class=\"language-text\">2030</code> — which aren’t monetary values. So a simple approach won’t cut it.</p>\n<p>But the real power of regex shines in situations like this. Even though monetary values seem to appear irregularly in natural language, they actually follow a specific pattern. In English, monetary values are preceded by a currency symbol like <code class=\"language-text\">$</code>:</p>\n<p>Using this observation, we can write a regex to find dollar amounts:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> string <span class=\"token operator\">=</span> <span class=\"token string\">'The global luxury goods market reached approximately $362 billion in 2023. The average consumer spent around $1,200 per year on luxury items. According to a recent survey, roughly 45% of millennials purchased at least one luxury item, with an average transaction value of $890 per purchase. The market is projected to grow to $500 billion by 2030.'</span><span class=\"token punctuation\">;</span>\n\nstring<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\$[\\d,]+(?:\\s(?:billion|million|thousand))?</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"$362 billion\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"$1,200\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"$890\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"$500 billion\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">String.prototype.match</code> finds all substrings that match the given regex. Since monetary values appear multiple times in the sentence, <code class=\"language-text\">match</code> returns all of them.</p>\n<p>The regex <code class=\"language-text\">\\$[\\d,]+(?:\\s(?:billion|million|thousand))?</code> breaks down as:</p>\n<blockquote>\n<p><code class=\"language-text\">\\$</code>: A literal <code class=\"language-text\">$</code> sign (escaped because <code class=\"language-text\">$</code> is a special regex character)</p>\n<p><code class=\"language-text\">[\\d,]+</code>: One or more digits or commas</p>\n<p><code class=\"language-text\">(?:\\s(?:billion|million|thousand))?</code>: Optionally followed by a space and a magnitude word</p>\n</blockquote>\n<p>In the previous post, I covered simple expressions like <code class=\"language-text\">[^\\d]</code>. This time the regex is more complex because we’re dealing with a multi-condition pattern — but the underlying principle is the same. We’re combining character classes, quantifiers, and non-capturing groups to precisely describe the pattern we’re looking for.</p>\n<p>Regex is just a tool for finding patterns in strings. Beyond extracting data like this, it can validate user input, parse HTML or JavaScript code, parse file formats — it’s useful virtually everywhere, making it a skill that pays dividends for a long time.</p>\n<h2 id=\"reformatting-strings\" style=\"position:relative;\">Reformatting Strings<a href=\"#reformatting-strings\" aria-label=\"reformatting strings permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>As hinted at in earlier examples, regex is also incredibly useful when you need to transform strings into a specific format.</p>\n<p>Think: masking sensitive user information with <code class=\"language-text\">*</code> characters, or inserting <code class=\"language-text\">-</code> between digits in a phone or credit card number for readability.</p>\n<p>Regex’s capturing feature is particularly effective here. Capturing is useful in many situations, but it truly shines when you need to grab specific parts of a string and replace the rest.</p>\n<h3 id=\"masking-user-information\" style=\"position:relative;\">Masking User Information<a href=\"#masking-user-information\" aria-label=\"masking user information permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>When building services, you sometimes need to display a list of users while masking their sensitive information. To signal that these are real people (not bots), you typically mask only part of the data rather than all of it.</p>\n<p>For names, you might show the first character and mask the rest. For phone numbers, you might reveal the area code and first couple of digits while masking everything else.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">mask</span> <span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> headCount <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Get the first n characters of the string</span>\n  <span class=\"token keyword\">const</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">^.{</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>headCount<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">}</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Mask everything except head</span>\n  <span class=\"token keyword\">const</span> tails <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Combine head and tails</span>\n  <span class=\"token keyword\">return</span> head <span class=\"token operator\">+</span> tails<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Evan Moon'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'01012345678'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'Ev** ****'</span>\n<span class=\"token string\">'01012******'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>The <code class=\"language-text\">mask</code> function takes the number of characters to leave unmasked as an argument, so we need to construct the regex dynamically using a <code class=\"language-text\">RegExp</code> object rather than the <code class=\"language-text\">/</code> literal syntax.</p>\n<p>But simple character counting can cause problems in cases like these:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Spaces count toward the character limit</span>\n<span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'E Van Moon'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Hyphens count too</span>\n<span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'010-1234-5678'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Intended to skip 2 characters, but only 1 is visible</span>\n<span class=\"token string\">'E ********'</span>\n\n<span class=\"token comment\">// Intended to skip 5 characters, but only 4 are visible</span>\n<span class=\"token string\">'010-1********'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This technically works, but <code class=\"language-text\">E V** ****</code> or <code class=\"language-text\">010-12**-****</code> looks much cleaner — excluding spaces and hyphens from the character count improves both completeness and readability.</p>\n<p>The tricky part is counting characters while skipping spaces and <code class=\"language-text\">-</code>. But regex quantifiers count <em>patterns</em>, not individual characters:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Did the (?:) grouped pattern appear 2 times?</span>\n<span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span>\\<span class=\"token constant\">S</span><span class=\"token punctuation\">[</span>\\s<span class=\"token operator\">-</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>This expression means: a non-space character (<code class=\"language-text\">\\S</code>) optionally followed by spaces or <code class=\"language-text\">-</code>, repeated 2 times. For a string like <code class=\"language-text\">E E-</code>, it groups <code class=\"language-text\">E\\s</code> or <code class=\"language-text\">E-</code> as a single unit for counting.</p>\n<p>Remember: to apply a quantifier to a complex pattern, you need to wrap it in <code class=\"language-text\">(?:)</code> (Non-Capturing Group) or <code class=\"language-text\">()</code> (Capturing Group).</p>\n<p>Using this property of regex quantifiers, we can easily satisfy both conditions — skip the first n visible characters and exclude spaces/hyphens from the count:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">enhancedMask</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">str<span class=\"token punctuation\">,</span> headCount <span class=\"token operator\">=</span> <span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Group \\S[\\s-]* patterns n times and assign to head</span>\n  <span class=\"token keyword\">const</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">^(?:\\\\S[\\\\s-]*){</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>headCount<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">}</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Mask everything in the tail except spaces and hyphens</span>\n  <span class=\"token keyword\">const</span> tails <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^\\s-]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Combine head and tails</span>\n  <span class=\"token keyword\">return</span> head <span class=\"token operator\">+</span> tails<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">enhancedMask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'E Van Moon'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">enhancedMask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'010-1234-5678'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'E V** ****'</span>\n<span class=\"token string\">'010-12**-****'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"find-and-replace-in-your-ide\" style=\"position:relative;\">Find-and-Replace in Your IDE<a href=\"#find-and-replace-in-your-ide\" aria-label=\"find and replace in your ide permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Most IDEs and code editors support regex in their Find and Replace features. Since code is essentially a collection of strings with specific patterns, regex can be far more effective than plain text search.</p>\n<p>There are many examples of using regex to find and modify code, but let me share a scenario I personally stumble into frequently.</p>\n<p>In JavaScript modules, when you export a constant or function without the <code class=\"language-text\">default</code> keyword, the module evaluates as an object:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Test</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Test</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Test <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>You typically use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"nofollow\">destructuring assignment</a> to access the value you want. The problem arises when the export style changes mid-development:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Test</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Test</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Export style changed</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Test<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Test <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Module not found: Error: Cannot resolve 'file' or 'directory'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>When you’re working fast, it’s easy to change a module’s export style without thinking about all the places that import it. In such cases, you might revert the export, but if the developer intentionally switched to <code class=\"language-text\">export default</code>, you need to find and update every import statement.</p>\n<p>Since most IDEs support regex in Find and Replace, we can handle this quickly:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 528px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cd303e1a62e4fc55b0c2dc0621732980/4af8e/use_regex.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 51.87500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACGElEQVR42mVSa2+bQBDkj0SNHXCwAfOG443BNgY/kjhxIjVqFUVVlR9QqT9/OpxSqVI/jI5bdndmd05Jy0cMzTdoMw/1qkdZdZhMLHy5NnA9MbEwQphWDNfLYC2FhGH40Kwcoj7h7viMZn1CUfawLAGlLi/4PfyCqrkwlxlcv4LtFliYCYtz3uvPOxtZKbxgTYISNzMfptfC9ltYXg3DqaGbKZS2fkGxeoI+j5GVA/rhCcPhGXV7wmb3iG64oN0+wA1WRI1+/46mfcVM9+HFPUynQhj0CMIBtwsqfNz/wPHwDl2PyFCQrYOqCyLEjCQa49o8YoMYllNQYSlX03LMFUmb9oBut8f5ckIQlVBEcoQZbnGrBxBJy2CDNNtAXwSYTC1Mb2xiiQkxVW3Mbj3u25EkdrhjXgo3KZGUBZYkVIr6Gd+7D1mY5luOe0HV7CmfykjyP0KoM5f/YzhRj7mZQZ2PubGMKXl2j5+bD7L6yIotHTugrHuaEElFN5rzD1zGHOn+WGwHW8yNBJorICjmeP8VSpidYImeo/gct6LsHJFo6aiQxSqJVD6pv81Gt12vkHHdiKXi08MrLi9vGPiEFFGcEWd38tmMoyzMmAYEZI5lU30RytOyU57JZ3zMYdyu5C5zTlS1e6lSCcSAQOyhUWFEhaNrFRNyjp9ma3muN0f53e3umFPj6konkZCmjDv0nQ5ZdIbvdvgDLCpH2gIHBEIAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"use regex\" title=\"\" src=\"/static/cd303e1a62e4fc55b0c2dc0621732980/4af8e/use_regex.png\" srcset=\"/static/cd303e1a62e4fc55b0c2dc0621732980/69538/use_regex.png 160w,\n/static/cd303e1a62e4fc55b0c2dc0621732980/72799/use_regex.png 320w,\n/static/cd303e1a62e4fc55b0c2dc0621732980/4af8e/use_regex.png 528w\" sizes=\"(max-width: 528px) 100vw, 528px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Regex lets you target exactly the parts you need</small>\n</center>\n<p>The challenge is that in <code class=\"language-text\">import { Test } from 'components/Test'</code>, parts like <code class=\"language-text\">import</code> and <code class=\"language-text\">from 'components/Test'</code> need to stay unchanged. And since we’re only changing the import style, not renaming the variable, we want to keep <code class=\"language-text\">Test</code> as-is.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Change this</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Test <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Into this</span>\n<span class=\"token keyword\">import</span> Test <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Regex capturing makes this precise transformation possible — capture exactly the parts you want to keep and replace the rest:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> targetCode <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">import { Component } from 'components/Test';</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\ntargetCode<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\{\\s(Component)\\s\\}</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'$1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">import Component from 'components/Test';</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Using regex for find-and-replace in your IDE really shines during migration work — library upgrades with breaking changes, large-scale refactors, and the like. <del>(In truth, I just make this mistake often enough that it made a good example.)</del></p>\n<h2 id=\"wrapping-up\" style=\"position:relative;\">Wrapping Up<a href=\"#wrapping-up\" aria-label=\"wrapping up permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Regular expressions are an abstract tool for matching patterns in strings, which gives them an enormous range of applications.</p>\n<p>Beyond the examples in this post, regex can be used to parse files, normalize scraped data, quickly search log files, and much more. Plus, regex syntax barely differs between programming languages, so once you learn it, you’ll keep reaching for it across your entire career.</p>\n<p>That’s all for this post on how regex is actually used.</p>","fields":{"slug":"20200815-regex-example-en","path":"/2020/08/15/regex-example/en/","lang":"en"},"frontmatter":{"title":"How Do You Actually Use Regex?","subTitle":"A journey of finding order in irregular data","date":"Sep 15, 2020","categories":["Programming"],"tags":["Regex","Regular Expression","Extracting Numbers","Lookahead","Lookbehind","Lookaround","Capturing Group"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/fc5c5/thumbnail.webp 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"slug":"20200815-regex-example","previous":{"fields":{"slug":"20200724-about-regular-expression","path":"/2020/07/24/about-regular-expression/","lang":"ko","postGroup":"20200724-about-regular-expression"},"frontmatter":{"title":"불규칙 속에서 규칙을 찾아내는 정규 표현식"}},"next":{"fields":{"slug":"20200927-work-life-balance","path":"/2020/09/27/work-life-balance/","lang":"ko","postGroup":"20200927-work-life-balance"},"frontmatter":{"title":"정말 근무 시간만이 워라밸의 전부일까?"}},"lang":"ko","postGroup":"20200815-regex-example"}},"staticQueryHashes":["3129619726","3523904809","376081736","650499039"],"slicesMap":{}}