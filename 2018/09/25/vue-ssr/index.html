<!DOCTYPE html>
<html lang="ko">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>Vue Server Side Rendering - Evan&#39;s Tech Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta name="description" content="이번 포스팅에서는 Universal Server Side Rendering에 이어서 VueJS의 공식 라이브러리인 vue-server-renderer와 Express를 사용하여 SSR(Server Side Rendering) 어플리케이션을 개발한 과정과 운영 환경에서 생겼던 문제, 그리고 그 문제를 어떻게 해결했는지 적어보려고 한다.">
<meta name="keywords" content="Web,SSR,Server Side Rendering,서버사이드 렌더링,NodeJS,Vue,Express">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue Server Side Rendering">
<meta property="og:url" content="https://evan-moon.github.io/2018/09/25/vue-ssr/index.html">
<meta property="og:site_name" content="Evan&#39;s Tech Blog">
<meta property="og:description" content="이번 포스팅에서는 Universal Server Side Rendering에 이어서 VueJS의 공식 라이브러리인 vue-server-renderer와 Express를 사용하여 SSR(Server Side Rendering) 어플리케이션을 개발한 과정과 운영 환경에서 생겼던 문제, 그리고 그 문제를 어떻게 해결했는지 적어보려고 한다.">
<meta property="og:locale" content="ko">
<meta property="og:image" content="https://evan-moon.github.io/2018/09/25/vue-ssr/vue.jpeg">
<meta property="og:updated_time" content="2020-02-28T09:06:22.069Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue Server Side Rendering">
<meta name="twitter:description" content="이번 포스팅에서는 Universal Server Side Rendering에 이어서 VueJS의 공식 라이브러리인 vue-server-renderer와 Express를 사용하여 SSR(Server Side Rendering) 어플리케이션을 개발한 과정과 운영 환경에서 생겼던 문제, 그리고 그 문제를 어떻게 해결했는지 적어보려고 한다.">
<meta name="twitter:image" content="https://evan-moon.github.io/2018/09/25/vue-ssr/vue.jpeg">




    <meta name="naver-site-verification" content="48beb5f578053c0c5f127b4198a57270bad360ca">


<link rel="canonical" href="https://evan-moon.github.io/2018/09/25/vue-ssr/">


<link rel="alternative" href="/feed.xml" title="Vue Server Side Rendering" type="application/xml">



<link rel="icon" href="/img/favicon.ico">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    

    
    
    
    

    
    
    


<link rel="stylesheet" href="/css/style.css">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-132075145-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-132075145-1');
</script>



<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
    (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: 'ca-pub-4372275195526937',
        enable_page_level_ads: true
    });
</script>

</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/" data-link-name="navigatorLogo">
            
                <img src="/img/logo-text.png" alt="Vue Server Side Rendering" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a data-link-name="navigator" class="navbar-item" href="/">Home</a>
                
                <a data-link-name="navigator" class="navbar-item" href="/archives">Archives</a>
                
                <a data-link-name="navigator" class="navbar-item" href="/categories">Categories</a>
                
                <a data-link-name="navigator" class="navbar-item" href="/tags">Tags</a>
                
                <a data-link-name="navigator" class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/evan-moon" rel="external nofollow noopener noreferrer">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="검색" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-8-widescreen has-order-2 column-main">
<!-- 아티클 위 광고 -->
<ins class="adsbygoogle" style="display:block;" data-ad-client="ca-pub-4372275195526937" data-ad-slot="6101119789" data-ad-format="auto" data-full-width-responsive="true"></ins>
<script class="card">
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>


<div class="card">
    
    <div class="card-image">
        <span class="image is-7by1">
            <img class="thumbnail" src="/2018/09/25/vue-ssr/vue.jpeg" alt="Vue Server Side Rendering">
        </span>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2018-09-25T14:02:33.000Z">2018-09-25</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/programming/javascript/">JavaScript</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-bold">
            
                Vue Server Side Rendering
            
        </h1>
        
        <hr>
        
        <div class="content">
            <html><head><meta name="generator" content="Hexo 3.9.0"></head><body><p>이번 포스팅에서는 <a href="/2018/09/25/universal-ssr/" title="Universal Server Side Rendering">Universal Server Side Rendering</a>에 이어서 VueJS의 공식 라이브러리인 <code>vue-server-renderer</code>와 <code>Express</code>를 사용하여 <code>SSR(Server Side Rendering)</code> 어플리케이션을 개발한 과정과 운영 환경에서 생겼던 문제, 그리고 그 문제를 어떻게 해결했는지 적어보려고 한다.<br><a id="more"></a></p>
<p>필자는 Frontend 개발자로 일하면서 Backend 프레임워크를 건드릴 일이 사실 거의 없었다. 그러나 필자의 현 직장에 SSR 서버를 필자가 도입하자고 주장하였고, 따라서 오너쉽도 필자에게 있었기 때문에 클라이언트 환경과 전혀 다른 서버의 작동방식과 여러 문제점에 대해서 상세하게 알고 있어야 할 필요가 있었다.<br>보통 Frontend 개발자는 클라이언트에서 작동하는 어플리케이션을 개발하기 때문에 서버에서 작동하는 어플리케이션에서 발생할 수 있는 <small>(조금만 생각해보면 당연한)</small>문제에 대해서 의외로 쉽게 놓치고 지나갈 수 있다고 생각한다.<br>그래서 두번 다시 이런 실수를 반복하지 않도록 문서로 정리를 하고 회고하려고 한다.</p>
<p>먼저 Vue SSR의 렌더링 과정을 전체적으로 살펴본 후, 서버단 렌더링과 클라이언트단 렌더링을 나눠서 다시 살펴본다.</p>
<blockquote>
<p>이 포스팅에 예제로 나와있는 코드는 현 직장의 비즈니스 로직 때문에 생략된 부분이 있기 때문에 코드를 복사붙혀넣기해도 작동하지않을 수 있습니다.</p>
</blockquote>
<h2 id="Vue-Server-Side-Rendering의-구조"><a href="#Vue-Server-Side-Rendering의-구조" class="headerlink" title="Vue Server Side Rendering의 구조"></a>Vue Server Side Rendering의 구조</h2><p>필자는 <code>Nuxt.js</code>를 사용하지 않고 보일러플레이트를 사용해서 약간 개선해서 구현했다. 처음에는 ‘그냥 Nuxt쓸걸…’이라고 후회하기도 했지만 그래도 덕분에 Universal SSR의 실행 과정을 더 깊게 알아볼 수 있는 좋은 기회였다고 생각한다.<small><del>(라고 삽질을 포장해본다)</del></small><br>해당 포스팅에서는 필자가 작성했던 SSR 어플리케이션의 초기화 과정에 대해서 함수단위까지 자세하게 기재하려고 한다. 먼저 어플리케이션의 렌더링 과정은 다음과 같다. 이후 각 과정에 대한 자세한 설명을 후술하도록 하겠다.</p>
<hr>
<ol>
<li>클라이언트가 서버에 리소스 <code>요청</code></li>
<li>nginx가 Express가 띄워져있는 포트로 요청을 서빙</li>
<li>Express 라우팅 시작</li>
<li><code>server-entry.js</code> 실행</li>
<li>서버의 <code>vue-router</code> 라우팅 진행</li>
<li>vue-server-renderer를 사용하여 HTML 렌더링</li>
<li>서버가 클라이언트로 <code>응답</code></li>
<li><code>client-entry.js</code> 실행</li>
<li>클라이언트 어플리케이션 초기화 함수 실행</li>
<li>클라이언트의 <code>vue-router</code> 라우팅 진행</li>
<li>app.$mount</li>
</ol>
<hr>
<p>1번 <code>요청</code>과 7번 <code>응답</code>을 제외한 <code>2~6</code>번 까지는 서버에서 일어나는 과정이고 <code>8~10</code>번 까지는 클라이언트에서 일어나는 과정이다. 특이한 점은 서버와 클라이언트의 엔트리 포인트가 다르다는 것이다. 그리고 후술하겠지만 이 엔트리 포인트들은 몇가지 같은 함수를 공유하며 사용한다. <code>router.onReady</code>나 <code>createApp</code>같은 함수들이 그렇다. 애초에 Universal SSR은 기본적으로 <code>첫 요청만 서버 사이드 렌더링하고 이후는 SPA처럼 작동하게 하자. 그리고 코드는 서버랑 클라이언트에서 재사용가능하게 하자!</code>라는 개념이다. 그래서 편한 면도 있지만 실행 타이밍이나 환경이 같은 함수라도 완전 달라질 수 있기 때문에 별도의 예외처리를 해줘야 하는 등 헷갈리는 부분도 많았다.<br>그리고 이 두개의 엔트리포인트가 서버와 클라이언트에서 실행될 때 서로 다른 초기화과정을 거치는데, 서버에서 초기화를 하고 클라이언트에서 싹 다 처음부터 다시 초기화를 진행하게 되면 비효율적이므로 몇가지 방법을 사용하여 최대한 효율적으로 렌더를 수행한다.</p>
<p>먼저 서버사이드렌더링부터 살펴보자.</p>
<h2 id="Server-Side-Rendering"><a href="#Server-Side-Rendering" class="headerlink" title="Server Side Rendering"></a>Server Side Rendering</h2><h3 id="클라이언트가-서버에-리소스-요청"><a href="#클라이언트가-서버에-리소스-요청" class="headerlink" title="클라이언트가 서버에 리소스 요청"></a>클라이언트가 서버에 리소스 <code>요청</code></h3><p>클라이언트에서 서버로 요청을 보낸다.</p>
<h3 id="nginx가-Express가-띄워져있는-포트로-요청을-서빙"><a href="#nginx가-Express가-띄워져있는-포트로-요청을-서빙" class="headerlink" title="nginx가 Express가 띄워져있는 포트로 요청을 서빙"></a>nginx가 Express가 띄워져있는 포트로 요청을 서빙</h3><p>보통 nodeJS를 사용하여 서버를 개발할 때 <code>node server.js</code>와 같은 명령어로 바로 서버를 띄우는 경우는 드물고 보통 <code>nginx</code>나 <code>apache</code>와 같은 서버 엔진을 같이 사용한다.<br>그 이유는 다음과 같다.</p>
<hr>
<ol>
<li>서버 엔진 소프트웨어의 특성 상 nodeJS보다 더 빠른 Static file serving이 가능하다. 그리고 그런 요청을 nodeJS까지 보내지 않고 엔진단에서 처리되므로 백엔드의 부하가 분산된다.</li>
<li>Node.js의 창시자인 Ryan Dahl이 “You just may be hacked when some yet-unknown buffer overflow is discovered. Not that that couldn’t happen behind nginx, but somehow having a proxy in front makes me happy” 라는 말을 한 적이 있음. 즉, 아직 발견되지 않은 취약점에 의한 공격을 어느 정도 방지할 수 있다는 뜻이다.</li>
</ol>
<hr>
<p>그래서 대략 다음과 같은 nginx config를 작성하였다.</p>
<figure class="highlight nginx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">server</span> {</span><br><span class="line">  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;</span><br><span class="line">  <span class="hljs-attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-attribute">location</span> / {</span><br><span class="line">    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;</span><br><span class="line">    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;</span><br><span class="line">    <span class="hljs-attribute">proxy_set_header</span> X-NginX-Proxy <span class="hljs-literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:3000/;</span><br><span class="line">    <span class="hljs-attribute">proxy_redirect</span> <span class="hljs-literal">off</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;</span><br><span class="line">  <span class="hljs-attribute">gzip_comp_level</span> <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-attribute">gzip_proxied</span> any;</span><br><span class="line">  <span class="hljs-attribute">gzip_min_length</span>  <span class="hljs-number">1000</span>;</span><br><span class="line">  <span class="hljs-attribute">gzip_disable</span>     <span class="hljs-string">"MSIE [1-6]\."</span></span><br><span class="line">  gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>요청이 <code>80</code>포트로 들어오면 <code>node server.js</code>로 실행된 nodeJS 서버가 대기하고 있는 <code>3000</code>포트로 포워딩 해준다.<br>그리고 사실 nodeJS 서버를 실행시킬 때 <code>pm2</code>나 <code>forever</code>와 같은 프로세스 관리자를 사용해서 실행시키는 편이 좋은데, 이 내용은 다음 포스팅에 <strong>언젠가</strong> 작성하겠다. 필자는 <code>pm2</code>를 사용 중.</p>
<h3 id="Express-라우팅-시작"><a href="#Express-라우팅-시작" class="headerlink" title="Express 라우팅 시작"></a>Express 라우팅 시작</h3><p>이렇게 들어온 요청은 nodeJS서버인 <code>server.js</code>에서 처리하게 된다.<br><code>server.js</code>에는 Vue 코드는 없고 nodeJS로 작성된 <code>Express</code> 프레임워크의 코드가 작성되어있다.</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> createRenderer = <span class="hljs-function">(<span class="hljs-params">bundle, template</span>) =></span> {</span><br><span class="line"> <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">'vue-server-renderer'</span>).createBundleRenderer(bundle, {</span><br><span class="line">   template,</span><br><span class="line">   runInNewContext: <span class="hljs-string">'once'</span>,</span><br><span class="line"> });</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> bundle = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./dist/vue-ssr-bundle.json'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> template = fs.readFileSync(resolve(<span class="hljs-string">'./dist/index.html'</span>), <span class="hljs-string">'utf-8'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> renderer = createRenderer(bundle, template);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> app = express();</span><br><span class="line">app.set(<span class="hljs-string">'views'</span>, <span class="hljs-string">'./src/express/views'</span>);</span><br><span class="line">app.set(<span class="hljs-string">'view engine'</span>, <span class="hljs-string">'ejs'</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="hljs-string">'/ping'</span>, (req, res) => {</span><br><span class="line">  debug(<span class="hljs-string">`health check from ELB`</span>);</span><br><span class="line">  res.render(<span class="hljs-string">'healthCheck'</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> bundle = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./dist/vue-ssr-bundle.json'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> template = fs.readFileSync(resolve(<span class="hljs-string">'./dist/index.html'</span>), <span class="hljs-string">'utf-8'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> renderer = createRenderer(bundle, template);</span><br><span class="line">app.get(<span class="hljs-string">'*'</span>, (req, res) => {</span><br><span class="line">  <span class="hljs-keyword">if</span> (!renderer) {</span><br><span class="line">    <span class="hljs-keyword">return</span> res.end(<span class="hljs-string">'<pre>렌더링 중 입니다 뿜뿜</pre>'</span>);</span><br><span class="line">  }</span><br><span class="line">  res.setHeader(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/html'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> context = { <span class="hljs-attr">url</span>: req.url, <span class="hljs-attr">cookie</span>: req.cookies };</span><br><span class="line">  <span class="hljs-keyword">if</span> (!context.url) {</span><br><span class="line">    errorLog(<span class="hljs-string">'[ERR] context url is not exist!!'</span>, context);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 렌더 스트림 진행</span></span><br><span class="line">  <span class="hljs-keyword">const</span> stream = renderer.renderToStream(context);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>필자는 <code>Express</code>를 사용했기 때문에 당연히 <code>Express</code>의 라우터를 사용했다. 그러나 실질적인 라우팅은 <code>Vue</code>가 진행하기 때문에 <code>Express</code>에서는 <code>app.get('*')</code>과 같이 와일드카드를 사용하여 모든 요청에 대한 콜백 함수를 실행하도록 한다.</p>
<p>중간에 보면 <code>app.get('/ping')</code>이라는 코드도 있는데 저건 AWS의 <code>Elastic Beanstalk</code>의 Health Check 때문에 별도로 작성한 라우터이다. ELB에서는 현재 환경이 제대로 작동하고 있는지를 체크하려고 그 환경에 속한 인스턴스들의 특정 URL로 주기적으로 ping을 날린다. 이 URL은 ELB의 설정에서 바꿔줄 수 있고, 필자는 <code>/ping</code>이라는 URL로 설정했다.<br>굳이 이 라우터를 따로 나눈 이유는 <code>vue-ssr-renderer</code>의 render 함수가 많이 실행될 수록 메모리에 올라가는 HTML 템플릿이 많아질 것이고 그렇게 됨으로써 결국 렌더 과정에 병목이 발생하기 때문에 <code>vue-ssr-renderer</code>를 실행시키지 않고 <code>Express</code>만으로 간단한 페이지를 응답으로 보내주게 해놓은 것이다.</p>
<p><code>Express</code>라우팅과 밑에서 설명할 <code>vue-router</code>의 라우팅이랑 헷갈릴 수 있는데, 방금 설명한 대로 실질적인 라우팅은 <code>Vue</code>에서 진행하게 되지만 요청을 <code>Express</code>에서 먼저 받아 처리한 후에 <code>Vue</code>로 넘겨주는 순서이기 때문에 <code>Express</code>에서도 라우팅을 해줘야한다. 라우팅 후 마지막 줄의 <code>renderToStream</code> 메소드가 실행되고나면 <code>Vue</code>에서 진행되는 라우팅과 렌더링을 시작하게 된다.</p>
<p>이제 <code>app.get('*')</code> 라우터 내부를 자세하게 설명한다.</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="hljs-string">'*'</span>, (req, res) => {</span><br><span class="line">  <span class="hljs-keyword">if</span> (!renderer) {</span><br><span class="line">    <span class="hljs-keyword">return</span> res.end(<span class="hljs-string">'<pre>렌더링 중 입니다 뿜뿜</pre>'</span>);</span><br><span class="line">  }</span><br><span class="line">  res.setHeader(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/html'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> context = { <span class="hljs-attr">url</span>: req.url, <span class="hljs-attr">cookie</span>: req.cookies };</span><br><span class="line">  <span class="hljs-keyword">if</span> (!context.url) {</span><br><span class="line">    errorLog(<span class="hljs-string">'[ERR] context url is not exist!!'</span>, context);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> stream = renderer.renderToStream(context);</span><br><span class="line">  stream.on(<span class="hljs-string">'data'</span>, () => {</span><br><span class="line">    <span class="hljs-comment">/* @desc</span></span><br><span class="line"><span class="hljs-comment">     * vue-meta 플러그인을 사용하면 컴포넌트에 선언되어있는 metaInfo 메소드에서 반환한 값을 받아올 수 있다.</span></span><br><span class="line"><span class="hljs-comment">     * https://github.com/declandewet/vue-meta 참고할 것</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">const</span> {</span><br><span class="line">      title, link, style, script, noscript, meta,</span><br><span class="line">    } = context.meta.inject();</span><br><span class="line">    context.head = <span class="hljs-string">`</span></span><br><span class="line"><span class="hljs-string">      <span class="hljs-subst">${title.text()}</span></span></span><br><span class="line"><span class="hljs-string">      <span class="hljs-subst">${meta.text()}</span></span></span><br><span class="line"><span class="hljs-string">      <span class="hljs-subst">${link.text()}</span></span></span><br><span class="line"><span class="hljs-string">      <span class="hljs-subst">${style.text()}</span></span></span><br><span class="line"><span class="hljs-string">      <span class="hljs-subst">${script.text()}</span></span></span><br><span class="line"><span class="hljs-string">      <span class="hljs-subst">${noscript.text()}</span></span></span><br><span class="line"><span class="hljs-string">    `</span>;</span><br><span class="line">  })</span><br><span class="line">  .on(<span class="hljs-string">'error'</span>, err => {</span><br><span class="line">    debug(<span class="hljs-string">`렌더 중 에러 발생`</span>);</span><br><span class="line">    <span class="hljs-comment">// 에러 페이지를 보여주는 등의 에러 핸들링 로직이 위치한다.</span></span><br><span class="line">  })</span><br><span class="line">  .on(<span class="hljs-string">'end'</span>, () => {</span><br><span class="line">    debug(<span class="hljs-string">`렌더링 종료`</span>);</span><br><span class="line">  })</span><br><span class="line">  .pipe(res);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>이 라우팅에서 가장 중요한 부분은 <code>renderToStream</code> 메소드의 역할이다.<br><code>vue-ssr-renderer</code>는 <code>renderToString</code>과 <code>renderToStream</code>이라는 2가지 렌더 함수를 가지고 있다.<br><code>renderToString</code>은 모든 렌더가 끝나면 렌더된 HTML을 string의 형태로 반환하고 그 이후 클라이언트로 HTML을 한번에 반환한다. 때문에 렌더 속도가 오래 걸리게 되면 유저는 빈 화면을 보고 있을 수 밖에 없다. 또한 데이터를 한번에 내려주기 때문에 HTML 렌더를 진행할 때 내용을 전부 다 메모리에 올려야한다는 단점이 있다. HTML의 크기가 작으면 문제가 되지 않겠지만 파일의 크기가 커질 수록 매 렌더링 시 메모리 공간을 많이 잡아먹는다.</p>
<p><code>renderToStream</code>은 한 이벤트가 끝날때마다 nodeJS의 <code>ReadableStream</code>객체를 반환한다. <a href="https://nodejs.org/api/stream.html" target="_blank" rel="external nofollow noopener noreferrer">stream</a>은 데이터를 일정한 chunk단위로 불러오고 <code>on</code>메소드를 사용한 이벤트 콜백 호출로 stream을 관리할 수 있는 nodeJS의 기능이다. data이벤트는 각 chunk가 <code>readable</code>상태가 될때마다 호출되며 모든 데이터를 불러왔다면 <code>end</code>이벤트가 호출된다.<br>이 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="external nofollow noopener noreferrer">stream</a>에 관한 내용은 추후 다른 포스트에서 <strong>언젠가</strong> 설명하도록 하겠다.</p>
<h3 id="server-entry-js-실행"><a href="#server-entry-js-실행" class="headerlink" title="server-entry.js 실행"></a><code>server-entry.js</code> 실행</h3><p><code>renderToStream</code>함수가 실행되면 <code>vue-server-renderer</code>는 서버 쪽 엔트리 파일인 <code>server-entry.js</code>파일을 찾게된다. 이 파일에서는 <code>app.js</code>에 있는 팩토리 함수를 사용하여 app 객체를 생성하고 몇가지 초기화 과정을 거친 뒤 라우팅을 한다.</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>; <span class="hljs-comment">// 팩토리 함수 import</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> context => {</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) => {</span><br><span class="line">    <span class="hljs-comment">// 해당 프로미스에서 resolve되면 router.push가 호출된 후에도 stream이 계속 진행되고</span></span><br><span class="line">    <span class="hljs-comment">// 해당 프로미스에서 reject되면 stream의 error이벤트가 호출된다.</span></span><br><span class="line">  });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>이 파일의 코드를 설명하기 위해서는 상단에 import된 <code>createApp</code> 함수에서 반환된 <code>app</code>, <code>store</code>, <code>router</code>가 뭔지 알고 있는 게 좋으므로, 자세히 살펴보기 전에 맨 위에서 import된 <code>createApp</code> 팩토리 함수를 먼저 살펴보자.<br><code>createApp</code> 함수는 <code>Vue 인스턴스</code>, vue-router의 <code>VueRouter 인스턴스</code>, Vuex의 <code>Store 인스턴스</code>를 반환하는 팩토리 함수이다.<br>이후 이 팩토리 함수는 <code>client-entry</code>에도 재사용되어 초기화를 진행하게 된다.</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> Store <span class="hljs-keyword">from</span> <span class="hljs-string">'./stores'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> { Router } <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createApp</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> store = Store();</span><br><span class="line">  <span class="hljs-keyword">const</span> router = Router();</span><br><span class="line">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue({ router, store, <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =></span> h(App) });</span><br><span class="line">  <span class="hljs-keyword">return</span> {</span><br><span class="line">      app, router, store,</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>일반적으로 클라이언트에서 <code>Vue</code>를 초기화하는 코드와 비슷하지만 다른 부분이 하나 있는데, <code>store</code>와 <code>router</code> 인스턴스를 팩토리 함수를 사용해서 생성한다는 점이다. 보통 SPA 어플리케이션에서는</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vue({</span><br><span class="line">  el: <span class="hljs-string">'#app'</span>,</span><br><span class="line">  components: { App },</span><br><span class="line">  template: <span class="hljs-string">'<app>'</app></span>,</span><br><span class="line">  router: <span class="hljs-keyword">new</span> VueRouter({ ... }),</span><br><span class="line">  store: <span class="hljs-keyword">new</span> Vuex.Store({ ... }),</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>이런 식으로 <code>Vue</code>인스턴스를 생성한다. 하지만 이 로직을 그대로 서버에서 사용하기엔 문제가 하나 있다.</p>
<p>문제는 <code>export default</code>로 <code>call by reference</code> 평가전략을 사용하는 자료형을 반환하게 될 때 발생한다. <code>new Vue()</code>에서 호출하는 <code>Vue</code>는 인스턴스를 반환하는 클래스같이 작동하기 때문에 해당 코드는 최종적으로 <code>Vue</code> 인스턴스가 올라간 메모리 주소를 반환하게 되는데, 이 로직은 클라이언트에서는 딱히 문제가 없지만 서버에서는 문제가 발생할 수 있다.</p>
<p>클라이언트와 다르게 서버는 <strong>한번 올라가면 오랜 시간동안 계속 돌아가는 프로그램</strong> 이라는 것이다. 현재 서버에 접속해있는 유저들이 <code>Store</code>의 상태를 공유하면 안되기 때문에 서버는 각 요청에 대해서 <strong>새로운</strong> <code>Store</code>와 <code>Vue</code> 인스턴스를 생성해야한다.<br>하지만 위의 코드에서 <code>export</code>하는 것은 결과적으로 <code>Vue인스턴스의 메모리 포인터</code>이고 위 모듈이 <code>import</code> 될때 이 모듈은 처음 한번만 <code>Vue</code>인스턴스를 생성하고 이후는 참조해야하는 메모리 포인터, 즉 <strong>같은 인스턴스</strong> 를 반환하게 된다.<br>그렇기 때문에</p>
<blockquote>
<p>서버 사이드 렌더링 때는 상태오염을 피하기 위해, 인스턴스의 메모리 포인터가 아닌 팩토리 함수를 노출시키고 매번 새로운 인스턴스를 생성해 반환하는 방법으로 작성하여야 한다.</p>
</blockquote>
<p>필자는 이 사실을 놓쳐서 유저들이 <code>Store</code>내부의 세션을 공유하게 되서 내 계정으로 로그인했지만 다른 사람 계정으로 로그인되버리는 버그를 생성한 적이 있다. 지금 생각해도 아찔한 순간이다.</p>
<blockquote><p>A Node.js server is a long-running process. When our code is required into the process, it will be evaluated once and stays in memory.<br>…<br>So, instead of directly creating an app instance, we should expose a factory function that can be repeatedly executed to create fresh app instances for each request.</p>
<footer><strong>Avoid Stateful Singletons - Vue SSR Guide</strong></footer></blockquote>
<p>심지어 이렇게 <a href="https://ssr.vuejs.org/guide/structure.html#avoid-stateful-singletons" target="_blank" rel="external nofollow noopener noreferrer">공식 문서</a>에도 버젓히 적혀있는 걸 놓쳐서 엄청난 버그를 내고 말았다. 공식 문서를 반드시 읽읍시다! 두번세번 읽읍시다!</p>
<p>자, 이제 <code>createApp</code>를 살펴보았으니 다시 <code>server-entry.js</code>로 돌아와서 해당 파일에 대한 설명을 계속 이어가겠다.</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>; <span class="hljs-comment">// 팩토리 함수 import</span></span><br><span class="line"><span class="hljs-keyword">import</span> { TOKEN_KEY } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/constants'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> { SET_TOKEN, DESTROY_TOKEN } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/stores/auth/config'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> APIAuth <span class="hljs-keyword">from</span> <span class="hljs-string">'src/api/auth'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> context => {</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) => {</span><br><span class="line">    <span class="hljs-keyword">const</span> { router, store } = createApp(); <span class="hljs-comment">// 새로운 앱 생성</span></span><br><span class="line">    <span class="hljs-keyword">const</span> cookies = context.cookie;</span><br><span class="line">    <span class="hljs-keyword">const</span> authToken = cookies[TOKEN_KEY]; <span class="hljs-comment">// 요청을 보낸 클라이언트의 쿠키에 있는 토큰</span></span><br><span class="line">    <span class="hljs-keyword">const</span> next = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {</span><br><span class="line">      router.push(context.url);</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (authToken) {</span><br><span class="line">      <span class="hljs-keyword">try</span> {</span><br><span class="line">        <span class="hljs-keyword">await</span> APIAuth.isValidToken(authToken); <span class="hljs-comment">// valid하면 200, invalid하면 400</span></span><br><span class="line">        store.dispatch(SET_TOKEN, authToken);</span><br><span class="line">      }</span><br><span class="line">      <span class="hljs-keyword">catch</span> (e) {</span><br><span class="line">        <span class="hljs-built_in">console</span>.error(e); <span class="hljs-comment">// throw하면 렌더 실패로 간주된다. 하지만 토큰이 invalid하다고 렌더 자체를 실패시키면 안된다.</span></span><br><span class="line">        store.dispatch(DESTROY_TOKEN);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    router.onReady(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {</span><br><span class="line">      <span class="hljs-comment">// 라우팅 로직이 위치</span></span><br><span class="line">    }, reject);</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>이 파일의 메인 로직은 크게 2가지로 나누어 진다.</p>
<hr>
<ol>
<li>요청을 보낸 클라이언트의 쿠키에 토큰이 저장되어있을 경우 <code>store.dispatch(SET_TOKEN, authToken)</code>로 Store에 인증상태를 저장</li>
<li><code>router.onReady</code>로 선언된 서버 측 라우팅 로직 및 예외처리</li>
</ol>
<hr>
<p>먼저 1번부터 살펴보자. 왜 굳이 인증된 토큰을 Store에 담아야 할까? 먼저 이 서버는 렌더링만을 수행하는 렌더서버이기 때문에 세션의 유효성 검사는 외부에 있는 API서버와 통신을 해서 수행해야한다.</p>
<p>인증상태는 서버에서도 필요할 수 있고 클라이언트에서도 필요할 수도 있는데, 그럼 서버에서 한번 통신해서 토큰을 검사하고 클라이언트에서도 또 통신을 해서 토큰을 검사해야한다. 하지만 이런 방식은 비효율적이기 때문에 보통 이런 유니버셜 SSR을 지원하는 프레임워크에서는 서버의 상태를 클라이언트로 반환해주는 방법으로 <code>window</code>객체에 서버의 상태를 직렬화해서 렌더 시 <code><script></code>태그 안에 선언해주는 방식을 사용한다.<br><code>vue-server-renderer</code>에서는 클라이언트에 반환할 서버의 상태를 Vue의 <a href="https://haruair.github.io/flux/" target="_blank" rel="noopener">Flux아키텍처</a> 라이브러리인 <a href="https://vuex.vuejs.org/kr/" target="_blank" rel="noopener">Vuex</a>를 사용하여 선언한다.<br>그렇게 서버의 상태는 렌더 시 <code>JSON.stringify</code>를 사용하여 직렬화되어 <code>window.__INITIAL_STATE__</code>라는 프로퍼티에 담기게 되고, 이후 클라이언트 초기화 시 해당 프로퍼티에 접근해 <code>JSON.parse</code>를 사용하여 Object형으로 형변환 후 Vuex Store의 <code>replaceState</code>메소드를 사용해 Store를 업데이트하게 된다.</p>
<center><br>    <img src="/2018/09/25/vue-ssr/initial_state.png"><br>    <sub>브라우저 콘솔에서 이렇게 확인해볼 수 있다</sub><br></center>

<h3 id="서버의-vue-router-라우팅-진행"><a href="#서버의-vue-router-라우팅-진행" class="headerlink" title="서버의 vue-router 라우팅 진행"></a>서버의 <code>vue-router</code> 라우팅 진행</h3><p>다음 2번이었던 라우팅 로직을 살펴보자. Universal SSR 어플리케이션은 맨 처음 사용자가 페이지를 열었을 때는 서버 쪽에서 라우팅을 진행하고 그 이후 사용자가 페이지를 이동할때는 클라이언트에서 라우팅을 진행하게된다.<br>즉 <code>server-entry.js</code> 내부의 라우팅 로직은 맨 처음 사용자가 어플리케이션을 초기 실행시킬 때 딱 한번 실행되는 로직이라는 의미이다. 필자는 서버에서는 이 라우터에 연결된 컴포넌트가 있는지에 대한 검사만 진행하고 클라이언트에 라우터 인증 관련 로직을 작성했기 때문에 서버 쪽 엔트리의 라우팅 로직은 간단하게 작성했다.</p>
<p>이 파일에서 사용된 <code>router</code>객체는 <code>createApp</code> 팩토리 함수에서 생성되어 반환된 <code>vue-router</code> 라이브러리 내 <code>VueRouter</code>클래스의 인스턴스이다. 필자는 이 클래스의 <code>getMatchedComponents</code> 메소드를 사용해서 현재 라우트가 유효한 라우트인지만 검사하기로 했다.<br><code>VueRouter</code>의 멤버변수와 메소드의 의미는 <code>vue-router</code>의 <a href="https://router.vuejs.org/kr/api/#router-link" target="_blank" rel="noopener">공식 문서</a>에도 나와있지만 가끔씩 라이브러리는 업데이트가 되었으나 공식 문서는 업데이트가 늦는 경우도 있으므로 필자는 직접 <code>vue-router</code>의 코드를 살펴봤다.<br><code>node_modules/vue-router/types/router.d.ts</code> 파일을 살펴보면 <code>VueRouter</code> 클래스의 멤버 변수와 메소드를 확인할 수 있다.</p>
<figure class="highlight typescript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> VueRouter {</span><br><span class="line">  <span class="hljs-keyword">constructor</span> (<span class="hljs-params">options?: RouterOptions</span>);</span><br><span class="line"></span><br><span class="line">  app: Vue;</span><br><span class="line">  mode: RouterMode;</span><br><span class="line">  currentRoute: Route;</span><br><span class="line"></span><br><span class="line">  beforeEach (guard: NavigationGuard): <span class="hljs-built_in">Function</span>;</span><br><span class="line">  beforeResolve (guard: NavigationGuard): <span class="hljs-built_in">Function</span>;</span><br><span class="line">  afterEach (hook: <span class="hljs-function">(<span class="hljs-params">to: Route, <span class="hljs-keyword">from</span>: Route</span>) =></span> <span class="hljs-built_in">any</span>): <span class="hljs-built_in">Function</span>;</span><br><span class="line">  push (location: RawLocation, onComplete?: <span class="hljs-built_in">Function</span>, onAbort?: <span class="hljs-built_in">Function</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">  replace (location: RawLocation, onComplete?: <span class="hljs-built_in">Function</span>, onAbort?: <span class="hljs-built_in">Function</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">  go (n: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">  back (): <span class="hljs-built_in">void</span>;</span><br><span class="line">  forward (): <span class="hljs-built_in">void</span>;</span><br><span class="line">  getMatchedComponents (to?: RawLocation | Route): Component[];</span><br><span class="line">  onReady (cb: <span class="hljs-built_in">Function</span>, errorCb?: <span class="hljs-built_in">Function</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">  onError (cb: <span class="hljs-built_in">Function</span>): <span class="hljs-built_in">void</span>;</span><br><span class="line">  addRoutes (routes: RouteConfig[]): <span class="hljs-built_in">void</span>;</span><br><span class="line">  resolve (to: RawLocation, current?: Route, append?: <span class="hljs-built_in">boolean</span>): {</span><br><span class="line">    location: Location;</span><br><span class="line">    route: Route;</span><br><span class="line">    href: <span class="hljs-built_in">string</span>;</span><br><span class="line">    <span class="hljs-comment">// backwards compat</span></span><br><span class="line">    normalizedTo: Location;</span><br><span class="line">    resolved: Route;</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">static</span> install: PluginFunction<never>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>getMatchedComponent</code>메소드는 <code>RawLocation</code>타입이나 <code>Route</code>타입을 인자로 받아서 <code>Component</code> 리스트를 반환해주는 메소드라는 것을 확인할 수 있다. 그럼 이제 <code>node_modules/vue-router/dist/vue-router.common.js</code>파일에서 <code>getMatchedComponent</code>이 어떻게 구현되어있는지 확인해보자.</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VueRouter.prototype.getMatchedComponents = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMatchedComponents</span> (<span class="hljs-params">to</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> route = to</span><br><span class="line">    ? to.matched</span><br><span class="line">      ? to</span><br><span class="line">      : <span class="hljs-keyword">this</span>.resolve(to).route</span><br><span class="line">    : <span class="hljs-keyword">this</span>.currentRoute;</span><br><span class="line">  <span class="hljs-keyword">if</span> (!route) {</span><br><span class="line">    <span class="hljs-keyword">return</span> []</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">return</span> [].concat.apply([], route.matched.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m</span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(m.components).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{</span><br><span class="line">      <span class="hljs-keyword">return</span> m.components[key]</span><br><span class="line">    })</span><br><span class="line">  }))</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><code>VueRouter</code>클래스의 <code>getMatchedComponent</code>라는 메소드는 <code>to</code> 인자를 받으면 해당 라우트와 매치된 컴포넌트를 반환하고, 인자가 주어지지 않는다면 현재 라우트에 매치된 컴포넌트를 반환하도록 되어있다. <code>VueRouter</code> 클래스의 타입 선언부에서 확인한 대로 <code>to</code>인자에는 <code>optional</code>을 의미하는 <code>?</code>가 붙어있었기 때문에 필요한 경우가 아니면 굳이 인자를 넘겨줄 필요는 없을 것 같다. 이제 <code>router.onReady</code>이벤트훅 내부를 한번 작성해보자.</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.onReady(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {</span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@desc </span>현재 라우터에 연결되어 있는 컴포넌트가 없다면 reject함으로써</span></span><br><span class="line"><span class="hljs-comment">  * nodeJS stream의 error이벤트가 호출되고 별도로 작성해놓은 errorHandler가 404페이지가 렌더 될 것이다.</span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line">  <span class="hljs-keyword">const</span> matchedComponents = router.getMatchedComponents();</span><br><span class="line">  <span class="hljs-keyword">if</span> (!matchedComponents.length) {</span><br><span class="line">    <span class="hljs-keyword">return</span> reject({</span><br><span class="line">      code: <span class="hljs-number">404</span>,</span><br><span class="line">      msg: <span class="hljs-string">`<span class="hljs-subst">${router.currentRoute.fullPath}</span> is not found`</span>,</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">else</span> {</span><br><span class="line">    resolve(app);</span><br><span class="line">  }</span><br><span class="line">}, reject);</span><br></pre></td></tr></tbody></table></figure>
<p>얼추 된 것 같다. 하지만 필자의 어플리케이션은 <code>asyncData</code>라는 프로퍼티를 사용하여 라우팅을 진행하기 전에 비동기로직을 기다릴 수 있도록 작성이 되어있다. Vue의 SSR라이브러리인 <code>Nuxt</code>에서도 비슷한 방식을 사용했던 것 같은데 이 부분은 잘 기억이 나지않는다.<br>어쨌든 현재 라우트에 매치된 컴포넌트리스트 중 <code>asyncData</code>를 가지고 있는 컴포넌트가 있다면 <code>Promise</code>를 사용해서 기다리도록 만들어주면 되는 간단한 로직이기 때문에 <code>Promise.all</code>을 사용하여 다음과 같이 작성하였다.</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">router.onReady(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {</span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@desc </span>현재 라우터에 연결되어 있는 컴포넌트가 없다면 404페이지를 렌더한다.</span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line">  <span class="hljs-keyword">const</span> matchedComponents = router.getMatchedComponents();</span><br><span class="line">  <span class="hljs-keyword">if</span> (!matchedComponents.length) {</span><br><span class="line">    <span class="hljs-keyword">return</span> reject({</span><br><span class="line">      code: <span class="hljs-number">404</span>,</span><br><span class="line">      msg: <span class="hljs-string">`<span class="hljs-subst">${router.currentRoute.fullPath}</span> is not found`</span>,</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-comment">// start: 추가된 부분</span></span><br><span class="line">  <span class="hljs-built_in">Promise</span>.all(matchedComponents.map(<span class="hljs-function"><span class="hljs-params">Component</span> =></span> {</span><br><span class="line">    <span class="hljs-keyword">if</span> (Component.asyncData) {</span><br><span class="line">      <span class="hljs-keyword">return</span> Component.asyncData({ <span class="hljs-attr">route</span>: router.currentRoute, store, });</span><br><span class="line">    }</span><br><span class="line">  })).then(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {</span><br><span class="line">    <span class="hljs-comment">/** <span class="hljs-doctag">@desc</span></span></span><br><span class="line"><span class="hljs-comment">     * context에 state를 넘겨주고 렌더러에`template` 옵션을 사용하면 context.state를 직렬화하여 `window .__ INITIAL_STATE__`로 HTML에 주입해준다.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    context.state = store.state;</span><br><span class="line">    resolve(app);</span><br><span class="line">  }).catch(reject);</span><br><span class="line">  <span class="hljs-comment">// end: 추가된 부분</span></span><br><span class="line">}, reject);</span><br></pre></td></tr></tbody></table></figure>
<p>그리고 모든 라우팅이 완료되었을 때 <code>context.state = store.state</code>처럼 <code>context.state</code>에 <code>store</code>상태를 담아주면 <code>vue-server-renderer</code>가 알아서 <code>window.__INITIAL_STATE__</code>에 상태를 주입해준다.</p>
<h3 id="vue-server-renderer를-사용하여-HTML-렌더링"><a href="#vue-server-renderer를-사용하여-HTML-렌더링" class="headerlink" title="vue-server-renderer를 사용하여 HTML 렌더링"></a>vue-server-renderer를 사용하여 HTML 렌더링</h3><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">.on(<span class="hljs-string">'error'</span>, err => {</span><br><span class="line">  <span class="hljs-keyword">return</span> errorHandler(req, res, err, bugsnag);</span><br><span class="line">})</span><br><span class="line">.on(<span class="hljs-string">'end'</span>, () => {</span><br><span class="line">  debug(<span class="hljs-string">`render stream end ==============================`</span>);</span><br><span class="line">  debug(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now() - s}</span>ms`</span>);</span><br><span class="line">  debug(<span class="hljs-string">'================================================'</span>);</span><br><span class="line">})</span><br><span class="line">.pipe(res);</span><br></pre></td></tr></tbody></table></figure>
<p>이렇게 <code>server-entry.js</code>에서 <code>Promise.resolve</code>가 호출되어 초기화가 끝나면 아까 선언해놓았던 <code>server.js</code>의 stream의 <code>end</code>이벤트가 실행되고나서 체이닝되어있는 <code>pipe</code>메소드가 실행된다.</p>
<h3 id="서버가-클라이언트로-응답"><a href="#서버가-클라이언트로-응답" class="headerlink" title="서버가 클라이언트로 응답"></a>서버가 클라이언트로 <code>응답</code></h3><p>위 과정을 거친 후 렌더가 끝난 HTML을 클라이언트로 전송한다.</p>
<h2 id="Client-Rendering"><a href="#Client-Rendering" class="headerlink" title="Client Rendering"></a>Client Rendering</h2><h3 id="client-entry-js-실행"><a href="#client-entry-js-실행" class="headerlink" title="client-entry.js 실행"></a><code>client-entry.js</code> 실행</h3><p>클라이언트에서 서버 렌더링이 완료된 HTML과 entry.js를 받아온 후 클라이언트 렌더링이 시작된다. 이때 웹팩이 컴파일할때 클라이언트단 엔트리 포인트로 잡는 파일은 <code>client-entry.js</code>이다.<br>먼저 <code>client-entry.js</code>파일의 <code>init</code> 함수를 살펴보자.</p>
<h3 id="클라이언트-어플리케이션-초기화-함수-실행"><a href="#클라이언트-어플리케이션-초기화-함수-실행" class="headerlink" title="클라이언트 어플리케이션 초기화 함수 실행"></a>클라이언트 어플리케이션 초기화 함수 실행</h3><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> { LOGIN } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/stores/auth/config'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> { app, router, store } = createApp();</span><br><span class="line"><span class="hljs-keyword">const</span> init = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">/** <span class="hljs-doctag">@desc </span>서버의 스토어의 클라이언트 스토어의 동기화 */</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.__INITIAL_STATE__) {</span><br><span class="line">    store.replaceState(<span class="hljs-built_in">window</span>.__INITIAL_STATE__);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">/** <span class="hljs-doctag">@desc </span>토큰 존재 여부 확인 후 로그인 처리  */</span></span><br><span class="line">  <span class="hljs-keyword">const</span> hasToken = store.state.auth.authToken;</span><br><span class="line">  <span class="hljs-keyword">if</span> (hasToken) {</span><br><span class="line">    <span class="hljs-keyword">try</span> {</span><br><span class="line">      <span class="hljs-keyword">await</span> store.dispatch(LOGIN);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">catch</span> (e) {</span><br><span class="line">      <span class="hljs-comment">// 쿠키 내 토큰을 삭제하는 등의 별도 예외처리</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>현 직장의 코드다 보니까 전체를 적지는 못했지만 <code>init</code>함수가 수행하는 로직은 <code>서버의 스토어 상태를 클라이언트에 반영</code>과 <code>사용자 인증</code>처리이다. 서버의 스토어 상태를 받아오는 원리는 <code>4. server-entry.js 실행</code>에서 설명했으니, 이번에는 <code>왜 로그인처리를 서버에서 하지않고 클라이언트에서 하는가?</code>에 대해서 설명해보려고 한다.</p>
<p>그 이유는 이 서버가 별도의 인증 로직을 가지고 있지 않은 렌더 서버이기 때문에 유저 정보를 가져오거나 인증 여부를 확인하거나 하는 작업은 모두 외부의 API 서버에 의존하고 있기 때문이다. 처음에 이 사실을 간과하고 서버 렌더링 시 API 통신을 한 후 유저데이터를 클라이언트로 내려주는 방법을 택했는데, 다음과 같은 문제가 발생했다.</p>
<hr>
<ol>
<li>HTML 템플릿 렌더시간에 API 통신시간이 포함되었다. <small>(렌더가 끝나면 서버렌더링의 라이프사이클도 같이 끝나기 때문에 렌더 중간에 await를 사용하여 API 통신을 동기처리할 수 밖에 없다. 심지어 인증된 유저 정보 GET API가 꽤 느린 편)</small></li>
<li>vue-ssr-renderer의 render 메소드의 수행시간이 늘어났다.</li>
<li>render메소드의 수행시간이 늘어나면서 한번에 메모리에 올라가는 템플릿이 많아졌다.</li>
<li>메모리가 꽉 차서 더 이상 렌더링을 수행하지 못한다.</li>
<li>서버가 응답을 하지 못한다.</li>
<li>Fail</li>
</ol>
<hr>
<p>그래서 이 렌더 서버를 구축할 때 가장 집중했던 부분은 render 메소드의 수행시간 단축이었고, 그 결과 유저 데이터를 받아오는 로직을 클라이언트로 내리게 되었다. 나중에 생각해보니 현재 인증된 사용자의 데이터가 필요한 뷰는 SEO가 필요없는 부분이라서 굳이 서버에서 할 필요가 없었다. 이제 마지막으로 클라이언트의 라우팅을 살펴보자.</p>
<h3 id="클라이언트의-vue-router-라우팅-진행"><a href="#클라이언트의-vue-router-라우팅-진행" class="headerlink" title="클라이언트의 vue-router 라우팅 진행"></a>클라이언트의 <code>vue-router</code> 라우팅 진행</h3><p><code>client-entry.js</code>에는 클라이언트 사이드의 전역 라우터도 같이 선언이 되어있다.</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> { LOGIN } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/stores/auth/config'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> { app, router, store } = createApp();</span><br><span class="line"><span class="hljs-keyword">const</span> init = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{...};</span><br><span class="line"></span><br><span class="line">router.onReady(<span class="hljs-keyword">async</span> () => {</span><br><span class="line">  <span class="hljs-keyword">await</span> init();</span><br><span class="line"></span><br><span class="line">  router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =></span> {</span><br><span class="line">    <span class="hljs-keyword">const</span> matched = router.getMatchedComponents(to);</span><br><span class="line">    <span class="hljs-keyword">const</span> prevMatched = router.getMatchedComponents(<span class="hljs-keyword">from</span>);</span><br><span class="line">    <span class="hljs-keyword">let</span> diffed = <span class="hljs-literal">false</span>;</span><br><span class="line">    <span class="hljs-keyword">const</span> activated = matched.filter(<span class="hljs-function">(<span class="hljs-params">c, i</span>) =></span> {</span><br><span class="line">      <span class="hljs-keyword">return</span> diffed || (diffed = (prevMatched[i] !== c));</span><br><span class="line">    });</span><br><span class="line">    <span class="hljs-keyword">if</span> (!activated.length) {</span><br><span class="line">      next();</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-built_in">Promise</span>.all(activated.map(<span class="hljs-function"><span class="hljs-params">c</span> =></span> {</span><br><span class="line">      <span class="hljs-keyword">if</span> (c.asyncData) {</span><br><span class="line">        <span class="hljs-keyword">return</span> c.asyncData({ store, <span class="hljs-attr">route</span>: to });</span><br><span class="line">      }</span><br><span class="line">    })).then(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {</span><br><span class="line">      <span class="hljs-comment">/* LOADING INDICATOR */</span></span><br><span class="line">      next();</span><br><span class="line">    }).catch(next);</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  app.$mount(<span class="hljs-string">'#app'</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>사실 라우터 부분은 <code>sever-entry.js</code>에 있던 라우팅 로직 부분과 별로 다르지 않다.<br>하나 차이점이 있다면 <code>client-entry.js</code>의 라우팅에서는 현재 라우터의 컴포넌트와 이전 라우터의 컴포넌트를 비교하는 로직이 있다는 것이다.<br>첫 요청 시 라우팅이 단 한번 일어나는 서버 렌더링과 다르게 클라이언트의 라우팅은 사용자의 액션에 따라서 여러 번 일어나게된다. 클라이언트 렌더링은 라우터가 변경되었을 때 컴포넌트가 변경된 부분만 새로 렌더하고 나머지는 그대로 유지하기 때문에 다음 라우터에는 현재 라우터에 있던 컴포넌트를 그대로 사용하고 있을 수 있다.<br>중요한 점은 클라이언트에서도 <code>asyncData</code>를 서버와 마찬가지로 <code>라우팅이 완료되기 전에 데이터를 fetch</code>해오는 용도로 사용되고 있다는 점이다.<br>즉, 현재 라우터에 존재하는 컴포넌트가 다음 라우터에도 존재한다면 굳이 그 컴포넌트의 <code>asyncData</code>에서 중복되는 로직을 수행할 필요가 없기 때문에 라우터가 변경될 때 컴포넌트를 비교하는 로직을 수행한 후, 달라진 컴포넌트의 <code>asyncData</code>만 수행하도록 로직을 작성해야한다.</p>
<h3 id="app-mount-gt-렌더-종료-Vue-라이프사이클-시작"><a href="#app-mount-gt-렌더-종료-Vue-라이프사이클-시작" class="headerlink" title="app.$mount -> 렌더 종료. Vue 라이프사이클 시작"></a>app.$mount -> 렌더 종료. Vue 라이프사이클 시작</h3><p>그 후 마지막에 app을 <code>#app</code> DOM에 직접 마운트하면 클라이언트 사이드의 Vue 라이프사이클이 시작된다.<br>마지막으로 해당 프로젝트 보일러 플레이트의 <a href="https://github.com/evan-moon/vue-ssr-starter" target="_blank" rel="noopener">Github 링크</a>를 첨부한다.</p>
<p>이상으로 Vue SSR 포스팅을 마친다.</p>
</body></html>
        </div>
        
        
        
            <div class="related-posts">
                <h4>관련 포스팅 보러가기</h4>
                <ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/2018/09/25/universal-ssr/" title="Universal Server Side Rendering이란?" rel="bookmark">Universal Server Side Rendering이란?</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/2019/06/13/http2-with-aws/" title="AWS와 함께 간단하게 HTTP/2 적용하기" rel="bookmark">AWS와 함께 간단하게 HTTP/2 적용하기</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/2019/08/08/fix-webpack-dev-memory-leak/" title="Webpack Watch의 메모리 누수 고치기" rel="bookmark">Webpack Watch의 메모리 누수 고치기</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/2019/06/28/v8-analysis/" title="V8 엔진은 어떻게 내 코드를 실행하는 걸까?" rel="bookmark">V8 엔진은 어떻게 내 코드를 실행하는 걸까?</a></h3></div></li><li class="popular-posts-item"><div class="popular-posts-title"><h3><a href="/2019/08/01/nodejs-event-loop-workflow/" title="로우 레벨로 살펴보는 Node.js 이벤트 루프" rel="bookmark">로우 레벨로 살펴보는 Node.js 이벤트 루프</a></h3></div></li></ul>
            </div>
        

        
        <div class="level is-size-7 is-uppercase post-tags">
            <div class="level-start">
                <div class="tags">
                    <span class="is-size-6 has-text-grey has-mr-7 tag-icon"><i class="fas fa-tag"></i></span>
                    <a class="tag -link" href="/tags/express/">Express</a><a class="tag -link" href="/tags/nodejs/">NodeJS</a><a class="tag -link" href="/tags/ssr/">SSR</a><a class="tag -link" href="/tags/server-side-rendering/">Server Side Rendering</a><a class="tag -link" href="/tags/vue/">Vue</a><a class="tag -link" href="/tags/web/">Web</a><a class="tag -link" href="/tags/서버사이드-렌더링/">서버사이드 렌더링</a>
                </div>
            </div>
        </div>
        

        

        
        
<div class="sharethis-inline-share-buttons"></div>
<script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5d0a1a560345900012ec77c4&amp;product=inline-share-buttons" async="async"></script>

        
    </code></p></body></html></div>
</div>





<!-- 댓글 위 광고 -->
<ins class="adsbygoogle card" style="display:block" data-ad-client="ca-pub-4372275195526937" data-ad-slot="7343917257" data-ad-format="auto" data-full-width-responsive="true"></ins>
<script class="card">
    (adsbygoogle = window.adsbygoogle || []).push({});
</script>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start card">
            <a data-link-name="pagenator" class="level level-item has-link-grey article-nav-prev" href="/2018/10/13/sort-algorithm/">
                <i class="fas fa-chevron-left"></i> 정렬 알고리즘 정리 (Bubble, Selection, Insertion, Merge, Quick)
            </a>
        </div>
        
        <!-- <div class="with-prev card to-home">
            <a data-link-name="pagenator" class="level level-item has-link-grey" href="/">
                <i class="fas fa-home"></i> Home
            </a>
        </div> -->
        
        <div class="level-end card">
            <a data-link-name="pagenator" class="level level-item has-link-grey  article-nav-next" href="/2018/09/25/universal-ssr/">
                Universal Server Side Rendering이란? <i class="fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div></div>
                
                




<div class="column is-4-tablet is-4-desktop is-4-widescreen  has-order-3 column-right is-sticky">
    
        
<div class="card widget" id="toc">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                카탈로그
            </h3>
            <ul class="menu-list"><li>
        <a class="is-flex" href="#Vue-Server-Side-Rendering의-구조" data-link-name="toc">
        <span class="has-mr-6">1</span>
        <span>Vue Server Side Rendering의 구조</span>
        </a></li><li>
        <a class="is-flex" href="#Server-Side-Rendering" data-link-name="toc">
        <span class="has-mr-6">2</span>
        <span>Server Side Rendering</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#클라이언트가-서버에-리소스-요청" data-link-name="toc">
        <span class="has-mr-6">2.1</span>
        <span>클라이언트가 서버에 리소스 요청</span>
        </a></li><li>
        <a class="is-flex" href="#nginx가-Express가-띄워져있는-포트로-요청을-서빙" data-link-name="toc">
        <span class="has-mr-6">2.2</span>
        <span>nginx가 Express가 띄워져있는 포트로 요청을 서빙</span>
        </a></li><li>
        <a class="is-flex" href="#Express-라우팅-시작" data-link-name="toc">
        <span class="has-mr-6">2.3</span>
        <span>Express 라우팅 시작</span>
        </a></li><li>
        <a class="is-flex" href="#server-entry-js-실행" data-link-name="toc">
        <span class="has-mr-6">2.4</span>
        <span>server-entry.js 실행</span>
        </a></li></ul></li></ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                카테고리
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/essay/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Essay</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">14</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/network/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Network</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Programming</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">45</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/programming/algorithm/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Algorithm</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">8</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/audio/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Audio</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/design/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Design</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">5</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/git/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Git</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/graphics/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Graphics</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/javascript/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">JavaScript</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">7</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/machine-learning/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Machine Learning</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/network/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Network</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">7</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/web/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Web</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/soft-skills/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Soft Skills</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/soft-skills/agile/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Agile</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/soft-skills/data/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Data</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/soft-skills/organization/" data-link-name="category">
            <span class="level-start">
                <span class="level-item">Organization</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li></ul></li>
            </ul>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/img/logo-text.png" alt="Vue Server Side Rendering" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 Evan Moon&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/" rel="external nofollow noopener noreferrer">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/" rel="external nofollow noopener noreferrer">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/evan-moon" rel="external nofollow noopener noreferrer">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>

<script>console.log("env -> development");</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("ko");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/" rel="external nofollow noopener noreferrer" target="_blank">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    

    
    
    
    

    
    
    


<script src="/js/main.js" defer></script>
<script src="/js/gaevents.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="입력 하세요...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '포스트',
                PAGES: '페이지',
                CATEGORIES: '카테고리',
                TAGS: '태그',
                UNTITLED: '(제목없음)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>