{"componentChunkName":"component---src-templates-post-page-template-index-tsx","path":"/2019/10/08/what-is-http3/","result":{"data":{"markdownRemark":{"id":"26553317-3b91-575a-a94a-167cb8e11d35","tableOfContents":"<ul>\n<li>\n<p><a href=\"#http3%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%86%8C%EA%B0%9C\">HTTP/3에 대한 간단한 소개</a></p>\n</li>\n<li>\n<p><a href=\"#tcp%EA%B0%80-%EC%99%9C-%EB%8A%90%EB%A6%AC%EB%8B%A4%EA%B3%A0-%ED%95%98%EB%8A%94-%EA%B1%B8%EA%B9%8C\">TCP가 왜 느리다고 하는 걸까?</a></p>\n<ul>\n<li><a href=\"#3-way-handshake\">3 Way Handshake</a></li>\n<li><a href=\"#holbhead-of-line-blocking\">HOLB(Head of line Blocking)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#http3%EA%B0%80-udp%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">HTTP/3가 UDP를 사용하는 이유</a></p>\n<ul>\n<li><a href=\"#udp%EB%8A%94-%ED%95%98%EC%96%80-%EB%8F%84%ED%99%94%EC%A7%80-%EA%B0%99%EC%9D%80-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%B4%EB%8B%A4\">UDP는 하얀 도화지 같은 프로토콜이다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#http3%EA%B0%80-udp%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8-%EA%B8%B0%EC%A1%B4-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EB%B3%B4%EB%8B%A4-%EB%82%98%EC%95%84%EC%A7%84-%EC%A0%90\">HTTP/3가 UDP를 사용함으로써 기존 프로토콜보다 나아진 점</a></p>\n<ul>\n<li><a href=\"#%EC%97%B0%EA%B2%B0-%EC%84%A4%EC%A0%95-%EC%8B%9C-%EB%A0%88%EC%9D%B4%ED%84%B4%EC%8B%9C-%EA%B0%90%EC%86%8C\">연결 설정 시 레이턴시 감소</a></li>\n<li><a href=\"#%ED%8C%A8%ED%82%B7-%EC%86%90%EC%8B%A4-%EA%B0%90%EC%A7%80%EC%97%90-%EA%B1%B8%EB%A6%AC%EB%8A%94-%EC%8B%9C%EA%B0%84-%EB%8B%A8%EC%B6%95\">패킷 손실 감지에 걸리는 시간 단축</a></li>\n<li><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1%EC%9D%84-%EC%A7%80%EC%9B%90\">멀티플렉싱을 지원</a></li>\n<li><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%9D%98-ip%EA%B0%80-%EB%B0%94%EB%80%8C%EC%96%B4%EB%8F%84-%EC%97%B0%EA%B2%B0%EC%9D%B4-%EC%9C%A0%EC%A7%80%EB%90%A8\">클라이언트의 IP가 바뀌어도 연결이 유지됨</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0-%EB%A7%81%ED%81%AC\">참고 링크</a></p>\n</li>\n</ul>","excerpt":"HTTP/3는 HTTP(Hypertext Transfer Protocol)의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 QUIC을 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다. 필자는 최근에 다른 분들이 공유해주시는 포스팅을 보고 나서 HTTP/3가 나왔다는 것을 처음 알게 되었다. 그 포스팅은 HTTP/3: the past, the present, and the future라는 포스팅…","html":"<p>HTTP/3는 HTTP(Hypertext Transfer Protocol)의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 QUIC을 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.</p>\n<p>필자는 최근에 다른 분들이 공유해주시는 포스팅을 보고 나서 HTTP/3가 나왔다는 것을 처음 알게 되었다. 그 포스팅은 <a href=\"https://blog.cloudflare.com/http3-the-past-present-and-future/\" target=\"_blank\" rel=\"nofollow\">HTTP/3: the past, the present, and the future</a>라는 포스팅이었는데, 솔직히 처음 딱 제목만 보고나서 이런 생각을 했었다.</p>\n<blockquote>\n<p>아니, HTTP/2가 공개된지 4년 정도 밖에 안 지났는데 무슨 HTTP/3가 벌써 나와? 그냥 설계하고 있다는 거 아니야?</p>\n</blockquote>\n<p>그런데 포스팅을 읽어 보니 이미 Google Chrome은 HTTP/3를 지원하는 카나리 빌드도 배포되어 있어서 실제로 사용까지 해볼 수 있는 단계에 도달했다는 사실을 알게 되어 놀랐다. HTTP/1에서 HTTP/2로 가는 데만 해도 대략 15년 정도의 시간이 걸렸는데, 고작 4년 만에 바로 사용해볼 수 있는 정도의 완성도인 다음 메이저 버전이 배포되었다는 것이다.</p>\n<p>게다가 아직 전 세계의 HTTP/2 점유율을 보면 40% 정도 밖에 안된다. 그 정도로 HTTP/2가 나온지도 얼마 되지 않았다는 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABKklEQVR42pWS2W6DMBBF+f8vzAPYHryUBLyw2NikD70JqJGatErR0WgYrrnjsatt287nZO2ntdc3ce46DGVZSjVNM2OjUkXK/BKlnil1HYchVuM4CTEZs2ldjHmBlIXogLHSNIVzLEazsQph5DxApHVu20z0gLFc14gr5ysiaNtVylUpJNH7m/N8OoWmge5QfEN0SLU+QL6/ChGdi9U8L2h73wzMn3neM4pEaXeeOB/3X8LnHaA8nLGYsXAf7P8XL0vkfHp1Hr/yaBt7xrT3tt8EAyO6O6eEwY445D+sftwZiOHsXKq893X9IYQlsm3rhBiI3B0rZUCCT1L6HaVQgcByPvS9h3OKMeacQ/BCcK0VkUBUSgohLpczcmN0132g3nWm7/t8e9aU0hd/j8r0CkmYvgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ce http2\" title=\"\" src=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png\" srcset=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/69538/ce-http2.png 160w,\n/static/8a0a69c0fbc05eba2198cd4f552845d4/72799/ce-http2.png 320w,\n/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png 600w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>W3Techs.com에서 조사한 2019년 8월 HTTP/2 사용률</small>\n</center>\n<p>프로그래밍 언어나 프레임워크같은 친구들은 배포하는 쪽에서 업데이트를 쫙 해버리고 유저들이 업데이트를 하면 그만이지만, 프로토콜은 일종의 규약이기 때문에 소프트웨어 제조사 간 합을 맞추는 기간이 필요하므로 이렇게 단기간 안에 급격한 변화가 자주 발생하지 않을 것이라고 생각했다.</p>\n<p>아무리 요즘 기술의 변화가 빠르다지만, HTTP는 나름 웹의 근간이 되는 프로토콜인데 꼴랑 4년 만에 이런 급격한 변화가 일어났다는 게 놀라울 따름이다. <small>(몇 달 전에 HTTP/2를 처음 도입해본 웹 개발자는 웁니다)</small></p>\n<p>그리고 또 한가지 놀랐던 점은 HTTP/3는 TCP가 아닌 UDP를 사용한다는 것이었다. 뭐 딱히 웹 프로토콜이 무조건 TCP만 사용해야 한다는 법이 있는 건 아니긴 하지만, 학교에서 배울 때도 그렇고 실무에서도 실제로 사용할 때도 그렇고 HTTP는 TCP 위에서 정의된 프로토콜이라는 사실이 너무 당연하게 인식되어 있었기 때문에 UDP를 사용한다는 점이 신기하기도 했고 “왜 멀쩡히 잘 돌아가는 TCP를 냅두고 UDP를 사용하는거지?”라는 의문도 들었다.</p>\n<p>사실 HTTP/3는 정식으로 배포된 프로토콜이라기보다 아직 테스트를 거치고 있는 단계라고 보는 게 맞다. 하지만 위에서 이야기 했듯이 Google Chrome은 이미 HTTP/3를 지원하는 카나리 빌드를 배포한 상태이고, Mozila Firefox도 조만간 Nightly 버전에서 HTTP/3를 지원할 예정이며, cURL에서도 HTTP/3를 실험적 기능으로 제공하고 있는 만큼 가까운 미래 안에 HTTP/3가 메인 프로토콜이 될 가능성이 높은 것도 사실이다.</p>\n<p>만약 Google Chrome에서 HTTP/3 프로토콜을 사용해보고 싶다면 터미널에서 <code class=\"language-text\">--enable-quic</code>과 <code class=\"language-text\">--quic-version=h3-23</code> 인자를 사용하여 실행하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">open</span> <span class=\"token parameter variable\">-a</span> Google<span class=\"token punctuation\">\\</span> Chrome <span class=\"token parameter variable\">--args</span> --enable-quic --quic-version<span class=\"token operator\">=</span>h3-23</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/1d6e0c652510ca8a97827fff1fad7575/5a6dd/http3-demo.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60.62500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACTElEQVR42lWRSXPTQBCF/QcgS0EVBwriRIvtaLVkS9Y20mixExNClkMqcQrHCVVw4sbff/S0i5AcXnVP98yn162elBK1rDB2bXiO9azAsxH6ziupWlNLnH1ZIokmnC+Xp8jSGXzXwjTw0Gtuf8NabPA5u4Em7qCVK+jVPd6Fl3jrfsWOd44d95zyc7yxz6i3woFYYZd6ZvMdo24DjWqmvMf7yRV6d7/+IOxuYJfXcOU1jotv+OgI7Bsz7GgRdrUYe5Tvmwl29RjD9Ayf/BZ7lFviAra4hFVcwKmu8MEq0fv5Y4OTroHIE8iygMgSBGQ/Ivtx6CEi+fYQI6PPytOYeyovixRS5BS3bz17gN7m8RGyaZHmAhmplA1yUUFUNeft/BRJlkM3DOi6jiTNEYRTOuvIihJFKSkK5GWFY8sm4GaDum7pYkbAAgXBFFhBgzBEOJnC98cM0zSN76m6rmtIs//3CwJaloXeIzmcL04IULKqmsanr6oLChaEEziuC88bwzBMBoZUM8hxzg4rioLfWDY5fHh4QNvNnyHxLEUQhPB8nx2ocSbTiOoJQ1R/HITsWPUKMrGNNPIxOVyv12jajoGy6Rg2Go34wdHREUuNqpMUMKV9KuemaTKEjRBU7dx2nC2wJtAsyXjctltgfrKE47gMeKntDnNeg/qgWpH4N3Iltzt8enqiP7lgoLqsonIxjWIMBoNXYof049QKTNNgSEnOlFNlRpngHfKBFt/vH+Dw8JBin0dVLl5KOZzQuK7rcT6NY96tihHF4XCEv+fijBWB+5EDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"http3 demo\" title=\"\" src=\"/static/1d6e0c652510ca8a97827fff1fad7575/6af66/http3-demo.png\" srcset=\"/static/1d6e0c652510ca8a97827fff1fad7575/69538/http3-demo.png 160w,\n/static/1d6e0c652510ca8a97827fff1fad7575/72799/http3-demo.png 320w,\n/static/1d6e0c652510ca8a97827fff1fad7575/6af66/http3-demo.png 640w,\n/static/1d6e0c652510ca8a97827fff1fad7575/5a6dd/http3-demo.png 802w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>http/2+quic/46이라고 되어있는 녀석들이 HTTP/3 프로토콜을 사용한 연결이다</small>\n</center>\n<p>필자는 웹 개발자이기 때문에 HTTP가 메이저 업데이트 된다는 사실을 그냥 넘기기는 힘들었고, UDP를 사용한다는 것이 뭘 의미하는지도 궁금하기도 해서 결국 HTTP/3에 대한 조사를 하게 되었다. 그래서 이번 포스팅에서는 필자가 여기저기 쑤셔보면서 알아본 HTTP/3에 대한 내용을 정리해볼까 한다.</p>\n<h2 id=\"http3에-대한-간단한-소개\" style=\"position:relative;\">HTTP/3에 대한 간단한 소개<a href=\"#http3%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%86%8C%EA%B0%9C\" aria-label=\"http3에 대한 간단한 소개 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 HTTP/3는 처음에는 “HTTP-over-QUIC”이라는 이름을 가지고 있었는데, IETF(Internet Engineering Task Force) 내 HTTP 작업 그룹과 QUIC 작업 그룹의 의장인 마크 노팅엄이 이 프로토콜의 이름을 HTTP/3로 변경할 것을 제안했고, 2018년 11월에 이 제안이 통과되어 HTTP-over-QUIC이라는 이름에서 HTTP/3으로 변경되게 되었다.</p>\n<p>즉, HTTP/3는 QUIC이라는 프로토콜 위에서 돌아가는 HTTP인 것이다. QUIC은 “Quick UDP Internet Connection”의 약자로, 말 그대로 UDP를 사용하여 인터넷 연결을 하는 프로토콜이다. <small>(참고로 발음은 그냥 “퀵”이라고 한다)</small></p>\n<p>HTTP/3는 QUIC을 사용하고, QUIC은 UDP를 사용하기 때문에 결과적으로 HTTP/3는 UDP를 사용한다고 이야기 할 수 있는 것이다.</p>\n<p>그렇다면 QUIC이 도대체 뭐길래 기존의 TCP보다 더 빠른 전송 속도를 가질 수 있다는 것일까? 그 이유를 알려면 먼저 TCP가 왜 느리다고 하는지, UDP를 사용함으로써 어떤 이득을 얻을 수 있는지 부터 알아야 한다.</p>\n<h2 id=\"tcp가-왜-느리다고-하는-걸까\" style=\"position:relative;\">TCP가 왜 느리다고 하는 걸까?<a href=\"#tcp%EA%B0%80-%EC%99%9C-%EB%8A%90%EB%A6%AC%EB%8B%A4%EA%B3%A0-%ED%95%98%EB%8A%94-%EA%B1%B8%EA%B9%8C\" aria-label=\"tcp가 왜 느리다고 하는 걸까 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 학교에서 네트워크 강의를 들을 때 TCP와 UDP의 차이에 대한 내용을 처음 배웠었는데, 교수님이 이건 반드시 시험에 나온다길래 이런 표를 보면서 열심히 외웠던 기억이 난다.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>연결 방식</td>\n<td>연결형 서비스</td>\n<td>비연결형 서비스</td>\n</tr>\n<tr>\n<td>패킷 교환</td>\n<td>가상 회선 방식</td>\n<td>데이터그램 방식</td>\n</tr>\n<tr>\n<td>전송 순서 보장</td>\n<td>보장함</td>\n<td>보장하지 않음</td>\n</tr>\n<tr>\n<td>신뢰성</td>\n<td>높음</td>\n<td>낮음</td>\n</tr>\n<tr>\n<td>전송 속도</td>\n<td>느림</td>\n<td>빠름</td>\n</tr>\n</tbody>\n</table>\n<p>위 표를 보면 대략 “TCP는 신뢰성이 높고 느리다”, “UDP는 신뢰성이 낮고 빠르다” 정도로 정리가 되는데, 여기서 말하는 신뢰성이란 전송되는 데이터 패킷들의 순서, 패킷 유실 여부 등을 검사하여 송신 측이 보낸 모든 데이터가 수신 측에 온전하게 전달이 될 수 있느냐를 말하는 것이다.</p>\n<p>TCP는 클라이언트와 서버가 서로 신뢰성있는 통신을 할 수 있도록 몇 가지 방법을 사용하게되는데, 이 방법들 또한 결국은 클라이언트와 서버 간의 통신이기 때문에 레이턴시가 발생할 수 밖에 없다. 게다가 이 과정은 TCP라는 프로토콜이 생길 때부터 정의된 표준이므로 무시할 수도 없다.</p>\n<p>그렇다면 레이턴시를 줄이기 위해서는 TCP에서 정의한 기능 외에 다른 부분들을 건드려야 한다는 것인데, 여러모로 제한 사항이 많다. 아무리 회선의 대역폭을 늘린다고 해도 기술이 발전하면서 전송해야하는 데이터의 크기도 점점 커지기 때문에 결국 언젠가는 또 느려질 것이고, 회선의 전송 속도 자체를 높힌다고 해도 결국은 빛의 속도 보다 빠르게 전송할 수 없기 때문에 한계가 있다.</p>\n<p>HTTP/3이 UDP 기반인 QUIC 프로토콜을 사용하는 이유가 바로 이런 제약 조건을 뛰어넘기 위해 프로토콜 자체를 손보는 방법을 택한 것이다. 하지만 TCP는 워낙 오래된 프로토콜이기도 하고 커널까지 내려가는 로우 레벨에서 정의되어 있기 때문에 이걸 뜯어고치는 것도 만만치 않은 대작업이라 UDP를 선택한 것이다.</p>\n<p>그럼 한번 TCP가 신뢰성 있는 통신을 위해 사용하는 방법들이 왜 느리다고 하는지 알아보자.</p>\n<h3 id=\"3-way-handshake\" style=\"position:relative;\">3 Way Handshake<a href=\"#3-way-handshake\" aria-label=\"3 way handshake permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>TCP는 굉장히 친절한 프로토콜이다. 통신을 시작할 때와 종료할 때 서로 준비가 되어있는지를 반드시 먼저 물어보고 패킷을 전송할 순서를 정하고 나서야 본격적인 통신을 시작하기 때문이다.</p>\n<p>이때 통신을 시작할 때 거치는 과정을 3 Way Handshake, 통신을 마칠 때 거치는 과정을 4 Way Handshake라고 한다. 이 포스팅의 목적은 이 과정을 자세히 다루는 것이 아니므로, TCP를 사용하여 통신을 시작할 때 거치는 과정인 3 Way Handshake가 어떤 원리로 작동하는지만 설명하겠다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.74999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA9gAAAPYAF6eEWNAAACX0lEQVR42k1S227aQBD1//9EH/LQqhSpJNCE2IAvwXfWxvLd611fARHRgBSJW7A7wEvnYTS7O2fm7JlhTqdz27bb7Ycyldfr9fl8Ph6OTdO0/9nlcjkcDvCUpqltWbvdDhLgyCiKMpnwgiAihBzHCYIA/HK5BExzMwjKspzP557n2bataxrPC7wgTmWZEUW+8/MHxw0JwUmSYJwAvijKe8M7OM/zoijquoaiGGOOe+12O5I0YTx3riqS50Fpa2bOLAuZpllV9b0zwCEAtsPhkGVfx+NxHMfI1gWB8/w5A5TCMABKPM8PBgOWZf88PyfJtfNqtd5sPiAghMg3myGUxFhjPfaXYk19JooSWdaCIPZ93zCN668MI4qK/b5FqAj81R2sqSo8aRpkhqHrz3QjDkOGZdHDw/CpP03iCKGZaRqSJOVZBpjPz/3m7+fHtuUnCc9PBFBVkqIoTlLsuE61qJk0jZGlJ0kI5YG8YRij0SjPr+C5EUQOaY+thzA34uAevmZb9nOH6357El5Epi7r0I/LvAIlQBhCKQTEq067dk3279m+OYPaWYpxlmWQQAn1HM9UjSgIGNVRBmJ/oo+kN1EUhF7vd78/sJTqcmqrugbNrmpj/PjYAy0ty8rynGTE9d2yKpmRMey9dYbqE6UpMAflXc+lWXk8tba9CIJ3AGNMQSdCKDSnlBa0DNxgUS2YZb1c1Svwt03Iq6oCbuAB8/XVnE7NdttOp1TTVF3XLdvGBI8MtjvuyPM3BrZihkzQ2brZdVS6fgffFqy5jYrK8hTmZJowI7037na57y/C4z+QeJZeh7viqwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3way handshake\" title=\"\" src=\"/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png\" srcset=\"/static/dd7f29fecd14fe5feebc6cf562123c48/69538/3way-handshake.png 160w,\n/static/dd7f29fecd14fe5feebc6cf562123c48/72799/3way-handshake.png 320w,\n/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png 550w\" sizes=\"(max-width: 550px) 100vw, 550px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>통신을 시작할 때 3 Way Handshake를 하는 과정</small>\n</center>\n<p>위 그림을 보면 클라이언트가 처음 서버와 통신을 하기 위해 TCP 연결을 생성할 때 <code class=\"language-text\">SYN</code>와 <code class=\"language-text\">ACK</code>라는 패킷을 주고 받고 있다. 이 패킷 내부에 들어있는 값들을 사용하여 클라이언트와 서버가 서로 보낸 패킷의 순서와 패킷을 제대로 받았는 지를 확인할 수 있는 것이다.</p>\n<p>그리고 이 과정에는 총 3번의 통신이 필요하다. OSX나 Linux를 사용하고 있는 분이라면 터미널에서 <code class=\"language-text\">tcpdump</code> 유틸리티를 사용하여 이 과정을 직접 눈으로 확인해볼 수 있다.</p>\n<p>단, <code class=\"language-text\">tcpdump</code>를 아무 옵션 없이 사용하면 디바이스의 모든 패킷을 감시하고 출력하기 때문에 원하는 정보를 찾기 힘들다. 그래서 필자는 루프백에서 동작하고 있는 블로그 서버와의 통신만 캡쳐해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> tcpdump <span class=\"token function\">host</span> localhost <span class=\"token parameter variable\">-i</span> lo0\nIP localhost.53920 <span class=\"token operator\">></span> localhost.terabase: Flags <span class=\"token punctuation\">[</span>S<span class=\"token punctuation\">]</span>, <span class=\"token function\">seq</span> <span class=\"token number\">1260460927</span>, win <span class=\"token number\">65535</span>\nIP localhost.terabase <span class=\"token operator\">></span> localhost.53920: Flags <span class=\"token punctuation\">[</span>S.<span class=\"token punctuation\">]</span>, <span class=\"token function\">seq</span> <span class=\"token number\">3009967847</span>, ack <span class=\"token number\">1260460928</span>, win <span class=\"token number\">65535</span>\nIP localhost.53920 <span class=\"token operator\">></span> localhost.terabase: Flags <span class=\"token punctuation\">[</span>.<span class=\"token punctuation\">]</span>, ack <span class=\"token number\">3009967848</span>, win <span class=\"token number\">6379</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>보낸 놈 > 받은 놈: Flags [플래그 종류], 헤더의 값들</p>\n</blockquote>\n<p>원래는 이것보다 더 많은 정보가 나오지만, 여기에 전부 기재하기에는 양이 너무 많으니 설명에 필요한 정보만 추려보았다. 이 로그에서 중요한 키워드는 <code class=\"language-text\">Flag</code>, <code class=\"language-text\">seq</code>, <code class=\"language-text\">ack</code> 정도이다. 한번 하나하나 뜯어보도록 하자.</p>\n<p>먼저 <code class=\"language-text\">localhost.53920</code>은 클라이언트, <code class=\"language-text\">localhost.terabase</code>는 서버를 의미한다. 각 라인의 첫번째 필드는 <code class=\"language-text\">보낸 놈 > 받은 놈</code>을 의미하고 있으니, 첫 패킷은 클라이언트가 서버에게, 두 번째 패킷은 서버가 클라이언트에게 보낸 것이라고 할 수 있다. 그리고 각 라인에는 <code class=\"language-text\">Flag</code>라는 것이 붙어있는데, 플래그는 이 패킷이 어떤 타입의 패킷인지를 알려주는 역할을 한다.</p>\n<table>\n<thead>\n<tr>\n<th>Flag</th>\n<th>이름</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S</td>\n<td>SYN</td>\n<td>연결을 생성할 때 클라이언트가 서버에 시퀀스 번호를 보내는 패킷</td>\n</tr>\n<tr>\n<td>S.</td>\n<td>SYN-ACK</td>\n<td>시퀀스 번호를 받은 서버가 ACK 값을 생성하여 클라이언트에게 응답하는 패킷</td>\n</tr>\n<tr>\n<td>.</td>\n<td>ACK</td>\n<td>ACK 값을 사용하여 응답하는 패킷</td>\n</tr>\n</tbody>\n</table>\n<p>이 통신 과정을 거치고 나면 클라이언트와 서버는 신뢰성 있는 TCP 연결을 생성할 수 있고, 이때 총 3회의 통신을 하기 때문에 3 Way Handshake라고 하는 것이다.</p>\n<p>그렇다면 이 과정에서 어떤 일이 벌어지길래 신뢰성 있는 연결을 생성할 수 있다는 것일까? 조금 더 자세히 들여다보면 클라이언트와 서버는 3 Way Handshake를 할 때 대략 이런 과정을 거치고 있다.</p>\n<blockquote>\n<p>1번 라인: 클라이언트가 서버로 시퀀스 번호를 <code class=\"language-text\">seq</code> 필드에 담아 보냄<br />\n2번 라인: 서버는 클라이언트가 보내준 시퀀스 번호를 1 증가시켜서 <code class=\"language-text\">ack</code> 필드에 담아 보냄<br />\n3번 라인: 클라이언트는 다시 서버로부터 받은 시퀀스 번호를 1 증가시켜서 자신의 <code class=\"language-text\">ack</code> 필드에 담아 보냄<br /></p>\n</blockquote>\n<p>새로운 TCP 연결을 생성하고자 할 때 클라이언트가 서버에게 랜덤한 시퀀스 번호를 전송함으로써 3 Way Handshake가 시작된다. 이때 생성된 시퀀스 번호는 이후 송신 측이 전송한 패킷을 수신 측이 재조립할때 패킷의 조립 순서를 알려주는 역할을 한다.</p>\n<p>이때 클라이언트와 서버는 상대방이 보내준 <code class=\"language-text\">seq(시퀀스 번호)</code>를 1 증가 시킨 후 자신의 <code class=\"language-text\">ack(승인 번호)</code> 필드에 담아서 보내는데, “지금 이 패킷이 니가 전에 보낸 시퀀스 번호의 다음으로 이어지는 패킷이야”라고 말하고 있는 것이다.</p>\n<p>이 3회의 통신이 바로 3 Way Handshake이다. 이 과정을 통해 클라이언트와 서버는 데이터를 주고 받을 준비가 되었다는 것을 서로에게 알려주고 이후 데이터 전송에 필요한 시퀀스 번호를 알 수 있게 된다. 연결을 끊을 때도 마찬가지로 이와 비슷한 과정인 4 Way Handshake를 거치고 나서야 세션을 종료할 수 있으며, 이때는 총 4회의 통신을 통해 연결을 종료한다.</p>\n<p>즉, TCP를 사용하는 이상 본격적인 통신을 시작하기 전에 무조건 저 번거로운 통신 과정을 거쳐야한다는 것이다.</p>\n<p>HTTP/1은 하나의 TCP 연결에 하나의 요청만 처리하고 연결을 끊어버렸기 때문에 매 요청마다 이 번거로운 핸드쉐이크를 거쳐야 했다. 그래서 HTTP/2에서는 핸드쉐이크를 최소화하기 위해서 단일 TCP 연결을 유지하면서 여러 개의 요청을 처리할 수 있도록 변경된 것이다.</p>\n<p>결국 HTTP/1에서 HTTP/2로 넘어갈 때도 핸드쉐이크 과정 자체는 건드리지 않았고 단지 핸드쉐이크가 발생하는 횟수를 최소화함으로써 레이턴시를 줄인 것이다. 이는 TCP를 사용하는 이상 핸드쉐이크가 반드시 필요한 과정이기 때문에 건드리지 못한 것이다.</p>\n<p>그러나 HTTP/3는 UDP를 사용함으로써 이 핸드쉐이크 과정 자체를 날려버리고 다른 방법으로 연결의 신뢰성을 확보함으로써 레이턴시를 줄이는 방법을 택했다.</p>\n<h3 id=\"holbhead-of-line-blocking\" style=\"position:relative;\">HOLB(Head of line Blocking)<a href=\"#holbhead-of-line-blocking\" aria-label=\"holbhead of line blocking permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그 외에도 TCP를 사용하는 기존의 HTTP에는 한 가지 문제가 더 있는데, 바로 HOLB(Head of Line Blocking)라고 하는 문제이다. 사실 HTTP 레벨에서의 HOLB와 TCP 레벨에서의 HOLB는 다른 의미이기는 하나 결국 어떤 요청에 병목이 생겨서 전체적인 레이턴시가 늘어난다는 맥락으로 본다면 동일하다고 할 수 있다.</p>\n<p>TCP를 사용한 통신에서 패킷은 무조건 정확한 순서대로 처리되어야 한다. 수신 측은 송신 측과 주고받은 시퀀스 번호를 참고하여 패킷을 재조립해야하기 때문이다.</p>\n<p>그래서 통신 중간에 패킷이 손실되면 완전한 데이터로 다시 조립할 수 없기 때문에 절대로 그냥 넘어가지 않는다. 무조건 송신 측은 수신 측이 패킷을 제대로 다 받았다는 것을 확인한 후, 만약 수신 측이 제대로 패킷을 받지 못했으면 해당 패킷을 다시 보내야 한다.</p>\n<p>또한 패킷이 처리되는 순서 또한 정해져있으므로 이전에 받은 패킷을 파싱하기 전까지는 다음 패킷을 처리할 수도 없다. 이렇게 패킷이 중간에 유실되거나 수신 측의 패킷 파싱 속도가 느리다면 통신에 병목이 발생하게 되는 현상을 “HOLB”라고 부르는 것이다. 이건 TCP 자체의 문제이므로 HTTP/1 뿐만 아니라 HTTP/2도 가지고 있는 문제이다.</p>\n<p>이런 문제들을 해결하기 위해 HTTP/3는 UDP를 기반으로 만들어진 프로토콜인 QUIC 위에서 작동하는 것을 선택한 것이다. 그럼 이제 QUIC가 정확히 어떤 프로토콜인지, UDP를 사용한다는 것이 TCP에 비해서 어떤 장점이 있다는 것인지를 알아보자.</p>\n<h2 id=\"http3가-udp를-사용하는-이유\" style=\"position:relative;\">HTTP/3가 UDP를 사용하는 이유<a href=\"#http3%EA%B0%80-udp%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"http3가 udp를 사용하는 이유 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>HTTP/3는 QUIC을 기반으로 돌아가는 프로토콜이기 때문에 우리가 HTTP/3를 이해하려면 QUIC에 초점을 맞춰야 한다. QUIC은 TCP가 가지고 있는 이런 문제들을 해결하고 레이턴시의 한계를 뛰어넘고자 구글이 개발한 UDP 기반의 프로토콜이다.</p>\n<p>QUIC은 처음부터 TCP의 핸드쉐이크 과정을 최적화하는 것에 초점을 맞추어 설계되었고, UDP를 사용함으로써 이를 실현해낼 수 있었다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/e8950/quic.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC3klEQVR42o1U/UuTURT2H4gI+iGTgqB+S5McFqlJZDaz0LK0NHSpSYkmlbNiH1okiC00h6SULjQykrWK/MyVpqFoUzIlNXP4rdkHfmzpdren+95t2mxbXTjcc+8553mfe597XjcAC86MEOJy/YfNUTNTq3eDk2E2m9k8O69DQ1sX5nR6u/1VucTqNrs5A1oyGFHV1IYD0Slw38lHcEwq6lo6/spzCWhL0v1axCNVDbb5H8WWM2Lwyt9ia4IEG31CEHvxBj4OaO3yHQISk4nNlbWNOJYsQux1OQIq3oHXoIVPqRretYPg0dmDL8Am/wg8a2hZrnMMSCyAIlkx1vidgG/TGHaUqBEnkiFbdhfh6TnwftCIXXTf/aAA4tvF1jriGlCadx/r/I5jj6oLPGUnAkUFEOYWoVjxGOICBUIVdVgbEIVMmucS0GQ98vuefuyLuYANu8OwXVIEn5p+eKk+4EihElLKPrdQAQkF0/QMWOvM/xZlnj6RgjIlPPdHwSM4Dl6Z97CeHtPrsACvWjv/X2X2RZpoYzsyNYNLN+XwDDoJYbYco5Nfl0/DMXMKaDQa6bszMDMaLTFuNlkUxMTMj+VXwOXY2Blo3aKlzjnD1VdgY8sxMjnoEocMa5vbkZyVTy0P1bQ7uPHpyzCKKl4wv6SyCh3dfcyXlz/F1Mx35iuUNUgQ3YL0jmIFUE+7IiA6FWWqOjx8Xg/fiHMs8rpVg9CzV5gfmZbFYtwIPJ0G7dgkej9rWZ2qvhnqVs0K4NyCHv6nUjAyMY3x6W8IElxmkTf0h8BPyGB3GU47p+Klmu3z44VMHE1vP0ISM8ARon1vd2STJL+U0CA5lHSVbN4bSdq7+8jP2XkSK8wmYedFJCJVSgaHx4mRvuL4azmEMiQLOj1JFOWS4Ph0kiSWLVlFb2R3aLaagXZLS2cPhkYnV0Qxc7Nz4bg4FcyO4RDVcQirjJKxW1O1Xa0HqXEsnvwGZ3Pl7+F/khcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"quic\" title=\"\" src=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/6af66/quic.png\" srcset=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/69538/quic.png 160w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/72799/quic.png 320w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/6af66/quic.png 640w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/d9199/quic.png 960w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/21b4d/quic.png 1280w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/e8950/quic.png 2000w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>UDP는 User Datagram Protocol이라는 이름에서도 알 수 있듯이 데이터그램 방식을 사용하는 프로토콜이기 때문에 애초에 각각의 패킷 간의 순서가 존재하지 않는 독립적인 패킷을 사용한다. 또한 데이터그램 방식은 패킷의 목적지만 정해져있다면 중간 경로는 어딜 타든 신경쓰지 않기 때문에 종단 간의 연결 설정 또한 하지 않는다. 즉, 핸드쉐이크 과정이 필요없다는 것이다.</p>\n<p>결론적으로 UDP는 TCP가 신뢰성을 확보하기 위해 거치던 많은 과정을 거치지 않기 때문에 속도가 더 빠를 수 밖에 없다는 것인데, 그렇다면 UDP를 사용하게되면 기존의 TCP가 가지던 신뢰성과 패킷의 무결함도 함께 사라지는 걸까?</p>\n<p>아니 그렇지 않다. UDP를 사용하더라도 기존의 TCP가 가지고 있던 기능을 전부 구현할 수 있다. UDP의 진짜 장점은 바로 커스터마이징이 용이하다는 것이기 때문이다.</p>\n<h3 id=\"udp는-하얀-도화지-같은-프로토콜이다\" style=\"position:relative;\">UDP는 하얀 도화지 같은 프로토콜이다<a href=\"#udp%EB%8A%94-%ED%95%98%EC%96%80-%EB%8F%84%ED%99%94%EC%A7%80-%EA%B0%99%EC%9D%80-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%B4%EB%8B%A4\" aria-label=\"udp는 하얀 도화지 같은 프로토콜이다 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>필자는 학교에서 UDP와 TCP의 가장 큰 차이점으로 “UDP는 TCP보다 신뢰성이 없는 대신 빠르다”라고 배웠었는데, 사실 이 말은 반은 맞고 반은 틀리다.</p>\n<p>왜냐면 애초에 UDP는 데이터 전송을 제외한 그 어떤 기능도 정의되어 있지 않은 프로토콜이기 때문에 프로토콜 자체적으로 신뢰성을 보장하지 않는 것은 맞지만, 다르게 말하자면 데이터 전송 기능을 제외한 아무 기능이 없는 백지 상태의 프로토콜이라고도 할 수 있기 때문이다. TCP가 신뢰성있는 연결과 혼잡 제어 등을 위해 얼마나 많은 기능을 가지고 있는 지는 TCP의 헤더를 보면 대충 각이 나온다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ac69210c44cd473bcb737665d590b124/c7bb6/tcp-header.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 33.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABWUlEQVR42j2P147CMBRE8/9/x4IQkEKq4zi9YofA7NjS7sOR43jKvV6YSMh2xbJs6PoR47Rg5vc0rxjGGbKq8fADVKpx/5q2d5o/rKbtBvTDhO2l4V0fCcK0gpAKWSGRCYkozvBMcqR5ibQoIVWLsmrce5wWjuvNx+0RIMkEYmr9KEHbD/ByoVz7/j6gzU4M20ZOucLsb9cqK4W8ENTVWLeXo6N5GCfnsTpNzL7DS3PJ9hrLurmQhUyzXWfGwDWSNEMYPSFK6mQFVTeuxIZuRGuDF9mIYbib0K7UsLHuejwZkNEsaVRtB9W06DiJOQ4c3y/eZKXZvlv9y05ntyOGeGFcoMwKHFxTM0A3HaoogopjTJxoYvggSow8F65uTxGEKMOIuif6vIC2wSw23MwTNSdIUnx9H0cQ4BOG2Pk9ns+O6XJx9KfT/338OaPjXd/v+LLcej7WrxR+AYjFDnQh+N9MAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tcp header\" title=\"\" src=\"/static/ac69210c44cd473bcb737665d590b124/6af66/tcp-header.png\" srcset=\"/static/ac69210c44cd473bcb737665d590b124/69538/tcp-header.png 160w,\n/static/ac69210c44cd473bcb737665d590b124/72799/tcp-header.png 320w,\n/static/ac69210c44cd473bcb737665d590b124/6af66/tcp-header.png 640w,\n/static/ac69210c44cd473bcb737665d590b124/d9199/tcp-header.png 960w,\n/static/ac69210c44cd473bcb737665d590b124/21b4d/tcp-header.png 1280w,\n/static/ac69210c44cd473bcb737665d590b124/c7bb6/tcp-header.png 1986w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>이미 정보들이 뚱뚱하게 들어찬 TCP의 헤더</small>\n</center>\n<p>TCP의 경우 워낙 오래 전에 설계되기도 했고, 이런 저런 기능이 워낙 많이 포함된 프로토콜이다보니 이미 헤더가 거의 풀방이다. TCP에 기본적으로 정의되어 있는 기능 외에 다른 추가 기능을 구현하고 싶다면 가장 하단에 있는 <code class=\"language-text\">옵션(Options)</code> 필드를 사용해야 하는데, 옵션 필드도 무한정 배당 해줄 수는 없으니 최대 크기를 <code class=\"language-text\">320 bits</code>로 정해놓았다.</p>\n<p>그러나 TCP의 단점을 보완하기 위해 나중에 정의된 <code class=\"language-text\">MSS(Maximum Segment Size)</code>, <code class=\"language-text\">WSCALE(Window Scale factor)</code>, <code class=\"language-text\">SACK(Selective ACK)</code> 등 많은 옵션들이 이미 옵션 필드를 차지하고 있기 때문에 실질적으로 사용자가 커스텀 기능을 구현할 수 있는 자리는 거의 남지도 않았다.</p>\n<p>반면 UDP는 데이터 전송 자체에만 초점을 맞추고 설계되었기 때문에 헤더에 진짜 아무 것도 없다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/73dae/udp-header.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 13.750000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAq0lEQVR42j2O226DMBAF+f/P60vTkNoO2GAuBoxNopJEky1S+zDSzh7tpVCVx0+ZdLszxcSSNtbtfhDzjXlN6KpGXesjiykTpoW4Zqm3gzmuTHNkkfnio3Qo7QjW4U1Nf7U0yqBOZ5pvg9cVvfQ7wTUdVqidp7Ytn6eS8qKxbU8l/kvRjYEwjOxy5WeJPOSjLN5q8+9/2T6OPIVXCOz9QPt1Zjbm8KfseQwDb9HI4QyOb6OzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"udp header\" title=\"\" src=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/6af66/udp-header.png\" srcset=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/69538/udp-header.png 160w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/72799/udp-header.png 320w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/6af66/udp-header.png 640w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/d9199/udp-header.png 960w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/21b4d/udp-header.png 1280w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/73dae/udp-header.png 2122w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>TCP와 비교해보면 확실히 휑한 UDP의 헤더</small>\n</center>\n<p>UDP의 헤더에는 출발지와 도착지, 패킷의 길이, 체크섬 밖에 없다. 이때 체크섬은 패킷의 무결성을 확인하기 위해 사용되는데, TCP의 체크섬과는 다르게 UDP의 체크섬은 사용해도 되고 안해도 되는 옵션이다.</p>\n<p>즉, UDP 프로토콜 자체는 TCP보다 신뢰성이 낮기도 하고 흐름 제어도 안되지만, 이후 개발자가 어플리케이션에서 구현을 어떻게 하냐에 따라서 TCP와 비슷한 수준의 기능을 가질 수도 있다는 것이다.</p>\n<p>물론 TCP가 신뢰성을 확보하기위해 이런 저런 기능을 제공해주는 것이 개발자 입장에서는 편하고 좋지만, 한가지 슬픈 점은 이 기능들이 프로토콜 자체에 정의된 필수 과정이라서 개발자가 맘대로 커스터마이징 할 수 없다는 것이다. 결국 여기서 발생하는 레이턴시들을 어떻게 더 줄여볼 시도조차 하기 힘들다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e0bf6f0a79b033925a91b04e4653d7af/e2310/tcp-tls.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 102.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAADtklEQVR42s2TbUxTVxjHsWwuRMbclmWGKZoN3USigsFJ1A9kWZZJsixmbPHLFr84i2lLaUtf0uaEVpcimkDGQjYVBTK23ESBZnTicLp0AtG2lL5cyu1tb+9tb6G0lHaoHVR6dm4DRnRu9sOSneRJ7n2ec375n/P8n5yc/3IJBIICoVC4VSqVviWRSDbX1dW9WV9fvwnlihoaGjbKZLJCPp+/icuLRKL1y7XX0dE1q0AYBnO5UCi+elUuB1sAABuXgeUItEOr1W7V6XSb1Wr1dg4gFovfUCj4LwOgL5LJQCGEMBfFc6uhN0C+sllZqmxVvsb9Awh5T7sJBA9rPK1Wv0MJwDurNty5M9kyMkzYzL/jt1wW0jwViQ5csAY+PKb/9iUPjpcHg8GjDMMcpWm6hts/KLlcCnJq1vqmUx8RzPwEPX3PNhVJVj0Edl2yD7WfGoEXVFdT174zw5nYQqSfjB/JqEkmtyDYCYIgakmSPIYxWF5Pbc+7bvsUFp39M3U/uZRegjAdu5uC1vEZUQbonIgPOYgktDHzKR99D17rsET7iOgn3cbRAjYQEPn9/hORSIQfDoWlOIl/0S3o3nf7FiO1k3+kTWb2wc1RJm3xJhZ/tYU/yABn5lP6u6kl08JS2hhL3L9uHqaw86OB6isDv2xDykQul+szpPJjpPBIcDpY2av6abegWPDCb65Eo2ViDjqJWMpiC9X//YNDmLGA6opzby1oy08kIm+zLNuAVMpCodCXXK1H3ldmbDUWcN9zc3D3/AIs5c4hd/BWIJm2c2E2w+e5nOZHR8U57OorLEsfQCA+RVHHUVOOOwlnyQ+NvQe7JF3rHhPC+0eFwnOWnSMWx3afz/cNUncKx3Hd+Ph4u5/xSzvVxrK2Wiz/ETG5T52WFaCmw1oRjieLY+Hwrng8vndxcbECXf2g1z9Z/XO36dOaErD2mcZv5R1Of2+vnJ6Jtnk9nkuoGc1ut/uM3W4/zYYCHe7bDHhi3P5NoeKMaU9np6Fo0uU6xCmbnZ3dj6xTheobWoT9O8/L+l7MCqhqGiqn6UghgjUiy+i9Xq+OcBOtoXDg8681hspmyeC6rIBy7c0yg8FUhOPOk6jDOnRlDUGQzYEQdbhJZihvAzfyswJqNIN7jEaigKI8VUhdNTL3IYfNcdiOW99vaex976x4OC8roFp+fZfTSpSQpAfzeDw9KNopyt8ZYOm6JtXQsytEyAwQKAa2XbyIbRgbG1u/bHreit+Aor/4rBjLy/k/rDXZnvgLm+tNcqo265oAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tcp tls\" title=\"\" src=\"/static/e0bf6f0a79b033925a91b04e4653d7af/6af66/tcp-tls.png\" srcset=\"/static/e0bf6f0a79b033925a91b04e4653d7af/69538/tcp-tls.png 160w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/72799/tcp-tls.png 320w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/6af66/tcp-tls.png 640w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/d9199/tcp-tls.png 960w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/e2310/tcp-tls.png 968w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>TCP에 TLS까지 사용한다면 통신을 시작하기도 전에 이렇게 많은 과정을 거쳐야 한다</small>\n</center>\n<p>결국 레이턴시를 줄이려면 프로토콜 외적인 것들을 건드려야 하는데, 위에서 이야기 했듯이 일반적인 개발자가 통신 과정에서 건드릴 수 있는 영역은 한계가 있기 때문에 이 또한 어려운 것이 사실이다.<small>(통신 업계의 큰 손 형님들이 인프라를 깔아주시는 걸 기다리자)</small></p>\n<p>아직 TCP와 UDP의 차이가 잘 와닿지 않는다면 “좋은 기능이 다 들어있는 무거운 라이브러리”와 “필요한 기능만 들어있는 가벼운 라이브러리”로 비교해보면 조금 더 이해가 빠를 것 같다.</p>\n<p>예를 들어 JavaScript 진영에서 많이 사용하는 <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"nofollow\">lodash</a>와 같은 라이브러리는 기능은 무궁무진하고 사용자에게 큰 편리함을 주지만, 보통 lodash의 모든 메소드를 다 사용하는 사람은 많지 않을 것이다. 결국 편하긴 하지만 내가 사용하지 않는 기능까지 전부 내 JS 번들에 포함시켜야 한다는 부담이 있다.</p>\n<p>반면 단순한 하나의 기능을 제공하는 라이브러리는 lodash보다 기능은 많지 않아도 내가 원하는 부분만 쏙쏙 골라서 사용할 수 있다는 장점이 있다. 하지만 해당 라이브러리에서 지원하지 않는 기능은 직접 구현해야하는 번거로움이 있을 수도 있다. 이때 lodash와 같은 만능 라이브러리가 TCP, 하나의 기능만 제공하는 작은 라이브러리가 UDP인 것이다.</p>\n<p>이렇듯 구글이 QUIC을 만들 때 UDP를 선택한 이유에는 기존의 TCP를 수정하기가 어려운데다가, 백지 상태나 다름 없는 UDP를 사용함으로써 QUIC의 기능을 확장하기 쉽다고 생각했기 때문이라는 것도 있다.</p>\n<h2 id=\"http3가-udp를-사용함으로써-기존-프로토콜보다-나아진-점\" style=\"position:relative;\">HTTP/3가 UDP를 사용함으로써 기존 프로토콜보다 나아진 점<a href=\"#http3%EA%B0%80-udp%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8-%EA%B8%B0%EC%A1%B4-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EB%B3%B4%EB%8B%A4-%EB%82%98%EC%95%84%EC%A7%84-%EC%A0%90\" aria-label=\"http3가 udp를 사용함으로써 기존 프로토콜보다 나아진 점 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지금까지 HTTP/3의 뼈대로 사용되는 QUIC이 왜 TCP가 아닌 UDP를 사용했는지 간략하게 알아보았다. 그렇다면 실제로 UDP를 사용함으로써 얻는 이득에는 무엇이 있을까? 진짜로 HTTP/3는 UDP를 사용함으로써 기존의 HTTP + TCP + TLS를 사용했던 방법보다 더 좋아진 것 일까?</p>\n<p>그에 대한 해답은 Chromium Projects의 <a href=\"https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit\" target=\"_blank\" rel=\"nofollow\">QUIC Overview</a>라는 문서에서 찾을 수 있었다. 한번 구글이 이야기하는 QUIC의 장점에 대해서 살펴보자.</p>\n<h3 id=\"연결-설정-시-레이턴시-감소\" style=\"position:relative;\">연결 설정 시 레이턴시 감소<a href=\"#%EC%97%B0%EA%B2%B0-%EC%84%A4%EC%A0%95-%EC%8B%9C-%EB%A0%88%EC%9D%B4%ED%84%B4%EC%8B%9C-%EA%B0%90%EC%86%8C\" aria-label=\"연결 설정 시 레이턴시 감소 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3 Way Handshake 과정을 거치지 않아도 된다. 클라이언트가 보낸 요청을 서버가 처리한 후 다시 클라이언트로 응답해주는 사이클을 “RTT(Round Trip Time)“라고 하는데, TCP는 연결을 생성하기 위해 기본적으로 1 RTT가 필요하고, 여기에 TLS를 사용한 암호화까지 하려고 한다면 TLS의 자체 핸드쉐이크까지 더해져 총 3 RTT가 필요하다.</p>\n<p>반면 QUIC은 첫 연결 설정에 1 RTT만 소요된다. 클라이언트가 서버에 어떤 신호를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할 수 있다는 것이다. 즉, 연결 설정에 소요되는 시간이 반 정도 밖에 안된다.</p>\n<center>\n  <img src=\"/95f5c7e411d0b7f96d182abe284be551/gcp-cloud-cdn-performance.gif\" width=\"100%\">\n  <br>\n</center>\n<p>어떻게 이게 가능한 걸까? 그 이유는 생각보다 간단하다. 첫번째 핸드쉐이크를 거칠 때, 연결 설정에 필요한 정보와 함께 데이터도 보내버리는 것이다. TCP + TLS는 데이터를 보내기 전에 신뢰성있는 연결과 암호화에 필요한 모든 정보를 교환하고 유효성을 검사한 뒤에 데이터를 교환하지만, QUIC은 묻지도 따지지도 않고 그냥 바로 데이터부터 꽂아버리고 시작한다.</p>\n<p>이 과정에 대해서는 2015년 IEEE Symposium에서 발표된 ”<a href=\"https://youtu.be/vXgbPZ-1-us\" target=\"_blank\" rel=\"nofollow\">How Secure and Quick is QUIC?</a>“이라는 세션에서 자세히 들어볼 수 있다.</p>\n<p><div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.49999999999999%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <div class=\"embedVideo-container\"> <iframe title=\"\" src=\"https://www.youtube.com/embed/vXgbPZ-1-us?rel=0\" class=\"embedVideo-iframe\" style=\"border:0; position: absolute; top: 0; left: 0; width: 100%; height: 100%; \" loading=\"eager\" allowfullscreen=\"\" sandbox=\"allow-same-origin allow-scripts allow-popups\"></iframe> </div> </div></p>\n<center>\n  <small>3분 33초 부터 보도록 하자.<br />한 손 주머니에 꽂고 발표하는 모습에서 스웩이 넘친다</small>\n  <br />\n  <br />\n</center>\n<p>결국 이 영상에서 말하고자 하는 것은 TCP + TLS는 서로 자신의 세션 키를 주고 받아 암호화된 연결을 성립하는 과정을 거치고 나서야 세션 키와 함께 데이터를 교환할 수 있지만, QUIC은 서로의 세션 키를 교환하기도 전에 데이터를 교환할 수 있기 때문에 연결 설정이 더 빠르다는 것이다.</p>\n<p>단, 클라이언트가 서버로 첫 요청을 보낼 때는 서버의 세션 키를 모르는 상태이기 때문에 목적지인 서버의 Connection ID를 사용하여 생성한 특별한 키인 초기화 키(Initial Key)를 사용하여 통신을 암호화 한다. 이 과정에 대한 자세한 설명은 QUIC 작업 그룹의 <a href=\"https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2\" target=\"_blank\" rel=\"nofollow\">Using TLS to Secure QUIC</a> 문서에서 확인 해볼 수 있다.</p>\n<p>그리고 한번 연결에 성공했다면 서버는 그 설정을 캐싱해놓고 있다가, 다음 연결 때는 캐싱해놓은 설정을 사용하여 바로 연결을 성립시키기 때문에 0 RTT만으로 바로 통신을 시작할 수도 있다. 이런 점들 때문에 QUIC은 기존의 TCP+TLS 방식에 비해 레이턴시를 더 줄일 수 있었던 것이다.</p>\n<p>참고로 이 세션이 발표될 당시에는 TLS 1.3이 나오기 전이라 따로 언급이 되지 않았지만, 지금은 TCP Fast Open과 TLS 1.3을 사용하여 QUIC와 비슷한 과정을 통해 연결을 설정함으로써 TCP를 사용하더라도 동일한 이점을 가져갈 수도 있긴하다.</p>\n<p>그러나 TCP SYN 패킷은 한 패킷당 약 <code class=\"language-text\">1460 Byte</code>만 전송할 수 있도록 제한하지만 QUIC은 데이터 전체를 첫 번째 라운드 트립에 포함해서 전송할 수 있기 때문에 주고 받아야할 데이터가 큰 경우에는 여전히 QUIC가 유리하다고 할 수 있다.</p>\n<h3 id=\"패킷-손실-감지에-걸리는-시간-단축\" style=\"position:relative;\">패킷 손실 감지에 걸리는 시간 단축<a href=\"#%ED%8C%A8%ED%82%B7-%EC%86%90%EC%8B%A4-%EA%B0%90%EC%A7%80%EC%97%90-%EA%B1%B8%EB%A6%AC%EB%8A%94-%EC%8B%9C%EA%B0%84-%EB%8B%A8%EC%B6%95\" aria-label=\"패킷 손실 감지에 걸리는 시간 단축 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>QUIC도 TCP와 마찬가지로 전송하는 패킷에 대한 흐름 제어를 해야한다. 왜냐면 QUIC든 TCP든 결국 본질적으로는 ARQ 방식을 사용하는 프로토콜이기 때문이다. 통신과정에서 발생한 에러를 어떻게 처리할 것인지를 이야기하는 것인데, ARQ 방식은 에러가 발생하면 재전송을 통해 에러를 복구하는 방식을 말하는 것이다.</p>\n<p>TCP는 여러 ARQ 방식 중에서 “Stop and Wait ARQ” 방식을 사용하고 있다. 이 방식은 송신 측이 패킷을 보낸 후 타이머를 사용하여 시간을 재고, 일정 시간이 경과해도 수신 측이 적절한 답변을 주지 않는다면 패킷이 손실된 것으로 판단하고 해당 패킷을 다시 보내는 방식이다.</p>\n<p>우선 2017년 구글에서 발표한 <a href=\"https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1\" target=\"_blank\" rel=\"nofollow\">QUIC Loss Detection and Congestion Control</a>에 따르면, QUIC은 기본적으로 TCP와 유사한 방법으로 패킷 손실을 탐지하나, 몇 가지 개선 사항을 추가한 것으로 보인다.</p>\n<p>TCP에서 패킷 손실 감지에 대한 대표적인 문제는 송신 측이 패킷을 수신측으로 보내고 난 후 얼마나 기다려줄 것인가, 즉 타임 아웃을 언제 낼 것인가를 동적으로 계산해야한다는 것이다. 이때 이 시간을 RTO(Retransmission Time Out)라고 하는데, 이때 필요한 데이터가 바로 RTT(Round Trip Time)들의 샘플들이다.</p>\n<p>한번 패킷을 보낸 후 잘 받았다는 응답을 받을 때 걸렸던 시간들을 측정해서 동적으로 타임 아웃을 정하는 것이다. 즉, RTT 샘플을 측정하기 위해서는 반드시 송신 측으로 부터 ACK를 받아야하는데, 정상적인 상황에서는 딱히 문제가 없으나 타임 아웃이 발생해서 패킷 손실이 발생하게 되면 RTT 계산이 애매해진다.</p>\n<blockquote>\n<p>패킷 전송 -> 타임 아웃 -> 패킷 재전송 -> ACK 받음!<br />\n<small>(근데 이거 첫 번째로 보낸 패킷의 ACK야? 두 번째로 보낸 패킷의 ACK야?)</small></p>\n</blockquote>\n<p>이때 이 ACK가 어느 패킷에 대한 응답인지 알기 위해서는 타임스탬프를 패킷에 찍어주는 등 별도의 방법을 또 사용해야하고, 또 이를 위한 패킷 검사도 따로 해줘야 한다. 이를 재전송 모호성(Retransmission Ambiguity)이라고 한다.</p>\n<p>이 문제를 해결하기 위해 QUIC는 헤더에 별도의 패킷 번호 공간을 부여했다. 이 패킷 번호는 패킷의 전송 순서 자체만을 나타내며, 재전송시 동일한 번호가 전송되는 시퀀스 번호와는 다르게 매 전송마다 모노토닉하게 패킷 번호가 증가하기 때문에, 패킷의 전송 순서를 명확하게 파악할 수 있다.</p>\n<p>TCP의 경우 타임스탬프를 사용할 수 있는 상황이라면 타임스탬프를 통해 패킷의 전송 순서를 파악할 수 있지만, 만약 사용할 수 없는 경우 시퀀스 번호에 기반하여 암묵적으로 전송 순서를 추론할 수 밖에 없지만, QUIC는 이런 불필요한 과정을 패킷마다 고유한 패킷 번호를 통해 타파함으로써 패킷 손실 감지에 걸리는 시간을 단축할 수 있었다.</p>\n<p>이 외에도 QUIC는 대략 5가지 정도의 기법을 사용하여 이 패킷 손실 감지에 걸리는 시간을 단축시켰는데, 자세한 내용은 <a href=\"https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1\" target=\"_blank\" rel=\"nofollow\">QUIC Loss Detection and Congestion Control</a>의 “3.1 Relevant Differences Between QUIC and TCP” 챕터를 한번 읽어보는 것을 추천한다.</p>\n<h3 id=\"멀티플렉싱을-지원\" style=\"position:relative;\">멀티플렉싱을 지원<a href=\"#%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1%EC%9D%84-%EC%A7%80%EC%9B%90\" aria-label=\"멀티플렉싱을 지원 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>멀티플렉싱(Multiplexing)은 위에서 TCP의 단점으로 언급했던 HOLB를 방지하기 때문에 매우 중요하다. 여러 개의 스트림을 사용하면, 그 중 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 굴릴 수 있기 때문이다.</p>\n<p>참고로 멀티플렉싱은 여러 개의 TCP 연결을 만든다는 의미가 아니라, 단일 연결 안에서 몇 가지 얌생이를 사용하여 여러 개의 데이터를 섞이지 않게 보내는 기법이다. 이때 각각의 데이터의 흐름을 스트림(Stream)이라고 하는 것이다.</p>\n<p>HTTP/1의 경우는 하나의 TCP 연결에 하나의 스트림만 사용하기 때문에 HOLB 문제에서 벗어날 수 없었다. 또한 한번의 전송이 끝나게 되면 연결이 끊어지기 때문에 다시 연결을 만들기 위해서는 번거로운 핸드쉐이크 과정을 또 겪어야 했다.</p>\n<p>비록 <code class=\"language-text\">keep-alive</code> 옵션을 통해 어느 정도의 시간 동안 연결을 유지할 수는 있지만 결국 일정 시간 안에 액세스가 없다면 연결이 끊어지게 되는 것은 똑같다.</p>\n<p>그리고 HTTP/2는 하나의 TCP 연결 안에서 여러 개의 스트림을 처리하는 멀티플렉싱 기법을 도입하여 성능을 끌어올린 케이스이다. 이 경우 한번의 TCP 연결로 여러 개의 데이터를 전송할 수 있기 때문에 핸드쉐이크 횟수도 줄어들게 되어 효율적인 데이터 전송을 할 수 있게 된다.</p>\n<center>\n  <img src=\"/40cb0bc1d62eba25c2e351d213d1700d/multiplexing.svg\">\n  <br>\n  <small>HTTP/3도 HTTP/2와 같은 멀티플렉싱을 지원한다.</small>\n  <br>\n  <br>\n</center>\n<p>QUIC 또한 HTTP/2와 동일하게 멀티플렉싱을 지원하기 때문에, 이런 이점을 그대로 가져가고 있다. 혹여나 하나의 스트림에서 문제가 발생한다고 해도 다른 스트림은 지킬 수 있게 되어 이런 문제에서 자유로울 수 있다.</p>\n<h3 id=\"클라이언트의-ip가-바뀌어도-연결이-유지됨\" style=\"position:relative;\">클라이언트의 IP가 바뀌어도 연결이 유지됨<a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%9D%98-ip%EA%B0%80-%EB%B0%94%EB%80%8C%EC%96%B4%EB%8F%84-%EC%97%B0%EA%B2%B0%EC%9D%B4-%EC%9C%A0%EC%A7%80%EB%90%A8\" aria-label=\"클라이언트의 ip가 바뀌어도 연결이 유지됨 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>TCP의 경우 소스의 IP 주소와 포트, 연결 대상의 IP 주소와 포트로 연결을 식별하기 때문에 클라이언트의 IP가 바뀌는 상황이 발생하면 연결이 끊어져 버린다. 연결이 끊어졌으니 다시 연결을 생성하기 위해 결국 눈물나는 3 Way Handshake 과정을 다시 거쳐야한다는 것이고, 이 과정에서 다시 레이턴시가 발생한다.</p>\n<p>게다가 요즘에는 모바일로 인터넷을 사용하는 경우가 많기 때문에 Wi-fi에서 셀룰러로 전환되거나 그 반대의 경우, 혹은 다른 Wi-fi로 연결되는 경우와 같이 클라이언트의 IP가 변경되는 일이 굉장히 잦아서 이 문제가 더 눈에 띈다.</p>\n<p>반면 QUIC은 Connection ID를 사용하여 서버와 연결을 생성한다. Connection ID는 랜덤한 값일 뿐, 클라이언트의 IP와는 전혀 무관한 데이터이기 때문에 클라이언트의 IP가 변경되더라도 기존의 연결을 계속 유지할 수 있다. 이는 새로 연결을 생성할 때 거쳐야하는 핸드쉐이크 과정을 생략할 수 있다는 의미이다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>사실 HTTP/3와 QUIC을 제대로 설명하기 위해서는 네트워크에 대한 기본 개념들이 필수적으로 동반되야하기 때문에 이 짧은 포스팅 만으로 세부적인 설명을 하기 힘든 부분이 있었다. 최대한 자세하게 작성해보려고 했지만 생각보다 글이 너무 길어지게 되어서 분량 조절을 조금 하려고 한다.</p>\n<p>이번에 HTTP/3를 공부해보고 여러가지 자료를 찾아보면서 느낀 점은 “뭐가 이렇게 많이 바뀌었어?” 였던 것 같다. 일단 TCP부터 갖다 버렸으니 뭐가 많이 바뀔만 하긴 했지만, HTTP/2를 사용해본지도 몇 달 밖에 되지 않은 필자의 입장에서는 조금 당황스럽기는 했다. <small>(HTTP를 만든다면서 TCP를 갖다 버린 건 아직도 신기하다)</small></p>\n<p>사실 개발자들이 HTTP/2를 사용하든 HTTP/3를 사용하든 한국에서 인터넷을 사용하고 있는 사용자는 별로 큰 차이를 못 느낄 것이다. 한국은 워낙 땅덩이도 작고 통신 인프라도 좋다보니 핸드쉐이크 레이턴시고 나발이고 그냥 인프라로 대충 커버칠 수 있지만, 그래도 상대적으로 통신 인프라가 빈약한 나라의 경우에는 꽤 큰 차이가 느껴질 수도 있을 것 같다.</p>\n<p>필자가 이 포스팅에서는 HTTP/3와 UDP의 장점만을 이야기했지만, 사실 많은 사람들이 TCP를 버리고 UDP로 갈아타는 것에 대해서 걱정하고 있다. 당연히 완벽한 기술이란 없으니 문제도 있을 것이다.</p>\n<p>그러나 기존의 HTTP와 TCP가 가지고 있는 한계를 돌파하기 위한 시도로는 굉장히 좋은 것 같다. 마치 엔비디아의 RTX 시리즈 같은 느낌이랄까.</p>\n<p>이상으로 HTTP/3는 왜 UDP를 선택한 것일까? 포스팅을 마친다.</p>\n<h2 id=\"참고-링크\" style=\"position:relative;\">참고 링크<a href=\"#%EC%B0%B8%EA%B3%A0-%EB%A7%81%ED%81%AC\" aria-label=\"참고 링크 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46403.pdf\" target=\"_blank\" rel=\"nofollow\">The QUIC Transport Protocol: Design and Internet-Scale Deployment</a></li>\n<li><a href=\"https://medium.com/codavel-blog/quic-vs-tcp-tls-and-why-quic-is-not-the-next-big-thing-d4ef59143efd\" target=\"_blank\" rel=\"nofollow\">QUIC vs TCP+TLS - and why QUIC is not the next big thing</a></li>\n<li><a href=\"https://blog.cloudflare.com/http3-the-past-present-and-future/\" target=\"_blank\" rel=\"nofollow\">HTTP/3: the past, the present, and the future</a></li>\n<li><a href=\"https://www.saturnsoft.net/network/2019/03/21/quic-http3-1/\" target=\"_blank\" rel=\"nofollow\">QUIC과 HTTP/3 - 1.UDP기반 전송 프로토콜의 대두</a></li>\n<li><a href=\"https://www.chromium.org/quic\" target=\"_blank\" rel=\"nofollow\">QUIC, a multiplexed stream transport over UDP</a></li>\n<li><a href=\"https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2\" target=\"_blank\" rel=\"nofollow\">Using TLS to Secure QUIC</a></li>\n<li><a href=\"https://blog.cloudflare.com/the-road-to-quic/\" target=\"_blank\" rel=\"nofollow\">The Road to QUIC</a></li>\n</ul>","fields":{"slug":"20191008-what-is-http3","path":"/2019/10/08/what-is-http3/","lang":"ko"},"frontmatter":{"title":"HTTP/3는 왜 UDP를 선택한 것일까?","subTitle":"웹의 표준이 바뀐다. HTTP/3, 빠른 속도를 위해 UDP를 선택하다","date":"Oct 08, 2019","categories":["프로그래밍","네트워크"],"tags":["HTTP3","TCP","UDP","네트워크"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/3a812/thumbnail.jpg","srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/3a812/thumbnail.jpg 320w,\n/static/70cbe98ca5682a8f70aa5afe9a5533ed/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/fc5c5/thumbnail.webp 320w,\n/static/70cbe98ca5682a8f70aa5afe9a5533ed/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/2d839/thumbnail.jpg","srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}},"allMarkdownRemark":{"edges":[{"node":{"id":"aa2d548e-4eb6-5e1b-804f-7cb6a2a8c809","tableOfContents":"<ul>\n<li>\n<p><a href=\"#a-brief-introduction-to-http3\">A Brief Introduction to HTTP/3</a></p>\n</li>\n<li>\n<p><a href=\"#why-is-tcp-considered-slow\">Why Is TCP Considered Slow?</a></p>\n<ul>\n<li><a href=\"#3-way-handshake\">3-Way Handshake</a></li>\n<li><a href=\"#holb-head-of-line-blocking\">HOLB (Head-of-Line Blocking)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#why-http3-uses-udp\">Why HTTP/3 Uses UDP</a></p>\n<ul>\n<li><a href=\"#udp-is-a-blank-canvas\">UDP Is a Blank Canvas</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#how-http3-improves-over-previous-protocols-by-using-udp\">How HTTP/3 Improves Over Previous Protocols by Using UDP</a></p>\n<ul>\n<li><a href=\"#reduced-latency-in-connection-setup\">Reduced Latency in Connection Setup</a></li>\n<li><a href=\"#faster-packet-loss-detection\">Faster Packet Loss Detection</a></li>\n<li><a href=\"#multiplexing-support\">Multiplexing Support</a></li>\n<li><a href=\"#connections-survive-ip-changes\">Connections Survive IP Changes</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#wrapping-up\">Wrapping Up</a></p>\n</li>\n<li>\n<p><a href=\"#references\">References</a></p>\n</li>\n</ul>","excerpt":"HTTP/3 is the third major version of HTTP (Hypertext Transfer Protocol). Unlike HTTP/1 and HTTP/2, it communicates using QUIC, a UDP-based protocol. The biggest difference between HTTP/3 and its predecessors is that it runs on UDP instead of TCP. I first learned about HTTP/3 after reading a post so…","html":"<p>HTTP/3 is the third major version of HTTP (Hypertext Transfer Protocol). Unlike HTTP/1 and HTTP/2, it communicates using QUIC, a UDP-based protocol. The biggest difference between HTTP/3 and its predecessors is that it runs on UDP instead of TCP.</p>\n<p>I first learned about HTTP/3 after reading a post someone shared: <a href=\"https://blog.cloudflare.com/http3-the-past-present-and-future/\" target=\"_blank\" rel=\"nofollow\">HTTP/3: the past, the present, and the future</a>. My honest first reaction when I saw the title was:</p>\n<blockquote>\n<p>Wait, HTTP/2 was only released about 4 years ago. HTTP/3 already? Isn’t it just in the design phase?</p>\n</blockquote>\n<p>But after reading the post, I was surprised to learn that Google Chrome had already shipped a Canary build with HTTP/3 support — it was at the point where you could actually try it. It took roughly 15 years to go from HTTP/1 to HTTP/2, yet just 4 years later, the next major version was already usable.</p>\n<p>On top of that, the global adoption rate of HTTP/2 was still only around 40% at the time. That’s how recent HTTP/2 still was.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABKklEQVR42pWS2W6DMBBF+f8vzAPYHryUBLyw2NikD70JqJGatErR0WgYrrnjsatt287nZO2ntdc3ce46DGVZSjVNM2OjUkXK/BKlnil1HYchVuM4CTEZs2ldjHmBlIXogLHSNIVzLEazsQph5DxApHVu20z0gLFc14gr5ysiaNtVylUpJNH7m/N8OoWmge5QfEN0SLU+QL6/ChGdi9U8L2h73wzMn3neM4pEaXeeOB/3X8LnHaA8nLGYsXAf7P8XL0vkfHp1Hr/yaBt7xrT3tt8EAyO6O6eEwY445D+sftwZiOHsXKq893X9IYQlsm3rhBiI3B0rZUCCT1L6HaVQgcByPvS9h3OKMeacQ/BCcK0VkUBUSgohLpczcmN0132g3nWm7/t8e9aU0hd/j8r0CkmYvgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ce http2\" title=\"\" src=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png\" srcset=\"/static/8a0a69c0fbc05eba2198cd4f552845d4/69538/ce-http2.png 160w,\n/static/8a0a69c0fbc05eba2198cd4f552845d4/72799/ce-http2.png 320w,\n/static/8a0a69c0fbc05eba2198cd4f552845d4/0a47e/ce-http2.png 600w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>HTTP/2 adoption rate as of August 2019, surveyed by W3Techs.com</small>\n</center>\n<p>With programming languages and frameworks, the publisher pushes an update and users upgrade — done. But protocols are agreements, requiring coordination between software vendors, so I assumed such rapid changes wouldn’t happen often.</p>\n<p>Technology moves fast, sure, but HTTP is a foundational web protocol. The fact that such a dramatic change happened in just 4 years was genuinely surprising. (Web developers who had just adopted HTTP/2 a few months earlier were in tears.)</p>\n<p>The other thing that surprised me was that HTTP/3 uses UDP instead of TCP. There’s no rule saying web protocols <em>must</em> use TCP, but from what we learn in school to what we use in practice, HTTP being defined on top of TCP was so deeply ingrained that using UDP felt novel. I couldn’t help but wonder: “Why abandon TCP when it works perfectly fine?”</p>\n<p>Technically, HTTP/3 hadn’t been formally released yet — it was still in the testing phase. But as mentioned above, Chrome already had a Canary build with HTTP/3 support, Mozilla Firefox was planning to support it in Nightly builds soon, and cURL was offering HTTP/3 as an experimental feature. It seemed very likely that HTTP/3 would become the main protocol in the near future.</p>\n<p>If you want to try HTTP/3 in Google Chrome, you can launch it from the terminal with the <code class=\"language-text\">--enable-quic</code> and <code class=\"language-text\">--quic-version=h3-23</code> flags:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">open</span> <span class=\"token parameter variable\">-a</span> Google<span class=\"token punctuation\">\\</span> Chrome <span class=\"token parameter variable\">--args</span> --enable-quic --quic-version<span class=\"token operator\">=</span>h3-23</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/1d6e0c652510ca8a97827fff1fad7575/5a6dd/http3-demo.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60.62500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACTElEQVR42lWRSXPTQBCF/QcgS0EVBwriRIvtaLVkS9Y20mixExNClkMqcQrHCVVw4sbff/S0i5AcXnVP98yn162elBK1rDB2bXiO9azAsxH6ziupWlNLnH1ZIokmnC+Xp8jSGXzXwjTw0Gtuf8NabPA5u4Em7qCVK+jVPd6Fl3jrfsWOd44d95zyc7yxz6i3woFYYZd6ZvMdo24DjWqmvMf7yRV6d7/+IOxuYJfXcOU1jotv+OgI7Bsz7GgRdrUYe5Tvmwl29RjD9Ayf/BZ7lFviAra4hFVcwKmu8MEq0fv5Y4OTroHIE8iygMgSBGQ/Ivtx6CEi+fYQI6PPytOYeyovixRS5BS3bz17gN7m8RGyaZHmAhmplA1yUUFUNeft/BRJlkM3DOi6jiTNEYRTOuvIihJFKSkK5GWFY8sm4GaDum7pYkbAAgXBFFhBgzBEOJnC98cM0zSN76m6rmtIs//3CwJaloXeIzmcL04IULKqmsanr6oLChaEEziuC88bwzBMBoZUM8hxzg4rioLfWDY5fHh4QNvNnyHxLEUQhPB8nx2ocSbTiOoJQ1R/HITsWPUKMrGNNPIxOVyv12jajoGy6Rg2Go34wdHREUuNqpMUMKV9KuemaTKEjRBU7dx2nC2wJtAsyXjctltgfrKE47gMeKntDnNeg/qgWpH4N3Iltzt8enqiP7lgoLqsonIxjWIMBoNXYof049QKTNNgSEnOlFNlRpngHfKBFt/vH+Dw8JBin0dVLl5KOZzQuK7rcT6NY96tihHF4XCEv+fijBWB+5EDAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"http3 demo\" title=\"\" src=\"/static/1d6e0c652510ca8a97827fff1fad7575/6af66/http3-demo.png\" srcset=\"/static/1d6e0c652510ca8a97827fff1fad7575/69538/http3-demo.png 160w,\n/static/1d6e0c652510ca8a97827fff1fad7575/72799/http3-demo.png 320w,\n/static/1d6e0c652510ca8a97827fff1fad7575/6af66/http3-demo.png 640w,\n/static/1d6e0c652510ca8a97827fff1fad7575/5a6dd/http3-demo.png 802w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>The entries showing http/2+quic/46 are connections using the HTTP/3 protocol</small>\n</center>\n<p>As a web developer, I couldn’t just ignore the fact that HTTP was getting a major update. I was also curious about what using UDP actually meant. So I dug into HTTP/3, and this post is a summary of what I found.</p>\n<h2 id=\"a-brief-introduction-to-http3\" style=\"position:relative;\">A Brief Introduction to HTTP/3<a href=\"#a-brief-introduction-to-http3\" aria-label=\"a brief introduction to http3 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>HTTP/3 was originally called “HTTP-over-QUIC.” Mark Nottingham, chair of both the HTTP and QUIC working groups within the IETF (Internet Engineering Task Force), proposed renaming the protocol to HTTP/3. The proposal was accepted in November 2018, and the name changed from HTTP-over-QUIC to HTTP/3.</p>\n<p>In other words, HTTP/3 is HTTP running on top of a protocol called QUIC. QUIC stands for “Quick UDP Internet Connection” — literally, a protocol that establishes internet connections using UDP. (It’s pronounced just like “quick,” by the way.)</p>\n<p>HTTP/3 uses QUIC, and QUIC uses UDP, so we can say HTTP/3 uses UDP.</p>\n<p>So what exactly is QUIC, and why can it achieve faster transmission speeds than TCP? To understand that, we first need to know why TCP is considered slow and what advantages UDP offers.</p>\n<h2 id=\"why-is-tcp-considered-slow\" style=\"position:relative;\">Why Is TCP Considered Slow?<a href=\"#why-is-tcp-considered-slow\" aria-label=\"why is tcp considered slow permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>When I first learned about the differences between TCP and UDP in a networking class, my professor said it would definitely be on the exam, so I memorized this table:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Connection</td>\n<td>Connection-oriented</td>\n<td>Connectionless</td>\n</tr>\n<tr>\n<td>Packet exchange</td>\n<td>Virtual circuit</td>\n<td>Datagram</td>\n</tr>\n<tr>\n<td>Order guarantee</td>\n<td>Guaranteed</td>\n<td>Not guaranteed</td>\n</tr>\n<tr>\n<td>Reliability</td>\n<td>High</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Speed</td>\n<td>Slow</td>\n<td>Fast</td>\n</tr>\n</tbody>\n</table>\n<p>From this table, the takeaway is roughly “TCP is reliable but slow” and “UDP is unreliable but fast.” The “reliability” here refers to whether all data sent by the sender arrives intact at the receiver — by checking packet ordering, detecting packet loss, and so on.</p>\n<p>TCP uses several mechanisms to ensure reliable communication between client and server. But these mechanisms are themselves communications between client and server, so they inevitably add latency. And since these processes have been part of the TCP standard since its inception, you can’t just skip them.</p>\n<p>To reduce latency, you’d need to touch things outside of TCP’s defined features — but there are many constraints. No matter how much you increase bandwidth, the data we need to transmit keeps growing with advancing technology, so things will eventually get slow again. And even if you increase the raw transmission speed, you can’t go faster than the speed of light.</p>\n<p>This is exactly why HTTP/3 chose QUIC, a UDP-based protocol — it opted to modify the protocol itself to overcome these constraints. But TCP is such an old protocol, deeply defined at the low level down to the kernel, that overhauling it would be a massive undertaking. So they chose UDP instead.</p>\n<p>Let’s look at why the mechanisms TCP uses for reliable communication are considered slow.</p>\n<h3 id=\"3-way-handshake\" style=\"position:relative;\">3-Way Handshake<a href=\"#3-way-handshake\" aria-label=\"3 way handshake permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>TCP is an extremely polite protocol. Before starting or ending communication, it always asks whether both sides are ready, establishes packet ordering, and only then begins the actual data transfer.</p>\n<p>The process at the start of communication is called the 3-Way Handshake, and the process at the end is called the 4-Way Handshake. Since the purpose of this post isn’t to cover these in detail, I’ll only explain how the 3-Way Handshake works.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 63.74999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAA9gAAAPYAF6eEWNAAACX0lEQVR42k1S227aQBD1//9EH/LQqhSpJNCE2IAvwXfWxvLd611fARHRgBSJW7A7wEvnYTS7O2fm7JlhTqdz27bb7Ycyldfr9fl8Ph6OTdO0/9nlcjkcDvCUpqltWbvdDhLgyCiKMpnwgiAihBzHCYIA/HK5BExzMwjKspzP557n2bataxrPC7wgTmWZEUW+8/MHxw0JwUmSYJwAvijKe8M7OM/zoijquoaiGGOOe+12O5I0YTx3riqS50Fpa2bOLAuZpllV9b0zwCEAtsPhkGVfx+NxHMfI1gWB8/w5A5TCMABKPM8PBgOWZf88PyfJtfNqtd5sPiAghMg3myGUxFhjPfaXYk19JooSWdaCIPZ93zCN668MI4qK/b5FqAj81R2sqSo8aRpkhqHrz3QjDkOGZdHDw/CpP03iCKGZaRqSJOVZBpjPz/3m7+fHtuUnCc9PBFBVkqIoTlLsuE61qJk0jZGlJ0kI5YG8YRij0SjPr+C5EUQOaY+thzA34uAevmZb9nOH6357El5Epi7r0I/LvAIlQBhCKQTEq067dk3279m+OYPaWYpxlmWQQAn1HM9UjSgIGNVRBmJ/oo+kN1EUhF7vd78/sJTqcmqrugbNrmpj/PjYAy0ty8rynGTE9d2yKpmRMey9dYbqE6UpMAflXc+lWXk8tba9CIJ3AGNMQSdCKDSnlBa0DNxgUS2YZb1c1Svwt03Iq6oCbuAB8/XVnE7NdttOp1TTVF3XLdvGBI8MtjvuyPM3BrZihkzQ2brZdVS6fgffFqy5jYrK8hTmZJowI7037na57y/C4z+QeJZeh7viqwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3way handshake\" title=\"\" src=\"/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png\" srcset=\"/static/dd7f29fecd14fe5feebc6cf562123c48/69538/3way-handshake.png 160w,\n/static/dd7f29fecd14fe5feebc6cf562123c48/72799/3way-handshake.png 320w,\n/static/dd7f29fecd14fe5feebc6cf562123c48/dd45a/3way-handshake.png 550w\" sizes=\"(max-width: 550px) 100vw, 550px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>The 3-Way Handshake process when starting communication</small>\n</center>\n<p>As shown above, when a client first creates a TCP connection to a server, they exchange <code class=\"language-text\">SYN</code> and <code class=\"language-text\">ACK</code> packets. The values inside these packets allow client and server to verify packet ordering and confirm that packets were properly received.</p>\n<p>This process requires 3 round trips of communication. If you’re on macOS or Linux, you can observe this process directly using the <code class=\"language-text\">tcpdump</code> utility in your terminal.</p>\n<p>Note that running <code class=\"language-text\">tcpdump</code> without options will monitor all packets on the device, making it hard to find what you want. So I captured only the communication with a blog server running on loopback:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\">$ <span class=\"token function\">sudo</span> tcpdump <span class=\"token function\">host</span> localhost <span class=\"token parameter variable\">-i</span> lo0\nIP localhost.53920 <span class=\"token operator\">></span> localhost.terabase: Flags <span class=\"token punctuation\">[</span>S<span class=\"token punctuation\">]</span>, <span class=\"token function\">seq</span> <span class=\"token number\">1260460927</span>, win <span class=\"token number\">65535</span>\nIP localhost.terabase <span class=\"token operator\">></span> localhost.53920: Flags <span class=\"token punctuation\">[</span>S.<span class=\"token punctuation\">]</span>, <span class=\"token function\">seq</span> <span class=\"token number\">3009967847</span>, ack <span class=\"token number\">1260460928</span>, win <span class=\"token number\">65535</span>\nIP localhost.53920 <span class=\"token operator\">></span> localhost.terabase: Flags <span class=\"token punctuation\">[</span>.<span class=\"token punctuation\">]</span>, ack <span class=\"token number\">3009967848</span>, win <span class=\"token number\">6379</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>sender > receiver: Flags [flag type], header values</p>\n</blockquote>\n<p>The original output contains more information, but I’ve trimmed it to what’s needed for the explanation. The key fields here are <code class=\"language-text\">Flag</code>, <code class=\"language-text\">seq</code>, and <code class=\"language-text\">ack</code>. Let’s break them down.</p>\n<p><code class=\"language-text\">localhost.53920</code> is the client, and <code class=\"language-text\">localhost.terabase</code> is the server. Each line’s first field shows <code class=\"language-text\">sender > receiver</code>, so the first packet is from client to server, the second from server to client. Each line also has a <code class=\"language-text\">Flag</code> that indicates what type of packet it is:</p>\n<table>\n<thead>\n<tr>\n<th>Flag</th>\n<th>Name</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S</td>\n<td>SYN</td>\n<td>Client sends a sequence number to the server to initiate connection</td>\n</tr>\n<tr>\n<td>S.</td>\n<td>SYN-ACK</td>\n<td>Server generates an ACK value and responds to the client</td>\n</tr>\n<tr>\n<td>.</td>\n<td>ACK</td>\n<td>Response using the ACK value</td>\n</tr>\n</tbody>\n</table>\n<p>After this communication, client and server can establish a reliable TCP connection. Since it takes 3 exchanges, it’s called a 3-Way Handshake.</p>\n<p>What happens during this process that creates a reliable connection? Looking more closely, the client and server go through roughly this flow:</p>\n<blockquote>\n<p>Line 1: Client sends a sequence number in the <code class=\"language-text\">seq</code> field to the server<br />\nLine 2: Server increments the client’s sequence number by 1 and sends it back in the <code class=\"language-text\">ack</code> field<br />\nLine 3: Client increments the server’s sequence number by 1 and sends it back in its own <code class=\"language-text\">ack</code> field<br /></p>\n</blockquote>\n<p>The 3-Way Handshake begins when a client sends a random sequence number to the server to create a new TCP connection. This sequence number later serves as the ordering guide when the receiver reassembles packets from the sender.</p>\n<p>Both client and server increment the received <code class=\"language-text\">seq</code> (sequence number) by 1 and place it in their own <code class=\"language-text\">ack</code> (acknowledgment number) field, essentially saying: “This packet follows the sequence number you sent earlier.”</p>\n<p>These 3 exchanges are the 3-Way Handshake. Through this process, client and server inform each other that they’re ready to exchange data and establish the sequence numbers needed for subsequent data transfer. Ending a connection goes through a similar 4-Way Handshake process, requiring 4 exchanges.</p>\n<p>In short, as long as you’re using TCP, you must go through this tedious process before any real communication can begin.</p>\n<p>HTTP/1 processed only one request per TCP connection and then closed it, so this handshake had to happen with every single request. HTTP/2 changed this by maintaining a single TCP connection and handling multiple requests over it, minimizing handshakes.</p>\n<p>Even in the transition from HTTP/1 to HTTP/2, the handshake process itself was left untouched — they only minimized how often it occurred to reduce latency. This is because handshaking is mandatory as long as TCP is in use.</p>\n<p>HTTP/3, however, chose UDP, eliminating the handshake process entirely and securing connection reliability through other means.</p>\n<h3 id=\"holb-head-of-line-blocking\" style=\"position:relative;\">HOLB (Head-of-Line Blocking)<a href=\"#holb-head-of-line-blocking\" aria-label=\"holb head of line blocking permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>There’s another problem with HTTP over TCP: Head-of-Line Blocking (HOLB). While HTTP-level HOLB and TCP-level HOLB technically mean different things, they share the same essence — a bottleneck in one request increases overall latency.</p>\n<p>In TCP communication, packets must be processed in exact order. The receiver must reassemble packets using the sequence numbers exchanged with the sender.</p>\n<p>If a packet is lost mid-transmission, the data can’t be fully reassembled, so it’s never ignored. The sender must confirm that the receiver got every packet, and if any packet wasn’t received, it must be retransmitted.</p>\n<p>Since packets must be processed in order, subsequent packets can’t be processed until previous ones are parsed. When a packet is lost or the receiver’s parsing speed is slow, this bottleneck is called “HOLB.” This is a fundamental TCP issue affecting not just HTTP/1 but HTTP/2 as well.</p>\n<p>To solve these problems, HTTP/3 chose to run on QUIC, a protocol built on UDP. Let’s now look at what QUIC actually is and what advantages UDP offers over TCP.</p>\n<h2 id=\"why-http3-uses-udp\" style=\"position:relative;\">Why HTTP/3 Uses UDP<a href=\"#why-http3-uses-udp\" aria-label=\"why http3 uses udp permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Since HTTP/3 runs on QUIC, understanding HTTP/3 means focusing on QUIC. QUIC is a UDP-based protocol developed by Google to solve TCP’s problems and break through latency limitations.</p>\n<p>QUIC was designed from the start with a focus on optimizing TCP’s handshake process, and it achieved this by using UDP.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/e8950/quic.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC3klEQVR42o1U/UuTURT2H4gI+iGTgqB+S5McFqlJZDaz0LK0NHSpSYkmlbNiH1okiC00h6SULjQykrWK/MyVpqFoUzIlNXP4rdkHfmzpdren+95t2mxbXTjcc+8553mfe597XjcAC86MEOJy/YfNUTNTq3eDk2E2m9k8O69DQ1sX5nR6u/1VucTqNrs5A1oyGFHV1IYD0Slw38lHcEwq6lo6/spzCWhL0v1axCNVDbb5H8WWM2Lwyt9ia4IEG31CEHvxBj4OaO3yHQISk4nNlbWNOJYsQux1OQIq3oHXoIVPqRretYPg0dmDL8Am/wg8a2hZrnMMSCyAIlkx1vidgG/TGHaUqBEnkiFbdhfh6TnwftCIXXTf/aAA4tvF1jriGlCadx/r/I5jj6oLPGUnAkUFEOYWoVjxGOICBUIVdVgbEIVMmucS0GQ98vuefuyLuYANu8OwXVIEn5p+eKk+4EihElLKPrdQAQkF0/QMWOvM/xZlnj6RgjIlPPdHwSM4Dl6Z97CeHtPrsACvWjv/X2X2RZpoYzsyNYNLN+XwDDoJYbYco5Nfl0/DMXMKaDQa6bszMDMaLTFuNlkUxMTMj+VXwOXY2Blo3aKlzjnD1VdgY8sxMjnoEocMa5vbkZyVTy0P1bQ7uPHpyzCKKl4wv6SyCh3dfcyXlz/F1Mx35iuUNUgQ3YL0jmIFUE+7IiA6FWWqOjx8Xg/fiHMs8rpVg9CzV5gfmZbFYtwIPJ0G7dgkej9rWZ2qvhnqVs0K4NyCHv6nUjAyMY3x6W8IElxmkTf0h8BPyGB3GU47p+Klmu3z44VMHE1vP0ISM8ARon1vd2STJL+U0CA5lHSVbN4bSdq7+8jP2XkSK8wmYedFJCJVSgaHx4mRvuL4azmEMiQLOj1JFOWS4Ph0kiSWLVlFb2R3aLaagXZLS2cPhkYnV0Qxc7Nz4bg4FcyO4RDVcQirjJKxW1O1Xa0HqXEsnvwGZ3Pl7+F/khcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"quic\" title=\"\" src=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/6af66/quic.png\" srcset=\"/static/8e3e92afbd86fb0b85dcbb6ef055c169/69538/quic.png 160w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/72799/quic.png 320w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/6af66/quic.png 640w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/d9199/quic.png 960w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/21b4d/quic.png 1280w,\n/static/8e3e92afbd86fb0b85dcbb6ef055c169/e8950/quic.png 2000w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>As the name “User Datagram Protocol” suggests, UDP uses a datagram approach with independent packets that have no inherent ordering. Since datagrams only need a destination — they don’t care about the intermediate path — there’s no end-to-end connection setup either. In other words, no handshake is needed.</p>\n<p>The bottom line is that UDP is faster because it skips the many steps TCP takes to ensure reliability. But does using UDP mean we lose the reliability and data integrity that TCP provided?</p>\n<p>No. Even with UDP, you can implement all the features TCP has. UDP’s real advantage is that it’s highly customizable.</p>\n<h3 id=\"udp-is-a-blank-canvas\" style=\"position:relative;\">UDP Is a Blank Canvas<a href=\"#udp-is-a-blank-canvas\" aria-label=\"udp is a blank canvas permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>In school, I was taught that the biggest difference between UDP and TCP is “UDP is faster but less reliable than TCP.” This is half right and half wrong.</p>\n<p>UDP has no features defined beyond data transmission itself, so it’s true that the protocol doesn’t guarantee reliability on its own. But put differently, it’s a blank-slate protocol with nothing but data transmission capability. To get a sense of how many features TCP packs in for reliability and congestion control, just look at its header:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ac69210c44cd473bcb737665d590b124/c7bb6/tcp-header.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 33.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABWUlEQVR42j2P147CMBRE8/9/x4IQkEKq4zi9YofA7NjS7sOR43jKvV6YSMh2xbJs6PoR47Rg5vc0rxjGGbKq8fADVKpx/5q2d5o/rKbtBvTDhO2l4V0fCcK0gpAKWSGRCYkozvBMcqR5ibQoIVWLsmrce5wWjuvNx+0RIMkEYmr9KEHbD/ByoVz7/j6gzU4M20ZOucLsb9cqK4W8ENTVWLeXo6N5GCfnsTpNzL7DS3PJ9hrLurmQhUyzXWfGwDWSNEMYPSFK6mQFVTeuxIZuRGuDF9mIYbib0K7UsLHuejwZkNEsaVRtB9W06DiJOQ4c3y/eZKXZvlv9y05ntyOGeGFcoMwKHFxTM0A3HaoogopjTJxoYvggSow8F65uTxGEKMOIuif6vIC2wSw23MwTNSdIUnx9H0cQ4BOG2Pk9ns+O6XJx9KfT/338OaPjXd/v+LLcej7WrxR+AYjFDnQh+N9MAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tcp header\" title=\"\" src=\"/static/ac69210c44cd473bcb737665d590b124/6af66/tcp-header.png\" srcset=\"/static/ac69210c44cd473bcb737665d590b124/69538/tcp-header.png 160w,\n/static/ac69210c44cd473bcb737665d590b124/72799/tcp-header.png 320w,\n/static/ac69210c44cd473bcb737665d590b124/6af66/tcp-header.png 640w,\n/static/ac69210c44cd473bcb737665d590b124/d9199/tcp-header.png 960w,\n/static/ac69210c44cd473bcb737665d590b124/21b4d/tcp-header.png 1280w,\n/static/ac69210c44cd473bcb737665d590b124/c7bb6/tcp-header.png 1986w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>TCP's header, already packed with information</small>\n</center>\n<p>TCP was designed a long time ago and includes so many features that its header is nearly full. If you want to implement custom features beyond TCP’s built-in ones, you’d use the <code class=\"language-text\">Options</code> field at the bottom, but since it can’t grow infinitely, it’s capped at <code class=\"language-text\">320 bits</code>.</p>\n<p>And the later-defined options like <code class=\"language-text\">MSS (Maximum Segment Size)</code>, <code class=\"language-text\">WSCALE (Window Scale Factor)</code>, and <code class=\"language-text\">SACK (Selective ACK)</code> already take up most of that options space, leaving barely any room for custom features.</p>\n<p>UDP, on the other hand, was designed with a sole focus on data transmission, so its header is practically empty:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/73dae/udp-header.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 13.750000000000002%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAq0lEQVR42j2O226DMBAF+f/P60vTkNoO2GAuBoxNopJEky1S+zDSzh7tpVCVx0+ZdLszxcSSNtbtfhDzjXlN6KpGXesjiykTpoW4Zqm3gzmuTHNkkfnio3Qo7QjW4U1Nf7U0yqBOZ5pvg9cVvfQ7wTUdVqidp7Ytn6eS8qKxbU8l/kvRjYEwjOxy5WeJPOSjLN5q8+9/2T6OPIVXCOz9QPt1Zjbm8KfseQwDb9HI4QyOb6OzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"udp header\" title=\"\" src=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/6af66/udp-header.png\" srcset=\"/static/f9ccf1094e8f9f057d72c004d4f0e0e8/69538/udp-header.png 160w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/72799/udp-header.png 320w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/6af66/udp-header.png 640w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/d9199/udp-header.png 960w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/21b4d/udp-header.png 1280w,\n/static/f9ccf1094e8f9f057d72c004d4f0e0e8/73dae/udp-header.png 2122w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Compared to TCP, UDP's header is noticeably bare</small>\n</center>\n<p>UDP’s header contains only source port, destination port, packet length, and checksum. The checksum is used for verifying packet integrity, but unlike TCP’s mandatory checksum, UDP’s checksum is optional.</p>\n<p>In other words, while the UDP protocol itself is less reliable than TCP and lacks flow control, depending on how a developer implements the application layer, it can achieve TCP-like functionality.</p>\n<p>Sure, it’s convenient that TCP provides all those reliability features out of the box. But the unfortunate part is that these features are mandatory processes defined in the protocol itself — developers can’t customize them. This makes it nearly impossible to even attempt reducing the latency they introduce.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e0bf6f0a79b033925a91b04e4653d7af/e2310/tcp-tls.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 102.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAADtklEQVR42s2TbUxTVxjHsWwuRMbclmWGKZoN3USigsFJ1A9kWZZJsixmbPHLFr84i2lLaUtf0uaEVpcimkDGQjYVBTK23ESBZnTicLp0AtG2lL5cyu1tb+9tb6G0lHaoHVR6dm4DRnRu9sOSneRJ7n2ec375n/P8n5yc/3IJBIICoVC4VSqVviWRSDbX1dW9WV9fvwnlihoaGjbKZLJCPp+/icuLRKL1y7XX0dE1q0AYBnO5UCi+elUuB1sAABuXgeUItEOr1W7V6XSb1Wr1dg4gFovfUCj4LwOgL5LJQCGEMBfFc6uhN0C+sllZqmxVvsb9Awh5T7sJBA9rPK1Wv0MJwDurNty5M9kyMkzYzL/jt1wW0jwViQ5csAY+PKb/9iUPjpcHg8GjDMMcpWm6hts/KLlcCnJq1vqmUx8RzPwEPX3PNhVJVj0Edl2yD7WfGoEXVFdT174zw5nYQqSfjB/JqEkmtyDYCYIgakmSPIYxWF5Pbc+7bvsUFp39M3U/uZRegjAdu5uC1vEZUQbonIgPOYgktDHzKR99D17rsET7iOgn3cbRAjYQEPn9/hORSIQfDoWlOIl/0S3o3nf7FiO1k3+kTWb2wc1RJm3xJhZ/tYU/yABn5lP6u6kl08JS2hhL3L9uHqaw86OB6isDv2xDykQul+szpPJjpPBIcDpY2av6abegWPDCb65Eo2ViDjqJWMpiC9X//YNDmLGA6opzby1oy08kIm+zLNuAVMpCodCXXK1H3ldmbDUWcN9zc3D3/AIs5c4hd/BWIJm2c2E2w+e5nOZHR8U57OorLEsfQCA+RVHHUVOOOwlnyQ+NvQe7JF3rHhPC+0eFwnOWnSMWx3afz/cNUncKx3Hd+Ph4u5/xSzvVxrK2Wiz/ETG5T52WFaCmw1oRjieLY+Hwrng8vndxcbECXf2g1z9Z/XO36dOaErD2mcZv5R1Of2+vnJ6Jtnk9nkuoGc1ut/uM3W4/zYYCHe7bDHhi3P5NoeKMaU9np6Fo0uU6xCmbnZ3dj6xTheobWoT9O8/L+l7MCqhqGiqn6UghgjUiy+i9Xq+OcBOtoXDg8681hspmyeC6rIBy7c0yg8FUhOPOk6jDOnRlDUGQzYEQdbhJZihvAzfyswJqNIN7jEaigKI8VUhdNTL3IYfNcdiOW99vaex976x4OC8roFp+fZfTSpSQpAfzeDw9KNopyt8ZYOm6JtXQsytEyAwQKAa2XbyIbRgbG1u/bHreit+Aor/4rBjLy/k/rDXZnvgLm+tNcqo265oAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"tcp tls\" title=\"\" src=\"/static/e0bf6f0a79b033925a91b04e4653d7af/6af66/tcp-tls.png\" srcset=\"/static/e0bf6f0a79b033925a91b04e4653d7af/69538/tcp-tls.png 160w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/72799/tcp-tls.png 320w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/6af66/tcp-tls.png 640w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/d9199/tcp-tls.png 960w,\n/static/e0bf6f0a79b033925a91b04e4653d7af/e2310/tcp-tls.png 968w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>If you add TLS on top of TCP, you have to go through all of this before communication even begins</small>\n</center>\n<p>To reduce latency, you’d need to modify things outside the protocol. But as I mentioned, the areas a typical developer can touch in the communication process are limited. (We just have to wait for the telecom giants to lay down the infrastructure.)</p>\n<p>If the difference between TCP and UDP still isn’t clicking, think of it as “a heavy, full-featured library” versus “a lightweight library with only the essentials.”</p>\n<p>For example, <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"nofollow\">lodash</a> in the JavaScript world is incredibly feature-rich and convenient, but most people don’t use every single method. It’s handy, but you’re bundling features you’ll never use.</p>\n<p>A small library with a single purpose has fewer features than lodash, but you can pick exactly what you need. The tradeoff is that anything the library doesn’t support, you have to implement yourself. In this analogy, lodash is TCP and the small single-purpose library is UDP.</p>\n<p>This is why Google chose UDP when building QUIC: TCP was too difficult to modify, and the blank-slate nature of UDP made it easy to extend QUIC’s capabilities.</p>\n<h2 id=\"how-http3-improves-over-previous-protocols-by-using-udp\" style=\"position:relative;\">How HTTP/3 Improves Over Previous Protocols by Using UDP<a href=\"#how-http3-improves-over-previous-protocols-by-using-udp\" aria-label=\"how http3 improves over previous protocols by using udp permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>So far we’ve briefly covered why QUIC, the backbone of HTTP/3, chose UDP over TCP. What concrete benefits does using UDP actually bring? Is HTTP/3 truly better than the old HTTP + TCP + TLS approach?</p>\n<p>The answer can be found in the Chromium Projects’ <a href=\"https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit\" target=\"_blank\" rel=\"nofollow\">QUIC Overview</a> document. Let’s look at the advantages Google describes.</p>\n<h3 id=\"reduced-latency-in-connection-setup\" style=\"position:relative;\">Reduced Latency in Connection Setup<a href=\"#reduced-latency-in-connection-setup\" aria-label=\"reduced latency in connection setup permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Since QUIC doesn’t use TCP, it doesn’t need the tedious 3-Way Handshake to start communication. A cycle where the client sends a request and the server processes and responds is called an “RTT (Round Trip Time).” TCP requires at least 1 RTT to create a connection, and if you add TLS encryption, the TLS handshake adds up to a total of 3 RTTs.</p>\n<p>QUIC, on the other hand, requires only 1 RTT for the initial connection setup. The client sends a signal to the server, the server responds, and real communication begins immediately. The connection setup time is roughly halved.</p>\n<center>\n  <img src=\"/95f5c7e411d0b7f96d182abe284be551/gcp-cloud-cdn-performance.gif\" width=\"100%\">\n  <br>\n</center>\n<p>How is this possible? The reason is simpler than you’d expect. During the first handshake, QUIC sends the data along with the connection setup information. TCP + TLS exchanges all the information needed for a reliable connection and encryption, validates it, and <em>then</em> exchanges data. QUIC just fires off the data immediately.</p>\n<p>This process is explained in detail in the session ”<a href=\"https://youtu.be/vXgbPZ-1-us\" target=\"_blank\" rel=\"nofollow\">How Secure and Quick is QUIC?</a>” presented at the 2015 IEEE Symposium.</p>\n<p><div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.49999999999999%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <div class=\"embedVideo-container\"> <iframe title=\"\" src=\"https://www.youtube.com/embed/vXgbPZ-1-us?rel=0\" class=\"embedVideo-iframe\" style=\"border:0; position: absolute; top: 0; left: 0; width: 100%; height: 100%; \" loading=\"eager\" allowfullscreen=\"\" sandbox=\"allow-same-origin allow-scripts allow-popups\"></iframe> </div> </div></p>\n<center>\n  <small>Start watching from 3:33.<br />The presenter's swagger, hand in pocket, is hard to miss.</small>\n  <br />\n  <br />\n</center>\n<p>The key point of the video is this: TCP + TLS must exchange session keys and establish an encrypted connection before data can be exchanged with those session keys. QUIC can exchange data <em>before</em> session keys are even exchanged, which is why connection setup is faster.</p>\n<p>However, when a client sends its first request to the server, it doesn’t yet know the server’s session key. So it encrypts the communication using an Initial Key generated from the destination server’s Connection ID. For a detailed explanation, see the QUIC working group’s <a href=\"https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2\" target=\"_blank\" rel=\"nofollow\">Using TLS to Secure QUIC</a> document.</p>\n<p>Once a connection succeeds, the server caches the configuration and uses it for the next connection, enabling communication to start with 0 RTT. This is how QUIC achieves lower latency compared to TCP + TLS.</p>\n<p>Note that this session was presented before TLS 1.3 was released, so it wasn’t mentioned. Today, using TCP Fast Open with TLS 1.3, you can achieve a similar connection setup process, giving TCP some of the same benefits.</p>\n<p>However, TCP SYN packets are limited to about <code class=\"language-text\">1460 bytes</code> per packet, while QUIC can include all the data in the first round trip. So for large payloads, QUIC still has the advantage.</p>\n<h3 id=\"faster-packet-loss-detection\" style=\"position:relative;\">Faster Packet Loss Detection<a href=\"#faster-packet-loss-detection\" aria-label=\"faster packet loss detection permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Like TCP, QUIC also needs flow control for transmitted packets. Both QUIC and TCP are fundamentally ARQ-based protocols — ARQ (Automatic Repeat Request) means recovering from errors through retransmission.</p>\n<p>TCP uses “Stop and Wait ARQ”: after sending a packet, the sender starts a timer, and if the receiver doesn’t respond within a certain time, the packet is considered lost and retransmitted.</p>\n<p>According to Google’s 2017 <a href=\"https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1\" target=\"_blank\" rel=\"nofollow\">QUIC Loss Detection and Congestion Control</a>, QUIC detects packet loss similarly to TCP but with several improvements.</p>\n<p>A major issue with TCP’s packet loss detection is dynamically calculating how long to wait after sending a packet — when to trigger a timeout. This timeout is called the RTO (Retransmission Time Out), and the data it needs is a collection of RTT (Round Trip Time) samples.</p>\n<p>You measure how long it takes to receive an acknowledgment after sending a packet, then dynamically determine the timeout. To measure RTT samples, you must receive an ACK from the sender. Under normal conditions this isn’t a problem, but when a timeout occurs and a packet is retransmitted, the RTT calculation becomes ambiguous:</p>\n<blockquote>\n<p>Send packet → Timeout → Retransmit packet → ACK received!<br />\n(But is this ACK for the first packet or the second one?)</p>\n</blockquote>\n<p>To determine which packet the ACK corresponds to, you need additional methods like timestamps on packets, plus extra packet inspection. This is called Retransmission Ambiguity.</p>\n<p>To solve this, QUIC assigns a separate packet number space in its header. This packet number represents only the transmission order itself. Unlike sequence numbers (which remain the same on retransmission), packet numbers increase monotonically with each transmission, making it possible to clearly identify packet ordering.</p>\n<p>With TCP, if timestamps are available, you can determine transmission order through them. If not, you’re left implicitly inferring order from sequence numbers. QUIC eliminates this unnecessary ambiguity through unique per-packet numbers, reducing the time needed for packet loss detection.</p>\n<p>QUIC uses roughly 5 additional techniques to speed up packet loss detection. For details, I recommend reading Chapter “3.1 Relevant Differences Between QUIC and TCP” in <a href=\"https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1\" target=\"_blank\" rel=\"nofollow\">QUIC Loss Detection and Congestion Control</a>.</p>\n<h3 id=\"multiplexing-support\" style=\"position:relative;\">Multiplexing Support<a href=\"#multiplexing-support\" aria-label=\"multiplexing support permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Multiplexing is crucial because it prevents the HOLB problem mentioned earlier as a TCP drawback. With multiple streams, even if packets are lost in one stream, only that stream is affected — the others continue running fine.</p>\n<p>Note that multiplexing doesn’t mean creating multiple TCP connections. It’s a technique for sending multiple data flows without mixing them up within a single connection. Each individual data flow is called a stream.</p>\n<p>HTTP/1 used only one stream per TCP connection, so it couldn’t escape the HOLB problem. And since the connection closed after each transfer, you had to go through the handshake all over again.</p>\n<p>The <code class=\"language-text\">keep-alive</code> option could maintain a connection for a certain time, but if there was no access within that window, the connection would still close.</p>\n<p>HTTP/2 introduced multiplexing — handling multiple streams within a single TCP connection — to boost performance. With a single TCP connection carrying multiple data transfers, the number of handshakes dropped and data transfer became more efficient.</p>\n<center>\n  <img src=\"/40cb0bc1d62eba25c2e351d213d1700d/multiplexing.svg\">\n  <br>\n  <small>HTTP/3 supports the same multiplexing as HTTP/2.</small>\n  <br>\n  <br>\n</center>\n<p>QUIC also supports multiplexing like HTTP/2, carrying over these benefits. Even if one stream encounters a problem, the other streams are unaffected.</p>\n<h3 id=\"connections-survive-ip-changes\" style=\"position:relative;\">Connections Survive IP Changes<a href=\"#connections-survive-ip-changes\" aria-label=\"connections survive ip changes permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>TCP identifies connections using the source IP and port plus the destination IP and port. If the client’s IP changes, the connection breaks. A broken connection means going through the tearful 3-Way Handshake all over again, adding more latency.</p>\n<p>This is especially noticeable today because people frequently use mobile internet — switching from Wi-Fi to cellular, or moving between different Wi-Fi networks, all of which change the client’s IP.</p>\n<p>QUIC, on the other hand, uses a Connection ID to establish connections with the server. A Connection ID is just a random value completely unrelated to the client’s IP, so even if the client’s IP changes, the existing connection is maintained. This means you can skip the handshake that would otherwise be needed to create a new connection.</p>\n<h2 id=\"wrapping-up\" style=\"position:relative;\">Wrapping Up<a href=\"#wrapping-up\" aria-label=\"wrapping up permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>To properly explain HTTP/3 and QUIC, foundational networking knowledge is essential, so there were parts that were hard to cover in depth in this single post. I tried to be as detailed as possible, but the post was getting quite long, so I had to trim things down.</p>\n<p>After studying HTTP/3 and digging through various resources, my main takeaway was: “How did so much change?” Granted, once you throw out TCP, a lot is bound to change. But as someone who had only adopted HTTP/2 a few months earlier, it was a bit overwhelming. (The fact that they built HTTP but threw out TCP still blows my mind.)</p>\n<p>Honestly, whether developers use HTTP/2 or HTTP/3, users in countries with excellent internet infrastructure might not notice much difference. The small geographic size and strong infrastructure can cover up handshake latency and then some. But in countries with weaker infrastructure, the difference could be quite significant.</p>\n<p>In this post, I only talked about the advantages of HTTP/3 and UDP. Many people are concerned about abandoning TCP for UDP, and of course no technology is perfect — there will be issues.</p>\n<p>But as an attempt to break through the limitations of existing HTTP and TCP, it seems like a great move.</p>\n<p>That concludes this post on why HTTP/3 chose UDP.</p>\n<h2 id=\"references\" style=\"position:relative;\">References<a href=\"#references\" aria-label=\"references permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46403.pdf\" target=\"_blank\" rel=\"nofollow\">The QUIC Transport Protocol: Design and Internet-Scale Deployment</a></li>\n<li><a href=\"https://medium.com/codavel-blog/quic-vs-tcp-tls-and-why-quic-is-not-the-next-big-thing-d4ef59143efd\" target=\"_blank\" rel=\"nofollow\">QUIC vs TCP+TLS - and why QUIC is not the next big thing</a></li>\n<li><a href=\"https://blog.cloudflare.com/http3-the-past-present-and-future/\" target=\"_blank\" rel=\"nofollow\">HTTP/3: the past, the present, and the future</a></li>\n<li><a href=\"https://www.saturnsoft.net/network/2019/03/21/quic-http3-1/\" target=\"_blank\" rel=\"nofollow\">QUIC과 HTTP/3 - 1.UDP기반 전송 프로토콜의 대두</a></li>\n<li><a href=\"https://www.chromium.org/quic\" target=\"_blank\" rel=\"nofollow\">QUIC, a multiplexed stream transport over UDP</a></li>\n<li><a href=\"https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2\" target=\"_blank\" rel=\"nofollow\">Using TLS to Secure QUIC</a></li>\n<li><a href=\"https://blog.cloudflare.com/the-road-to-quic/\" target=\"_blank\" rel=\"nofollow\">The Road to QUIC</a></li>\n</ul>","fields":{"slug":"20191008-what-is-http3en","path":"/2019/10/08/what-is-http3/en/","lang":"en"},"frontmatter":{"title":"Why Did HTTP/3 Choose UDP?","subTitle":"The web standard is changing. HTTP/3 picks UDP for speed.","date":"Oct 08, 2019","categories":["Programming","Network"],"tags":["HTTP3","TCP","UDP","Network"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/3a812/thumbnail.jpg","srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/3a812/thumbnail.jpg 320w,\n/static/70cbe98ca5682a8f70aa5afe9a5533ed/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/fc5c5/thumbnail.webp 320w,\n/static/70cbe98ca5682a8f70aa5afe9a5533ed/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/2d839/thumbnail.jpg","srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/70cbe98ca5682a8f70aa5afe9a5533ed/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"slug":"20191008-what-is-http3","previous":{"fields":{"slug":"20190928-how-do-i-write-postings","path":"/2019/09/28/how-do-i-write-postings/","lang":"ko","postGroup":"20190928-how-do-i-write-postings"},"frontmatter":{"title":"블로그 개설을 망설이고 있는 사람들에게"}},"next":{"fields":{"slug":"20191012-introduction-data-structure-heap","path":"/2019/10/12/introduction-data-structure-heap/","lang":"ko","postGroup":"20191012-introduction-data-structure-heap"},"frontmatter":{"title":"최소 값과 최대 값을 빠르게 찾을 수 있게 도와주는 힙(Heap)"}},"lang":"ko","postGroup":"20191008-what-is-http3"}},"staticQueryHashes":["3129619726","3523904809","376081736","650499039"],"slicesMap":{}}