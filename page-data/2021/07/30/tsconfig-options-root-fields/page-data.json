{"componentChunkName":"component---src-templates-post-page-template-index-tsx","path":"/2021/07/30/tsconfig-options-root-fields/","result":{"data":{"markdownRemark":{"id":"0ac439ab-855f-5520-af64-44ebedcb8b80","tableOfContents":"<ul>\n<li><a href=\"#include\">include</a></li>\n<li><a href=\"#files\">files</a></li>\n<li><a href=\"#exclude\">exclude</a></li>\n<li><a href=\"#extends\">extends</a></li>\n<li><a href=\"#references\">references</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>","excerpt":"필자가 타입스크립트를 사용하게 된 지도 어언 4년 정도가 지났다. 필자는 자바스크립트에는 없던 타입스크립트가 제공하는 강력한 정적 타입 검사 기능에 흠뻑 빠져버렸고, 지금까지 꽤 많은 프로젝트들을 타입스크립트로 작성해왔다. 그러다가 며칠 전 타입스크립트로 작성한 프로젝트를 새롭게 만들게 되면서 평소처럼 자연스럽게 를 세팅하고 있었는데, 뭔가 마음처럼 잘 안되어서 tsconfig 공식 문서를 한참 들여다보던 중 문득 이런 생각이 들었다. 필자만 그런 것일 수도 있지만, 사실 이런저런 프로젝트를 만들다보면 를 직접 손으로 한땀 한땀 …","html":"<p>필자가 타입스크립트를 사용하게 된 지도 어언 4년 정도가 지났다. 필자는 자바스크립트에는 없던 타입스크립트가 제공하는 강력한 정적 타입 검사 기능에 흠뻑 빠져버렸고, 지금까지 꽤 많은 프로젝트들을 타입스크립트로 작성해왔다.</p>\n<p>그러다가 며칠 전 타입스크립트로 작성한 프로젝트를 새롭게 만들게 되면서 평소처럼 자연스럽게 <code class=\"language-text\">tsconfig</code>를 세팅하고 있었는데, 뭔가 마음처럼 잘 안되어서 <a href=\"https://www.typescriptlang.org/tsconfig\" target=\"_blank\" rel=\"nofollow\">tsconfig 공식 문서</a>를 한참 들여다보던 중 문득 이런 생각이 들었다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5fe0821bc535c0c02b3be547c5507fb8/7bf67/jordan-peele.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHlNNiqGkC//8QAGhAAAgIDAAAAAAAAAAAAAAAAAQIAAxARIf/aAAgBAQABBQIjTNg9iypQV//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/Aar/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAEAAwAAAAAAAAAAAAAAAAAAASAx/9oACAEBAAY/AkUx/8QAGBABAAMBAAAAAAAAAAAAAAAAAQARITH/2gAIAQEAAT8hG5ex2OHCabs3Y6Syttn/2gAMAwEAAgADAAAAEKjv/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAh/9oACAEDAQE/EMBH/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAgEBPxB5So//xAAbEAEAAwEAAwAAAAAAAAAAAAABABFBITFRcf/aAAgBAQABPxBRQTZsIZvplZEPynD7tjX44cc5GAlctn//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"jordan peele\" title=\"\" src=\"/static/5fe0821bc535c0c02b3be547c5507fb8/c08c5/jordan-peele.jpg\" srcset=\"/static/5fe0821bc535c0c02b3be547c5507fb8/0913d/jordan-peele.jpg 160w,\n/static/5fe0821bc535c0c02b3be547c5507fb8/cb69c/jordan-peele.jpg 320w,\n/static/5fe0821bc535c0c02b3be547c5507fb8/c08c5/jordan-peele.jpg 640w,\n/static/5fe0821bc535c0c02b3be547c5507fb8/7bf67/jordan-peele.jpg 680w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>어...? 내가 이걸 진짜 알고 쓰는 게 맞나...?</small>\n</center>\n<p>필자만 그런 것일 수도 있지만, 사실 이런저런 프로젝트를 만들다보면 <code class=\"language-text\">tsconfig</code>를 직접 손으로 한땀 한땀 작성하는 경우가 많지는 않게 되는 것 같다.</p>\n<p>물론 맨 처음 타입스크립트로 프로젝트를 개발했을 때는 손수 정성을 들여 작성했을 것이다. <small><del>(사실 오래 되서 잘 기억이…)</del></small> 하지만 언젠가부터는 그냥 기존에 잘 돌아가고 있는 프로젝트의 <code class=\"language-text\">tsconfig</code>를 복붙해서 새로운 프로젝트에 꽂아넣고 약간의 커스터마이징만 직접 해주는 방식으로 프로젝트를 세팅하고 있었던 것이다.</p>\n<p>그래서 다시 초심으로 돌아가 <code class=\"language-text\">tsconfig</code>에 있는 옵션들이 내 타입스크립트 프로젝트에 어떤 영향을 주는 지 한번 찬찬히 뜯어보려고 한다.</p>\n<p>사실 <code class=\"language-text\">tsconfig</code>의 모든 것을 하나의 포스팅으로 풀어내고 싶었지만, 이 놈의 컴파일 옵션들이 워낙 많다보니 포스팅이 500줄이 넘어가는 슬픈 상황을 마주하게 되었으므로, 이번 포스팅에서는 <code class=\"language-text\">tsconfig</code>의 루트에 있는 필드들에 대해서만 자세히 알아보고, 이후 다른 포스팅에서 컴파일 옵션들에 대한 설명을 이어가도록 하겠다.</p>\n<h2 id=\"include\" style=\"position:relative;\">include<a href=\"#include\" aria-label=\"include permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">string[]</code></td>\n<td><code class=\"language-text\">[]</code>, <code class=\"language-text\">['**/*']</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"include\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"src/**/*\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"tests/**/*\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">include</code> 필드는 타입스크립트 어플리케이션에 포함할 파일 목록을 선언할 때 사용하며, <code class=\"language-text\">files</code> 필드의 존재 여부에 따라 기본값이 변경되는데, 만약 <code class=\"language-text\">ㅋ</code> 필드가 선언되어 있다면 <code class=\"language-text\">[]</code>로, 선언되어 있지 않다면 <code class=\"language-text\">[\"**/*\"]</code>으로 기본 값이 설정된다.</p>\n<p>이 필드는 <code class=\"language-text\">files</code> 필드와 하는 일이 비슷하지만, <code class=\"language-text\">include</code> 필드에는 glob 문법을 사용하여 포함할 파일 경로의 패턴을 표현할 수 있기 때문에 일반적으로는 <code class=\"language-text\">files</code> 보다 <code class=\"language-text\">include</code>를 주로 사용한다.</p>\n<p>glob 문법은 <code class=\"language-text\">*</code>이나 <code class=\"language-text\">?</code> 같은 와일드 카드를 사용하여 여러 파일 이름의 패턴을 나타내게 되는데, 문법 자체는 정규 표현식과 유사하기 때문에 익히기에 크게 어렵지 않다.</p>\n<table>\n<thead>\n<tr>\n<th>와일드카드</th>\n<th>설명</th>\n<th>예시</th>\n<th>일치하는 파일이름</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">*</code></td>\n<td><code class=\"language-text\">/</code>를 제외한 0번 이상 나타나는 문자를 매칭</td>\n<td><code class=\"language-text\">types*.ts</code></td>\n<td>types.d.ts, types.ts, types.test.ts</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">**</code></td>\n<td><code class=\"language-text\">/</code>를 포함한 0번 이상 나타나는 문자를 매칭</td>\n<td><code class=\"language-text\">src/**/index.ts</code></td>\n<td>src/index.ts, src/utils/index.ts, src/test/index.ts</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">?</code></td>\n<td>하나의 문자를 매칭, 정규식의 <code class=\"language-text\">.</code>과 동일</td>\n<td><code class=\"language-text\">?at.ts</code></td>\n<td>Cat.ts, Bat.ts, Rat.ts</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">[ab]</code></td>\n<td><code class=\"language-text\">[]</code> 안에 있는 문자 중 하나를 매칭</td>\n<td>`[C</td>\n<td>B]at.ts`</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">[a-z]</code></td>\n<td><code class=\"language-text\">[]</code> 안에 있는 문자의 범위</td>\n<td><code class=\"language-text\">test[0-9].ts</code></td>\n<td>test0.ts, test1.ts, test9.ts</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">{ab,bc}</code></td>\n<td><code class=\"language-text\">{}</code> 안에 있는 문자열 중 하나를 매칭</td>\n<td><code class=\"language-text\">*.{ts,tsx}</code></td>\n<td>foo.ts, foo.tsx</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">{ab,bc}</code></td>\n<td><code class=\"language-text\">{}</code> 안에 있는 문자열 중 하나를 매칭</td>\n<td><code class=\"language-text\">*.{ts,tsx}</code></td>\n<td>foo.ts, foo.tsx</td>\n</tr>\n</tbody>\n</table>\n<p>glob 문법은 파일 경로를 통해 원하는 파일을 잡아내야하는 거의 모든 상황에서 유용하게 사용되기 때문에, 한번만 익숙해지고 나면 앞으로 프로그래밍을 하면서 만나게 될 설정 파일들이 조금은 친숙하게 다가올 것이다.</p>\n<h2 id=\"files\" style=\"position:relative;\">files<a href=\"#files\" aria-label=\"files permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">string[]</code></td>\n<td><code class=\"language-text\">false</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"files\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"./src/index.ts\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"./src/utils.ts\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"./src/models.ts\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">files</code> 필드는 타입스크립트 어플리케이션에 포함할 파일 목록을 명시적으로 선언할 때 사용한다. <code class=\"language-text\">includes</code> 필드와 비슷하지만, <code class=\"language-text\">files</code> 필드는 <code class=\"language-text\">src/**/*</code>와 같은 glob 문법을 사용할 수 없기 때문에, 일일히 파일명을 입력해줘야 한다는 단점이 있다.</p>\n<p>만약 <code class=\"language-text\">files</code> 필드에 값이 존재한다면 <code class=\"language-text\">includes</code> 필드의 기본 값은 <code class=\"language-text\">['**/*']</code>에서 빈 배열인 <code class=\"language-text\">[]</code>으로 변경된다. 즉, 기존에 <code class=\"language-text\">includes</code> 필드의 기본 값에 의존하고 있었다면, <code class=\"language-text\">files</code> 필드에 값을 추가함으로써 컴파일 결과물이 완전히 달라질 수 있으니 이 점을 유의해야 한다.</p>\n<h2 id=\"exclude\" style=\"position:relative;\">exclude<a href=\"#exclude\" aria-label=\"exclude permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">string[]</code></td>\n<td><code class=\"language-text\">['node_modules', 'bower_components', 'jspm_packages']</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"include\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"src/**/*\"</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"exclude\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"src/**/*.test.ts\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"node_modules\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">exclude</code> 필드는 “제외하다”라는 사전적 의미 그대로 <code class=\"language-text\">include</code> 필드에 선언한 파일들 중에서 “이 파일들은 포함하지마”라는 설정을 할 때 사용한다.</p>\n<p>이 필드의 기본 값인 <code class=\"language-text\">node_modules</code>, <code class=\"language-text\">bower_components</code>, <code class=\"language-text\">jspm_packages</code> 라는 친구들을 보면 알 수 있겠지만, 보통 타입스크립트로 작성된 패키지는 <code class=\"language-text\">js</code> + <code class=\"language-text\">*.d.ts</code> 파일들의 조합으로 빌드해서 배포하기 때문에, 타입스크립트는 기본적으로 이런 외부 패키지들이 빌드가 되어있다고 가정하고 있는 것이다.</p>\n<p>만약 외부에서 받아온 패키지도 컴파일이 필요한 상황이라면 <code class=\"language-text\">exclude</code> 필드를 수정해주면 된다. <small>(참고로 <code class=\"language-text\">Next.js</code>는 이 필드에 기본적으로 <code class=\"language-text\">node_modules</code>가 포함되어 있도록 프로젝트를 세팅하고, 이 값을 지워도 빌드할 때 자동으로 다시 넣어버린다…)</small></p>\n<p>그리고 한 가지 중요한 점은 <code class=\"language-text\">exlucde</code> 필드는 단지 <code class=\"language-text\">include</code> 필드에 세팅해준 파일들을 찾아올 때 “이건 찾지마”라는 의미이기 때문에 이 필드에 넣어준 파일들이라고 해서 반드시 내 어플리케이션에 포함되지 않는 것이 아니라는 것이다.</p>\n<p>즉, <code class=\"language-text\">exlucde</code> 필드에 <code class=\"language-text\">node_modules</code> 같은 디렉토리가 세팅되어있다고 해도 코드 내에서 import 문을 사용하여 직접 해당 모듈을 가져오는 경우나 <code class=\"language-text\">/// &lt;reference path=\"...\" /></code> 처럼 트리플 슬래시 디렉티브를 사용하여 컴파일러에게 특정 모듈을 포함하라고 직접 지시하는 경우, 그리고 <code class=\"language-text\">files</code> 필드를 사용하여 직접 컴파일할 파일을 명시하는 경우에는 <code class=\"language-text\">exlucde</code> 필드에 뭘 세팅했던 무시하고 해당 모듈을 가져온다.</p>\n<h2 id=\"extends\" style=\"position:relative;\">extends<a href=\"#extends\" aria-label=\"extends permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">string</code></td>\n<td><code class=\"language-text\">false</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.base.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"noImplicitAny\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"strictNullChecks\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// tsconfig.base.json의 설정을 가져와서 확장한다.</span>\n  <span class=\"token property\">\"extends\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./tsconfig.base.json\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"files\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"./src/main.ts\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">extends</code> 필드는 이름 그대로 다른 <code class=\"language-text\">tsconfig</code>의 경로를 지정하면 해당 <code class=\"language-text\">tsconfig</code>를 상속할 수 있는 필드이다. 필자 같은 경우에는 다른 사람이 미리 만들어 놓은 설정을 가져와서 조금 커스터마이징하는 상황이나, 모노 레포지토리에 포함된 모든 프로젝트에 공통적으로 적용하고 싶은 설정이 있는 경우에 주로 사용했던 것 같다.</p>\n<p>만약 상속 대상인 <code class=\"language-text\">tsconfig.base.json</code>의 내부 필드에 <code class=\"language-text\">./src</code>와 같은 상대 경로가 지정되어 있는 경우에는 해당 상속 파일을 불러온 주체인 <code class=\"language-text\">tsconfig.json</code> 기준으로 상대 경로가 계산된다.</p>\n<p>또한 이렇게 다른 <code class=\"language-text\">tsconfig</code>를 상속하여 새로운 <code class=\"language-text\">tsconfig</code>를 정의하는 경우, <code class=\"language-text\">files</code>, <code class=\"language-text\">include</code>, <code class=\"language-text\">exclude</code> 처럼 배열을 사용하여 선언된 필드들은 확장되는 것이 아니라 필드 자체가 덮어씌워지기 때문에 이 점을 유의해야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.base.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"files\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"./src/main.ts\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"extends\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"./tsconfig.base.json\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"files\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"./src/index.ts\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그러므로 위의 예시 같은 상황이라면 최종 <code class=\"language-text\">files</code>필드는 <code class=\"language-text\">[\"./src/main.ts\", \"./src/index.ts\"]</code>로 합쳐지는 것이 아니라 <code class=\"language-text\">[\"./src/index.ts\"]</code>로 평가된다. <code class=\"language-text\">extends</code>라는 필드 이름을 보면 왠지 필드의 값도 확장해줄 것 같지만, 아무런 경고나 에러도 없이 그냥 쿨하게 오버라이팅 해버리므로 주의하도록 하자.</p>\n<h2 id=\"references\" style=\"position:relative;\">references<a href=\"#references\" aria-label=\"references permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">Array&lt;{ path: string; prepend: boolean; }></code></td>\n<td><code class=\"language-text\">false</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// my-project/test/tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"references\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token comment\">// my-project/src/tsconfig.json을 참조한다</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token property\">\"path\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"../src\"</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">reference</code> 필드는 같은 프로젝트 안에서 모듈 별로 여러 개의 <code class=\"language-text\">tsconfig</code>를 사용하는 경우, 이 모듈들의 참조 관계를 표현하기 위한 필드이다. 보통 하나의 프로젝트에서는 하나의 <code class=\"language-text\">tsconfig</code>만 사용하는 경우가 많기 때문에 거의 사용할 일이 없기는 하다.</p>\n<p>사실 타입스크립트가 이런 옵션을 제공하는 이유는 바로 이런 경우 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">├── src/\n│   ├── converter.ts\n│   └── units.ts\n├── test/\n│   ├── converter-tests.ts\n│   └── units-tests.ts\n└── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 프로젝트는 소스 코드와 테스트 코드가 별도의 디렉토리로 분리되어있고, 루트에는 하나의 <code class=\"language-text\">tsconfig</code>가 전체 프로젝트의 컴파일 옵션을 관리하고 있다. 이런 구조의 프로젝트는 상당히 흔한 구조이기는 하지만, 막상 이렇게 만들어놓고 개발을 하다보면 몇 가지 불편한 점이 생긴다.</p>\n<blockquote>\n<ol>\n<li>소스 코드인 <code class=\"language-text\">src</code> 모듈에서도 테스트 코드인 <code class=\"language-text\">test</code> 모듈을 불러올 수가 있음…</li>\n<li>소스 코드에서 절대 오류가 발생하지 않는 부분을 수정했는데도 테스트 코드까지 다시 타입 검사해야 함…</li>\n<li>반대로 테스트 코드를 고치면 소스 코드까지 다시 타입 검사해야 함…</li>\n</ol>\n</blockquote>\n<p>물론 평소라면 어느 정도 감당이 가능한 불편함이기는 하지만, 프로젝트의 크기가 커지면 커질 수록 컴파일러의 타입 검사도 비례해서 느려지기 때문에 어느 순간부터는 개발 자체에 어려움을 느낄 수도 있다. 그렇다면 프로젝트의 모듈마다 <code class=\"language-text\">tsconfig</code>를 만들어 두고 따로 컴파일하면 어떨까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">├── src/\n│   ├── converter.ts\n│   ├── units.ts\n│   └── tsconfig.json\n└── test/\n    ├── converter-tests.ts\n    ├── units-tests.ts\n    └── tsconfig.json</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이렇게 각각의 모듈 별로 <code class=\"language-text\">tsconfig</code>를 가지도록 구성하면 위에서 이야기했던 문제들은 어느 정도 해결된다. 하지만 이 경우에는 각각의 모듈 별로 따로 컴파일해줘야 하는데다가, 기본적으로 <code class=\"language-text\">tsc</code>는 하나의 프로세스만 띄울 수 있도록 만들어졌기 때문에 동시에 여러 개의 <code class=\"language-text\">tsconfig</code>를 토대로 빌드를 하거나 소스 코드의 변경 사항을 감시하는 것이 불가능하다.</p>\n<p>그래서 타입스크립트 팀에서는 <code class=\"language-text\">references</code>라는 필드로 이 문제를 해결하려고 하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token comment\">// my-project/test/tsconfig.json</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"references\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token comment\">// my-project/src/tsconfig.json을 참조한다</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token property\">\"path\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"../src\"</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이 예시는 <code class=\"language-text\">references</code> 필드를 사용하여 <code class=\"language-text\">test</code> 모듈에서 <code class=\"language-text\">src</code> 모듈을 참조하고 있다는 것을 표현하고 있다. 이때 <code class=\"language-text\">test</code> 모듈에서 <code class=\"language-text\">src</code> 모듈에 있는 하위 모듈들을 불러오게 되면 소스 코드인 <code class=\"language-text\">*.ts</code>가 아니라 빌드가 완료된 결과물인 <code class=\"language-text\">*.d.ts</code> 파일을 가져온다. <small>(<code class=\"language-text\">tsc --build</code>를 사용하면 해당 모듈의 최신 상태를 감지하고 증분 빌드도 해준다.)</small></p>\n<p>프로젝트 레퍼런스에 대한 자세한 내용은 이 포스팅의 주제는 아니니, 더 궁금하신 분들은 타입스크립트 공식 문서의 <a href=\"https://www.typescriptlang.org/docs/handbook/project-references.html\" target=\"_blank\" rel=\"nofollow\">Project Referneces</a> 문서를 확인해보도록 하자.</p>\n<h2 id=\"마치며\" style=\"position:relative;\">마치며<a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이번 포스팅에서는 <code class=\"language-text\">tsconfig</code>의 루트에 있는 몇 가지 필드들의 역할을 알아보았다. 사실 하나의 포스팅으로 <code class=\"language-text\">tsconfig</code>를 깔끔하게 정리하고 싶었는데, 이 친구가 워낙 방대한 옵션들을 가지고 계신지라 부득이하게 여러 개의 포스팅으로 나눠서 집필하게 되었다.</p>\n<p>이어지는 <a href=\"/2021/08/08/tsconfig-compiler-options-type-check/\">다음 포스팅</a>에서는 타입스크립트의 컴파일 옵션들 중 타입 체크에 관한 옵션들에 대해서 이야기해보도록 하겠다.</p>\n<p>이상으로 [tsconfig의 모든 것] Root fields 포스팅을 마친다.</p>","fields":{"slug":"20210730-tsconfig-options-root-fields","path":"/2021/07/30/tsconfig-options-root-fields/","lang":"ko"},"frontmatter":{"title":"[tsconfig의 모든 것] Root fields","subTitle":null,"date":"Jul 30, 2021","categories":["프로그래밍","튜토리얼","자바스크립트"],"tags":["TypeScript","타입스크립트","tsconfig"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/18562cf9f40ec5572baa9105e9ecddbd/d803c/thumbnail.png","srcSet":"/static/18562cf9f40ec5572baa9105e9ecddbd/d803c/thumbnail.png 320w,\n/static/18562cf9f40ec5572baa9105e9ecddbd/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/18562cf9f40ec5572baa9105e9ecddbd/fc5c5/thumbnail.webp 320w,\n/static/18562cf9f40ec5572baa9105e9ecddbd/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/18562cf9f40ec5572baa9105e9ecddbd/01fb2/thumbnail.png","srcSet":"/static/18562cf9f40ec5572baa9105e9ecddbd/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/18562cf9f40ec5572baa9105e9ecddbd/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}},"allMarkdownRemark":{"edges":[]}},"pageContext":{"slug":"20210730-tsconfig-options-root-fields","previous":{"fields":{"slug":"20210507-why-regexp-called-regexp","path":"/2021/05/07/why-regexp-called-regexp/","lang":"ko","postGroup":"20210507-why-regexp-called-regexp"},"frontmatter":{"title":"정규 표현식으로 HTML을 파싱할 수 없는 이유"}},"next":{"fields":{"slug":"20210808-tsconfig-compiler-options-type-check","path":"/2021/08/08/tsconfig-compiler-options-type-check/","lang":"ko","postGroup":"20210808-tsconfig-compiler-options-type-check"},"frontmatter":{"title":"[tsconfig의 모든 것] Compiler options / Type Checking"}},"lang":"ko","postGroup":"20210730-tsconfig-options-root-fields"}},"staticQueryHashes":["3129619726","3523904809","376081736","650499039"],"slicesMap":{}}