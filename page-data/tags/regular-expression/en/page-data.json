{"componentChunkName":"component---src-templates-tag-page-template-index-tsx","path":"/tags/regular-expression/en/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"291b2741-13ed-52c0-89e8-e5ae34330c89","tableOfContents":"<ul>\n<li>\n<p><a href=\"#when-bad-regex-causes-late-nights-at-the-office\">When Bad Regex Causes Late Nights at the Office</a></p>\n<ul>\n<li><a href=\"#the-regex-that-never-ends\">The Regex That Never Ends</a></li>\n<li><a href=\"#problems-regex-simply-cannot-solve\">Problems Regex Simply Cannot Solve</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#why-were-regular-expressions-created\">Why Were Regular Expressions Created?</a></p>\n<ul>\n<li><a href=\"#expressing-languages-that-machines-can-understand\">Expressing Languages That Machines Can Understand</a></li>\n<li><a href=\"#the-runtime-environment-for-regex-finite-automata\">The Runtime Environment for Regex: Finite Automata</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#the-limitations-of-regular-expressions\">The Limitations of Regular Expressions</a></p>\n<ul>\n<li><a href=\"#why-regex-cant-understand-html\">Why Regex Can’t Understand HTML</a></li>\n<li><a href=\"#regex-is-ultimately-a-finite-automaton\">Regex Is Ultimately a Finite Automaton</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#closing-thoughts\">Closing thoughts</a></p>\n</li>\n</ul>","excerpt":"This post is the third installment in my series about regular expressions, that dreaded beast whose name alone is enough to make you break a sweat. As everyone knows, regex is infamous for its gnarly syntax, and there’s no shortage of posts out there (like my own Finding Patterns in Irregularity) that break down regex grammar and usage.","html":"<p>This post is the third installment in my series about regular expressions, that dreaded beast whose name alone is enough to make you break a sweat.</p>\n<p>As everyone knows, regex is infamous for its gnarly syntax, and there’s no shortage of posts out there (like my own <a href=\"/2020/07/24/about-regular-expression\">Finding Patterns in Irregularity</a>) that break down regex grammar and usage.</p>\n<!-- more -->\n<p>On the flip side, once you get comfortable with that gnarly syntax, you can solve a surprisingly wide range of string problems with short regex patterns. This is why regex occupies a love-hate place in most developers’ hearts. <del>(Most developers I know aren’t exactly fans of regex either…)</del></p>\n<p>So when solving problems with regex, many of us either copy-paste patterns found via Google or hack away on sites like <a href=\"https://regexr.com/\" target=\"_blank\" rel=\"nofollow\">regexr</a>, and in the process, it’s not uncommon to use a flawed regex without proper validation and pay the price.</p>\n<p>Of course, looking at a regex and determining whether it’s correct isn’t easy. But if you understand why regular expressions were created in the first place and what kind of environment they were designed to run in, the limitations of regex become naturally apparent.</p>\n<p>In this post, I’ll explore the purpose and limitations of regular expressions through a single question that’s especially familiar to frontend developers like me: can you parse HTML using only regex?</p>\n<h2 id=\"when-bad-regex-causes-late-nights-at-the-office\" style=\"position:relative;\">When Bad Regex Causes Late Nights at the Office<a href=\"#when-bad-regex-causes-late-nights-at-the-office\" aria-label=\"when bad regex causes late nights at the office permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Before diving in, let’s look at what can happen when a poorly written regex makes it into your code.</p>\n<p>The kind of “poorly written” regex I’m talking about here isn’t the “the regex was supposed to find <code class=\"language-text\">a</code> but found <code class=\"language-text\">b</code>” variety. That kind of mistake is just unfamiliarity with regex syntax — spend a bit more time studying the pattern and anyone can spot the error.</p>\n<p>What I’m talking about are performance issues that arise from not understanding how regex works internally, or the sad situation of spending hours trying to solve a problem that regex fundamentally cannot solve.</p>\n<p>Of course, the regex engine exists as an abstraction layer so developers can use regex without understanding these internals. But trusting the engine too blindly can absolutely come back to bite you.</p>\n<h3 id=\"the-regex-that-never-ends\" style=\"position:relative;\">The Regex That Never Ends<a href=\"#the-regex-that-never-ends\" aria-label=\"the regex that never ends permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>The first kind of bite is a performance issue that can occur when you don’t understand how regex matches patterns.</p>\n<p>Regex uses a <a href=\"https://docs.microsoft.com/en-us/dotnet/standard/base-types/backtracking-in-regular-expressions\" target=\"_blank\" rel=\"nofollow\">backtracking</a> algorithm based on DFS (depth-first search) to match string patterns. This means that depending on which nodes are explored and under what conditions, the matching time can become surprisingly long.</p>\n<p>In particular, the regex engine built into JavaScript engines operates synchronously, not asynchronously. So if a regex takes a long time to match, nothing else can execute during that time: a truly painful scenario.</p>\n<p>If that’s hard to picture, open a new browser tab and try running this in the console. <del>(Do it in another tab so you can still read this post…)</del></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Always exactly 8 explorations regardless of string length</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>\\d<span class=\"token operator\">+</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>$<span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'123123123123123123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// 26 explorations</span>\n<span class=\"token comment\">// This finishes quickly</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>\\d<span class=\"token operator\">+</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>$<span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'123!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 98,306 explorations</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>\\d<span class=\"token operator\">+</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>$<span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'123123123123123!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Uh... the computation never ends....</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">^</span><span class=\"token punctuation\">(</span>\\d<span class=\"token operator\">+</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>$<span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'123123123123123123123123123123123123123123!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The first example always completes in just 8 explorations regardless of string length. But in the second example, adding a single special character to the end causes the number of operations to grow exponentially, eventually reaching the point where it never finishes.</p>\n<p>If this happened in an actual business application, the user would be staring at a frozen screen, unable to interact with any UI element. There’s even an attack method called <a href=\"https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS\" target=\"_blank\" rel=\"nofollow\">ReDoS</a> that exploits exactly this behavior to bring systems to a halt.</p>\n<p>This is the kind of late-night debugging session you might find yourself in when you don’t understand how regex works under the hood.</p>\n<p>What makes it even more frustrating is that these regex patterns don’t throw errors; they just take exponentially longer to execute. That makes it even easier to get blindsided. And even if you do track it down, these kinds of bugs are notoriously hard to find. <del>(And even if you do find it, realizing the culprit is a regex is its own kind of despair…)</del></p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/eb72386d97e23ce4f176bfa012c913c9/6a068/noway.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMFBP/EABUBAQEAAAAAAAAAAAAAAAAAAAIB/9oADAMBAAIQAxAAAAGQ9ugmcLFf/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQMAAhIRQf/aAAgBAQABBQLyy8ViaAx6xjpn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bp//EABkQAAIDAQAAAAAAAAAAAAAAAAABEBEhUv/aAAgBAQAGPwIWwrL5j//EABkQAQEAAwEAAAAAAAAAAAAAAAEAEBEhYf/aAAgBAQABPyGEvpcArrduSs9r/9oADAMBAAIAAwAAABCc7//EABYRAQEBAAAAAAAAAAAAAAAAAAEAEf/aAAgBAwEBPxATG2//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAECAQE/EJqRp//EABoQAQADAQEBAAAAAAAAAAAAAAEAETEhUUH/2gAIAQEAAT8QqwCCmsVKH0+ZPNyDdb1h2MA0cFsRaqUcvP/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"noway\" title=\"\" src=\"/static/eb72386d97e23ce4f176bfa012c913c9/c08c5/noway.jpg\" srcset=\"/static/eb72386d97e23ce4f176bfa012c913c9/0913d/noway.jpg 160w,\n/static/eb72386d97e23ce4f176bfa012c913c9/cb69c/noway.jpg 320w,\n/static/eb72386d97e23ce4f176bfa012c913c9/c08c5/noway.jpg 640w,\n/static/eb72386d97e23ce4f176bfa012c913c9/6a068/noway.jpg 960w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>The face you make when you realize your overtime was caused by a single bad regex.</small>\n</center>\n<p>Because of how the backtracking algorithm works, the exploration path can dramatically impact performance. So when using regex, you should always keep in mind that unexpected situations like this can occur.</p>\n<h3 id=\"problems-regex-simply-cannot-solve\" style=\"position:relative;\">Problems Regex Simply Cannot Solve<a href=\"#problems-regex-simply-cannot-solve\" aria-label=\"problems regex simply cannot solve permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>The second kind of bite is trying to solve a problem with regex that regex fundamentally cannot solve.</p>\n<p>The first situation can at least be detected through performance monitoring: “something’s off with this regex.” But this second situation? If you don’t understand the principles and limitations of regex, you could spend an entire week going in circles. Personally, I find this second scenario the sadder one.</p>\n<p>As I’ll explain below, regex is not some master key that can find patterns in any string. It’s actually a tool with strict limitations.</p>\n<p>Most notably, languages with arbitrarily nested tags or brackets — like HTML and CSS — cannot be validated with regex. So the answer to this post’s title question, “Can you parse HTML with regex?” is:</p>\n<center>\n.<br/>\n.<br/>\n.<br/>\n</center>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/1f85f28d9af3c34a4c07a14d96563b68/066f9/x.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 116.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAXABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMEAf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHJSPJcQS1AyCv/xAAdEAACAQQDAAAAAAAAAAAAAAABAgADERIyEyEx/9oACAEBAAEFAqZXj6WPuptSzj7hrByRD7//xAAVEQEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAwEBPwFj/8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQIBAT8BI//EABwQAAICAgMAAAAAAAAAAAAAAAABAhEhcRAxMv/aAAgBAQAGPwJXRHOx7EzpDFhM8RV8f//EAB0QAAICAgMBAAAAAAAAAAAAAAERACExYRBBUaH/2gAIAQEAAT8hEyigBia/XBVc9QWob1PthiyIKDmX6BCO7zP/2gAMAwEAAgADAAAAEIPoQP/EABURAQEAAAAAAAAAAAAAAAAAACAh/9oACAEDAQE/EIH/xAAWEQEBAQAAAAAAAAAAAAAAAAAQESH/2gAIAQIBAT8Q0U//xAAeEAACAgICAwAAAAAAAAAAAAABEQAhMbFBcVGBwf/aAAgBAQABPxAJEjA+4AjKsBBKeOIteG3FOBiiTWTdQgB5RgvplO/uAoEhyHZwDA4qjJh3PM2vuf/Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"x\" title=\"\" src=\"/static/1f85f28d9af3c34a4c07a14d96563b68/066f9/x.jpg\" srcset=\"/static/1f85f28d9af3c34a4c07a14d96563b68/0913d/x.jpg 160w,\n/static/1f85f28d9af3c34a4c07a14d96563b68/cb69c/x.jpg 320w,\n/static/1f85f28d9af3c34a4c07a14d96563b68/066f9/x.jpg 400w\" sizes=\"(max-width: 400px) 100vw, 400px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>\"No.\"</small>\n</center>\n<p>If you didn’t know that parsing HTML with regex alone is impossible, you could end up wasting a lot of time trying to solve a literally unsolvable problem.</p>\n<p>But wait — many of us, myself included, have used regex to work with HTML before. So why am I saying it can’t be done?</p>\n<p>The key distinction is that what we were actually doing was checking small, constrained rules like “did a <code class=\"language-text\">&lt;div></code> tag open and close?”, not validating an entire HTML document.</p>\n<p>To understand why full HTML validation is impossible with regex, we need to look at the context in which regex was developed, the assumptions it was built on, and the limitations that follow.</p>\n<h2 id=\"why-were-regular-expressions-created\" style=\"position:relative;\">Why Were Regular Expressions Created?<a href=\"#why-were-regular-expressions-created\" aria-label=\"why were regular expressions created permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>The term “regular expression” is already familiar to developers — so familiar, in fact, that it’s spawned various nicknames and memes in developer communities around the world.</p>\n<p>But few people stop to wonder why it has this peculiar name: “regular expression.” So as a first step toward understanding what regex actually does, let’s think about what this name means.</p>\n<p>The English word “regular” means something that follows a rule or pattern. A “regular expression” is literally an expression that represents a regular pattern. That’s why we generally think of regex as a tool for matching patterns in strings.</p>\n<p>The word “pattern” here doesn’t just mean simple repetition like <code class=\"language-text\">12121212</code>. It encompasses any rule a user defines, such as ”<code class=\"language-text\">a</code> appears twice, followed immediately by <code class=\"language-text\">b</code>.”</p>\n<p>So the most basic use of regex is finding patterns in strings. But regex wasn’t actually created just to satisfy the need for string pattern matching. So what kind of pattern is a regular expression actually expressing?</p>\n<h3 id=\"expressing-languages-that-machines-can-understand\" style=\"position:relative;\">Expressing Languages That Machines Can Understand<a href=\"#expressing-languages-that-machines-can-understand\" aria-label=\"expressing languages that machines can understand permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>As mentioned, regex was born to express patterns. But to truly understand its origins, what matters more is understanding <em>why</em> people wanted to find patterns in strings in the first place.</p>\n<p>The short answer: regular expressions originated from the effort to express languages that machines can understand. In other words, regex was born as a concept for mathematically expressing language so that machines could recognize it.</p>\n<center>\n  <div style=\"max-width: 400px\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 562px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/4f4d2658e241ef2ff07b2ea1ebe8d947/9f2bf/kleene.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 142.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAdABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAQFAwH/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABroo6pqJCLVJzJUOi/wD/xAAbEAEBAQADAQEAAAAAAAAAAAACAwEAERITBP/aAAgBAQABBQL6Hn6L+eCrRROW+M9CkZrN6pR+hgyppRSUabQRzof/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAeEAADAAIBBQAAAAAAAAAAAAAAAQIRMSESIlFiof/aAAgBAQAGPwLZwzJXfm38F1rnWRzVjbF7SKsrRUp8ZJb2rMeD/8QAGxAAAwEBAQEBAAAAAAAAAAAAAAERITFxQVH/2gAIAQEAAT8hxskCauX0WQ46yvMY2BEauD2FX45g++ad2YxCieNj8HbZekqWpoYE4L6hX31Ef//aAAwDAQACAAMAAAAQaCD8/8QAFxEBAAMAAAAAAAAAAAAAAAAAAQAQEf/aAAgBAwEBPxBbwn//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAgEAEAAgEEAgMAAAAAAAAAAAABESEAMUFxkVGBodHw/9oACAEBAAE/EGdoyUm44w4zG9VoisIB2H3hxLJEGF8mIcZk32CbRK9ZMGUixUVWSWqgKTn4xBVqlzFs864rVAhh7JyCACCe44rAtSaixJr9OTtJVNK1D1MZ/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"kleene\" title=\"\" src=\"/static/4f4d2658e241ef2ff07b2ea1ebe8d947/9f2bf/kleene.jpg\" srcset=\"/static/4f4d2658e241ef2ff07b2ea1ebe8d947/0913d/kleene.jpg 160w,\n/static/4f4d2658e241ef2ff07b2ea1ebe8d947/cb69c/kleene.jpg 320w,\n/static/4f4d2658e241ef2ff07b2ea1ebe8d947/9f2bf/kleene.jpg 562w\" sizes=\"(max-width: 562px) 100vw, 562px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>Stephen Kleene, who in 1951 first used regular sets to mathematically describe language</small>\n  <br>\n  <br>\n</center>\n<p>Of course, “languages that machines can understand” at the time didn’t mean high-level natural languages like the ones we research today.</p>\n<p>Here, “language” doesn’t mean natural languages like English or Korean. It’s a more abstract concept. Just as we call programming languages “languages,” in computer science and mathematics, a language simply means a set of strings that follow certain rules.</p>\n<h4 id=\"the-mathematical-definition-of-language\" style=\"position:relative;\">The Mathematical Definition of Language<a href=\"#the-mathematical-definition-of-language\" aria-label=\"the mathematical definition of language permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>We all have an intuitive sense of what a “language” is, but most of us have never rigorously defined it.</p>\n<p>In computer science and mathematics, however, intuitive knowledge doesn’t cut it. If you want to use the concept of “language” in these fields, you need a precise definition.</p>\n<p>A language, in the mathematical and computer science sense, is simply a set of strings — nothing more, nothing less.</p>\n<center>\n  <div style=\"max-width: 500px\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6ddec89701fd0b1be27aa0c351fb400f/3534c/language_set.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 105%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAADFklEQVR42n1VWU9TYRC9PxAoW4FuQAsJWygF2SWENSmlgO8+EaDCpfokxgARxKAoxEQkbMGG4ANqQvTFGOS2x55pptwWtcnkW+58Z+acme+rgTu/FK5vLDz9cIXF3a8w975h8e0lltJm7n5BbOcSzz5e4cZKim/+z7AvksmkjD+vLSzsfcf9h88RmnqE4OSC2L0ZE6GZZZjvf+DXbysTPpX6O6B+SCQ+IRyJIrr4Eg+evEN06RWml19jOv4mM3+8g8nYC0xGp/D54uIOqGHPbGNjAx6PB8XFxXB73PB4ffD6fDLq3JseKysr4SgqQnV1Nba3t3PYGTpZW1sToIqKCjngdDrTcyeqqqpyzO12IRDwo6amRnzLysqwtbWVBZUMT09P4XK5xKG2thYNDQ2or69HXV2d7KsRkECjo6Nobm6WNYN7vV6cn5/fUh4eHs7QdLsFaGxsDAMDA+jo6JA9OyBHgmSydQuYw+FAOBzOAB4cHKC8vDx7gM5c00ib+zxIbX1pDRWce2SkUpA6mRqzs7MSgVRpjMgDBKAjaQ8NDWF8fBxdXV0CxKCtra3CrLe3FyMjIwiFQjBNEwadCcAPnDc2Nkpkpaq0NJAaA1JPZq0FmpiYgNHe3i7U7FrZjdnQWaufXyTVsqSkBH19ff8H5F4gEBDaLBbn9mrzrGZLwP7+fhjkX1paKqnzgz06193d3RKZVacsWml+o+b2DCORCIy5uTkUFBSIqC0tLVn91EhTaXPUfaVLUGbOtovH4zD29/elRXxyrW6F17bR1rAH0Cy5JgP2K/2Oj48zjT04OCgpa6sQuKenB21tbdIefr8/KwO7gJpqgQjKtmNbZW/K0dGRRLA3cWdnp4AGg0FZs3GZdVNTkxRIr5xmf3Z2lvs4rKysoCj9ghCUjjxMEAaitqwo769SpkQcqd36+nru46Cgq6urAqj0CcwnigXjLWF23GNGBKLP5uZm7vOV/1rzPvJKsSDUhuCFhYXSCWTAPWZNzRKJRM7Zf/4FWJaFw8NDzM/Pyz2lluxBPluxWAwnJydZ3/y/gD9PC0UiLVJxTgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"language set\" title=\"\" src=\"/static/6ddec89701fd0b1be27aa0c351fb400f/6af66/language_set.png\" srcset=\"/static/6ddec89701fd0b1be27aa0c351fb400f/69538/language_set.png 160w,\n/static/6ddec89701fd0b1be27aa0c351fb400f/72799/language_set.png 320w,\n/static/6ddec89701fd0b1be27aa0c351fb400f/6af66/language_set.png 640w,\n/static/6ddec89701fd0b1be27aa0c351fb400f/3534c/language_set.png 808w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>JavaScript is roughly a set of strings like these, isn't it?</small>\n  <br>\n  <br>\n</center>\n<p>But it’s not just any arbitrary collection of strings. The set of strings that constitutes a language must satisfy three conditions:</p>\n<blockquote>\n<ol>\n<li>\n<p>There must exist a finite set of symbols S</p>\n</li>\n<li>\n<p>There must be rules for forming S*, a set of strings made from elements of S</p>\n</li>\n<li>\n<p>It must be possible to determine what meaning each string in the set carries</p>\n</li>\n</ol>\n</blockquote>\n<p>Any set of strings satisfying these three conditions qualifies as a basic language. Now that we know the definition, let’s satisfy each condition one by one and build a language.</p>\n<p>First, what does the set of symbols <code class=\"language-text\">S</code> mean?</p>\n<p>If you think about it, every language on Earth has symbols used within that language. Korean has consonant symbols like ㄱ, ㄴ, ㄷ and vowel symbols like ㅏ, ㅑ, ㅓ. English has symbols like a, b, c. We call these collections of symbols an “alphabet,” and this alphabet is the set of symbols <code class=\"language-text\">S</code> — the first condition of a language.</p>\n<p>Let me define an alphabet. I’ll keep it simple with just two symbols: <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token constant\">S</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Now I’ve fulfilled the first condition: “a finite set of symbols <code class=\"language-text\">S</code>.” Next, I need to create <code class=\"language-text\">S*</code>, the set of strings made from elements of <code class=\"language-text\">S</code>. The second condition says we need rules for forming this set.</p>\n<p>These rules are what we call the syntax of the language. Since many languages share the same alphabet, it’s this second element — the syntax — that gives each language its character.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">[Same Latin alphabet, different rules for combining strings]\n\nEnglish: I love you\nFrench: je t'aime\nItalian: ti amo</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>As you can see, English, French, and Italian largely share the Latin alphabet. Even for the same concept of “love,” English uses the 4-letter string <code class=\"language-text\">love</code>, while French uses <code class=\"language-text\">l'amour</code> with 7 characters including an apostrophe.</p>\n<p>So defining just an alphabet isn’t enough to define a language. I’ll set the rule for my string set <code class=\"language-text\">S*</code> as “all strings of 3 characters or fewer that can be made from the alphabet <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>.” Then the set <code class=\"language-text\">S*</code> of my language looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token constant\">S</span><span class=\"token operator\">*</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ba\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bb\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"aab\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"aba\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"abb\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">\"baa\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bab\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bba\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bbb\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Now that I’ve defined the second condition, I can see exactly what strings my language contains. At this point, the third condition is automatically satisfied.</p>\n<p>Since my rule — “all strings of 3 characters or fewer made from <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>” — produces only a finite number of strings, it’s possible to assign meaning to each one.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">a = I'm hungry\nb = I want to go home\naa = The server is returning 500s\n...</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Just like that, I’ve satisfied all three conditions and created a humble language. I’ll call it “Evan-ese” going forward.</p>\n<h4 id=\"machine-please-understand-my-language\" style=\"position:relative;\">Machine, Please Understand My Language<a href=\"#machine-please-understand-my-language\" aria-label=\"machine please understand my language permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Creating a language with simple rules isn’t hard — anyone can create something like Evan-ese. The question is whether a machine can understand it.</p>\n<p>For a machine to understand a language, the strings that compose it need to have a recognizable pattern. If we can express the pattern of a language’s strings mathematically, then we can say this is a language a machine can understand.</p>\n<p>Of course, natural languages like English or Korean have highly free-form context and evolving grammar, so absolute patterns don’t exist. But if the rules governing a language’s strings are clear — like Evan-ese — then it’s a language a machine can understand.</p>\n<p>Evan-ese has a clear rule: strings of 3 characters or fewer made from <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>. This can be expressed as a mathematical formula:</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right\" columnspacing=\"\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi>L</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>ϵ</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>ϵ</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>ϵ</mi><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mo>=</mo><mo stretchy=\"false\">{</mo><mi>ϵ</mi><mo separator=\"true\">,</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo separator=\"true\">,</mo><mi>a</mi><mi>a</mi><mo separator=\"true\">,</mo><mi>a</mi><mi>b</mi><mo separator=\"true\">,</mo><mi>b</mi><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mi>b</mi><mo separator=\"true\">,</mo><mi>b</mi><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mi>b</mi><mo separator=\"true\">,</mo><mi>a</mi><mi>a</mi><mi>a</mi><mo separator=\"true\">,</mo><mi>a</mi><mi>a</mi><mi>b</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi>b</mi><mi>b</mi><mi>b</mi><mo stretchy=\"false\">}</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{aligned}\nL = (a+b+\\epsilon)(a+b+\\epsilon)(a+b+\\epsilon) \\\\\n= \\{ \\epsilon, a, b, aa, ab, ba, bb, ba, bb, aaa, aab, ... bbb \\}\n\\end{aligned}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">ϵ</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">ϵ</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\">ϵ</span><span class=\"mclose\">)</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">ϵ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">aa</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">ab</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">ba</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">bb</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">ba</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">bb</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">aaa</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">aab</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">...</span><span class=\"mord mathnormal\">bbb</span><span class=\"mclose\">}</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span></span></span></span></span></span></span></div>\n<p>Since Evan-ese consists of “strings of 3 characters or fewer made from a and b,” the empty string is also included. That’s why the formula adds <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span></span> (epsilon, representing the empty string) to each position, and the language Evan-ese includes <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span></span> as well.</p>\n<p>And when you translate this formula into a specific notation that machines can understand, you get…</p>\n<div class=\"gatsby-highlight\" data-language=\"regex\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-regex line-numbers\"><code class=\"language-regex\"><span class=\"token anchor function\">^</span><span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span>ab<span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">{0,3}</span><span class=\"token anchor function\">$</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>…the regular expression we all know.</p>\n<p>In other words, the first step toward making machines recognize language was to create a way to express the “rules” by which a language’s strings are generated. That’s the origin of regular expressions. If you look at the <a href=\"https://en.wikipedia.org/wiki/Regular_expression\" target=\"_blank\" rel=\"nofollow\">Wikipedia article on regular expressions</a>, you can see this context reflected directly in the definition:</p>\n<blockquote>\n<p>A regular expression […] is <strong>a sequence of characters that specifies a match pattern in text</strong>. Usually such patterns are used by string-searching algorithms for “find” or “find and replace” operations on strings, or for input validation.</p>\n</blockquote>\n<p>Of course, the definition of language I’ve presented here is quite simplified. If you’re interested in going deeper, I’d recommend searching for “formal language” and “Chomsky hierarchy.”</p>\n<h3 id=\"the-runtime-environment-for-regex-finite-automata\" style=\"position:relative;\">The Runtime Environment for Regex: Finite Automata<a href=\"#the-runtime-environment-for-regex-finite-automata\" aria-label=\"the runtime environment for regex finite automata permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>We now know that regular expressions weren’t simply born to match string patterns — they emerged from the effort to make machines recognize language. But I’ve been saying “machine” over and over. What machine exactly?</p>\n<p>Regular expressions as a concept were born in 1951. Computers did exist at the time, but it was the wild days of debating whether to use mercury delay lines or magnetic cores for memory — not exactly an era where you could write code without worrying about memory constraints.</p>\n<p>So research on machines during this period often involved imagining abstract machines in your head rather than working with actual computers. <del>(The OG of vibe coding…)</del></p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 512px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/edc01160f5c13aa18f99073f08bdb540/36dd4/magnatic_drum.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQBAgP/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABU0StDAqWf//EABoQAQEAAgMAAAAAAAAAAAAAAAECABEDEhP/2gAIAQEAAQUCjiE8pMuGWa3nbF2//8QAFREBAQAAAAAAAAAAAAAAAAAAECH/2gAIAQMBAT8Bh//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAECAQE/Aaf/xAAbEAACAQUAAAAAAAAAAAAAAAAAEQEgIUGBkf/aAAgBAQAGPwKGumI2K1H/xAAbEAEBAQADAQEAAAAAAAAAAAABEQAhMVFBYf/aAAgBAQABPyGKUz7nJ8HkrXZ6XvDFCv5kwQLfMtF3/9oADAMBAAIAAwAAABDPz//EABURAQEAAAAAAAAAAAAAAAAAABEQ/9oACAEDAQE/EET/xAAWEQEBAQAAAAAAAAAAAAAAAAABABH/2gAIAQIBAT8QTVrf/8QAHRABAAMAAQUAAAAAAAAAAAAAAQARIUFRYbHB4f/aAAgBAQABPxCgSUcdtjehlaJnSC11ATgxbSt4eZROQC/vtGyl9T//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"magnatic drum\" title=\"\" src=\"/static/edc01160f5c13aa18f99073f08bdb540/36dd4/magnatic_drum.jpg\" srcset=\"/static/edc01160f5c13aa18f99073f08bdb540/0913d/magnatic_drum.jpg 160w,\n/static/edc01160f5c13aa18f99073f08bdb540/cb69c/magnatic_drum.jpg 320w,\n/static/edc01160f5c13aa18f99073f08bdb540/36dd4/magnatic_drum.jpg 512w\" sizes=\"(max-width: 512px) 100vw, 512px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Behold the majesty of the magnetic drum — cutting-edge computer memory circa 1952</small>\n</center>\n<p>Among these abstract machines, regular expressions specifically emerged from research on making <a href=\"https://en.wikipedia.org/wiki/Finite-state_machine\" target=\"_blank\" rel=\"nofollow\">finite automata</a> (abstract machines) understand language.</p>\n<p>“Automata” means automatic (Auto) machine (Mata). Since these are abstract automated machines, they don’t require physical devices like computers. They can exist purely as theory or design.</p>\n<p>The study of automata is fundamentally about finding answers to what a machine can and cannot do, making it a foundational field for the computer science we study today.</p>\n<p>A finite automaton, in simple terms, is a machine that can be in exactly one of a finite number of states at any time. When designing finite automata, we use diagrams called state transition diagrams to illustrate how states change. They look something like this:</p>\n<center>\n  <div style=\"max-width: 500px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/79576089b5b65ad5a36ea7b3a791bbc6/ea964/dfa.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 43.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABf0lEQVR42mNgQAP///9nAtFbtmzx2LVrVx+yGCWAtaenx3Dt2rWBQDZnfX09ZQbKyckJAikWEJuPj08IxsbiG0Y0NiOGotDQUDYgJXz06FGxw4cPKxkbG/PLyMhwwjStWrWKGcSGufrQoUOily9fVt62bRs7zAKYyYwwgfXr1zd+/vz5/devX/8/fPhwS3p6ujSSIXBDz507F3/v3r23z549+3/r1q09GzZskMIWGQbfgADI///r16/fIBpoaAdIDuhiwStXrmiB2MuXL1d+8+bNB5D8z58/weru3LkzGyQHCi8BLS0tUFixzZo1qxwkeffu3Z9nz579BWI/ffp0N0jhnDlzHIFeA2tqbW1NBfng0aNHP06cOPHn+/fv/y9evHgVJAdyGZO9vT0L1GZNoEKwzUAAs7keJAd0qeDr16/VQeyFCxfKvQQCZHU3b96cgDUNAgM5+N27d9ffvn37Cui6KTExMdzIsQpTd/r0aS9gGF4G+uY1MAwXzJ8/XwAAZcUKOrOtVWoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"dfa\" title=\"\" src=\"/static/79576089b5b65ad5a36ea7b3a791bbc6/6af66/dfa.png\" srcset=\"/static/79576089b5b65ad5a36ea7b3a791bbc6/69538/dfa.png 160w,\n/static/79576089b5b65ad5a36ea7b3a791bbc6/72799/dfa.png 320w,\n/static/79576089b5b65ad5a36ea7b3a791bbc6/6af66/dfa.png 640w,\n/static/79576089b5b65ad5a36ea7b3a791bbc6/d9199/dfa.png 960w,\n/static/79576089b5b65ad5a36ea7b3a791bbc6/21b4d/dfa.png 1280w,\n/static/79576089b5b65ad5a36ea7b3a791bbc6/ea964/dfa.png 1312w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <br>\n  <br>\n</center>\n<p>This state transition diagram shows how a finite automaton’s state changes. The machine receives a string as input: if the character is <code class=\"language-text\">a</code>, it transitions to State 1; if the next character is <code class=\"language-text\">b</code>, it transitions to State 2. State 2 is the machine’s final (accepting) state, shown as a double circle.</p>\n<p>If this machine reaches its final state after processing an input string, the string is guaranteed to be something like <code class=\"language-text\">ab</code>, <code class=\"language-text\">aab</code>, <code class=\"language-text\">aaa...b</code>, and so on. This machine can also be expressed as the regex <code class=\"language-text\">a+b</code>. The machine I drew and the regex <code class=\"language-text\">a+b</code> are conceptually equivalent — the regex is just a representation of that machine. (Finite automata and regular expressions are said to be in an equivalence relation.)</p>\n<p>When there’s only one possible path from any state to the next, you can tell at a glance how the machine will behave just from the state transition diagram. That’s because from any state, there’s exactly one possible next state. Such a finite automaton is called a Deterministic Finite Automaton (DFA) because the state transitions are already fully determined.</p>\n<p>DFAs are simple in structure and fully predictable, making them easy to implement as programs and efficient to run. But they have one drawback:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/eeda28f28f54f69d85014dfc688e8f14/41099/difficult.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 82.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAARABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAEDBAUC/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQAC/9oADAMBAAIQAxAAAAHmbMvrOrnOJXAkCv/EABwQAAICAgMAAAAAAAAAAAAAAAECAAMQEhETMv/aAAgBAQABBQKWougqfjrZppbHBVj6x//EABcRAQADAAAAAAAAAAAAAAAAAAEAEBH/2gAIAQMBAT8BGbf/xAAVEQEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAgEBPwEj/8QAHRAAAgEEAwAAAAAAAAAAAAAAAAERAiAhkTFR0f/aAAgBAQAGPwIULPYvRcbImnZDs//EABsQAAMAAwEBAAAAAAAAAAAAAAABESExQRBR/9oACAEBAAE/ISfWozWyiiVXURrGqaowc2BTdaX2mz3/2gAMAwEAAgADAAAAEFsffP/EABYRAQEBAAAAAAAAAAAAAAAAAAEgMf/aAAgBAwEBPxADYf/EABcRAAMBAAAAAAAAAAAAAAAAAAABERD/2gAIAQIBAT8Qpk3/xAAcEAEAAwACAwAAAAAAAAAAAAABABEhMVFxkaH/2gAIAQEAAT8QsIsbj2nKstAwJcJ3SysnML1m0kCpUNLDQqZ6lSYnFAVmz7WdeYz/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"difficult\" title=\"\" src=\"/static/eeda28f28f54f69d85014dfc688e8f14/41099/difficult.jpg\" srcset=\"/static/eeda28f28f54f69d85014dfc688e8f14/0913d/difficult.jpg 160w,\n/static/eeda28f28f54f69d85014dfc688e8f14/cb69c/difficult.jpg 320w,\n/static/eeda28f28f54f69d85014dfc688e8f14/41099/difficult.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Expressing a language's structure with a DFA's restricted state transitions is really hard...</small>\n</center>\n<p>Why is it hard? For a simple regex like <code class=\"language-text\">a+b</code>, drawing the state transition diagram as a DFA is straightforward. But try expressing something like <code class=\"language-text\">(a|b)b</code> — which includes an OR — as a DFA, and it gets tough. A DFA requires that for any given input, there be exactly one possible next state. It’s like trying to handle conditionals without <code class=\"language-text\">if</code> statements.</p>\n<p>For this reason, when expressing machines that recognize language, we use machines where multiple next states can exist rather than just one. Since the next state depends on the input, you can’t predict from the diagram alone how the machine will behave.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/e7fceab762eed09c508982488f4c711d/a3a74/nfa.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 42.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABq0lEQVR42n1STUsCYRD2o0L6ALtVUN66RJf2WlCQeKsf0DE6BV38AV6Cbp4iSmIXNUwEwUvgx8GDCmtsrBZiICLiYSF11V3dxc1tm3fZlWUpB4bhfeadeed55rVYTKYoihXFYrG4xrIszXGc0Gg0jrScjaKo9X6//wE4X6/XD3Tc8l8jiHMottvtM1EUFWTQ+M7r9bqCweB+qVQ6lyRJxTudzr2xRu8xtWw2u4xiOp3fCAQCp9CIGo1GXK1W8yAcw7D5QqHgGgwG74CzlUrlOBqNemiadvp8PkcsFrNPx2UY5nI4HH5DEyIcfj4kSUqlk0gkVsxsUHEoFFrSjlaSJK9hWgmkeUSAA3wVgDdEA2gK1Wp1V6NgN2uEaBkdIDto+jmZTBSe50X0msq/1WpdCYLw0+12n3Acd79kMttGGYxGEIQjlUoZJ7wBzeVms4mbqSyimMvlsHg8fgL0X0EGDi669Ykht4U0hGlUDSORiBsedUJ6AeptM7c8Ho/VbfZ6vVu/378HvlMuly9kWVZxuPMwc8tofB3U/lse/Ev/hyifTCY3ASPBmb/+4S99g1RDfuL+QQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"nfa\" title=\"\" src=\"/static/e7fceab762eed09c508982488f4c711d/6af66/nfa.png\" srcset=\"/static/e7fceab762eed09c508982488f4c711d/69538/nfa.png 160w,\n/static/e7fceab762eed09c508982488f4c711d/72799/nfa.png 320w,\n/static/e7fceab762eed09c508982488f4c711d/6af66/nfa.png 640w,\n/static/e7fceab762eed09c508982488f4c711d/d9199/nfa.png 960w,\n/static/e7fceab762eed09c508982488f4c711d/21b4d/nfa.png 1280w,\n/static/e7fceab762eed09c508982488f4c711d/a3a74/nfa.png 2272w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <br>\n</center>\n<p>Such a machine is called a Nondeterministic Finite Automaton (NFA) because the state transitions aren’t predetermined but change depending on the input.</p>\n<p>The machine above starts by accepting the empty string <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span></span></span></span></span>, then transitions to State 2 if the next character is <code class=\"language-text\">a</code>, or to State 3 if it’s <code class=\"language-text\">b</code>. There are two or more possible next states from a single state. Since you can’t tell from the diagram alone what the next state will be, it’s called “nondeterministic.”</p>\n<p>This is the rough concept of finite automata — the machine that regex runs on. Regular expressions were designed with the goal of making this kind of abstract machine recognize language. The critical point to note here is that <strong>a finite automaton can only remember a single state at a time</strong>.</p>\n<p>This constraint is precisely what creates the limitations of regular expressions as a language.</p>\n<h2 id=\"the-limitations-of-regular-expressions\" style=\"position:relative;\">The Limitations of Regular Expressions<a href=\"#the-limitations-of-regular-expressions\" aria-label=\"the limitations of regular expressions permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Languages that can be expressed by regular expressions — that is, languages that finite automata can understand — are called “regular languages.”</p>\n<p>As we’ve seen, regex was originally designed to express languages with mathematically describable rules, and it was built to run on finite automata that can hold only one state at a time, so it cannot express all languages.</p>\n<p>Think of it this way: you can’t express free-form natural languages like English or Korean with regex. (If you could express natural language with regex, we wouldn’t need machine learning.)</p>\n<p>In other words, there are clear limits to what regex can express, and the languages within those limits are called regular languages.</p>\n<center>\n  <div style=\"max-width: 400px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cbdaac181d19daaf1bcf0282472c8d32/21b4d/chomsky.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 71.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTklEQVR42o2U6UrDQBRGszVJ0yaTBvdgCYqodcO6oYL4/k/lN/GMXOMfBw4zzd3v3GkUfa/Y7JVYiVrMJ1TsNTqVsf2zctGIIvr/KrDJp4KSqIO4E+fiWlyJJ77figv2e3EjPsSJWJL5uGai5ew/dvz2HMGh2Bc9Zy9zYs84avE1CrJJLwv6M4OcPeNcmdYEmywk1prSU5rdEaimHXMchAtp0OmwiUyWozBEchgO9OhVvNOzT/Es3sSDOCVbZ7JsrEMffWEyLSEDW/LcZLYwfWxsyTVKoRcN+465pF1xQFtC71Nsf3x5QcLVp8bxirHxJb6ILSO1pXcJQVNsE3yNpTgzpEtza0ExkE7Krc1jcGFswmA7c8Mxit74koH2nKHboNOZmSynryUM+MAAOzLpeTnHDHIorUe3tZlNV0yktXgUG8opzBxukK3R/fXn8AWNkA9NoCwYMAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"chomsky\" title=\"\" src=\"/static/cbdaac181d19daaf1bcf0282472c8d32/6af66/chomsky.png\" srcset=\"/static/cbdaac181d19daaf1bcf0282472c8d32/69538/chomsky.png 160w,\n/static/cbdaac181d19daaf1bcf0282472c8d32/72799/chomsky.png 320w,\n/static/cbdaac181d19daaf1bcf0282472c8d32/6af66/chomsky.png 640w,\n/static/cbdaac181d19daaf1bcf0282472c8d32/d9199/chomsky.png 960w,\n/static/cbdaac181d19daaf1bcf0282472c8d32/21b4d/chomsky.png 1280w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>In the Chomsky hierarchy, which ranks languages by complexity, regular languages sit at the very bottom.</small>\n  <br>\n  <br>\n</center>\n<p>Even among the strings we deal with in everyday business contexts, quite a few aren’t regular languages. The most prominent example is HTML. In other words, it’s impossible to determine whether a given string is valid HTML using regex.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 420px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/7c89426e48dfcc4187fffa597065a5e1/65f94/question.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAACAP/aAAwDAQACEAMQAAAB6UdChKUBf//EABoQAAICAwAAAAAAAAAAAAAAAAACAREDEiP/2gAIAQEAAQUCHbnjvUVKk//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQIBAT8BWosP/8QAGxAAAQQDAAAAAAAAAAAAAAAAAQACEEEiMTL/2gAIAQEABj8CQdyTSy3DibMf/8QAHBABAAEEAwAAAAAAAAAAAAAAAQARITFBUWFx/9oACAEBAAE/IW1ctSWEKgFmvE3z6hkndym2f//aAAwDAQACAAMAAAAQw+//xAAXEQADAQAAAAAAAAAAAAAAAAAAASER/9oACAEDAQE/EFio7T//xAAXEQEAAwAAAAAAAAAAAAAAAAAAESFB/9oACAECAQE/ENyVH//EAB0QAQACAgIDAAAAAAAAAAAAAAEAESFBMVFhcZH/2gAIAQEAAT8QSQ0o42wgx0mC6cDKDYs3ueIkYy3X2MqFoVo1HHvn/9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"question\" title=\"\" src=\"/static/7c89426e48dfcc4187fffa597065a5e1/65f94/question.jpg\" srcset=\"/static/7c89426e48dfcc4187fffa597065a5e1/0913d/question.jpg 160w,\n/static/7c89426e48dfcc4187fffa597065a5e1/cb69c/question.jpg 320w,\n/static/7c89426e48dfcc4187fffa597065a5e1/65f94/question.jpg 420w\" sizes=\"(max-width: 420px) 100vw, 420px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Wait, I've definitely matched HTML with regex before though?</small>\n</center>\n<p>Sure, I’ve matched HTML with regex too. But the rules we were applying at the time were small, constrained checks on parts of the HTML (like “did a <code class=\"language-text\">&lt;div></code> tag open and close?”), not validating the entire HTML document.</p>\n<p>So why do I say regex can’t validate HTML? The answer becomes clear when you remember that regex represents a finite automaton that can only remember a single state, and then look at HTML’s structure.</p>\n<h3 id=\"why-regex-cant-understand-html\" style=\"position:relative;\">Why Regex Can’t Understand HTML<a href=\"#why-regex-cant-understand-html\" aria-label=\"why regex cant understand html permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>As we all know, HTML has a structure where tags open and close, and tags can be nested infinitely deep inside other tags.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-html line-numbers\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>main</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>section</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>\n      ...\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>section</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>main</span><span class=\"token punctuation\">></span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So if a machine receives an HTML string as input and needs to verify that it’s valid, what would it need to do?</p>\n<p>A valid HTML string requires every opening tag to have a matching closing tag, which means the machine needs to read characters one by one while simultaneously tracking which tags are open and closed. It would work roughly like this:</p>\n<hr>\n<ol>\n<li>Encounter <code class=\"language-text\">&lt;main></code>. Store the state that the <code class=\"language-text\">&lt;main></code> tag is open.</li>\n<li>Encounter <code class=\"language-text\">&lt;section></code>. Store the state that the <code class=\"language-text\">&lt;section></code> tag is open.</li>\n<li>…repeat</li>\n<li>Encounter <code class=\"language-text\">&lt;/main></code>. If the state says <code class=\"language-text\">&lt;main></code> is open, it has closed correctly.</li>\n<li>Encounter <code class=\"language-text\">&lt;/section></code>. If the state says <code class=\"language-text\">&lt;section></code> is open, it has closed correctly.</li>\n<li>If no tags remain open when the end of the string is reached, this is valid HTML.</li>\n</ol>\n<hr>\n<p>If you were building such a machine, how many states would it need to store?</p>\n<center>\n.<br/>\n.<br/>\n.<br/>\n</center>\n<blockquote>\n<p>The answer is <strong>infinite</strong>.</p>\n</blockquote>\n<p>If that’s not immediately clear, imagine building an HTML parser yourself. As discussed, this parser needs to verify that tags are properly opened and closed, so whenever it encounters an opening tag string, it needs to store that state somewhere.</p>\n<p>The exact approach to state management may vary from person to person, but the classic technique for validating matched pairs of opening and closing brackets is using a stack.</p>\n<center>\n  <div style=\"max-width: 400px\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d4263f72bef0eb338a9fd098cb06b100/17a7a/html_parser.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 96.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAADG0lEQVR42o2U+1MbVRTH+S99TLWo4+MHf4AUKoWhjr85U7WETtugBIJUpUKDZYpAaUmCBJKxJs2StGmSXfJ+kRdsVgoBPt7dJJXOFOiZ+ezee8853z333N3tQJim7hOPVkjEqgYpuUZK2WkiN9HX41HhU2o0Gke07fj42KBtHfpFCZeZGnnKvXGJmTEJq3mF29cWDEaHHjM+7MRuCzFtDTA7sUkskqRaq5BMJslms3g8HiRJ4vDwsClYLmg8WU3hc6cNPE6ZdUeUDYHXpRj41zP8s5ZC8ubIpPMiuSEqPeTo6IharUa5XP6/wpMln2XtOD1ZF3qTdehBmqaxu7uLqqoG+rhNe9721et1crnca4In+9gUFEHtBCNJPEBroQvUT/jfJPhahUKfQrVOML3Ls4xq4JeL+GIF/IKnyjaBeJnn2TqhtEo4qyJvJURFZwjmqxqSCA5mdGGVpXWJhTU/Dzc2cfmirAYUnuf32NRjBLnC9ql9br42+R3mfAXmA9v8uVlhIVgVVFpUxVqZeanEA3+RRanITn2v1btTBB8Fi3TaXvD5xDM++G6RD68v03nDxUc317lodtA5rI/dfDYZ4ctfIiSKKqe9HYZgIF7hh6UEw8sJrs+HGVqKYV5SMD9UGFqMvcK8nOTWSpJiTTu7wo1omcszMa7OxRm4F6HvN4krU0H674bo/z1kjAf/2GJgVuGbOYVspX62oDtSonc6xuD9OH0iuXtkBdNPTnonvFwac9NjXWPAHqNfCH59XyFTOkcwmKxy41ESy0qK2440ltU8lr8KWJxZgxF9LtZvPU4x6kpR2jlny8viUC6Mhvl0Uuai5QnvfPuA964tcsHs4v3vl3lXzD+xhfl4IsIXd97iUEKiwpui2T86U4zoOJJNXs0T4i524EgxtvoWFa69KNE1FaXPvsWlX4N0WTfoGvdi+tlHt+1vusY8xqH1Tsv022XS5/XQLQRNd6NcsStcngrRbXVjGvfQM+mj544fk81LnxD8akZmcFYmUz5ny/sHB6j/vqSus7ePtt9Ae6lz0KLR9LVoiB/paZ/ef/l8VA9zcB1BAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"html parser\" title=\"\" src=\"/static/d4263f72bef0eb338a9fd098cb06b100/6af66/html_parser.png\" srcset=\"/static/d4263f72bef0eb338a9fd098cb06b100/69538/html_parser.png 160w,\n/static/d4263f72bef0eb338a9fd098cb06b100/72799/html_parser.png 320w,\n/static/d4263f72bef0eb338a9fd098cb06b100/6af66/html_parser.png 640w,\n/static/d4263f72bef0eb338a9fd098cb06b100/17a7a/html_parser.png 753w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  </div>\n  <small>A bare-bones HTML parser can be built just by pushing opening tags onto a stack and popping when closing tags are encountered.</small>\n  <br>\n  <br>\n</center>\n<p>No matter how deeply tags are nested, inner tags must always close before outer ones — and the stack’s last-in-first-out property is a perfect fit for validating this structure.</p>\n<p>But the problem is the size of the stack. How large does the stack need to be to handle any possible HTML string?</p>\n<p>The bigger the better, obviously. A larger stack means you can parse HTML with deeper nesting. But eventually, an HTML tree deeper than the stack’s capacity will come along and crash the program, which means that to build an HTML parser that can handle any string, the stack size needs to be infinite.</p>\n<h3 id=\"regex-is-ultimately-a-finite-automaton\" style=\"position:relative;\">Regex Is Ultimately a Finite Automaton<a href=\"#regex-is-ultimately-a-finite-automaton\" aria-label=\"regex is ultimately a finite automaton permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Validating whether HTML is well-formed requires an infinite number of states. But regex represents a finite automaton that can hold only a single state, so it fundamentally cannot recognize HTML, which requires infinite states to parse.</p>\n<p>The core takeaway is that regex represents a finite automaton that can only hold one state, and there exist problems that such a machine simply cannot solve.</p>\n<p>So rather than reaching for regex the moment you see a string problem, it’s better to first think: “If I were building a parser for this string, how many states would I need?” If the answer is two or more, you can generally conclude that regex alone won’t cut it.</p>\n<p>Of course, this kind of mental simulation differs between those who are experienced and those who aren’t; you might think a problem requires multiple states when one would suffice. But algorithms are a domain of practice, not talent, so with a year or two of steady effort, your intuition will sharpen over time.</p>\n<h2 id=\"closing-thoughts\" style=\"position:relative;\">Closing thoughts<a href=\"#closing-thoughts\" aria-label=\"closing thoughts permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>The limitations of regex can actually be summarized in a single sentence: “it cannot recognize strings with unbounded nesting depth.”</p>\n<p>But rather than just stating and memorizing that, I thought it would be easier to understand if we explored what problem regex was created to solve and what concept it’s built on.</p>\n<p>If you don’t know that regex has these limitations, you might take your experience of using regex in constrained situations (like checking whether a <code class=\"language-text\">&lt;li></code> tag exists inside a <code class=\"language-text\">&lt;ul></code> tag) and try to tackle a fundamentally unsolvable problem.</p>\n<p>Regex does provide a lot of convenience when working with strings, that’s true. But as we’ve discussed, the backtracking algorithm can introduce unexpected performance issues, and there are problems regex simply cannot solve. So before reaching for regex, it’s always worth asking: “Is this really the right tool for the job?”</p>\n<p>That’s all for this post on why you can’t parse HTML with regex.</p>","fields":{"slug":"20210507-why-regexp-called-regexp-en","path":"/2021/05/07/why-regexp-called-regexp/en/","lang":"en"},"frontmatter":{"title":"Why You Can't Parse HTML with Regex","subTitle":"Backtracking and Automata: Why Regular Expressions Can't Understand HTML","date":"May 07, 2021","categories":["Programming"],"tags":["Regex","Regular Expression","Automaton","Automata","Backtracking"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/267c5d189674e3002cc5cc4b33695d75/3a812/thumbnail.jpg","srcSet":"/static/267c5d189674e3002cc5cc4b33695d75/3a812/thumbnail.jpg 320w,\n/static/267c5d189674e3002cc5cc4b33695d75/4b287/thumbnail.jpg 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/267c5d189674e3002cc5cc4b33695d75/fc5c5/thumbnail.webp 320w,\n/static/267c5d189674e3002cc5cc4b33695d75/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/267c5d189674e3002cc5cc4b33695d75/2d839/thumbnail.jpg","srcSet":"/static/267c5d189674e3002cc5cc4b33695d75/2d839/thumbnail.jpg 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/267c5d189674e3002cc5cc4b33695d75/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"84c50775-bbc4-52ef-ba7f-eed918a9867c","tableOfContents":"<ul>\n<li>\n<p><a href=\"#validating-user-input\">Validating User Input</a></p>\n<ul>\n<li><a href=\"#validating-email-addresses\">Validating Email Addresses</a></li>\n<li><a href=\"#phone-numbers\">Phone Numbers</a></li>\n<li><a href=\"#passwords\">Passwords</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#extracting-specific-information-from-irregular-strings\">Extracting Specific Information from Irregular Strings</a></p>\n<ul>\n<li><a href=\"#extracting-only-numbers-from-a-string\">Extracting Only Numbers from a String</a></li>\n<li><a href=\"#extracting-monetary-values-from-a-sentence\">Extracting Monetary Values from a Sentence</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#reformatting-strings\">Reformatting Strings</a></p>\n<ul>\n<li><a href=\"#masking-user-information\">Masking User Information</a></li>\n<li><a href=\"#find-and-replace-in-your-ide\">Find-and-Replace in Your IDE</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#wrapping-up\">Wrapping Up</a></p>\n</li>\n</ul>","excerpt":"In my previous post, Finding Patterns in Irregularity: A Guide to Regular Expressions, I covered the basics of how regex works. But no matter how well you understand the fundamentals, the moment you actually need to use regex in a real situation, your mind tends to go blank.","html":"<p>In my previous post, <a href=\"/2020/07/24/about-regular-expression\">Finding Patterns in Irregularity: A Guide to Regular Expressions</a>, I covered the basics of how regex works.</p>\n<p>But no matter how well you understand the fundamentals, the moment you actually need to use regex in a real situation, your mind tends to go blank.</p>\n<!-- more -->\n<p>So in this post, I’d like to walk through several real-world scenarios I’ve encountered at work, with examples and explanations of how I used regex to solve them.</p>\n<p>Regex sees the most action in three situations: “validating user input,” “extracting desired information,” and “reformatting strings.” Let’s define problems in each category and solve them with regex.</p>\n<h2 id=\"validating-user-input\" style=\"position:relative;\">Validating User Input<a href=\"#validating-user-input\" aria-label=\"validating user input permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>The most common place you’ll encounter regex in practice is when validating user input.</p>\n<p>You learn this naturally as you build products, but users absolutely will not use your product the way you designed it. Blindly trusting user-submitted data and shipping it straight to the server is a fairly dangerous thing to do.</p>\n<p>You told them to enter an email address, but they entered a phone number. In the worst case, someone with malicious intent might inject a script or query and send it to the server.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 554px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d3d5049ed982f669de8ee19432f6f22e/04abd/sql_injection.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 48.75000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABd0lEQVR42m1R2U7DMBDMF/MnfAa/0JcKkFpKaaAtSCVNFdLch9PmPp2TSS0QIEYra7zeWe14ueGCvu9xFkVxOBw0TXNdRxAEcEVRJEkC3+/3Xdd9VzJwjLNUnuerFf/0xMvycT5/mM1mkImiuFgslsslpfSvuKkrtIzj2PfPURSnWWiRo02Uokz/lDLOzqZp2rblriePyJxOZ8uyCPFUTVytpwjb0SitdV3Tdd0wDLzihAvTNMHTNE2ShJusNl1dE0JM03BdIsm75+3ty/bOcY2qooYxKqGXZRlKRlAMC6M4i4KyqjAD7nXd5EUKB3ESUFqx8X4CZYxUaEwpN/wGHPVdP8YPt/8CBdzRctADk6iqatuObkrrt/vX3Zx45tAPwReiKArD0Pd9dgUZx766mQ5tjZzneUEQHlWR39w9b+8tW8/zce1ois2LX8DaYR5/hsm513chSzM0cxznfPZ140M48Igg9DAbfhXLz7IsuQAEmeKCsiw/AXYMKq9gkgA4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"sql injection\" title=\"\" src=\"/static/d3d5049ed982f669de8ee19432f6f22e/04abd/sql_injection.png\" srcset=\"/static/d3d5049ed982f669de8ee19432f6f22e/69538/sql_injection.png 160w,\n/static/d3d5049ed982f669de8ee19432f6f22e/72799/sql_injection.png 320w,\n/static/d3d5049ed982f669de8ee19432f6f22e/04abd/sql_injection.png 554w\" sizes=\"(max-width: 554px) 100vw, 554px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Modern backend frameworks and ORMs handle injection attacks automatically,<br>but raw queries are still used for performance reasons — never let your guard down</small>\n</center>\n<p>That’s why client-side developers write validation logic to verify that user input is correct, and regex is incredibly useful in this process.</p>\n<h3 id=\"validating-email-addresses\" style=\"position:relative;\">Validating Email Addresses<a href=\"#validating-email-addresses\" aria-label=\"validating email addresses permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Email is one of the most common data formats you’ll receive from users. And since email addresses have clearly defined fields and limited rules, validating whether a given string is a proper email address isn’t terribly difficult.</p>\n<p>The specifics may vary slightly between MBPs (Mailbox Providers), but according to <a href=\"https://tools.ietf.org/html/rfc2822#section-3.4.1\" target=\"_blank\" rel=\"nofollow\">RFC 2822 § Addr-spec specification</a>, which defines the internet message protocol, an email address can be described as a string with the following pattern:</p>\n<blockquote>\n<ol>\n<li>\n<p>An email address consists of a local part, <code class=\"language-text\">@</code>, and a domain.</p>\n</li>\n<li>\n<p>The local part may contain letters, digits, and special characters such as <code class=\"language-text\">!#$%&amp;'*+-/=?^_{|}~</code>. The <code class=\"language-text\">.</code> character is also allowed, but the local part must not start or end with <code class=\"language-text\">.</code>.</p>\n</li>\n<li>\n<p>The domain consists of a host and domain identifier connected by <code class=\"language-text\">.</code> (e.g., google.com).</p>\n</li>\n<li>\n<p>The local part and domain are connected by <code class=\"language-text\">@</code>.</p>\n</li>\n</ol>\n</blockquote>\n<p>Since email addresses follow a well-defined pattern, we can validate them through simple pattern matching with regex.</p>\n<h4 id=\"the-local-part\" style=\"position:relative;\">The Local Part<a href=\"#the-local-part\" aria-label=\"the local part permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The local part of an email can contain letters and digits, so we can use <code class=\"language-text\">\\w</code> — the word group that matches both letters and digits — to handle this easily. It also allows special characters like <code class=\"language-text\">!#$%&amp;'*+-/=?^_{|}~</code>, so a custom group like <code class=\"language-text\">[\\w!#$%&amp;'*+-/=?^_{|}~]</code> covers all valid characters for the local part.</p>\n<p>This pattern must appear at least once. If it appears zero times, the local part is empty, which isn’t a valid email address. So we append the <code class=\"language-text\">+</code> quantifier at the end, meaning “one or more occurrences.”</p>\n<div class=\"gatsby-highlight\" data-language=\"regex\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-regex line-numbers\"><code class=\"language-regex\"><span class=\"token anchor function\">^</span><span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span><span class=\"token char-set class-name\">\\w</span>!#$%&amp;'*+/=?^_{|}~-<span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">+</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>This is the basic pattern for an email local part. But RFC 2822 has one more finicky rule: ”<code class=\"language-text\">.</code> is allowed, but the local part must not start or end with <code class=\"language-text\">.</code>.”</p>\n<p>Checking that a string doesn’t start or end with <code class=\"language-text\">.</code> is straightforward using the <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code> anchors, but handling <code class=\"language-text\">.</code> appearing in the middle requires a bit more thought.</p>\n<p>The simplest way to express “a character that may or may not appear in the middle” is actually quite intuitive:</p>\n<blockquote>\n<p><code class=\"language-text\">.</code> always appears in the middle of the local part. In other words, <code class=\"language-text\">.</code> must always be followed by the <code class=\"language-text\">[\\w!#$%&amp;'*+-/=?^_{|}~]</code> pattern.</p>\n</blockquote>\n<p>To put it more precisely: the pattern <code class=\"language-text\">.something</code> may or may not appear within the local part, but if it does appear, there must always be other characters after the <code class=\"language-text\">.</code>.</p>\n<p>Expressed as regex on its own:</p>\n<div class=\"gatsby-highlight\" data-language=\"regex\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-regex line-numbers\"><code class=\"language-regex\"><span class=\"token group punctuation\">(?:</span><span class=\"token special-escape escape\">\\.</span><span class=\"token char-class\"><span class=\"token char-class-punctuation punctuation\">[</span><span class=\"token char-set class-name\">\\w</span>!#$%&amp;'*+/=?^_{|}~-<span class=\"token char-class-punctuation punctuation\">]</span></span><span class=\"token quantifier number\">+</span><span class=\"token group punctuation\">)</span><span class=\"token quantifier number\">*</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Let’s start with the <code class=\"language-text\">(?:</code> and <code class=\"language-text\">)</code> wrapping. This is the same grouping mechanism as the capturing feature I explained in the previous post.</p>\n<p>Capturing groups actually serve double duty — they capture and they group multiple expressions. When you add <code class=\"language-text\">?:</code> at the beginning of a group <code class=\"language-text\">()</code>, you’re saying “I want the grouping but not the capturing.” That’s why it’s called a “Non-Capturing Group.”</p>\n<p>Inside the group, <code class=\"language-text\">\\.</code> means the literal <code class=\"language-text\">.</code> character. Without the escape, the regex engine would interpret <code class=\"language-text\">.</code> as the character class meaning “any character,” so we escape it to match the literal dot.</p>\n<p>After that comes the same <code class=\"language-text\">[\\w!#$%&amp;'*+/=?^_{|}~-]+</code> pattern we used before — meaning at least one character from this set must follow the <code class=\"language-text\">.</code>.</p>\n<p>Finally, since this entire pattern may or may not appear, we append the <code class=\"language-text\">*</code> quantifier (zero or more) after the closing <code class=\"language-text\">)</code>.</p>\n<p>Combining this with the earlier <code class=\"language-text\">[\\w!#$%&amp;'*+/=?^_{|}~-]+</code> pattern gives us a complete regex for valid email local parts:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^[\\w!#$%&amp;'*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_{|}~-]+)*$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Letters + digits</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// Dot in the middle</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91.test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\n<span class=\"token comment\">// Starts or ends with dot</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.bboydart91'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id=\"the-domain\" style=\"position:relative;\">The Domain<a href=\"#the-domain\" aria-label=\"the domain permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Now that we’ve defined a regex pattern for valid email local parts, all that’s left is defining one for valid domains.</p>\n<p>According to RFC 2822, the domain is “a host and domain identifier connected by <code class=\"language-text\">.</code>” — so the matching conditions aren’t particularly demanding.</p>\n<p>But look closely: the spec says the host and domain identifier are connected by <code class=\"language-text\">.</code>, but it doesn’t say <code class=\"language-text\">.</code> appears only once. So we need to handle cases like <code class=\"language-text\">google.com</code> as well as <code class=\"language-text\">google.co.kr</code> where <code class=\"language-text\">.</code> appears multiple times.</p>\n<p>These ambiguous patterns are easily handled with the Non-Capturing Group we just used:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^(?:\\w+\\.)+\\w+$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">(?:\\w+\\.)+</code> expresses that a word group followed by <code class=\"language-text\">.</code> (like <code class=\"language-text\">google.</code>) must appear at least once, and the trailing <code class=\"language-text\">\\w+</code> requires that another word group must follow the final <code class=\"language-text\">.</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Both host and domain identifier present</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google.co.kr'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//true</span>\n\n<span class=\"token comment\">// Missing domain identifier</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'google'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n\n<span class=\"token comment\">// Missing host</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.co.kr'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4 id=\"combining-the-local-part-and-domain-patterns\" style=\"position:relative;\">Combining the Local Part and Domain Patterns<a href=\"#combining-the-local-part-and-domain-patterns\" aria-label=\"combining the local part and domain patterns permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Now that we have regex patterns for both valid local parts and domains, we just need to join them with <code class=\"language-text\">@</code> to satisfy the final condition: “the local part and domain are connected by <code class=\"language-text\">@</code>.”</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Local part pattern: ^[\\w!#$%&amp;'*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_{|}~-]+)*</span>\n<span class=\"token comment\">// Domain pattern: (?:\\w+\\.)+\\w+$</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^[\\w!#$%&amp;'*+/=?^_{|}~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_{|}~-]+)*@(?:\\w+\\.)+\\w+$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">regex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart.evan@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart@naver.co.kr'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.bboydart91@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91@gmail'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bboydart91.@gmail.com'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3 id=\"phone-numbers\" style=\"position:relative;\">Phone Numbers<a href=\"#phone-numbers\" aria-label=\"phone numbers permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Phone numbers are another piece of data you frequently receive from users. I touched on this in the previous post, <a href=\"/2020/07/24/about-regular-expression\">Finding Patterns in Irregularity</a>, but I’ll revisit it here for readers who may have missed that one.</p>\n<p>Phone number formats vary by country, but the core idea is universal: digits grouped in a predictable structure separated by delimiters. Let’s use US phone numbers as an example. A standard US phone number has a 3-digit area code, a 3-digit exchange code, and a 4-digit subscriber number:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'212-555-1234'</span>\n<span class=\"token string\">'(212) 555-1234'</span>\n<span class=\"token string\">'2125551234'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Since phone numbers are just digits repeating in fixed-length groups, the regex to match them is straightforward:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\d{3}-?\\d{3}-?\\d{4}$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">regex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2125551234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'212-555-1234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'3015551234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'301-555-1234'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The digit counts in each field are clearly defined, so simple quantifiers do the job. The hyphens between fields may or may not be present, so we use the <code class=\"language-text\">?</code> quantifier (zero or one) to handle them.</p>\n<p>The regex itself is straightforward, but there’s a subtle mistake developers sometimes make in practice:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Pattern that only matches numbers starting with a specific area code</span>\n<span class=\"token operator\">/</span><span class=\"token number\">212</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>This pattern only captures phone numbers with the <code class=\"language-text\">212</code> area code. If your validation is too narrow, you’ll reject perfectly valid phone numbers from other regions.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/5d22138cdc7f106c76184f763b009060/41099/old_phone.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 66.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDBP/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAF4bZikSGP/xAAbEAACAQUAAAAAAAAAAAAAAAAAAQISEyEiMv/aAAgBAQABBQLQqki2xYHy5s//xAAWEQADAAAAAAAAAAAAAAAAAAABECH/2gAIAQMBAT8BMX//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwFH/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAEQMUH/2gAIAQEABj8CwfYxT//EABkQAQEBAQEBAAAAAAAAAAAAAAERACExQf/aAAgBAQABPyEATpndAlQ/HQ9evc7BjOi0uQ7/2gAMAwEAAgADAAAAEGPf/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAwEBPxDBMp//xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8QHY//xAAZEAEBAAMBAAAAAAAAAAAAAAABEQAhMUH/2gAIAQEAAT8QYwEaGgeFyCchT3fIcxh2hVybek20lTmWCj0aO+ZWrXP/2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"old phone\" title=\"\" src=\"/static/5d22138cdc7f106c76184f763b009060/41099/old_phone.jpg\" srcset=\"/static/5d22138cdc7f106c76184f763b009060/0913d/old_phone.jpg 160w,\n/static/5d22138cdc7f106c76184f763b009060/cb69c/old_phone.jpg 320w,\n/static/5d22138cdc7f106c76184f763b009060/41099/old_phone.jpg 500w\" sizes=\"(max-width: 500px) 100vw, 500px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>The 1996 \"Gulliver Phone\" — a nostalgic relic from the early mobile era</small>\n</center>\n<p>The takeaway: when building phone number validation, think about all the formats your users might enter. Consider international prefixes, area codes with varying lengths, and optional delimiters like hyphens, dots, or parentheses. A pattern like <code class=\"language-text\">\\d{3}[-.\\s]?\\d{3}[-.\\s]?\\d{4}</code> handles more cases gracefully.</p>\n<h3 id=\"passwords\" style=\"position:relative;\">Passwords<a href=\"#passwords\" aria-label=\"passwords permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Passwords are directly tied to user authentication and security, making them one of the more demanding fields to validate.</p>\n<p>Off the top of my head, there are roughly three common conditions — these are baseline security requirements observed across most services:</p>\n<blockquote>\n<ul>\n<li>Must contain at least one lowercase letter, one uppercase letter, one digit, and one special character.</li>\n<li>No character may repeat three or more times consecutively.</li>\n<li>Must be at least 8 characters long.</li>\n</ul>\n</blockquote>\n<p>Depending on how detailed you want your error messages to be, you might validate these conditions individually or all at once.</p>\n<p>The first condition requires that the password contains at least one of each character type. Checking them individually is simple with expressions like <code class=\"language-text\">/[a-z]/g</code> or <code class=\"language-text\">/\\d/g</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> password <span class=\"token operator\">=</span> <span class=\"token string\">'test1234!'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Individual checks</span>\n<span class=\"token keyword\">const</span> hasNumberPattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\d</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> hasLowerCasePattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[a-z]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> hasUpperCasePattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[A-Z]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> hasSpecialCharPattern <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\W</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasNumberPattern<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Password must contain at least one number...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasLowerCasePattern<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Password must contain at least one lowercase letter...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>But the challenge arises when you want to check all conditions at once. A custom group like <code class=\"language-text\">[a-zA-Z\\d]</code> would pass if just one type is present, and a pattern like <code class=\"language-text\">[a-z]+[A-Z]+</code> would enforce a specific order — “lowercase must come before uppercase” — which isn’t what we want.</p>\n<p>This is where we can use a slightly tricky technique.</p>\n<h4 id=\"validating-with-lookaround\" style=\"position:relative;\">Validating with Lookaround<a href=\"#validating-with-lookaround\" aria-label=\"validating with lookaround permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The technique is Positive Lookahead (<code class=\"language-text\">(?=)</code>), which matches a pattern based on what follows it.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Match \"https\" only when followed by \"://\"</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">https(?=:\\/\\/)</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">regex<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// null</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ['https']</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Expressions that match based on what appears before or after a pattern are called “Lookaround,” and they come in four flavors:</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Pattern</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Positive Lookahead</td>\n<td><code class=\"language-text\">abc(?=123)</code></td>\n<td>Match <code class=\"language-text\">abc</code> when followed by <code class=\"language-text\">123</code></td>\n</tr>\n<tr>\n<td>Negative Lookahead</td>\n<td><code class=\"language-text\">abc(?!123)</code></td>\n<td>Match <code class=\"language-text\">abc</code> when NOT followed by <code class=\"language-text\">123</code></td>\n</tr>\n<tr>\n<td>Positive Lookbehind</td>\n<td><code class=\"language-text\">(?&lt;=123)abc</code></td>\n<td>Match <code class=\"language-text\">abc</code> when preceded by <code class=\"language-text\">123</code></td>\n</tr>\n<tr>\n<td>Negative Lookbehind</td>\n<td><code class=\"language-text\">(?&lt;!123)abc</code></td>\n<td>Match <code class=\"language-text\">abc</code> when NOT preceded by <code class=\"language-text\">123</code></td>\n</tr>\n</tbody>\n</table>\n<p>True to the name “look around,” these expressions check whether a specific pattern exists before or after the target. But by understanding how the regex engine processes them, we can repurpose them to check whether a certain pattern appears at least once anywhere in a string.</p>\n<p>Lookaround expressions don’t actually consume characters — they act as boundaries, similar to the <a href=\"/2020/07/24/about-regular-expression/#anchors-that-match-boundaries-not-characters\">\\b anchor</a>. The crucial characteristic is that even when the regex engine successfully matches a character via Lookaround, it then acts as if that match never happened.</p>\n<p>Let me illustrate with a detailed example. If we apply the expression <code class=\"language-text\">q(?=u)i</code> to the string <code class=\"language-text\">quit</code>, the regex engine works like this:</p>\n<blockquote>\n<ol>\n<li>Engine tries to match <code class=\"language-text\">q</code> in the string. The literal <code class=\"language-text\">q</code> in the regex matches — success.</li>\n<li>Engine tries to match <code class=\"language-text\">u</code> in the string. The <code class=\"language-text\">u</code> inside <code class=\"language-text\">(?=u)</code> matches — success. Then the engine “forgets” that this Lookaround match ever happened.</li>\n<li>Engine now tries to match the pattern <em>after</em> the Lookaround against <code class=\"language-text\">u</code> again.</li>\n<li>But the next expression is <code class=\"language-text\">i</code>. It doesn’t match <code class=\"language-text\">u</code> — failure.</li>\n</ol>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">q(?=u)i</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'quit'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">null</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>This makes sense when you think about it: <code class=\"language-text\">(?=u)</code> is merely a condition for what should follow <code class=\"language-text\">q</code> — it’s not actually trying to capture <code class=\"language-text\">u</code>. That’s why the regex engine tries to match <code class=\"language-text\">u</code> again with the next expression after the Lookaround.</p>\n<p>If we change the literal after <code class=\"language-text\">(?=u)</code> from <code class=\"language-text\">i</code> to <code class=\"language-text\">u</code>, condition 4 passes and we get a match:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">q(?=u)u</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'quit'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"qu\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The key insight is that the regex engine treats a Lookaround match as a “preliminary” match rather than a “real” one, so it re-attempts matching the same character with whatever expression comes after the Lookaround.</p>\n<p>By exploiting this behavior, we can effectively use Lookaround as an <code class=\"language-text\">if</code> statement. Let’s use this technique to check one of our password conditions:</p>\n<blockquote>\n<p>Must contain at least one lowercase letter, one uppercase letter, one digit, and one special character.</p>\n</blockquote>\n<p>Checking all at once would make the expression long, so let’s start with just one condition: does the password contain at least one digit?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=\\d).</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abc123'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The regex matched <code class=\"language-text\">1</code> because <code class=\"language-text\">(?=\\d)</code> successfully matched <code class=\"language-text\">1</code>, and then the engine re-attempted the match on the same character using <code class=\"language-text\">.</code> — which succeeded.</p>\n<p>In pseudocode, it works like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=\\d)</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=\\d)</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Pattern matched, discard it</span>\n  <span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Re-attempt with the next pattern on the same character</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In other words, the fact that the engine reached the <code class=\"language-text\">.</code> literal means the preceding <code class=\"language-text\">(?=\\d)</code> already matched that character successfully.</p>\n<p>Now that we’ve handled digits, we just chain the remaining conditions — lowercase, uppercase, and special characters — in the same way:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// \\d = digit</span>\n<span class=\"token comment\">// [a-z] = lowercase letter</span>\n<span class=\"token comment\">// [A-Z] = uppercase letter</span>\n<span class=\"token comment\">// [\\W] = non-word character (not a letter or digit)</span>\n<span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\\d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">[</span>a<span class=\"token operator\">-</span>z<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token operator\">-</span><span class=\"token constant\">Z</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">=</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">[</span>\\<span class=\"token constant\">W</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>g</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The <code class=\"language-text\">\\W</code> character class technically matches any non-word character, which includes not just special characters but also characters like CJK or Cyrillic. Listing every special character individually would be tedious, so I’m using the shorthand here. <del>(Laziness is a virtue.)</del> <small>(In production, you’d want to explicitly list the allowed special characters like <code class=\"language-text\">!@#$%^...</code>.)</small></p>\n<p>Using the same approach, we can add the remaining conditions — “no character repeats 3+ times consecutively” and “at least 8 characters” — into a single expression:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\\W])(?!.*(.)\\1{2}).{8,}</span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">(?=.*\\d)</code></td>\n<td>Contains at least one <code class=\"language-text\">\\d</code> (digit)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?=.*[a-z])</code></td>\n<td>Contains at least one <code class=\"language-text\">[a-z]</code> (lowercase)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?=.*[A-Z])</code></td>\n<td>Contains at least one <code class=\"language-text\">[A-Z]</code> (uppercase)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?=.*[\\W])</code></td>\n<td>Contains at least one <code class=\"language-text\">[\\W]</code> (special character)</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">(?!.*(.)\\1{2})</code></td>\n<td>No character repeats 3+ times consecutively</td>\n</tr>\n<tr>\n<td><code class=\"language-text\">.{8,}</code></td>\n<td>At least 8 characters that pass all above conditions</td>\n</tr>\n</tbody>\n</table>\n<p>This expression only reaches the final <code class=\"language-text\">.{8,}</code> after all the Positive and Negative Lookahead conditions pass, so any string that matches has satisfied every condition we defined.</p>\n<p>Of course, validating passwords with a single regex like this means you can only show a generic “Invalid password” error message, so in practice it’s more common to check conditions individually. But Lookaround-based conditional checking is such a useful technique that I thought it was worth explaining in detail.</p>\n<h2 id=\"extracting-specific-information-from-irregular-strings\" style=\"position:relative;\">Extracting Specific Information from Irregular Strings<a href=\"#extracting-specific-information-from-irregular-strings\" aria-label=\"extracting specific information from irregular strings permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Most of the time, regex is used for validating user input. But the true raison d’être of regex isn’t merely validation — it’s finding and extracting specific patterns from within irregular data.</p>\n<p>This time, I want to share some real-world scenarios I’ve encountered, along with how I used regex to solve them.</p>\n<h3 id=\"extracting-only-numbers-from-a-string\" style=\"position:relative;\">Extracting Only Numbers from a String<a href=\"#extracting-only-numbers-from-a-string\" aria-label=\"extracting only numbers from a string permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Extracting just the numbers from a given string is a surprisingly common problem in practice. I’ve frequently needed to pull out numbers representing amounts or ages from source data I couldn’t modify directly, in order to normalize the data or display it in a different format.</p>\n<p>For example, imagine an API that returns price information not as a numeric <code class=\"language-text\">1000</code> but as a formatted string like <code class=\"language-text\">$1,000</code>. And your client needs this business logic:</p>\n<blockquote>\n<p>Which is the larger amount: ”<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>000</mn><mi mathvariant=\"normal\">\"</mi><mi>o</mi><mi>r</mi><mi mathvariant=\"normal\">\"</mi></mrow><annotation encoding=\"application/x-tex\">1,000\" or \"</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">000\"</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord\">\"</span></span></span></span></span>2,000”?</p>\n</blockquote>\n<p>Ideally, the raw data would come as a numeric <code class=\"language-text\">1000</code> and the display formatting would happen on the client side. But modifying the API might require auditing everywhere it’s used and updating every client that consumes it — so sometimes you just leave it as-is for risk management.</p>\n<p>In this situation, the developer needs to strip everything except the digits from <code class=\"language-text\">$1,000</code>, convert it to <code class=\"language-text\">1000</code>, and then compare the two amounts.</p>\n<p>Without regex, you’d have to split the string, iterate through the resulting array checking whether each character is a digit, or call <code class=\"language-text\">String.prototype.replace</code> multiple times:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">NUMBERS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'3'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'4'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'5'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'6'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'7'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'8'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'9'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'$1,000'</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> <span class=\"token constant\">NUMBERS</span><span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Or</span>\n\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'$1,000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'$'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">1000</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The <code class=\"language-text\">String.prototype.replace</code> approach looks simple enough, but its limitation is that if any unexpected characters sneak in, you need to add another <code class=\"language-text\">replace</code> for each one. <small>(The moment a string like <code class=\"language-text\">$1,000...maybe?</code> shows up, you’re in trouble.)</small></p>\n<p>With regex, you can solve the same problem far more concisely and flexibly:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'$1,000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^0-9]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Or</span>\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'$1,000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^\\d]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Or</span>\n<span class=\"token keyword\">const</span> amount <span class=\"token operator\">=</span> <span class=\"token string\">'$1,000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\D</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token number\">1000</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>JavaScript’s <code class=\"language-text\">String.prototype.replace</code> method searches for a pattern and replaces it with the second argument. Since <code class=\"language-text\">replace</code> supports regex, we can catch “everything that isn’t a digit” and replace it with an empty string — effectively solving our “extract only numbers” problem.</p>\n<p>The expressions <code class=\"language-text\">[^0-9]</code>, <code class=\"language-text\">[^\\d]</code>, and <code class=\"language-text\">\\D</code> all mean “characters that are not digits,” letting us strip everything non-numeric in one shot.</p>\n<p>Of course, you can solve this without regex by combining <code class=\"language-text\">split</code>, <code class=\"language-text\">filter</code>, <code class=\"language-text\">join</code>, and <code class=\"language-text\">replace</code>. But in the real world, problems far more complex than “find the numbers in a string” are the norm.</p>\n<p>Let’s look at a slightly harder problem.</p>\n<h3 id=\"extracting-monetary-values-from-a-sentence\" style=\"position:relative;\">Extracting Monetary Values from a Sentence<a href=\"#extracting-monetary-values-from-a-sentence\" aria-label=\"extracting monetary values from a sentence permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>This time, we’ll tackle a problem in the same vein but more complex. Instead of extracting digits from a clearly monetary string like <code class=\"language-text\">$1,000</code>, we need to find and extract monetary values from a long natural-language sentence.</p>\n<p>Here’s an example paragraph — drawn from my wishful thinking about getting rich:</p>\n<blockquote>\n<p>The global luxury goods market reached approximately <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>362</mn><mi>b</mi><mi>i</mi><mi>l</mi><mi>l</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>i</mi><mi>n</mi><mn>2023.</mn><mi>T</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>u</mi><mi>m</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">362 billion in 2023. The average consumer spent around </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">362</span><span class=\"mord mathnormal\">bi</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">nin</span><span class=\"mord\">2023.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">eco</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">ers</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span></span></span></span></span>1,200 per year on luxury items. According to a recent survey, roughly 45% of millennials purchased at least one luxury item, with an average transaction value of <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>890</mn><mi>p</mi><mi>e</mi><mi>r</mi><mi>p</mi><mi>u</mi><mi>r</mi><mi>c</mi><mi>h</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi mathvariant=\"normal\">.</mi><mi>T</mi><mi>h</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>i</mi><mi>s</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>t</mi><mi>o</mi><mi>g</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>t</mi><mi>o</mi></mrow><annotation encoding=\"application/x-tex\">890 per purchase. The market is projected to grow to </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">890</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">rc</span><span class=\"mord mathnormal\">ha</span><span class=\"mord mathnormal\">se</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">wt</span><span class=\"mord mathnormal\">o</span></span></span></span></span>500 billion by 2030.</p>\n</blockquote>\n<p>If we need to extract only the monetary data from this long sentence, we can break the problem into two smaller problems:</p>\n<blockquote>\n<ol>\n<li>From all the numbers in the text, pick out only the ones that represent monetary values.</li>\n<li>Convert values like <code class=\"language-text\">$362 billion</code> into a numeric <code class=\"language-text\">362000000000</code>.</li>\n</ol>\n</blockquote>\n<p>The second problem is a bit much for regex alone, so let’s focus on the first: “pick out only the monetary values from all the numbers.”</p>\n<p>If we just used <code class=\"language-text\">\\d</code> or <code class=\"language-text\">[0-9]</code>, we’d also catch numbers from <code class=\"language-text\">2023</code>, <code class=\"language-text\">45%</code>, and <code class=\"language-text\">2030</code> — which aren’t monetary values. So a simple approach won’t cut it.</p>\n<p>But the real power of regex shines in situations like this. Even though monetary values seem to appear irregularly in natural language, they actually follow a specific pattern. In English, monetary values are preceded by a currency symbol like <code class=\"language-text\">$</code>:</p>\n<p>Using this observation, we can write a regex to find dollar amounts:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> string <span class=\"token operator\">=</span> <span class=\"token string\">'The global luxury goods market reached approximately $362 billion in 2023. The average consumer spent around $1,200 per year on luxury items. According to a recent survey, roughly 45% of millennials purchased at least one luxury item, with an average transaction value of $890 per purchase. The market is projected to grow to $500 billion by 2030.'</span><span class=\"token punctuation\">;</span>\n\nstring<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\$[\\d,]+(?:\\s(?:billion|million|thousand))?</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"$362 billion\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"$1,200\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"$890\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"$500 billion\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">String.prototype.match</code> finds all substrings that match the given regex. Since monetary values appear multiple times in the sentence, <code class=\"language-text\">match</code> returns all of them.</p>\n<p>The regex <code class=\"language-text\">\\$[\\d,]+(?:\\s(?:billion|million|thousand))?</code> breaks down as:</p>\n<blockquote>\n<p><code class=\"language-text\">\\$</code>: A literal <code class=\"language-text\">$</code> sign (escaped because <code class=\"language-text\">$</code> is a special regex character)</p>\n<p><code class=\"language-text\">[\\d,]+</code>: One or more digits or commas</p>\n<p><code class=\"language-text\">(?:\\s(?:billion|million|thousand))?</code>: Optionally followed by a space and a magnitude word</p>\n</blockquote>\n<p>In the previous post, I covered simple expressions like <code class=\"language-text\">[^\\d]</code>. This time the regex is more complex because we’re dealing with a multi-condition pattern — but the underlying principle is the same. We’re combining character classes, quantifiers, and non-capturing groups to precisely describe the pattern we’re looking for.</p>\n<p>Regex is just a tool for finding patterns in strings. Beyond extracting data like this, it can validate user input, parse HTML or JavaScript code, parse file formats — it’s useful virtually everywhere, making it a skill that pays dividends for a long time.</p>\n<h2 id=\"reformatting-strings\" style=\"position:relative;\">Reformatting Strings<a href=\"#reformatting-strings\" aria-label=\"reformatting strings permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>As hinted at in earlier examples, regex is also incredibly useful when you need to transform strings into a specific format.</p>\n<p>Think: masking sensitive user information with <code class=\"language-text\">*</code> characters, or inserting <code class=\"language-text\">-</code> between digits in a phone or credit card number for readability.</p>\n<p>Regex’s capturing feature is particularly effective here. Capturing is useful in many situations, but it truly shines when you need to grab specific parts of a string and replace the rest.</p>\n<h3 id=\"masking-user-information\" style=\"position:relative;\">Masking User Information<a href=\"#masking-user-information\" aria-label=\"masking user information permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>When building services, you sometimes need to display a list of users while masking their sensitive information. To signal that these are real people (not bots), you typically mask only part of the data rather than all of it.</p>\n<p>For names, you might show the first character and mask the rest. For phone numbers, you might reveal the area code and first couple of digits while masking everything else.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">mask</span> <span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> headCount <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Get the first n characters of the string</span>\n  <span class=\"token keyword\">const</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">^.{</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>headCount<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">}</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Mask everything except head</span>\n  <span class=\"token keyword\">const</span> tails <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Combine head and tails</span>\n  <span class=\"token keyword\">return</span> head <span class=\"token operator\">+</span> tails<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Evan Moon'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'01012345678'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'Ev** ****'</span>\n<span class=\"token string\">'01012******'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>The <code class=\"language-text\">mask</code> function takes the number of characters to leave unmasked as an argument, so we need to construct the regex dynamically using a <code class=\"language-text\">RegExp</code> object rather than the <code class=\"language-text\">/</code> literal syntax.</p>\n<p>But simple character counting can cause problems in cases like these:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Spaces count toward the character limit</span>\n<span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'E Van Moon'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Hyphens count too</span>\n<span class=\"token function\">mask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'010-1234-5678'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Intended to skip 2 characters, but only 1 is visible</span>\n<span class=\"token string\">'E ********'</span>\n\n<span class=\"token comment\">// Intended to skip 5 characters, but only 4 are visible</span>\n<span class=\"token string\">'010-1********'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This technically works, but <code class=\"language-text\">E V** ****</code> or <code class=\"language-text\">010-12**-****</code> looks much cleaner — excluding spaces and hyphens from the character count improves both completeness and readability.</p>\n<p>The tricky part is counting characters while skipping spaces and <code class=\"language-text\">-</code>. But regex quantifiers count <em>patterns</em>, not individual characters:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Did the (?:) grouped pattern appear 2 times?</span>\n<span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span>\\<span class=\"token constant\">S</span><span class=\"token punctuation\">[</span>\\s<span class=\"token operator\">-</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>This expression means: a non-space character (<code class=\"language-text\">\\S</code>) optionally followed by spaces or <code class=\"language-text\">-</code>, repeated 2 times. For a string like <code class=\"language-text\">E E-</code>, it groups <code class=\"language-text\">E\\s</code> or <code class=\"language-text\">E-</code> as a single unit for counting.</p>\n<p>Remember: to apply a quantifier to a complex pattern, you need to wrap it in <code class=\"language-text\">(?:)</code> (Non-Capturing Group) or <code class=\"language-text\">()</code> (Capturing Group).</p>\n<p>Using this property of regex quantifiers, we can easily satisfy both conditions — skip the first n visible characters and exclude spaces/hyphens from the count:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">enhancedMask</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">str<span class=\"token punctuation\">,</span> headCount <span class=\"token operator\">=</span> <span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Group \\S[\\s-]* patterns n times and assign to head</span>\n  <span class=\"token keyword\">const</span> head <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">^(?:\\\\S[\\\\s-]*){</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>headCount<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">}</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'g'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">exec</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Mask everything in the tail except spaces and hyphens</span>\n  <span class=\"token keyword\">const</span> tails <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^\\s-]</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Combine head and tails</span>\n  <span class=\"token keyword\">return</span> head <span class=\"token operator\">+</span> tails<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token function\">enhancedMask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'E Van Moon'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">enhancedMask</span><span class=\"token punctuation\">(</span><span class=\"token string\">'010-1234-5678'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'E V** ****'</span>\n<span class=\"token string\">'010-12**-****'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"find-and-replace-in-your-ide\" style=\"position:relative;\">Find-and-Replace in Your IDE<a href=\"#find-and-replace-in-your-ide\" aria-label=\"find and replace in your ide permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Most IDEs and code editors support regex in their Find and Replace features. Since code is essentially a collection of strings with specific patterns, regex can be far more effective than plain text search.</p>\n<p>There are many examples of using regex to find and modify code, but let me share a scenario I personally stumble into frequently.</p>\n<p>In JavaScript modules, when you export a constant or function without the <code class=\"language-text\">default</code> keyword, the module evaluates as an object:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Test</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Test</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Test <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>You typically use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" target=\"_blank\" rel=\"nofollow\">destructuring assignment</a> to access the value you want. The problem arises when the export style changes mid-development:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Test</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Test</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Export style changed</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Test<span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Test <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Module not found: Error: Cannot resolve 'file' or 'directory'</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>When you’re working fast, it’s easy to change a module’s export style without thinking about all the places that import it. In such cases, you might revert the export, but if the developer intentionally switched to <code class=\"language-text\">export default</code>, you need to find and update every import statement.</p>\n<p>Since most IDEs support regex in Find and Replace, we can handle this quickly:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 528px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cd303e1a62e4fc55b0c2dc0621732980/4af8e/use_regex.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 51.87500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACGElEQVR42mVSa2+bQBDkj0SNHXCwAfOG443BNgY/kjhxIjVqFUVVlR9QqT9/OpxSqVI/jI5bdndmd05Jy0cMzTdoMw/1qkdZdZhMLHy5NnA9MbEwQphWDNfLYC2FhGH40Kwcoj7h7viMZn1CUfawLAGlLi/4PfyCqrkwlxlcv4LtFliYCYtz3uvPOxtZKbxgTYISNzMfptfC9ltYXg3DqaGbKZS2fkGxeoI+j5GVA/rhCcPhGXV7wmb3iG64oN0+wA1WRI1+/46mfcVM9+HFPUynQhj0CMIBtwsqfNz/wPHwDl2PyFCQrYOqCyLEjCQa49o8YoMYllNQYSlX03LMFUmb9oBut8f5ckIQlVBEcoQZbnGrBxBJy2CDNNtAXwSYTC1Mb2xiiQkxVW3Mbj3u25EkdrhjXgo3KZGUBZYkVIr6Gd+7D1mY5luOe0HV7CmfykjyP0KoM5f/YzhRj7mZQZ2PubGMKXl2j5+bD7L6yIotHTugrHuaEElFN5rzD1zGHOn+WGwHW8yNBJorICjmeP8VSpidYImeo/gct6LsHJFo6aiQxSqJVD6pv81Gt12vkHHdiKXi08MrLi9vGPiEFFGcEWd38tmMoyzMmAYEZI5lU30RytOyU57JZ3zMYdyu5C5zTlS1e6lSCcSAQOyhUWFEhaNrFRNyjp9ma3muN0f53e3umFPj6konkZCmjDv0nQ5ZdIbvdvgDLCpH2gIHBEIAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"use regex\" title=\"\" src=\"/static/cd303e1a62e4fc55b0c2dc0621732980/4af8e/use_regex.png\" srcset=\"/static/cd303e1a62e4fc55b0c2dc0621732980/69538/use_regex.png 160w,\n/static/cd303e1a62e4fc55b0c2dc0621732980/72799/use_regex.png 320w,\n/static/cd303e1a62e4fc55b0c2dc0621732980/4af8e/use_regex.png 528w\" sizes=\"(max-width: 528px) 100vw, 528px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Regex lets you target exactly the parts you need</small>\n</center>\n<p>The challenge is that in <code class=\"language-text\">import { Test } from 'components/Test'</code>, parts like <code class=\"language-text\">import</code> and <code class=\"language-text\">from 'components/Test'</code> need to stay unchanged. And since we’re only changing the import style, not renaming the variable, we want to keep <code class=\"language-text\">Test</code> as-is.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Change this</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Test <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Into this</span>\n<span class=\"token keyword\">import</span> Test <span class=\"token keyword\">from</span> <span class=\"token string\">'components/Test'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Regex capturing makes this precise transformation possible — capture exactly the parts you want to keep and replace the rest:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> targetCode <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">import { Component } from 'components/Test';</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\ntargetCode<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\{\\s(Component)\\s\\}</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'$1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">import Component from 'components/Test';</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Using regex for find-and-replace in your IDE really shines during migration work — library upgrades with breaking changes, large-scale refactors, and the like. <del>(In truth, I just make this mistake often enough that it made a good example.)</del></p>\n<h2 id=\"wrapping-up\" style=\"position:relative;\">Wrapping Up<a href=\"#wrapping-up\" aria-label=\"wrapping up permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Regular expressions are an abstract tool for matching patterns in strings, which gives them an enormous range of applications.</p>\n<p>Beyond the examples in this post, regex can be used to parse files, normalize scraped data, quickly search log files, and much more. Plus, regex syntax barely differs between programming languages, so once you learn it, you’ll keep reaching for it across your entire career.</p>\n<p>That’s all for this post on how regex is actually used.</p>","fields":{"slug":"20200815-regex-example-en","path":"/2020/08/15/regex-example/en/","lang":"en"},"frontmatter":{"title":"How Do You Actually Use Regex?","subTitle":"A journey of finding order in irregular data","date":"Sep 15, 2020","categories":["Programming"],"tags":["Regex","Regular Expression","Extracting Numbers","Lookahead","Lookbehind","Lookaround","Capturing Group"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/fc5c5/thumbnail.webp 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}},{"node":{"id":"5378ff90-1b70-5262-9faf-4d5f6558180f","tableOfContents":"<ul>\n<li>\n<p><a href=\"#what-even-is-regex\">What Even Is Regex?</a></p>\n</li>\n<li>\n<p><a href=\"#basic-regex-features\">Basic Regex Features</a></p>\n<ul>\n<li><a href=\"#character-classes-catching-groups-of-characters\">Character Classes: Catching Groups of Characters</a></li>\n<li><a href=\"#anchors-catching-boundaries-not-characters\">Anchors: Catching Boundaries, Not Characters</a></li>\n<li><a href=\"#flags-regex-options\">Flags: Regex Options</a></li>\n<li><a href=\"#quantifiers-how-many-times-a-pattern-appears\">Quantifiers: How Many Times a Pattern Appears</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#nice-to-know-advanced-features\">Nice-to-Know Advanced Features</a></p>\n<ul>\n<li><a href=\"#capturing-remembering-patterns\">Capturing: Remembering Patterns</a></li>\n<li><a href=\"#greedy-vs-lazy\">Greedy vs. Lazy</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#wrapping-up\">Wrapping Up</a></p>\n</li>\n</ul>","excerpt":"Developers are people who analyze problems described in natural language, then design and write programs to solve them. This work often involves filtering out the useful bits from a flood of unstructured information, or abstracting haphazardly declared classes and variables into clean structures.","html":"<p>Developers are people who analyze problems described in natural language, then design and write programs to solve them. This work often involves filtering out the useful bits from a flood of unstructured information, or abstracting haphazardly declared classes and variables into clean structures.</p>\n<!-- more -->\n<p>Many skills contribute to doing this well, but one especially important one is the ability to find regularity — patterns — within seemingly irregular information.</p>\n<p>Among the most common problems in everyday business contexts are things like parsing files or validating user input: extracting desired information by finding patterns in irregular strings. But the sheer number of edge cases means that trying to solve these with plain programming alone can leave you drowning in a spectacular nest of <code class=\"language-text\">if</code> statements.</p>\n<p>This is exactly the kind of problem that regular expressions — regex — make easy to solve.</p>\n<h2 id=\"what-even-is-regex\" style=\"position:relative;\">What Even Is Regex?<a href=\"#what-even-is-regex\" aria-label=\"what even is regex permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>The full name is “regular expression,” but in practice it goes by regex, regexp, or various affectionate nicknames in different developer communities.</p>\n<p>Regex is a type of expression that can represent patterns, and by applying these expressions to strings, you can pluck out exactly the parts you want — an incredibly convenient tool. But thanks to its notoriously hostile readability, regex tends to be met with a certain… reluctance.</p>\n<p>I use regex fairly often myself, but unless it’s a pattern I write frequently, I always Google the expression and verify it on <a href=\"https://regexr.com/\" target=\"_blank\" rel=\"nofollow\">RegExr</a> before using it.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cf1e76c74723af6eb45ee626ca4269a9/e5166/regex_meme.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAIDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAAB32UTM6UU0wG1Av/EABoQAQEBAQADAAAAAAAAAAAAAAECAxEAEiH/2gAIAQEAAQUCvXlNEnfLZ96iED5pAumJZJw//8QAFREBAQAAAAAAAAAAAAAAAAAAEAH/2gAIAQMBAT8BIf/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABsQAAICAwEAAAAAAAAAAAAAAAERABACITFB/9oACAEBAAY/Al5GclSLm+WiShX/xAAcEAEAAgMBAQEAAAAAAAAAAAABABEhMUFRgaH/2gAIAQEAAT8hW+aewNVPZdBHDLg9NkzifghA79iJfIG5pUpS2jE//9oADAMBAAIAAwAAABBsPwP/xAAaEQEAAQUAAAAAAAAAAAAAAAABEBEhQWHB/9oACAEDAQE/EBat4OdvI//EABcRAQEBAQAAAAAAAAAAAAAAAAABMUH/2gAIAQIBAT8Qmq6r/8QAGxABAAMBAQEBAAAAAAAAAAAAAQARIUExUYH/2gAIAQEAAT8QaOoLcX3IcLIJ/YXBgInSPUmgph2AgAcL0SHQoDG3nJZzdCys2e0w2Fr9chA0ILrwJ//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"regex meme\" title=\"\" src=\"/static/cf1e76c74723af6eb45ee626ca4269a9/c08c5/regex_meme.jpg\" srcset=\"/static/cf1e76c74723af6eb45ee626ca4269a9/0913d/regex_meme.jpg 160w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/cb69c/regex_meme.jpg 320w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/c08c5/regex_meme.jpg 640w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/6a068/regex_meme.jpg 960w,\n/static/cf1e76c74723af6eb45ee626ca4269a9/e5166/regex_meme.jpg 1200w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Memes like this exist because regex genuinely looks like gibberish at first glance</small>\n</center>\n<p>But since regex’s primary use case is finding patterns in strings — a situation developers encounter constantly — you’ll inevitably cross paths with regex sooner or later. There’s no escaping it. <del>(Just accept your fate and it gets easier.)</del></p>\n<p>Of course, staring at regex cold makes you think “what on earth does this mean?” But even the longest regular expression is just small expressions combined together, so when you break them apart, they’re often simpler than you’d expect.</p>\n<h2 id=\"basic-regex-features\" style=\"position:relative;\">Basic Regex Features<a href=\"#basic-regex-features\" aria-label=\"basic regex features permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Regex has a wide variety of keywords, and the entirety of using regex comes down to combining these keywords to build expressions that capture the patterns you want. In other words, the most fundamental way to get started with regex is to memorize these keywords.</p>\n<p>You don’t need to know every keyword — just searching “regex” on Google yields an avalanche of references. But memorizing at least the basics means you can solve simple pattern matching problems without consulting Google, which is a win for productivity. <del>(Memorizing all of them is impossible anyway.)</del></p>\n<p>Combining these features appropriately for each situation is what determines how well you use regex. So in this post, I’ll give a quick taste of the features regex provides, and in the next post, I’ll go deeper with practical, real-world examples.</p>\n<h3 id=\"character-classes-catching-groups-of-characters\" style=\"position:relative;\">Character Classes: Catching Groups of Characters<a href=\"#character-classes-catching-groups-of-characters\" aria-label=\"character classes catching groups of characters permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Regex has various keywords that represent specific characters or groups of characters. These are called “character classes.”</p>\n<p>Since the core function of regex is finding the characters you want, knowing the types and roles of character classes lets you roughly decipher simple regex patterns without Googling.</p>\n<h4 id=\"lets-start-by-finding-specific-characters\" style=\"position:relative;\">Let’s Start by Finding Specific Characters<a href=\"#lets-start-by-finding-specific-characters\" aria-label=\"lets start by finding specific characters permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Regex is packed with character classes like <code class=\"language-text\">\\d</code> and <code class=\"language-text\">\\w</code> whose meanings aren’t obvious at a glance. But these cryptic keywords aren’t the only option. For example, to extract a specific word from a long sentence, you can just write:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'hello, world'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">hello</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"hello, world\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Since regular characters work freely in regex, keywords like <code class=\"language-text\">\\w</code> and <code class=\"language-text\">\\s</code> that represent character groups must be escaped with <code class=\"language-text\">\\</code> in front. In other words, <code class=\"language-text\">\\s</code> is a keyword, but <code class=\"language-text\">s</code> is just the letter s.</p>\n<p>Because of this escaping, people unfamiliar with regex often get confused about whether something is <code class=\"language-text\">s</code> or the whitespace keyword <code class=\"language-text\">\\s</code>. There’s no magic tip here — when you see something like <code class=\"language-text\">/\\/s\\.s.{1,2}/</code>, just read it by slicing from left to right, one token at a time.</p>\n<p>Using specific characters like <code class=\"language-text\">hello</code> in a regex can find exact patterns in strings, but if all you need is to find a specific string, you don’t need regex at all — <code class=\"language-text\">String.prototype</code> methods like <code class=\"language-text\">includes</code>, <code class=\"language-text\">indexOf</code>, or <code class=\"language-text\">search</code> with a plain string argument work just fine.</p>\n<p>The real power of regex lies not in finding specific strings, but in finding <em>groups</em> of strings matching a pattern.</p>\n<h4 id=\"lets-build-custom-character-groups\" style=\"position:relative;\">Let’s Build Custom Character Groups<a href=\"#lets-build-custom-character-groups\" aria-label=\"lets build custom character groups permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Imagine you need to validate that user input contains only English letters. English has 48 characters counting both upper and lowercase, so you could build a map or array of the alphabet and check each character, or in the worst case, chain 48 conditions with <code class=\"language-text\">||</code>. <del>(49 including exception handling…)</del></p>\n<p>We can all agree that’s not the coolest approach. And as conditions pile up — checking for numbers too, or verifying that letters repeat n times — the code just keeps getting more complex.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-ts line-numbers\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> alphabet <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'B'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'C'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'d'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Z'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">isAlphabet</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token builtin\">string</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">every</span><span class=\"token punctuation\">(</span>char <span class=\"token operator\">=></span> alphabet<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<center>\n  <small>For simple English-only validation, you could handle it like this</small>\n  <br />\n  <br />\n</center>\n<p>So regex also lets you create custom groups to catch the characters you want. The syntax is simple: just put the characters you want to group inside square brackets (<code class=\"language-text\">[]</code>).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Match x or y or z!</span>\n<span class=\"token operator\">/</span><span class=\"token punctuation\">[</span>xyz<span class=\"token punctuation\">]</span><span class=\"token operator\">/</span>\n\n<span class=\"token comment\">// Match anything that's NOT x, y, or z!</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[^xyz]</span><span class=\"token regex-delimiter\">/</span></span>\n\n<span class=\"token comment\">// Match a through z!</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[a-z]</span><span class=\"token regex-delimiter\">/</span></span>\n\n<span class=\"token comment\">// Match a-z and A-Z!</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">[a-zA-Z]</span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Inside the brackets, you’re not limited to individual characters — you can use <code class=\"language-text\">-</code> to express character ranges, and adding <code class=\"language-text\">^</code> at the start means “NOT.”</p>\n<p>The range syntax like <code class=\"language-text\">a-z</code> refers to ranges in the <a href=\"http://www.asciitable.com/\" target=\"_blank\" rel=\"nofollow\">ASCII Table</a>.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 349px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/55b14704e00c60b3167cd812dcd52258/e9bf8/ascii-table.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 121.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9ElEQVR42pWVW2/TQBCFF9GQxLk5iR2HYGgFlNhJCIUWIR6QEIgXxP//PcyKb6PTiVFhpSN5x+szZ27rEEL4ZfhsaAw/DS8N3wxbwx3Pe8MP9jfy/rvhleGL4athZQifeJjzsm94z/7KMDZUEC0MteG5YWI4GqY8x3NPIuEthsywCX/WwTAwrNnPDK2hB/mcjxvOTYOsD7CP8BzwHG2FEB5FbQlhTMVQCB8F8jJDYc2LPQ5K9jGCHakpcdTDNuT707rBQyR8IbYRoSXCPepWoEdqhig/reQlEjyTHEYHS6dwjcIlIe9cyGeESeEWW/4XwgqF266ipHxFXAphBjTkjSNsUDpQwoNU+UoIxy6HO8nhGsKWSCZeYQZBUtjgIOVwzLkaWyVV7v9LyC37p6KwJdxU5QsIz3L4DoNWuSGUQggb+q2QKrcQ3gv5VhTWrvKlU1jgfO4mZe5Hb+QUtv9B2JduOCn0s9xim7kql9gWEL4l5JES3vGBNvaBvW/sBbYlVe4kVIW1KMxoDw15Rche4b0qf8SgfZhmuXSTspZKa5XPCHM3KanZc9c2BYQlIb/uum1Slcf8T7Sxpx2NncukXD9EeCl9OOGwElY4SQrfcCbrqrIqPHYQag4ruRwGcu50O6cqb9zl8FgIt9LYueTwIv1L4voNxWskW8umJHYAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"ascii table\" title=\"\" src=\"/static/55b14704e00c60b3167cd812dcd52258/e9bf8/ascii-table.png\" srcset=\"/static/55b14704e00c60b3167cd812dcd52258/69538/ascii-table.png 160w,\n/static/55b14704e00c60b3167cd812dcd52258/72799/ascii-table.png 320w,\n/static/55b14704e00c60b3167cd812dcd52258/e9bf8/ascii-table.png 349w\" sizes=\"(max-width: 349px) 100vw, 349px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</center>\n<p>Looking at the table, you can see special characters like <code class=\"language-text\">[</code> and <code class=\"language-text\">^</code> sitting between the uppercase group (65–90) and lowercase group (97–122). Since regex operates based on ASCII codes, if you try to catch only English letters with a range like <code class=\"language-text\">a-Z</code>, those special characters in between get included too.</p>\n<p>That’s why I separate the ranges into <code class=\"language-text\">a-z</code> and <code class=\"language-text\">A-Z</code> to filter English letters properly.</p>\n<p>With some ASCII knowledge, you can easily build custom character groups using the <code class=\"language-text\">-</code> range keyword. Even without memorizing the table, just Google “ASCII Table” and reference it.</p>\n<p>But manually defining groups every time is also tedious. <del>(Lazier developers make better developers…)</del> So regex helpfully provides several predefined groups.</p>\n<h4 id=\"code-classlanguage-textcode\" style=\"position:relative;\"><code class=\"language-text\">.</code><a href=\"#code-classlanguage-textcode\" aria-label=\"code classlanguage textcode permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Matches any single character except the newline escape <code class=\"language-text\">\\n</code>. Regardless of what the character is, if it’s a character, it matches. This includes spaces — applying the <code class=\"language-text\">.</code> class to <code class=\"language-text\">I am Evan</code> will match spaces too.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Match the first 4 characters from the start!</span>\n<span class=\"token string\">'I am Evan'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^....</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"I am\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>To express this character class as a custom group, you’d need to put every character in the ASCII table except <code class=\"language-text\">\\n</code> inside brackets — which is obviously impossible. That’s why knowing these character classes is the first step to writing regex comfortably.</p>\n<h4 id=\"the-code-classlanguage-textdcode-and-code-classlanguage-textdcode-classes\" style=\"position:relative;\">The <code class=\"language-text\">\\d</code> and <code class=\"language-text\">\\D</code> Classes<a href=\"#the-code-classlanguage-textdcode-and-code-classlanguage-textdcode-classes\" aria-label=\"the code classlanguage textdcode and code classlanguage textdcode classes permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">d</code> keyword stands for Digit — characters representing numbers. In ASCII terms, this means characters <code class=\"language-text\">0</code>–<code class=\"language-text\">9</code> (codes 48–57), so characters like Roman numerals (II) or Chinese numerals (五) are not recognized as digits.</p>\n<p>Lowercase <code class=\"language-text\">\\d</code> matches digit characters; uppercase <code class=\"language-text\">\\D</code> matches non-digit characters.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'010-1111-1111'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\d</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Characters 0-9 are matched, excluding -</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h4 id=\"the-code-classlanguage-textwcode-and-code-classlanguage-textwcode-classes\" style=\"position:relative;\">The <code class=\"language-text\">\\w</code> and <code class=\"language-text\">\\W</code> Classes<a href=\"#the-code-classlanguage-textwcode-and-code-classlanguage-textwcode-classes\" aria-label=\"the code classlanguage textwcode and code classlanguage textwcode classes permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">w</code> class stands for Word. In regex, “Word” characters are ASCII <code class=\"language-text\">A</code>–<code class=\"language-text\">Z</code> (65–90), <code class=\"language-text\">a</code>–<code class=\"language-text\">z</code> (97–122), and the <code class=\"language-text\">\\d</code> (digit) group.</p>\n<p>Characters outside this ASCII range — like Korean, Cyrillic, etc. — are not considered “Word” and can’t be caught with <code class=\"language-text\">\\w</code>. Like the <code class=\"language-text\">d</code> class, lowercase <code class=\"language-text\">\\w</code> matches Word characters and uppercase <code class=\"language-text\">\\W</code> matches non-Word characters.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'Phone: 010-0000-1111'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\w</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// : and - are not Word characters, so only English and digits match</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"P\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"o\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"n\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"e\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h4 id=\"the-code-classlanguage-textscode-and-code-classlanguage-textscode-classes\" style=\"position:relative;\">The <code class=\"language-text\">\\s</code> and <code class=\"language-text\">\\S</code> Classes<a href=\"#the-code-classlanguage-textscode-and-code-classlanguage-textscode-classes\" aria-label=\"the code classlanguage textscode and code classlanguage textscode classes permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">s</code> keyword stands for Space — whitespace characters. Lowercase <code class=\"language-text\">\\s</code> matches whitespace; uppercase <code class=\"language-text\">\\S</code> matches non-whitespace.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'Hi, my name is Evan'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\s</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// The 4 spaces in the string are matched</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"anchors-catching-boundaries-not-characters\" style=\"position:relative;\">Anchors: Catching Boundaries, Not Characters<a href=\"#anchors-catching-boundaries-not-characters\" aria-label=\"anchors catching boundaries not characters permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>The keywords we’ve looked at so far all represent individual characters. But regex also provides the ability to match boundaries between characters, not the characters themselves.</p>\n<p>Keywords that catch boundaries are called “anchors.” Since anchors only represent boundaries, they’re typically used in combination with character classes to catch characters positioned before or after a specific boundary.</p>\n<p>Since anchors catch the “boundary” itself, using an anchor alone returns a zero-length string.</p>\n<h4 id=\"the-code-classlanguage-textcode-and-code-classlanguage-textcode-anchors\" style=\"position:relative;\">The <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code> Anchors<a href=\"#the-code-classlanguage-textcode-and-code-classlanguage-textcode-anchors\" aria-label=\"the code classlanguage textcode and code classlanguage textcode anchors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">^</code> anchor represents the start-of-string boundary; <code class=\"language-text\">$</code> represents the end-of-string boundary.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Match only the character right after ^(start boundary)</span>\n<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Evans Library</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^.</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"E\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Evans Library\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Match only the character right before $(end boundary)</span>\n<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Evans Library</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"y\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Evans Library\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>It goes without saying that a character before <code class=\"language-text\">^</code> or after <code class=\"language-text\">$</code> can’t exist, so expressions like <code class=\"language-text\">.^</code> or <code class=\"language-text\">$.</code> can’t match anything.</p>\n<h4 id=\"the-code-classlanguage-textbcode-and-code-classlanguage-textbcode-anchors\" style=\"position:relative;\">The <code class=\"language-text\">\\b</code> and <code class=\"language-text\">\\B</code> Anchors<a href=\"#the-code-classlanguage-textbcode-and-code-classlanguage-textbcode-anchors\" aria-label=\"the code classlanguage textbcode and code classlanguage textbcode anchors permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">b</code> keyword stands for Boundary — specifically, all boundaries between words composed of the Word group. In simple terms, it’s a superset of the <code class=\"language-text\">^</code> and <code class=\"language-text\">$</code> anchors, which only match the start and end of the entire string.</p>\n<p>An important caveat: since it’s about “words composed of the Word group,” this only applies to English letters and digits included in the <code class=\"language-text\">\\w</code> group.</p>\n<p>The vague definition of “boundaries between words” might be confusing, but examples make it clear:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'abc def'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Here I used <code class=\"language-text\">\\b</code> to catch all word boundaries in <code class=\"language-text\">abc def</code>. The results are all zero-length strings, because as I mentioned, a boundary isn’t a character and has no length.</p>\n<p>The word boundaries in <code class=\"language-text\">abc def</code> are:</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/6d1779cbaba0a0243ed42fc5d27d3228/d56e1/boundaries.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 41.875%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABfUlEQVR42l2STU/bQBCG+cP0wC0SIHEoKkINCIEg6qlqqoo4uXDhBodElIiI8Bc4cIjrxHYcf+56H2btJKS80uyu57HfGY+9hSiYpcy8BG8Sk8aFTWFMtRFHBaGfMQ+yNVvJMpsP/ZRkUbMtu+SpJgpzFvOcoig/GeZM3RhfCtrzptJEVY3UbMPQqshLTFm7lEphJKqz5LQqURK2iJHFMqN1zXXNV1obqlwLtKYSYYj2PHlIoSWnpGvLjeVipF0XPZvZamv+Ybh8NZUW/HscMh0OGToOb4MB8/GY17t7ijCiFP7WH/DY6eDKPYuXF0a9Ln+dHiZbzla6rwwrz0Lz1HG42N3lx8EBPw8PcU6aPF93IIoJJh7d702u9ve53Nvj5vyCr1+26f9qyzCzDUM7h2W7vbMzvu3scN1sitkJf46PGUlH5DmhjOD30RFtidNGg367zW2rhfvwUPH/DFfKZHZZEJD6PrFEKtfBZLL+5NF0WnMJuxPHmCT5+CWAd1F4UjIJMUWSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"boundaries\" title=\"\" src=\"/static/6d1779cbaba0a0243ed42fc5d27d3228/6af66/boundaries.png\" srcset=\"/static/6d1779cbaba0a0243ed42fc5d27d3228/69538/boundaries.png 160w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/72799/boundaries.png 320w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/6af66/boundaries.png 640w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/d9199/boundaries.png 960w,\n/static/6d1779cbaba0a0243ed42fc5d27d3228/d56e1/boundaries.png 1130w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Don't overthink it — just consider where each word's boundaries are</small>\n</center>\n<p>The uppercase <code class=\"language-text\">\\B</code> catches positions that are NOT word boundaries — in other words, positions where a word hasn’t ended.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'abc def'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\B</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Again 4 boundaries, but their meaning is completely different: these are “boundaries where the word hasn’t ended.”</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/97a4fb713d83f95c04382b7fb6b20106/748b0/boundaries2.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 53.125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACMklEQVR42m2S208TURDG96/knQfriwkQCbEl4QHCTYWIwUQESV8AjZBwMUYNofhgBRoCGKFSWygUaekFCnS3ezv9OdsCyUYm2d05+818852Z0RBTbo3c32tKZzq5k2sKZxX0is19Zug2F0WDy/Mq5wUD/cpCqdodrnmvmpw9sFyqcnlhUhLfrDp+ppsc/doim7miKMXPPBF5A9dRfkLPHFvdAZbp1ovcZ54ay2wUcyTetpQP124zPULbdv8nvHVuvq6r6vgtoSM5SjClGsRaTQ6u62DJFb0AJb5p2KJWAl3Xr07Ojvz3FCrlijoH2/S3RrNSKUj+wdj7TTLyDZVKcvVzDzeZRCUS2Pl8Q025DIKdrm9w+iMGhweY8f36s7m4yH4k4vUDrbi2xvL4G+JLn3jW3sH04CCl7xtEp6ZZHhvDOT5uqCsU2F+YJ/ggwMb7WdZnpvk1v0js3Qc6mpvZmZuTXllo6dVVeltaGHjcznhPD+G+Pp53PGGit5f01y9U0+k6YV5u8ioUItw/wItgJ6GHAUZCncwMDRMMBMisrIBpon2emOBRUxOjwSBvu7t53dXFwssRRiU5Gg5jHx3VCS+EeLi1ladtbUz199MpJJHJSRIfl5gdGkLt7ODoOlo1l+Nwa4vLgwOy29skolFq2Swnu7ukNjdlk42bvXI4jcc5lBg7k+E4FiMrJIYUKku/LeGp9/Bub2XatVIJVSziVir+lcG/QkqKKBmWkkHVHP+U/wHruB77k5EMYwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"boundaries2\" title=\"\" src=\"/static/97a4fb713d83f95c04382b7fb6b20106/6af66/boundaries2.png\" srcset=\"/static/97a4fb713d83f95c04382b7fb6b20106/69538/boundaries2.png 160w,\n/static/97a4fb713d83f95c04382b7fb6b20106/72799/boundaries2.png 320w,\n/static/97a4fb713d83f95c04382b7fb6b20106/6af66/boundaries2.png 640w,\n/static/97a4fb713d83f95c04382b7fb6b20106/748b0/boundaries2.png 868w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Boundaries at positions where the word hasn't ended</small>\n</center>\n<p>The <code class=\"language-text\">b</code> keyword doesn’t match a character — it matches a boundary. Keep this distinction in mind and you’ll find it surprisingly useful in various situations.</p>\n<h3 id=\"flags-regex-options\" style=\"position:relative;\">Flags: Regex Options<a href=\"#flags-regex-options\" aria-label=\"flags regex options permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>You’ll often see characters like <code class=\"language-text\">g</code>, <code class=\"language-text\">i</code>, or <code class=\"language-text\">m</code> appended after a regex: <code class=\"language-text\">/regex/g</code>. These are “flags” that serve as option settings.</p>\n<p>When using the <code class=\"language-text\">new RegExp()</code> constructor instead of literal <code class=\"language-text\">/</code> syntax, pass flags as the second argument.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">pattern</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gi</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> regex2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">pattern</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'gi'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// These two have the same pattern</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">===</span> regex2<span class=\"token punctuation\">.</span>flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token boolean\">true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Regex provides 6 flags: <code class=\"language-text\">g</code>, <code class=\"language-text\">i</code>, <code class=\"language-text\">m</code>, <code class=\"language-text\">s</code>, <code class=\"language-text\">u</code>, <code class=\"language-text\">y</code>. I’ll only cover the three most commonly used — <code class=\"language-text\">g</code>, <code class=\"language-text\">i</code>, and <code class=\"language-text\">m</code> — so Google the rest if you’re curious.</p>\n<h4 id=\"the-code-classlanguage-textgcode-flag\" style=\"position:relative;\">The <code class=\"language-text\">g</code> Flag<a href=\"#the-code-classlanguage-textgcode-flag\" aria-label=\"the code classlanguage textgcode flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">g</code> flag stands for <code class=\"language-text\">global</code>. A regex with this flag finds all parts of the string that match the pattern. Without <code class=\"language-text\">g</code>, the regex only finds the first match.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'hello, world'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'hello, world'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">.</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">input</span><span class=\"token operator\">:</span> <span class=\"token string\">\"hello, world\"</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">groups</span><span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"e\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"l\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"l\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"o\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\",\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"w\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"o\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"r\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"l\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"d\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Without the <code class=\"language-text\">g</code> flag, regex matches only one character; with it, all matching characters are found. This is intuitive enough that playing with it in the console a few times will make it click.</p>\n<h4 id=\"the-code-classlanguage-texticode-flag\" style=\"position:relative;\">The <code class=\"language-text\">i</code> Flag<a href=\"#the-code-classlanguage-texticode-flag\" aria-label=\"the code classlanguage texticode flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">i</code> flag stands for <code class=\"language-text\">ignoreCase</code> — matching without distinguishing uppercase from lowercase.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">abcd</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">i</span></span><span class=\"token punctuation\">;</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abcd'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nregex<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ABCD'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>User-generated strings often vary in capitalization — <code class=\"language-text\">My name is Evan</code>, <code class=\"language-text\">my name is evan</code>, etc. The <code class=\"language-text\">i</code> flag lets you find the string you want without worrying about case.</p>\n<h4 id=\"the-code-classlanguage-textmcode-flag\" style=\"position:relative;\">The <code class=\"language-text\">m</code> Flag<a href=\"#the-code-classlanguage-textmcode-flag\" aria-label=\"the code classlanguage textmcode flag permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>The <code class=\"language-text\">m</code> flag stands for <code class=\"language-text\">multiline</code>, meaning the regex will evaluate a multi-line string. But oddly, regex matches multi-line strings just fine without this flag.</p>\n<p>Let’s create a multi-line string and try a simple pattern match:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">const</span> string <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">abcd\\nefgh\\nijkl</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\nstring<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\w{2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cd\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ef\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"gh\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ij\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"kl\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Regex just finds matching patterns in whatever string it’s given, so multi-line strings work fine without the <code class=\"language-text\">m</code> flag.</p>\n<p>So why does the <code class=\"language-text\">m</code> flag exist? Because it changes how regex treats the <code class=\"language-text\">\\n</code> newline escape.</p>\n<p>Let’s add the <code class=\"language-text\">^</code> anchor to find two characters at the start of the string, not just any two <code class=\"language-text\">\\w</code> characters:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">string<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\w{2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Only <code class=\"language-text\">ab</code> is returned. Even though lines are separated by <code class=\"language-text\">\\n</code>, the regex sees the whole thing as a single string, so only the <code class=\"language-text\">a</code> at the very beginning counts as the start (<code class=\"language-text\">^</code>).</p>\n<p>Now with the <code class=\"language-text\">m</code> flag:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">string<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^\\w{2}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gm</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"ab\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ef\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ij\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Now each line separated by <code class=\"language-text\">\\n</code> is treated as a separate string. The <code class=\"language-text\">m</code> flag doesn’t simply mean “search multi-line strings” — it means “split on <code class=\"language-text\">\\n</code> and treat each line as its own search target.”</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/69dd01cadc54feeecd2154af66259484/35751/multiline.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 58.12500000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACVUlEQVR42m1Ta08aQRTdf84fwU8mtSQWaCMULfUBRogCAkKoqAhqdBeFfTA7uzszcHpnfETSTkLYnTn3zDnn3rUSKRHHMYRSUPRLkgRRFEGIBMvlEp+XovfkDaPx+lwIgTiJzZ6ut17abbgnJ7g+O0OTngs7Oziu1hCGkblIr9VqZf7jMMRLpwOvXsdVs4n2xQW+5/PodC4Iz40Qy97dRdBoYFCpoFQuI5/PonrYwPXAgZRindB14RSLBt/e30eRajOZr6hVu7j5Q3glYAmyzBiD7/vgnGOxWIBHHEEQGDuflyRLnPY4KY0Iqx3oGq2MsfDV8tHREba2tlCkm0ulEj1/wehmgkXATC5rCumS+WBgLE/Oz/GjUEA2m8XTo01CXvFWOp3G6empIUulUjg4+I3acRtXA/sfy9F0CodiiUYj/KSsNb5c/oX6cZci0ngi9DzPME8mE3S7Xbju3NjWEfzPckjx6MkY396i1+sZbEgRaIVKSVgVasbl5SU2NzfRarWwt7dHpK4BfhC+KUxozx0Owe/vcU5NOSO8jiyk/BidGcu5XA79fh8bGxsoUCZ6bB6oQDfqnfDDMqmeUjyc3BxubyPzLWtqHNs2AnSTrJgG+O5ubCzqLoXU4YT25FJ9EL2vJb0LPdTPU0jqrqCMtV0dgcbrc0u6HnhMXwCXCJgA8wjoh5BzD0up1iyv9Kj4NGJMIY4UXD+GZPSVzTwIL4CKKcPYdvA4DWHfeXh0GJyHOfjTM4LhmIrDNctqNgMnwvHEx8xmGI3niGYLsNsHzPsj8FmAv+izel8PUmvHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"multiline\" title=\"\" src=\"/static/69dd01cadc54feeecd2154af66259484/6af66/multiline.png\" srcset=\"/static/69dd01cadc54feeecd2154af66259484/69538/multiline.png 160w,\n/static/69dd01cadc54feeecd2154af66259484/72799/multiline.png 320w,\n/static/69dd01cadc54feeecd2154af66259484/6af66/multiline.png 640w,\n/static/69dd01cadc54feeecd2154af66259484/35751/multiline.png 873w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>Whether the m flag is present determines if lines are treated<br>as one combined string or as individual strings.</small>\n</center>\n<p>The <code class=\"language-text\">m</code> flag is more useful when dealing with long strings containing line breaks than short strings. I’ve used it for things like checking that English text capitalizes the first letter of each line, or parsing uncompressed files.</p>\n<h3 id=\"quantifiers-how-many-times-a-pattern-appears\" style=\"position:relative;\">Quantifiers: How Many Times a Pattern Appears<a href=\"#quantifiers-how-many-times-a-pattern-appears\" aria-label=\"quantifiers how many times a pattern appears permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>In the previous example, I used <code class=\"language-text\">{2}</code> to find two <code class=\"language-text\">\\w</code> characters. This expression specifies the repetition count for the preceding expression. You can also use <code class=\"language-text\">{0,2}</code> to specify a min/max range.</p>\n<p>Expressions that capture how many times a preceding pattern matches are called quantifiers.</p>\n<h4 id=\"specifying-exact-repetition-counts\" style=\"position:relative;\">Specifying Exact Repetition Counts<a href=\"#specifying-exact-repetition-counts\" aria-label=\"specifying exact repetition counts permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'aaaabbbcc'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\w{3}</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"abb\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"bcc\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The expression <code class=\"language-text\">\\w{3}</code> simply says “find where the Word group repeats 3 times,” so regex pulls out every 3-character chunk of Word characters.</p>\n<p>Repetition patterns are applicable in many situations. A classic example is phone numbers or ID numbers, where character groups repeat a fixed number of times.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'010-0101-0101'</span>  <span class=\"token comment\">// Mobile</span>\n<span class=\"token string\">'02-0101-0101'</span>   <span class=\"token comment\">// Landline (Seoul area code)</span>\n<span class=\"token string\">'031-010-0101'</span>   <span class=\"token comment\">// Landline (regional area code)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Phone numbers in many countries follow predictable formats. Mobile numbers typically start with a carrier prefix followed by fixed-length digit groups. Using quantifiers makes it easy to capture these patterns:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Pattern for catching mobile numbers (Korean format)</span>\n<span class=\"token operator\">/</span><span class=\"token number\">01</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token operator\">|</span><span class=\"token number\">1</span><span class=\"token operator\">|</span><span class=\"token number\">6</span><span class=\"token operator\">|</span><span class=\"token number\">8</span><span class=\"token operator\">|</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token operator\">-</span>\\d<span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>You might wonder why we don’t just match <code class=\"language-text\">010</code> — but mobile carrier prefixes weren’t always <code class=\"language-text\">010</code>. Older prefixes like <code class=\"language-text\">011</code>, <code class=\"language-text\">016</code>, <code class=\"language-text\">018</code> existed before being unified, and some people still use them. Keep edge cases like these in mind when writing validation logic.</p>\n<h4 id=\"checking-if-a-pattern-appears-one-or-more-times\" style=\"position:relative;\">Checking If a Pattern Appears One or More Times<a href=\"#checking-if-a-pattern-appears-one-or-more-times\" aria-label=\"checking if a pattern appears one or more times permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>Exact repetition counts are great, but they’re too rigid for abstract patterns like “may or may not exist” or “appears n or more times.” So regex provides more flexible quantifiers.</p>\n<h5 id=\"the-code-classlanguage-textcode-quantifier\" style=\"position:relative;\">The <code class=\"language-text\">*</code> Quantifier<a href=\"#the-code-classlanguage-textcode-quantifier\" aria-label=\"the code classlanguage textcode quantifier permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>The <code class=\"language-text\">*</code> quantifier matches when the preceding pattern appears 0 or more times. “0 or more” means the pattern before it may not appear at all, or may repeat many times.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// The a before b can be absent or appear many times — match them all!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">a*b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">'b'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'ab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'aab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'aab'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Since patterns before <code class=\"language-text\">*</code> are matched no matter how many times they appear, any number of <code class=\"language-text\">a</code>s will be caught.</p>\n<h5 id=\"the-code-classlanguage-textcode-quantifier-1\" style=\"position:relative;\">The <code class=\"language-text\">?</code> Quantifier<a href=\"#the-code-classlanguage-textcode-quantifier-1\" aria-label=\"the code classlanguage textcode quantifier 1 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>The <code class=\"language-text\">?</code> quantifier matches when the preceding pattern appears 0 or 1 times. Unlike <code class=\"language-text\">*</code>, even if the pattern appears many times, <code class=\"language-text\">?</code> only captures one.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// The a before b can be absent or appear many times — only match 1!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">a?b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">'b'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'ab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'aab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h5 id=\"the-code-classlanguage-textcode-quantifier-2\" style=\"position:relative;\">The <code class=\"language-text\">+</code> Quantifier<a href=\"#the-code-classlanguage-textcode-quantifier-2\" aria-label=\"the code classlanguage textcode quantifier 2 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h5>\n<p>The <code class=\"language-text\">+</code> quantifier means the preceding pattern must appear at least once. If it doesn’t appear, the match fails.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// The a before b must exist, and match all of them!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">a+b</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">'b'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'ab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'aab'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token keyword\">null</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'ab'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token string\">'aab'</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Put simply, <code class=\"language-text\">+</code> means “I don’t care how many times, just be there” — useful for catching characters that must be present.</p>\n<h2 id=\"nice-to-know-advanced-features\" style=\"position:relative;\">Nice-to-Know Advanced Features<a href=\"#nice-to-know-advanced-features\" aria-label=\"nice to know advanced features permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>So far we’ve covered the basics: character classes, anchors, flags, and quantifiers. This is enough for most business situations, but occasionally you’ll hit cases where these alone become unwieldy.</p>\n<p>Let’s look at some features that make regex more convenient to work with.</p>\n<h3 id=\"capturing-remembering-patterns\" style=\"position:relative;\">Capturing: Remembering Patterns<a href=\"#capturing-remembering-patterns\" aria-label=\"capturing remembering patterns permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Regex doesn’t just match patterns — it can also remember matched patterns. This capturing ability is useful for string replacement (distinguishing parts that should change from parts that shouldn’t), finding duplicates, and more.</p>\n<p>For example, consider a string representing a dollar amount: <code class=\"language-text\">$10000</code>. What pattern captures this?</p>\n<p>A dollar amount means <code class=\"language-text\">$</code> followed by at least one digit to be meaningful. A simple expression matching <code class=\"language-text\">$</code> followed by one or more digits does the trick. (Remember that bare <code class=\"language-text\">$</code> is the end-of-string anchor, so escape it with <code class=\"language-text\">\\</code>.)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'$10000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\$\\d+</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"$10000\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Now, what if we want to change <code class=\"language-text\">$10000</code> to <code class=\"language-text\">10000 dollars</code>?</p>\n<p>You might think of <code class=\"language-text\">String.prototype.replace</code>, but the pattern above captures <code class=\"language-text\">$10000</code> as a whole — there’s no way to keep <code class=\"language-text\">10000</code> while replacing just the <code class=\"language-text\">$</code>.</p>\n<p>We need a way to remember a specific part of the match. This is where capturing comes in.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Wrap the part you want to remember in parentheses!</span>\n<span class=\"token operator\">/</span>\\<span class=\"token function\">$</span><span class=\"token punctuation\">(</span>\\d<span class=\"token operator\">+</span><span class=\"token punctuation\">)</span><span class=\"token operator\">/</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>The only difference from before is wrapping <code class=\"language-text\">\\d+</code> in parentheses. This tells regex to capture that part.</p>\n<p>The second argument of <code class=\"language-text\">String.prototype.replace</code> is the replacement string. Captured patterns can be referenced there using the special <code class=\"language-text\">$n</code> syntax.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'$10000'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\$(\\d+)</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">'$1 dollars'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">\"10000 dollars\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">$1</code> refers to the first captured group. With multiple capture groups, you can use <code class=\"language-text\">$2</code>, <code class=\"language-text\">$3</code>, and so on.</p>\n<p>Capturing is also useful for finding repeated characters, since repetition means a previously seen character appears again consecutively:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(\\w)\\1</span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Here I captured a Word character with <code class=\"language-text\">(\\w)</code>, then referenced it with <code class=\"language-text\">\\1</code> — expressing the pattern of repetition.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token string\">'aabccdeef'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(\\w)\\1</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"aa\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cc\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ee\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Expressions like <code class=\"language-text\">(.)\\1{2}</code> (combined with quantifiers) are useful for password validation rules like “the same character must not repeat 3 or more times.”</p>\n<h3 id=\"greedy-vs-lazy\" style=\"position:relative;\">Greedy vs. Lazy<a href=\"#greedy-vs-lazy\" aria-label=\"greedy vs lazy permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Earlier we learned about the <code class=\"language-text\">+</code> (1 or more) and <code class=\"language-text\">*</code> (0 or more) quantifiers. Using “n or more” quantifiers creates an ambiguity in pattern matching:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Find all strings wrapped in &lt; and >!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.*></span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">\"&lt;p>This is p tag&lt;/p>\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"&lt;p>This is p tag&lt;/p>\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>My regex just says “find anything wrapped in <code class=\"language-text\">&lt;</code> and <code class=\"language-text\">></code>,” so it might seem natural that it captures the entire <code class=\"language-text\">&lt;p>This is p tag&lt;/p></code>. But <code class=\"language-text\">&lt;p></code> and <code class=\"language-text\">&lt;/p></code> individually also match this pattern.</p>\n<p>Regex defaults to matching the longest possible pattern — this is called <strong>greedy</strong> matching. It greedily gobbles up the longest match it can find. <del>(This is unrelated to the Greedy algorithm concept, despite sharing the name.)</del></p>\n<p>So how do you capture the smaller matches like <code class=\"language-text\">&lt;p></code> and <code class=\"language-text\">&lt;/p></code>?</p>\n<blockquote>\n<p>Make the regex <strong>lazy</strong>.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Find all strings wrapped in &lt; and > — lazily!</span>\n<span class=\"token keyword\">const</span> regex <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.*?></span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token string\">\"&lt;p>This is p tag&lt;/p>\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>regex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token string\">\"&lt;p>\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"&lt;/p>\"</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>The only change is adding <code class=\"language-text\">?</code> after the <code class=\"language-text\">*</code> quantifier. Lazy matching finds the shortest possible matches. Given the same expression, it finds the minimal match and calls it a day — hence “lazy.”</p>\n<p>In summary: quantifiers like <code class=\"language-text\">*</code> and <code class=\"language-text\">+</code> default to greedy matching (longest possible). Adding <code class=\"language-text\">?</code> after them switches to lazy matching (shortest possible).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\"><span class=\"token comment\">// Greedy</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token operator\">/</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.+></span><span class=\"token regex-delimiter\">/</span></span>\n\n<span class=\"token comment\">// Lazy</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token operator\">?</span><span class=\"token operator\">></span><span class=\"token operator\">/</span>\n<span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">&lt;.+?></span><span class=\"token regex-delimiter\">/</span></span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Without understanding the difference between greedy and lazy matching, you’ll fail to capture the patterns you want when multiple valid matches exist. Keep this distinction in mind.</p>\n<h2 id=\"wrapping-up\" style=\"position:relative;\">Wrapping Up<a href=\"#wrapping-up\" aria-label=\"wrapping up permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>I first encountered regex as a college student, building a parser that converted OBJ files into <a href=\"https://threejs.org/\" target=\"_blank\" rel=\"nofollow\">ThreeJS</a> objects. That required seriously heavy regex usage. <del>(The OBJ Loader that ThreeJS provided at the time had a bug 😢)</del></p>\n<p>OBJ files represent vertex coordinates, texture UV mapping coordinates, vertex normals, and more:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\"># Vertex coordinates\nv -1.692615 -0.021714 -1.219301\nv 7.334266 -0.021714 -1.219302\nv 7.334265 0.021714 -1.219302\n...\n\n# Texture UV values\nvt 0.0000 0.0000\nvt 1.0000 0.0000\n...\n\n# Vertex normals\nvn -0.0000 -0.0000 -1.0000\nvn 0.0000 -1.0000 -0.0000\n\nusemtl Material.001\n\n# Vertex indices for each face\nf 1/1/1 4/2/1 3/3/1 2/4/1\nf 8/5/2 5/6/2 6/7/2 7/8/2</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>I used the <code class=\"language-text\">m</code> flag to split the file line by line, then parsed lines starting with <code class=\"language-text\">v</code> as vertex coordinates, <code class=\"language-text\">vt</code> as texture UVs, <code class=\"language-text\">vn</code> as normals, and so on. It was challenging and complex, but fun.</p>\n<p>It was eye-opening to realize that computer-generated files are really just sequences of meaningful strings — and even more fun that regex could transform those strings into meaningful information.</p>\n<p>But as I mentioned, regex is used far more often in everyday business logic than in building parsers. For validating user input like passwords or email addresses, regex is practically a cheat code.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 399px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f8ab432328c5d8bafe5aa95518ad4df2/a307d/password_rule.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 68.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZ0lEQVR42p1T2Y7CMBDr///c8sA+8oSABnoftMmk8XpSjiJYCYjkJk0ztjMzTfqmwe96jZ/VClVdw3sPay2ccx9BRKAjKcsKTd2gbduv0XUd8jyPxElVVVDUdPctGt5SCdVlInK17OHkbn+Jec897WlqlgghINGcqUJRFDGHTUv7XBdFieyUoeQcHWQZjDHI6ETdDMMQc6YkOpRnmqaZ0DmLkXkYux6WGEigihqkszqydozv4zhGaNxy3An5CAzwVPV0JCaFbLe4yOPd8eAwEJ6FkdMpwpcF7GZzu84XhHTY1JDjkU4LSMYW2O+iyLtOnx2yEHI0dFdCtKfSAyRN59M8+ED6QuCRkAuJ+TPz1VnZmMsr4ccOL0WR/Z7XzeguhdN8ktweDnAUmvoenlV2ux2FzJPQjTD+g/wQ2B5Tf55nBk5sjTDamFvPlgpsZBUO/BbO5/8dKqG+aPu8BMVe7mvMAsqjf8of4zBFjqIV43cAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"password rule\" title=\"\" src=\"/static/f8ab432328c5d8bafe5aa95518ad4df2/a307d/password_rule.png\" srcset=\"/static/f8ab432328c5d8bafe5aa95518ad4df2/69538/password_rule.png 160w,\n/static/f8ab432328c5d8bafe5aa95518ad4df2/72799/password_rule.png 320w,\n/static/f8ab432328c5d8bafe5aa95518ad4df2/a307d/password_rule.png 399w\" sizes=\"(max-width: 399px) 100vw, 399px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n  <small>You can validate with built-in methods alone, but regex makes it far simpler</small>\n</center>\n<p>Without regex, validating something as simple as an email address requires combining multiple built-in methods — quite inefficient. And personally, as hard as regex is to read, I think it’s still more readable than a complex chain of method calls.</p>\n<p>Regex doesn’t have lines or indentation like code, so it looks like a meaningless jumble of characters. But the number of expressions regex provides isn’t that large, and with a bit of practice, anyone can understand short regex patterns quickly.</p>\n<p>That’s all for this post on finding patterns in irregularity. In the next post, I’ll walk through real-world examples of how I’ve used regex as a working developer.</p>","fields":{"slug":"20200724-about-regular-expression-en","path":"/2020/07/24/about-regular-expression/en/","lang":"en"},"frontmatter":{"title":"Finding Patterns in Irregularity: A Guide to Regular Expressions","subTitle":"The art of defining patterns in infinite possibility","date":"Aug 10, 2020","categories":["Programming","Tutorial"],"tags":["Regex","Regular Expression","Character Class","Anchor","Capturing Group","Greedy","Lazy"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/d803c/thumbnail.png 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/2a1fd/thumbnail.png 750w","sizes":"(min-width: 320px) 320px, 100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/fc5c5/thumbnail.webp 320w,\n/static/c9a689e73a6e0677baa07d0624c6b5c1/e9225/thumbnail.webp 750w","type":"image/webp","sizes":"(min-width: 320px) 320px, 100vw"}]},"width":320,"height":320}}},"jumbotron":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","images":{"fallback":{"src":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png","srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/01fb2/thumbnail.png 750w","sizes":"100vw"},"sources":[{"srcSet":"/static/c9a689e73a6e0677baa07d0624c6b5c1/b384d/thumbnail.webp 750w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}}}}}]}},"pageContext":{"tag":"Regular Expression","lang":"en"}},"staticQueryHashes":["3523904809","650499039"],"slicesMap":{}}