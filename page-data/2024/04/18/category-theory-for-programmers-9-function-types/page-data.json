{"componentChunkName":"component---src-templates-post-page-template-tsx","path":"/2024/04/18/category-theory-for-programmers-9-function-types/","result":{"data":{"markdownRemark":{"id":"8c27f197-f80b-5745-8160-8b77ad6878d2","excerpt":"지금까지는 함수 타입의 의미를 간단하게만 설명해왔다. 하지만 조금 더 자세히 들여다보면 함수 타입은 다른 타입과는 약간 다른 특성을 가지고 있다.","html":"<p>지금까지는 함수 타입의 의미를 간단하게만 설명해왔다. 하지만 조금 더 자세히 들여다보면 함수 타입은 다른 타입과는 약간 다른 특성을 가지고 있다.</p>\n<!-- more -->\n<p>예를 들어 <code class=\"language-text\">Integer</code> 타입은 그냥 정수들의 집합, 그리고 <code class=\"language-text\">Bool</code> 타입은 두 개의 원소로 이루어진 집합일 뿐이다. 그러나 함수 타입 <code class=\"language-text\">a -&gt; b</code>은 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 사이에 존재하는 모든 사상들의 집합이다. 어떤 카테고리에서 두 객체 사이의 존재하는 모든 사상들의 집합은 Hom 집합이라고 한다. 그리고 Hom 집합 또한 결국 집합이기 때문에 카테고리 <strong>Set</strong>(모든 집합의 카테고리)에서는 Hom 집합 또한 <strong>Set</strong>에 포함된 대상이다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/cb189cb187003cfbbbefe5161aefba06/bba1f/1.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 111.87500000000001%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAWABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAIBAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7WLiNqVVJFiv/8QAGRABAQEBAQEAAAAAAAAAAAAAAQACERAS/9oACAEBAAEFAta+Z1yG4McYJIzzz//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABYQAAMAAAAAAAAAAAAAAAAAABAgIf/aAAgBAQAGPwI1v//EABsQAAMAAgMAAAAAAAAAAAAAAAABERAhMUFx/9oACAEBAAE/IbFWR1sQ1TYhP0es6KFOHMBaP//aAAwDAQACAAMAAAAQ9MC8/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFREBAQAAAAAAAAAAAAAAAAAAICH/2gAIAQIBAT8Qo//EABoQAQADAQEBAAAAAAAAAAAAAAEAESExYUH/2gAIAQEAAT8QNS05WZ7NgN+wEEjsILxcFqKVbt+wCvy4gdD2DaqL7RAADhP/2Q==&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"1\" title=\"1\" src=\"/static/cb189cb187003cfbbbefe5161aefba06/c08c5/1.jpg\" srcset=\"/static/cb189cb187003cfbbbefe5161aefba06/0913d/1.jpg 160w,\n/static/cb189cb187003cfbbbefe5161aefba06/cb69c/1.jpg 320w,\n/static/cb189cb187003cfbbbefe5161aefba06/c08c5/1.jpg 640w,\n/static/cb189cb187003cfbbbefe5161aefba06/bba1f/1.jpg 840w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  </div>\n  <small>Hom &#xC9D1;&#xD569;&#xB3C4; &#xACB0;&#xAD6D; &#xC9D1;&#xD569;&#xC774;&#xAE30; &#xB54C;&#xBB38;&#xC5D0; Set&#xC5D0; &#xD3EC;&#xD568;&#xB41C; &#xB300;&#xC0C1;&#xC774;&#xB2E4;.</small>\n  <br>\n  <br>\n</center>\n<p><strong>Set</strong>이 아닌 다른 카테고리에서는 Hom 집합이 카테고리 외부에 있는 경우도 있다. 이런 경우 외부(External) Hom 집합이라고 한다.</p>\n<p>이것이 바로 함수 타입을 다른 타입보다 특별하게 만드는 카테고리 <strong>Set</strong>의 자기 참조적인 성격이다. 이런 카테고리에서는 Hom 집합을 나타내는 대상을 구성할 수 있는 방법이 존재하며, 이러한 대상을 내부(Internal) Hom 집합이라고 한다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/42654a7df0869c5e40df37dc0c04c694/232db/2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 117.5%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAYABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7LShdYRkRsK//8QAGhAAAgMBAQAAAAAAAAAAAAAAAQIAEBEhEv/aAAgBAQABBQJn8ktkB5yDDRiplf/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABQQAQAAAAAAAAAAAAAAAAAAADD/2gAIAQEABj8CH//EABwQAAMAAgMBAAAAAAAAAAAAAAABESFREDFhkf/aAAgBAQABPyGRa7oXt9LUPL0foFgWot4//9oADAMBAAIAAwAAABCUwPz/xAAWEQEBAQAAAAAAAAAAAAAAAAAQEUH/2gAIAQMBAT8Qwp//xAAWEQEBAQAAAAAAAAAAAAAAAAAREAH/2gAIAQIBAT8Qhiz/xAAcEAEAAwACAwAAAAAAAAAAAAABABEhMWEQkbH/2gAIAQEAAT8QAgJV0gjYsvIY0NwrfpH0VU04cwAo4iYd/Jctc1t+P//Z&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"2\" title=\"2\" src=\"/static/42654a7df0869c5e40df37dc0c04c694/c08c5/2.jpg\" srcset=\"/static/42654a7df0869c5e40df37dc0c04c694/0913d/2.jpg 160w,\n/static/42654a7df0869c5e40df37dc0c04c694/cb69c/2.jpg 320w,\n/static/42654a7df0869c5e40df37dc0c04c694/c08c5/2.jpg 640w,\n/static/42654a7df0869c5e40df37dc0c04c694/232db/2.jpg 819w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  </div>\n  <small>&#xCE74;&#xD14C;&#xACE0;&#xB9AC; C&#xC758; Hom &#xC9D1;&#xD569;&#xC740; &#xC678;&#xBD80; Hom &#xC9D1;&#xD569;&#xC774;&#xB2E4;.</small>\n  <br>\n  <br>\n</center>\n<h2 id=\"91-보편적-구성universal-construction\" style=\"position:relative;\">9.1 보편적 구성(Universal Construction)<a href=\"#91-%EB%B3%B4%ED%8E%B8%EC%A0%81-%EA%B5%AC%EC%84%B1universal-construction\" aria-label=\"91 보편적 구성universal construction permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자, 이제 함수 타입이 집합이라는 사실은 잠시 잊고, 함수 타입을 일반화하여 내부 Hom 집합이라고 생각해서 처음부터 구성해보도록 하자. 일반적으로는 <code class=\"language-text\">Set</code> 카테고리가 이 구성에 대한 단서를 주겠지만, 여기서는 집합의 특성에 의존하지 않고 생각해볼 것이다. 이런 과정을 통해 하나의 구성이 다른 카테고리에 자동으로 적용될 수 있도록 일반화해볼 수 있다.</p>\n<p>함수 타입은 인수 타입과 결과 타입과의 관계로 인해 복합적인 타입으로 간주된다. 이미 우리는 <a href=\"/2024/02/27/category-theory-for-programmers-5-products-and-coproducts/\">곱 타입과 합 타입</a>이라는 대상 간의 관계를 포함하는 복합적인 타입들을 정의하기 위한 보편적 구성(Universal Construction)에 대해서 배웠던 적이 있다. 함수 타입을 정의하는 데도 동일한 방법을 사용해볼 수 있다.</p>\n<p>함수 타입을 정의하기 위해서는 구성하려는 함수 타입, 인수 타입, 결과 타입을 모두 포함하는 패턴이 필요하다.</p>\n<p>이 세 가지 타입을 연결하는 명확한 패턴은 함수 적용(Function application) 또는 평가(Evaluation)이라고 불린다. 만약 함수 타입의 후보인 대상을 <code class=\"language-text\">z</code>라고 하고 인수 타입인 대상을 <code class=\"language-text\">a</code>라고 할 때, 적용(Application)은 이 쌍을 결과 타입인 대상 <code class=\"language-text\">b</code>로 매핑하는 행위이다. 즉, 우리에게는 총 세 가지 대상이 있으며, 이 중 인수 타입과 결과 타입 두 가지는 고정되어있는 것이다.</p>\n<p>우리는 매핑인 적용도 가지고 있다. 어떻게 하면 이 매핑을 이 패턴에 통합할 수 있을까? 만약 우리가 대상 내부를 들여다볼 수 있다면, 집합 <code class=\"language-text\">z</code>의 원소인 함수 <code class=\"language-text\">f</code>와 집합 <code class=\"language-text\">a</code>의 원소인 인수 <code class=\"language-text\">x</code>를 짝지어 집합 <code class=\"language-text\">b</code>의 원소인 <code class=\"language-text\">f x</code>로 매핑할 수 있게 된다.</p>\n<center>\n  <div style=\"max-width: 300px;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/8d0e9053a062a17fd43fa807d4d4d315/a847c/3.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB9nTOxq5VQUH/xAAZEAEAAwEBAAAAAAAAAAAAAAABAAIQESL/2gAIAQEAAQUCbessssvCO//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABcQAAMBAAAAAAAAAAAAAAAAAAAQISD/2gAIAQEABj8CcJn/xAAaEAEBAQADAQAAAAAAAAAAAAABABEQITFB/9oACAEBAAE/IWAfLEh2GgLKz3DTW8Qcf//aAAwDAQACAAMAAAAQRMc8/8QAFREBAQAAAAAAAAAAAAAAAAAAESD/2gAIAQMBAT8QI//EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAECAQE/EEY//8QAHBABAAICAwEAAAAAAAAAAAAAAQARIUEQMVGh/9oACAEBAAE/EKatjIfJ6GVM4TERG32h5ph0Z2MRBCl1ANqIVdHH/9k=&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"3\" title=\"3\" src=\"/static/8d0e9053a062a17fd43fa807d4d4d315/c08c5/3.jpg\" srcset=\"/static/8d0e9053a062a17fd43fa807d4d4d315/0913d/3.jpg 160w,\n/static/8d0e9053a062a17fd43fa807d4d4d315/cb69c/3.jpg 320w,\n/static/8d0e9053a062a17fd43fa807d4d4d315/c08c5/3.jpg 640w,\n/static/8d0e9053a062a17fd43fa807d4d4d315/a847c/3.jpg 846w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  </div>\n  <small>&#xD568;&#xC218; &#xC9D1;&#xD569; z&#xC5D0;&#xC11C; &#xD568;&#xC218; f&#xB97C; &#xC120;&#xD0DD;&#xD558;&#xACE0;, &#xC778;&#xC218; &#xD0C0;&#xC785; a&#xC758; &#xC9D1;&#xD569;&#xC5D0;&#xC11C; &#xD558;&#xB098;&#xC758; &#xC778;&#xC218; x&#xB97C; &#xC120;&#xD0DD;&#xD55C;&#xB2E4;.<br>&#xADF8;&#xB7EC;&#xBA74; &#xC774;&#xC81C; &#xC9D1;&#xD569; b&#xC5D0;&#xC11C; &#xC6D0;&#xC18C; f x&#xB97C; &#xC5BB;&#xC744; &#xC218; &#xC788;&#xAC8C;&#xB41C;&#xB2E4;.</small>\n  <br>\n  <br>\n</center>\n<p>그러나 이렇게 하나의 쌍인 <code class=\"language-text\">(f, x)</code>를 다루는 것보다는 함수 타입 <code class=\"language-text\">z</code>와 인수 타입 <code class=\"language-text\">a</code>의 전체적인 곱에 대해서 이야기하는 것이 더 일반화된 개념일 것이다. 곱 <code class=\"language-text\">z×a</code> 또한 하나의 대상이며, 이 대상에서 <code class=\"language-text\">b</code>로의 화살표인 우리의 적용 변형으로 <code class=\"language-text\">g</code>를 선택할 수 있다. <strong>Set</strong>에서는 <code class=\"language-text\">g</code>가 모든 쌍 <code class=\"language-text\">(f, x)</code>를 <code class=\"language-text\">f x</code>로 매핑하는 함수가 될 것이다.</p>\n<p>두 대상 <code class=\"language-text\">z</code>와 <code class=\"language-text\">a</code>의 곱이 사상 <code class=\"language-text\">g</code>에 의해 다른 대상 <code class=\"language-text\">b</code>로 연결되는, 이것이 바로 패턴이다.</p>\n<p>정말 이 패턴이 보편적 구성을 통해 함수 타입을 명확하게 정의할 수 있는 것일까? 사실 모든 카테고리에 대해서 생각해본다면 그렇지 않을 수도 있다. 하지만 우리가 지금 다루고자 하는 카테고리에 대해서는 충분하다.</p>\n<p>그렇다면 또 다른 질문을 해보자. 과연 우리는 곱을 먼저 정의하지 않고도 함수 대상을 정의할 수 있을까? 모든 쌍의 대상에 대해 곱이 없는 카테고리나 모든 쌍의 곱이 존재하지 않는 카테고리도 있지 않은가? 정답은 “아니다”이다. 곱 타입이 없다면 함수 타입도 존재할 수 없다. 이에 대한 내용은 추후 지수(Exponentials)에 대해 설명하며 다시 다루도록 하겠다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/4848023ae6caa38a3db6fb74b2138af9/c222a/4.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 57.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAexqolQ//8QAGhAAAgIDAAAAAAAAAAAAAAAAAAECERASIf/aAAgBAQABBQLZnROxxvP/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhMRBBYYH/2gAIAQEAAT8hUvxqXtXWowyJA3X5DBx//9oADAMBAAIAAwAAABDQz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQEBAAEFAAAAAAAAAAAAAAERADEQIVGBsf/aAAgBAQABPxAaGDpDmYQIT2XO1QZ3JcxCnhT5gAHATp//2Q==&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"4\" title=\"4\" src=\"/static/4848023ae6caa38a3db6fb74b2138af9/c08c5/4.jpg\" srcset=\"/static/4848023ae6caa38a3db6fb74b2138af9/0913d/4.jpg 160w,\n/static/4848023ae6caa38a3db6fb74b2138af9/cb69c/4.jpg 320w,\n/static/4848023ae6caa38a3db6fb74b2138af9/c08c5/4.jpg 640w,\n/static/4848023ae6caa38a3db6fb74b2138af9/c222a/4.jpg 794w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  <small>&#xC774; &#xADF8;&#xB9BC;&#xC774; &#xBC14;&#xB85C; &#xBCF4;&#xD3B8;&#xC801; &#xAD6C;&#xC131;&#xC758; &#xC2DC;&#xC791;&#xC810;&#xC778; &#xB300;&#xC0C1;&#xACFC; &#xC0AC;&#xC0C1;&#xC758; &#xD328;&#xD134;&#xC774;&#xB2E4;.</small>\n</center>\n<p>한번 보편적 구성에 대해 검토해보자. 우선 대상과 사상의 패턴에서부터 시작할 것이다. 물론 그저 대상과 사상의 패턴이라고만 하면 굉장히 많은 결과가 매칭될 것이기 때문에 이대로는 상당히 부정확한 쿼리라고 할 수 있다.</p>\n<p><strong>Set</strong>에서는 거의 모든 것이 서로 연결되어있다. 어떤 대상 <code class=\"language-text\">z</code>와 대상 <code class=\"language-text\">a</code>의 곱을 형성할 수도 있으며, 이 곱에서 <code class=\"language-text\">b</code>로의 함수도 존재할 수 있다. (단, <code class=\"language-text\">b</code>가 빈 집합일 경우는 제외한다.)</p>\n<p>이제 이 패턴의 결과들에 대한 순위를 매긴다는 비밀무기를 꺼내볼 차례이다. 일반적으로 후보 대상들 사이에는 이 구성을 어떤 방식이로든 분해할 수 있는 고유한 매핑이 있어야 한다.</p>\n<p>필자는 <code class=\"language-text\">z</code>와 <code class=\"language-text\">z×a</code>에서 <code class=\"language-text\">b</code>로 향하는 사상 <code class=\"language-text\">g</code>가 <code class=\"language-text\">z&#39;</code>와 이에 적용되는 사상 <code class=\"language-text\">g’</code>보다 우수하다고 결정할 것이다. 그리고 만약 이 결정이 참이라면 <code class=\"language-text\">z&#39;</code>에서 <code class=\"language-text\">z</code>로 향하는 유일한 사상 <code class=\"language-text\">h</code>이 존재해야 할 것이다. 그리고 이 사상은 <code class=\"language-text\">g&#39;</code>를 적용한 결과와 <code class=\"language-text\">g</code>를 적용한 결과가 동일하다는 것 또한 보장해야한다. (잘 이해되지 않는다면 아래 그림을 보면서 이 문장을 읽어보자.)</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/d7e642209529d3ac993be63af211510a/d4b53/5.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdqkqDCh/8QAGRABAAIDAAAAAAAAAAAAAAAAAQACEBEx/9oACAEBAAEFAnebQ4E//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFhAAAwAAAAAAAAAAAAAAAAAAACAx/9oACAEBAAY/Alp//8QAHBABAAEEAwAAAAAAAAAAAAAAAQAQESFRQWGB/9oACAEBAAE/IXc63BwUL35A2Z4iEf/aAAwDAQACAAMAAAAQow//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAWEQADAAAAAAAAAAAAAAAAAAABEDH/2gAIAQIBAT8QEX//xAAbEAEBAQEBAAMAAAAAAAAAAAABESEAMRCBof/aAAgBAQABPxCFKGQc+p6a34udZRC7+cmi+m3j0W7TPO//2Q==&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"5\" title=\"5\" src=\"/static/d7e642209529d3ac993be63af211510a/c08c5/5.jpg\" srcset=\"/static/d7e642209529d3ac993be63af211510a/0913d/5.jpg 160w,\n/static/d7e642209529d3ac993be63af211510a/cb69c/5.jpg 320w,\n/static/d7e642209529d3ac993be63af211510a/c08c5/5.jpg 640w,\n/static/d7e642209529d3ac993be63af211510a/d4b53/5.jpg 853w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  <small>&#xD568;&#xC218; &#xB300;&#xC0C1;&#xC5D0; &#xB300;&#xD55C; &#xD6C4;&#xBCF4;&#xB4E4; &#xAC04;&#xC758; &#xC21C;&#xC704;&#xB97C; &#xACB0;&#xC815;&#xD55C;&#xB2E4;.</small>\n</center>\n<p>여기가 조금 어려운 부분인데, 이게 바로 필자가 이 보편적 구성에 대한 정의를 계속 질질 끌고 있던 이유이다. 사상 <code class=\"language-text\">h :: z&#39;-&gt; z</code>가 주어졌을 때 우리는 <code class=\"language-text\">z’</code>와 <code class=\"language-text\">z</code>가 모두 <code class=\"language-text\">a</code>와 연결되어있는 다이어그램을 닫기를 원한다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>다이어그램을 닫는다는 이야기가 이해하기 어렵다면, 자료구조 그래프를 떠올려보면 된다. 여기서 <code class=\"language-text\">z’</code>와 <code class=\"language-text\">z</code>가 모두 연결되어있는 다이어그램을 닫고 싶다는 의미는, <code class=\"language-text\">z→a</code>, <code class=\"language-text\">z’→a</code>, <code class=\"language-text\">z’→z</code>처럼 연결되어있고 다른 대상들과는 이어지지 않은 그래프를 만들고 싶다는 의미이다.</p>\n</blockquote>\n<p>이를 위해 필요한 것은 <code class=\"language-text\">z’</code>에서 <code class=\"language-text\">z</code>로 향하는 매핑 <code class=\"language-text\">h</code>가 주어졌을 때, 이를 이용해서 <code class=\"language-text\">z&#39;×a</code>에서 <code class=\"language-text\">z×a</code>로의 매핑을 얻어내는 것이다. 앞서 <a href=\"/2024/04/02/category-theory-for-programmers-8-functoriality/\">곱의 함수적인 특징</a>에 대해 논의했었으니, 이제 이 과정에 대해 이해할 수 있을 것이다.</p>\n<p>곱 자체는 펑터, 정확하게는 엔도 이항 펑터이기 때문에 쌍에 대한 사상을 리프팅할 수 있다. 다른 말로 하면 우리는 대상의 곱 뿐만 아니라 사상의 곱도 정의할 수 있다는 것이다.</p>\n<p>이를 리프팅하기 위해 곱 <code class=\"language-text\">z&#39;×a</code>의 두 번째 구성 요소인 <code class=\"language-text\">a</code>에는 아무런 영향을 끼치지 않아야 하므로, <code class=\"language-text\">a</code>에 대한 항등사상인 <code class=\"language-text\">id</code>를 사용하여 사상의 쌍 <code class=\"language-text\">(h, id)</code>를 리프팅할 것이다.</p>\n<p><code class=\"language-text\">g’</code>를 <code class=\"language-text\">g</code>가 포함된 식으로 인수 분해하는 방법은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span>' <span class=\"token operator\">=</span> <span class=\"token hvariable\">g</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">h</span> × <span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>여기서의 핵심은 곱이 사상에 대해서 어떻게 작용하고 있는지를 보는 것이다.</p>\n<p>보편적 구성의 세 번째 파트는 보편적으로 가장 좋은 대상을 선택하는 것이었다. 필자는 이 대상을 <code class=\"language-text\">a ⇒ b</code>라고 부를 것이다. (참고로 이건 어떤 대상에 대한 상징적인 이름이며, Haskell 타입 클래스 제약과는 관련없는 네이밍이다. 추후에 조금 더 다양한 방법으로 이름을 지을 수 있는 방법에 대해 논의해보겠다.)</p>\n<p><code class=\"language-text\">a ⇒ b</code>라는 대상은 <code class=\"language-text\">(a ⇒ b) × a</code> 에서 <code class=\"language-text\">b</code>로 향하는 사상인 <code class=\"language-text\">eval</code>이라는 적용을 가지고 있다. 만약 다른 함수 대상 후보로부터 출발하는 사상 <code class=\"language-text\">g</code>가 <code class=\"language-text\">eval</code>을 포함한 식으로 분해되어 이 대상에 유일하게 매핑될 수 있다면, 대상 <code class=\"language-text\">a ⇒ b</code>가 가장 적합한 후보라고 할 수 있을 것이다.</p>\n<center>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 640px;\">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/36c0f5325a8dadf4bf7dcae580413720/edf8d/6.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 76.875%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe3UDVA//8QAGhAAAgIDAAAAAAAAAAAAAAAAAAECERIhMf/aAAgBAQABBQJ3a4SQo6xP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxABAAMAAAAAAAAAAAAAAAAAACAhQf/aAAgBAQAGPwKFtf/EABoQAAIDAQEAAAAAAAAAAAAAAAERACGREEH/2gAIAQEAAT8hsXUbghZeQ1GgT3U//9oADAMBAAIAAwAAABCzz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ECf/xAAbEAEBAQEBAAMAAAAAAAAAAAABEQAhQTGx4f/aAAgBAQABPxCg+JA+bmRSl9ehru8CwD9Zii7yM+sNTs3P/9k=&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"6\" title=\"6\" src=\"/static/36c0f5325a8dadf4bf7dcae580413720/c08c5/6.jpg\" srcset=\"/static/36c0f5325a8dadf4bf7dcae580413720/0913d/6.jpg 160w,\n/static/36c0f5325a8dadf4bf7dcae580413720/cb69c/6.jpg 320w,\n/static/36c0f5325a8dadf4bf7dcae580413720/c08c5/6.jpg 640w,\n/static/36c0f5325a8dadf4bf7dcae580413720/edf8d/6.jpg 929w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  <small>&#xC774;&#xAC83;&#xC774; &#xBCF4;&#xD3B8;&#xC801; &#xAD6C;&#xC131;&#xC744; &#xD1B5;&#xD55C; &#xD568;&#xC218; &#xB300;&#xC0C1;&#xC758; &#xC815;&#xC758;&#xC774;&#xB2E4;. &#xC704; &#xADF8;&#xB9BC;&#xACFC; &#xB3D9;&#xC77C;&#xD55C; &#xB2E4;&#xC774;&#xC5B4;&#xADF8;&#xB7A8;&#xC774;&#xC9C0;&#xB9CC; &#xC774;&#xC81C; &#xB300;&#xC0C1; a &#x21D2; b&#xAC00; &#xAC00;&#xC7A5; &#xBCF4;&#xD3B8;&#xC801;&#xC774;&#xAC8C; &#xB418;&#xC5C8;&#xB2E4;.</small>\n</center>\n<p>한번 정리해보자.</p>\n<p><code class=\"language-text\">a</code>에서 <code class=\"language-text\">b</code>로 향하는 <strong>함수 대상</strong>은 대상 <code class=\"language-text\">a ⇒ b</code>와 사상 <code class=\"language-text\">eval :: ((a ⇒ b) × a) -&gt; b</code> 으로 정의된다. 만약 임의의 다른 대상 <code class=\"language-text\">z × a</code>에서 <code class=\"language-text\">b</code>로 향하는 사상 <code class=\"language-text\">g :: z × a -&gt; b</code>가 주어진다면, <code class=\"language-text\">z</code>에서 <code class=\"language-text\">a ⇒ b</code>로 향하는 유일한 사상 <code class=\"language-text\">h :: z -&gt; (a ⇒ b)</code>이 존재해야하고, 최종적으로 <code class=\"language-text\">g</code>는 <code class=\"language-text\">eval</code>을 포함한 식으로 분해될 수 있어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">eval</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">h</span> × <span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>물론 모든 카테고리에서 반드시 임의의 대상의 쌍 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code>에 대해 대상 <code class=\"language-text\">a ⇒ b</code>가 반드시 존재할 것이라는 보장은 없다. 하지만 최소한 <strong>Set</strong>에서만큼은 항상 존재한다. 게다가 이 대상은 Set의 Hom 집합인 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Set(a,b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">t</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\">)</span></span></span></span>와도 동형이다.</p>\n<h2 id=\"92-커링currying\" style=\"position:relative;\">9.2 커링(Currying)<a href=\"#92-%EC%BB%A4%EB%A7%81currying\" aria-label=\"92 커링currying permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수 대상에 대한 후보를 다시 한번 살펴보자. 그러나 이번에는 사상 <code class=\"language-text\">g</code>를 두 변수 <code class=\"language-text\">z</code>와 <code class=\"language-text\">a</code>에 대한 함수로 생각해볼 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">z</span> × <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>대상의 곱으로부터 출발한 사상은 두 개의 변수를 가진 함수와 유사한 형태를 가지고 있다. <strong>Set</strong>에서 <code class=\"language-text\">g</code>는 집합 <code class=\"language-text\">z</code>과 집합 <code class=\"language-text\">a</code>에서 값을 하나씩 가져와 구성한 쌍에서 출발하게 될 것이다.</p>\n<p>그리고 함수 <code class=\"language-text\">g</code>가 가진 보편적인 속성에 따라 각각의 <code class=\"language-text\">g</code>에 대해 <code class=\"language-text\">z</code>를 함수 대상 <code class=\"language-text\">a ⇒ b</code>로 매핑하는 유일한 사상 <code class=\"language-text\">h</code> 또한 존재한다는 것을 떠올려볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">h</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">z</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><strong>Set</strong>에서는 단순히 <code class=\"language-text\">h</code>가 타입이 <code class=\"language-text\">z</code>인 변수를 하나 받아 <code class=\"language-text\">a</code>에서 <code class=\"language-text\">b</code>로 향하는 함수를 반환하는 함수임을 의미한다. 이러한 정의는 <code class=\"language-text\">h</code>를 고차함수(Higher ordered function)로 만든다.</p>\n<p>따라서 보편적 구성은 이변수 함수와 함수를 반환하는 일변수 함수 간의 일대일 대응을 설정한다. 이 대응은 커링(Currying)이라고 불리며, <code class=\"language-text\">h</code>는 <code class=\"language-text\">g</code>의 커링된(Curried) 버전이라고 한다.</p>\n<p>이처럼 어떤 <code class=\"language-text\">g</code>가 주어졌을때 유일한 <code class=\"language-text\">h</code>가 존재하고, 어떤 <code class=\"language-text\">h</code>가 주어질 때도 아래의 공식을 이용하여 이변수 함수인 <code class=\"language-text\">g</code>를 다시 생성할 수 있기 때문에 일대일 대응이라고 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">eval</span> ◦ <span class=\"token punctuation\">(</span><span class=\"token hvariable\">h</span> × <span class=\"token builtin\">id</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이때 함수 <code class=\"language-text\">g</code>는 <code class=\"language-text\">h</code>의 커링되지 않은(Uncurried) 버전이라고 할 수 있다. 사실 커링은 함수가 함수를 반환하는 Haskell의 구문만으로도 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이런 문법은 보통 아래와 같이 괄호가 제거된 시그너치를 통해 이변수 함수로 해석된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이러한 해석은 다인수 함수를 정의할 때 명확하게 확인해볼 수 있다. 예를 들어 아래와 같은 함수처럼 말이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">catstr</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">catstr</span> <span class=\"token hvariable\">s</span> <span class=\"token hvariable\">s</span>' <span class=\"token operator\">=</span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s</span>'</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 함수는 하나의 인수를 받아 다시 함수를 반환하는 형태로도 작성할 수 있다. 만약 람다로 표현하면 다음과 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">catstr</span>' <span class=\"token hvariable\">s</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">s</span>' <span class=\"token operator\">-></span> <span class=\"token hvariable\">s</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">s</span>'</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 두 정의는 동등하며, 두 정의 중 어떤 것을 사용하든 하나의 인수에 대해 부분 적용되어 아래와 같이 하나의 인수를 받은 함수를 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">greet</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">greet</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">catstr</span> <span class=\"token string\">\"Hello \"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>엄밀히 말하자면 이변수 함수는 곱 타입인 쌍을 받는 함수이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 두 개의 표현 간의 변환은 간단하다. 이미 예상했겠지만 이러한 변환을 수행하는 두 개의 고차함수는 <code class=\"language-text\">curry</code>와 <code class=\"language-text\">uncurry</code>로 불린다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">curry</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">curry</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token builtin\">uncurry</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">uncurry</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">curry</code>가 함수 대상의 보편적 구성을 위한 인수분해(factorization)라는 점에 주목하자. 이 점은 아래와 같은 형태로 다시 작성해보면 더 명확하게 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorizer</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">factorizer</span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">g</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>다시 한번 짚고 넘어가자면 <code class=\"language-text\">factorizer</code>라는 인수분해 행위는 후보로부터 분해 함수를 생성한다.</p>\n<p>C++과 같이 함수형 언어가 아닌 언어에서도 커링이 가능하기는 하지만 일이 조금 복잡해진다. C++에서의 다인수 함수는 Haskell에서 튜플을 받는 함수에 해당한다고 볼 수 있다. (여기서 더 혼란스러운 점은 C++에서 명시적으로 <code class=\"language-text\">std::tuple</code>을 받는 함수, 가변 인수 함수, 초기화 리스트를 받는 함수를 정의할 수 있다는 점이다.)</p>\n<p>C++ 함수를 부분 적용하려면 템플릿 <code class=\"language-text\">std::bind</code>를 사용하면 된다. 예를 들어 아래와 같이 두 개의 문자열을 받는 함수가 있다고 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>string <span class=\"token function\">catstr</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>string s1<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>string s2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> s1 <span class=\"token operator\">+</span> s2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>그럼 이 함수와 <code class=\"language-text\">std::bind</code>를 사용하여 하나의 문자열을 받는 함수를 정의해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-cpp line-numbers\"><code class=\"language-cpp\"><span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token operator\">::</span>placeholders<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">auto</span> greet <span class=\"token operator\">=</span> std<span class=\"token operator\">::</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>catstr<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Hello \"</span><span class=\"token punctuation\">,</span> _1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Haskell Curry\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Scala는 C++이나 Java에 비하면 함수형 프로그래밍에 더 가깝긴 하지만, 사실은 애매한 어딘가에 위치하고 있다. 만약 함수가 부분 적용되도록 작성하려면 아래처럼 여러 인수의 목록으로 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> catstr<span class=\"token punctuation\">(</span>s1<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>s2<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> s1 <span class=\"token operator\">+</span> s2</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>물론 이 코드는 이 함수가 확실히 부분 적용될 것이라는 것을 가정하기 때문에 프로그래머의 예지력에 의존하고 있지만 말이다.</p>\n<h2 id=\"93-지수exponentials\" style=\"position:relative;\">9.3 지수(Exponentials)<a href=\"#93-%EC%A7%80%EC%88%98exponentials\" aria-label=\"93 지수exponentials permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>수학 논문에서 함수 대상 또는 두 대상 <code class=\"language-text\">a</code>와 <code class=\"language-text\">b</code> 사이의 내부 Hom 대상은 종종 지수(Exponential)로 불리며 <code class=\"language-text\">ba</code>라고 표기된다. 처음에는 이 표기법이 조금 어색해보일 수 있지만, 함수와 곱의 관계를 생각해보면 그렇게 이상한 것도 아니다. 이미 내부 Hom 대상의 보편적 구성에서 곱이 필요하다는 것을 한 차례 확인했지만, 사실 이 둘 간의 연결은 더 심오하다.</p>\n<p>이 연결은 <code class=\"language-text\">Bool</code>, <code class=\"language-text\">Char</code>, <code class=\"language-text\">Int</code>, <code class=\"language-text\">Double</code>과 같이 유한한 값을 가지는 집합 간의 함수를 고려해볼 때 제대로 확인해볼 수 있다. 이러한 함수들은 원론적으로 완전히 메모아이징(Memoizing)될 수 있거나 데이터 구조로 변환되어 조회될 수도 있다. 이것이 바로 사상으로써의 함수와 대상으로써의 함수 타입 간 동등성의 본질이다.</p>\n<p>예를 들어 <code class=\"language-text\">Bool</code>에서의 순수 함수는 <code class=\"language-text\">False</code>에 해당하는 값과 <code class=\"language-text\">True</code>에 해당하는 값의 쌍에 의해 완전히 특정화된다. <code class=\"language-text\">Bool</code>에서 <code class=\"language-text\">Int</code>로 향하는 모든 함수의 집합은 모든 <code class=\"language-text\">Int</code> 쌍들의 집합이다. 이것은 곱 <code class=\"language-text\">Int × Int</code>, 조금 더 창의적으로 표기해보자면 <code class=\"language-text\">Int2</code>와 동일하다.</p>\n<p>다른 예시로 C++의 타입인 <code class=\"language-text\">char</code>를 한번 살펴보자. 이 타입은 총 256개의 값을 포함하고 있다.</p>\n<p>C++ 표준 라이브러리의 <code class=\"language-text\">isupper</code>, <code class=\"language-text\">isspace</code>와 같은 일부 함수들은 테이블 조회를 사용하여 구현되며, 이 테이블은 256개의 부울 값들의 튜플과 동등하다. 튜플은 곱 타입이므로 우리는 <code class=\"language-text\">bool × bool × bool × ... × bool</code>과 같은 256개의 부울의 곱을 떠올려볼 수 있다.</p>\n<p>그리고 우리는 이렇게 반복적인 곱이 곧 지수(Exponential)을 정의한다는 사실을 알고 있다. 만약 <code class=\"language-text\">bool</code>을 <code class=\"language-text\">char</code> 타입이 가진 값의 개수인 256번만큼 곱한다면, <code class=\"language-text\">bool</code>을 <code class=\"language-text\">char</code>만큼 거듭제곱한 것, 즉, <code class=\"language-text\">boolchar</code>를 얻을 수 있다.</p>\n<p>그렇다면 <code class=\"language-text\">bool</code>의 256 튜플로 정의된 타입에는 얼마나 많은 값이 존재하는 것일까? 정확하게 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>256</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{256}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">5</span><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span></span>개이다. 이는 <code class=\"language-text\">char</code>에서 <code class=\"language-text\">bool</code>로 향하는 서로 다른 함수들의 개수와도 동일하며, 각 함수는 고유한 256 튜플에 해당된다.</p>\n<p>비슷한 방식으로 <code class=\"language-text\">bool</code>에서 <code class=\"language-text\">char</code>로 향하는 함수의 개수도 계산해보면 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>25</mn><msup><mn>6</mn><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">256^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">5</span><span class=\"mord\"><span class=\"mord\">6</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>개라는 사실을 알 수 있다. 함수 타입에 대한 지수 표기법은 이런 의미를 가지고 있는 것이다.</p>\n<p>아마 우리는 <code class=\"language-text\">int</code>나 <code class=\"language-text\">double</code>에서 출발하는 함수를 모두 메모아이즈하고 싶어하지는 않을 것이다. 하지만 비록 실용적이지 않더라도 함수와 데이터 타입 사이의 동등성은 명확히 존재한다.</p>\n<p>그리고 리스트, 트리, 문자열과 같은 무한한 타입도 있다. 이러한 타입에서 출발하는 함수를 메모아이즈하기 위해서는 무한한 저장 공간을 필요로 한다.</p>\n<p>그러나 Haskell은 게으른 언어이므로, 게으르게 평가되는 무한한 데이터 구조와 함수 사이의 경계는 모호하게 다가온다. 이러한 함수와 데이터 간의 쌍대성은 함수 타입을 카테고리론적 지수 대상과 동일시 할 수 있다는 것을 설명한다. 이러한 특성은 우리가 가진 데이터에 대한 개념과도 일치하기 때문에 Haskell에서는 함수를 데이터처럼 취급할 수 있다.</p>\n<h2 id=\"94-데카르트-닫힌-카테고리cartesian-closed-categories\" style=\"position:relative;\">9.4 데카르트 닫힌 카테고리(Cartesian Closed Categories)<a href=\"#94-%EB%8D%B0%EC%B9%B4%EB%A5%B4%ED%8A%B8-%EB%8B%AB%ED%9E%8C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACcartesian-closed-categories\" aria-label=\"94 데카르트 닫힌 카테고리cartesian closed categories permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>물론 필자는 계속 집합의 카테고리를 타입과 함수의 모델로 사용할 것이지만, 이런 목적으로 사용할 수 있는 더 큰 카테고리 패밀리가 있다는 것을 언급하는 것은 충분히 가치가 있을 것 같다. 이런 카테고리는 데카르트 닫힌 카테고리(Cartesian closed categories)라고 하며, <strong>Set</strong>은 그저 이 카테고리 중 하나의 예일 뿐이다.</p>\n<p>데카르트 닫힌 카테고리는 아래 세 가지를 반드시 포함하고 있어야 한다.</p>\n<ol>\n<li>종결 대상</li>\n<li>어떤 두 대상의 곱</li>\n<li>어떤 두 대상의 지수</li>\n</ol>\n<p>지수를 무한히 많은 횟수로 반복되는 곱이라고 간주한다면, 데카르트 닫힌 카테고리는 임의의 항수를 지원하는 것이라고 생각할 수 있다. 특히 종결 대상은 곱의 항등원(0)인 대상의 곱 또는 대상의 항등원(0) 승이라고 볼 수 있다.</p>\n<p>컴퓨터 과학의 관점에서 데카르트 닫힌 카테고리들이 흥미로운 이유는 이 카테고리들이 간단하게 타이핑된 람다 미적분법의 모델을 제공하고 있기 때문이다. 이 모델은 타입을 사용하는 모든 프로그래밍 언어의 기초를 형성한다.</p>\n<p>종결 대상과 곱 연산에는 각각 초기 대상과 합 연산이라는 쌍대(Dual)가 존재한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">a × (b + c) = a × b + a × c\n(b + c) × a = b × a + c × a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이 두 요소를 지원하고 곱이 합을 통해 분배될 수 있는 데카르트 닫힌 카테고리를 이중 데카르트 닫힌 카테고리(Bicartesian closed category)라고 한다. 다음 섹션에서 보겠지만 우리가 계속 다뤄온 <strong>Set</strong>이 대표적인 이중 데카르트 닫힌 카테고리이며, 이 카테고리는 몇 가지 흥미로운 특성을 가지고 있다.</p>\n<h2 id=\"95-지수와-대수적-자료형exponentials-and-algebraic-data-types\" style=\"position:relative;\">9.5 지수와 대수적 자료형(Exponentials and Algebraic Data Types)<a href=\"#95-%EC%A7%80%EC%88%98%EC%99%80-%EB%8C%80%EC%88%98%EC%A0%81-%EC%9E%90%EB%A3%8C%ED%98%95exponentials-and-algebraic-data-types\" aria-label=\"95 지수와 대수적 자료형exponentials and algebraic data types permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수 타입을 지수로 해석하는 것은 대수적 자료형의 체계에 아주 잘 들어맞는다. 실제로 고등학교에서 배우는 대수학에서 나오는 숫자 0과 1, 합, 곱, 그리고 지수와 관련된 기본적인 항등식은 각각 초기 대상, 종결 대상, 합집합, 곱집합 그리고 지수에 대해 거의 그대로 적용된다는 것을 볼 수 있다.</p>\n<p>우리는 아직 이 성질을 제대로 증명할만한 수반(Adjunction)이나 요네다 보조정리같은 도구를 가지고 있지는 않지만, 그럼에도 불구하고 독자 여러분께 직관을 제공하기 위해 일단 쭉 설명해보겠다.</p>\n<h3 id=\"951-0승\" style=\"position:relative;\">9.5.1 0승<a href=\"#951-0%EC%8A%B9\" aria-label=\"951 0승 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">a^0 = 1 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></span>\n<p>카테고리적 해석에서 우리는 0을 초기 대상으로, 1을 종결 대상으로, 그리고 등식을 동형사상으로 대체한다. 여기서 지수는 내부 Hom 대상을 의미하기 때문에 결국 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">a^0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span>이라는 식은 초기 대상에서 임의의 대상 <code class=\"language-text\">a</code>로 향하는 사상의 집합을 나타낸다. 초기 대상의 정의에 따라 이런 사상은 정확히 하나만 존재할 수 있으므로 Hom 집합 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C(0,a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mclose\">)</span></span></span></span>는 단일 원소 집합이다.</p>\n<p>단일 원소 집합은 <strong>Set</strong>에서의 종결 대상이므로, 이 항등식은 <strong>Set</strong>에서 쉽게 성립할 수 있다. 여기서 중요한 것은 이 항등식이 이중 데카르트 닫힌 카테고리의 모든 경우에 대해서 성립한다는 것이다.</p>\n<p>Haskell에서는 0을 <code class=\"language-text\">Void</code>로, 1을 유닛 타입인 <code class=\"language-text\">()</code>으로 대체한다. 결국 필자가 앞에서 했던 주장은 <code class=\"language-text\">Void</code>에서 임의의 타입 <code class=\"language-text\">a</code>로 향하는 함수의 집합이 유닛 타입과 동등하다는 것이다. 다시 말하자면 <code class=\"language-text\">Void -&gt; a</code> 함수는 하나뿐이라는 것이다. 그리고 우리는 이미 이 함수를 예전에 본 적이 있다. 바로 <code class=\"language-text\">absurd</code> 함수이다.</p>\n<p>그러나 이것을 현실에 구현하기는 약간 까다롭다. 이유는 크게 두 가지인데, 첫째로 Haskell에서는 실제로 어떤 값도 속하지 않는 타입이라는게 존재하지 않는다. 모든 타입은 “끝나지 않는 계산의 결과” 또는 Bottom(<code class=\"language-text\">_|_</code>)을 포함하기 때문이다.</p>\n<p>두번째 이유는 <code class=\"language-text\">absurd</code>에는 어떤 값도 전달할 수 없기 때문에 누가 무슨 짓을 하던 결국 아무도 실행시킬 수 없다는 점이다. 결국 이 함수의 구현은 근본적으로 모두 동등하다는 것이다. 그렇다고 해서 만약 영원히 끝나지 않는 계산을 전달한다면 이 함수는 결코 반환이라는 행위까지 도달하지 못할 것이다.</p>\n<h3 id=\"952-1의-지수\" style=\"position:relative;\">9.5.2 1의 지수<a href=\"#952-1%EC%9D%98-%EC%A7%80%EC%88%98\" aria-label=\"952 1의 지수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>1</mn><mi>a</mi></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1^a = 1\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7143919999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">a</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></span>\n<p>위 식은 <strong>Set</strong>에서 해석될 때 모든 대상에서 종결 대상으로 향하는 고유한 사상이 존재한다는 종결 대상에 대한 정의를 다시 한번 표현하고 있다. 일반적으로 <code class=\"language-text\">a</code>에서 종결 대상으로 향하는 내부 Hom 대상은 종결 대상과 동형이다.</p>\n<p>Haskell에서 임의의 타입 <code class=\"language-text\">a</code>에서 유닛으로 향하는 함수는 <code class=\"language-text\">a -&gt; ()</code> 단 하나 뿐이다. 우리는 이 함수를 <code class=\"language-text\">unit</code>이라고 부른다는 것을 이미 알고 있다. 이 함수는 <code class=\"language-text\">()</code>에 부분 적용된 <code class=\"language-text\">const</code> 함수로 생각할 수도 있다.</p>\n<h3 id=\"953-1승\" style=\"position:relative;\">9.5.3 1승<a href=\"#953-1%EC%8A%B9\" aria-label=\"953 1승 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mn>1</mn></msup><mo>=</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a^1 = a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span></span>\n<p>위 식은 종결 대상으로부터 출발하는 사상은 대상 <code class=\"language-text\">a</code>의 원소를 선택하는데 사용될 수 있다는 것을 다시 표현한 것이다. 이러한 사상들의 집합은 대상 자체와 동형이다. <strong>Set</strong>, 그리고 Haskell에서는 집합 <code class=\"language-text\">a</code>의 원소들과 해당 원소들을 선택하는 함수들인 <code class=\"language-text\">() -&gt; a</code>가 동형이라는 것이다.</p>\n<h3 id=\"954-지수의-합\" style=\"position:relative;\">9.5.4 지수의 합<a href=\"#954-%EC%A7%80%EC%88%98%EC%9D%98-%ED%95%A9\" aria-label=\"954 지수의 합 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mrow><mi>b</mi><mo>+</mo><mi>c</mi></mrow></msup><mo>=</mo><msup><mi>a</mi><mi>b</mi></msup><mo>×</mo><msup><mi>a</mi><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">a^{b+c} = a^b ×a^c\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8991079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">b</span><span class=\"mbin mtight\">+</span><span class=\"mord mathdefault mtight\">c</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9824379999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">b</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7143919999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span>\n<p>카테고리론적으로 위 식은 대상의 두 지수의 합이 각 지수를 가진 대상들의 곱과 동형이라는 것을 의미한다.</p>\n<p>이 대수적 동형성을 Haskell에서 다루게 되면 매우 실용적인 해석을 가져다준다. 이는 두 타입의 합으로부터 출발하는 함수가 각각의 타입으로부터 출발하는 함수의 쌍과 동등하다는 것을 의미하기 때문이다.</p>\n<p>이 개념이 바로 우리가 합에 대한 함수를 정의할 때 사용하는 문법의 근원이다. 우리는 합을 의미하는 <code class=\"language-text\">Either</code>를 정의할 때 <code class=\"language-text\">case</code> 문을 사용하여 함수를 정의하지 않고, 각각의 타입 생성자를 따로 처리하는 두 개, 혹은 그 이상의 함수로 나눈다.</p>\n<p>예를 들어 합 타입(<code class=\"language-text\">Either Int Double</code>)를 한번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Either</span> <span class=\"token constant\">Int</span> <span class=\"token constant\">Double</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 경우 <code class=\"language-text\">Either</code>는 각각 <code class=\"language-text\">Int</code>와 <code class=\"language-text\">Double</code>에 대한 함수의 쌍으로 정의될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Left</span> <span class=\"token hvariable\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token keyword\">then</span> <span class=\"token string\">\"Negative int\"</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"Positive int\"</span>\n<span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Right</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.0</span> <span class=\"token keyword\">then</span> <span class=\"token string\">\"Negative double\"</span> <span class=\"token keyword\">else</span> <span class=\"token string\">\"Positive double\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<h3 id=\"955-지수의-지수\" style=\"position:relative;\">9.5.5 지수의 지수<a href=\"#955-%EC%A7%80%EC%88%98%EC%9D%98-%EC%A7%80%EC%88%98\" aria-label=\"955 지수의 지수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>a</mi><mi>b</mi></msup><msup><mo stretchy=\"false\">)</mo><mi>c</mi></msup><mo>=</mo><msup><mi>a</mi><mrow><mi>b</mi><mo>×</mo><mi>c</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">(a^b)^c = a^{b×c}\t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.149108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">b</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8991079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">b</span><span class=\"mbin mtight\">×</span><span class=\"mord mathdefault mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span></span>\n<p>위 식은 지수 대상들에 대한 커링(Currying)을 표현하고 있다. 함수가 함수를 반환하는 것은 곱에서 출발하는 함수, 즉 이변수 함수와 동등하다.</p>\n<h3 id=\"956-곱의-지수\" style=\"position:relative;\">9.5.6 곱의 지수<a href=\"#956-%EA%B3%B1%EC%9D%98-%EC%A7%80%EC%88%98\" aria-label=\"956 곱의 지수 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><msup><mo stretchy=\"false\">)</mo><mi>c</mi></msup><mo>=</mo><msup><mi>a</mi><mi>c</mi></msup><mo>×</mo><msup><mi>b</mi><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">(a×b)^c =a^c × b^c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7977219999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">c</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7143919999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span>\n<p>Haskell에서 쌍을 반환하는 함수는 각 쌍의 요소 하나를 생성하는 두 함수의 쌍과 동등하다.</p>\n<p>이처럼 고등학교에서 배우는 대수학의 간단한 항등식들이 카테고리 이론으로 확장되어 함수형 프로그래밍에서 실용적으로 적용될 수 있다는 것은 굉장히 놀라운 일이다.</p>\n<h2 id=\"96-커리-하워드-동형사상curry-howard-isomorphism\" style=\"position:relative;\">9.6 커리-하워드 동형사상(Curry-Howard Isomorphism)<a href=\"#96-%EC%BB%A4%EB%A6%AC-%ED%95%98%EC%9B%8C%EB%93%9C-%EB%8F%99%ED%98%95%EC%82%AC%EC%83%81curry-howard-isomorphism\" aria-label=\"96 커리 하워드 동형사상curry howard isomorphism permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>필자는 이미 논리와 대수적 자료형 간의 대응 관계에 대해 언급한 적이 있다. <code class=\"language-text\">Void</code> 타입과 유닛 타입(<code class=\"language-text\">()</code>)은 각각 거짓과 참에 해당하며, 곱 타입과 합 타입은 논리곱(AND)과 논리합(OR)에 해당한다. 이 체계에서 함수 타입은 논리적 함의(<code class=\"language-text\">⇒</code>)에 해당한다. 다시 말해 타입 <code class=\"language-text\">a -&gt; b</code>는 “만약 <code class=\"language-text\">a</code>라면 <code class=\"language-text\">b</code>이다”라고 읽을 수 있다.</p>\n<p>커리-하워드 동형사상에 따르면 모든 타입은 참 또는 거짓일 수 있는 명제, 즉 진술이나 판단으로 해석될 수 있다. 해당 타입이 존재하면 그 명제는 참으로 간주되고, 존재하지 않으면 거짓으로 간주된다. 특히 논리적 함의가 참이라는 것은 그에 해당하는 함수 타입이 존재한다는 것을 의미하며, 그 타입의 함수가 실제로 존재한다는 것을 의미한다.</p>\n<p>따라서 함수의 구현 자체가 정리의 증명이 되는 것이며, 우리가 프로그램을 작성하는 것은 정리를 증명하는 것과 동등하다. 한번 몇 가지 예시를 살펴보자.</p>\n<p>함수 대상의 정의에서 소개했던 <code class=\"language-text\">eval</code> 함수를 살펴보도록 하겠다. <code class=\"language-text\">eval</code>의 시그니처는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">eval</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 함수는 함수와 그 인자로 구성된 쌍을 받아 적절한 타입의 결과를 반환한다. 즉 위 코드는 사상에 대한 Haskell에서의 구현이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">eval</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> ⇒ <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> × <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 표현은 함수 타입 <code class=\"language-text\">a ⇒ b</code> (또는 지수 대상 <code class=\"language-text\">ba</code>)를 정의한다. 이 서명을 커리-하워드 동형사상을 사용하여 논리적 술어로 번역해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">((a ⇒ b) ∧ a) ⇒ b</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이 명제는 만약 <code class=\"language-text\">b</code>가 <code class=\"language-text\">a</code>로부터 도출되는 것이 참이고, <code class=\"language-text\">a</code> 또한 참이라면, <code class=\"language-text\">b</code> 또한 반드시 참이어야 한다고 읽을 수 있다. 이는 직관적으로 완벽한 의미를 가지고 있으며 고대부터 전건 긍정(<em>modus ponens)</em>라고 불려왔다. 이제 다음 함수를 구현함으로써 이 정리를 증명할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">eval</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n<span class=\"token hvariable\">eval</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">a</code>를 받아서 <code class=\"language-text\">b</code>를 반환하는 함수 <code class=\"language-text\">f</code>와 타입 <code class=\"language-text\">a</code>의 구체적인 값 <code class=\"language-text\">x</code>로 구성된 쌍을 제공한다면, 함수 <code class=\"language-text\">f</code>를 <code class=\"language-text\">x</code>에 적용함으로써 타입 b의 구체적인 값을 생성할 수 있다.</p>\n<p>즉, 필자는 이 함수를 구현함으로써 타입 <code class=\"language-text\">((a -&gt; b), a) -&gt; b</code>가 실제로 존재한다는 것을 보였다. 따라서 우리의 논리에서 전건 긍정(modus ponens)는 참이다.</p>\n<p>그렇다면 명백하게 거짓인 술어는 어떨까? 예를 들어 “만약 <code class=\"language-text\">a</code> 또는 <code class=\"language-text\">b</code>가 참이면, <code class=\"language-text\">a</code>는 반드시 참이어야 한다”와 같은 명제가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">a ∨ b ⇒ a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>이는 명백하게 잘못된 명제이다. 왜냐하면 이 명제대로라면 <code class=\"language-text\">a</code>가 거짓이고  <code class=\"language-text\">b</code>가 참인 상황도 존재할 수 있기 때문이다. 이 술어를 커리-하워드 동형사상을 사용하여 함수 시그니처로 매핑하면 다음과 같은 결과를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>사실 아무리 시도를 하더라도 이 함수는 절대 구현할 수 없다. <code class=\"language-text\">Right</code> 값으로 호출되었을 때는 <code class=\"language-text\">a</code> 타입의 값을 생성할 수 없기 때문이다. (우리가 순수 함수에 대해서만 이야기하고 있다는 점을 기억하자)</p>\n<p>이제 드디어 <code class=\"language-text\">absurd</code> 함수의 진짜 의미에 대해 이야기할 때가 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">absurd</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Void</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>만약 <code class=\"language-text\">Void</code>가 “거짓”이라고 번역된다고 생각해보면 우리는 아래와 같은 술어를 얻을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">false ⇒ a</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>거짓에서는 어떤 것이든 따라올 수 있다(<em>ex falso quodlibet</em>). 여기 Haskell에서 이 명제(함수)를 증명(구현)할 수 있는 한 가지 예시가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token hvariable\">absurd</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Void</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">absurd</span> <span class=\"token hvariable\">a</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Haskell에서 <code class=\"language-text\">Void</code>는 다음과 같이 정의된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-haskell line-numbers\"><code class=\"language-haskell\"><span class=\"token keyword\">newtype</span> <span class=\"token constant\">Void</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Void</span> <span class=\"token constant\">Void</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"language-text\">Void</code> 타입은 까다로운 녀석이다. 이 정의는 <code class=\"language-text\">Void</code> 타입의 값을 생성하기 위해서는 <code class=\"language-text\">Void</code> 타입의 값이 필요하다는 의미를 가지고 있기 때문에 절대 값을 구성할 수 없게 만든다. 결국 <code class=\"language-text\">Void</code> 타입의 값이라는 것은 존재할 수가 없으므로 <code class=\"language-text\">absurd</code> 함수는 절대 호출될 수가 없는 것이다.</p>\n<blockquote>\n<p>💡 <strong>역주</strong></p>\n<p>“거짓에서는 어떤 것이든 따라올 수 있다”라는 뜻의 <em>ex falso quodlibet</em>는 거짓 명제로부터는 어떤 명제라도 유도될 수 있다는 것을 의미하며, 이는 논리학에서 매우 중요한 원칙 중 하나이다.</p>\n<p>쉽게 말하자면 거짓인 전제가 주어진다면, 그 전제로부터 나오는 어떠한 결론도 모두 정당화될 수 있다는 것이다.이와 마찬가지로 <code class=\"language-text\">absurd</code> 함수는 절대 생성될 수 없는 값의 타입인 <code class=\"language-text\">Void</code>를 인자로 받아 임의의 타입 <code class=\"language-text\">a</code>를 반환할 수 있다고 선언된다.</p>\n<p>즉, 거짓으로부터 출발했으니 어떤 타입을 반환하더라도 논리가 깨지지는 않는 것이다.참고로 <code class=\"language-text\">absurd</code> 함수는 절대 호출될 수가 없기 때문에 실제로 사용될 수는 없고, 순수하게 프로그래밍 언어의 타입 시스템의 원리를 설명하기 위한 이론적인 목적으로만 사용된다.</p>\n</blockquote>\n<p>물론 이 예시들이 모두 흥미롭기는 하지만, 도대체 커리-하워드 동형사상이 우리에게 어떤 실용적인 혜택을 가져다준다는 것일까? 아마도 일상적인 프로그래밍에서는 아니겠지만, Agda나 Coq와 같은 프로그래밍 언어들은 정리를 증명하기 위해 커리-하워드 동형사상을 활용한다.</p>\n<p>컴퓨터는 수학자들이 그들의 일을 하는데 도움을 주는 것뿐만 아니라, 수학의 근본을 혁신하고 있다. 이러한 분야에서 가장 최근에 뜨거운 감자로 떠오르는 연구는 호모토피 타입 이론이라고 하며, 타입 이론의 발전에 큰 기여를 하고있다. 이 이론은 Boolean, Integer, 곱과 쌍대곱, 함수 타입 등으로 가득 차 있다. 그리고 이러한 이론은 Coq와 Agda에서 공식적으로 도입되고 있다.</p>\n<p>이처럼 컴퓨터는 여러 방면에서 세상을 혁신하고 있다.</p>","tableOfContents":"<ul>\n<li><a href=\"#91-%EB%B3%B4%ED%8E%B8%EC%A0%81-%EA%B5%AC%EC%84%B1universal-construction\">9.1 보편적 구성(Universal Construction)</a></li>\n<li><a href=\"#92-%EC%BB%A4%EB%A7%81currying\">9.2 커링(Currying)</a></li>\n<li><a href=\"#93-%EC%A7%80%EC%88%98exponentials\">9.3 지수(Exponentials)</a></li>\n<li><a href=\"#94-%EB%8D%B0%EC%B9%B4%EB%A5%B4%ED%8A%B8-%EB%8B%AB%ED%9E%8C-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%ACcartesian-closed-categories\">9.4 데카르트 닫힌 카테고리(Cartesian Closed Categories)</a></li>\n<li>\n<p><a href=\"#95-%EC%A7%80%EC%88%98%EC%99%80-%EB%8C%80%EC%88%98%EC%A0%81-%EC%9E%90%EB%A3%8C%ED%98%95exponentials-and-algebraic-data-types\">9.5 지수와 대수적 자료형(Exponentials and Algebraic Data Types)</a></p>\n<ul>\n<li><a href=\"#951-0%EC%8A%B9\">9.5.1 0승</a></li>\n<li><a href=\"#952-1%EC%9D%98-%EC%A7%80%EC%88%98\">9.5.2 1의 지수</a></li>\n<li><a href=\"#953-1%EC%8A%B9\">9.5.3 1승</a></li>\n<li><a href=\"#954-%EC%A7%80%EC%88%98%EC%9D%98-%ED%95%A9\">9.5.4 지수의 합</a></li>\n<li><a href=\"#955-%EC%A7%80%EC%88%98%EC%9D%98-%EC%A7%80%EC%88%98\">9.5.5 지수의 지수</a></li>\n<li><a href=\"#956-%EA%B3%B1%EC%9D%98-%EC%A7%80%EC%88%98\">9.5.6 곱의 지수</a></li>\n</ul>\n</li>\n<li><a href=\"#96-%EC%BB%A4%EB%A6%AC-%ED%95%98%EC%9B%8C%EB%93%9C-%EB%8F%99%ED%98%95%EC%82%AC%EC%83%81curry-howard-isomorphism\">9.6 커리-하워드 동형사상(Curry-Howard Isomorphism)</a></li>\n</ul>","fields":{"lang":"ko","slug":"20240418-category-theory-for-programmers-9-function-types"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 9. 함수 타입","date":"2024-04-18","categories":["프로그래밍"],"tags":["함수형 프로그래밍","모나드","카테고리 이론","Functional Programming","Monad","Category Theory"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAdiaRQH/xAAWEAADAAAAAAAAAAAAAAAAAAAAASD/2gAIAQEAAQUCFP8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGBAAAwEBAAAAAAAAAAAAAAAAARARAFH/2gAIAQEAAT8hOO2uDi//2gAMAwEAAgADAAAAEMsv/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxAAAgMAAwAAAAAAAAAAAAAAAAERIUExcZH/2gAIAQEAAT8Qa9G8xQ4vSR2rvsgahPBH/9k=","aspectRatio":1.7751479289940828,"src":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/47498/thumbnail.jpg","srcSet":"/static/eea67acfacfc20db2c9d3f6b3a3a786d/9dc27/thumbnail.jpg 300w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/4fe8c/thumbnail.jpg 600w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/47498/thumbnail.jpg 1200w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/52258/thumbnail.jpg 1800w,\n/static/eea67acfacfc20db2c9d3f6b3a3a786d/d8255/thumbnail.jpg 1920w","sizes":"(max-width: 1200px) 100vw, 1200px"}}}}},"allMarkdownRemark":{"edges":[]}},"pageContext":{"slug":"20240418-category-theory-for-programmers-9-function-types","previous":{"fields":{"slug":"20240402-category-theory-for-programmers-8-functoriality","path":"/2024/04/02/category-theory-for-programmers-8-functoriality/","lang":"ko","postGroup":"20240402-category-theory-for-programmers-8-functoriality"},"frontmatter":{"title":"[번역] 프로그래머를 위한 카테고리 이론 - 8. 펑터의 특성"}},"next":null,"lang":"ko","postGroup":"20240418-category-theory-for-programmers-9-function-types"}}}